{"id": "48c006e2-e872-423a-97d3-54605cc1fbe2", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive Metropolis Sampling for exploration\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * 2.4**2 / self.dim\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybridized Differential Evolution with Adaptive Metropolis Sampling for robust exploration and exploitation in black box optimization.", "configspace": "", "generation": 0, "fitness": 0.1691451231826269, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": null, "metadata": {"aucs": [0.3390733874659857, 0.35904574103416065, 0.33222271122129166, 0.3668519611401668, 0.3873792691889292, 0.3649773617083827, 0.36830358753044934, 0.3633660896067882, 0.34731785515771985, 0.11847849953812417, 0.09445352175594945, 0.11159407178559888, 0.11751005191146591, 0.12321412193979653, 0.10978258716795175, 0.11126513567185903, 0.09995306892857736, 0.11870057567128656, 0.07137753149697823, 0.06864238075415374, 0.06926374833573645, 0.07421586833486493, 0.080279526440446, 0.11898836007742852, 0.0808109107374132, 0.07466733857324526, 0.07570472479161527, 0.07021428284486664, 0.06101166144676973, 0.08194180748023194, 0.06873598302715689, 0.05723162945120497, 0.06365255378056422, 0.06062035366420149, 0.06090890890335865, 0.06488166169494214, 0.865255568997675, 0.9151285663228983, 0.9209167396262112, 0.8899111154953092, 0.8954610245393511, 0.7913749216892212, 0.8730728077283371, 0.9635520634603376, 0.8565155691482997, 0.16224134679683633, 0.15607618732156714, 0.14552146866401838, 0.1520575163300999, 0.13682425393403397, 0.14761825356311253, 0.1733015326981746, 0.1543626963057253, 0.15637025179318353, 0.217323856264646, 0.21890385695261383, 0.20867451524068736, 0.24043955479966062, 0.2352787205435828, 0.22720685151659858, 0.2518146631768813, 0.22088476006481284, 0.22619181799160337, 0.09239057369391757, 0.09275928903020048, 0.10155780368973577, 0.0908227051132855, 0.10834529158659079, 0.10465868028980818, 0.08745290606444855, 0.08529551627786436, 0.09836780685260604, 0.0871719774721128, 0.102140467901496, 0.1285995796128827, 0.08813063498181473, 0.08041830232530334, 0.08509136849015353, 0.0670364441815916, 0.0731206304675105, 0.08099151717376185, 0.013488103409918795, 0.01151259934103166, 0.02433248297222057, 0.028382049215075145, 0.01446552696102732, 0.002442520871933862, 0.02049095346643548, 0.018286763328700717, 0.013813537021335698, 0.09163811862241567, 0.1131149933953366, 0.11816595608275804, 0.11634816593056929, 0.08524534979394649, 0.09802964350909027, 0.1307979224466933, 0.15145583760812975, 0.12494588813529117, 0.0014796912960737263, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.059415965275021465, 0.06195018901008953, 0.07284883227846095, 0.07451605371853842, 0.05115445725484902, 0.06394982532857307, 0.067737837663145, 0.07789617995691844, 0.06432304365375474, 0.3325640548968761, 0.32579781719670886, 0.3165804661546555, 0.3566609638041597, 0.3305525750700803, 0.3298981717811069, 0.3323393179810086, 0.3130248649110503, 0.3073843829874656, 0.08984746947920863, 0.07658302508784987, 0.06978145122577029, 0.07899119086748074, 0.06707852518327018, 0.06984864126699808, 0.07047812707854262, 0.06258692464751625, 0.08287479846370605, 0.140873436448247, 0.12507227100164675, 0.12625219967495083, 0.13617280653503072, 0.1481823604262712, 0.120586039158741, 0.1296581066015482, 0.12012973611801048, 0.1376852003417942, 0.21252836662087615, 0.2027333230768632, 0.20627463788246247, 0.1981537920049774, 0.19568188915806295, 0.19734639769700146, 0.1976836588287021, 0.23286014618173845, 0.23420742828905117, 0.13405067377546787, 0.14782231833934478, 0.15574246013341309, 0.14872968155314925, 0.14458506020411455, 0.17689233948013683, 0.16645351756021431, 0.1621685547885683, 0.1564013353532857, 0.1679671111596388, 0.17229446931908843, 0.15584965752825575, 0.16249955161246266, 0.18848667059621227, 0.17114843682139602, 0.17292132542637006, 0.1706683413099761, 0.16522447883203184, 0.1530375369770165, 0.17204111122144228, 0.17697035251944015, 0.1628477936537247, 0.15925076597829468, 0.1681653428952472, 0.1616468630065203, 0.16038888881617464, 0.16952456713172082, 0.15203555407616676, 0.15898455427648917, 0.15915003500305103, 0.1650231784220434, 0.15051244933498076, 0.14931521000658143, 0.1356936885291551, 0.15212439510704368, 0.1461959607165607, 0.18175161216642188, 0.18046526186243805, 0.1592627517203402, 0.14736871784689953, 0.13325263647178287, 0.16878340471813502, 0.18731418465432226, 0.1751244755502137, 0.19524674763469196, 0.2016396402632461, 0.17917222669989918, 0.18494126053365656, 0.1757130849618148, 0.1837218667454772, 0.18343900040839567, 0.17952779283269427, 0.17934465698938762, 0.1788810807504918, 0.05648543926208638, 0.05805814958241917, 0.05817486083270362, 0.058849009971034705, 0.059602597107500155, 0.07346200599526542, 0.05728884374679277, 0.05625347089938659, 0.06815373766814081]}, "mutation_prompt": null}
{"id": "00bc9263-355b-49f3-9a5b-bd9df40854ea", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                # Mutation with stochastic scaling factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive Metropolis Sampling for exploration\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * 2.4**2 / self.dim\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Enhanced Differential Evolution with Stochastic Scaling Factor for improved convergence in black box optimization.", "configspace": "", "generation": 1, "fitness": 0.17158446101236252, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "48c006e2-e872-423a-97d3-54605cc1fbe2", "metadata": {"aucs": [0.37598100480326446, 0.3555542136873212, 0.33404948206394136, 0.37873559618269537, 0.39227861854479307, 0.43031616151904195, 0.38635433841586564, 0.3855817505269531, 0.3497107587719678, 0.11623624761688367, 0.10989177266793737, 0.11363731597182813, 0.10615122279557088, 0.11054899961207554, 0.115523132382091, 0.11921862722330312, 0.11247799859887819, 0.11948553249253513, 0.07975785118697365, 0.09476379613713837, 0.07390566229727025, 0.08033800859586204, 0.07709078809064851, 0.07907125346782828, 0.0769774400689548, 0.07795826877158996, 0.08194550740979756, 0.06717320707439034, 0.06185314294870936, 0.06744493128717366, 0.06856628370022722, 0.070876910721408, 0.05993693537746836, 0.057977973077233735, 0.06362610248542955, 0.06292213893756304, 0.9221794153746177, 0.8167089372525789, 0.9147059167825408, 0.8785813314179602, 0.9439293943889011, 0.8399700488255585, 0.9258339448772684, 0.8781312359401634, 0.9432375399071217, 0.16148216819056738, 0.15423416150672542, 0.1508028010671404, 0.14470535270687956, 0.14942661994247242, 0.16750892064407985, 0.16763295219472607, 0.1865073832312667, 0.1642352906373319, 0.22216563924734145, 0.2621833834374687, 0.2107487866764226, 0.20885739399422332, 0.21295082435651125, 0.2497122205923511, 0.2272226320884705, 0.22424460925000855, 0.21368392467272956, 0.11094451814401951, 0.10762692310888944, 0.0820395898068298, 0.11133570478526889, 0.09048320350196137, 0.1021639667662606, 0.09789263719340835, 0.10691549960021551, 0.09480183638322559, 0.09380634838994484, 0.01917806356586793, 0.14489928078687608, 0.09230544310326272, 0.06769676075970077, 0.09601029982055298, 0.09330070585465455, 0.07891229461512705, 0.07539785375035668, 0.015224953891314175, 0.016786491097765976, 0.03152157961071789, 0.015929712295666976, 0.003807659466218305, 0.00792485138022525, 0.017660770616980015, 0.028600784419796965, 0.015305902497804169, 0.1353322969188202, 0.1252017449203231, 0.13503215935583235, 0.12292929572384292, 0.12313688524638455, 0.09275383838723206, 0.12941754121908067, 0.11765553245294191, 0.11623837294833106, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010821662487900952, 9.999999999998899e-05, 0.06859485766815288, 0.07745563691381607, 0.05962304895875914, 0.06744803634438923, 0.05712255156177237, 0.05310839447907145, 0.07736023401724978, 0.06951451682891308, 0.0733703209395824, 0.2858261645869157, 0.32303070023618996, 0.3365669943055468, 0.3217288707993976, 0.3196164009479038, 0.32793138785951037, 0.3305353621798125, 0.30626920558300663, 0.3183699451764046, 0.07499659677368198, 0.07233495080837715, 0.07591462253496262, 0.06240440185731677, 0.06928324684930431, 0.06675124300213575, 0.0720039801905239, 0.06963685077061765, 0.07882650308506067, 0.13130188597000836, 0.1130059150804924, 0.14095151858700028, 0.141600035064827, 0.12890308551857854, 0.12338386107592691, 0.14688497417855706, 0.1130239343577617, 0.13050107208617623, 0.20571372657499487, 0.2166314232501776, 0.21443532676738308, 0.1884925800190299, 0.19177313639881666, 0.1804674889583603, 0.2263940642918918, 0.22418398954220953, 0.22622041788261904, 0.15829057374933886, 0.14294548403966634, 0.16144747421056604, 0.16270870165755846, 0.13747222816063642, 0.1319899955411944, 0.14852491275204516, 0.145780912341391, 0.15499233057066975, 0.17026340340519286, 0.17362895232958653, 0.16136992982736742, 0.16347305559986036, 0.15912185435024184, 0.17149467019273557, 0.1771320635078153, 0.1561517179087819, 0.16579872250752437, 0.15762910448819856, 0.16517039198289363, 0.15851438301948673, 0.16254204315224596, 0.15555951163911919, 0.16956465825393885, 0.16830432913338533, 0.15265682225006094, 0.15300659497478897, 0.23211598196546168, 0.1535105540342232, 0.15240775626487135, 0.23444210705465618, 0.14795790622150085, 0.2379373808208125, 0.15973588248628312, 0.15372507899449628, 0.15627099654162435, 0.16202145560055992, 0.17233505865890242, 0.18946095532611174, 0.193066700222828, 0.11252535342059977, 0.16631504882781978, 0.2679340734339376, 0.18544414684618438, 0.2008948890224772, 0.18719544568650426, 0.18545160884658995, 0.1734830062411038, 0.17181245398742262, 0.174495779137659, 0.1977997707403163, 0.18181653953132837, 0.17939292460188316, 0.17576893575748653, 0.056876081954089, 0.06369938851143886, 0.057814044303422296, 0.05693651630297136, 0.0565894073189287, 0.05450855211303862, 0.06449454459487247, 0.06011090835718602, 0.06731278918070438]}, "mutation_prompt": null}
{"id": "445fbdcf-dcf1-4e9c-a662-3efaa6ab3e14", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                fitness_feedback = (func(a) + func(b) + func(c)) / 3\n                F_dynamic = self.F * (1 - fitness_feedback / self.best_fitness) + (np.random.rand() - 0.5) * 0.1\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive Metropolis Sampling for exploration\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * 2.4**2 / self.dim\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Introduced adaptive mutation strategy using fitness feedback to improve convergence in black box optimization.", "configspace": "", "generation": 2, "fitness": 0.10544275189196144, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.13.", "error": "", "parent_id": "00bc9263-355b-49f3-9a5b-bd9df40854ea", "metadata": {"aucs": [0.23600989895735547, 0.26461309001305144, 0.25002237252643167, 0.23598749037359035, 0.21025849766865434, 0.1781347928288165, 0.20967078601944455, 0.26121055417774486, 0.20663531533092627, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08476437872401188, 0.10919728209959978, 0.09428655812550368, 0.09391440816415308, 0.07362918229810289, 0.09364124609746172, 0.0787508778625301, 0.12187519840894112, 0.08846037697483267, 0.09989984226403648, 0.07460409141523361, 0.1273996585926901, 0.05991295684726261, 0.04370207118131897, 0.0682615300686692, 0.0691254035979082, 0.06002212874985979, 0.06074665343764174, 0.9863870363143268, 0.9367235017777777, 0.9070502925169616, 0.09756338667498654, 0.12005836532812608, 0.11054758744542847, 0.3393576166101888, 0.17775595200356498, 0.19677835742367344, 0.07543304034166665, 0.06087918106957202, 0.029889095501910212, 0.061770908063257024, 0.07778689568344377, 0.046485874999861676, 0.024779533628915273, 0.02641308921279506, 0.027742818182899254, 0.18069762571482295, 0.17122958418893486, 0.15670318599069355, 0.13390438196385857, 0.1460768748191542, 0.12811618906033906, 0.09720594736967614, 0.09422442434339195, 0.10707970175535575, 0.0018767356856920214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038227769619323393, 9.999999999998899e-05, 9.999999999998899e-05, 0.006705349629652302, 0.004773607368525723, 0.005279800887622366, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032370294137535893, 0.010429215605030517, 9.999999999998899e-05, 0.004711105800094484, 0.004898419717859315, 9.999999999998899e-05, 0.0001795955731993537, 9.999999999998899e-05, 0.0062426489675783126, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014242108774697448, 0.012978281451508145, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016259568784008804, 0.00020909334268803814, 9.999999999998899e-05, 0.20774088089316012, 0.2587823176930353, 0.22047792031936841, 0.2844026327174022, 0.22737467903011566, 0.16410913455346032, 0.2740587472554862, 0.24995624237977088, 0.2533336950273374, 0.0525316784779396, 0.06740663850647666, 0.06934016395846576, 0.08329128420883158, 0.06849099122509472, 0.06596585267317956, 0.024089659957224785, 0.026109395599146823, 0.026735655856342633, 0.12652539292514087, 0.13363649943930833, 0.13907016667773586, 0.20313011232510725, 0.20587203637022866, 0.15262119818208297, 0.13204302858687444, 0.17874679565046958, 0.14845344583303322, 0.19687903901098625, 0.17699359126376968, 0.21643900964043006, 0.22193746514884394, 0.15911489605217144, 0.2139723609490356, 0.18809285727516223, 0.21056889562652437, 0.17067763504327793, 0.06928154757448379, 0.06291035964741354, 0.08435518489399074, 0.13997298927547874, 0.15949502096736012, 0.14502532997542616, 0.12126537961446471, 0.1509852985313559, 0.13452216985953402, 0.17795272803223616, 0.17230731298084534, 0.18187788294834695, 0.17973559990541377, 0.20622608374546214, 0.16216453901428707, 0.1742185783916662, 0.17869087379809845, 0.21584064772317135, 0.0018486217204168875, 9.999999999998899e-05, 9.999999999998899e-05, 0.0746440669515428, 0.004945050839479714, 0.09346461058059685, 9.999999999998899e-05, 9.999999999998899e-05, 0.012447122349534046, 0.15203088782224894, 0.14817369483476028, 0.16665227273917294, 0.11821235251352313, 0.12075634974604343, 0.13184431135340546, 0.1694518343576883, 0.15577815784355242, 0.1506745709460411, 0.2499322326643264, 0.1608311178106362, 0.07203665582068774, 0.15600277945909746, 0.18821756298883152, 0.1357469976826453, 0.16870645189760292, 0.15656029767388302, 0.15289870424534946, 0.17285820503902882, 0.15901437352518555, 0.1850428527861473, 0.1582302675426014, 0.17443798099043506, 0.16846096198897054, 0.17606115725332294, 0.16514806317961084, 0.17851463444699367, 0.06638125162504371, 0.06750726377281657, 0.07547589402713162, 0.06028743488158439, 0.07509579629552077, 0.06676303169200581, 0.06783043726976012, 0.06604559961022383, 0.0604005459299658]}, "mutation_prompt": null}
{"id": "f5a0cb5c-8eac-49f7-ba29-4d8123698427", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n\n    def __call__(self, func):\n        evaluations = 0\n        subpopulation_size = self.population_size // 2\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                # Select a subpopulation for mutation\n                sub_idx = np.random.choice(self.population_size, subpopulation_size, replace=False)\n                subpop = self.population[sub_idx]\n\n                # Mutation with stochastic scaling factor\n                indices = list(range(subpopulation_size))\n                a, b, c = subpop[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive Metropolis Sampling for exploration\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * 2.4**2 / self.dim\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Subpopulation Strategies for Improved Convergence.", "configspace": "", "generation": 3, "fitness": 0.17061698164618785, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "00bc9263-355b-49f3-9a5b-bd9df40854ea", "metadata": {"aucs": [0.3499995016340648, 0.36591194203765176, 0.36561413389214226, 0.37720474569643314, 0.3768097389905857, 0.4120174840494789, 0.36092929926063344, 0.3814978036684763, 0.3635165110986168, 0.15921070914397317, 0.1113429390492553, 0.10617739484732447, 0.1136015753093883, 0.10648385938761362, 0.10851351888861716, 0.10336233771099235, 0.14907055784755607, 0.09808517290988783, 0.07909393597300407, 0.07219518555264626, 0.0773154431971117, 0.07415863462248873, 0.09478119845118127, 0.07306660108248231, 0.07372210165952842, 0.07682689802599907, 0.07906885284137555, 0.06214284872157483, 0.05858551180857796, 0.06877779048541977, 0.0674357884009873, 0.07630624561909449, 0.05461807097639215, 0.07125388948904476, 0.07110601355485213, 0.05980642344882858, 0.9335283058888243, 0.9019770295943528, 0.8300328521720568, 0.7991132597267303, 0.9091012145271594, 0.8877357663311775, 0.8736323540958352, 0.788681130447132, 0.9773890659019956, 0.18601448126698694, 0.17104076857737815, 0.15455438075976813, 0.16586600355677494, 0.14100389991337148, 0.16302065436957858, 0.131596307760098, 0.1759414435669583, 0.16896664273025475, 0.20317962309821802, 0.2147818870826571, 0.1982109221228746, 0.2377226722972, 0.2350088101519594, 0.2195526773438271, 0.24251107502681324, 0.21275113587444405, 0.2235780575205898, 0.10383256854616807, 0.08055241959295345, 0.10445132653666911, 0.10672168326923615, 0.09709049934925462, 0.08832599884762316, 0.08481338841156216, 0.0771295895349956, 0.08961286775298871, 0.10505001087034394, 0.08160718898115005, 0.08418758692901629, 0.0796253355219565, 0.06975143720852683, 0.10283373110155991, 0.07024579759479821, 0.08118928484106269, 0.08298390184275717, 0.015027023478184076, 0.027291264408677685, 0.02340302456333576, 0.008951381088203147, 0.008354535993852164, 0.010260635003119578, 0.00852799297714324, 0.025208492731662036, 0.01742536991593735, 0.1365637758294066, 0.10782084779314449, 0.12455915279592722, 0.09734113398084632, 0.09675737227532155, 0.1280133266769502, 0.12595946982168715, 0.10426436058514177, 0.11873610892076414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007637280935477442, 9.999999999998899e-05, 9.999999999998899e-05, 0.06320773459412432, 0.0657358207714489, 0.052175893968939846, 0.06579939061259721, 0.06119518491804943, 0.06380304423829819, 0.06266610353129054, 0.07108939217608035, 0.06916139508199559, 0.3004518575042099, 0.2990699583146269, 0.32540624759834014, 0.3383758835681243, 0.32026230953035983, 0.34585556442082266, 0.33282618444147494, 0.32683173300363955, 0.3168188830179878, 0.08248361448837771, 0.0720678766572389, 0.07443413703931179, 0.07264005387068517, 0.0952214128106742, 0.07258970973867218, 0.0706589395960373, 0.0921782342882832, 0.06306451257851786, 0.14235125131744752, 0.1714332961208811, 0.12235695574506955, 0.1220747856053156, 0.12383372951033211, 0.18259741325314494, 0.133969061043275, 0.11046310939754622, 0.1674123029181277, 0.2062289485779749, 0.2118198012556627, 0.20291062720752084, 0.19920726316674986, 0.19685201881450098, 0.20808699797607078, 0.21382269295636902, 0.22591210472681333, 0.21101138667105002, 0.12757213668250678, 0.1412086735542153, 0.1543865510552419, 0.15309921270027693, 0.14246521105449705, 0.14047503784008497, 0.15099012073516116, 0.15703827531443637, 0.14315302220486814, 0.16678478377307404, 0.16954401207868575, 0.20911415506579323, 0.16685881177918382, 0.16868336278585372, 0.16022081423815349, 0.1792112607073355, 0.1931158677585949, 0.16837456576233267, 0.16001127206267485, 0.1675823744910313, 0.1658309378145767, 0.16594667275073716, 0.16276057207108585, 0.15867846345407, 0.1761741471108369, 0.17326033709482858, 0.15602579961069374, 0.17936886407670172, 0.2491156005316365, 0.200932975525285, 0.19942949606157367, 0.1581678530598365, 0.20355744918410024, 0.15514966666691365, 0.1600256407386993, 0.1603085089846773, 0.14189322096575274, 0.19669953869739676, 0.17264296848810368, 0.15235432809056493, 0.16213615771345724, 0.14871442973839, 0.1865222368242555, 0.18991875085362253, 0.19284963863304483, 0.16584650084981223, 0.1719716039198973, 0.16328447468945595, 0.16828482733322903, 0.1755167415481672, 0.17268430894484132, 0.1835045356700845, 0.16747673899147153, 0.1803817866157973, 0.06181895418561567, 0.059334851223350915, 0.0636427663550414, 0.060052929881840966, 0.06606623875157924, 0.05886158612212544, 0.06976834907740681, 0.0691779172990542, 0.05668763440512481]}, "mutation_prompt": null}
{"id": "e8d94c94-020a-4406-90f7-bdbabe87875d", "solution": "import numpy as np\n\nclass HybridDifferentialEvolutionAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                # Adaptive mutation with dynamic scaling factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.2:  # Adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive Metropolis Sampling for exploration\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * 2.4**2 / self.dim\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolutionAdaptiveMutation", "description": "Hybrid Differential Evolution with Adaptive Mutation Thresholds for enhanced exploration and convergence in black box optimization.", "configspace": "", "generation": 4, "fitness": 0.17343610649646024, "feedback": "The algorithm HybridDifferentialEvolutionAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "00bc9263-355b-49f3-9a5b-bd9df40854ea", "metadata": {"aucs": [0.36314956871290693, 0.33414086191795167, 0.35708783185464255, 0.3756091245326363, 0.38032618580936983, 0.3907853923925334, 0.38401789486401117, 0.37322240590651345, 0.33534961097964344, 0.0913606472589874, 0.11250885794191146, 0.1349388945463621, 0.11671812501645218, 0.11045167613508167, 0.12911389506352067, 0.12294288492170313, 0.12842840060936833, 0.13348914848232252, 0.06828800152170711, 0.07915285089580171, 0.08776653715017024, 0.07890700170526199, 0.07237057289021809, 0.09019528833023938, 0.07484504664321845, 0.0787530145875095, 0.08151476704197069, 0.05809006462014732, 0.06372068266874231, 0.06545991509021554, 0.06798457581897677, 0.07024016934877053, 0.061959637895966035, 0.07331393530436614, 0.07479085198021329, 0.06535137425666815, 0.8792433145847597, 0.9232089229784555, 0.8224814621333177, 0.9172978431078063, 0.8990294368697601, 0.9168126224248583, 0.8556546701612393, 0.8698539005527297, 0.9197853029545091, 0.15897724851531658, 0.15044819738788662, 0.1483497873042514, 0.14665345488889614, 0.1537992189374423, 0.17666645549065674, 0.18867912196181413, 0.1712439572666239, 0.1639647336941482, 0.22243823758046288, 0.24519664835456112, 0.25911024481939104, 0.22453200690354003, 0.23720857555246755, 0.2103016148288822, 0.23337864144894027, 0.22117817371543447, 0.2603698282010113, 0.08028717621713477, 0.09932260355447675, 0.08641253703586604, 0.10942983113912319, 0.09847465974441383, 0.09547786903956568, 0.08494935470614184, 0.09875802348443452, 0.1018386267907122, 0.1250099462066837, 0.11221833583178709, 0.1073222513877572, 0.09385427720446748, 0.08591874962538115, 0.12010874827225959, 0.0804276287408, 0.07325047786861105, 0.08757817012093094, 0.009114077332072479, 0.017734313381705724, 0.02437471666721236, 0.022291057034943718, 0.016052993160200257, 0.016865100123755528, 0.015216470299539653, 0.01664253902228574, 0.03275298715136521, 0.144206506112319, 0.09697517066922134, 0.09735550214609445, 0.1209802309326018, 0.103620793918765, 0.11910625893915217, 0.1601005651256956, 0.13925907626938439, 0.15364988544692204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004551980513153864, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07023581409790791, 0.07227771678838868, 0.05458259536433929, 0.06748182104407063, 0.07008120982391153, 0.07135154400420962, 0.07607043276702186, 0.06560087462899356, 0.07699101087515103, 0.33036109052851426, 0.3428355213435985, 0.3328244114773897, 0.3201896742513247, 0.35553572737996897, 0.3528916781242536, 0.34205824924447203, 0.3135458269545839, 0.3306678268539266, 0.07393052556829594, 0.071064562471012, 0.06971762953147231, 0.08364095265191684, 0.06728507782826587, 0.0818449346689597, 0.06510040987739885, 0.07219928194282887, 0.07141661650406439, 0.12997951451505374, 0.150855301884117, 0.17005294731982046, 0.12724991025400956, 0.1632320197742967, 0.13228594619386824, 0.12128430175299998, 0.13441585446845206, 0.12448571281901388, 0.2138735903501412, 0.21485084191253967, 0.212731101157279, 0.19420808788765642, 0.1864899489659102, 0.20424216150343577, 0.21907133113501664, 0.22587986654104275, 0.24031877066860408, 0.15669104705913106, 0.14389170874703072, 0.15298944768799339, 0.15459733047042024, 0.13722203982188363, 0.15473004284090985, 0.15669848943303444, 0.16783294659349324, 0.15804171281448964, 0.16326940695213565, 0.16850024905994154, 0.19124771282532316, 0.16868905592482097, 0.1623691436899357, 0.16742640775675333, 0.16779794946629334, 0.17809934504401004, 0.15965914933804126, 0.15437364054510017, 0.16650220565288654, 0.18213152638072105, 0.16533461178329834, 0.15421227450381958, 0.16467999559169888, 0.16005825853202638, 0.15948343191473757, 0.16942174662518827, 0.15892181992432275, 0.15803511041808582, 0.20343426016606547, 0.2732890669366024, 0.16310020724220742, 0.13119207952216816, 0.18015146593803633, 0.2206705734195289, 0.13824922683984242, 0.16775054253201271, 0.17459477289299608, 0.16955464364960482, 0.1576178007426342, 0.14886861174743138, 0.15458221905451697, 0.18390817356620448, 0.19791282276425226, 0.18829711999196952, 0.21088183412465433, 0.18778016528063135, 0.17349461480669615, 0.16661632024436834, 0.1641112217176982, 0.1677454183711723, 0.16712382980977003, 0.177603846176823, 0.17459752455330602, 0.06040520630185797, 0.06715600508854769, 0.06373073058682788, 0.06037945696997071, 0.05365715552428285, 0.048581387938626874, 0.05658586527618703, 0.053872068224365965, 0.07000592360435054]}, "mutation_prompt": null}
{"id": "7c644e92-8c95-472b-8c64-7ab93ae05303", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolutionAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.8\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.evaluation_ratio = 0.7  # Adaptive population resizing parameter\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.2:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Novel Crossover Strategy: adjusting CR dynamically\n                cross_points = np.random.rand(self.dim) < (self.CR + 0.1 * np.sin(evaluations / self.budget * np.pi))\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive Population Resizing\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * 2.4**2 / self.dim\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n                # Resize the population according to evaluation ratio\n                self.population_size = max(4, int(self.population_size * self.evaluation_ratio))\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolutionAdaptiveCrossover", "description": "Enhanced Differential Evolution with Adaptive Population Resizing and Novel Crossover Strategy for Improved Convergence.", "configspace": "", "generation": 5, "fitness": 0.15196170802016196, "feedback": "The algorithm EnhancedDifferentialEvolutionAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "e8d94c94-020a-4406-90f7-bdbabe87875d", "metadata": {"aucs": [0.19175708644530998, 0.22123197688816953, 0.21362523005044642, 0.19278559169863774, 0.14052840435250924, 0.2716631273705258, 0.17249517554426896, 0.29380936939624047, 0.22389649389142952, 9.999999999998899e-05, 9.999999999998899e-05, 0.07731085564758011, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.24349393284377252, 0.0504433414087232, 0.06176765393436667, 0.08783872375346413, 0.0774062781063356, 0.1346114099332557, 0.050238926540990714, 0.07562316997611629, 0.10042954342994947, 0.07409900200961206, 0.0626681932800146, 0.08340813536809144, 0.07700029510963691, 0.08296559053236341, 0.07677476644142445, 0.0473316725506564, 0.06960441174160625, 0.053343159130904816, 0.06358675950749126, 0.024970713641317754, 0.0705585903503686, 0.9637960085868471, 0.9649711794468839, 0.870764840618272, 0.9611831511287628, 0.9551193836717282, 0.9678994164897646, 0.11345349233577218, 0.9502497742652102, 0.9787600771127554, 0.0786125181122741, 0.036229449400461466, 0.0874119253872474, 0.03666622771060479, 0.034174945585084604, 0.028759754288916195, 0.0613636184309484, 0.041951527411906, 0.11718691940520476, 0.15020186361948473, 0.2794374423841557, 0.15988510183839066, 0.17407353964378658, 0.17044070962173397, 0.20730542742732427, 0.13268115884293952, 0.22882762232164788, 0.11439336444755077, 0.1224209746341961, 0.043003492204337856, 0.1273913051590938, 0.025542020298964907, 0.03148927495028364, 0.1094413204541197, 0.13054773123289487, 9.999999999998899e-05, 0.018069308280442953, 0.06649349757030287, 0.016228238358461433, 0.07822990758168202, 0.11633306126248133, 0.1825433387515203, 0.03648265561525221, 0.13564963691877696, 0.05410038723708144, 0.08087592016152945, 9.999999999998899e-05, 9.999999999998899e-05, 0.10245934600124751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06969425762836257, 9.999999999998899e-05, 9.999999999998899e-05, 0.017120556289554223, 0.07251170882386082, 0.07977566128777358, 0.06232551419763244, 0.11895221901540576, 0.09341442661359545, 0.055441390868748885, 0.09501363007477959, 0.026247148737791215, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02446334204225442, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026823694588399283, 0.07720577849741872, 0.040220731934273335, 9.999999999998899e-05, 9.999999999998899e-05, 0.003832851631152656, 0.06363314986583768, 9.999999999998899e-05, 0.04814983774088233, 0.20963900323104911, 0.3119547711286583, 0.2751059031950025, 0.21600842468390513, 0.208969337114429, 0.25061932689440924, 0.36833811249889425, 0.16537093248700707, 0.3382217250405368, 0.06978726697582804, 0.07409552736298008, 0.07077603058326476, 0.032556158826271164, 0.1319255422065333, 0.07012007663863074, 0.07927659415201382, 0.06731388323143861, 0.08201529575680266, 0.12088620204820089, 0.14008859941687046, 0.14854869456854702, 0.12955387638831872, 0.11821444196667541, 0.19135317103407046, 0.1267449382397826, 0.17616014745771735, 0.16712585888609843, 0.2130422639993338, 0.1814711112961651, 0.16863126662039718, 0.21861905852254582, 0.21049772099968922, 0.20000615747299377, 0.19373912570146445, 0.22011583383177513, 0.21919868678654908, 0.10046945127161466, 0.1338976742624436, 0.23870757711402935, 0.12798263446497837, 0.16097353774942968, 0.12115138885699084, 0.14795178051441438, 0.13078569987174216, 0.20426166950377633, 0.19650772155855045, 0.2101173585869598, 0.19823707441748362, 0.18653435170762422, 0.21532226609925786, 0.188081555434382, 0.19871627390164737, 0.16944565028252323, 0.19526475811109845, 0.16630269349821314, 0.04526471924654174, 0.17674744259397301, 0.17337074914888162, 0.1268441688166866, 0.17477274429595413, 0.241456285096032, 0.17872744602535218, 0.14237352381755042, 0.4221841601089936, 0.0895722392165873, 0.1685618822476519, 0.21901985176792227, 0.16679738722803616, 0.18472306091307122, 0.16268778242609205, 0.434356800394338, 0.14654344386957652, 0.19284177816542913, 0.15316655795306466, 0.15895142143350915, 0.3320128392885566, 0.1713321484371645, 0.3857549821023605, 0.15551100916490235, 0.12451102346971543, 0.19324726221725197, 0.1743315584548356, 0.18338027273459734, 0.17640225035481272, 0.17542486275904923, 0.1905808545880452, 0.17931052952818993, 0.1666111021458646, 0.16194721755934993, 0.2008079333086501, 0.07343914222741532, 0.0695688594760906, 0.07526688530425107, 0.07191874519536401, 0.07755627035063173, 0.07378436525770826, 0.05803542425551145, 0.057614470677100016, 0.09201795735868068]}, "mutation_prompt": null}
{"id": "935c3ead-8148-47a1-806c-8023573b6c3f", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.dynamic_population_factor = 0.5\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            # Dynamically adjust population size\n            adaptive_population_size = int(self.population_size * (1 - self.dynamic_population_factor * evaluations / self.budget))\n            new_population = np.zeros_like(self.population[:adaptive_population_size])\n\n            for i in range(adaptive_population_size):\n                # Self-adaptive mutation strategy\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.2  # Adjusted scaling factor range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population[:adaptive_population_size] = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Population Size and Self-Adaptive Mutation Strategy for improved convergence in black box optimization.", "configspace": "", "generation": 6, "fitness": 0.16418120360375973, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.18.", "error": "", "parent_id": "e8d94c94-020a-4406-90f7-bdbabe87875d", "metadata": {"aucs": [0.3288926168692171, 0.3272462772674014, 0.34185932072608616, 0.37962857329107313, 0.3593700202428938, 0.37532082643225795, 0.3601692312536551, 0.33350740835693826, 0.3504651418591569, 0.08998423488659268, 0.09052940596353876, 0.09982534151494982, 0.08072672885515475, 0.09589429144782624, 0.07678449818247923, 0.08187310674962622, 0.09026387629472943, 0.09579264112263208, 0.0897669528386692, 0.07824155100199792, 0.07491061441665092, 0.06482741741564191, 0.06496413681545887, 0.07231681844301763, 0.0666291857294058, 0.06849352870714176, 0.08941112744737911, 0.06752632035203465, 0.05498003808081575, 0.06609038276377399, 0.06367186668466607, 0.06820330593746016, 0.056067044730465976, 0.06324727707807365, 0.0535486786099012, 0.07706327410521385, 0.8873672263248277, 0.8856046167728238, 0.9119455487197353, 0.8896383307442299, 0.8794907435771889, 0.9546660741566451, 0.9362771221878194, 0.8720105287122779, 0.9262586674287994, 0.13850169839308224, 0.137759016755566, 0.1310829094676541, 0.1281802037534846, 0.14093280980441325, 0.1540069632964327, 0.14926813418350704, 0.14406187698786965, 0.14838018351568405, 0.20303972082805022, 0.18819768558375527, 0.21529524295692093, 0.20721915770317123, 0.20456822701082, 0.20970421622623936, 0.21240645848490258, 0.21735268491913107, 0.20381871284403796, 0.0891470165635907, 0.05873091438672129, 0.08876414708172309, 0.08646867506830747, 0.09214890595640268, 0.09647619505642491, 0.09616971722080181, 0.05519058659169074, 0.0813850600654401, 0.12428381419598922, 0.12279855264424, 0.0718450248794199, 0.07817482092497918, 0.06277840374684807, 0.08346946392860188, 0.07177586076955089, 0.07178984522278553, 0.07138617728183927, 0.009303250067487334, 0.012264850393283289, 0.0015859376575854123, 0.02339879040215076, 0.0006750061919388317, 0.007334890713680431, 0.00953363771587068, 0.017244190783016866, 0.028429142615094105, 0.09389472478254635, 0.11582199086698697, 0.09089091709335317, 0.10993321955438096, 0.09468925307207665, 0.07088891767981476, 0.1252398456238688, 0.09076007166376077, 0.12240065407526413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053628855350895344, 0.04638627388166183, 0.05444237637545846, 0.06411777612997827, 0.06023265749511397, 0.06106256132286436, 0.0553760256223762, 0.06418755359856898, 0.06471167256177468, 0.30485426246805036, 0.31467979260608314, 0.3170465657011994, 0.3216838198593246, 0.31022150736023446, 0.304834161782804, 0.29091085219962587, 0.3070682775599518, 0.30112908168924746, 0.06965282959048236, 0.06899013317728053, 0.07184945766540407, 0.08300031879022585, 0.07334540091169106, 0.07521594051342506, 0.06257384177950531, 0.07686317917352659, 0.061631695274127374, 0.14480789972849617, 0.13028164313870805, 0.15745827467787754, 0.12658021899529137, 0.12433738849503806, 0.14300724835141865, 0.14622647427221036, 0.12843710752969495, 0.1639010087452798, 0.19303733387383637, 0.19884066815942691, 0.1915614983175431, 0.19708037987421967, 0.1786755671708815, 0.1910304874650317, 0.20327989224948428, 0.2247660747036201, 0.20232173514024265, 0.1490193059520729, 0.1459267911242187, 0.13940542504522924, 0.14355243160391296, 0.13207125674442033, 0.13261026984952318, 0.14518188692587775, 0.15663792214640349, 0.17015356121181924, 0.16007781009776478, 0.162811281326793, 0.15203191064265176, 0.15614056215054894, 0.15475821110208177, 0.17317874933113853, 0.1748443556470345, 0.15866690671375983, 0.1607896488064684, 0.1494224068250225, 0.16268790102523234, 0.1585312313637478, 0.16564708685552, 0.15211735107076496, 0.1517969601345054, 0.16250789606368476, 0.1528126729922098, 0.15833614902274729, 0.15068431457339482, 0.1398072109303894, 0.15434140918416128, 0.1903074179323968, 0.1786756056881924, 0.2521209427089509, 0.2314266261178024, 0.19589567918607698, 0.12997698827386683, 0.24964944854560056, 0.17241090311298246, 0.1496581194229688, 0.11622566542623003, 0.12455627951502735, 0.1286810812275322, 0.19554109326755253, 0.1900732822716802, 0.20215791351877443, 0.16535425232533185, 0.17684318682792888, 0.1736044817323289, 0.17930035055903593, 0.17763348247800737, 0.18481566532673577, 0.1893497060934407, 0.16733837113630667, 0.18073687151300488, 0.053553362626755585, 0.0614822969208082, 0.06778296706802289, 0.058252181203787945, 0.06035917293361104, 0.059758909926376114, 0.05568254671129946, 0.06146413871801082, 0.0674920439528307]}, "mutation_prompt": null}
{"id": "bfecee05-f80c-4926-bfdd-9b9996ea7d8e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.8  # Crossover rate\n        self.F = 0.9   # Differential weight\n        self.mutation_factor_bounds = (0.4, 0.9)\n        self.local_search_radius = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.25:  # Adjusted mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * 2.4**2 / self.dim\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations < self.budget:\n                for j in range(self.population_size):\n                    local_search_solution = new_population[j] + np.random.uniform(-self.local_search_radius, self.local_search_radius, self.dim)\n                    local_search_solution = np.clip(local_search_solution, self.lower_bound, self.upper_bound)\n                    local_search_fitness = func(local_search_solution)\n                    evaluations += 1\n                    if local_search_fitness < func(new_population[j]):\n                        new_population[j] = local_search_solution\n                    if evaluations >= self.budget:\n                        break\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Step Size and Local Search for improved convergence in black box optimization.", "configspace": "", "generation": 7, "fitness": 0.14150862860663202, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.15.", "error": "", "parent_id": "e8d94c94-020a-4406-90f7-bdbabe87875d", "metadata": {"aucs": [0.2668604708174702, 0.24950229706915905, 0.2580648357435502, 0.2770598512133503, 0.29641731171961117, 0.25704096257941644, 0.3027541221172263, 0.24674866531145268, 0.2572067036814001, 0.026945146035545986, 0.039459794563154404, 0.04129622032175195, 0.030182961483948723, 0.02228389850682455, 0.03160394208132489, 0.02673299986601796, 0.023042956781338386, 0.023666561176957646, 0.08014028237118709, 0.08214323206449348, 0.07694970301958326, 0.0968256505978341, 0.06294349869392357, 0.09535856965576672, 0.06617301916230112, 0.07044984155468115, 0.07629711534031536, 0.07472510026800905, 0.04608971978937115, 0.059234606067342765, 0.06938101839101218, 0.06310121700459426, 0.05351214119997838, 0.07250085348482649, 0.05263438116148644, 0.04490268804263886, 0.750915738216876, 0.7057460123450952, 0.7214796619692765, 0.8266271408867274, 0.8882705374998981, 0.7186556041964227, 0.8159887797920171, 0.7501595754206233, 0.8188815469429649, 0.09151051223227513, 0.08655119181545157, 0.0762782105065195, 0.0878846073343833, 0.06933532828956745, 0.06833146209866714, 0.10338179845998896, 0.1053837683829486, 0.11424724218681637, 0.16963303896965953, 0.16890948736445444, 0.146557153232864, 0.17808694223185828, 0.19075588650640996, 0.1807392410609664, 0.15985271185217897, 0.17615457229578335, 0.14995484463816233, 0.05960843062188559, 0.03315779016293219, 0.05119352015858203, 0.046700155689748724, 0.07038320821301236, 0.09591516677465484, 0.08256686229769161, 0.04607685263343575, 0.057462844754707865, 0.0573858201012013, 0.05205926127671556, 0.04290471305591359, 0.09310946237884377, 0.07075286694466998, 0.0584464476954899, 0.04565049377410346, 0.046972151376764804, 0.06534633756002672, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0020134654118392215, 9.999999999998899e-05, 9.999999999998899e-05, 0.007662097479654739, 0.08319805762621268, 0.08257241094054957, 0.10510013477026947, 0.09829020789650644, 0.08123084108260314, 0.0820166600656057, 0.08420359840247205, 0.0872140003977443, 0.07734546086303817, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021782527428592435, 0.027892305267721573, 0.04327370154260368, 0.020660016425628647, 0.02348678493768397, 0.03964747784425693, 0.03568716083658252, 0.034165535462550856, 0.035311674509279856, 0.22355824904240462, 0.2654356037307436, 0.27549228953687876, 0.23716034982660972, 0.2583779991673436, 0.255910859450192, 0.25848655448118596, 0.21163050893020086, 0.26875618620575914, 0.07349926658790207, 0.06875448231959125, 0.08289360304303461, 0.06762823739977375, 0.062095163411226895, 0.09178149116322143, 0.07006047396681847, 0.07631185957967523, 0.07521305437942283, 0.14363627737182283, 0.14833791125505702, 0.1723829824633083, 0.16874826366604778, 0.16380661576706046, 0.16179721605860597, 0.1511933077657508, 0.1462750751477725, 0.15415308197186717, 0.16893970807876235, 0.1690525315217295, 0.19773488310499765, 0.16545833965227263, 0.16723107579283314, 0.17742424662488954, 0.1756129127010868, 0.18624233600909745, 0.16938739062347907, 0.10197014515043235, 0.12140747847034183, 0.11823123833898297, 0.12883649884436232, 0.11253810826115718, 0.12022209885816881, 0.12507937959034388, 0.13524197253760672, 0.12011406199710217, 0.18023143215482307, 0.1782305534181805, 0.15437710407003447, 0.17228972925863617, 0.17888239930180716, 0.16018481813551022, 0.1597784224509542, 0.1727235905376696, 0.17524537066236667, 0.17859101910185127, 0.15183151247270665, 0.15054960179359733, 0.1655147306881838, 0.16531950581499355, 0.16541543247074864, 0.15286417488514492, 0.14356494010137122, 0.1580776119123264, 0.16102277686662747, 0.17328902869633145, 0.2662552011383046, 0.15171977193841701, 0.149637871382041, 0.2185768963025302, 0.13368938091465754, 0.15925972133176547, 0.14235517985250268, 0.17644512449770022, 0.15686546205889007, 0.18732386081147534, 0.1651607834760298, 0.17022951229328265, 0.13298013783694151, 0.1647591506064917, 0.16826363385608967, 0.16874650833922844, 0.18694853833938863, 0.17748425835056114, 0.17912165719506434, 0.17667482156159786, 0.19135108938979284, 0.17808199040466044, 0.18698838975945997, 0.1838048369315699, 0.1785449359554685, 0.06797347908811535, 0.06819791537583297, 0.068809792665255, 0.05314244849409988, 0.05554714236856195, 0.0522668632392409, 0.05702461835362005, 0.053326984559986745, 0.055669255393625106]}, "mutation_prompt": null}
{"id": "4ceca266-fe97-4bfb-a93b-51f39bdce66c", "solution": "import numpy as np\n\nclass HybridDifferentialEvolutionAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.historical_best = np.copy(self.population[np.argmin([func(x) for x in self.population])])\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.2:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                historical_influence = 0.1 * np.random.uniform(-1, 1, self.dim) * (self.historical_best - a)\n                mutant = np.clip(a + F_dynamic * (b - c) + historical_influence, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * 2.4**2 / self.dim\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n                    self.historical_best = proposal if proposal_fitness < func(self.historical_best) else self.historical_best\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolutionAdaptiveMutation", "description": "Enhanced diversity in mutation by integrating historical best solutions to improve convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "e8d94c94-020a-4406-90f7-bdbabe87875d", "metadata": {}, "mutation_prompt": null}
{"id": "c2563f13-a025-4254-b6c5-e548fd1194bc", "solution": "import numpy as np\n\nclass HybridDifferentialEvolutionAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                # Adaptive mutation with dynamic scaling factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.2:  # Adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Enhanced Metropolis Sampling with adaptive covariance\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolutionAdaptiveMutation", "description": "Improved Hybrid Differential Evolution with Enhanced Metropolis Sampling leveraging adaptive covariance scaling for accelerated convergence.", "configspace": "", "generation": 9, "fitness": 0.1734904699851363, "feedback": "The algorithm HybridDifferentialEvolutionAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "e8d94c94-020a-4406-90f7-bdbabe87875d", "metadata": {"aucs": [0.3631373330989214, 0.33408287833352335, 0.35707487034151864, 0.3755839559869518, 0.3803136444675158, 0.39078743914000946, 0.3839763263386734, 0.3732119410948035, 0.3353377603408104, 0.0913606472589874, 0.11249799801720506, 0.13493190651490716, 0.11671079532832596, 0.1103653712667314, 0.12908077041818233, 0.12294266054472136, 0.12842840060936833, 0.1334791888146245, 0.06828800152170711, 0.07915285089580171, 0.08776653715017024, 0.07890700170526199, 0.07179969691516397, 0.09019093093893316, 0.07484504664321845, 0.07877878308537434, 0.08151476704197069, 0.05809006462014732, 0.06369322215615958, 0.06545991509021554, 0.06798457581897677, 0.07025577345049772, 0.061959637895966035, 0.07331393530436614, 0.07433473743356411, 0.06535137425666815, 0.8792422973326358, 0.9232089229784555, 0.8224847443048979, 0.9172978431078063, 0.8990294368697601, 0.9168126224248583, 0.867071397379563, 0.8698527181533053, 0.9197853029545091, 0.1589797717872543, 0.15048276755549217, 0.14835336256240828, 0.14665345488889614, 0.1537843150081264, 0.17667318943793364, 0.18867892800353192, 0.1711708955675174, 0.16398281957538108, 0.22243823758046288, 0.24519664835456112, 0.25909920099365813, 0.22453200690354003, 0.23720857555246755, 0.2103016148288822, 0.23337864144894027, 0.22117817371543447, 0.2603698282010113, 0.08028717621713477, 0.09930186125169127, 0.0863515596554304, 0.10933089010796848, 0.098469427334399, 0.09547604736278936, 0.08494935470614184, 0.09873869919541134, 0.10183769873244763, 0.1250099462066837, 0.11221688757133619, 0.10731577186385088, 0.09385427720446748, 0.08591641897953772, 0.12010874827225959, 0.0804276287408, 0.07324322443620235, 0.08757176233350528, 0.009114077332072479, 0.017734313381705724, 0.02430544410500557, 0.022277481562081758, 0.016052975064287822, 0.01683425568103447, 0.015198936897402038, 0.016624740137649474, 0.03271803628666603, 0.14419787655487548, 0.09697517066922134, 0.09735550214609445, 0.1209802309326018, 0.10363475260635624, 0.11906796554647314, 0.160060183003488, 0.1392558544318928, 0.15362252005799093, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004551980513153864, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0702127699843077, 0.07227771678838868, 0.05458259536433929, 0.06748119826299348, 0.07007671853394826, 0.0713462765745988, 0.0760593790352454, 0.06560087462899356, 0.07695259109035602, 0.33036038031233295, 0.3428286631070184, 0.33281901257838187, 0.3201786472773922, 0.3555341998968744, 0.3528890618025883, 0.3420297187173653, 0.3135378798443965, 0.33064431180887455, 0.07393052556829594, 0.071064562471012, 0.06971762953147231, 0.08364095265191684, 0.06725215768603288, 0.08184496777703665, 0.06508222453048129, 0.07216614951173284, 0.07141661650406439, 0.12997951451505374, 0.150855301884117, 0.17005294731982046, 0.12724991025400956, 0.1632320197742967, 0.13228594619386824, 0.1232612765152773, 0.13440439963853912, 0.12448571281901388, 0.2138735903501412, 0.2148502519307759, 0.212731101157279, 0.19420808788765642, 0.18655089885735843, 0.20424216150343577, 0.21905634941171515, 0.22631228169649553, 0.24033954444527195, 0.156755661129381, 0.14394626700603008, 0.15272804046301047, 0.15467022403591546, 0.13722203982188363, 0.15472535699093115, 0.15676439832950217, 0.16783294659349324, 0.1580784052579487, 0.16326940695213565, 0.16806781033018925, 0.19124771282532316, 0.16868905592482097, 0.1623691436899357, 0.16775712413922994, 0.16779794946629334, 0.17809934504401004, 0.15977292135090915, 0.15437364054510017, 0.16658099662849213, 0.18213152638072105, 0.16533461178329834, 0.15421227450381958, 0.16467431697630164, 0.16005825853202638, 0.1594991043693843, 0.16942174662518827, 0.15892181992432275, 0.15803511041808582, 0.20341926500758578, 0.2735374105017847, 0.16310020724220742, 0.13119207952216816, 0.18015012802399322, 0.2206296692188463, 0.13824922683984242, 0.16775054253201271, 0.17459331384035026, 0.16955464364960482, 0.1576178007426342, 0.14886861174743138, 0.15458221905451697, 0.18390731996325316, 0.19791284912090434, 0.18829713602689835, 0.21088183412465433, 0.18778016528063135, 0.17349461480669615, 0.16661632024436834, 0.1641112217176982, 0.1677454183711723, 0.16712382980977003, 0.177603846176823, 0.17459752455330602, 0.06040520630185797, 0.06715600508854769, 0.06375350115594014, 0.06037945696997071, 0.05365715552428285, 0.048581387938626874, 0.05626918543674764, 0.053872068224365965, 0.07000592360435054]}, "mutation_prompt": null}
{"id": "75a43e41-ef4f-4fd9-9c61-401b99870e47", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.opp_learning_rate = 0.1  # Learning rate for opposition-based learning\n        \n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.2:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            for i in range(self.population_size):\n                opp_solution = self.lower_bound + self.upper_bound - new_population[i]\n                opp_solution = opp_solution + self.opp_learning_rate * (self.best_solution - opp_solution)\n                opp_solution = np.clip(opp_solution, self.lower_bound, self.upper_bound)\n                opp_fitness = func(opp_solution)\n                evaluations += 1\n                if opp_fitness < func(new_population[i]):\n                    new_population[i] = opp_solution\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Opposition-Based Learning and Covariance Matrix Adaptation for improved exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.13010640060096693, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.13.", "error": "", "parent_id": "c2563f13-a025-4254-b6c5-e548fd1194bc", "metadata": {"aucs": [0.2533569162578039, 0.22941838843228324, 0.25546853949855286, 0.269305788060788, 0.2649859690327935, 0.28128815946671404, 0.2729246722212304, 0.26714741020999677, 0.26283953948384264, 0.023323024218043997, 0.029149405597813538, 0.028315491236258317, 0.020977860764692546, 0.024496039186771346, 0.018596338315650995, 0.01686208835154901, 0.021946490567630983, 0.02837317267422146, 0.0649926759658983, 0.06289448445714929, 0.05899807091823295, 0.0857303200304308, 0.06435716024760929, 0.05174973487651913, 0.055418500687216654, 0.0674371834914731, 0.06802745219489625, 0.049034993212580646, 0.042556504917259375, 0.038745375233363855, 0.058832358431528564, 0.05041112121320335, 0.04802183736263976, 0.04779519172965685, 0.08072642536767183, 0.05975712837694758, 0.5789815441566712, 0.6583093209356654, 0.6946242734129247, 0.8032990122009862, 0.687915121181033, 0.5825451260232454, 0.6100658191810777, 0.49502465689446795, 0.5879402705359418, 0.10882014714306298, 0.0841766409728818, 0.08820655275089317, 0.09936443748691037, 0.10702917507613552, 0.11105166124318533, 0.0974003129607901, 0.11224202231556302, 0.10126828481937322, 0.17421648920792054, 0.15330354545580338, 0.1765136986993291, 0.17943723084228114, 0.15647560524816528, 0.162485896863804, 0.1538232256757407, 0.18565657131486846, 0.15211389642464568, 0.048354664992906304, 0.05184408545127295, 0.05333915871742123, 0.0613106840212595, 0.04968661961679954, 0.04992337695366145, 0.06218740185590255, 0.036406314143368035, 0.05032597205029943, 0.09996213529791442, 0.08768138457956798, 0.06129320677167638, 0.09400347616053784, 0.09105330327337013, 0.08297631887280599, 0.07258898585159257, 0.0688507781412292, 0.07567995345025758, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001774216886833213, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04876090450789483, 0.08173417524499271, 0.05855738666951915, 0.04965754884545126, 0.05657228508552581, 0.07020264597399672, 0.10672372519343609, 0.07213174410206014, 0.09258465630934387, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020920242250869303, 0.0156886598183692, 0.022590230655704535, 0.035881903269987525, 0.029050430042229847, 0.03288713706229196, 0.03185721437055122, 0.030462698258109433, 0.031538975553038084, 0.23300187044948828, 0.24525553727592309, 0.2483814743456484, 0.23541612201627904, 0.2560244316384823, 0.2459597914757754, 0.23787252994284758, 0.24652376589713743, 0.24981372949049652, 0.06135784719339876, 0.06902771983915645, 0.056787766803987116, 0.06066889182326063, 0.05798432576610324, 0.05798885457374292, 0.050879256105122894, 0.0540994754722649, 0.06038768342801981, 0.10352797374301392, 0.14515004339012172, 0.11863091475941567, 0.11321117470713216, 0.12851595377489866, 0.13072531268068832, 0.15064590842380365, 0.11143876424518218, 0.1259681056728621, 0.1657270610363899, 0.17053104023698706, 0.17873514444710714, 0.17183451636574554, 0.1765386390855096, 0.18041126404711028, 0.1829658746848919, 0.1963549552608873, 0.19051886910622384, 0.09571379896073773, 0.12641072416774046, 0.11779270122198049, 0.13936401274589394, 0.12534714564203553, 0.1290610340438476, 0.12766556684315544, 0.12987443612759375, 0.12812898210672652, 0.17597802086350567, 0.16850148371594587, 0.16324474448905368, 0.16229791582854947, 0.16539005776179072, 0.15536060171091215, 0.18018777636188166, 0.16204221753316284, 0.16271029436831086, 0.15742726911654537, 0.1609421477682459, 0.15554104963133053, 0.13959055292472855, 0.15057471861986305, 0.15215179308373994, 0.15995042063842135, 0.14026580830913282, 0.14819390209246175, 0.1434755299316215, 0.12940186276841892, 0.15517047717047738, 0.1269996341137687, 0.1349534758348766, 0.1559616935391317, 0.1310956154859103, 0.15128859777395842, 0.15382152177735386, 0.19911667979793146, 0.1699913871809875, 0.13472931887350859, 0.12605522326036078, 0.1256370385908987, 0.1603018677096385, 0.17302136999128148, 0.16566467266327567, 0.16328376887752782, 0.18083722079205378, 0.16289146634855511, 0.177296746527428, 0.1698633626993129, 0.18862386917802976, 0.19447621583174834, 0.1851138431812991, 0.17452002806325528, 0.17357061495118398, 0.059532573622398055, 0.05858570679793429, 0.05727954074932573, 0.05705956055114125, 0.04850546705888015, 0.06116493091630637, 0.06203409636947932, 0.05788276857088315, 0.06990606475998429]}, "mutation_prompt": null}
{"id": "348f21a2-b2fa-435b-a8d6-55d9f8f3c6dd", "solution": "import numpy as np\n\nclass HybridDifferentialEvolutionAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])  # Retain best\n            for i in range(self.population_size):\n                # Adaptive mutation with dynamic scaling factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.2:  # Adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                CR_dynamic = self.CR + (0.1 * (self.budget - evaluations) / self.budget)  # Increase CR\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Enhanced Metropolis Sampling with adaptive covariance\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite  # Maintain elite\n\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolutionAdaptiveMutation", "description": "Adaptive Mutation Differential Evolution with Elite Retention and Dynamic Crossover for accelerated convergence.", "configspace": "", "generation": 11, "fitness": 0.1770290036148055, "feedback": "The algorithm HybridDifferentialEvolutionAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "c2563f13-a025-4254-b6c5-e548fd1194bc", "metadata": {"aucs": [0.3361958084629557, 0.3396232947479, 0.3550766473844936, 0.37752650635825025, 0.34062021377501406, 0.3372481885099382, 0.3315883037503201, 0.3555516932803653, 0.35608654310233345, 0.12183621643040787, 0.05687617561739822, 0.09058288504623524, 0.08952462628807822, 0.07212238001640581, 0.07432223673583704, 0.12975075088419796, 0.05874695702542798, 0.14240459371090086, 0.062321174717057115, 0.06117172359222589, 0.10486176081239684, 0.08282415193172932, 0.07498835511581659, 0.10398029255521035, 0.05469746760536853, 0.0871543634276013, 0.07106038868534836, 0.06813046844920212, 0.05951636325381893, 0.07441716016770317, 0.08001152294459912, 0.11518628719851653, 0.06800107975515379, 0.07162230242868206, 0.07528325620718479, 0.0609756382324369, 0.8988224312994553, 0.7543500650714718, 0.6340377231029524, 0.947058799111548, 0.784791458261583, 0.8217737023346461, 0.6486477418134933, 0.7679543989922313, 0.8672239620970581, 0.15865860706400148, 0.14428193306896686, 0.14436560988050662, 0.18619003666905376, 0.13336443699380562, 0.15695989039222658, 0.13183690099451928, 0.1331100056376927, 0.1764343323362345, 0.2888719948282432, 0.23821821241114138, 0.3058156623189384, 0.2948757680324807, 0.31163539193228074, 0.21965587476227644, 0.3810460616332175, 0.23761855632565398, 0.23285395516938556, 0.09859946599866998, 0.08756773816243735, 0.11699380351956301, 0.10915414907641319, 0.14565085012793466, 0.09006823633859806, 0.08688889052358373, 0.071471732743143, 0.10221926637712053, 0.11672099985583462, 0.09860171588497757, 0.008711868078281948, 0.09238496124571671, 0.11253616163803237, 0.08226340725653714, 0.09286274627856128, 0.09382703275468307, 0.09738303750360755, 0.08525572942495652, 0.08452074153728995, 0.07031156457200483, 0.06574711981065007, 0.04691642946025909, 0.05976381169612177, 0.06933287307135105, 0.04593857580051974, 0.04680109846313785, 0.1729059922897188, 0.1595771361454259, 0.19712566505113838, 0.14048203891078592, 0.17534622697724644, 0.1745618456274699, 0.20391961304776085, 0.16590688650939334, 0.17554403819638098, 0.002498920509456326, 0.006333265769560392, 0.008609697255875126, 0.01784369144200504, 0.0005799439756567493, 0.00037878810934632856, 0.0019033667685056654, 0.0006243304303258368, 0.009413563654392054, 0.0860221229154502, 0.058182869441896434, 0.061725189027665106, 0.06821768840108666, 0.05051682197496088, 0.07796821209812299, 0.10086926738982638, 0.08621618009290744, 0.06970607947258722, 0.3596106094570568, 0.3135142109698391, 0.32510891353891025, 0.3271803467296043, 0.3189488919430379, 0.31412901671311355, 0.34398980045191585, 0.31382801089897594, 0.3238451392529249, 0.06508186954599893, 0.08249077487225898, 0.08973040993352366, 0.0778693652628466, 0.07114726976134012, 0.06570420975035174, 0.07042401618159633, 0.08066605450092834, 0.07588174380313517, 0.12375156019099254, 0.1435120737592127, 0.14907840820634644, 0.21189012572623733, 0.1274007256014671, 0.16825684367525207, 0.13587605555422655, 0.14441274307632523, 0.14216896848430083, 0.2563804022223235, 0.19901041179190793, 0.23506386400089396, 0.22490176838610831, 0.20456020233089334, 0.22793468661850036, 0.2360799340762414, 0.26586443281686967, 0.18765785685373282, 0.18287447660100153, 0.16364034262926053, 0.1950497694505705, 0.14664270996415762, 0.1402454030742123, 0.1784411682457936, 0.1476606394676041, 0.1983312998308746, 0.16745106892380357, 0.17080424282104867, 0.15397405319564983, 0.16611425647851463, 0.1612071075528233, 0.16349832903269912, 0.16914344723630892, 0.18334198614837993, 0.15537704219371118, 0.16391267981831448, 0.15802156433434666, 0.15488736461283448, 0.1552624090132385, 0.1743767635506287, 0.14322658031752122, 0.1642499896204841, 0.16433431291260514, 0.16539229058306282, 0.17514629838598827, 0.1541318176854798, 0.1563469071023874, 0.16685806237714185, 0.15636195570536493, 0.16820494305184108, 0.2493230923506513, 0.17221037893452362, 0.2895403233495343, 0.14798759372945025, 0.2492422112244782, 0.2821892549708005, 0.3307633871043505, 0.23806654228926938, 0.15497267649185975, 0.23477606189371814, 0.18456806701925976, 0.20142710758394, 0.18150851666235324, 0.18872148206022732, 0.16461982087007543, 0.16589544718536142, 0.17217746797386757, 0.18067557134365597, 0.18951088869032706, 0.18991798810260596, 0.178405348205665, 0.17105005095992454, 0.0684167344274974, 0.05568284843626503, 0.06178392207883587, 0.07372575079480848, 0.05916640595139688, 0.051471146015801605, 0.054839855074075405, 0.05678496001929434, 0.07756614072075918]}, "mutation_prompt": null}
{"id": "27dcc49d-6ac0-4ac6-8952-b5ff80ec45af", "solution": "import numpy as np\n\nclass ImprovedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaotic_sequence = np.sin(np.linspace(0, np.pi, self.initial_population_size))  # Chaotic sequence\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])  # Retain best\n            for i in range(self.population.shape[0]):\n                # Adaptive mutation with dynamic scaling factor\n                indices = list(range(self.population.shape[0]))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.2:  # Adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                CR_dynamic = self.CR + (0.1 * (self.budget - evaluations) / self.budget)  # Increase CR\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Population resizing strategy\n            if evaluations < (0.5 * self.budget):\n                self.population = new_population[:int(self.initial_population_size * chaotic_sequence[evaluations % len(chaotic_sequence)])]\n            else:\n                self.population = new_population\n\n            # Enhanced Metropolis Sampling with adaptive covariance\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population = new_population\n            self.population[np.random.randint(self.population.shape[0])] = elite  # Maintain elite\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedDifferentialEvolution", "description": "Improved Differential Evolution with Dynamic Population Resizing and Chaotic Sequence for Enhanced Convergence.", "configspace": "", "generation": 12, "fitness": 0.1770290036148055, "feedback": "The algorithm ImprovedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "348f21a2-b2fa-435b-a8d6-55d9f8f3c6dd", "metadata": {"aucs": [0.3361958084629557, 0.3396232947479, 0.3550766473844936, 0.37752650635825025, 0.34062021377501406, 0.3372481885099382, 0.3315883037503201, 0.3555516932803653, 0.35608654310233345, 0.12183621643040787, 0.05687617561739822, 0.09058288504623524, 0.08952462628807822, 0.07212238001640581, 0.07432223673583704, 0.12975075088419796, 0.05874695702542798, 0.14240459371090086, 0.062321174717057115, 0.06117172359222589, 0.10486176081239684, 0.08282415193172932, 0.07498835511581659, 0.10398029255521035, 0.05469746760536853, 0.0871543634276013, 0.07106038868534836, 0.06813046844920212, 0.05951636325381893, 0.07441716016770317, 0.08001152294459912, 0.11518628719851653, 0.06800107975515379, 0.07162230242868206, 0.07528325620718479, 0.0609756382324369, 0.8988224312994553, 0.7543500650714718, 0.6340377231029524, 0.947058799111548, 0.784791458261583, 0.8217737023346461, 0.6486477418134933, 0.7679543989922313, 0.8672239620970581, 0.15865860706400148, 0.14428193306896686, 0.14436560988050662, 0.18619003666905376, 0.13336443699380562, 0.15695989039222658, 0.13183690099451928, 0.1331100056376927, 0.1764343323362345, 0.2888719948282432, 0.23821821241114138, 0.3058156623189384, 0.2948757680324807, 0.31163539193228074, 0.21965587476227644, 0.3810460616332175, 0.23761855632565398, 0.23285395516938556, 0.09859946599866998, 0.08756773816243735, 0.11699380351956301, 0.10915414907641319, 0.14565085012793466, 0.09006823633859806, 0.08688889052358373, 0.071471732743143, 0.10221926637712053, 0.11672099985583462, 0.09860171588497757, 0.008711868078281948, 0.09238496124571671, 0.11253616163803237, 0.08226340725653714, 0.09286274627856128, 0.09382703275468307, 0.09738303750360755, 0.08525572942495652, 0.08452074153728995, 0.07031156457200483, 0.06574711981065007, 0.04691642946025909, 0.05976381169612177, 0.06933287307135105, 0.04593857580051974, 0.04680109846313785, 0.1729059922897188, 0.1595771361454259, 0.19712566505113838, 0.14048203891078592, 0.17534622697724644, 0.1745618456274699, 0.20391961304776085, 0.16590688650939334, 0.17554403819638098, 0.002498920509456326, 0.006333265769560392, 0.008609697255875126, 0.01784369144200504, 0.0005799439756567493, 0.00037878810934632856, 0.0019033667685056654, 0.0006243304303258368, 0.009413563654392054, 0.0860221229154502, 0.058182869441896434, 0.061725189027665106, 0.06821768840108666, 0.05051682197496088, 0.07796821209812299, 0.10086926738982638, 0.08621618009290744, 0.06970607947258722, 0.3596106094570568, 0.3135142109698391, 0.32510891353891025, 0.3271803467296043, 0.3189488919430379, 0.31412901671311355, 0.34398980045191585, 0.31382801089897594, 0.3238451392529249, 0.06508186954599893, 0.08249077487225898, 0.08973040993352366, 0.0778693652628466, 0.07114726976134012, 0.06570420975035174, 0.07042401618159633, 0.08066605450092834, 0.07588174380313517, 0.12375156019099254, 0.1435120737592127, 0.14907840820634644, 0.21189012572623733, 0.1274007256014671, 0.16825684367525207, 0.13587605555422655, 0.14441274307632523, 0.14216896848430083, 0.2563804022223235, 0.19901041179190793, 0.23506386400089396, 0.22490176838610831, 0.20456020233089334, 0.22793468661850036, 0.2360799340762414, 0.26586443281686967, 0.18765785685373282, 0.18287447660100153, 0.16364034262926053, 0.1950497694505705, 0.14664270996415762, 0.1402454030742123, 0.1784411682457936, 0.1476606394676041, 0.1983312998308746, 0.16745106892380357, 0.17080424282104867, 0.15397405319564983, 0.16611425647851463, 0.1612071075528233, 0.16349832903269912, 0.16914344723630892, 0.18334198614837993, 0.15537704219371118, 0.16391267981831448, 0.15802156433434666, 0.15488736461283448, 0.1552624090132385, 0.1743767635506287, 0.14322658031752122, 0.1642499896204841, 0.16433431291260514, 0.16539229058306282, 0.17514629838598827, 0.1541318176854798, 0.1563469071023874, 0.16685806237714185, 0.15636195570536493, 0.16820494305184108, 0.2493230923506513, 0.17221037893452362, 0.2895403233495343, 0.14798759372945025, 0.2492422112244782, 0.2821892549708005, 0.3307633871043505, 0.23806654228926938, 0.15497267649185975, 0.23477606189371814, 0.18456806701925976, 0.20142710758394, 0.18150851666235324, 0.18872148206022732, 0.16461982087007543, 0.16589544718536142, 0.17217746797386757, 0.18067557134365597, 0.18951088869032706, 0.18991798810260596, 0.178405348205665, 0.17105005095992454, 0.0684167344274974, 0.05568284843626503, 0.06178392207883587, 0.07372575079480848, 0.05916640595139688, 0.051471146015801605, 0.054839855074075405, 0.05678496001929434, 0.07756614072075918]}, "mutation_prompt": null}
{"id": "02444db9-73f0-4aab-90c7-a10ed2de7f6b", "solution": "import numpy as np\n\nclass HybridDifferentialEvolutionAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])  # Retain best\n            for i in range(self.population_size):\n                # Adaptive mutation with dynamic scaling factor\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.2:  # Adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                \n                # Introduce rotation to search direction\n                rotation_matrix = np.eye(self.dim)\n                theta = np.pi * np.random.rand()  # Random rotation angle\n                rotation_matrix[0, 0] = np.cos(theta)\n                rotation_matrix[0, 1] = -np.sin(theta)\n                rotation_matrix[1, 0] = np.sin(theta)\n                rotation_matrix[1, 1] = np.cos(theta)\n                rotated_direction = rotation_matrix @ (b - c)\n                \n                mutant = np.clip(a + F_dynamic * rotated_direction, self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                CR_dynamic = self.CR + (0.1 * (self.budget - evaluations) / self.budget)  # Increase CR\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            # Enhanced Metropolis Sampling with adaptive covariance\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            # Update population with new solutions\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite  # Maintain elite\n\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolutionAdaptiveMutation", "description": "Hybrid Differential Evolution with Adaptive Mutation and Rotated Search Directions for Enhanced Exploration.", "configspace": "", "generation": 13, "fitness": 0.15888301316028186, "feedback": "The algorithm HybridDifferentialEvolutionAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": "348f21a2-b2fa-435b-a8d6-55d9f8f3c6dd", "metadata": {"aucs": [0.33012468107499215, 0.2925312730748981, 0.3443674303046832, 0.3683874510760635, 0.33098200491437235, 0.34256540097919097, 0.3678471645962944, 0.3382823318839593, 0.32340051132584235, 0.06470371893816973, 0.08382355905835626, 0.05866828775653543, 0.06163253964568882, 0.06450966193456698, 0.06970969842589181, 0.05945955675949721, 0.09016261707885098, 0.0646355679161843, 0.08497867635788747, 0.08416440361093513, 0.0707108757270466, 0.07486688531488106, 0.08350465975731991, 0.06696184721111897, 0.06220217261838423, 0.09442274738777068, 0.08784919356683207, 0.05261011879022848, 0.05939660229201871, 0.06338057838657063, 0.05778654605655098, 0.059128405532731576, 0.0591780219123893, 0.08003982987854619, 0.079672972084608, 0.057649747514320726, 0.8704092668587956, 0.9355587384289694, 0.7735893774182983, 0.9185586766245103, 0.8310106727437788, 0.6647213272223425, 0.8634878054437036, 0.8351587587883376, 0.8202574576609428, 0.16030593612038158, 0.1601073233163297, 0.10596888093510459, 0.12733191294619794, 0.13202590704834605, 0.1223574249803665, 0.1550253941952453, 0.15290249562540248, 0.1465224437688727, 0.20847659482455572, 0.23007871125264068, 0.19171064902226753, 0.1801052667158729, 0.20346485383363155, 0.16173072463034333, 0.17204758957376343, 0.18531862783153863, 0.19660245347338046, 0.0867505291919497, 0.07968282201801191, 0.07772047380506375, 0.05717690615182658, 0.09648627513905172, 0.093154814553158, 0.10681821011330483, 0.07177741316454189, 0.0814507874857816, 0.01086824970615019, 0.0913867935096796, 0.07453782822900834, 0.09601107298046596, 0.09934692376732313, 0.07323853571447358, 0.12264017371348379, 0.09004966278744653, 0.09001536444230573, 9.999999999998899e-05, 0.002997410897637942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001660327774563819, 9.999999999998899e-05, 9.999999999998899e-05, 0.038680055938848046, 0.04724836602111426, 0.039827324984446966, 0.010888685571489254, 0.04564924242529811, 0.07340361876687584, 0.055379371538500144, 0.02457797266113848, 0.05838179998533777, 0.0042443931741840135, 9.999999999998899e-05, 9.999999999998899e-05, 0.006050103718829858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042880163028579554, 0.047406710261859386, 0.04703799386336427, 0.04024221385539384, 0.03115268777613167, 0.05743030637000268, 0.06751504422425036, 0.04524666138029532, 0.043932852121150834, 0.2903011218188549, 0.31591391092986476, 0.3009143812815218, 0.29865723542846967, 0.298976119323338, 0.3242663074215788, 0.3215089229967192, 0.2949027848115061, 0.3112301855210421, 0.06448352869986707, 0.06961678437622254, 0.07279440180721031, 0.08353205255172047, 0.06259690843711774, 0.08952914246683363, 0.0576461767093539, 0.07985655591262963, 0.06848311491971948, 0.13673772984053756, 0.15547962100262125, 0.11842175776965747, 0.1397920100694522, 0.1138333791499615, 0.10925816907453478, 0.12421614879873955, 0.10986731538180161, 0.12021015847123251, 0.2207455897956544, 0.2295239219956391, 0.2395061304447269, 0.20053201401854182, 0.20401278738763517, 0.22097220577923038, 0.22313671965320658, 0.2239517887575564, 0.24806849447002488, 0.1417788808695779, 0.1500944524236516, 0.15027463893395376, 0.12393325611547557, 0.15246473886025846, 0.14421726968917048, 0.14365622090644115, 0.17032326071799309, 0.1434477666269891, 0.17152131561347284, 0.1475527122048621, 0.15148766434127703, 0.17002911093003892, 0.15463225219487964, 0.15728056231836707, 0.1473842882198041, 0.20027262856789718, 0.17004738263155705, 0.15869483152471076, 0.15572170105471783, 0.16343847347483298, 0.16704566816357214, 0.14749430768562177, 0.15338813226004167, 0.16452558102658787, 0.1708063465413141, 0.15982917248495665, 0.15274313921273075, 0.15344270045679553, 0.4151428468959888, 0.14517592700150472, 0.1662006356689597, 0.1482143773668103, 0.13210493142444812, 0.18083004165491234, 0.1475057353114071, 0.33261129259432465, 0.22208517144794115, 0.23873570210044515, 0.20934468310910848, 0.10915119930413697, 0.15273720209300468, 0.18924745727643977, 0.2854843323674132, 0.25438930373296076, 0.16126173789513598, 0.16774154615779047, 0.18764824187832396, 0.18588228499946613, 0.17002246406772337, 0.1729884260704454, 0.1755094492514434, 0.18790595463921955, 0.19662883291032818, 0.05715421575477231, 0.06223996779529539, 0.06241035732383804, 0.05295931064575321, 0.0592456841429444, 0.06298240809986178, 0.05093965081513363, 0.06246348559649029, 0.06130279706081743]}, "mutation_prompt": null}
{"id": "7e19ec5e-4157-480c-abbe-00f78717ec1d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            # Dynamic population sizing based on remaining budget\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])  # Retain best\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:  # Adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR + (0.1 * (self.budget - evaluations) / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Mutation and Metropolis Sampling enhanced by Dynamic Population Sizing and Exponential Weight Decay for improved convergence speed.", "configspace": "", "generation": 14, "fitness": 0.1819225161808315, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "348f21a2-b2fa-435b-a8d6-55d9f8f3c6dd", "metadata": {"aucs": [0.35444400086403305, 0.3099756758593398, 0.33874675991455794, 0.337336507385412, 0.34635993474761584, 0.35240807019502085, 0.32727256349748834, 0.3296186380689251, 0.343403110739982, 0.09205161265157114, 0.05808198308877255, 0.11079486564209418, 0.13623682491589684, 0.10070508654345123, 0.06187503956973539, 0.10375280675784138, 0.09005113808673815, 0.11535778317461065, 0.08058625032056244, 0.08223186408444016, 0.07652828077497942, 0.06831127200636511, 0.08305870403429783, 0.09378957056225101, 0.07048610854691328, 0.07043446600143466, 0.07124984027674908, 0.07946180615984544, 0.05947183359897168, 0.06939379296160442, 0.06588281835362109, 0.07994203049885895, 0.06326171766327693, 0.05908924891546796, 0.05437683562079787, 0.06635834802382345, 0.7240697922938498, 0.8230216904419723, 0.5476035318953111, 0.8574858503073702, 0.8810202035797189, 0.7033036731175893, 0.728113278575144, 0.8864431469274079, 0.9373339578461922, 0.15445871809690104, 0.1536796807090246, 0.1778046121228707, 0.16249620334989923, 0.1849551749436219, 0.13562849223340057, 0.16843320706012344, 0.1706614881291062, 0.2018948029654266, 0.40069994661335784, 0.30732311862900674, 0.23506917007874484, 0.33691287932225533, 0.36921038744609314, 0.2434943506693955, 0.46183664634228827, 0.2784090074730846, 0.31825057351656116, 0.08660057920998021, 0.09220369603532674, 0.08467596287854795, 0.07723488173030091, 0.10273948098388974, 0.10306587648919907, 0.06935346963377864, 0.09090973422117843, 0.09474464054897436, 0.16265401008061964, 0.10143819603033821, 0.07512921360438962, 0.10630151136422505, 0.10595858916402756, 0.09744256876065716, 0.11646475166339476, 0.08961176790625636, 0.09279145049254367, 0.11535216178088736, 0.07875880605499386, 0.07710837763936418, 0.062211913690698006, 0.05451198280318437, 0.053115898325703736, 0.08969334097996562, 0.08067384006598255, 0.05272850267611462, 0.223730676575411, 0.21700247145871399, 0.19274385679034178, 0.21498494407518465, 0.2087972415668471, 0.12183681642010846, 0.1879513645494446, 0.1596253445649518, 0.1875486540026522, 0.01043397633768639, 0.01367802430567222, 9.999999999998899e-05, 0.0013482670913071981, 0.00012981926079114192, 0.0008977529159652775, 0.00832326716845233, 0.013196576556105177, 0.0029507233537977573, 0.08040447385783522, 0.07638138958838625, 0.07885497352216786, 0.07667888903621733, 0.07176230768238656, 0.08173924946933109, 0.08197490528207896, 0.07953832116849702, 0.07600326836492444, 0.3175354954012841, 0.33571563873529175, 0.3607873991218632, 0.3194147437756255, 0.33671436938839716, 0.32369727975639184, 0.29988256437036975, 0.3297453709925271, 0.29493158226602945, 0.07561552851809739, 0.06342695594058345, 0.08745902996665411, 0.0756876289486863, 0.06167919277104139, 0.07576651504392062, 0.0686898665899578, 0.06201470089129524, 0.07902029706576341, 0.15031415073730137, 0.12312498448112053, 0.11842175776965747, 0.17582278285338104, 0.12880946177437413, 0.13513557322952952, 0.12429165364622696, 0.14794828458697462, 0.13460049440440103, 0.21576240987918793, 0.22440777376264387, 0.26930481581654153, 0.2340601064403044, 0.22451477764400307, 0.23102723324798458, 0.23875652326326247, 0.23627797122557626, 0.2646613980106912, 0.16010258060795368, 0.18799171236543943, 0.1828297886999921, 0.1245977143100443, 0.16961618258581346, 0.16330049443632177, 0.17366728669614162, 0.18407716779800398, 0.17503681252665448, 0.18166166876747425, 0.16807280689271442, 0.17532374458112066, 0.15783621615956467, 0.15102425120696794, 0.19290137015522102, 0.17739911775520356, 0.15604774421792134, 0.1614365080020691, 0.14832981992348737, 0.16093734935429604, 0.22547351300253793, 0.1744852701819607, 0.17206847873131137, 0.1650736060782112, 0.1625618747200177, 0.16263165201783436, 0.1545846626760311, 0.4123922050033164, 0.1516160424508689, 0.3408934503375918, 0.16104767721355562, 0.16839992519916136, 0.15461817981533965, 0.16065287702915032, 0.32571260272909, 0.13023550664993877, 0.30843382245949735, 0.1575485836650622, 0.17510458350776825, 0.18125175243387803, 0.27912504177753106, 0.32938104172077143, 0.1766709713759561, 0.20156679047221138, 0.18862968371836097, 0.15923040133573485, 0.1793469112642293, 0.1799585497225311, 0.1783657404493264, 0.17762860659615165, 0.16451219174445686, 0.1656428164776489, 0.1706679769258126, 0.1849863175352774, 0.05317309993966757, 0.058155683030832406, 0.07100359195495909, 0.05637535624730028, 0.0689492617193993, 0.06467491028557593, 0.06066101940183377, 0.07445258840330449, 0.07600849312641289]}, "mutation_prompt": null}
{"id": "cd7da799-93f8-43b1-b65a-1c6ab0b6694b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n        self.inertia_coefficient = 0.7  # Inertia coefficient for velocity-based exploration\n\n    def __call__(self, func):\n        evaluations = 0\n        velocities = np.zeros_like(self.population)\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n                velocities = velocities[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR + (0.1 * (self.budget - evaluations) / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                velocities[i] = self.inertia_coefficient * velocities[i] + (trial - self.population[i])\n                new_population[i] = np.clip(new_population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Mutation and Metropolis Sampling enhanced by Dynamic Population Sizing, Exponential Weight Decay, and Inertia Coefficient for improved exploration-exploitation balance and convergence speed.", "configspace": "", "generation": 15, "fitness": 0.1049024882870319, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.18.", "error": "", "parent_id": "7e19ec5e-4157-480c-abbe-00f78717ec1d", "metadata": {"aucs": [0.12141682211598526, 0.10805360794410968, 0.10825496112657762, 0.13783782963606228, 0.14161645956222202, 0.14759433693489032, 0.129608645461458, 0.14157527501898404, 0.1482230472063102, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0175494042485409, 0.022171602243821864, 0.02840057466009116, 0.02074467449009587, 0.01914313443079063, 0.0323435146045804, 0.03165114821100856, 0.024888031321571358, 0.04234144082589175, 0.0020992798518473244, 0.013156472307634837, 0.018657102513962465, 0.021371533447646307, 0.023045040650975124, 0.013619856454594625, 0.015230896125303262, 0.022640227291415793, 0.00699601983928988, 0.8804286555678857, 0.9756664035912128, 0.8925859041321578, 0.9562274679209025, 0.8735194154995409, 0.9437835722271297, 0.971276702347326, 0.970777830589593, 0.9538633426315262, 0.06628773001580301, 0.055942738348448984, 0.030177005748707186, 0.026172874502970234, 0.04557561765852547, 0.02916089219527096, 0.047522094081015376, 0.06045351959237122, 0.08220137677913442, 0.10027683525177622, 0.08224659834595494, 0.07406322386035258, 0.1040174366923935, 0.11996378689507403, 0.09057000916462388, 0.09951729639215878, 0.08582213832874186, 0.09085404042586287, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0026425142916941535, 0.018463231539009972, 0.008336233235198276, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018015674102865864, 0.0033850084611268816, 0.01625100478492203, 0.02812139217249099, 0.029835902981416806, 0.04243281294224288, 0.05445046690943822, 0.03792223670516137, 0.015384033549140974, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15777792025785875, 0.1635861090766999, 0.1565806366164496, 0.16276601038702843, 0.18273046563163742, 0.1636585571432242, 0.16696550584191738, 0.17888343840449927, 0.17931937642845264, 0.03141158866678018, 0.042708969812213726, 0.04562901351408122, 0.03375958677068924, 0.0257548050720523, 0.04756015186134188, 0.041749964157217656, 0.031261782605427335, 0.031178924699954425, 0.1298098648711441, 0.12828077093466694, 0.13824833576024464, 0.13640276322724532, 0.12303334857631276, 0.14217275785690653, 0.12066863847913867, 0.140848274401565, 0.15319767180865818, 0.1473392691310733, 0.1471377999560003, 0.1613932299901244, 0.16129259134116636, 0.1413806511864124, 0.14172044157700747, 0.1475688587295203, 0.17377774300845283, 0.14234247812005707, 0.10474366352068132, 0.1087526064101898, 0.09056209930320713, 0.08611294400076419, 0.07937588772844828, 0.09643390464181734, 0.10586827776628271, 0.10352322682528414, 0.10668440743939589, 0.13668061901943707, 0.12619312882129796, 0.14800885613009573, 0.14338168085722058, 0.1492596281055788, 0.1313232187908061, 0.14274581301476352, 0.1195876328877461, 0.13604076309936686, 0.018638311647705685, 9.999999999998899e-05, 0.04800680030382409, 0.0945797663883362, 0.0059363342249988404, 0.04590143251766421, 0.00019614195540385015, 0.033567200382455864, 9.999999999998899e-05, 0.14597420915316783, 0.13313771159512777, 0.1505366600377267, 0.12515957860098315, 0.12418812867424944, 0.1257880489319979, 0.13192847095372962, 0.11787074603774161, 0.12914337441725476, 0.13211135356956327, 0.11366324221829605, 0.11662731836536422, 0.10903517782924987, 0.11982878924183893, 0.08937917196327905, 0.14976557123019751, 0.1594346775923583, 0.1680820276370547, 0.17834049301877808, 0.18314607061124177, 0.18196327507751153, 0.1777959946692781, 0.1804875758445429, 0.17930873367202005, 0.19839976560862393, 0.17663619025722677, 0.2052297863592144, 0.026733263985913247, 0.03343305581377953, 0.033812149419097826, 0.032387421148579065, 0.03874036384729518, 0.03520961951188639, 0.035879379384595844, 0.03803354422653826, 0.05001792882076095]}, "mutation_prompt": null}
{"id": "6716ca7f-f489-4dfb-8a06-18c0bb6b0498", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n        self.restart_threshold = 0.1  # 10% chance to restart\n        self.adaptive_increase = 0.05  # Adaptive increase value for CR\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            # Stochastic restart mechanism\n            if np.random.rand() < self.restart_threshold:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n            \n            # Dynamic population sizing based on remaining budget\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])  # Retain best\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:  # Adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR + (0.1 * (self.budget - evaluations) / self.budget) + self.adaptive_increase\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "EnhancedHybridDifferentialEvolution with stochastic restart and adaptive crossover for improved diversity and convergence.", "configspace": "", "generation": 16, "fitness": 0.11458622394032687, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.14.", "error": "", "parent_id": "7e19ec5e-4157-480c-abbe-00f78717ec1d", "metadata": {"aucs": [0.18881180218549887, 0.16143845852906558, 0.1960839679625609, 0.23082972827520187, 0.18159773249568256, 0.19590993608286422, 0.18790181794361926, 0.18533606903821342, 0.18203818441073805, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06008239320469422, 0.05533649997454393, 0.060885747030799964, 0.0489588663800572, 0.04922659318673328, 0.05945389509592369, 0.05093540203000635, 0.04702336093711823, 0.05033332784086719, 0.030641610935369545, 0.02829691804641077, 0.03518260357734593, 0.03207171725178193, 0.03554902133343407, 0.03389348079943688, 0.026299735454006656, 0.02858500580854617, 0.04997154144164884, 0.3194152063289888, 0.9501763854504847, 0.6862580474900444, 0.19783355127334146, 0.9334054270937764, 0.7394830837540629, 0.37254136321023434, 0.9313097485565215, 0.6305497919554934, 0.07233834490036939, 0.09355071463445097, 0.06702122909987251, 0.06596226762176538, 0.06291953988895038, 0.08579350325730517, 0.10349744500303748, 0.08623893749585387, 0.07326240210059909, 0.1374110966593045, 0.15448954123108027, 0.15414562715585978, 0.14954253868560186, 0.12902368797855746, 0.12367484862502676, 0.13352013217246328, 0.16002978020136127, 0.1415811008641531, 0.012567656731774846, 9.999999999998899e-05, 0.0050620249242018245, 0.005626123927865101, 0.01140019515196744, 0.013738674240520221, 0.0035139695668118254, 0.028783252223863243, 0.027780299145508947, 0.019318717519085427, 0.01632254353398943, 0.019042911684614583, 0.08838827046412678, 0.026634357695424882, 0.06924456556171643, 0.017692143011110217, 0.03944174559761504, 0.020393257671897813, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05123368898402003, 0.07424841396318238, 0.06250774763139544, 0.06172671957566567, 0.05779008458883672, 0.042052825761361934, 0.07750099505191554, 0.056650384420716016, 0.052878587568384705, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004661199503621871, 0.006987073162905477, 0.00820762368566319, 0.004642384473989347, 0.010590954617006876, 0.0038316695223377106, 0.006906467027138596, 0.003915422201932972, 0.021761588323985448, 0.24345262560747016, 0.1833284975658952, 0.20106557579857498, 0.21024237335515084, 0.2132786038446155, 0.2240333762511999, 0.21437462307642952, 0.20716134955118237, 0.21358053162110202, 0.060185014351068045, 0.05869499514178611, 0.05083985860010287, 0.05791744424578005, 0.04415467389531147, 0.0575732808887105, 0.04657622674149131, 0.038499654363646774, 0.05138451404616029, 0.12383634260853649, 0.12397076508290428, 0.12392733355939267, 0.1350240906996083, 0.12721182099913075, 0.12379298071604339, 0.1238521684007261, 0.11177725237022784, 0.12848401057775227, 0.15785107861672532, 0.1645519890317252, 0.1970439125431407, 0.14890509859230783, 0.15759358228852993, 0.17896598887742943, 0.17397066152213314, 0.1729814497924721, 0.15582485078424602, 0.09971476496106968, 0.0951150322953157, 0.11667985905145228, 0.11136364390212516, 0.10145100676902585, 0.1080838360894073, 0.11137356117936581, 0.10341063148202134, 0.12508135763922723, 0.15310090209755056, 0.15403116075295586, 0.1404926183834665, 0.15900803511416817, 0.16143091954595146, 0.1550263622425797, 0.1506858148337753, 0.15225428850404388, 0.1773355137907482, 0.11361901903928207, 0.11911441396570921, 0.1334536263639975, 0.14292790922217613, 0.13832821982432308, 0.14671770083901647, 0.14566975980883434, 0.1363914748101519, 0.1296745045878337, 0.15252564833098425, 0.15311373366472913, 0.15258359441676916, 0.16748160808874468, 0.1984363710267637, 0.17918975066392506, 0.15544504660919578, 0.16817654666789095, 0.1508181557516307, 0.20048358037043668, 0.15422002074264074, 0.12010180027612827, 0.1007785083442222, 0.19486680893064445, 0.13326741270321618, 0.1596754098407861, 0.16195865886268312, 0.15625780054832306, 0.17157819002033448, 0.18553796128108446, 0.16880529792443577, 0.17079284086219726, 0.1632006447201677, 0.1750850852184016, 0.18344005264994923, 0.18708613246667094, 0.16949870584012883, 0.04104145260088554, 0.04679516963774766, 0.05160979257986398, 0.04897428598873288, 0.04840616931116293, 0.05216961736029846, 0.05011234033376499, 0.048085209956533204, 0.05808513475736221]}, "mutation_prompt": null}
{"id": "185991bd-aca8-4701-9505-2609350406b7", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay + np.random.normal(0, 0.02)  # Slightly changed\n                if np.random.rand() < 0.2:  # Adjusted adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget)  # New modulation formula\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced hybrid differential evolution algorithm with adaptive crossover rate modulation and refined mutation strategy for improved convergence.", "configspace": "", "generation": 17, "fitness": 0.16852883440233876, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "7e19ec5e-4157-480c-abbe-00f78717ec1d", "metadata": {"aucs": [0.35009286348581203, 0.34885409476918394, 0.3687928030020904, 0.36773102404996827, 0.3516320665114214, 0.36532447163433035, 0.3588476795517971, 0.34499638674748867, 0.39780902646542815, 0.10257578983050042, 0.09191727206608447, 0.1204306796364264, 0.07926099108792917, 0.08314641751442797, 0.07974480156684294, 0.08739732819555013, 0.09632249005688176, 0.10656986852608641, 0.09855313808099142, 0.09969530221095424, 0.07615982896142248, 0.0975037888950806, 0.08656276115006967, 0.09741114366518377, 0.09159309566450757, 0.10612394924981072, 0.0965990811195021, 0.070596473466771, 0.09050763278900431, 0.06683028420920567, 0.09209353680280419, 0.07598034034448009, 0.08233577153219307, 0.08599081177628831, 0.06580269957248597, 0.09079926285896323, 0.9238961735982648, 0.8184922218202062, 0.9232666172282646, 0.8628815764604716, 0.8965600520530788, 0.816614369679738, 0.9002495312120947, 0.8795524684274505, 0.7582590395518609, 0.14109651933998024, 0.13435348409651304, 0.15134466938895563, 0.1285222116186635, 0.15484381756636378, 0.13294111119304142, 0.17127916314375757, 0.1459195703970385, 0.1438273851284313, 0.18946512534633808, 0.2270092513354771, 0.1762001283154394, 0.20197342097886417, 0.16685504096636394, 0.2129150282674105, 0.19825359993774128, 0.2266440857343326, 0.22863795411657473, 0.08991985329655905, 0.0825816355002349, 0.08490695857855701, 0.0821073954680307, 0.08661209427549821, 0.07890421693784577, 0.10641808806316855, 0.1029496893492966, 0.0860016160478686, 0.08069976795599865, 0.10635590320952981, 0.13121826877989318, 0.09221540055299371, 0.07046064651495287, 0.0746919682138838, 0.07998220524240673, 0.07265848117110763, 0.07052115722446362, 0.0039514808558788195, 0.007473477932967709, 0.007630315662857545, 0.000489853270486118, 0.001211923958424399, 0.0015617244569843258, 0.0003372632448678248, 0.0018509109602815599, 0.040058473179217846, 0.07644539311720022, 0.0753172027020762, 0.08960222659515982, 0.06794596006574738, 0.07897578239235403, 0.12624131408822048, 0.09471485349466946, 0.12204179314271046, 0.12514801749926951, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04255102600094307, 0.0548224860173705, 0.0622556437311752, 0.07097836343965214, 0.06220057752634034, 0.053855962190336726, 0.05402344552809413, 0.052619449615485814, 0.05564077631352937, 0.3153415626849806, 0.3517603427094137, 0.32028139362109376, 0.3312181387059251, 0.2993479204112929, 0.31381111431020803, 0.3353579539696844, 0.3147564208153666, 0.31282944119785105, 0.07615811398538175, 0.07349838474154968, 0.06666190107482539, 0.09936637374977253, 0.0811719019045597, 0.0861644182359731, 0.06520048807784984, 0.06354747367513314, 0.07921460567923533, 0.16210521075903084, 0.12256680703982781, 0.16911868435392807, 0.12373013532689059, 0.17400998076146756, 0.13909201005143312, 0.13882264282779033, 0.12871221712380898, 0.12877672196330026, 0.19970387160347947, 0.2055986300785666, 0.2326837156075976, 0.2076756561963492, 0.2341176178990857, 0.2032243913424696, 0.21905812613555242, 0.2434319509384939, 0.20698015916312762, 0.12481695769724643, 0.1596343291359471, 0.17336760676910856, 0.14703775949896647, 0.14478226504093306, 0.13978501298324586, 0.15655604816118684, 0.1691044383896666, 0.14766410977717825, 0.1663238807443207, 0.15408249460640366, 0.16589671099834757, 0.16529762920372815, 0.1550332383256291, 0.17420296117622402, 0.1703646508653286, 0.1481063007249388, 0.2012656887853106, 0.17076616027701697, 0.16764041568655086, 0.17587870224403723, 0.1575132868481891, 0.1665163252374745, 0.17809583908641058, 0.17086629289639954, 0.16246886235321323, 0.1686137268820399, 0.15063695336905625, 0.13739220917866046, 0.15559716862874173, 0.2745346436489211, 0.16797512740847853, 0.1834882482360065, 0.15987362186725407, 0.13459243215906003, 0.31816096425429863, 0.2579046200749453, 0.2192003356709381, 0.3433372929465671, 0.18537433571805462, 0.16971741534041307, 0.13383608140110215, 0.140450663033714, 0.17587475753967718, 0.17475309872069777, 0.18267080032566485, 0.1722424408533929, 0.1727547032461898, 0.15834314180630804, 0.1742215841499446, 0.17441382049892873, 0.18696910994168725, 0.16803796430489015, 0.16282769901274274, 0.0771500764118277, 0.061945171901041984, 0.06058782957137632, 0.05933325913985954, 0.06654848570722383, 0.053035108566584, 0.06686786052759786, 0.06304834807964255, 0.05726306723107044]}, "mutation_prompt": null}
{"id": "ac9acf97-934a-4ecd-8719-fbb451ddfd0a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c) + np.random.normal(0, 0.1, self.dim), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR + (0.1 * (self.budget - evaluations) / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced dynamic mutation strategy using Gaussian perturbation for improved exploration.", "configspace": "", "generation": 18, "fitness": 0.16528846236468858, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.16.", "error": "", "parent_id": "7e19ec5e-4157-480c-abbe-00f78717ec1d", "metadata": {"aucs": [0.31105514966819103, 0.2911588511935128, 0.3256652547124065, 0.31125632610691967, 0.3212533368641268, 0.3217653031767038, 0.31034022789764726, 0.3196884023181866, 0.32572237076904664, 0.010426195491028412, 0.023272871072205326, 0.021365261533335844, 0.024496275376025944, 0.017483073970118723, 0.013066303892165121, 0.011186276855777, 0.023720815537251472, 0.00623267019016549, 0.07292420129842381, 0.06835156678012755, 0.06027598126395095, 0.07291327077669374, 0.06497842738783877, 0.08822228645900554, 0.06835745273528504, 0.08790502299445524, 0.07482208838207771, 0.059133731735300565, 0.05813605789229892, 0.048213411135683226, 0.06042671356988394, 0.05334708590845094, 0.0656667058515652, 0.072303366925485, 0.061320207878419075, 0.05129755771655364, 0.83827292095256, 0.8656800207467467, 0.737698604656488, 0.8357513083403758, 0.7123561324258811, 0.44397747273725374, 0.7857486129865232, 0.7104658736751186, 0.9221843864194024, 0.1608946996387729, 0.14923200065587516, 0.14887609828855186, 0.165629931823575, 0.13569802287839916, 0.1704243661631184, 0.178064673552489, 0.1518964078409485, 0.16946037032026529, 0.23894040634309643, 0.2567565547452808, 0.25162363673624655, 0.23171505035326612, 0.24233902528636053, 0.24485429122082591, 0.2253614277175724, 0.22164048672857062, 0.23767532392981616, 0.09345360432309058, 0.09184172255456557, 0.07159147470121952, 0.07480505439087137, 0.08825937011321472, 0.07506679505363523, 0.09686016829690447, 0.0859302023699392, 0.08971228969611078, 0.08256323236390417, 0.09152739256407072, 0.08397491790036471, 0.07542313564999892, 0.09900365240313236, 0.08116179440340587, 0.1065369857455748, 0.09651879020935772, 0.08289065000526608, 0.006798425943357556, 0.005252202955796426, 0.019196635763065406, 0.023094250373683956, 0.01806852560981609, 0.009175129837963314, 0.006509279833949999, 0.003438805710969439, 0.01135935997162596, 0.08888237755411155, 0.08996808516857235, 0.09700328456883289, 0.07519841127919247, 0.06489682146661346, 0.0948867869134119, 0.07971617857317925, 0.1294219269803063, 0.06647535702917684, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050492046681306024, 0.06189066268631782, 0.0558672486576659, 0.06645347622643116, 0.06790621586063661, 0.05413800677742164, 0.06663092743077481, 0.05666368972414826, 0.07060723821305914, 0.31048551712545736, 0.31699214083066596, 0.31735366178169966, 0.30769668755204116, 0.2763169223557925, 0.32086526169997076, 0.3247003817326023, 0.3217605850191583, 0.30279211191483446, 0.07675787541214574, 0.07154486255604697, 0.07611039710805867, 0.08954555039810985, 0.08101093962434047, 0.07950868864037386, 0.06954823720745174, 0.07112725152176158, 0.0814792449352244, 0.14772438479364192, 0.20001191593299394, 0.18334773910163826, 0.19492761008716641, 0.1813819168296692, 0.1805039636984508, 0.17301475346651773, 0.1633178798040743, 0.14721859168946516, 0.2090969287100276, 0.2267054538805332, 0.22544747034200274, 0.21652039283210256, 0.21347865595402826, 0.22218311973257332, 0.23023855797798687, 0.2382746465347746, 0.21323300977498605, 0.14503691147073683, 0.1625076465724482, 0.16360459602770383, 0.16215879349104412, 0.1645834734594186, 0.14219329803273906, 0.17684416385372992, 0.1633050634952391, 0.15324205129070723, 0.17839492222232167, 0.18349444584523955, 0.15896239012957558, 0.1756807847107602, 0.19915175361461657, 0.1983927118029063, 0.17421515293016676, 0.1548390408150272, 0.15898505887082515, 0.16239248020601826, 0.1565616521809854, 0.16606331477162017, 0.1802700634276453, 0.13982602937148203, 0.15421773753023338, 0.16077792844831018, 0.16494587777081493, 0.15769512215280956, 0.3788796078863703, 0.19844303118059092, 0.36254021807654213, 0.15869975845093465, 0.178447052018751, 0.1536363401430082, 0.16889548078225813, 0.1637865473739033, 0.46985845706384943, 0.4021247990635447, 0.16388821652089702, 0.29212639344662217, 0.1663468531394917, 0.14952865913613023, 0.3069862775034292, 0.19309561782052254, 0.19219023959636483, 0.374126294814775, 0.16401227827793896, 0.1918267520638206, 0.16391940352789902, 0.16908014211547562, 0.17873856434561652, 0.1847042284146312, 0.15836115178809107, 0.16776870811619427, 0.16595996176452832, 0.056805401157906776, 0.05479795169247059, 0.05899663218459805, 0.059714978817136055, 0.055725050200417736, 0.06192738365725159, 0.053967177792179744, 0.06410057483242948, 0.07875511193696516]}, "mutation_prompt": null}
{"id": "4411dbd7-3969-4e9f-82a1-bd73cd45c776", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.85  # Crossover rate\n        self.F = 0.75   # Differential weight\n        self.mutation_factor_bounds = (0.4, 0.9)\n        self.weight_decay = 0.95  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            # Dynamic population sizing based on remaining budget\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])  # Retain best\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                selected = np.random.choice(indices, 3, replace=False)\n                a, b, c = self.population[selected]\n                F_dynamic = self.F * self.weight_decay + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.2:  # Adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR + (0.1 * (self.budget - evaluations) / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]) or self._crowding_distance(self.population[i], trial) < 0.1:\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.1**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n\n            # Local Search Intensification\n            if np.random.rand() < 0.1:\n                local_search_point = elite + np.random.randn(self.dim) * 0.05\n                local_search_point = np.clip(local_search_point, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_search_point)\n                evaluations += 1\n                if local_fitness < self.best_fitness:\n                    self.best_fitness = local_fitness\n                    self.best_solution = local_search_point\n\n        return self.best_solution, self.best_fitness\n\n    def _crowding_distance(self, individual, trial):\n        return np.linalg.norm(trial - individual) / np.linalg.norm(self.upper_bound - self.lower_bound)", "name": "EnhancedHybridDifferentialEvolution", "description": "Hybrid Differential Evolution enhanced with Adaptive Mutation, Metropolis Sampling, Local Search Intensification, and Crowding for improved convergence speed and diversity maintenance.", "configspace": "", "generation": 19, "fitness": 0.16112341577700384, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "7e19ec5e-4157-480c-abbe-00f78717ec1d", "metadata": {"aucs": [0.29303912726462833, 0.2507734289677087, 0.30272316290146095, 0.33212549364312727, 0.3058711492059184, 0.3258859791843871, 0.2749299356891264, 0.28877446682819985, 0.27380740835220585, 0.04836358371897931, 0.05612527115718935, 0.05329006038805362, 0.06971996387717172, 0.05524834371830656, 0.051966824707808335, 0.03550488559058851, 0.05677056375222078, 0.03729568070844835, 0.07504370230536317, 0.07720145996730154, 0.07871322637747524, 0.08034923602051403, 0.07786784922836831, 0.06917024087655077, 0.0778798353213842, 0.07261691476426346, 0.08706449144601702, 0.06511120493268685, 0.06897215474934315, 0.0643654762347966, 0.06385782292126219, 0.06897247785970484, 0.06588523507620625, 0.05667441642374049, 0.06627945784149758, 0.06137636913528277, 0.8225534399930843, 0.8365645621506087, 0.874665311221873, 0.9043400682297499, 0.737747325311384, 0.8662280691195609, 0.7163186329385247, 0.8429676904822152, 0.9205107961929843, 0.13042651969138608, 0.12371383871924713, 0.16530865761006497, 0.12872669229538802, 0.11177755440563963, 0.12397452191375447, 0.1360092295673545, 0.14016528304151266, 0.13767157772308947, 0.20404940655093706, 0.2185630350175949, 0.19245356508627698, 0.21755920375634874, 0.19389631660522588, 0.19939553573544244, 0.23277765307616105, 0.238576100014237, 0.23341363335582976, 0.08501380224235033, 0.08882984805869132, 0.06643838300312777, 0.08821320559524504, 0.07774294421875072, 0.11173883163706178, 0.09878582497539523, 0.08470164639067657, 0.08286647227347899, 0.08945573583317723, 0.07064829618208446, 0.08597849126168167, 0.10503393879251466, 0.07963173649402866, 0.06763249794071002, 0.06985917357299953, 0.07116936510596583, 0.06835122511472802, 0.011631729656493395, 0.00655518188900317, 0.005233391317502001, 0.017679832134607887, 0.012655342679314674, 0.015039968022248273, 0.008882702828917344, 0.015273692377859138, 0.008430261352027846, 0.12628415148002825, 0.1145312884560501, 0.1451943085152354, 0.1562419917265928, 0.11651179093588726, 0.10658944731504183, 0.1547403550116938, 0.1654370854829833, 0.1469074587963789, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046490675070558374, 0.045291821976266466, 0.048900416805058966, 0.046569059229950804, 0.03952770706274711, 0.04926786219027457, 0.042458964218451856, 0.04474298479200933, 0.07457310578375964, 0.2826069579775119, 0.2854511225761973, 0.2798271181223738, 0.2768738352080451, 0.2664175067434609, 0.2907970379030199, 0.2813351842266769, 0.2932921391180914, 0.2611681198372847, 0.06812377777119272, 0.06577770940791161, 0.07112837137456551, 0.07422795019493822, 0.07936722922278583, 0.06297765217355922, 0.07336035637717964, 0.06037016686264818, 0.06663654015984888, 0.12651892104295293, 0.12812660495587447, 0.14133543968894613, 0.14292709236891332, 0.1304216084337979, 0.1272010685898436, 0.12598860047419402, 0.12102917919860268, 0.15223227993226607, 0.1964784395358975, 0.19365835322688085, 0.21947447603007042, 0.21308077467838082, 0.2112034951213927, 0.20126450230694093, 0.19953600240325564, 0.22166526674330211, 0.20287380031984625, 0.13874610793397169, 0.15725515869005235, 0.15261241352538057, 0.14686133317767258, 0.13951059066795934, 0.14832359806955686, 0.1715270683830291, 0.16667434804402914, 0.13995543239495034, 0.1752924393830133, 0.1786640959810578, 0.17701502117283052, 0.15786966571069827, 0.1670671999341795, 0.19072430866997447, 0.17043875834406552, 0.1634929148665748, 0.17579258423752075, 0.16135279473693243, 0.1544188076040509, 0.1503573627101994, 0.16319256279729455, 0.16585386850132944, 0.17052929511956594, 0.15191850249457095, 0.16301787252037048, 0.16220937669279334, 0.15225521388563434, 0.16130980696647534, 0.14975059342305996, 0.29423202384285274, 0.16974173972664863, 0.15088013105089226, 0.16602927572787918, 0.26943493232070437, 0.15337583566272128, 0.2861722768497651, 0.2894860567714397, 0.15961526846498586, 0.16392210173578747, 0.23375621043661143, 0.29559296504095056, 0.19626871817095348, 0.18653749139955933, 0.22848415860111093, 0.16934433277187733, 0.23131090317236425, 0.19215427382117123, 0.1761709599496879, 0.1815758428744071, 0.168706601936622, 0.1774296286888093, 0.19729773072627288, 0.17940505198335577, 0.05520018683470829, 0.05982739531678838, 0.057132395585251516, 0.07489413331695105, 0.07218869378583681, 0.06201233624907343, 0.05915648305103516, 0.062167541633218026, 0.05980523664271897]}, "mutation_prompt": null}
{"id": "f342890e-03ae-4342-8dd3-e0ecd502c488", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                # Adaptive scaling factor\n                F_dynamic = self.F * self.weight_decay + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:  # Adaptive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                F_dynamic *= (1 + (0.1 * (self.budget - evaluations) / self.budget))  # Adaptive F scaling\n\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR + (0.1 * (self.budget - evaluations) / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "EnhancedHybridDifferentialEvolution with Adaptive Scaling Factor and Differential Weight to Improve Convergence.", "configspace": "", "generation": 20, "fitness": 0.17576986177243972, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "7e19ec5e-4157-480c-abbe-00f78717ec1d", "metadata": {"aucs": [0.32065550489775485, 0.34062371312113826, 0.28090584047233225, 0.35204909189069833, 0.3645303614029022, 0.32703602632620066, 0.3410489119185379, 0.32009564994312045, 0.2938079462265837, 0.07952281264381089, 0.0746240482357915, 0.08755969657919938, 0.053437794076664935, 0.03576403246326476, 0.0571819940838697, 0.08158803871736187, 0.04994671154793562, 0.08605596303825691, 0.08099318871383732, 0.07044394581795366, 0.09992447924122094, 0.07108393401783919, 0.10726040717207974, 0.08006266442009002, 0.06690290787299324, 0.08745501104994202, 0.08880347671799482, 0.06463064031765808, 0.05683100788651829, 0.06257407112481905, 0.069156331625703, 0.06690781613554686, 0.0711947848988097, 0.056042413851019046, 0.06929913556829725, 0.05788776765283277, 0.8770485628294702, 0.8737680423332851, 0.6622552676292413, 0.9280705075156441, 0.8924244573090191, 0.7018422553697249, 0.8299096302772355, 0.8079157543329758, 0.9373771604386298, 0.17027545304993585, 0.14034278884185192, 0.13308229422311746, 0.13990336405937687, 0.1555099656806047, 0.19204890873970248, 0.13484022680475083, 0.15348018082633808, 0.15360502718991143, 0.23367992648067692, 0.2479342534328952, 0.2166585467589187, 0.24188779243610437, 0.5045457747802982, 0.213991291686071, 0.2909969801663287, 0.2993650734464671, 0.18657326330384938, 0.10704394278295348, 0.12384382759923496, 0.09997722632764017, 0.1042087905079716, 0.10128076476585679, 0.08372649079929273, 0.11615276535224894, 0.13132170102930563, 0.10176458473489836, 0.09873159503525819, 0.009224911645794087, 0.08285978742233235, 0.0818137459730931, 0.09353426721188496, 0.07590619892249628, 0.11020538566932425, 0.09370636326336912, 0.08997654939334787, 0.050052408018437244, 0.0493297555501544, 0.026552687769208716, 0.036595784961509725, 0.08817305848040091, 0.010518250498822046, 0.05656531624707928, 0.10712063005135775, 0.007425379040158386, 0.19762344925150888, 0.1339828359833184, 0.19054205602466612, 0.20287380576505376, 0.1441540521397432, 0.15558093682393137, 0.15733108219637892, 0.16762734878934493, 0.20687938408549733, 0.002964413172739322, 0.006924385563089386, 0.0001450640047682139, 0.011189343585635503, 0.0011994859201709396, 0.001056221524027623, 9.999999999998899e-05, 0.003610325486670618, 0.0019136434383577594, 0.0797729100576744, 0.09393187433092465, 0.05823269662697417, 0.04364092310147316, 0.05543201023165789, 0.05283835076813759, 0.06048696227497452, 0.06652680146993994, 0.0607172988615714, 0.26963366889127294, 0.3240740785825026, 0.308408643331603, 0.32689650515404634, 0.29332118162977194, 0.2920567603170483, 0.2984301876950499, 0.3003011803030958, 0.3388678543829835, 0.07155699365827006, 0.058738522920395164, 0.08166283815640529, 0.07561211353261954, 0.07273414863743766, 0.06190991193804407, 0.05619359694623649, 0.07678139381649429, 0.080421073345749, 0.10667865110315489, 0.14282671171450434, 0.13944649459497382, 0.22889482162312247, 0.10852972522114035, 0.14022703921599589, 0.12797586611956335, 0.18443595000854407, 0.128760952233812, 0.2137528219484064, 0.20253438438640103, 0.2641496028663203, 0.20948844335666272, 0.20917537852931933, 0.21053545419740194, 0.22383099673686657, 0.23533076670913622, 0.2371119499637827, 0.160465210173927, 0.15483229870484772, 0.17458088862040255, 0.14167765595527848, 0.15655565938349536, 0.16135688099280887, 0.16160988488295047, 0.18187013083431425, 0.16965310487346164, 0.17243093757147676, 0.16452668361619638, 0.17706729454099845, 0.2058049549785531, 0.1661998248901846, 0.1597309764422813, 0.1787796192678277, 0.18408323336609955, 0.1767009351736598, 0.15301615826335657, 0.13499495391756045, 0.15815155809140402, 0.1633644239990234, 0.16803544783794133, 0.15081569178951681, 0.18892218868148203, 0.1701712415792923, 0.20712837277206197, 0.15326740948499662, 0.45398449902825544, 0.1690243011547844, 0.14846711443399618, 0.15445318235232952, 0.1551304394437819, 0.15957814786144897, 0.45565401432228003, 0.3612139551402217, 0.28404596918634395, 0.17736640598080156, 0.16938108128538665, 0.20094729114833543, 0.19743973171911644, 0.3325383796890765, 0.17847261682017035, 0.1966680893872813, 0.19114274675778908, 0.16882368626929034, 0.1783953767480585, 0.1749789763949231, 0.16085474846321945, 0.1610951961333159, 0.16801048092668402, 0.16096117589246728, 0.17869960048257783, 0.17563466408614636, 0.046160591183652455, 0.04696024141517574, 0.08419846313656798, 0.06326545575396869, 0.0540167780491716, 0.06289802321050486, 0.09218462010042627, 0.06790877176913235, 0.05054434052209922]}, "mutation_prompt": null}
{"id": "dc1a2d0c-f520-47a3-9d76-3a21952a097c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.8\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.20:  # Slightly more aggressive mutation threshold\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR + (0.2 * (self.budget - evaluations) / self.budget)  # More adaptive\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced strategy incorporating diversified crossover rates and selective mutation strategy with adaptive learning rate to accelerate convergence.", "configspace": "", "generation": 21, "fitness": 0.1778536202647378, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "7e19ec5e-4157-480c-abbe-00f78717ec1d", "metadata": {"aucs": [0.3564959554528998, 0.290337644718184, 0.3376418390408096, 0.3454258163012215, 0.3476458693983905, 0.37553901703158876, 0.32600939662016337, 0.3665502858509909, 0.3035378314086504, 0.09479688916080353, 0.09128801950737309, 0.12626142848513278, 0.06851085804588908, 0.08591670707314025, 0.10322212655632779, 0.08548381432671814, 0.06869580400978526, 0.07430984844319122, 0.07006405272975047, 0.07121498203561805, 0.06820712500852621, 0.07038302608780356, 0.06564698897147248, 0.06891936111564823, 0.07035637566667519, 0.07490134710100516, 0.06796240916575791, 0.0710160668148101, 0.06848210594500048, 0.07662743207627609, 0.090961944545496, 0.07257425004416018, 0.07549254148110851, 0.06046728245041011, 0.05212318811268546, 0.046972213772381144, 0.7739953661290853, 0.6890056408765838, 0.668284155512764, 0.9469873797598973, 0.732081114683537, 0.8003485467189109, 0.8616977229155572, 0.7984337507622428, 0.8158851957586615, 0.18042049391691106, 0.1405841710756136, 0.14991526441308323, 0.1645200937188196, 0.15958228748274905, 0.1785477744320325, 0.08106551178176813, 0.13476781771573665, 0.15567227110972148, 0.4051611298912977, 0.2638043482521759, 0.34090435244641226, 0.3481684691813508, 0.41871920043183686, 0.2463805553331866, 0.26719150664762614, 0.2769008060365431, 0.3621284624226291, 0.10181900538214539, 0.08724703591650596, 0.09084598720731152, 0.10922629982413401, 0.09104968642135591, 0.11669372693733437, 0.1360740194388692, 0.0985572300515567, 0.09486100036197331, 0.10149999524618447, 0.008693688556577817, 0.015954148277529723, 0.11449317126450931, 0.17320053976365501, 0.0821475856364976, 0.10369786810257953, 0.10071632653893703, 0.08091021467861936, 0.04619723388708841, 0.08137046601295295, 0.08113602988547719, 0.06459811119501624, 0.0790019054175527, 0.09650634790130042, 0.07697765766935794, 0.0751065225071661, 0.04136569849780769, 0.07365332018769932, 0.15242644096065672, 0.18330535917102864, 0.17198701930552784, 0.1542382949550949, 0.2030588128841102, 0.2016690515209909, 0.18098475105618883, 0.22652024966052886, 0.02829458386584649, 0.0016321584751364249, 9.999999999998899e-05, 0.011428723569204657, 0.0042539246690297405, 0.012690207978934498, 0.004782315885767607, 0.0025581631934077365, 0.019793996958284543, 0.07573259849170388, 0.07963624835970129, 0.08257185446903437, 0.0666139572023925, 0.08290335108365565, 0.09629671815893348, 0.09705513513368147, 0.07076185978514715, 0.07761210187014345, 0.3370691225047271, 0.335147588859698, 0.3112261146442159, 0.3488967213602122, 0.3091751978250157, 0.3358575987998379, 0.3512771913029814, 0.3059129889976032, 0.35555692628019353, 0.05623788280217301, 0.08068106639290784, 0.05736021745308062, 0.062434054910567305, 0.07050827507771318, 0.07148576343497604, 0.04877512189237476, 0.07017995919263953, 0.07265848670205721, 0.11535315185708228, 0.12312498448114928, 0.11842175776965747, 0.1377881785732743, 0.14550411681415376, 0.1205545914964381, 0.1206172470014315, 0.1439346926099273, 0.12975492604448335, 0.2343480855293627, 0.21342741217106254, 0.23549672205669003, 0.23047774022879874, 0.22587410259271523, 0.20440555674355743, 0.2434510697311929, 0.2429982591264903, 0.20592681472538454, 0.16658276570407593, 0.16988922834240006, 0.16784863733202926, 0.18126677138598346, 0.1798224886316273, 0.17252754598976716, 0.18281659790267324, 0.17963071002810083, 0.1902344981408325, 0.15290171080010573, 0.1505774408345798, 0.1810814260186454, 0.20357740359149368, 0.1833783694466058, 0.15194432965408666, 0.16937154814977928, 0.1636362416666428, 0.17261790985171233, 0.14257415708954158, 0.15166164831823004, 0.15702100497878058, 0.17117360068336585, 0.1523149467634426, 0.1582794083886906, 0.16693407395492377, 0.15525875833265723, 0.16829006950605685, 0.16003555671598968, 0.1156212554117455, 0.14409711955227444, 0.291219077550978, 0.16493114866940328, 0.28640533519073486, 0.1719188456884967, 0.2803129853841331, 0.15452706043973596, 0.4220368122478576, 0.1577768500181288, 0.404189027106408, 0.2037013078496105, 0.1421528328786842, 0.1875324144734598, 0.19246357422966331, 0.2010088396875359, 0.1861557331492425, 0.17119145120251, 0.17275269095081636, 0.17164444048802419, 0.16183934622952134, 0.16767910868978397, 0.1692074422323402, 0.16723752283142346, 0.17468774757512562, 0.17238398557129841, 0.06909696796831866, 0.05693171401399655, 0.05047261488544996, 0.05564838683566853, 0.06102307369847515, 0.07479272461381148, 0.05555721593851448, 0.06632510278457326, 0.053007749562566264]}, "mutation_prompt": null}
{"id": "39382a27-8652-4b8c-b0f2-bdc83dc56a6a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                # Adaptive crossover rate decay\n                CR_dynamic = self.CR * (1 - evaluations / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            # Elite migration mechanism\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Incorporate adaptive crossover rate decay and elite migration mechanism to balance exploration and exploitation for improved convergence speed.", "configspace": "", "generation": 22, "fitness": 0.1856714487526595, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "7e19ec5e-4157-480c-abbe-00f78717ec1d", "metadata": {"aucs": [0.3848421458956971, 0.3839358848104938, 0.38111093952340147, 0.4098166827292993, 0.4472751757943161, 0.427720233684704, 0.41385546474178214, 0.41918372286985905, 0.34335929582896185, 0.1275117344139346, 0.13686062208177951, 0.1607711116958429, 0.1277308389068894, 0.13316987064360397, 0.15826507107398924, 0.13426575612348557, 0.13306298874504352, 0.1336356723710953, 0.1479950952878275, 0.11924571238212489, 0.09472085898614424, 0.09394025067157474, 0.10607028156712672, 0.10463677594269061, 0.13856592973634907, 0.13176674593714066, 0.1002532096479033, 0.09476983082240253, 0.1030456253779013, 0.09596974647615242, 0.09817082513575026, 0.09450538812555898, 0.09128518669936891, 0.0808290518728847, 0.08777046475103711, 0.08963979766340269, 0.9455429979786021, 0.9204064329121027, 0.9070282406084881, 0.8898488195965224, 0.8376817451448993, 0.8062274896155347, 0.8786463353821063, 0.8659427947262398, 0.9336075431064326, 0.16472866110038464, 0.1631362667695606, 0.15314482322259027, 0.1948705793845762, 0.1838128193632096, 0.1463142958527991, 0.1096896718357715, 0.18424848233925617, 0.18562944081417454, 0.23931676299440574, 0.2451404866174235, 0.20695813194243096, 0.18558718743860747, 0.29217868799780367, 0.43005377463384653, 0.396988608587198, 0.19887279285787296, 0.21878229470620714, 0.12418491653173458, 0.108759093949224, 0.07536847429184113, 0.11328144518257999, 0.11631465761678306, 0.10684112735597973, 0.14068156393244136, 0.0898518685508588, 0.1063621246740899, 0.10081519942070682, 0.11772106354313638, 0.00876931224968902, 0.09057976110967225, 0.10497160805764616, 0.10034185503113391, 0.11565754063619971, 0.13647567898560886, 0.09041924724198103, 0.04436989575971095, 0.01149946141759317, 0.020323112706591706, 0.0003345423603589026, 0.027743838298921353, 0.0008558635966342543, 0.0035134636329324787, 0.017579561532718113, 0.0011628584785852158, 0.11307892156251509, 0.1120486478468381, 0.12471773207247971, 0.08115166219586445, 0.06276569789312147, 0.06929266871608164, 0.07137851991928512, 0.11601499910288404, 0.07889740599507822, 9.999999999998899e-05, 0.004542588179126006, 0.0006406360858589588, 9.999999999998899e-05, 9.999999999998899e-05, 0.002698335723398171, 0.01866771349995766, 0.0019858350914697676, 9.999999999998899e-05, 0.06006962305935959, 0.06543723996754869, 0.07075852095265767, 0.06492575836708925, 0.09918610205822187, 0.07316234984135095, 0.0650549716165526, 0.0665488323634641, 0.06565827123019463, 0.3252330176851371, 0.34795016944229806, 0.3853191953751939, 0.3505763370431203, 0.3291748946150074, 0.3491125144651067, 0.3642801556284201, 0.33706251038958013, 0.34852827493749605, 0.06842927331399096, 0.09126541678859668, 0.0844475592285322, 0.08429150990951018, 0.06869450803374944, 0.06925127243565765, 0.09129802657138009, 0.11110725183068115, 0.08085515937950893, 0.13436700347225028, 0.13678305544970504, 0.11842175776965747, 0.13451530328854355, 0.12118937730925083, 0.10798713552684513, 0.13106012429979075, 0.11760119496114307, 0.17241609393687507, 0.2216710694494073, 0.22299659207910705, 0.2413500287021505, 0.25943456174871615, 0.2383352909311761, 0.21917049634777808, 0.24357045243872744, 0.2852262004521735, 0.25963947319984093, 0.1678564256183941, 0.16221986537526611, 0.15916201235459249, 0.14397317705537627, 0.1533158745587756, 0.17303172951436896, 0.16984773719748025, 0.18603201042683215, 0.19413078637529657, 0.1632063444665195, 0.15868624999626868, 0.16301303888827445, 0.1604624768165217, 0.16074341689025207, 0.18756589102965604, 0.1613560411129471, 0.1804600490788394, 0.20056586783820085, 0.17487089596297467, 0.1769244090575106, 0.17313415273659116, 0.18379856661543603, 0.17024435667657567, 0.17171069080059664, 0.17933313279520735, 0.2165587675908489, 0.16477574263844885, 0.40815145853199397, 0.25405263164692005, 0.13594580817011703, 0.3057039936641128, 0.17639514295677272, 0.15370216990883623, 0.160311609547931, 0.13203290254572275, 0.45140515158957895, 0.27053884611143375, 0.16884899754516214, 0.1549163474364723, 0.1787312390207808, 0.13396090412296913, 0.2913052836499702, 0.19650500468133614, 0.18144117730788478, 0.1872051984075369, 0.17087992043706113, 0.1727526909507987, 0.19157574436628888, 0.18517947979448635, 0.17122064225347333, 0.16994825550345427, 0.18948646493828758, 0.17350678127239805, 0.17389789486400187, 0.058108669242095345, 0.06222155832494025, 0.06074822508965483, 0.06226388353581114, 0.0632488500084577, 0.05874594156875135, 0.06641406838583774, 0.07927329449534026, 0.06701240476130665]}, "mutation_prompt": null}
{"id": "5fc88d37-b57b-4e3d-ad1c-edf0c129962b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                diversity = np.mean(np.std(self.population, axis=0))\n                F_dynamic = self.F * (1 + 0.1 * (diversity / self.dim)) * self.weight_decay + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                # Adaptive crossover rate decay\n                CR_dynamic = self.CR * (1 - evaluations / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            # Elite migration mechanism\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce dynamic mutation factor adjustment based on population diversity to enhance convergence speed.", "configspace": "", "generation": 23, "fitness": 0.18539732447452886, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "39382a27-8652-4b8c-b0f2-bdc83dc56a6a", "metadata": {"aucs": [0.39967061501719825, 0.4483748816703391, 0.4197813219362071, 0.4282499658350204, 0.39116730561834245, 0.46155402449003746, 0.40606237772616427, 0.38491161379173344, 0.3551406606618507, 0.13822835886129248, 0.11496408187479279, 0.13865238842285454, 0.11160254038956174, 0.13221821435138903, 0.12438470314105887, 0.12741695111218065, 0.118209430783495, 0.14706954398443417, 0.10112016715696504, 0.10307267400453057, 0.12394972728104425, 0.08707320607701663, 0.10923246934006514, 0.10925643453976264, 0.11873265782083453, 0.11180370659789063, 0.0892234852459669, 0.09184860628755209, 0.09202521542998932, 0.09308518592154158, 0.08615132817825721, 0.09303095474008372, 0.08329334713648973, 0.09507877040129609, 0.09667815166171223, 0.10038084620021637, 0.9460569690889515, 0.920678735511707, 0.902293172298419, 0.8967675792537454, 0.8279559111686732, 0.8296577274336422, 0.908099702027577, 0.8234457836198109, 0.9342486316871694, 0.17254986282769647, 0.17220177984803375, 0.16493204215021984, 0.16458670818467946, 0.1504382844669353, 0.14466119099039587, 0.12048025720886801, 0.15531126316937494, 0.1932945996040102, 0.2089703182730107, 0.3239986948421709, 0.2179009376806652, 0.18875172138597918, 0.28911111542197976, 0.3546187731812337, 0.24129313049595125, 0.22607734958497872, 0.19042256947559033, 0.06794510795432629, 0.09606213317252754, 0.08746775451666167, 0.08165808482421466, 0.11015587418229456, 0.11569999426291, 0.13209904924682614, 0.0996583470078436, 0.10348542038797282, 0.13797677147362264, 0.014429389716067997, 0.043063263303210975, 0.10541092981585731, 0.114197761509932, 0.11717569528448735, 0.12885705134401637, 0.11204053885986864, 0.1418418943833225, 0.0010963069309626317, 0.021056253938423808, 0.03556152881980834, 0.00013027792138420313, 0.01537868813001353, 0.00806560585011451, 0.01599928972679554, 0.03585780882007661, 0.029606650935845358, 0.07602201461280422, 0.14562330065045648, 0.0790824646476943, 0.1083004510245189, 0.0708773977601479, 0.03480012086776241, 0.08647096183235004, 0.04858453542271579, 0.11782831511421932, 9.999999999998899e-05, 0.009047824797463577, 0.0008352075631519185, 0.009616267189796024, 9.999999999998899e-05, 0.006893593180578361, 9.999999999998899e-05, 9.999999999998899e-05, 0.001637356202520146, 0.06123350512533399, 0.06640095825014891, 0.053642932786464925, 0.06008562037907572, 0.07649326452118055, 0.07247717999931103, 0.06691784638359022, 0.07197449654459465, 0.07455748791663497, 0.32989239273059623, 0.3428356661136953, 0.3493805718685533, 0.32880072215132694, 0.333324503723444, 0.343369783665176, 0.363846488085649, 0.34927698706315136, 0.3325272306656323, 0.0879194382219528, 0.08602078068402663, 0.06885770158147442, 0.09875678656564946, 0.09899532330394234, 0.08875187863997058, 0.06329719911525367, 0.07209269912364635, 0.0713103179479434, 0.12651234019211077, 0.11338492830265112, 0.1327236277756536, 0.18461313611810715, 0.12487082975847519, 0.17090402198481303, 0.1116334707791733, 0.1313642190859069, 0.12867533555601218, 0.21623274354243616, 0.23212352891942978, 0.2026261783492267, 0.2231399485898582, 0.22590043439695529, 0.210070403769947, 0.2501120694158684, 0.27800780809767356, 0.2371674387223709, 0.1993810739021432, 0.15276311837482304, 0.13853731683394266, 0.17902353024534312, 0.15540502038236736, 0.18574759623443338, 0.2006199003621265, 0.16666940764972238, 0.20054385246799689, 0.16428263019408718, 0.15914810822562508, 0.17886951749471824, 0.20895427308251424, 0.15161386157359646, 0.15683195350465906, 0.1868642232375014, 0.1625329791812441, 0.17909158286754756, 0.17013518293903473, 0.17594907513171565, 0.18480395029582075, 0.20378204644833142, 0.1589820802546894, 0.16627089743925605, 0.17566575074306034, 0.17455815455347679, 0.1659334442857867, 0.3888570450081583, 0.15491885475270228, 0.15535975574630578, 0.427352330180371, 0.2447079209817148, 0.14794894101817335, 0.17308509277174566, 0.16009173273709254, 0.3649075401362628, 0.3634406907823152, 0.17432781261514196, 0.3227624338197975, 0.15896321424440152, 0.278405481695046, 0.32375223775409334, 0.192935381783774, 0.1920667215225249, 0.18730133373734392, 0.1610379083805581, 0.17970765529310306, 0.16063751528580306, 0.17384218922931283, 0.179539423528012, 0.19908691066536144, 0.17792098917580257, 0.15952670030990534, 0.18713933995411858, 0.0639999665096318, 0.057580225191097845, 0.06663514756164401, 0.06645612764853137, 0.06361590056660282, 0.06271557580711995, 0.06381355140453848, 0.0658331635360433, 0.059988512988223386]}, "mutation_prompt": null}
{"id": "ce2591ca-ee4c-4167-808d-ce81bc17401d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + (evaluations / self.budget))\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                # Adaptive crossover rate decay\n                CR_dynamic = self.CR * (1 - evaluations / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            # Elite migration mechanism\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce proportional mutation factor adjustment for improved exploration control.", "configspace": "", "generation": 24, "fitness": 0.18357914225338623, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "39382a27-8652-4b8c-b0f2-bdc83dc56a6a", "metadata": {"aucs": [0.38046368435408107, 0.3394721013237547, 0.3956444864704096, 0.36697654628278276, 0.37111146592937716, 0.36368567728593615, 0.4080912892982196, 0.3878638972841838, 0.35030182865850523, 0.10790778961939618, 0.10279575879304881, 0.11911708690081924, 0.09231867398306515, 0.1518005025276592, 0.1060924971307815, 0.10277673311390989, 0.1124055170846544, 0.1423830094941797, 0.1256446392658157, 0.14831620434195125, 0.14733064477418123, 0.11914139754612885, 0.10333289832471004, 0.1244038841648577, 0.12776319741057884, 0.10748511743760714, 0.1352668865715193, 0.08954608351446036, 0.09010959973731936, 0.08006105729099966, 0.09813246806186648, 0.09368712562984838, 0.10824700559676625, 0.1309820131229641, 0.08770730388443371, 0.09647479324270258, 0.9074965186070091, 0.837595112721347, 0.848375239452476, 0.88661893571191, 0.9328791788065209, 0.8855302735880983, 0.8933514654470653, 0.921826822902554, 0.8976399064730715, 0.16850427334005635, 0.13079972457550282, 0.15555917104986927, 0.14223848706224196, 0.13529149827010445, 0.1431250682824693, 0.1255482285995584, 0.1808430609614481, 0.1603286933831778, 0.20773224746753194, 0.21031954367147043, 0.1905625475003192, 0.46178091535985544, 0.26930434257773306, 0.2376164686436415, 0.23017791072904514, 0.23595350332375253, 0.26628248052004033, 0.0767940678603618, 0.0914789934013055, 0.1067993581167489, 0.10245182581781975, 0.09680877078554662, 0.12159964332917972, 0.10050058131001993, 0.08694272300522188, 0.09853567965962395, 0.039415000648728715, 0.01651011395614077, 0.09491497009191696, 0.10322504239816532, 0.12283363920327917, 0.10913038155748545, 0.07429307504634586, 0.129794080796934, 0.07877048265985287, 0.03804319613273621, 0.024102169258367945, 0.0012922433162332325, 0.00010504891264973004, 0.00028025894987682154, 0.004190512539252622, 0.07084412006780061, 0.01605550310636006, 0.011660780582422925, 0.07411307763293462, 0.12996481570298601, 0.10864634099815662, 0.07801021328430835, 0.09201718033122308, 0.027437280830392985, 0.09579097261286584, 0.12034029653645195, 0.13464722313723565, 9.999999999998899e-05, 0.0005421592408739739, 0.003980866367500835, 0.0033629001657172752, 0.0022131990028632087, 0.00036825122062233984, 0.0001765971831831914, 0.0003170585813839777, 0.0026134351886841767, 0.051196268471022766, 0.05626200685241034, 0.05464251386766772, 0.05171374218192082, 0.05454357704163815, 0.07056334233161432, 0.0515034544302827, 0.05098304844645174, 0.07741977272047007, 0.3202185366541689, 0.3097901585586206, 0.36467007576182053, 0.31389755246337536, 0.32206637837687324, 0.3245515325055405, 0.3444976427542841, 0.3458232244145024, 0.32174125006952803, 0.08799740103938802, 0.0808257509698247, 0.08781537799767336, 0.07710900309784408, 0.06528385085994837, 0.08952997414146124, 0.07635874523225905, 0.07702744960435526, 0.08292364366933958, 0.10644946940628164, 0.17888876783272356, 0.12617191065507738, 0.12327225033551936, 0.127191763359208, 0.16672944948678414, 0.1301752929127863, 0.13995655923174743, 0.11944992660482112, 0.23586805068302474, 0.22200586271763656, 0.26653661122635963, 0.21554870665672898, 0.2053617116909019, 0.20904698403507427, 0.24098761858170092, 0.26539435171664205, 0.24475198038240686, 0.17152641485375386, 0.1445492676567377, 0.16283388423392808, 0.14684741911869315, 0.13700781914726812, 0.15371508792964883, 0.16173407662010453, 0.17736384311542097, 0.17130915460977936, 0.16288604251669314, 0.19859997805698648, 0.17734732573172773, 0.1728491253743214, 0.1595075180085176, 0.19507483160724448, 0.21743830649011497, 0.171536799758632, 0.18473086206847433, 0.18309400067277048, 0.16453065278644408, 0.16820177309697482, 0.31289222675125816, 0.21993285714460897, 0.16569097046085246, 0.20551629830553464, 0.1693350951386592, 0.17790252256800465, 0.16090980764797946, 0.16279319719763774, 0.16487953551270906, 0.4952786075837474, 0.4096092914602052, 0.2545841605113266, 0.16622145413251932, 0.1499357038264596, 0.20896483709866076, 0.4203727245163176, 0.1867988687983625, 0.17533370708291807, 0.15491999994518724, 0.16608274091359543, 0.3730006760267752, 0.1993530651770009, 0.18121277516695544, 0.32686940382091023, 0.16788729731328966, 0.1635868897783459, 0.175445763229771, 0.17930693912459006, 0.16792420586289314, 0.16668931876122084, 0.17159466015403946, 0.18023642852394473, 0.17025864132793922, 0.06658720902182269, 0.06863866296138477, 0.07637948840554731, 0.0677731817132553, 0.06476208269115102, 0.05572519236658957, 0.07055670475495868, 0.07492920857927943, 0.06885898488016007]}, "mutation_prompt": null}
{"id": "4b06b3b9-0ec9-47ec-8545-a40844642311", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity_threshold = 1e-5\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            population_diversity = np.std(self.population)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                if population_diversity < diversity_threshold:\n                    F_dynamic *= 0.5  # Enhance exploitation\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate an adaptive scaling factor based on population diversity to enhance convergence speed by dynamically adjusting exploration and exploitation.", "configspace": "", "generation": 25, "fitness": 0.1856714487526595, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "39382a27-8652-4b8c-b0f2-bdc83dc56a6a", "metadata": {"aucs": [0.3848421458956971, 0.3839358848104938, 0.38111093952340147, 0.4098166827292993, 0.4472751757943161, 0.427720233684704, 0.41385546474178214, 0.41918372286985905, 0.34335929582896185, 0.1275117344139346, 0.13686062208177951, 0.1607711116958429, 0.1277308389068894, 0.13316987064360397, 0.15826507107398924, 0.13426575612348557, 0.13306298874504352, 0.1336356723710953, 0.1479950952878275, 0.11924571238212489, 0.09472085898614424, 0.09394025067157474, 0.10607028156712672, 0.10463677594269061, 0.13856592973634907, 0.13176674593714066, 0.1002532096479033, 0.09476983082240253, 0.1030456253779013, 0.09596974647615242, 0.09817082513575026, 0.09450538812555898, 0.09128518669936891, 0.0808290518728847, 0.08777046475103711, 0.08963979766340269, 0.9455429979786021, 0.9204064329121027, 0.9070282406084881, 0.8898488195965224, 0.8376817451448993, 0.8062274896155347, 0.8786463353821063, 0.8659427947262398, 0.9336075431064326, 0.16472866110038464, 0.1631362667695606, 0.15314482322259027, 0.1948705793845762, 0.1838128193632096, 0.1463142958527991, 0.1096896718357715, 0.18424848233925617, 0.18562944081417454, 0.23931676299440574, 0.2451404866174235, 0.20695813194243096, 0.18558718743860747, 0.29217868799780367, 0.43005377463384653, 0.396988608587198, 0.19887279285787296, 0.21878229470620714, 0.12418491653173458, 0.108759093949224, 0.07536847429184113, 0.11328144518257999, 0.11631465761678306, 0.10684112735597973, 0.14068156393244136, 0.0898518685508588, 0.1063621246740899, 0.10081519942070682, 0.11772106354313638, 0.00876931224968902, 0.09057976110967225, 0.10497160805764616, 0.10034185503113391, 0.11565754063619971, 0.13647567898560886, 0.09041924724198103, 0.04436989575971095, 0.01149946141759317, 0.020323112706591706, 0.0003345423603589026, 0.027743838298921353, 0.0008558635966342543, 0.0035134636329324787, 0.017579561532718113, 0.0011628584785852158, 0.11307892156251509, 0.1120486478468381, 0.12471773207247971, 0.08115166219586445, 0.06276569789312147, 0.06929266871608164, 0.07137851991928512, 0.11601499910288404, 0.07889740599507822, 9.999999999998899e-05, 0.004542588179126006, 0.0006406360858589588, 9.999999999998899e-05, 9.999999999998899e-05, 0.002698335723398171, 0.01866771349995766, 0.0019858350914697676, 9.999999999998899e-05, 0.06006962305935959, 0.06543723996754869, 0.07075852095265767, 0.06492575836708925, 0.09918610205822187, 0.07316234984135095, 0.0650549716165526, 0.0665488323634641, 0.06565827123019463, 0.3252330176851371, 0.34795016944229806, 0.3853191953751939, 0.3505763370431203, 0.3291748946150074, 0.3491125144651067, 0.3642801556284201, 0.33706251038958013, 0.34852827493749605, 0.06842927331399096, 0.09126541678859668, 0.0844475592285322, 0.08429150990951018, 0.06869450803374944, 0.06925127243565765, 0.09129802657138009, 0.11110725183068115, 0.08085515937950893, 0.13436700347225028, 0.13678305544970504, 0.11842175776965747, 0.13451530328854355, 0.12118937730925083, 0.10798713552684513, 0.13106012429979075, 0.11760119496114307, 0.17241609393687507, 0.2216710694494073, 0.22299659207910705, 0.2413500287021505, 0.25943456174871615, 0.2383352909311761, 0.21917049634777808, 0.24357045243872744, 0.2852262004521735, 0.25963947319984093, 0.1678564256183941, 0.16221986537526611, 0.15916201235459249, 0.14397317705537627, 0.1533158745587756, 0.17303172951436896, 0.16984773719748025, 0.18603201042683215, 0.19413078637529657, 0.1632063444665195, 0.15868624999626868, 0.16301303888827445, 0.1604624768165217, 0.16074341689025207, 0.18756589102965604, 0.1613560411129471, 0.1804600490788394, 0.20056586783820085, 0.17487089596297467, 0.1769244090575106, 0.17313415273659116, 0.18379856661543603, 0.17024435667657567, 0.17171069080059664, 0.17933313279520735, 0.2165587675908489, 0.16477574263844885, 0.40815145853199397, 0.25405263164692005, 0.13594580817011703, 0.3057039936641128, 0.17639514295677272, 0.15370216990883623, 0.160311609547931, 0.13203290254572275, 0.45140515158957895, 0.27053884611143375, 0.16884899754516214, 0.1549163474364723, 0.1787312390207808, 0.13396090412296913, 0.2913052836499702, 0.19650500468133614, 0.18144117730788478, 0.1872051984075369, 0.17087992043706113, 0.1727526909507987, 0.19157574436628888, 0.18517947979448635, 0.17122064225347333, 0.16994825550345427, 0.18948646493828758, 0.17350678127239805, 0.17389789486400187, 0.058108669242095345, 0.06222155832494025, 0.06074822508965483, 0.06226388353581114, 0.0632488500084577, 0.05874594156875135, 0.06641406838583774, 0.07927329449534026, 0.06701240476130665]}, "mutation_prompt": null}
{"id": "c5963fc4-6825-4f6d-b630-82a8e1e0eb4b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrating adaptive mutation scaling with feedback mechanism to enhance convergence speed.", "configspace": "", "generation": 26, "fitness": 0.18721206254846617, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "39382a27-8652-4b8c-b0f2-bdc83dc56a6a", "metadata": {"aucs": [0.3623114826406013, 0.4287536618321528, 0.40604542978759195, 0.4566986349857499, 0.40399533940674903, 0.41679040611826457, 0.41156221931987225, 0.4425915997029981, 0.36103321181539294, 0.12753897053736385, 0.13526814858133263, 0.13911624384573928, 0.0997854585589355, 0.10264996380036995, 0.14212028280900246, 0.11852621083431769, 0.13650238564816264, 0.1269185587714048, 0.10640575422845522, 0.1071521429976714, 0.11430108421201002, 0.1118346637932427, 0.11620307260121676, 0.09918019172016301, 0.1512358542372425, 0.09818754909729266, 0.09817884337541005, 0.09742476211080542, 0.09176340875847322, 0.13528596796147108, 0.10746337290053176, 0.07523517012729064, 0.09915628153676748, 0.08880508102043183, 0.10345472694645852, 0.09074256707070871, 0.9459134154174442, 0.9204380877858852, 0.9079747215912393, 0.8962115255260834, 0.8823755233093529, 0.8481954923329516, 0.8846776285465745, 0.8746888134296085, 0.900576847947393, 0.1862769171162666, 0.1911824307863027, 0.1955906960745729, 0.1530997648453345, 0.17416699670963476, 0.15854378435281524, 0.07683545712115591, 0.2087584465151554, 0.1800710316013554, 0.21416875986446493, 0.2426385851552446, 0.3088658744443684, 0.24257839829480476, 0.270657622595475, 0.2181642551231353, 0.2555951163339889, 0.29305005358876246, 0.23993735006068295, 0.10121943634953656, 0.0975887850893814, 0.11689469864422486, 0.10067769165372442, 0.07464792248475371, 0.14083376823369986, 0.12495248031314399, 0.10628357740703998, 0.110786587915778, 0.08671826427676477, 0.008878063511889911, 0.00949994045491398, 0.10038109503543946, 0.11420872076920974, 0.09627543955921569, 0.11991843894289778, 0.11178915565989012, 0.09108866391685766, 0.018768170301946108, 0.01565953076819837, 0.04135614749112648, 9.999999999998899e-05, 0.02461888130166623, 0.0023865655028318944, 0.031150947148293584, 0.007615590643232251, 0.039814224850487356, 0.0741213608242891, 0.10354376668358689, 0.09308368422397395, 0.09422584029328429, 0.021124780630838336, 0.13212906841343552, 0.10664281926776364, 0.13622249045940849, 0.12500799897719406, 0.000283199115484023, 0.005482835041485723, 0.010348716459814056, 0.01572739276078372, 0.008305216414565608, 0.017461756196319955, 0.0023513621707392796, 9.999999999998899e-05, 9.999999999998899e-05, 0.07755072541731134, 0.05348801024947658, 0.061083723511632715, 0.061869483170026274, 0.08129548188156277, 0.06111957375539878, 0.07321180335683253, 0.07442842326390875, 0.07026129769093004, 0.33296865661164887, 0.3409973201262223, 0.35268875143885625, 0.33297196907174, 0.3520132448041995, 0.33622185483984446, 0.36052852254358136, 0.3463670340727779, 0.31158044410971664, 0.09679948834085861, 0.08491115087273304, 0.09634273121989922, 0.10683856830536986, 0.08877947093297789, 0.08281585526178536, 0.07015564333734126, 0.08818311398107526, 0.06780958912396218, 0.12195774953447547, 0.17795290860251156, 0.11842175776965747, 0.11643108954747516, 0.1422221616394358, 0.11871483855429543, 0.13629192204157048, 0.11928703332616009, 0.11863785961325213, 0.2024694095524926, 0.2531551128738365, 0.2417469018827072, 0.21847819830237314, 0.25909972713685914, 0.23534409656944177, 0.2476104469231335, 0.2666487345366094, 0.265523559523, 0.18921306018225081, 0.15458111616475412, 0.17029113892207481, 0.17881340284312774, 0.16068383666914687, 0.17169922031681928, 0.19688496670900857, 0.17352910109294495, 0.18210005787860306, 0.18740663050810558, 0.15823100085637143, 0.16496744847204625, 0.19151672292207966, 0.17473358610791379, 0.17190077661810887, 0.16564718908411447, 0.18091742497817198, 0.1759514451456201, 0.16885550580446596, 0.1639646344082476, 0.17759303686453964, 0.17847007446176433, 0.20563569466637, 0.17500866924473613, 0.2187392386773015, 0.18731304531760828, 0.17492692490643147, 0.3609343821794969, 0.13712586625762757, 0.1599233079036798, 0.41552582508125446, 0.39259608014800795, 0.12544221401836964, 0.1649048945988859, 0.1479906692082723, 0.1759119462271308, 0.38750688741927186, 0.33467703116329905, 0.1568713370807414, 0.17252746015765663, 0.2169896150453926, 0.399743717482695, 0.18693980001288169, 0.18772357924535144, 0.18439403374915864, 0.17564451171143702, 0.17519770767455134, 0.1743143790142596, 0.16048675900598042, 0.15424366467541006, 0.17714972245442173, 0.16480657016085076, 0.16395259093639403, 0.1793380148945034, 0.06958749370170103, 0.05426994928802864, 0.0675992770640943, 0.05520929738633984, 0.06710136584429238, 0.05954417870491957, 0.05991576495420481, 0.05703577496011203, 0.07000207569352312]}, "mutation_prompt": null}
{"id": "a87afa72-998f-4744-a669-b080738c5612", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introducing an adaptive crossover rate adjustment based on success rate to enhance exploration.", "configspace": "", "generation": 27, "fitness": 0.1872277937433002, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "c5963fc4-6825-4f6d-b630-82a8e1e0eb4b", "metadata": {"aucs": [0.3865392631168959, 0.41251314978627474, 0.42022751120996227, 0.450353309551469, 0.421749227970326, 0.4761592341892872, 0.39216285289034036, 0.40228427684963985, 0.3922962981713294, 0.15755925540654547, 0.1119631961037234, 0.12473236599127524, 0.1288368284817839, 0.15055628888515948, 0.12819524099318536, 0.11406617072546266, 0.14628642717936546, 0.13818566156511713, 0.14231060801909645, 0.11109356267733272, 0.10514595685442707, 0.10358980845273313, 0.11271205200519652, 0.10299417958785595, 0.1077754584973809, 0.10766746415330541, 0.12449466311955948, 0.09289920088343007, 0.09324157835323188, 0.0976836572640335, 0.10553589366300442, 0.09636191888969003, 0.11337267301855303, 0.0930677830467097, 0.10238574275834111, 0.08701199622839717, 0.917123705182842, 0.9204352492895262, 0.908004365295431, 0.8959727592845326, 0.8296723185670917, 0.8798330417396928, 0.8990695131529423, 0.9396628148027667, 0.904645542893682, 0.13851333587223347, 0.19235098696999364, 0.1595035831985957, 0.1560026524340241, 0.19222226703401102, 0.14103885008748496, 0.15586361054069098, 0.15923614339173964, 0.1791861920418989, 0.279245964365914, 0.19759513470399503, 0.19559370365984674, 0.2803584747489405, 0.22753087659553972, 0.24024314111965595, 0.37387950765921163, 0.23789057593952379, 0.3271596505168771, 0.07668977651227271, 0.08440300280415214, 0.08837900293973211, 0.10211127527158603, 0.1109645027389593, 0.1092919096783509, 0.13159233018773464, 0.17592019361129896, 0.08514365604484297, 0.10026251057245428, 0.08087421358569824, 0.09117142785810906, 0.11924069345629362, 0.11501345117555917, 0.09458333700266353, 0.10731703893391698, 0.07046192592851552, 0.08521004312167424, 0.021421969855748624, 0.0001761625014033985, 9.999999999998899e-05, 0.00024904823596949566, 0.025385438922107095, 0.011712547205423696, 0.03379733085692693, 0.00880826340317764, 0.0023150208813258466, 0.08310329660044768, 0.10638482868041121, 0.06681303580123965, 0.07666447808751087, 0.09263321752066245, 0.025654300848488076, 0.10056232106625107, 0.1457451685606289, 0.0997774111627654, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010694658163845627, 9.999999999998899e-05, 0.030448862905441132, 9.999999999998899e-05, 9.999999999998899e-05, 0.04987166246049346, 0.059937284886506625, 0.05951451941598973, 0.09593738479924141, 0.07516147274972751, 0.08830378060901134, 0.07522673483811282, 0.0620073509932767, 0.08486145934885314, 0.3450078020930263, 0.3491065271582805, 0.38032789675253764, 0.33468394984258, 0.33622374533400634, 0.36833669606678343, 0.402280571249093, 0.3276325735990251, 0.3607598488580037, 0.06962067166540031, 0.09527151708136439, 0.07884062387771484, 0.1049260507564912, 0.06706160116053028, 0.06682175016724157, 0.0840235477010266, 0.09439508933293839, 0.07419699127286261, 0.14202232321722075, 0.14237712337433894, 0.13919303839147046, 0.12410673343462986, 0.1099628298560067, 0.14167416000033772, 0.1388359475421983, 0.11937891684786428, 0.15226613845108583, 0.21950825389441764, 0.22526583172990322, 0.2518694399231667, 0.24083030719864174, 0.2550637187561735, 0.23823368718969418, 0.23898090919412518, 0.27786978871877377, 0.2782324723434908, 0.1357095443821752, 0.15095342200394535, 0.18016946769683984, 0.15283429257884618, 0.13673868721482818, 0.1732725699484685, 0.1632676595377578, 0.22755541869100926, 0.21064359920931364, 0.16836947914416, 0.15011889788159483, 0.20248919815089705, 0.1592481883932242, 0.16693820002369264, 0.18020801509397844, 0.15228536626971423, 0.18857098279048545, 0.17855573701312188, 0.16815802643403277, 0.18271745185601374, 0.17960951508409073, 0.15556462595132903, 0.18685162252796805, 0.1896614516308599, 0.20008806101566523, 0.196061034897151, 0.1788783250215431, 0.40845582335940767, 0.14489804933616124, 0.14272448640301205, 0.36569961574878973, 0.17336678312230813, 0.15480610576955678, 0.16971785787078875, 0.3371625179973917, 0.18381513193932486, 0.33375081340883106, 0.19272663404590307, 0.14492317639106989, 0.17685663241776128, 0.20693913606582515, 0.23511142857563283, 0.18743391960087774, 0.18857249242275242, 0.2258853693070283, 0.15771173666463367, 0.15938783977849458, 0.16255645489768977, 0.19926284345237022, 0.1900064861882761, 0.16750434532272263, 0.17550618352314673, 0.19653708819665117, 0.1837247152888547, 0.061723013538983795, 0.06829663487864768, 0.07263026455973864, 0.05838616184624501, 0.07009857449506085, 0.06550895904161846, 0.06007481646243795, 0.06821723221424181, 0.06665990111474984]}, "mutation_prompt": null}
{"id": "ad2ae89c-06d1-4224-b275-17879e3a9dd0", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            population_diversity = np.mean(np.std(self.population, axis=0))\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                F_dynamic *= 1 + 0.1 * (population_diversity / self.dim)\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce adaptive mutation factor based on population diversity to enhance convergence speed.", "configspace": "", "generation": 28, "fitness": 0.18287159728084054, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "a87afa72-998f-4744-a669-b080738c5612", "metadata": {"aucs": [0.41003594338466165, 0.4417644184438997, 0.390239326849269, 0.43396464583885963, 0.4056501208825972, 0.3886152564508567, 0.3971924363229218, 0.35989280992418937, 0.4059904363750636, 0.10845949986001835, 0.1396851513093159, 0.14014538068589533, 0.10312133276013846, 0.13550382110186654, 0.1232892585481693, 0.13157072803597747, 0.12005775311409073, 0.17028815441839362, 0.12732064313115465, 0.11927028060729139, 0.12082932484188136, 0.10231959036377525, 0.11285309245988173, 0.09907062883175022, 0.1274619406076667, 0.13866180256630867, 0.11007872986701095, 0.10605826250225614, 0.08741674074513195, 0.07264444325066255, 0.09422681790415954, 0.1005573396204954, 0.11082538344929038, 0.0905783235987555, 0.09756132383876337, 0.11456951306172292, 0.929374938806444, 0.9207438251149012, 0.910909972815651, 0.8963151111017865, 0.8087817527327067, 0.8254231809516708, 0.8635566959984258, 0.9397267153077588, 0.8970778559435038, 0.16008948472663764, 0.17198101209004124, 0.1489242270763269, 0.17486886230875642, 0.17866849754632308, 0.1577691767270447, 0.07496930121100609, 0.16664743937601545, 0.15312403723418644, 0.22619228995237006, 0.19104810061919375, 0.20369214851385709, 0.18679516754340597, 0.37500818645872813, 0.2401637780726914, 0.23931997796354287, 0.26719040296326635, 0.2676059826543482, 0.0665092158924454, 0.10790432864943555, 0.07574469521409433, 0.09727054787146117, 0.1014696048506083, 0.11274662118902068, 0.08379461587645387, 0.10289870700675618, 0.11964190600082769, 0.03291473810357348, 0.09653417184246449, 0.06922224967966795, 0.09570593552663631, 0.09110644964666603, 0.11539720732561598, 0.09653848686297495, 0.08185197425721158, 0.08932990263877583, 0.00026500730417722274, 0.02102925671787359, 0.009642773590165077, 9.999999999998899e-05, 0.01800849677842964, 0.01039210937121715, 0.00445424782123971, 0.0009776831862620128, 0.005129359891510865, 0.12975657368741245, 0.05641519998032274, 0.11710113986495307, 0.13536638223300346, 0.14304143741329023, 0.015611909909457045, 0.09453653155878416, 0.10197256568535917, 0.08454585295527417, 9.999999999998899e-05, 0.0021870730091526625, 0.0029730954008813093, 0.0032428395642341012, 9.999999999998899e-05, 0.014398874074825985, 0.0056536835374881855, 0.00803064208184956, 0.00781967790144078, 0.0758792064247098, 0.04776889389666705, 0.03856661963492192, 0.06385201082288472, 0.08028043878256907, 0.0690740444057798, 0.04032472101344087, 0.07383799745650976, 0.06540803000461148, 0.33392003716868734, 0.34561983775767424, 0.3540119878821195, 0.3399669046173954, 0.3389818586167087, 0.3439303382019444, 0.3608516157114151, 0.3239013935719661, 0.3472406388241531, 0.0888778803760526, 0.10323550452718444, 0.08843377026278887, 0.05463662139486192, 0.08858794758488953, 0.09403869332736381, 0.09989287413556835, 0.059766127542470904, 0.06404023999364583, 0.12947780969102018, 0.13633730576838787, 0.13104475842351626, 0.11467656153168704, 0.11772218520173194, 0.1480250280473152, 0.15094616812362094, 0.19042600852827096, 0.13491785759199537, 0.20872515105520129, 0.22152030771712672, 0.2600094194265895, 0.21129177435388868, 0.2202125255077666, 0.21682706575407396, 0.2308223094951276, 0.2570593185567598, 0.22995174771943716, 0.16040753195875646, 0.152749827337755, 0.17276116002048802, 0.14179171154302672, 0.16852126073302076, 0.15349262312742762, 0.21052906996822163, 0.13332523428270038, 0.20837658802539505, 0.16781209723927715, 0.15905645033021065, 0.17614059876828925, 0.18383946469978651, 0.16170164258905972, 0.17235698458468973, 0.19597847503058918, 0.15308187091490943, 0.1794458474408982, 0.18052238639749085, 0.22522089288016744, 0.1989040950395019, 0.2101515480084074, 0.17531195024649315, 0.16058085552195556, 0.19824322327881194, 0.16292800893397574, 0.16729847661310437, 0.26247238512652815, 0.3468174185304327, 0.1636038128271291, 0.40585274266772997, 0.1785093738354797, 0.11830210584120182, 0.1656085580681962, 0.1264225407825148, 0.29068173976918055, 0.33992186931534574, 0.1860777217385441, 0.38246861349766537, 0.13942505735798927, 0.23252005606624138, 0.14228863110223888, 0.17615592233408117, 0.17910185641814846, 0.18066524139973006, 0.17681263495992194, 0.17070585604210442, 0.1774191692185506, 0.15716196075029498, 0.16946812920885201, 0.1704255234752876, 0.1775532088551114, 0.1593394710442375, 0.17189272997678096, 0.055850118267781745, 0.062304452709371794, 0.05937972296824379, 0.06330032100144922, 0.07804018079836628, 0.06668466232054338, 0.06229662296239147, 0.07255059421947774, 0.06356204593947057]}, "mutation_prompt": null}
{"id": "fdc3e985-c2d2-4820-a93b-9e760c55c306", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                diversity = np.mean(np.std(self.population, axis=0)) / (self.upper_bound - self.lower_bound)\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) * (1 + diversity) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a dynamic adjustment of the differential weight factor based on population diversity to enhance convergence speed.", "configspace": "", "generation": 29, "fitness": 0.17905239297345463, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "a87afa72-998f-4744-a669-b080738c5612", "metadata": {"aucs": [0.37071133360148034, 0.40891164916214096, 0.4031936250577167, 0.42195259321580814, 0.39380807736513423, 0.40421852027138294, 0.42566152394665346, 0.3786429460479117, 0.37509033732888875, 0.11334962439916763, 0.1040280677759764, 0.1288133606208527, 0.10848027904145363, 0.10751747660969846, 0.1755615783929727, 0.11726716051112507, 0.012058173805732042, 0.16378899252046553, 0.11679774720104763, 0.11291982551795499, 0.13587007989496103, 0.10523992473251986, 0.10569897337582757, 0.09441930973652202, 0.10256923531710727, 0.09427890484932322, 0.10260867039429522, 0.09818058863250134, 0.07888515644475902, 0.09089256578074423, 0.09381104286473041, 0.0968123092927432, 0.10516939408842774, 0.09386222081371687, 0.10366042339788983, 0.08049355183801021, 0.9356642098230775, 0.9221731333918771, 0.8993415664592381, 0.8990103212890921, 0.8975521090444943, 0.8833749445732331, 0.8887831181967153, 0.9181844306983777, 0.9043499737714666, 0.15527685173890116, 0.18029788192822582, 0.14803414332493448, 0.11824149854117127, 0.13667519202855305, 0.13277641086351066, 0.09215803239565834, 0.15087466950356943, 0.13803734684917124, 0.20371455992507803, 0.21221955712985363, 0.32534590631039595, 0.21703939833257657, 0.2897451629653578, 0.19491171833413012, 0.19649422954929563, 0.21709575234395506, 0.2086337616236179, 0.09531760971316616, 0.09809201847455407, 0.08415429330173574, 0.10004429419105088, 0.09390225487362591, 0.09428776401054806, 0.07145481164590872, 0.09880347945898504, 0.095947280216652, 0.0802082315071262, 0.033847554619918285, 0.09763307206497973, 0.10677470695621705, 0.06403090172805148, 0.0946781965725384, 0.13360365363429283, 0.09196738388043246, 0.09713414962108291, 0.00921310226925287, 0.003458552317953556, 0.013778994361841934, 9.999999999998899e-05, 0.0021153965001365904, 0.001803319675210524, 0.0067549592865537855, 0.02347081708064469, 9.999999999998899e-05, 0.10769805243334507, 0.046402560939148185, 0.09960934255419962, 0.08601521545591784, 0.056297164135041045, 0.033209159846415925, 0.0824104976748471, 0.058431909268126025, 0.14488491279092774, 0.005889192986706648, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02189575453379622, 9.999999999998899e-05, 0.0013815940099710655, 0.02146240665041732, 0.03414189150314362, 0.06735895827678418, 0.05573180964635738, 0.06785685602858504, 0.04532623242597533, 0.08832808223169364, 0.07149685593169486, 0.03784898146328308, 0.06737791537347726, 0.0783964379413139, 0.35309861815363586, 0.3184175844080067, 0.360478453514536, 0.35371251153957406, 0.33214204316871077, 0.3550874300517265, 0.33618648158136355, 0.2956464070458583, 0.3241510103367633, 0.08293192569531094, 0.08145793736971196, 0.08003756246449989, 0.08604378011027602, 0.07263434419320458, 0.08577469443030605, 0.07171760516518721, 0.07385999654010633, 0.09263209854923171, 0.14335160832291605, 0.16623198298599473, 0.18066635168239498, 0.14890009838849405, 0.1269104628819332, 0.13364577548655066, 0.16882016734991667, 0.16761832821250577, 0.22227469662316302, 0.21987548023661896, 0.21478085828775118, 0.2551703160945863, 0.22456559539295873, 0.20853099391231722, 0.23780718759661867, 0.24976366585634013, 0.2550618553563486, 0.2657308557500373, 0.16001637275766079, 0.16786212254489874, 0.1444526027085853, 0.1484105236356945, 0.1402123026229769, 0.14400133761582, 0.2064144142345672, 0.18827875300441987, 0.2170060973699267, 0.14802949792753062, 0.19400334286391396, 0.15754737155450893, 0.17592155871133142, 0.16966862459372456, 0.1824230614372686, 0.17659540137785257, 0.1600300086750951, 0.1843934220288942, 0.1765763835569485, 0.16467116300824003, 0.20852300491544773, 0.18347896935879093, 0.179732634074803, 0.1834802898210386, 0.2027770571911497, 0.16362345640370746, 0.19568723225567952, 0.16808620520101414, 0.15308581130645693, 0.3607591107477084, 0.14970926078276225, 0.16243311175592767, 0.1676840009944648, 0.2606436390482685, 0.1717379112389652, 0.21515395437815543, 0.23258841609359082, 0.18764909412852915, 0.2525356072923426, 0.1855256195708952, 0.17797435290057162, 0.12241896975926325, 0.1882230841850333, 0.18639270018431064, 0.185159885132005, 0.1679399370688257, 0.1861765193253101, 0.17028917470418947, 0.1628670455669311, 0.16838154270420036, 0.16612733676599367, 0.1854732711969369, 0.17719793702611475, 0.16984330231821843, 0.05666017998961348, 0.05703797269603006, 0.059578983621330184, 0.06551892034883244, 0.061212415976298895, 0.059672924702888874, 0.061657629233466515, 0.08189853163260863, 0.05672904485541874]}, "mutation_prompt": null}
{"id": "ac7cca83-34c0-47ed-bc2d-eb5844a6739f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    # Dynamic adjustment of mutation factor bounds based on evaluation progress.\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces dynamic scaling of mutation factor bounds based on evaluation progress to enhance convergence speed.", "configspace": "", "generation": 30, "fitness": 0.18844544427753857, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "a87afa72-998f-4744-a669-b080738c5612", "metadata": {"aucs": [0.4136998789595183, 0.40250107984490757, 0.42519322883383015, 0.45049526188436495, 0.4177599264779761, 0.43534417860884156, 0.3978086653904551, 0.40999684702910866, 0.4234315027900487, 0.1262111372177218, 0.11375849188060838, 0.13019658873254325, 0.12828753430347062, 0.1563241554208713, 0.1406309607406827, 0.1230801974416923, 0.11060548347594357, 0.15938943492517554, 0.10594643177596863, 0.12189452838263515, 0.09970100043642016, 0.11989384290619987, 0.11323718449664044, 0.14326962411892907, 0.1046214481569181, 0.13129881956724399, 0.12715592740046866, 0.07887979870296336, 0.10008218214453168, 0.10234234221291594, 0.10895679683315795, 0.09370984719743225, 0.08486076474315929, 0.09562045551070764, 0.08400940196568829, 0.08431664497633284, 0.9189858713584949, 0.9204224569779962, 0.9080033680002907, 0.8959617814715315, 0.8295059011855656, 0.8796724274155228, 0.8989647697303456, 0.9396231088149656, 0.9045861592655515, 0.15517978852579584, 0.1679346912421752, 0.16434775531029155, 0.15261407507393465, 0.19153372613620367, 0.1518267546419605, 0.15188881600044601, 0.17625948572491745, 0.17359619325741882, 0.20322435594181332, 0.250367753202125, 0.2738826704548033, 0.23411611946704924, 0.41176078489389023, 0.2613610435203447, 0.31733523241194384, 0.2979792101680149, 0.37946482787491587, 0.10404911033428821, 0.09157909543766696, 0.10534088458804258, 0.11686482097048134, 0.11223222678423006, 0.10788994660527573, 0.14907790672758858, 0.1276750776556972, 0.08122415270016847, 0.09120952228094281, 0.018053171796364897, 0.08798584725282121, 0.10332983563970899, 0.10481813868802581, 0.11010368278625515, 0.09743208121611258, 0.07290677537436385, 0.08160675877287571, 0.026732725800499235, 0.0003302814931015474, 9.999999999998899e-05, 0.028049556105813056, 9.999999999998899e-05, 0.009182545292702682, 0.03256665982649809, 0.006228959806852563, 0.015215272105610689, 0.09435850496669262, 0.0968981367496724, 0.1125299075741546, 0.06675543819207308, 0.025069824752112835, 0.03873794739979852, 0.1062982521678476, 0.13710117300528601, 0.08494044228588626, 0.0026408886932000053, 0.0016812105479598882, 0.0027458619033932097, 9.999999999998899e-05, 0.004729573031179601, 0.014295346464939351, 0.0028964517693526037, 0.0001076849164591831, 9.999999999998899e-05, 0.05430202210958812, 0.06899290792588075, 0.05919485294150928, 0.0716149448426957, 0.06184660849228785, 0.08906550709181849, 0.045349106434657505, 0.057995873410138454, 0.08547316021787288, 0.3358925077304994, 0.34635610166392694, 0.3718502999352038, 0.31841907269644487, 0.357365663191056, 0.3579767385688676, 0.3875273446808737, 0.3708015274606712, 0.34235856468335224, 0.06697685281115795, 0.11120180742019548, 0.10684201031911567, 0.10069149152684254, 0.06754311353786835, 0.09408647014294924, 0.07148717029343588, 0.063729884725513, 0.09034951851268325, 0.14598301274212078, 0.14868741127938478, 0.1249360021933249, 0.13947404260247986, 0.16659173585385145, 0.13208475757712257, 0.20692383638482204, 0.11640062071795287, 0.10903401585497852, 0.26143860785055917, 0.22095964434149662, 0.27745029409659216, 0.2131472712566289, 0.2191953468197717, 0.22539611204748966, 0.24565489524701378, 0.26081378974191427, 0.25087047408177154, 0.16942140279340545, 0.18120647593248607, 0.1778904366154025, 0.17489271473567736, 0.1914724268864355, 0.15155191094158604, 0.20118204114827654, 0.18730572615332408, 0.202886758865088, 0.1808074811464594, 0.17085186221705206, 0.18348966566133396, 0.1661022162253456, 0.17748203872615864, 0.18543043759416555, 0.1639440121449206, 0.1695067885120054, 0.19212567247261036, 0.1760437355893848, 0.18357475040680216, 0.19050424495020335, 0.19797292421958979, 0.20149252884434166, 0.16826191608289787, 0.199254364098859, 0.1535253348549832, 0.18005103607079675, 0.4406008733908837, 0.15151980589640002, 0.16573443325203552, 0.398530669183331, 0.16954042030962246, 0.14711652414254928, 0.1708670544449591, 0.22901569913484687, 0.1818082542581717, 0.2529258740328172, 0.19241068661140603, 0.1765311868032735, 0.17876360782244682, 0.20866709747541334, 0.30299790533609317, 0.1885293073768337, 0.1906214890001514, 0.1893018185825306, 0.19182539178715863, 0.17826583112531114, 0.16018512591492706, 0.16666996849783877, 0.16338378239164175, 0.16575157132279472, 0.18787085730143227, 0.17336298979462716, 0.17760787384258714, 0.057690392831073245, 0.06172908914572439, 0.06195910078451161, 0.061217978924054894, 0.06394359667999683, 0.06710719437296797, 0.05951307867224931, 0.06475655480850784, 0.05854657673480945]}, "mutation_prompt": null}
{"id": "c7636e8e-2584-448c-846b-d6ad49e2310c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                population_std = np.std(self.population, axis=0).mean()  # Added line\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    # Dynamic adjustment of mutation factor bounds based on evaluation progress and diversity\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget) * (1 + population_std / 5.0))  # Modified line\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhances convergence by dynamically adjusting the mutation factor based on population diversity.", "configspace": "", "generation": 31, "fitness": 0.1872621207393321, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "ac7cca83-34c0-47ed-bc2d-eb5844a6739f", "metadata": {"aucs": [0.3948856794997968, 0.402193673189564, 0.4296011613417773, 0.4521138747731702, 0.42099864949655863, 0.40809973163885094, 0.39906627370278036, 0.40936923271900705, 0.40374406191919976, 0.12354913076334173, 0.1351664614943926, 0.1728155684910967, 0.10649005036169878, 0.15591346747622647, 0.13991746953521667, 0.11462063063942662, 0.126243495765334, 0.1330335329462763, 0.09855140450509592, 0.11483900427879257, 0.10309641177303253, 0.10351970839278601, 0.11949004754749437, 0.09969740398374327, 0.09145102655413917, 0.10669179066396972, 0.12805501484315862, 0.08985976356284842, 0.10921061016171374, 0.10306639158137132, 0.10305219501330809, 0.08718972144139447, 0.09249510901547142, 0.11017165566268627, 0.09031414920142433, 0.08252048205482787, 0.9286189824592539, 0.9204147861088918, 0.9080029226453407, 0.895955180811549, 0.8294034814619441, 0.8795477094274077, 0.8989644923168684, 0.9395994569033753, 0.9045595510587601, 0.16802439652941825, 0.16759983057017214, 0.15889873752455008, 0.1641380077478256, 0.17478367497489167, 0.16064097272438826, 0.15279050436859742, 0.1583740535494771, 0.168994248532513, 0.30845851495349164, 0.222338877539081, 0.2533795837802758, 0.23776057696229924, 0.45237519350143174, 0.2077567413385376, 0.2560150531763682, 0.2613652257886965, 0.2658883810501146, 0.13398994489270022, 0.08814060619741326, 0.11410667806792207, 0.10106670448499555, 0.11388026393768635, 0.11099693714827041, 0.1590393850270706, 0.12524079183274062, 0.08080138444726659, 0.07739960997568218, 0.018014721682568235, 0.08493323818345055, 0.10754066355386749, 0.09687070587543278, 0.09997370139240158, 0.09978899452666223, 0.11152297978902848, 0.07578273754502485, 0.02899446901688829, 0.012059344002446792, 9.999999999998899e-05, 0.024671806471485813, 9.999999999998899e-05, 0.006120900319680711, 0.04149434406757169, 0.003674406582030443, 0.007778339922990596, 0.07410902222685767, 0.1582859026066249, 0.06548970811403865, 0.04822061098787067, 0.09062262720638825, 0.06908448395266964, 0.10007510375361417, 0.11773546281641034, 0.1279009014528899, 9.999999999998899e-05, 0.0035333943842500437, 0.0038236837565713833, 0.0009145389809062099, 0.019643237488605525, 0.018588576047843475, 0.00011561151026928673, 0.03693847334798772, 9.999999999998899e-05, 0.0715982677492879, 0.04993642059746495, 0.05568262936243207, 0.07959431965981878, 0.09240852082355688, 0.07634844202733126, 0.05677800136356814, 0.08974443094649454, 0.07648864164105251, 0.30997696259316365, 0.346851862122891, 0.3511728891269217, 0.33129142294277236, 0.36742814794180445, 0.3638007208138223, 0.39804152075102306, 0.3307863299450342, 0.3363703225449477, 0.0678391789552184, 0.09436851142485159, 0.07475764029596099, 0.07559107877689641, 0.06258851525100961, 0.06675481634391667, 0.07902090659008243, 0.0781881406905115, 0.11181869508888975, 0.14708421523866022, 0.13697469967786202, 0.1425273954445938, 0.12710023657998004, 0.12797815606495933, 0.13067669466412135, 0.17899099898091864, 0.11177843665927523, 0.12307805223989421, 0.2386726229827082, 0.23117371247210605, 0.20914001644962388, 0.23829821345700364, 0.21349012897236175, 0.22767287324969365, 0.22813932653664237, 0.29310428074055883, 0.26264415331066426, 0.15356868719903283, 0.17256625961142924, 0.18587799241422243, 0.1754849983115211, 0.18176757714767033, 0.15154205670859078, 0.2365147958622289, 0.17427601870945986, 0.20231246912695777, 0.16794884765192164, 0.14307924369043068, 0.18956525828841242, 0.17403768009981702, 0.17284184190511676, 0.16627839351639317, 0.17559704218633287, 0.19612670326826775, 0.17381587549291888, 0.18930626998811872, 0.18810056274637554, 0.19099347495361296, 0.1871162837503786, 0.1811432086318776, 0.17685338675476592, 0.19856143552846484, 0.15895641324040533, 0.17202639220999094, 0.4525266978552045, 0.14777384146827865, 0.16608543486024951, 0.407490844852198, 0.1727922157284023, 0.1462463935434818, 0.17074444398754585, 0.21561064468477154, 0.18174640976852463, 0.2021954868577075, 0.18919700821473429, 0.26954400577155013, 0.17894969164865238, 0.20920576151948, 0.2602725537581867, 0.1864119750722829, 0.19056682860403373, 0.18945717887076785, 0.17629385661720476, 0.17345112557738862, 0.1792075143829559, 0.17602826168148766, 0.16953881926488612, 0.16261682740421946, 0.15736076098236884, 0.18196532072840466, 0.17931681371919717, 0.06267368786944405, 0.05741464555931397, 0.06855853787411503, 0.06076905717901515, 0.06335297868130241, 0.07451482424067979, 0.057163032682508, 0.08119984503626798, 0.06525586268828287]}, "mutation_prompt": null}
{"id": "e1042d57-8f45-4977-80da-4ea224b4881d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5)) * (1 + 0.1 * (success_rate - 0.5))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces variable crossover rate adaptation based on success rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.18442078255515806, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "ac7cca83-34c0-47ed-bc2d-eb5844a6739f", "metadata": {"aucs": [0.4326701155602657, 0.3749369535259982, 0.37844962591129794, 0.43382391483943017, 0.40579491035748316, 0.40978291720672566, 0.40520149325774646, 0.4049557147221533, 0.39822420035124073, 0.12928299880905492, 0.10383457306448729, 0.16156667667126434, 0.12193339428622274, 0.14396287492926918, 0.130177601774785, 0.10864696122634154, 0.11603203732433798, 0.14150949132307522, 0.10819828434147016, 0.08797731993158342, 0.10820630547236865, 0.10855339590021507, 0.09534453405761978, 0.102902957714201, 0.12059789885608174, 0.09002434768571199, 0.12974662483853605, 0.07851114552161276, 0.09929730252823321, 0.14388759915909888, 0.13084553310660396, 0.09015520695106405, 0.10401987905500687, 0.08950016173531217, 0.11050269421704417, 0.11105277491364829, 0.9172962542924583, 0.9220067867195594, 0.9069732370765057, 0.9025285810358668, 0.8548192265279297, 0.8615624575780974, 0.8879430555980843, 0.939390303968377, 0.8807165646328275, 0.17846544614723858, 0.17904337039661367, 0.19023392266286832, 0.15801721240349764, 0.1696153061154615, 0.12644452901852188, 0.15869560728523302, 0.1929890224840276, 0.18471852638283137, 0.26219004397950507, 0.2079546019609264, 0.19074660153955836, 0.212787204704165, 0.20706962653948402, 0.18128540138039384, 0.24089196708112104, 0.2001350094047366, 0.19465066185508417, 0.09322008975547891, 0.13842862358515307, 0.11709028024667711, 0.1453256160630193, 0.09645571218269211, 0.12386967894967182, 0.127585856839308, 0.09953395213493565, 0.10226440072687037, 0.10314081928237229, 0.041093781374485716, 0.11270583097413855, 0.11738612608482268, 0.10304824542245028, 0.11450730723736635, 0.09572804884869945, 0.09980575347407883, 0.09284225923155265, 9.999999999998899e-05, 0.007422180553813051, 9.999999999998899e-05, 0.012870097624583465, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03418964002041902, 0.0307102161075401, 0.0408890109476735, 0.0877463604363713, 0.12335030879039988, 0.09116072550400312, 0.08946946709775871, 0.13659979362487396, 0.09236088143402355, 0.10917904702209147, 0.10185757282090524, 0.00027120355447529665, 0.008867931598172452, 9.999999999998899e-05, 0.011477542220458936, 9.999999999998899e-05, 0.003601317212623467, 0.004239368911867714, 0.008803686476759665, 0.009405604235689813, 0.052782874783055767, 0.0825832575394787, 0.0614569009168241, 0.07214569950352034, 0.07542394707009847, 0.07011510116466635, 0.0642047158350495, 0.07002636820793418, 0.07178217236849616, 0.32976569658992383, 0.33891756713390875, 0.3752644684483808, 0.37918693733837616, 0.33819248111063593, 0.3528240220152167, 0.3877380987348096, 0.32281913336409007, 0.31592202057267416, 0.08358011889243955, 0.09362514855000104, 0.09370457127504339, 0.09669659115704798, 0.07740463196702008, 0.06505096607013638, 0.08897171862980668, 0.07066358033758569, 0.09534260933828176, 0.1440204663732384, 0.1380941554776568, 0.12641967465419912, 0.16100992147213855, 0.14121873870106372, 0.1951349968786109, 0.1083158294359875, 0.13270435448656537, 0.1409875244025739, 0.22720660137763782, 0.20805069526613718, 0.2276580854530098, 0.24483121758779824, 0.1977390848939512, 0.24565335776377784, 0.234302080492514, 0.2683920077891505, 0.2363530260273461, 0.15820171239737535, 0.16963562559153145, 0.16398924440610718, 0.1483361857112161, 0.16972029829076096, 0.158502979418924, 0.20816602737674206, 0.18898550463114394, 0.18787118073988263, 0.16924719874378336, 0.18312882312764445, 0.1678105758053947, 0.16690136543604073, 0.17566758842884123, 0.1710541380818813, 0.15077439367407586, 0.17464993702058051, 0.16818151927163105, 0.19967726388548124, 0.17181932973788538, 0.20333549391176586, 0.18712814756072305, 0.16237662796100727, 0.16773789115565052, 0.17475565717335173, 0.18449315135636823, 0.1767326758801624, 0.16059387383830448, 0.15543943972383933, 0.1752286380895277, 0.3089575487262626, 0.36841357646105133, 0.433866291179855, 0.16972307296310996, 0.14987160824912404, 0.14608367651712273, 0.15703356034665306, 0.19265626127739344, 0.2640021511718348, 0.15431702369530687, 0.3073379529046789, 0.2724502131928678, 0.18895435917423975, 0.18973934146658322, 0.13879172706548382, 0.18703511028819308, 0.15510128044007598, 0.16974604880380795, 0.15887943218002343, 0.19806753703114477, 0.1615985310349255, 0.1644986492012247, 0.16229118717600488, 0.17860055323760826, 0.07218840311858443, 0.06004552924317719, 0.05958330945002144, 0.06523569800500595, 0.07118022342008257, 0.07617564451379477, 0.06217648452932811, 0.07142190608961774, 0.0659541453786312]}, "mutation_prompt": null}
{"id": "1a6b965c-655f-453a-9dc7-1f9b2103a875", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.92  # Crossover rate slightly increased\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.985  # Slightly adjusted weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Slightly increased crossover rate and adjusted weight decay to enhance exploration and convergence efficiency.", "configspace": "", "generation": 33, "fitness": 0.1856409728965273, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "ac7cca83-34c0-47ed-bc2d-eb5844a6739f", "metadata": {"aucs": [0.3866924382925869, 0.40517396075513445, 0.4258634810116383, 0.4161093051296776, 0.4059096490087205, 0.426119331303747, 0.41765772993027794, 0.38635603354467174, 0.35526479032118885, 0.12866269846254286, 0.14378208895073663, 0.1442306995620245, 0.14191623034328238, 0.1454724916344594, 0.09735014960233135, 0.13212612518783518, 0.12376160045915441, 0.12621543600990992, 0.11292224612126989, 0.10288439438336683, 0.13111084210178647, 0.09242354487591475, 0.10175546359738563, 0.11227896470102772, 0.11837983092123472, 0.1013608405788805, 0.11690602735414612, 0.08603561532780346, 0.08664896308076109, 0.08891510134731617, 0.1123400080708934, 0.0832497978387835, 0.08600246068596007, 0.11359216560406926, 0.12062371027388652, 0.0818298074722994, 0.9140743733605814, 0.9209678685980015, 0.9071853798462544, 0.9117378951018945, 0.8658491480666214, 0.877698837373165, 0.878636294288161, 0.8339506131357848, 0.8479540856942325, 0.17375918883826802, 0.19680068391874572, 0.21473526468647675, 0.15599092405671622, 0.1917093605090655, 0.18857339285488506, 0.18111808155129916, 0.18300340950944438, 0.20830722293730686, 0.19526003241813916, 0.25298639362664477, 0.21161896658651735, 0.2523596104733028, 0.3743586222614772, 0.3092780824606085, 0.41080721110288765, 0.24519066092792552, 0.2372723797281523, 0.11113094546871893, 0.08828536180875812, 0.09811299463786038, 0.1092730552300818, 0.08863032102639368, 0.10971183615155422, 0.11818055848138154, 0.10977200671738285, 0.112009294453706, 0.0977503804371489, 0.05058883322969654, 0.040141631092243224, 0.1309997957287926, 0.12152750566575088, 0.09606828353689578, 0.1060763890868901, 0.08521039912326123, 0.08874525715366433, 0.040058628301776644, 0.022201398237158165, 9.999999999998899e-05, 9.999999999998899e-05, 0.002169863840575048, 0.0032192224085759724, 0.012040749719448685, 0.049665752228791105, 9.999999999998899e-05, 0.05304809111053088, 0.07628679769049818, 0.0705862487233897, 0.09980710090402467, 0.06335736262059488, 0.07120028699310588, 0.08132801960071534, 0.1824708270960319, 0.1652237494714165, 0.00048806321828664956, 0.010339275091062361, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011827220429418972, 0.007889922385405534, 0.0008540609472914573, 0.012432121388279316, 0.0013397042220187894, 0.05520523308598935, 0.062029152076900185, 0.0458901607833333, 0.08245015551724011, 0.09047567655210298, 0.08137884798540929, 0.051482548383733784, 0.086899284196153, 0.07001740151070912, 0.3437754146603089, 0.3587904993459933, 0.38083668135372595, 0.32895916029252026, 0.35340236303495787, 0.3222537724706027, 0.3659533256115757, 0.3296351737441442, 0.35506687026573713, 0.07027454176320802, 0.06583006736722763, 0.07881744117066514, 0.07345932309038217, 0.0818779665154945, 0.07296118597134404, 0.08994247812340184, 0.09451425109519695, 0.07035067689127428, 0.13473105182404377, 0.14862012537100977, 0.1330649606805866, 0.16000759754314442, 0.172920063987677, 0.10798713552684513, 0.1287894321123727, 0.13981422607759175, 0.11446902435411921, 0.2298487582017802, 0.2275888230482026, 0.2524320805435214, 0.21062589177436775, 0.20713405573573473, 0.23553783180790155, 0.23700475680067512, 0.26872956840259477, 0.23961939801822119, 0.1575091217734571, 0.17529013650032443, 0.1760445029900235, 0.19636249687680585, 0.1557248993738598, 0.178107337733572, 0.16628486645434581, 0.20683735870386477, 0.19042847462366386, 0.1862981306899304, 0.1634603199693092, 0.18129992870417777, 0.18876371152114935, 0.14788215613533862, 0.16521228046898961, 0.19465743919879763, 0.1689471623870208, 0.16912719815228572, 0.18357353515900854, 0.17292295321170092, 0.1801293097739537, 0.194243149594867, 0.21717744550141593, 0.18917763028998602, 0.1813412652338673, 0.19229196453109376, 0.17608973223146784, 0.44768031362214655, 0.1492898125372485, 0.1688898829712614, 0.4220596275141133, 0.17714205842790598, 0.14750829550171984, 0.1439222557437726, 0.1686512730892571, 0.26101669485192724, 0.15673469948837937, 0.19286116176602786, 0.1378143534596007, 0.17618898610622602, 0.17334910801653347, 0.14910826636008045, 0.19049254734581533, 0.18707670111779473, 0.18607927126333257, 0.1700498875193185, 0.1744439918854609, 0.17692153073751016, 0.17522371807220682, 0.16337907273284924, 0.17950485884948053, 0.1748642032302936, 0.1685799517904708, 0.19117622750674312, 0.05916950503919083, 0.06446970714009126, 0.06171828283638281, 0.07058747026919576, 0.07924673423734219, 0.06308470049034642, 0.06735475934066959, 0.08109989918553095, 0.08605856811831014]}, "mutation_prompt": null}
{"id": "50ac3abb-43c1-48a0-8719-bdd2a9eda7d4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            fitness_values = np.array([func(ind) for ind in self.population])\n            elite = self.population[np.argmin(fitness_values)]\n            fitness_variance = np.var(fitness_values)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * (1 + 0.2 * (success_rate - 0.2) + 0.1 * fitness_variance) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive mutation strategy by modulating mutation factor bounds based on variance in population fitness to improve convergence speed.", "configspace": "", "generation": 34, "fitness": 0.1778278521335101, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "ac7cca83-34c0-47ed-bc2d-eb5844a6739f", "metadata": {"aucs": [0.41847739636127024, 0.4207516827148986, 0.5083679182158611, 0.45725734069522816, 0.5343581452976519, 0.5428718728286613, 0.4985109617610507, 0.4666813146011938, 0.4378205023649787, 0.10060689005951318, 0.02178103495493755, 0.0648547988500624, 0.0613240950259597, 9.999999999998899e-05, 0.10429972886784522, 0.1238610724932574, 0.08883319836487613, 0.1537617325102123, 0.08912266512014955, 0.08932087481745188, 0.07640058242762626, 0.08051254428114296, 0.07254213313508429, 0.11611234982446528, 0.09121140898151747, 0.10507074218903967, 0.12130491865700965, 0.08733221936875235, 0.0836737602552372, 0.10388135334838877, 0.06641516096118594, 0.10366328884690323, 0.0795370906427777, 0.09204333867427317, 0.06720442600759857, 0.09472957859600506, 0.983097427880528, 0.9942321576767413, 0.9842161471260116, 0.9916577808171039, 0.9910706860365253, 0.9948796931624317, 0.9582035185780768, 0.9928659982702877, 0.9852496662449535, 0.10761181838190348, 0.12924229222978556, 0.07081905134162392, 0.1447866205320688, 0.09619403120603331, 0.09366996388771365, 0.07413814372051253, 0.1317984251336235, 0.13716390099965048, 0.18121336378778674, 0.19309894869548438, 0.21251958410452354, 0.1552436671791746, 0.2354125089852529, 0.15716603901435466, 0.12691424392736295, 0.20482163175724377, 0.22187442342054875, 0.0858203878939543, 0.01303998289504793, 0.09704721686194828, 0.11625524924051844, 0.06766383348223659, 0.08472688944199347, 0.03695405848144617, 0.10542539899924264, 0.10074224282123923, 0.07188286461005322, 0.015416684593429264, 0.00936427257071859, 0.14310153170679973, 0.11507884687489933, 0.10380074197675826, 0.1656635011147528, 0.10067440476755796, 0.06982304032429076, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00680548234959244, 0.03296061970603492, 0.03306902113339616, 0.029665321144246803, 0.041880092038402816, 0.08437086990220344, 0.035958855333260376, 0.10668734061096985, 0.013700334675655013, 0.0626107157127822, 0.012036111840674879, 9.999999999998899e-05, 0.006129888729341837, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002334180064850422, 9.999999999998899e-05, 0.011045615402713649, 0.08215270531701169, 0.07236385693554725, 0.0463239285679552, 0.07392617218886066, 0.015464945803919217, 0.03220160072821432, 0.06508965771313147, 0.04998200819497689, 0.05752874007152897, 0.3638335914936861, 0.31937459486901965, 0.42200423639315876, 0.336222650240366, 0.3615502127032354, 0.36126993975371113, 0.4377729735909587, 0.3845475804325066, 0.4002809946834055, 0.055649973652399654, 0.0680217393415804, 0.11285064375209053, 0.08454558654720967, 0.07336494599606758, 0.06916132697463384, 0.08830373214083032, 0.05578625909901602, 0.054657374239794665, 0.1459048858634886, 0.14727395408091304, 0.15410871417257388, 0.14975873223904435, 0.11028015687349002, 0.13119170390099466, 0.24199571175587287, 0.1271684186773807, 0.12271428845748611, 0.23077085455129986, 0.2622446274456841, 0.19525865419929767, 0.2479217952225342, 0.25392708664712904, 0.250300802164669, 0.27673775798813194, 0.2371437363847535, 0.27061101096071083, 0.15644135219177902, 0.16317062840344265, 0.2025613904683674, 0.16793182700835618, 0.15105785398331173, 0.14796735226522428, 0.1619259473784277, 0.17030887748863466, 0.22382204176519738, 0.2156804432348277, 0.17153084573823363, 0.20490992723553814, 0.17744864436524732, 0.18133318080221839, 0.18434399326375284, 0.17463305188054068, 0.1482040465629596, 0.21887971183585941, 0.15760746065477138, 0.15660887426532866, 0.18261161118593927, 0.16220409198868713, 0.2844371308962761, 0.1779070958326585, 0.17814375114460657, 0.15785272390366756, 0.16912147335549665, 0.153350367858883, 0.11154666302172223, 0.14692435605755605, 0.2233034883977818, 0.1614645613103739, 0.17246617320097468, 0.1650399060305413, 0.14574110150405994, 0.19095272270167984, 0.31135648541470595, 0.16572947613254396, 0.15966241788773328, 0.17073932886517684, 0.17760809477381534, 0.13709362945247483, 0.1845984856939472, 0.18152316698067472, 0.17774666339873946, 0.1733211661010131, 0.19120608199184685, 0.16223703478093154, 0.20790700386265515, 0.1635007492702738, 0.17595413766494783, 0.17946569203299279, 0.16418532504629768, 0.19762098831520725, 0.061716716000953964, 0.05462941162779866, 0.05985953400572508, 0.08005331292862083, 0.060324462295657355, 0.061563732414594785, 0.06027234278827487, 0.05996351888120266, 0.05520211653579443]}, "mutation_prompt": null}
{"id": "e1af71ef-c67f-48cc-abcb-abb7e5dd6e7e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                # Adaptive mutation factor scaling based on dimensional variance\n                var_factor = np.var(self.population[:, i % self.dim])\n                F_dynamic = self.F * (1 + 0.1 * var_factor) + (np.random.rand() - 0.5) * 0.05\n\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive mutation factor scaling based on dimensional variance to improve exploration and convergence balance.", "configspace": "", "generation": 35, "fitness": 0.1726566644168828, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "ac7cca83-34c0-47ed-bc2d-eb5844a6739f", "metadata": {"aucs": [0.36209372943117824, 0.36309035961068414, 0.36189398260747707, 0.40282012788132393, 0.40197635924222896, 0.41407446206511356, 0.3933016138839188, 0.34700773908368077, 0.4028586808984391, 0.07474972509015565, 0.07625598036664427, 0.14108326301506935, 0.10518868574690365, 0.12380777695000489, 0.07350879302038882, 0.11719766245795016, 0.11575830621884109, 0.15683596915662967, 0.11559387993743808, 0.11475805862698185, 0.12438669994373908, 0.11094435727969887, 0.16177124721333946, 0.12540757855078843, 0.09678763449529848, 0.10327878995954798, 0.10643039325333703, 0.09300160585308237, 0.07354131700256583, 0.09812561962131017, 0.09149099665928839, 0.08391927107516806, 0.09706471113528292, 0.08207391034875, 0.09858424853486614, 0.08181287596209241, 0.9219802824787331, 0.9266743060739664, 0.8673889410833866, 0.9191459472594365, 0.91810767539706, 0.9127453482743747, 0.8890532607473955, 0.9099111140949911, 0.9535825376295823, 0.1372762715607987, 0.13932682756753145, 0.13213216786568205, 0.13693682837982668, 0.11652528319611433, 0.1418721762565256, 0.16260725182714975, 0.12749829431439352, 0.1523531805889745, 0.23534971838469876, 0.20227005603114123, 0.16925733953297006, 0.23713174988945407, 0.30867313311479827, 0.21884726230302953, 0.1731149284066782, 0.19748695986202203, 0.110583643074604, 0.10820820167989265, 0.10222843155078731, 0.09692664649130112, 0.08519580857402309, 0.0942797814022559, 0.09854442376525607, 0.07871616832063155, 0.09511860566515074, 0.105205512761122, 0.008906683755372624, 0.014291444103473827, 0.09855737055342229, 0.09504831161932847, 0.05999569329854326, 0.09719924066437347, 0.0904727770867294, 0.06405660259664514, 0.08849239559438338, 0.013626893953818997, 0.013059641984920933, 0.003081358508478682, 0.0014792615736507475, 0.00010438171671378615, 0.003558077361734635, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06513260281029709, 0.08341150194458313, 0.15439776591317678, 0.08246698072176151, 0.04603752568201691, 0.09694381737791102, 0.029937513833668716, 0.0815218803533524, 0.06723518286832297, 0.008201844556361748, 9.999999999998899e-05, 0.0031291025138944217, 0.007598426310137074, 0.020899187827838617, 0.00500728606016132, 9.999999999998899e-05, 0.011772072701784264, 9.999999999998899e-05, 0.055961887179443504, 0.042902954962713014, 0.06201017623229799, 0.05860999587703375, 0.06631414418884651, 0.07074467306013921, 0.056661357228098286, 0.06665984130647173, 0.06099906776023345, 0.3301232472959529, 0.3131649117701133, 0.3648030759155265, 0.3140412541351244, 0.3444994956851122, 0.351945867719638, 0.3631800050334436, 0.3025851351385259, 0.3306108352226409, 0.06927772375439012, 0.08862324958131429, 0.08275408063425382, 0.07294768090570891, 0.06528254407208933, 0.08943057094670315, 0.06594890918860397, 0.07489968235840516, 0.0755777184922587, 0.15265835640609637, 0.13349797100966276, 0.1283183614331077, 0.17048889210870877, 0.13319861503204045, 0.17702821124251933, 0.14309711892574373, 0.13018644420905912, 0.1948075648668467, 0.20401938972709976, 0.19724609014003247, 0.272312132358989, 0.21115850202275155, 0.21990733252076577, 0.18473744708584416, 0.21535246712243095, 0.25700577647051237, 0.2467652466109559, 0.15257200053125763, 0.1706896320085154, 0.17353262019803262, 0.1267528350535938, 0.12827301166578886, 0.15265037076025967, 0.1798402172143384, 0.17889517454683534, 0.2195343695143599, 0.16948077737088973, 0.1858086711710073, 0.1538655783913775, 0.1645383927482893, 0.16278270212729107, 0.15788695408239095, 0.18797872280534622, 0.16296807735742436, 0.18018339858286236, 0.18869935139103533, 0.14254921612914662, 0.15812571847563595, 0.1830302653756063, 0.16715308887792635, 0.16845806502132543, 0.16182923331109345, 0.15526159221735958, 0.18235095680654279, 0.14668969639645257, 0.14943061108788347, 0.1257857006141958, 0.256255765749976, 0.1651139868055307, 0.14489734593929315, 0.15188816959320572, 0.13785454361314842, 0.15466875710891304, 0.35792394358557555, 0.1955290116445355, 0.170843715170376, 0.09565708442772447, 0.2751122151208776, 0.18703209382139818, 0.17409290475744654, 0.18647232273987246, 0.11386777895487099, 0.17872678128961383, 0.16028968684065203, 0.17560579016882516, 0.17059227620605033, 0.16342106063128992, 0.16009240071794428, 0.17755036350528186, 0.15509133043708645, 0.1753959088386038, 0.058080065696383465, 0.06236026037016218, 0.06474094847011169, 0.06966409300238008, 0.07045683736746688, 0.0665118207676818, 0.05323328129107774, 0.0664158539681341, 0.05750280524107476]}, "mutation_prompt": null}
{"id": "86617bdd-2841-4b92-be30-d19582e60971", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                # Adaptive adjustment based on success rate\n                CR_dynamic *= 1 + 0.05 * (success_rate - 0.3)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive adjustment of crossover rate based on success history to balance exploration and exploitation more effectively.", "configspace": "", "generation": 36, "fitness": 0.18562017265433492, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "ac7cca83-34c0-47ed-bc2d-eb5844a6739f", "metadata": {"aucs": [0.40307639231307324, 0.42299377410574956, 0.4029539814942579, 0.4299684063576774, 0.42220430114960317, 0.42863826400267657, 0.440766863558925, 0.40439729068043784, 0.3931339719047664, 0.12179248172244006, 0.144602688102894, 0.12222981971815483, 0.11532128819822318, 0.10000391528090002, 0.159907597521038, 0.1103377591889887, 0.11639263332836713, 0.12751598128856512, 0.16931292900354622, 0.11373451856429562, 0.11359552008068896, 0.10310240270372995, 0.11115444426584054, 0.11102233438003006, 0.11107233934629313, 0.09946170047756209, 0.10595069969574511, 0.06894914717183342, 0.09433773801010226, 0.09645352208128921, 0.1027931608494046, 0.09304286335826162, 0.08485922072935481, 0.07303991097412799, 0.08598323515050688, 0.09712059995978928, 0.9175166302079658, 0.8703039714686598, 0.9080033680002907, 0.900393307148716, 0.8347324891344823, 0.8401168181229695, 0.9006038785748691, 0.8253700526323715, 0.900191084791182, 0.16800739270987164, 0.20043207769666682, 0.15488228142470362, 0.14477163799698733, 0.17086934571684664, 0.15643279066192894, 0.15592904817051312, 0.17138218726107768, 0.1749703438342589, 0.297763679751223, 0.2596652789187087, 0.23609396412841444, 0.2574390425070703, 0.2482461525876446, 0.2063341163054211, 0.36687909697530163, 0.20665899462562698, 0.22163131913511624, 0.12608320040030174, 0.13022204101997648, 0.08917573350559926, 0.10728489150724907, 0.07198513132960016, 0.11797944804891614, 0.19345958860958312, 0.07121287464685244, 0.11302980705702625, 0.09330192570155471, 0.01715716731236494, 0.1520153067403206, 0.12264810936272408, 0.10502249039823741, 0.13088448020586474, 0.08628345744425259, 0.09866031350107751, 0.07890413855931089, 0.010935731806096194, 9.999999999998899e-05, 0.0015470829998528446, 0.00016971080085004253, 0.02807936344139894, 0.0011578074604150501, 0.03147674881278417, 0.05575492383501346, 0.025353796739879697, 0.11067368061101313, 0.18205674634750857, 0.05243537906607676, 0.027451562938815566, 0.09475875597954653, 0.062386357980647844, 0.0772649341500522, 0.08498868897633438, 0.07331985624786574, 0.0007094115241245147, 0.011250824358113864, 9.999999999998899e-05, 0.004698716127833902, 0.0061352565445297325, 9.999999999998899e-05, 0.00630987952090778, 9.999999999998899e-05, 0.00040553957748490355, 0.06633420677524104, 0.06540763956582762, 0.08018842102581925, 0.06451539132260098, 0.05394293078082013, 0.0790193725683277, 0.0713267861485789, 0.0817168179658938, 0.07400400379827021, 0.3413803096864624, 0.3407032928217434, 0.3625982404552198, 0.3267458913901319, 0.34080806645844264, 0.32866405893634265, 0.3725432514936895, 0.3144816314600991, 0.38066215887847354, 0.08477523214547378, 0.08729790894887068, 0.08622981207485936, 0.07391465294220267, 0.06436215342289908, 0.08506749092303967, 0.08069654078857114, 0.06980324553276585, 0.09952077166924522, 0.11358254606681839, 0.14893884459337692, 0.12096384842573005, 0.1502839797716522, 0.1337418428849746, 0.1673218630960127, 0.16545505707927877, 0.2136833120756183, 0.14977160040071535, 0.24611241241963788, 0.22015014432068714, 0.25209574174610394, 0.21218059473382955, 0.22956427281942338, 0.24147632468679292, 0.2629031566633122, 0.274459413043991, 0.2512924646967609, 0.16375757361954002, 0.17042580896949622, 0.19217369322637767, 0.15847529286014506, 0.16102759836475034, 0.17418166947652625, 0.19212716525153262, 0.20327054295272062, 0.21588673266833436, 0.16944093585504816, 0.18468843777230992, 0.16625777027985422, 0.16800104305358277, 0.19086949117205887, 0.1764105619673757, 0.1861611752394886, 0.18010470692806013, 0.16759800801731328, 0.17867715370300752, 0.1723483011205028, 0.18775875099143846, 0.19222174254904634, 0.18566177049026478, 0.1674604119053713, 0.1945675303359079, 0.16173430614017215, 0.178853537656807, 0.5315454151547097, 0.1545017162011174, 0.16664344808447784, 0.1753262328225923, 0.1751011189454479, 0.14889006912694147, 0.16953497436641496, 0.11560297914027484, 0.33417504978900714, 0.254711835075663, 0.19115331784622225, 0.1529757289393845, 0.165813754174431, 0.19967857617989848, 0.3159217922194074, 0.18512601643898874, 0.19025739138701292, 0.18614325017683042, 0.17080967038972872, 0.1762490042052468, 0.17620023022543896, 0.1638068023879421, 0.17776855964729732, 0.16575157132279472, 0.1724218543230972, 0.18304203322195034, 0.18999366237326598, 0.06280442924664398, 0.05875140261744105, 0.06834968942343544, 0.053653388270822555, 0.06353279530343448, 0.06816389645489584, 0.06072058515058165, 0.06886553246911209, 0.0772651997567485]}, "mutation_prompt": null}
{"id": "4504b573-09b0-4604-8177-ab7694bff692", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    # Dynamic adjustment of mutation factor bounds based on evaluation progress.\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5))\n                CR_dynamic *= (1 + 0.05 * (1 - success_rate))  # Adaptive scaling for crossover rate\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive scaling of the crossover rate based on convergence feedback to improve solution diversity and speed.", "configspace": "", "generation": 37, "fitness": 0.18820509244309738, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "ac7cca83-34c0-47ed-bc2d-eb5844a6739f", "metadata": {"aucs": [0.38033675673540235, 0.4010597916982144, 0.4378615978654763, 0.4727934698396923, 0.4215528765061075, 0.412074742787649, 0.4017106530369856, 0.40200586321283527, 0.38591418074191264, 0.12117379262797767, 0.14462110020374852, 0.13639152181915504, 0.10320235608165318, 0.15811389853630586, 0.1411089437434383, 0.15220152861517766, 0.1106634702166257, 0.12692064055988794, 0.11069436612045569, 0.10638620941627519, 0.14571445449538423, 0.11975235846098853, 0.12271686189513331, 0.09554790745776687, 0.11669701100771057, 0.13600136860546685, 0.09898305117438777, 0.07918344328168403, 0.09395190720082824, 0.09884550917461399, 0.08670253349112866, 0.08072896037522115, 0.090081132968163, 0.07981583770669021, 0.08761467927551514, 0.07362470067100113, 0.9145229653724365, 0.8987152384945857, 0.9070727582124604, 0.8961608064312194, 0.824619363203789, 0.8201334116249791, 0.8680551853313403, 0.8187425286062971, 0.8388821151056043, 0.20245766141193222, 0.1864680063175943, 0.16625091536765835, 0.18967805009251848, 0.1495176117439232, 0.1683740364227544, 0.16146330353200444, 0.17763201934347073, 0.1771692727226769, 0.1998768427022275, 0.2079233258352816, 0.18408013340758334, 0.36641901597072435, 0.268590090510489, 0.22723035144498782, 0.2555348530583006, 0.23148595156007012, 0.24483261222999098, 0.1143170142746952, 0.11455476752420546, 0.11429757854962863, 0.1129767175655727, 0.10695375748567626, 0.14057745771109076, 0.11472828639136223, 0.13668965466117877, 0.1097655416976524, 0.08593471275832743, 0.1052705607358021, 0.041947779371896865, 0.1137640102170373, 0.13308401607295417, 0.20950204869321043, 0.09075773979059465, 0.1046642374551977, 0.14247991407281113, 9.999999999998899e-05, 0.004714371656317606, 0.005608008407565479, 0.0031447361194348877, 0.05963738854473344, 0.01677651000291569, 0.004132963340501061, 0.023322125247439596, 0.009469542301139722, 0.11372912964427873, 0.11260282658975573, 0.06603347367881729, 0.1144499740716044, 0.035888982761534516, 0.10392949720379696, 0.15298555975870964, 0.1520308490770923, 0.07396280260446164, 0.029923297980900543, 0.0013713768178422736, 0.013331816120862094, 9.999999999998899e-05, 0.007209777802506645, 0.003518846258268926, 0.0197853915048658, 0.0015096321151606418, 0.0021143664746823276, 0.05673134717266726, 0.0831359065367604, 0.07572886523422517, 0.07398248042425037, 0.06243230554294166, 0.09204707962755054, 0.07053666362599764, 0.08021584579080066, 0.0876803905885376, 0.3328384307232888, 0.35088829024041956, 0.3746500495288796, 0.3393331842245336, 0.3279386227427957, 0.36466929270857107, 0.3536341001855451, 0.3404981545928225, 0.3612032507436421, 0.06971401324238902, 0.09626056765939606, 0.07791584273752672, 0.06206632666650225, 0.08926105244171889, 0.07115287400430226, 0.07666437887798006, 0.08251780115298402, 0.06666635393885156, 0.13041735683268108, 0.11930343591115711, 0.12797886200112585, 0.1637288205827967, 0.1370683082676425, 0.13279080207420324, 0.15491950230520468, 0.1518743487246671, 0.19167339558230378, 0.22828288672876196, 0.21831811235879728, 0.24897418920569525, 0.24756336514956656, 0.2341255863889926, 0.2044104328402926, 0.2421404124545714, 0.29643024741154045, 0.25918906772852757, 0.17640133303794792, 0.1745604715542799, 0.17829382548778627, 0.1604988959620619, 0.17680548231634985, 0.16714006807452464, 0.20175104854063897, 0.19302909194924245, 0.19850650626078636, 0.17551380813354478, 0.1665722795046498, 0.20350678334539196, 0.18208873253714575, 0.18683820405286145, 0.1767694316608599, 0.1630322411799181, 0.15565341037347535, 0.16509875209984926, 0.19101060256288316, 0.1705923032730221, 0.19035409882484533, 0.2003340916941776, 0.16970425818719104, 0.16710823536898312, 0.18449806358776732, 0.2213618584824446, 0.20817263364956184, 0.36107664529565164, 0.10371165207946176, 0.13854195876415865, 0.4570930341939564, 0.17071708824132115, 0.14549509638752844, 0.1591203239001634, 0.32366502501876926, 0.40111178484831644, 0.2550773108871701, 0.24437665756164828, 0.21368830499646474, 0.19039947260141432, 0.12269684613274279, 0.1816951412032306, 0.19187955294866565, 0.18486477411692426, 0.19072930395543863, 0.1659245027370655, 0.16866019629876172, 0.172023646372367, 0.17752336673037827, 0.18922015862237807, 0.1874288261779241, 0.189459764013021, 0.16627655786141748, 0.17542891838404617, 0.06271606845613764, 0.07463100622290963, 0.0702927059079258, 0.058333924120102854, 0.06733973072658028, 0.057601414222554936, 0.06622689131969817, 0.06704559832403334, 0.0771906580944638]}, "mutation_prompt": null}
{"id": "f023ac6f-d076-4594-abd4-5930b9200af4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Incorporates adaptive crossover rate scaling based on population diversity to improve exploration-exploitation balance.", "configspace": "", "generation": 38, "fitness": 0.19127689912105458, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "ac7cca83-34c0-47ed-bc2d-eb5844a6739f", "metadata": {"aucs": [0.4185467785357522, 0.37369656207005153, 0.37798831432405144, 0.41514749839579534, 0.46322517636308913, 0.436347421815118, 0.41117863291087486, 0.3555244780850906, 0.3396325060398876, 0.17780784011149076, 0.12494992339398614, 0.17006742743445702, 0.10485061277566388, 0.11649756543638645, 0.12450740593426313, 0.1578662150106973, 0.1396311173174739, 0.15226462848040023, 0.09660546529747138, 0.12087910989931228, 0.11912915880628627, 0.09317325746550853, 0.11082143347935458, 0.10455549137372855, 0.13170672556557106, 0.11419017599362702, 0.14870635271479804, 0.09700481754842549, 0.09562469455528988, 0.11207841223571435, 0.09366076365386944, 0.08702937654172382, 0.09347375025669713, 0.09883786712459564, 0.07912129893585607, 0.08894965885458916, 0.9263150372933003, 0.7985610995023996, 0.8709504248179716, 0.9290033502443872, 0.7995752019881918, 0.6642755458470294, 0.732807534855121, 0.8473263000692601, 0.8953322668575534, 0.1789734444914689, 0.1695322597891611, 0.11414259560804418, 0.1621140140159949, 0.1847713577071427, 0.16075457985676844, 0.17762807086311805, 0.16536292699392308, 0.19122929137718336, 0.23930129913006448, 0.46543257875532007, 0.5103010157208316, 0.2677520185324527, 0.2529612864609895, 0.23806471887164893, 0.2551064673006528, 0.28364380466219963, 0.3151475484512467, 0.11794132105967325, 0.09200875254661078, 0.11347411876814295, 0.09291184708157796, 0.08967261616821853, 0.10066403532454771, 0.1150888317700014, 0.10882480835747288, 0.10610748179276286, 0.10692107718059596, 0.015972220984972973, 0.0954604207799693, 0.10579941224165756, 0.09246756724345373, 0.09555081149196654, 0.11833574738568409, 0.1341732873230761, 0.12406662218726883, 0.023749180625188826, 0.02519013415427307, 0.051697847102857075, 0.03026955472244186, 0.037130006508649394, 0.09464848945816362, 0.04410176395340781, 0.025873727118555512, 0.012179613984214521, 0.1475446540509192, 0.17345014870179898, 0.12494351525910374, 0.1426526061207627, 0.13040441168182637, 0.15228545719524533, 0.15423057760522874, 0.12009493227628865, 0.1811201087684703, 0.0006660732960154236, 0.02095408110575514, 0.008014318909740359, 9.999999999998899e-05, 0.015087372262815757, 0.013303968927355858, 0.00857561648236993, 0.021264743830317623, 0.0064522776339159815, 0.09201942798021356, 0.0688730801268761, 0.06025626976993803, 0.07734759678700942, 0.06483718170367281, 0.08904479403182286, 0.09859858138167032, 0.08803259218967763, 0.11240271189639695, 0.3511193072744033, 0.3552214790357716, 0.3470622479742206, 0.3443942586634411, 0.3344873524986015, 0.34878187787362236, 0.3868901674506413, 0.346792875550768, 0.37359522763631037, 0.0667482098080614, 0.08892539167501945, 0.08353558064159439, 0.08630972307077733, 0.06585053983090439, 0.1005287482849988, 0.07682371630695684, 0.06897128202655911, 0.0887068371781512, 0.10317258031409549, 0.12407152313397729, 0.11842175776965747, 0.11458259243793678, 0.13704085135617117, 0.10798713552684513, 0.11938557107820047, 0.11968384889200556, 0.10518756701174625, 0.2488662624871315, 0.2174167252439897, 0.23217689648570994, 0.22336704095933724, 0.22940308781729113, 0.21738916854436752, 0.25585241335487374, 0.2845020070489097, 0.2723073950751407, 0.20494624609818024, 0.14308848258753226, 0.18114435674205165, 0.19701117969312731, 0.1674600611667313, 0.15168659366299764, 0.1859798434721478, 0.16552621979200144, 0.1744079605860246, 0.15399195979235192, 0.19109835997439006, 0.2609142831517819, 0.16969363759274458, 0.15351286376610496, 0.1820170154432219, 0.1755075843835182, 0.15579401356751243, 0.17890912805436543, 0.1736532883767159, 0.17269059523231933, 0.17381482022207007, 0.18517313006110336, 0.1651710308881842, 0.16972712313519023, 0.19208692421535412, 0.17490600832524628, 0.1782373698099078, 0.17339184675876018, 0.44640943221298635, 0.11217013571701462, 0.11452605218432332, 0.5486499483986637, 0.4185554193602615, 0.1721426984477581, 0.14566981369881216, 0.12178488083536665, 0.3598701917196294, 0.18458851210333738, 0.38076718761952943, 0.2066035972549165, 0.1754182726229605, 0.15811579894018324, 0.18977584468044129, 0.2050136528235571, 0.28770491767288764, 0.17003425421102425, 0.1551216267059362, 0.16709254440647459, 0.1776127502358411, 0.19158414090106257, 0.16859106250827705, 0.17308337002838958, 0.1686743670383607, 0.18156514185047312, 0.05599619745986806, 0.06518600968717003, 0.05627098676595488, 0.054181885823256226, 0.07160388666168094, 0.06937086710019025, 0.05869600191624924, 0.06266587898008635, 0.05912935561404753]}, "mutation_prompt": null}
{"id": "0fe098d9-8800-41d6-8a82-dcf0db04d002", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                population_spread = np.std(self.population)\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2) + 0.1 * population_spread) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhances adaptive mutation by introducing a dynamic scaling factor based on population spread to improve exploration.", "configspace": "", "generation": 39, "fitness": 0.1791477836216482, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "f023ac6f-d076-4594-abd4-5930b9200af4", "metadata": {"aucs": [0.38871793483744876, 0.3476145174957155, 0.3613823110667752, 0.3320931366680382, 0.40058293941891565, 0.38064555485907403, 0.44731332686570335, 0.3622396869847726, 0.3513873775477908, 0.10387019511198559, 0.06492233729815611, 0.11416616552937797, 0.09196232728437648, 0.14001108143161423, 0.09926435327753658, 0.12890027371631607, 0.09330791092046986, 0.127493128488551, 0.12131832695001898, 0.12842777892725166, 0.1251893933731466, 0.09958624704752927, 0.09311824936396096, 0.14711095564136156, 0.08935311762875575, 0.10779305079816182, 0.09283118168722171, 0.08366177045895495, 0.07100059545584281, 0.09858874522981476, 0.11644228704554094, 0.10483277503984523, 0.0939949513266023, 0.10688312619119622, 0.09975219278453895, 0.1106539854490638, 0.9513348373593918, 0.9508612204347631, 0.883114255834782, 0.9763893056636361, 0.8090001965234006, 0.8660234931790047, 0.8978734975800018, 0.8981903250070356, 0.9374434583067736, 0.15656848116593014, 0.087331905660335, 0.16393988377894186, 0.14158851680537898, 0.16236617032501688, 0.1568069970644852, 0.1015475194918557, 0.13643675278114153, 0.1688186063668765, 0.2541587420784449, 0.3212389888043946, 0.2259256394935233, 0.25110086717157687, 0.22929097313622238, 0.2149686863349317, 0.19080819489687828, 0.20409486135534438, 0.40742997509390866, 0.09001452085896289, 0.11814444573136429, 0.08981941315391673, 0.09616380463308183, 0.1135871877778083, 0.11101243186703125, 0.09370038880369469, 0.08187376438410154, 0.09278701436495118, 0.01711410633059207, 0.019225617126714445, 0.008866697258570144, 0.10492756577890794, 0.10890394604244624, 0.09192560062329613, 0.13979591062784602, 0.07351365676652855, 0.11523992229210966, 9.999999999998899e-05, 0.029800636317022677, 0.02432536849326916, 9.999999999998899e-05, 0.02900190242653733, 0.005827040345083523, 0.017075090526402215, 0.02863009885136414, 0.012019604415320795, 0.14170421585361692, 0.12358016009279449, 0.12282006777151333, 0.16121581710176447, 0.03882613515364153, 0.06897347375979412, 0.12493108562162125, 0.14331806452030904, 0.15275998960195825, 0.0001616263968957643, 0.001785160192265156, 0.0026539706073206437, 9.999999999998899e-05, 0.008144611846527039, 9.999999999998899e-05, 0.006250811802274492, 0.014402763153387399, 9.999999999998899e-05, 0.05509427703951386, 0.06405324165779036, 0.06157926777235612, 0.03825748153507191, 0.06489409307572891, 0.06924096982771066, 0.05588473230813029, 0.061013185546107906, 0.0473512044746649, 0.3176029884548337, 0.3093871948053054, 0.3449918937342431, 0.3269803002125068, 0.3133241765698783, 0.3390363750692641, 0.36344594399812113, 0.34622554209898315, 0.34502463082985846, 0.07786498682225595, 0.08696451627019963, 0.10743682442194002, 0.07578183286184648, 0.09006997340426537, 0.08985388555935148, 0.06893597166884025, 0.07341791428327471, 0.09853523438662615, 0.14229809628210754, 0.13096290526741683, 0.1431464242088688, 0.1613189420151495, 0.13681733726925305, 0.18207817936425197, 0.1522634503060406, 0.14317055345086083, 0.13851614532242051, 0.21725234550832506, 0.20355858563194384, 0.24726213018283005, 0.22117670414715962, 0.2085464094200885, 0.2418798429896747, 0.2335926997745561, 0.28002891626660953, 0.2409033240424333, 0.1632871660686147, 0.09836848271042964, 0.169587362831369, 0.14900930455450512, 0.1495185178538181, 0.1349558783439042, 0.19924780540002884, 0.1782169229593854, 0.21215436652602737, 0.17824832389379863, 0.17073593750013605, 0.23230392820166856, 0.17586320016943702, 0.15102171414214005, 0.19384686754936808, 0.15551655402144793, 0.16701058807091218, 0.18683212250375136, 0.18525504427699524, 0.18637411400743464, 0.1855472662017036, 0.1713159659830158, 0.1563150226380574, 0.16138646041476656, 0.20587356836695714, 0.16185223707447438, 0.1741048225737608, 0.15505653262096641, 0.15592791554038066, 0.14278326936102403, 0.15413605995932045, 0.1667516554759828, 0.17201040898874964, 0.16705937653537295, 0.15852302275142305, 0.16961418689004915, 0.32444744168987605, 0.25860165691258263, 0.18359212727080298, 0.13709882346739977, 0.13773140937129724, 0.4103504124213918, 0.17090799003913448, 0.18850222876220923, 0.1900937044725901, 0.16785986547401677, 0.1667041534649779, 0.16026097024776187, 0.18062251867391566, 0.17474648156156547, 0.16913931463958976, 0.17952810184681933, 0.16476463995326907, 0.18581152570336756, 0.05487866857570811, 0.06384198397160434, 0.05640098226416268, 0.06272048622804627, 0.06763892934793025, 0.04626499381286375, 0.05168248397821684, 0.08647213329704262, 0.04623430156003161]}, "mutation_prompt": null}
{"id": "abeef31c-197f-4c49-8459-7a62f2ed481e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2) + 0.05 * (np.std(self.population) - 0.5))\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces a dynamic scaling factor for the mutation factor based on diversity and success rate to enhance convergence.", "configspace": "", "generation": 40, "fitness": 0.17770104444339177, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "f023ac6f-d076-4594-abd4-5930b9200af4", "metadata": {"aucs": [0.4329825121053559, 0.3654087233879202, 0.39306431794075414, 0.3247970657079101, 0.36679044803644234, 0.352442048963424, 0.38697908468755804, 0.36516662146579215, 0.37688350937450743, 0.10709094383048356, 0.10738624821157106, 0.12158793097013276, 0.08726173401306547, 0.1521617705024324, 0.11843550525024527, 0.09301783559852428, 0.062041072610987014, 0.13030273748863708, 0.08099044713671666, 0.10195359462889153, 0.07539078563223844, 0.09883295903166922, 0.09819858602406095, 0.09263379454851561, 0.08626777902274985, 0.08857951628525007, 0.09459406102251, 0.09488733291919793, 0.10264136552629244, 0.08437572014877459, 0.10336949185768662, 0.09104861276086362, 0.08817925911239821, 0.067494476735106, 0.09116742514147624, 0.09648353044326319, 0.7265251169398419, 0.6512848779143523, 0.7482521684181176, 0.8522562396297613, 0.8915707623876734, 0.7970390790021818, 0.8959042195101221, 0.8288740554279082, 0.9044705869004068, 0.18293699878096792, 0.16621478302603265, 0.15362688631540622, 0.15313415414546272, 0.14786885419021378, 0.1470698085519172, 0.14202274574986518, 0.20617260364319367, 0.14470849071631942, 0.20618227368140352, 0.26081349360098494, 0.1977696178413012, 0.23820007366143026, 0.23147135117184447, 0.21449877842410092, 0.27043926246670724, 0.1986608809895818, 0.24697069389868842, 0.09903139048241905, 0.08335996575010662, 0.10349273035587447, 0.07463940168682426, 0.11190897863209048, 0.0827169975508043, 0.11258545778618523, 0.11891360676173135, 0.10579919992246456, 0.09444656959677267, 0.00887338379877578, 0.008889421583966217, 0.08717885832709549, 0.11317389789731647, 0.14542053773795982, 0.12230766523291181, 0.1279016373673425, 0.10132216494431268, 0.05230439571979861, 0.005977626866795038, 0.07272040310218486, 0.023345445741446147, 9.999999999998899e-05, 0.022742950696759023, 0.02774234416117638, 0.011197132656549869, 0.016058910814794047, 0.027092565465966056, 0.139583727476569, 0.10486808865136832, 0.10115557125834895, 0.06275669864164846, 0.092056685666014, 0.0912652308766646, 0.10950260109057419, 0.1362616349935033, 0.003357828172703581, 0.006481635057805968, 0.00173083172591193, 0.01704538681476786, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008870178080978564, 9.999999999998899e-05, 0.0018252465233030701, 0.06498521710589233, 0.08461013117639415, 0.06764037654082711, 0.08521867637583125, 0.06034697049850257, 0.05838763745474129, 0.09880375424489085, 0.09987610942075986, 0.07971126714675669, 0.3287980368657032, 0.3685331438595616, 0.36435093481912995, 0.316451972479765, 0.338452851094193, 0.3498168461105584, 0.3374005012074528, 0.3490777652010457, 0.32441446257551476, 0.08053977396276424, 0.07692125837837371, 0.09368363903665089, 0.08318128030165517, 0.07258522367762876, 0.07769887163788314, 0.06655662874690604, 0.07126028433410414, 0.08212581593830492, 0.1193772075785764, 0.14126212006949723, 0.14006439161948092, 0.15581572735720362, 0.1846542801360943, 0.10798713552707517, 0.16944121811296242, 0.11707290225370492, 0.13168051210906273, 0.21177663917112577, 0.2350611460341161, 0.21519801989999643, 0.24812766449130963, 0.24748441116531894, 0.2589808014463407, 0.24278878673253335, 0.28799508915420946, 0.2474583116386564, 0.1672603267237449, 0.15697427732425073, 0.19151411959704134, 0.16602648301557565, 0.15656605025749326, 0.13788727196636097, 0.154987184768537, 0.18602308336804707, 0.19090697277923296, 0.17000177060116917, 0.14868484298841544, 0.17723792186042142, 0.1900800934050978, 0.17124585351906774, 0.17389558579810704, 0.17375407999730685, 0.1621748222567012, 0.19691337792990082, 0.15519580243325382, 0.16837268454460796, 0.1873526785484595, 0.16283587559718615, 0.18838859367615102, 0.17090102840059995, 0.17349917553488592, 0.19841787047078852, 0.16696706681762752, 0.14649219600731778, 0.13495645246752008, 0.30935329689889035, 0.18032594847588757, 0.17562363028152372, 0.4305983324317375, 0.16798444936261936, 0.1363171971056587, 0.14038499033142393, 0.3644169682493976, 0.18296492583449475, 0.3901161141106184, 0.16675105688815473, 0.16914761788599242, 0.25278960584856347, 0.19222530367912682, 0.39640097908130334, 0.17117695047847137, 0.1504986831063041, 0.1538226009400372, 0.1668147828511506, 0.1797667585992505, 0.1688834761003738, 0.171920370782237, 0.1781538666272483, 0.1900149933165064, 0.1549472718708741, 0.058168840334826055, 0.07960449045955231, 0.05788714905928882, 0.056414712595145966, 0.0626357133679265, 0.06019723792447962, 0.06659078148211306, 0.05007016355083871, 0.06513747200977904]}, "mutation_prompt": null}
{"id": "cb4809e9-8c76-4b9f-b63f-18e113a6dc8e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        improvement_trend = 0.0\n        \n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2) + 0.1 * improvement_trend) + (np.random.rand() - 0.5) * 0.05\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    improvement_trend = 0.8 * improvement_trend + 0.2 * (self.best_fitness - trial_fitness) / self.best_fitness\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                if np.random.rand() < 0.1:  # Periodic random exploration\n                    rand_ind = np.random.randint(self.population_size)\n                    self.population[rand_ind] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive mutation scaling based on fitness improvement trends and injects periodic random exploration for enhanced convergence.", "configspace": "", "generation": 41, "fitness": 0.07095584655291083, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.10.", "error": "", "parent_id": "f023ac6f-d076-4594-abd4-5930b9200af4", "metadata": {"aucs": [0.1747334602770314, 0.16700200420135625, 0.13604387406123786, 0.12273185680961574, 0.14836819068323237, 0.16484431239089425, 0.16266693096272977, 0.14274412745924714, 0.12892391459283858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014735155429882574, 0.022072469388406124, 0.019447046600844287, 0.034867151861829315, 0.03312825166229305, 0.016267467516961953, 0.021425263448139775, 0.026929105254088426, 0.019309086193930125, 9.999999999998899e-05, 0.02268033355965604, 0.016317173414703734, 0.021329484857309233, 0.0296844601672559, 0.007239183538109151, 0.02207136561965617, 0.01916789656444584, 0.012474507649256728, 0.7241791982485378, 0.10348290944502847, 0.8874332024434197, 0.07920031913616388, 0.4095470890122773, 0.10629196519333162, 0.11828080476124359, 0.23203622876875252, 0.5931352130368955, 0.07387501890078418, 0.032598384417789394, 0.002089540155959191, 0.03902047667851971, 0.01583756181343776, 0.006830747941401372, 0.05930080941748894, 0.027874383841682726, 0.009543357282753684, 0.14536581634689105, 0.08523874761343408, 0.09798142344306993, 0.08432571796269472, 0.07984485483746817, 0.0704713064869813, 0.04792414068271933, 0.05931056463008866, 0.01249862140350122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03626837594474508, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008753661777974986, 0.013691588561779433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003589685713789703, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003347793561611634, 0.007221449006951874, 9.999999999998899e-05, 9.999999999998899e-05, 0.00032203108024564386, 9.999999999998899e-05, 0.0022207751745684234, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1556120824756052, 0.18187390088756406, 0.16081308772969383, 0.17351578345734342, 0.16218665975496238, 0.14772038636357065, 0.16280239092930315, 0.13662867309967064, 0.19124923814328476, 0.02973716267202342, 0.01564002341155557, 0.0353677563416579, 0.03266886175302153, 0.03231829622373994, 0.023594336856830544, 0.014627188491458165, 0.01811454773658827, 0.02681492126097962, 0.09010351784603521, 0.08609370886951495, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08633687200294715, 0.07731711347711478, 0.11498242213016108, 0.14074152163006493, 0.1613932299901244, 0.13800672315110074, 0.128694637358721, 0.12291757557693839, 0.12028165949079228, 0.17825800740697528, 0.13143230446187248, 0.05985564337097804, 0.05240212561289059, 0.08922870581851983, 0.05873086313254461, 0.07124164012665135, 0.0768657076417758, 0.09145963054142625, 0.10467434407790766, 0.07979001577439881, 0.12780740308325822, 0.13697247033075632, 0.1635850118523433, 0.12347300253087978, 0.10846011511080955, 0.10896891037713907, 0.1473166657784084, 0.11142492225676415, 0.1376741630376469, 0.07329992748979497, 9.999999999998899e-05, 0.028414869877365856, 0.0667244567415719, 9.999999999998899e-05, 0.04515050575569057, 0.05753512445512965, 0.04706448980158162, 0.025619097841358185, 0.08578282047404828, 0.11092373656741583, 0.082401149457063, 0.1340487083885462, 0.1207914665021157, 0.06661401029160186, 0.14906531986966642, 0.10511484148144368, 0.06972660672683728, 0.11917630508628607, 0.10267165755511809, 0.07672084362726195, 0.0506857903344724, 0.08588042256254991, 0.08224116405256188, 0.08413406240080512, 0.14615380249354148, 0.05253676191811607, 0.1550871124049421, 0.14400800346219533, 0.14763022729669195, 0.131847583797146, 0.13847447508573585, 0.14893581234726438, 0.15364018714161143, 0.13307075790142608, 0.14689007985489466, 0.03407724560812897, 0.03147574621577165, 0.05480509716135207, 0.02843535851927792, 0.03425093938292756, 0.038124233758185966, 0.032108242346047144, 0.03886886590265881, 0.024967508176691133]}, "mutation_prompt": null}
{"id": "79f9ee25-35b9-47e9-8af8-4cfdf237adcf", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.8\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                \n                # Adaptive mutation based on fitness improvement\n                improvement_factor = (self.best_fitness - func(self.population[i])) / (self.best_fitness + 1e-9)\n                F_dynamic *= (1 + 0.1 * improvement_factor)\n                \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive mutation strategy based on fitness improvement rate to enhance convergence speed.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('mean must be 1 dimensional').", "error": "ValueError('mean must be 1 dimensional')", "parent_id": "f023ac6f-d076-4594-abd4-5930b9200af4", "metadata": {}, "mutation_prompt": null}
{"id": "b454887f-1783-4107-96f7-70fa0f4c2484", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 * self.dim  # Increased initial population size\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.4, 1.2)  # Adjusted mutation factor bounds\n        self.weight_decay = 0.98  # Altered weight decay factor\n        self.min_population_size = 4 * self.dim  # Minimum population size\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.25)) + (np.random.rand() - 0.5) * 0.1\n                if np.random.rand() < 0.3:\n                    dynamic_bounds = (0.4, 1.0 - 0.4 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.15 * (success_rate - 0.5) + 0.1 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.0**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite \n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive population resizing and mutation strategy based on diversity and success rates to enhance convergence efficiency.", "configspace": "", "generation": 43, "fitness": 0.1671089352196284, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "f023ac6f-d076-4594-abd4-5930b9200af4", "metadata": {"aucs": [0.30613396973013396, 0.28793966314219, 0.32146689217984503, 0.3247022294485301, 0.3389490371325403, 0.3508983218128834, 0.3213870974084587, 0.3172264030008952, 0.32071872397279766, 0.07068964624469276, 0.07341703599966454, 0.06844093700165688, 0.09308845660490461, 0.06786110262025646, 0.06990835697670228, 0.06420782615877563, 0.0816373654767214, 0.07357722961013968, 0.07704207986825617, 0.07771269582621321, 0.06905117654099158, 0.06140473106384292, 0.07704604425960293, 0.09200278820419061, 0.07538105338598822, 0.0814090622310012, 0.07803705946219797, 0.068665138332351, 0.0775186037628608, 0.07210402733303012, 0.06503897271893855, 0.07703911494269011, 0.06375497796104324, 0.06756536160478277, 0.06734641217862658, 0.057215907544490796, 0.7978093599758712, 0.9214422290149643, 0.893910635612517, 0.911315789004487, 0.8132684597566767, 0.8799189965533091, 0.6890386304324015, 0.8878534706038379, 0.889082586356514, 0.16265866714844068, 0.11576821173112839, 0.12516559746408096, 0.13518608105783192, 0.12878282004200425, 0.14890478157796982, 0.1363273807125508, 0.20029335888907895, 0.15093455889161655, 0.24302398833692962, 0.23230566166390354, 0.19673922724243165, 0.19476652162200392, 0.22354988719264712, 0.1872855385258808, 0.19347493283810302, 0.2441318547960083, 0.2527897581741374, 0.06113310043849174, 0.07002498787325317, 0.08383876888943664, 0.08631163459208968, 0.11376237998172178, 0.07594548189465478, 0.07902266338122554, 0.09164288908545803, 0.08894020634700661, 0.01806095260492735, 0.057367562616169376, 0.05868021629135578, 0.09213993389088937, 0.06937782642970447, 0.10281800215483705, 0.060820632284831144, 0.08483843569316873, 0.04898277464847012, 0.013204197905572812, 0.02915258395107234, 0.013028102674996656, 0.028377388615658306, 0.023286026951974792, 0.024492685723428997, 0.0041599561337037905, 0.0020784876817462328, 0.034254978166988415, 0.13988599828333592, 0.11899595784532502, 0.10193564974597302, 0.13631556945314494, 0.11986827927908139, 0.12142328517429157, 0.12822441700776177, 0.15545811977529123, 0.138503332696016, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042629013866828824, 0.06031644722263896, 0.04010287872882434, 0.06820473754425216, 0.052163029256586224, 0.05629776718469315, 0.05327968216636547, 0.0831652202223413, 0.053071900170027386, 0.29314295121409184, 0.3549129150165927, 0.30333684447170517, 0.30423210100235487, 0.2880465608205812, 0.2835430981664846, 0.2880771452194767, 0.2920732890227359, 0.29642649193009185, 0.08312133454505388, 0.05838208653151922, 0.08342702907742039, 0.06466696709059794, 0.07842506939172567, 0.06633023068929889, 0.07868082686752353, 0.0701842623794855, 0.07148117961756872, 0.1304723373805169, 0.1419053617872018, 0.1392697078887979, 0.13766266535167815, 0.11787087244602412, 0.13797443998593717, 0.14503218365624526, 0.126790584581996, 0.13247725831203938, 0.2172156851229724, 0.20159550351385092, 0.22849961475046277, 0.2062039183013269, 0.20205205642392987, 0.1995695415636909, 0.19623841320778201, 0.23070422657739098, 0.23473785277855252, 0.13576524278638735, 0.1581673099027121, 0.14961575496270485, 0.14623745657271736, 0.14828805021212899, 0.12645440847107225, 0.1491307334899531, 0.1596330022897655, 0.13313637692506686, 0.15938835912594074, 0.1869856364225997, 0.1568251139414435, 0.1597247797475999, 0.15717402697742322, 0.18036323806815102, 0.16851410216836615, 0.18978756971509936, 0.1554733886160271, 0.18645043672129047, 0.16153691231010947, 0.1508136651474804, 0.16052990610742723, 0.1644336627172046, 0.15676988745830645, 0.15212581082578858, 0.15223573938648338, 0.16798389484215326, 0.2735471533803716, 0.23220535896415562, 0.2871299655845839, 0.30994033913640273, 0.2513401580430308, 0.2240599478126747, 0.16853829632831696, 0.2971749850513873, 0.1620727604315727, 0.26560547603273865, 0.3274725692247271, 0.15936797644289147, 0.31035410164812005, 0.2737240058408268, 0.1177721597732776, 0.1877462303033932, 0.19747552530474033, 0.1882970777309605, 0.16748372573332415, 0.1739940902213677, 0.17334909944569332, 0.17037578744805504, 0.1678138702799037, 0.16788216287558755, 0.16485764672513104, 0.1697940200843745, 0.18655977181420802, 0.055829910978666186, 0.057161975474410376, 0.06611594346114236, 0.061010503172698516, 0.06243548547440314, 0.06133324550312502, 0.06573877055683353, 0.07220433470193732, 0.059659874372769095]}, "mutation_prompt": null}
{"id": "4ccfba6b-1797-4895-bc8a-40e0b0d98ed9", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                dynamic_mutation_bounds = (\n                    max(0.4, self.mutation_factor_bounds[0] - 0.1 * np.random.rand()),\n                    min(1.2, self.mutation_factor_bounds[1] + 0.1 * np.random.rand())\n                )\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2)) + (np.random.rand() - 0.5) * 0.05\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces stochastic adjustments to the mutation factor bounds to increase adaptability and exploration capacity of the population.", "configspace": "", "generation": 44, "fitness": 0.19205095916995307, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "f023ac6f-d076-4594-abd4-5930b9200af4", "metadata": {"aucs": [0.4036662106940331, 0.38841499154210557, 0.42592376528934706, 0.3735228484229639, 0.4131045769188417, 0.40262961329362357, 0.37983270656247026, 0.44212535249596663, 0.40872123750006306, 0.0946183925623334, 0.12453945575032777, 0.11858252212725362, 0.11041045074188771, 0.12310329908224615, 0.16661209922931153, 0.12328625606213717, 0.13391129819684888, 0.14205699408862404, 0.12014532377966403, 0.12076459785076843, 0.139096493568461, 0.10416381948682707, 0.10251597075400354, 0.10817291906476967, 0.09477008402486153, 0.10101148419272699, 0.1134487378350233, 0.08061146124382634, 0.10324485622979451, 0.1020111060842046, 0.09644955807505395, 0.10279563126344604, 0.0999404037498478, 0.10595796470753338, 0.08385181601001712, 0.08866992078022218, 0.926803852601195, 0.8657963475619108, 0.8770106071779367, 0.8944215552656591, 0.8713245936448392, 0.8479882365852576, 0.8977006545913593, 0.8956809406703672, 0.9366123198537261, 0.1779593571093876, 0.1658829256879979, 0.16733342143235608, 0.1581980808130249, 0.13794420497504123, 0.17960157203563498, 0.08478019202345144, 0.14738078179047187, 0.1727142005491592, 0.39168545781038067, 0.35921886776763345, 0.2335890035079099, 0.2572441261718854, 0.2801252010431796, 0.2276388724600653, 0.2933648133129523, 0.2484896325422754, 0.40610811592924956, 0.10340611852137227, 0.10196312627085191, 0.10037086449381916, 0.1551757463465817, 0.11408208323705549, 0.10942907131091784, 0.08738503573156065, 0.11057728315104032, 0.11184586692421139, 0.11938654117155767, 0.0832246105312121, 0.10780564075776222, 0.12919127970907252, 0.09380056234544065, 0.09892242380631544, 0.0954065515782655, 0.12034856924427606, 0.09948528287863667, 0.06799597064359386, 0.02238890306548058, 0.01499971121185828, 0.06143665535274445, 0.035265031294191784, 0.05153437623358548, 0.013564832242335956, 0.008450380150069159, 0.024086061231969325, 0.1195364109719943, 0.10931247288714951, 0.1109106937350065, 0.1370720661973157, 0.10844715012079287, 0.18176225974968496, 0.17376440109189717, 0.15819298977330887, 0.1429726186805056, 0.00033414671212361746, 0.0012492521217256636, 0.003831042968378773, 0.002237704621721015, 0.004221259933268828, 0.0037823121252853475, 0.0028636844488966195, 0.0018541502217108707, 0.03268178297150737, 0.0809050931084101, 0.07741733615792823, 0.0738004566454179, 0.06125663527977854, 0.078926877239346, 0.0879643939094662, 0.08360373640707475, 0.07440574613441187, 0.07647553275361518, 0.33624504836166624, 0.3411502036087881, 0.34722775568962483, 0.3691649572859095, 0.3525115811428735, 0.3436215213082072, 0.34986049260625585, 0.3207834583794277, 0.3313354544532634, 0.09468244207148013, 0.08995716031109391, 0.07941447719526407, 0.10784254868466303, 0.06348630834286484, 0.10511264167381706, 0.07952297829289978, 0.10558293063143631, 0.11249851018030699, 0.09964800717425149, 0.12463156020511212, 0.11842175776965747, 0.17744548452130926, 0.12019490371007813, 0.19656418572954926, 0.13542374101729093, 0.11015601046183598, 0.11430392853395843, 0.24871952198550074, 0.24550454562402613, 0.2813954757407655, 0.23120398095230488, 0.23810407782341858, 0.2427232426664867, 0.25112948700760984, 0.2769825229509223, 0.24441486895980136, 0.18919859734064515, 0.16848703116967012, 0.2285215277414827, 0.15541692863758183, 0.15789872413821537, 0.1751437272183617, 0.21952895178578147, 0.18537617240015747, 0.1581833812469362, 0.1511388207946831, 0.18895584516392483, 0.16941484302801668, 0.19150363609741472, 0.18560241465249017, 0.17173210249800885, 0.1853369920504997, 0.16866682698447055, 0.16262320731424096, 0.17205412683636845, 0.16595301625290937, 0.17837659815927787, 0.1871040452678776, 0.18386866528507384, 0.17305058112157934, 0.15745783247243728, 0.1756168845619852, 0.16230680373544204, 0.16437300715285796, 0.12140456846017655, 0.16722690872322987, 0.16261214691885817, 0.17924094053200224, 0.5338311846034386, 0.16904478894407204, 0.1151045234766025, 0.30180903978189466, 0.3272068543252501, 0.19230895102184709, 0.3492552653707427, 0.3433000991726187, 0.18345086145671918, 0.3843332149797857, 0.1861334103429948, 0.1836127377050607, 0.19586458183192001, 0.15305730725085653, 0.17406717629502177, 0.16448855409557617, 0.16564484680929958, 0.16777698139828934, 0.16787242228598276, 0.1706072563358625, 0.18999159404130495, 0.17945494031159137, 0.05634420244641036, 0.05852206434434504, 0.062039600118054095, 0.05887683278985478, 0.06596315882537962, 0.06678055291194074, 0.06744740234864588, 0.057721607140312714, 0.06415859857256256]}, "mutation_prompt": null}
{"id": "61558421-5ba6-4d47-80b4-223fe4283352", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                dynamic_mutation_bounds = (\n                    max(0.4, self.mutation_factor_bounds[0] - 0.1 * np.random.rand()),\n                    min(1.2, self.mutation_factor_bounds[1] + 0.1 * np.random.rand())\n                )\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2) + 0.05 * (success_rate - 0.5))  # Adjusted line\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive mutation factor variance based on past success rate to enhance convergence speed.", "configspace": "", "generation": 45, "fitness": 0.19424200648545967, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "4ccfba6b-1797-4895-bc8a-40e0b0d98ed9", "metadata": {"aucs": [0.3925214372479532, 0.3713002783488606, 0.40701071870421746, 0.403695374548366, 0.4146311293753271, 0.4866652627435658, 0.46798134711548145, 0.37430939097871385, 0.41411378843159685, 0.13292129833891153, 0.1237775096121333, 0.12777452296242697, 0.1071659247164769, 0.13105989238962157, 0.11259058209757389, 0.11736065831063647, 0.12658866594628582, 0.12822164752025733, 0.09200202536350877, 0.10319455535227184, 0.07910014828987455, 0.1172385143541207, 0.10435028184780515, 0.09163145487231483, 0.11804257810575913, 0.11003109146619572, 0.09624187327785272, 0.10490210902715358, 0.08831959982574067, 0.10271124616770266, 0.10473667772860595, 0.09393275057988415, 0.088718994125071, 0.10506407591708444, 0.10501729119312131, 0.08864083777234899, 0.8774249421525021, 0.9475036298463876, 0.8813403046690856, 0.7062481064091884, 0.9181746592991638, 0.8715351621738066, 0.9101714396767243, 0.8808272540040467, 0.9887507067044343, 0.18226065531571667, 0.1984037776063906, 0.15239250772758206, 0.20405456608137207, 0.15912120888526204, 0.21228746823551237, 0.16251031107135605, 0.181747023658425, 0.16029087731935565, 0.3017500228382691, 0.2543312754339372, 0.19911935134418135, 0.2986325857399489, 0.2656790296867967, 0.3940439408756089, 0.4332560551344594, 0.28904510621014723, 0.3847013289751692, 0.11456813099629182, 0.10670693403546994, 0.1665698075493548, 0.16491615732765164, 0.10909703476858357, 0.102116363438989, 0.10871960685336413, 0.11656719847846686, 0.10750445382052365, 0.018480712500441032, 0.11429972765984986, 0.09925250459664747, 0.10800641040537573, 0.17636886846022393, 0.1567852242254767, 0.10871606216578344, 0.09679774196704471, 0.09776709278105988, 0.06360513124070444, 0.04514719373843712, 0.011615697524914093, 0.012040082558268161, 0.015317624358616166, 0.022709578673524633, 0.0261800614815747, 0.042929004928618064, 0.0001258017910801268, 0.14096773812618923, 0.1444707716096213, 0.19204067051933926, 0.14942180298343777, 0.12480654978796779, 0.15620477812303157, 0.1191835350538295, 0.0999773736770454, 0.14924633655602448, 9.999999999998899e-05, 0.008149227478335574, 0.007707420481626315, 0.004007642515594156, 0.004093034824731001, 0.0005556324156364978, 0.009734217591987893, 0.02411784129432859, 0.0062957408446986385, 0.0720876160623124, 0.0794462673402877, 0.08371684397958035, 0.10253439765748285, 0.08240652087009603, 0.09032453440219501, 0.07064926587059073, 0.07973481722576858, 0.0790841821830065, 0.32177215139799165, 0.3697236602155267, 0.3609922762835961, 0.3336827988403218, 0.34365108842717007, 0.34280225619345506, 0.3604221906967311, 0.3697805612433863, 0.36396824910352354, 0.09142677813146272, 0.07456148672126506, 0.06805137419597596, 0.08428600783821816, 0.09358726988169852, 0.08300806616019363, 0.07821248972421979, 0.06581373688055392, 0.0834491590147729, 0.09280256023452804, 0.11353053489023046, 0.12197066495851028, 0.14230250676475809, 0.20125998359112596, 0.15415835868465422, 0.12652858752840968, 0.1116793582740696, 0.1341367885953657, 0.25602442080839527, 0.20482501589819968, 0.26510022917633824, 0.23801284139586898, 0.19045668764621893, 0.2285843983308461, 0.23090078165934536, 0.27881618817072973, 0.22761683685305123, 0.1806433397752949, 0.19384034180824128, 0.17887530049211886, 0.17375826551869245, 0.15693545144618615, 0.19271351565518902, 0.17935436755214396, 0.19698233964951128, 0.16739689601046825, 0.17232447387935568, 0.16605564414480378, 0.175878225464844, 0.1811518617372897, 0.15735468785706508, 0.1657561428625035, 0.18078255203931204, 0.17387488241209792, 0.17199710090738718, 0.2506101550456912, 0.16159107793570437, 0.18490298398206806, 0.16732691711271985, 0.18910588080537094, 0.16261978557608514, 0.16746254731472476, 0.17849540955130283, 0.17670533862343596, 0.5196860531595675, 0.14700365667901338, 0.13520698828639632, 0.38721344220259035, 0.3306301953686923, 0.20538213404224315, 0.15456666256829832, 0.18185021176388672, 0.485976251881743, 0.27383045941439776, 0.19165875382591024, 0.1498029050577777, 0.2174467613568032, 0.31247425870645884, 0.17220348765237958, 0.22749569035005957, 0.18630581681819391, 0.12650690507919116, 0.16679892062753954, 0.16301782728306702, 0.16041739882085126, 0.1680217279259255, 0.16947164255209501, 0.18735889669278238, 0.16262639598998507, 0.16338885965225203, 0.16855356069266714, 0.05993614433810779, 0.06681149099219952, 0.07708322097633447, 0.055307271059338525, 0.0682656052944538, 0.06404872097117897, 0.08025761714319546, 0.06110643944630989, 0.05302339708635295]}, "mutation_prompt": null}
{"id": "80eecb9e-619a-408d-94a2-884dbde4227a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolutionPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.8\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.98  # Slightly increased decay \n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2\n        dynamic_CR_factor = 1.0  # New dynamic factor for CR\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2) + 0.05 * (success_rate - 0.5))\n\n                if np.random.rand() < 0.3:  # Adjusted probability for dynamic mutation\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * dynamic_CR_factor * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                    dynamic_CR_factor *= 1.05  # Increase CR factor on improvement\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n                    dynamic_CR_factor *= 0.95  # Decrease CR factor on stagnation\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolutionPlus", "description": "Incorporates dynamic crossover rate adjustment and elitism to balance exploration and exploitation for improved convergence.", "configspace": "", "generation": 46, "fitness": 0.1683770587073274, "feedback": "The algorithm EnhancedHybridDifferentialEvolutionPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "61558421-5ba6-4d47-80b4-223fe4283352", "metadata": {"aucs": [0.3939899395712577, 0.36952648637748453, 0.4081029150780381, 0.3755785913804581, 0.4058168127724714, 0.45624548341555726, 0.3783743138029647, 0.36839666237519186, 0.4212620127784644, 0.07493103648273991, 0.11554043314505658, 0.08833219146876836, 0.0925667148019449, 0.12358017096832574, 0.09631511829673123, 0.06964701595496259, 0.11819752153151841, 0.15678918403455178, 0.121231006832632, 0.14697334324665912, 0.1440458400435316, 0.1515590423119133, 0.15108661517503297, 0.15011762660454786, 0.12360282277911305, 0.11348816169559994, 0.11581689166502851, 0.11209481538143773, 0.11358938466605573, 0.10886100692906042, 0.12843136302266234, 0.09625226109801299, 0.1117382782774965, 0.1484500377650727, 0.10465082667006831, 0.11479709093281432, 0.9264192454875507, 0.880025548194757, 0.8406333406748153, 0.8711355459754204, 0.8540411600091478, 0.8828568260755995, 0.8626673125771541, 0.867513325742873, 0.8196411381548628, 0.11042739506758537, 0.14890628703458697, 0.13441415583197525, 0.09177787053526476, 0.10729686713735376, 0.12369610135650855, 0.11411885917567577, 0.13103434965246574, 0.1202345573152579, 0.12282557063978805, 0.16251800271893446, 0.13688806866321868, 0.23518606941968123, 0.16773568714428888, 0.156033944983913, 0.15560867204237272, 0.15220505150843078, 0.14505560002163798, 0.08915363268116505, 0.09589953272914442, 0.12130251241177648, 0.10123928278642758, 0.09207674932122878, 0.09632603998411216, 0.11085167271250917, 0.11455406788484201, 0.08458118574072138, 0.12691023661066703, 0.06745282282737686, 0.09055537131258573, 0.08407943957494213, 0.07620785144639197, 0.08611714506861479, 0.09494824431123483, 0.08319176105697645, 0.11913735319134067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006149496203997629, 0.05296611758776182, 0.062043967880591855, 0.04874985467714288, 0.05021482421842771, 0.06046896644010136, 0.03587855377281923, 0.12072279261371222, 0.04467983063732428, 0.041841308131635224, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04296898513940328, 0.025986800110007424, 0.03167153625558039, 0.04519707119739147, 0.034419074404532735, 0.03427697198587465, 0.041197820042634725, 0.0425362848081422, 0.045976892346971776, 0.2968782518239187, 0.29704108262074125, 0.303618549202495, 0.3125463059045409, 0.3131254413689658, 0.2825671324498874, 0.30118721625871947, 0.29597213883889095, 0.30354226637738, 0.07216897710590109, 0.08136717391091386, 0.0612723239581181, 0.07553065902525091, 0.05754730210333814, 0.08526701167539863, 0.06742357774334973, 0.06642817898544984, 0.06392226330727391, 0.13537111805927504, 0.1781425059400773, 0.1379646312124685, 0.17503858127639382, 0.14081166721576466, 0.15605179773183808, 0.12499233946656241, 0.11598725390996056, 0.15050080660531306, 0.1701650228828676, 0.16629115012929652, 0.2202851476814781, 0.2114083914109155, 0.1931727580431266, 0.19685946735056503, 0.22933992768601175, 0.2183920652491279, 0.20548241679010204, 0.12056903464432578, 0.12181328098676025, 0.16401224793023594, 0.1289351890257382, 0.13468033456658557, 0.12609969944860056, 0.1469187013262122, 0.13561771088807584, 0.11287285676626457, 0.16479568099395914, 0.15904877087238833, 0.16123622207235477, 0.1859683245559517, 0.1895724401519524, 0.1750199942836873, 0.18473326065477724, 0.17185919369134628, 0.1857200199286323, 0.21169930518603608, 0.19144101677957814, 0.20640105871121328, 0.1848052433846864, 0.15681482605138608, 0.17726495006939147, 0.17353856450637228, 0.16188529812009056, 0.16812921137440295, 0.25021501401046, 0.2892443159484661, 0.22011445280411168, 0.4558183800765173, 0.20698787213337755, 0.16737060493454048, 0.1643026167166055, 0.14637707851752235, 0.17474015075684568, 0.2307960581539299, 0.1552738750993421, 0.1739357867370791, 0.15277666406598034, 0.18717582348034456, 0.16619521912736468, 0.1761475827076312, 0.1786526672958142, 0.15513325769247144, 0.1735657331703282, 0.15985264726001902, 0.1776238901290541, 0.16968887082211637, 0.160443802922278, 0.1941201493752296, 0.1863330046032432, 0.15884005388528932, 0.17995082133406926, 0.07259774708242928, 0.06283131820471721, 0.056036156200099274, 0.0799503504226865, 0.06765203961153798, 0.061888385997020845, 0.07506738671932467, 0.06543816735401875, 0.061618321161310496]}, "mutation_prompt": null}
{"id": "f695a1e3-f632-4420-99f4-e9135bb59a05", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            \n            mutation_factors = np.random.uniform(self.mutation_factor_bounds[0], self.mutation_factor_bounds[1], self.population_size)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                F_dynamic = mutation_factors[i] * (1 + 0.1 * (success_rate - 0.3))\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.1**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Utilizes adaptive population resizing, enhanced diversity management, and non-linear mutation strategies for improved convergence.", "configspace": "", "generation": 47, "fitness": 0.18554976917025207, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "61558421-5ba6-4d47-80b4-223fe4283352", "metadata": {"aucs": [0.3264943692565977, 0.3283044262899911, 0.3301846758803083, 0.3742361595654038, 0.3900990733126435, 0.3771687396935802, 0.3695024932153358, 0.4056084122334037, 0.36463390842152155, 0.1012064825603638, 0.1613870598872159, 0.07828434901742909, 0.08441909368380451, 0.08402221837125468, 0.14115946367781884, 0.11927719803448167, 0.10229205119585982, 0.07149142738353842, 0.09664966408998754, 0.09292679546261517, 0.11089201896288048, 0.07021668288391669, 0.08379558869358295, 0.07892027746132058, 0.08645815976537452, 0.10009768714579292, 0.10446106176618741, 0.08916963865967187, 0.08696031844073204, 0.09029909084831711, 0.07130843294904443, 0.08141770365546186, 0.07511604993815213, 0.09363068029094024, 0.07187399421360918, 0.07543255587411002, 0.8870591230459557, 0.9258098329822817, 0.7936356905293445, 0.7102812465039419, 0.7488764054213282, 0.8891313022527599, 0.8898900909371243, 0.8664469297751632, 0.8712098279070725, 0.16948585783634484, 0.16401459757570325, 0.15329287082287812, 0.13171342172436362, 0.14785612604042675, 0.11856925206541213, 0.12984079090567213, 0.13001333073001786, 0.15381505671031914, 0.2390857354279311, 0.3023982322230515, 0.23825645038445764, 0.2604922567169837, 0.33989972678811586, 0.24890690729797194, 0.2899191610359203, 0.24550851655164396, 0.2581257824016383, 0.09142205013179316, 0.0858198298858468, 0.10498481984734642, 0.08598247949425186, 0.11837950532786778, 0.09923135382803283, 0.10497539759219887, 0.10124613063360954, 0.1235875844975195, 0.1010081696022107, 0.040498628850171414, 0.08540934680368317, 0.11789939052413212, 0.0818737386699866, 0.08728809462429021, 0.09692109934672732, 0.07412997146829714, 0.09481896013790014, 0.0748026103913515, 0.04930584078869493, 0.05590713782668777, 0.07159409898801772, 0.06328284112180826, 0.05964400436840189, 0.03543496412941294, 0.05919636379946536, 0.023275737841559896, 0.16866105804801335, 0.16588427446570442, 0.1720939265104804, 0.1822121493284885, 0.16545973919220558, 0.16552531301380458, 0.15995105346968597, 0.1468252632567244, 0.17476633730289615, 9.999999999998899e-05, 0.00020462711301716396, 0.0017007762567807783, 9.999999999998899e-05, 0.00012140953428119161, 0.004302624273012201, 0.0004964346841130896, 9.999999999998899e-05, 0.0005430531359233992, 0.07503872294883784, 0.06472476086870538, 0.07539156507349032, 0.07253607360916137, 0.07506855392576783, 0.05983150847693852, 0.0969987224426424, 0.07304151928557279, 0.06232369492473222, 0.3422103544545102, 0.3229081548602074, 0.3385016749567079, 0.3238582116802058, 0.3191427374739455, 0.31393382896395194, 0.3449651099755764, 0.311646354456668, 0.36156134827022335, 0.07250660110287666, 0.07971487752408635, 0.07096372910323623, 0.07883949438524629, 0.08163871663309585, 0.0701983434147413, 0.07890311604516265, 0.06433094981184262, 0.07561232228081716, 0.11786553119510701, 0.10843980086914962, 0.11842175776965747, 0.14575101867419726, 0.18527202292280032, 0.12196308146387858, 0.15806333997938948, 0.17297180371251275, 0.14080273848042302, 0.2185989557889909, 0.2298794614566475, 0.233061420664593, 0.2428218018405761, 0.21189133206518396, 0.20559904253391503, 0.24158572777223353, 0.2734543869753686, 0.21830790564829416, 0.16561197112047044, 0.15139851318551356, 0.16897296584203925, 0.17064691407576138, 0.16522482870451471, 0.16504983132064555, 0.16501814707527118, 0.1945442156463124, 0.16521013745398505, 0.17207952178708652, 0.16665489231773611, 0.16996359808128214, 0.17747200559230336, 0.18252907185963674, 0.16488167427900968, 0.1903861854730543, 0.17962756358260412, 0.17980770022740966, 0.17321273341776955, 0.16609138204969454, 0.1955452638840287, 0.17337296767141286, 0.1724664501095995, 0.15481056438822505, 0.15757287259472996, 0.1577965605162921, 0.18750731346623206, 0.2456473370071447, 0.24562609479753794, 0.14547340059736857, 0.48771446446744016, 0.17275790652476408, 0.3742854977084369, 0.3861983792180186, 0.12722127439489905, 0.4115175425142743, 0.33127794601383576, 0.21759862255372286, 0.2697109322608643, 0.28426548526466533, 0.2887910746069473, 0.14099483183632366, 0.17898008122769082, 0.16556820275767636, 0.4225112956165049, 0.17462462803686563, 0.16628734269859813, 0.1694902399569621, 0.15679155331434325, 0.16460171478704544, 0.17146702291763227, 0.16384050718667353, 0.18669870770458408, 0.2008581981609724, 0.06486451341350818, 0.056485188180283696, 0.06680088814263985, 0.06003027943705053, 0.07274924014740536, 0.058516353497868434, 0.06188255301469203, 0.06835247211217721, 0.06376963073007391]}, "mutation_prompt": null}
{"id": "50763b86-87f4-450b-ab66-f58c2a4024d1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        improvement_rate = 0.1  # Initial improvement rate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                dynamic_mutation_bounds = (\n                    max(0.4, self.mutation_factor_bounds[0] - 0.1 * np.random.rand()),\n                    min(1.2, self.mutation_factor_bounds[1] + 0.1 * np.random.rand())\n                )\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2) + 0.05 * (success_rate - 0.5))\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity) * (1 - improvement_rate)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                    improvement_rate = improvement_rate * 0.9 + 0.1\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive crossover rate that shrinks over time based on improvement rate to enhance convergence stability.", "configspace": "", "generation": 48, "fitness": 0.17855429438951514, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "61558421-5ba6-4d47-80b4-223fe4283352", "metadata": {"aucs": [0.4373448829190616, 0.4606946676715006, 0.41874368683446894, 0.40557347770853336, 0.43513365601773935, 0.4380225652668981, 0.5151656238843099, 0.4153269238020092, 0.4233360595344654, 0.16310078717276588, 0.10877778598119514, 0.16932403856235267, 0.16607548073647815, 0.11157043263427435, 0.12760660952981784, 0.1332012625425545, 0.08002965693733755, 0.15717598287430867, 0.13693490180880252, 0.1641371749044036, 0.12528604298526314, 0.15639596701560754, 0.16964906129097856, 0.15757954100876415, 0.1585212375638313, 0.1351035715539356, 0.14159012296995332, 0.12941771515013856, 0.1266342396633685, 0.132403160654475, 0.17490603652961367, 0.12459382884662207, 0.13336869843797738, 0.1196054288388626, 0.11179790931999212, 0.11042787769306628, 0.8807939871752952, 0.8557610499939466, 0.8830786530576549, 0.8555481621892462, 0.9384011967579643, 0.8817264063414694, 0.8663571140953915, 0.8516828818957769, 0.8929372339643259, 0.1165392687854363, 0.16120038799371106, 0.08969246085098859, 0.13432612373538522, 0.13428783716919968, 0.15360287533046757, 0.14399724578145268, 0.12429056540980832, 0.14476531405866955, 0.2017496840527483, 0.23797981657789968, 0.17372418838154113, 0.20864258846892814, 0.1837622438550932, 0.17857480109579882, 0.2042022577682746, 0.1847591795893624, 0.17128369134633126, 0.1029081423736341, 0.11208050177692419, 0.12124166521839219, 0.105442801222972, 0.12697528152944693, 0.10367228328346612, 0.13456833618351538, 0.10942294368650674, 0.10236886495356212, 0.08239844791964956, 0.0790969717870399, 0.07782007445057626, 0.08239682073234622, 0.12500406581754342, 0.13290046858276894, 0.1066632450866799, 0.060665070847507385, 0.09079546829110863, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021388728202844653, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03904730365455267, 0.07429063849254947, 0.06085823676998259, 0.01680732928336781, 0.03687747975503586, 0.04602612854632426, 0.057030988574325425, 0.052916507579989225, 0.09914439004366993, 0.004226382753173663, 0.0022037180779296284, 0.0012949544605409535, 0.010230048278456305, 0.003512858265903751, 0.006467041453728561, 0.0011135376777267059, 0.00522287401435928, 0.01714902935545337, 0.0610232679394247, 0.03666680858729776, 0.03508478932363068, 0.05518929443471077, 0.04600164456405709, 0.03206800406795751, 0.07306665909343102, 0.05756210648698179, 0.07162388411760945, 0.32294697995958854, 0.34168603607932346, 0.368368604676105, 0.3386898162139994, 0.31843500930245805, 0.3134773491614171, 0.3645580257165374, 0.3144841064367937, 0.35909232105961886, 0.06791034085804915, 0.07930919308919293, 0.07390440545562782, 0.06781268029549758, 0.07699904826377879, 0.0701208609367282, 0.07877291614783077, 0.07920659317230727, 0.09865770468732427, 0.18810593500245587, 0.130361278641968, 0.16793626806256756, 0.1334335460803282, 0.13029601334286867, 0.12842014267766932, 0.1369166877032667, 0.13928225303511643, 0.1251429931777066, 0.20893611995013261, 0.22793769543397657, 0.25900611485725433, 0.18896721417341233, 0.21016165903107153, 0.20623624474848035, 0.22588923810875272, 0.23500838727140905, 0.21831338083454543, 0.14339613179662358, 0.15223700375867433, 0.15922584502136583, 0.13529405000909467, 0.14337154936017227, 0.15391241417550539, 0.1633456563441077, 0.1588557537686307, 0.1553099045531351, 0.16719685278557805, 0.18952153987602316, 0.16558933473528215, 0.16860760317928603, 0.1510626574791688, 0.16992484035567046, 0.17135266859152942, 0.1672877286168849, 0.16773935197708612, 0.1813053519170298, 0.17908876922395034, 0.1699637241872448, 0.20310861463456154, 0.19339890373268986, 0.17437784428910685, 0.18020073076513932, 0.17849773164907545, 0.1763217342096315, 0.15680871636922744, 0.16937325611785636, 0.13342803773899903, 0.17675502217348804, 0.1771659310213174, 0.16588717955460708, 0.17510861879612172, 0.1589808442206717, 0.14562947117283997, 0.24789276600369958, 0.3790567945536677, 0.15697617857303625, 0.17971397060586747, 0.2872218333175176, 0.25883694383701894, 0.1359391981420467, 0.21174054950019905, 0.1889151359043134, 0.17830246309600428, 0.1809247195494743, 0.16464972532861488, 0.167863458325062, 0.17074606687760008, 0.17327060257523386, 0.1786406813924215, 0.16759428183315417, 0.18282088927404716, 0.06607153071805172, 0.0716726474264271, 0.06279922609221844, 0.05585020653609063, 0.06693593842556833, 0.07547090334416984, 0.06122154171344196, 0.06362923714589475, 0.06926602145790062]}, "mutation_prompt": null}
{"id": "b1aa933e-5384-4512-accc-cf2746e00de3", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                dynamic_mutation_bounds = (\n                    max(0.4, self.mutation_factor_bounds[0] - 0.1 * np.random.rand()),\n                    min(1.2, self.mutation_factor_bounds[1] + 0.1 * np.random.rand())\n                )\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2) + 0.05 * (success_rate - 0.5))\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                distance_to_best = np.linalg.norm(self.population[i] - self.best_solution) / self.dim\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * distance_to_best)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Implements a dynamic crossover rate adjustment based on distance to the best solution to enhance convergence.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "61558421-5ba6-4d47-80b4-223fe4283352", "metadata": {}, "mutation_prompt": null}
{"id": "28607fc1-8ec8-4c71-bf2f-4cabb9f13a51", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        trial_attempts = 2  # Attempt multiple trials for better candidate solutions\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                dynamic_mutation_bounds = (\n                    max(0.4, self.mutation_factor_bounds[0] - 0.1 * np.random.rand()),\n                    min(1.2, self.mutation_factor_bounds[1] + 0.1 * np.random.rand())\n                )\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2) + 0.05 * (success_rate - 0.5))\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                for _ in range(trial_attempts):  # Trying multiple trials\n                    trial = np.where(cross_points, mutant, self.population[i])\n                    trial_fitness = func(trial)\n                    evaluations += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    if trial_fitness < func(self.population[i]):\n                        new_population[i] = trial\n                        success_rate = success_rate * 0.9 + 0.1\n                        break  # Exit loop once a successful trial is found\n                    else:\n                        new_population[i] = self.population[i]\n                        success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduces adaptive multi-trial approach and dynamic adjustment of crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.15354958652007794, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": "61558421-5ba6-4d47-80b4-223fe4283352", "metadata": {"aucs": [0.3330611615254774, 0.2550062686803781, 0.2739604300840969, 0.30364038988957853, 0.30389175085061104, 0.33376228732084756, 0.3495632808930441, 0.3074306051711937, 0.2981745497335102, 0.05104397738673394, 0.0675098282602179, 0.055876760752691323, 0.03294531074922302, 0.0448074251757411, 0.038337657493637156, 0.02066256265152211, 0.06988822442407217, 0.06229585134148252, 0.07752063398824138, 0.07610346328684614, 0.08731798827864312, 0.08188726112587741, 0.06374905296669697, 0.07492986793933343, 0.08821212370705, 0.08358200671460103, 0.0837857597474595, 0.059387566090519095, 0.06210548199698729, 0.07170737803100746, 0.06699877209252647, 0.059447593245812835, 0.07363594661431183, 0.0677852390726903, 0.07266786489066523, 0.07251473557192933, 0.8246101421741919, 0.9278672190160246, 0.8401231217136883, 0.7868395339548508, 0.894944375315969, 0.7859837641832088, 0.8266508766661395, 0.6578076561097665, 0.9853406177010053, 0.15665589001777902, 0.1319601304529051, 0.11185885311856691, 0.1340228703063, 0.09228423865182389, 0.12086017932256998, 0.13308723805931555, 0.10173187452479893, 0.131015790849356, 0.20707902151140856, 0.21260760780985022, 0.17562785548322302, 0.24576329453333212, 0.19243223815930244, 0.16205802367388988, 0.39037650812867863, 0.20705102404044307, 0.17562268851230578, 0.07296899428583581, 0.07445055687520197, 0.07487981631730112, 0.1034181549026233, 0.07516959247979482, 0.08140098757894232, 0.06854767067460199, 0.05125857590448124, 0.08086809043005938, 0.012486142580643955, 0.1079190759930867, 0.08059000982151066, 0.07316068311467261, 0.0707759193759322, 0.06416600037344322, 0.08082239923444101, 0.06758948591689318, 0.05013527832072884, 9.999999999998899e-05, 9.999999999998899e-05, 0.00029172257259924006, 0.03437818128318615, 0.009254116265355328, 0.0002920720234674823, 0.0019711260270911524, 9.999999999998899e-05, 9.999999999998899e-05, 0.09070035590067038, 0.06209847289804915, 0.08011120499855462, 0.0355507423574174, 0.09271081828746697, 0.06173942700220503, 0.13449837528325792, 0.10462164933162221, 0.06546407350425631, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.038612597347160826, 0.03879268088396948, 0.04915721261791495, 0.07203993504289885, 0.03067925495131496, 0.026827239651572743, 0.04253920192207772, 0.03844466948323477, 0.04303987127689868, 0.31082671387465066, 0.32159638528913315, 0.30095574998311647, 0.28016130316589527, 0.280277222694732, 0.3026913712236553, 0.3111234388890832, 0.30300776907063687, 0.27264470845596545, 0.0654786419275617, 0.058763479202786795, 0.06293355285808155, 0.0704350814670297, 0.06463158543545144, 0.08307973443793559, 0.05891187396461717, 0.0679149088241735, 0.05589966177237238, 0.1313393146440036, 0.1478849049630946, 0.14195695446185874, 0.11729564023087968, 0.12913183900896874, 0.14771395044147062, 0.141403887026186, 0.10876193221408359, 0.1057499088302144, 0.19704368216111878, 0.18732108731128483, 0.20809656176704083, 0.21025741797144049, 0.20343005001701087, 0.176904380464729, 0.2456841017761252, 0.22422427464602435, 0.19380711690525332, 0.1578866813297276, 0.12225367733462211, 0.14987437474278142, 0.1395902161810636, 0.13907870657741894, 0.17326452114553526, 0.17790570969700548, 0.14402449667748551, 0.1385624574679859, 0.17399918347181043, 0.1567567145665496, 0.1611004594088481, 0.1859361209016518, 0.1680152135970353, 0.1572492927955793, 0.1940020856681336, 0.15308947080114854, 0.16856214277554704, 0.1471411741231754, 0.16079748579538677, 0.1423513522044958, 0.1571744842197057, 0.17383915622825463, 0.14774943700348964, 0.14696586561550373, 0.15443069027378076, 0.14989785260942046, 0.15234841782643294, 0.13087321951332165, 0.13178408117615958, 0.2500925986734598, 0.1751433670219571, 0.14305394801208404, 0.16117280233261322, 0.1230112410116524, 0.23411041159663315, 0.23782527100268402, 0.17960842552478062, 0.09231533339893727, 0.171595727364254, 0.0956651265905033, 0.18036600881030063, 0.1687767703604175, 0.16434455406858506, 0.17198600830141186, 0.1673795573761332, 0.16580149060161142, 0.15179322588088584, 0.17136195497892548, 0.17886982641817673, 0.1860604301816574, 0.1598775475108012, 0.15928091550610002, 0.1992648640428505, 0.06990348476018449, 0.07166026853774088, 0.06104690660227585, 0.058338656517284315, 0.05598416873542633, 0.06264599058335263, 0.049155927648138475, 0.05897215760725927, 0.06121866484264826]}, "mutation_prompt": null}
{"id": "841e592b-f4c9-4a9d-bc8a-9633a6215c7e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9  # Crossover rate\n        self.F = 0.8   # Differential weight\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.99  # Exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.2  # Initial success rate estimate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                dynamic_mutation_bounds = (\n                    max(0.4, self.mutation_factor_bounds[0] - 0.1 * np.random.rand()),\n                    min(1.2, self.mutation_factor_bounds[1] + 0.1 * np.random.rand())\n                )\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.2) + 0.05 * (success_rate - 0.5))  # Adjusted line\n                if np.random.rand() < 0.25:\n                    dynamic_bounds = (0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                    F_dynamic = np.random.uniform(*dynamic_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * (success_rate - 0.5) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(self.population_size)] = elite\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Incorporates adaptive learning rate based on population success diversity to refine exploration-exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.19424200648545967, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "61558421-5ba6-4d47-80b4-223fe4283352", "metadata": {"aucs": [0.3925214372479532, 0.3713002783488606, 0.40701071870421746, 0.403695374548366, 0.4146311293753271, 0.4866652627435658, 0.46798134711548145, 0.37430939097871385, 0.41411378843159685, 0.13292129833891153, 0.1237775096121333, 0.12777452296242697, 0.1071659247164769, 0.13105989238962157, 0.11259058209757389, 0.11736065831063647, 0.12658866594628582, 0.12822164752025733, 0.09200202536350877, 0.10319455535227184, 0.07910014828987455, 0.1172385143541207, 0.10435028184780515, 0.09163145487231483, 0.11804257810575913, 0.11003109146619572, 0.09624187327785272, 0.10490210902715358, 0.08831959982574067, 0.10271124616770266, 0.10473667772860595, 0.09393275057988415, 0.088718994125071, 0.10506407591708444, 0.10501729119312131, 0.08864083777234899, 0.8774249421525021, 0.9475036298463876, 0.8813403046690856, 0.7062481064091884, 0.9181746592991638, 0.8715351621738066, 0.9101714396767243, 0.8808272540040467, 0.9887507067044343, 0.18226065531571667, 0.1984037776063906, 0.15239250772758206, 0.20405456608137207, 0.15912120888526204, 0.21228746823551237, 0.16251031107135605, 0.181747023658425, 0.16029087731935565, 0.3017500228382691, 0.2543312754339372, 0.19911935134418135, 0.2986325857399489, 0.2656790296867967, 0.3940439408756089, 0.4332560551344594, 0.28904510621014723, 0.3847013289751692, 0.11456813099629182, 0.10670693403546994, 0.1665698075493548, 0.16491615732765164, 0.10909703476858357, 0.102116363438989, 0.10871960685336413, 0.11656719847846686, 0.10750445382052365, 0.018480712500441032, 0.11429972765984986, 0.09925250459664747, 0.10800641040537573, 0.17636886846022393, 0.1567852242254767, 0.10871606216578344, 0.09679774196704471, 0.09776709278105988, 0.06360513124070444, 0.04514719373843712, 0.011615697524914093, 0.012040082558268161, 0.015317624358616166, 0.022709578673524633, 0.0261800614815747, 0.042929004928618064, 0.0001258017910801268, 0.14096773812618923, 0.1444707716096213, 0.19204067051933926, 0.14942180298343777, 0.12480654978796779, 0.15620477812303157, 0.1191835350538295, 0.0999773736770454, 0.14924633655602448, 9.999999999998899e-05, 0.008149227478335574, 0.007707420481626315, 0.004007642515594156, 0.004093034824731001, 0.0005556324156364978, 0.009734217591987893, 0.02411784129432859, 0.0062957408446986385, 0.0720876160623124, 0.0794462673402877, 0.08371684397958035, 0.10253439765748285, 0.08240652087009603, 0.09032453440219501, 0.07064926587059073, 0.07973481722576858, 0.0790841821830065, 0.32177215139799165, 0.3697236602155267, 0.3609922762835961, 0.3336827988403218, 0.34365108842717007, 0.34280225619345506, 0.3604221906967311, 0.3697805612433863, 0.36396824910352354, 0.09142677813146272, 0.07456148672126506, 0.06805137419597596, 0.08428600783821816, 0.09358726988169852, 0.08300806616019363, 0.07821248972421979, 0.06581373688055392, 0.0834491590147729, 0.09280256023452804, 0.11353053489023046, 0.12197066495851028, 0.14230250676475809, 0.20125998359112596, 0.15415835868465422, 0.12652858752840968, 0.1116793582740696, 0.1341367885953657, 0.25602442080839527, 0.20482501589819968, 0.26510022917633824, 0.23801284139586898, 0.19045668764621893, 0.2285843983308461, 0.23090078165934536, 0.27881618817072973, 0.22761683685305123, 0.1806433397752949, 0.19384034180824128, 0.17887530049211886, 0.17375826551869245, 0.15693545144618615, 0.19271351565518902, 0.17935436755214396, 0.19698233964951128, 0.16739689601046825, 0.17232447387935568, 0.16605564414480378, 0.175878225464844, 0.1811518617372897, 0.15735468785706508, 0.1657561428625035, 0.18078255203931204, 0.17387488241209792, 0.17199710090738718, 0.2506101550456912, 0.16159107793570437, 0.18490298398206806, 0.16732691711271985, 0.18910588080537094, 0.16261978557608514, 0.16746254731472476, 0.17849540955130283, 0.17670533862343596, 0.5196860531595675, 0.14700365667901338, 0.13520698828639632, 0.38721344220259035, 0.3306301953686923, 0.20538213404224315, 0.15456666256829832, 0.18185021176388672, 0.485976251881743, 0.27383045941439776, 0.19165875382591024, 0.1498029050577777, 0.2174467613568032, 0.31247425870645884, 0.17220348765237958, 0.22749569035005957, 0.18630581681819391, 0.12650690507919116, 0.16679892062753954, 0.16301782728306702, 0.16041739882085126, 0.1680217279259255, 0.16947164255209501, 0.18735889669278238, 0.16262639598998507, 0.16338885965225203, 0.16855356069266714, 0.05993614433810779, 0.06681149099219952, 0.07708322097633447, 0.055307271059338525, 0.0682656052944538, 0.06404872097117897, 0.08025761714319546, 0.06110643944630989, 0.05302339708635295]}, "mutation_prompt": null}
{"id": "61d55228-7840-4042-8256-48cc14933d1e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim  # Reduced initial population size for efficiency\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7  # Slightly adjusted differential weight\n        self.mutation_factor_bounds = (0.6, 1.1)  # Adjusted mutation factor bounds\n        self.weight_decay = 0.98  # Modified exponential weight decay factor\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25  # Adjusted initial success rate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))  # More gradual decrease\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))  # Adjusted\n                if np.random.rand() < 0.2:\n                    F_dynamic = np.random.uniform(0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.2 * (success_rate - 0.4) + 0.05 * population_diversity)  # Adjusted\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15  # Slightly modified update\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "EnhancedHybridDifferentialEvolution with dynamic pop. resizing and improved mutation strategies for better convergence.", "configspace": "", "generation": 52, "fitness": 0.2085706608091756, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "61558421-5ba6-4d47-80b4-223fe4283352", "metadata": {"aucs": [0.49738492604210127, 0.4062794720991646, 0.45477593825970064, 0.4558610822861475, 0.4548466322354675, 0.43623796290111627, 0.4749397785062529, 0.48040571923929587, 0.47055996231516206, 0.18399508985565172, 0.19568959969808386, 0.18535385617213718, 0.1763320042379386, 0.18167896454248178, 0.14401497299913335, 0.19031892425463415, 0.15344895642743572, 0.22759058266989252, 0.11321249679672618, 0.09622762829614151, 0.09795552005449082, 0.09679381456008518, 0.12600011035299263, 0.14892005372121497, 0.1135946750754332, 0.1175903401113485, 0.12295895415143454, 0.1157314466701409, 0.12003635451210426, 0.10287156901371641, 0.0988234123182592, 0.11182222857222446, 0.07806645409081847, 0.09960459122067056, 0.10144802090482685, 0.1070960781678284, 0.6107692821238837, 0.789883245256551, 0.8513974913104593, 0.7829203369167836, 0.9320361890670223, 0.8768716141353242, 0.8145661334343683, 0.6471910017051159, 0.9004946156534359, 0.20302133827503155, 0.1897367747924834, 0.20059482073269175, 0.18704572034505051, 0.17563830428697225, 0.1824596557540754, 0.21461812228667554, 0.2086657025131231, 0.21740575910375814, 0.2102370192052021, 0.3634104890886465, 0.2011621922067225, 0.5060981913367839, 0.4267706765277096, 0.2779762942030435, 0.2972415369718523, 0.45529062079952665, 0.505189278857394, 0.16465268335650307, 0.11409961609911812, 0.11682063942402798, 0.1251969582250504, 0.10709909789576144, 0.09911790787866126, 0.10360793839561044, 0.11731509426510034, 0.10207631175231491, 0.10168021197939614, 0.01269428238239434, 0.09598706508541965, 0.10321905179993773, 0.12301816836500168, 0.11245919917395675, 0.12251375881538984, 0.10357770566112212, 0.07400139549050122, 0.027971274845540073, 0.06252475800268564, 0.051514217486463565, 0.08248957130608814, 0.05144571084094118, 0.05842515877601784, 0.05725538222471749, 0.01829592563406801, 0.02044691912184493, 0.15706557404196142, 0.07919814013818016, 0.1108477701453694, 0.14303351909042428, 0.07756323428005785, 0.1306397496975047, 0.2132832893555907, 0.15624931797715957, 0.1793100989045281, 0.0042838344393467676, 0.0063390518336456925, 0.006165417966844555, 0.0282694365648416, 0.0027678265452173445, 0.005162576812130282, 0.010865652315569019, 0.019479902649653158, 0.015941004977401474, 0.09540936725988391, 0.11770767419538009, 0.08969273757074137, 0.08570871182747875, 0.12798356373391961, 0.12217804112501707, 0.12165011072060894, 0.12917544253848956, 0.10983509353716037, 0.37436941013371483, 0.3769144188929415, 0.3650997502478397, 0.3609567815557526, 0.34913624329583404, 0.3807524219557773, 0.39620621390209587, 0.3841783495778456, 0.3838931187704374, 0.08118365524006654, 0.08889879927712752, 0.09804834001622442, 0.09323911351928049, 0.08688144796681718, 0.07709655463105669, 0.08387252237485276, 0.10384876757646089, 0.11128278467687469, 0.23671291995045185, 0.20160957642565835, 0.13472089563089762, 0.16637981709066008, 0.1415690117599574, 0.13017250626508048, 0.12474444190278478, 0.12774883037433515, 0.10276872812957605, 0.23575680777062646, 0.25619281993520737, 0.26426145995070194, 0.24566809207892015, 0.22541010146403906, 0.22891891582989576, 0.2811775249028796, 0.2984921063194833, 0.2890991637004382, 0.16300333356778396, 0.1909532385535303, 0.16765936724447417, 0.2020213843710461, 0.1729819099558385, 0.18231719255653644, 0.1959841493113872, 0.23687849654813853, 0.19889696460939887, 0.19998247354599608, 0.15782405050143045, 0.16123676235407924, 0.19654630242680982, 0.14468249107733155, 0.19338638910006734, 0.17753167953910776, 0.15999338796826545, 0.17011962061051578, 0.18834965373150026, 0.1851213776203432, 0.18037258837425363, 0.17536276708578136, 0.17513825224896296, 0.20127266357521256, 0.2262050441489034, 0.1781017970374782, 0.1846944280465309, 0.1568061324427401, 0.19271822190196264, 0.1560915784796345, 0.5575103024771981, 0.1835776983200904, 0.4493669149478996, 0.4952266322917752, 0.15713680107218753, 0.5643023929037545, 0.5091670011803308, 0.48491493622030846, 0.14835306655562275, 0.28474781657566894, 0.27866005140482764, 0.1354263520916651, 0.19271203206470566, 0.19641393540754692, 0.24891680079256384, 0.16147588764357967, 0.1766834150850558, 0.17212972537293825, 0.15875794969803814, 0.17595942898126993, 0.1920710027557242, 0.18154000240147894, 0.15987061652302437, 0.17177856887630527, 0.07258632647224716, 0.058861191066762464, 0.06521798645683718, 0.06400197614868708, 0.07625569248047537, 0.06653831225714169, 0.07469501497048459, 0.06627150413125749, 0.06816656277715794]}, "mutation_prompt": null}
{"id": "bfe535c0-cf94-400f-bb86-9d129d619972", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n    \n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                F_dynamic *= np.random.uniform(0.9, 1.1)  # Adaptive scaling\n                if np.random.rand() < 0.2:\n                    F_dynamic = np.random.uniform(0.5, 1.0 - 0.5 * (evaluations / self.budget))\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.2 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "EnhancedHybridDifferentialEvolution with adaptive scaling to improve exploration-exploitation balance.", "configspace": "", "generation": 53, "fitness": 0.20741938791718686, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "61d55228-7840-4042-8256-48cc14933d1e", "metadata": {"aucs": [0.4810442167896799, 0.489011368997891, 0.4498865103575096, 0.47442095729110556, 0.46838716484036336, 0.4949677834236037, 0.4956843729240408, 0.4851348491484335, 0.4780025315299826, 0.18771053037306684, 0.19049339147437772, 0.1680529382847682, 0.14885299591504753, 0.1902266166767549, 0.15749914792852016, 0.18430307323057815, 0.19937657334955194, 0.2155179260923381, 0.09726590849724048, 0.101865704667231, 0.09891321485510196, 0.11793598428879837, 0.10720839539391358, 0.1068362140777177, 0.11641236196244042, 0.11608663684598919, 0.10330234466884725, 0.10290044445683322, 0.0787460471620891, 0.08963571038147888, 0.08577110134096, 0.10617337712532116, 0.08978243468157576, 0.1284012128074582, 0.11971285202397608, 0.10646658216065374, 0.8597417537011462, 0.9357235922193642, 0.7704110170832573, 0.7239364390404153, 0.7613102988166465, 0.725817804384637, 0.9206019446597294, 0.7652569689208226, 0.9313925773051769, 0.2036783847582727, 0.20822470735379417, 0.19535814205355817, 0.2145065751427344, 0.16832135498767242, 0.1941981357305116, 0.21664837928853387, 0.250002854937879, 0.22703467271562117, 0.42646235795774046, 0.29330886862880035, 0.35953555871092957, 0.4115017829743788, 0.42744797368141063, 0.398791678983793, 0.3903123226167078, 0.3188111469376974, 0.32499924270373026, 0.12788591548494987, 0.10583717225732947, 0.12021139804567593, 0.12932745643933596, 0.14410130317086256, 0.10033190092375277, 0.12335320082371215, 0.11305846295397426, 0.13652314397125576, 0.04089653721740538, 0.08515864880601132, 0.1383743113817445, 0.14271311235736817, 0.14559549127539506, 0.13279231287778437, 0.08250332020979745, 0.13334408803864484, 0.12209098784126071, 0.0824465111147662, 0.06901920733343503, 0.08208604070025116, 0.08657514773422192, 0.07040174192550164, 0.05062634693672885, 0.058751387504991204, 0.03762074988042319, 0.04172282270356331, 0.16744891840487086, 0.1726654321830483, 0.1826213368730455, 0.13670878982162082, 0.07954483557408454, 0.20295841022906447, 0.17390699563375533, 0.18895870976375995, 0.2008481765143224, 0.0011628520350716043, 0.022427220559716465, 0.00613713176176911, 0.0009805981644616102, 0.005843324778882053, 0.005955167556565222, 0.010839359023358197, 9.999999999998899e-05, 0.009718361714041723, 0.10768927750799162, 0.09199084555325676, 0.09562074437278312, 0.08392564734706665, 0.11931784229843634, 0.120127078947046, 0.11066862457407822, 0.10538075612124465, 0.09791817719505902, 0.43478201532985206, 0.39534931629964143, 0.39427343635089607, 0.4054096287852008, 0.3758923212687446, 0.37617140552696204, 0.3901047322970105, 0.36542147602750297, 0.39425997306271177, 0.1072607173093747, 0.08226076648912317, 0.06801760419936764, 0.10899205861385364, 0.07134831697456123, 0.0597251451876899, 0.06804113614191754, 0.099442393433532, 0.09378013040034805, 0.12213985573843456, 0.1390539060438032, 0.14443397451315865, 0.12008889830274805, 0.1547276591510881, 0.12765006659553202, 0.163013780262653, 0.18952382231905196, 0.1232567335268614, 0.2529754264767573, 0.26132045962037687, 0.2549277424830789, 0.24031106253206047, 0.22818946580967048, 0.2276174273715853, 0.2576233053828102, 0.2885314569625017, 0.23914275198675883, 0.1775935521409543, 0.17756750462648108, 0.19601736011994375, 0.2100885106253867, 0.1659495929458662, 0.18998781686123012, 0.2197864985709762, 0.20381689265531966, 0.2250594989824264, 0.17249759185015479, 0.16376407485814148, 0.18547738416805593, 0.17018050439037524, 0.1942245716474782, 0.1601920808674624, 0.1671077157322134, 0.19765512804793484, 0.1831321843864363, 0.2215545885221344, 0.17207994348069044, 0.19664167139553623, 0.18821762703107348, 0.17516934097148573, 0.1816971848951232, 0.22271994838358788, 0.17868646299933244, 0.19133693321760925, 0.15578244561585164, 0.18161995037735723, 0.15328268010717605, 0.39392823290471013, 0.16868366630785914, 0.1595542037952793, 0.1379317217655731, 0.1570437914207965, 0.19562157776893196, 0.504472597325144, 0.19775488784858108, 0.21931954420477606, 0.1698442010365443, 0.15458508833565954, 0.23758143519363273, 0.1972825046279577, 0.2014947544729464, 0.40635372468609254, 0.1573762237199644, 0.17984249410746067, 0.1802998299984041, 0.18495329383051362, 0.18562907007643914, 0.1885621153845679, 0.18295058314519552, 0.18331747965678846, 0.16520889787982362, 0.06582535027886294, 0.06464925305443703, 0.07165832532024397, 0.07098465969926127, 0.07131508822999733, 0.07046078736431804, 0.061054567334969945, 0.08196064717256668, 0.07100023617430051]}, "mutation_prompt": null}
{"id": "bdd43173-764f-4d45-857b-ce96b273afde", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:  # Adjusted to introduce more mutation variability\n                    F_dynamic = np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.2 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Improved selection pressure and mutation variability for enhanced convergence speed.", "configspace": "", "generation": 54, "fitness": 0.21222903491866038, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "61d55228-7840-4042-8256-48cc14933d1e", "metadata": {"aucs": [0.5167762068815706, 0.5087661206127705, 0.45806843088186544, 0.4408326074599861, 0.4573195372330404, 0.47614485150916375, 0.4640710519893533, 0.48408502391340247, 0.43801307338173057, 0.21374309860728113, 0.16592295288887038, 0.17851042223146307, 0.18895999889889448, 0.17032652916870517, 0.2131477566498292, 0.18708182118947592, 0.22452509469306592, 0.2017055583456161, 0.12703717770572132, 0.1548469465781902, 0.10643626987666699, 0.1067352121608095, 0.10630545479883657, 0.11323736792776129, 0.10042695981166272, 0.1253431424975726, 0.11858668454161247, 0.09554714029627231, 0.10361065012766757, 0.1584723644888778, 0.1075598106669311, 0.09738039660896813, 0.09900343915058585, 0.07633519363962027, 0.11284450384196021, 0.08654090845159967, 0.7980357233902062, 0.7520456799062631, 0.8830287014974245, 0.6238718870153221, 0.8429190560230163, 0.7624961655681777, 0.8148050409241914, 0.7393122541070882, 0.9886379425350804, 0.23831594242518372, 0.24970408002915445, 0.2182846679312369, 0.22895713424644704, 0.20054245221507472, 0.24212129430092977, 0.21319177734746209, 0.20868889834241322, 0.19164944517073568, 0.27425989583419874, 0.40558418854022094, 0.3509468405435533, 0.5795304364206886, 0.29154627129190824, 0.4300150203712657, 0.4095422445048873, 0.2777185536901102, 0.2830069631564308, 0.12799547263834432, 0.1308189259971304, 0.07476397193435891, 0.150618933546798, 0.1469331224142112, 0.11263428002861797, 0.13373064398876267, 0.14662304005107596, 0.16194071420106648, 0.13448953036888722, 0.031323489109591485, 0.10730251613160413, 0.13444983042307468, 0.11037140219114061, 0.10693853563287503, 0.1141449549839374, 0.09626323508973367, 0.07929069106682163, 0.09805999122555109, 0.04271829000016569, 0.05351208852760447, 0.09308994988521968, 0.09753584161761464, 0.025415181154783917, 0.04302518338141126, 0.027682883466368602, 0.007118309394696154, 0.22977670120196214, 0.07240075059779538, 0.20017945373555313, 0.0962711368331629, 0.14001990936088982, 0.1281741621550444, 0.20146709042744693, 0.23250034758825655, 0.14210298583550685, 0.023616696624898736, 0.0017573294287461794, 0.020583591317620664, 0.04199755698375207, 0.010349056304159276, 0.004676070606941307, 0.05498180974552491, 0.014750488811211104, 0.010232501983924114, 0.11623244437944269, 0.10162480238559113, 0.10595939263716736, 0.10827098636325827, 0.10100860080505425, 0.1260355592052621, 0.10889153948223684, 0.10539389640089869, 0.1081323212470594, 0.4213128328979847, 0.41709291302461493, 0.41493778305741047, 0.3765043542102011, 0.3632954370671899, 0.3844257962473091, 0.38739670526082814, 0.3910941625384401, 0.392154374205972, 0.09911502024912588, 0.0798026033982735, 0.07666418807679454, 0.07749141276901406, 0.07915651908336951, 0.09767265861603303, 0.08218149625425408, 0.08646251648134107, 0.10274950284374407, 0.14184875557164855, 0.15669840308259664, 0.12829057847779057, 0.09855305120391278, 0.1405987342267545, 0.12796082081283, 0.1227575855420393, 0.13817781564879517, 0.11742309868406386, 0.24932969595378995, 0.26042208145032286, 0.2666321061866951, 0.2650316977547291, 0.2406232615729117, 0.25916784591978026, 0.2841043911586657, 0.2859935949327027, 0.2658633289568194, 0.19474001815057984, 0.16538749177441292, 0.22232516348813347, 0.22242032572902437, 0.1657411223263724, 0.19830052455596325, 0.18444184476947778, 0.2055408149342659, 0.19355437137032538, 0.19632206326817792, 0.17927451167507935, 0.17305146306964603, 0.18403882103879265, 0.17586654768148036, 0.18147407666088633, 0.1705925328411957, 0.18103736576027118, 0.18160144447213966, 0.2110010874239513, 0.1721567435852439, 0.19684178672958208, 0.25754528563080226, 0.16590417118490208, 0.22688839030275898, 0.19054081700930925, 0.17370008239226042, 0.18280592399152673, 0.16859414159577413, 0.21404487296536112, 0.4122505208278181, 0.5334841330603861, 0.18245955007660897, 0.16870526664926233, 0.14137400326998018, 0.1702283397548654, 0.4010015527205343, 0.30785622201318175, 0.4077489031549971, 0.38420135474759487, 0.49462428486627963, 0.13554569044286946, 0.28914683249221884, 0.1957452469419566, 0.1841439845782724, 0.1781879265342321, 0.1702014100253335, 0.16954756009996086, 0.17131618436512386, 0.1657863129419649, 0.17042445800509431, 0.16794609768903834, 0.15739621855192232, 0.1672783142259574, 0.19026079935573514, 0.10571614025891518, 0.0624262094035537, 0.06545186228234579, 0.07230503372694586, 0.06116175984798522, 0.06905391517241355, 0.06461926358030501, 0.05906315184511646, 0.07090560118953415]}, "mutation_prompt": null}
{"id": "39d0744e-4972-4cac-8078-bd968d8f438f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        stochastic_factor = 0.05  # Introducing stochastic perturbation\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F_dynamic * (b - c) + stochastic_factor * np.random.randn(self.dim), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.2 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced adaptive strategy integrating stochastic perturbation for improved exploration and convergence.", "configspace": "", "generation": 55, "fitness": 0.19313547186708868, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "bdd43173-764f-4d45-857b-ce96b273afde", "metadata": {"aucs": [0.4271482722515533, 0.3906246121379471, 0.40721302320463215, 0.415035852157401, 0.4340050167836653, 0.39741931434397515, 0.41023166822108803, 0.41940114002416606, 0.42566009604751076, 0.07362215453634147, 0.10510272407643095, 0.09280090573076083, 0.08029190519994556, 0.06132034134309783, 0.08824583154785037, 0.08731456227452905, 0.06273295326625705, 0.05222540968984013, 0.10108250998863422, 0.14690777742163186, 0.11708130797469862, 0.11283382387125007, 0.11287120357827896, 0.09560768870356551, 0.09868439779404892, 0.10220140338200001, 0.11566102852890747, 0.09529365452503957, 0.08461991230115329, 0.08993645208111523, 0.09181391341967338, 0.08484869925400196, 0.10832840710985969, 0.08563068716990418, 0.1068845755334713, 0.08485806427332332, 0.9310789711369417, 0.7475137392197562, 0.6816876126243909, 0.8425680333814758, 0.6075871898587057, 0.746274323917653, 0.9407436895514629, 0.6772838347906498, 0.8512125575992482, 0.20474980828179457, 0.19444473783994431, 0.23057020770283543, 0.19404392999953224, 0.18253415558203323, 0.22266096707917726, 0.23570563245978138, 0.18345644433201447, 0.21052264671358822, 0.2455112467647439, 0.26233819000736824, 0.33213766397162403, 0.25456368501678783, 0.2720554664504091, 0.375777132904334, 0.3885559187447677, 0.29117693964509883, 0.2837356081392106, 0.12596217571655977, 0.0979043416874229, 0.12399358396726567, 0.11242040046622825, 0.11489199615147627, 0.1202089762961539, 0.14457881541683326, 0.133712407506397, 0.11915214458826284, 0.09620242440662619, 0.0915684813684331, 0.12631145526932563, 0.1195595615109385, 0.10714696932184797, 0.12453862884587397, 0.10532060947837252, 0.10916922994429046, 0.10775853328530227, 0.003356315884737837, 0.015272614613366042, 0.03345533604104223, 0.0038056223858062843, 0.028340179434679147, 0.015644806981469084, 0.02199164283041477, 0.0020640061391618003, 0.025131375283438673, 0.08928060969991292, 0.0893560994546495, 0.11920769357576722, 0.07673946849851565, 0.09449861736691778, 0.033419986678080216, 0.0741039219228633, 0.16156122074006074, 0.09430255251802588, 0.00015150011879938585, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004685193845595181, 9.999999999998899e-05, 9.999999999998899e-05, 0.012702022780828881, 9.999999999998899e-05, 0.08502870814696506, 0.07225399659238496, 0.07948971762940527, 0.08773720857905498, 0.08680854418951933, 0.12159758060381587, 0.08496804468885943, 0.0735204009737257, 0.09834255335889697, 0.363212173097319, 0.36498394775860976, 0.369803582553639, 0.37162497494362534, 0.3548645124289257, 0.35793032037009775, 0.37455655049071324, 0.36986712648566555, 0.37533407060091906, 0.11319342772907748, 0.09286731792872416, 0.11126741236208726, 0.0755989806834172, 0.09078170912848871, 0.08674203309102702, 0.0771973447834744, 0.0984846675195713, 0.0733089783165225, 0.17631494203040343, 0.1543679543282287, 0.17267188017719437, 0.24707084273919433, 0.17519430991130025, 0.18448454666224035, 0.1331661096011867, 0.15723677266912217, 0.16835073947434231, 0.23547651851927653, 0.24417230594882688, 0.25388772118697245, 0.24758976280906253, 0.2433568366492982, 0.24543054219927285, 0.26441213527192764, 0.2539323345532475, 0.26605662705218525, 0.1799601436806133, 0.17379819548549824, 0.19372885029044729, 0.16126670786222164, 0.1666638607727342, 0.17200917148611317, 0.17221482768594232, 0.2171673099968512, 0.19700043906039022, 0.17821476250739854, 0.1699124663328474, 0.16761094070550875, 0.16247042451774818, 0.17044720378833134, 0.16471311256071164, 0.1669546640916173, 0.16951729350582134, 0.2041640614173671, 0.20529476177105122, 0.18052955371061763, 0.1660476268371105, 0.19955572997966475, 0.17468677624210882, 0.17418311442013024, 0.17112199892352942, 0.20057880250931492, 0.18065795651832361, 0.14141049044998677, 0.16557729716591418, 0.18248770135185033, 0.1723100950979617, 0.18683013619907085, 0.49038589944371946, 0.176304965285202, 0.15612478611094283, 0.1524030483605877, 0.48328037611903674, 0.4958067401224603, 0.31353725849745184, 0.42884863916624394, 0.1830879480395069, 0.277607412479173, 0.24719765164244523, 0.19645655543051777, 0.4930867495968658, 0.1684981676179823, 0.18930860140856443, 0.1866821119803127, 0.18234906592416078, 0.2074962386736514, 0.18107379133281054, 0.1899041090991147, 0.17845217349473474, 0.16427239150818662, 0.07627416847786317, 0.06308759505699402, 0.06551731317547216, 0.0669067322933462, 0.07691302506085229, 0.06393405235728622, 0.06437806750648012, 0.06200136579589721, 0.0763565330060606]}, "mutation_prompt": null}
{"id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:  # Introduced variability\n                    F_dynamic = np.random.uniform(0.45, 0.85)  # Adjusted bounds\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)  # Adjusted factor\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Adaptive diversity-driven mutation and crossover for improved exploration and exploitation balance.", "configspace": "", "generation": 56, "fitness": 0.21359880786736005, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "bdd43173-764f-4d45-857b-ce96b273afde", "metadata": {"aucs": [0.47997421116134986, 0.4715210896499693, 0.43574926714653306, 0.46762170060032826, 0.42112157117118343, 0.45184856474919366, 0.46611904311448416, 0.4531847303868348, 0.4584895809732391, 0.19203197863620602, 0.20645380112745548, 0.1671833916465243, 0.19576411254238157, 0.18389402590861859, 0.19553236507139982, 0.17884446353660255, 0.18360432583059805, 0.19182090630144766, 0.09291480191258783, 0.12186083948313886, 0.11737327193030456, 0.11913110358652435, 0.13047167319825603, 0.12073487363202018, 0.14371173890074673, 0.16687538796959123, 0.11393983117104145, 0.09475133217183807, 0.09882648062114585, 0.09673374952887448, 0.10223602471040927, 0.1005042893093332, 0.08553175264469848, 0.0879899281323927, 0.08780315374536951, 0.09661288229295528, 0.9058563914235943, 0.7639031089460537, 0.8837629854607948, 0.8547905807735721, 0.838474316250986, 0.8698445789702893, 0.8434548636553248, 0.6378435993707232, 0.988644359535393, 0.22295110608809943, 0.19595527083813502, 0.1620908661142817, 0.2176307395640783, 0.19820341762505034, 0.2088283906584567, 0.2272305844059097, 0.20593806866052156, 0.1876877635105748, 0.26038792915328524, 0.3856769838520365, 0.2646470790081188, 0.5935915343497649, 0.3436216746570552, 0.26949444906155207, 0.3249517042122112, 0.3668191961559649, 0.37019090297280044, 0.12524089826892792, 0.1546497010614183, 0.1277131318239142, 0.12872742904397871, 0.12399024508282641, 0.12657482496757655, 0.13377472441731975, 0.12287782345791709, 0.12046818171736229, 0.1447868122401751, 0.0652770038246917, 0.11598199834989209, 0.13695572867883532, 0.1302540186279142, 0.10573517970968938, 0.09895213260923741, 0.1396904068977085, 0.1155294061776092, 0.024677219427096886, 0.05560871820259794, 0.0378658725781601, 0.08229730809116864, 0.0001398557474986406, 0.05488306806002907, 0.05679468517121189, 0.02968585918652311, 0.034964798736848435, 0.16884109158032656, 0.19149854928039411, 0.13965084897907531, 0.14566932505525287, 0.12281443582299711, 0.16083010310103074, 0.17722174595466478, 0.17990455793592608, 0.20679482996085163, 0.0079387442819292, 9.999999999998899e-05, 9.999999999998899e-05, 0.030142033252013478, 0.005245872448848776, 0.02517320575677917, 0.0008109503071429547, 0.005075041592651597, 0.0032087248438052995, 0.0857660200559236, 0.10598544141668331, 0.09079085786662966, 0.10368607913470351, 0.117264331501032, 0.1131607057147328, 0.10548616260540389, 0.09658955114768308, 0.09129596883372615, 0.40551947630788776, 0.35417829529825273, 0.38613230935263887, 0.38058793087701426, 0.3603957150152467, 0.3815419774286096, 0.40907201224466894, 0.3643498752612513, 0.37932716167996394, 0.08848369428054126, 0.08716964066491617, 0.0812759722677101, 0.08177754164373441, 0.10894597235760106, 0.0783189220435292, 0.08028334369174095, 0.07135608069806254, 0.0777958752138147, 0.13515182359822175, 0.15709311141074267, 0.23920523332387655, 0.10224203069199989, 0.12858769126510394, 0.139614464992329, 0.11258527235169313, 0.1293863586066203, 0.132487182310412, 0.2656466501740382, 0.22219969989445165, 0.2573897593608392, 0.270766465174786, 0.23065370408128183, 0.2584899153863892, 0.2557959745596685, 0.28548715107565636, 0.2634285320892873, 0.18385909165987546, 0.167132870012073, 0.1671737039508393, 0.19768162283297408, 0.1909880207224598, 0.2000730273209731, 0.21626469465496334, 0.18998753113621603, 0.17669364472439575, 0.172185516516431, 0.19763827813009582, 0.20992309284206556, 0.18811821525984462, 0.17940883444277278, 0.22682338775128585, 0.18933663950820678, 0.1869167964450843, 0.18697946521957742, 0.17766653667309495, 0.20163793881807035, 0.17650603205238224, 0.19617017229345113, 0.1616249846168839, 0.25423740980553144, 0.18558859439941544, 0.17517179112708636, 0.18454040085773804, 0.1413556190263211, 0.38543686723597925, 0.358121896039165, 0.16178703626849167, 0.18630990266946057, 0.4042877632063837, 0.15715538192320677, 0.1886377775247412, 0.4798841392550829, 0.4139408254314624, 0.4339244645108745, 0.37175832059293723, 0.38811313812175363, 0.3800712089287277, 0.1811366113469246, 0.5292140413881274, 0.26692482688540153, 0.1845453730513339, 0.16211448265744455, 0.1702310516828318, 0.17246101518779977, 0.17489384909950823, 0.16050782999744928, 0.17945381661866555, 0.17790251197376894, 0.16863155021300869, 0.19471841801624645, 0.07855797747446192, 0.06808297756799875, 0.076915759793452, 0.06655555626354526, 0.06825923409716328, 0.06603735994616489, 0.06657140616611501, 0.058387800015082036, 0.06502669836577801]}, "mutation_prompt": null}
{"id": "34471420-0208-42bb-be65-6d683ec4c617", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                # Adjusted bounds\n                if np.random.rand() < 0.3:  \n                    F_dynamic = np.random.uniform(0.5, 0.8) \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Modified mutation strategy and diversity maintenance for enhanced convergence speed.", "configspace": "", "generation": 57, "fitness": 0.21159168694975966, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.4809877956245061, 0.48203776664295583, 0.4444867544426836, 0.4585911797709291, 0.4063436007482153, 0.4646699725056793, 0.4468126317155552, 0.5270086691555499, 0.4623082559003978, 0.2122403724373635, 0.20795488953136787, 0.16835061331117485, 0.18684820362486798, 0.18547367969159856, 0.18800158501412012, 0.197637395146801, 0.18805206286262988, 0.1888910023347372, 0.14553362847326878, 0.10816305338262777, 0.10724725848489602, 0.11160275239731576, 0.10478159579683566, 0.10997753568056645, 0.15143520227478424, 0.12892019824746725, 0.12220073755046978, 0.09120441830451431, 0.10195284448472752, 0.10332500905189901, 0.09598088901728574, 0.09419961863753346, 0.08573162934242606, 0.1070764855102716, 0.10462145067053075, 0.09402944350469389, 0.6251537769279056, 0.805799971709589, 0.8726360227924268, 0.7854458446316522, 0.8991829622995199, 0.893481658517525, 0.8244418458406059, 0.7247999773152536, 0.9886485540501891, 0.17750811598098903, 0.20176476204071203, 0.2193497750063128, 0.22447261525661677, 0.18269869397636007, 0.1853207499663947, 0.20297589079292666, 0.20783527861785955, 0.2039520938858841, 0.3851566301527668, 0.30662158249021043, 0.20374355671520705, 0.4152015524878204, 0.31508127813878717, 0.29653667925643423, 0.5010409839496139, 0.24433684257180455, 0.3183818983532488, 0.14619286278510613, 0.19584680940846688, 0.11662046889825994, 0.13097044504553013, 0.10297464970476289, 0.08958352051623641, 0.11439990580772041, 0.14188199873337304, 0.11235695113408206, 0.09612270428963221, 0.10064905095895027, 0.12460871177478838, 0.10580291761195348, 0.10318361686893973, 0.140745873108458, 0.103168253532268, 0.08008091143016882, 0.11878193003829696, 0.035669589884949504, 0.030423651070571434, 0.04459290640864233, 0.023270443452290457, 0.03790902841737498, 0.047681574334606514, 0.044584940047646016, 0.03507231759658713, 0.04223544157827286, 0.1736411951776623, 0.22260009315678475, 0.16475230018862708, 0.19530824646482436, 0.12065652994089837, 0.11924019087542892, 0.2041537005720011, 0.1901231510528968, 0.18434475112444892, 0.022040957274162665, 0.005275729240362459, 0.029778873392848793, 0.006897772342097541, 0.02858356599879719, 0.015392872390171619, 0.006733218916930683, 0.013156759532133244, 0.001973053377763656, 0.11155721785006112, 0.08507841015766882, 0.07848147703178421, 0.11225142051898351, 0.09918483636861997, 0.11617729053416403, 0.11511141523775914, 0.09951027243817079, 0.09948423725325795, 0.36765277434877797, 0.368588916658634, 0.39047562254316603, 0.40141251454037896, 0.368537518072942, 0.38444788311735634, 0.4138477565593759, 0.3772325844940867, 0.3916461430018173, 0.09293089665273468, 0.08472448840922375, 0.08278494145842064, 0.0913358606525444, 0.07501390990206835, 0.09277417970750157, 0.0739354850385705, 0.10478716705911395, 0.0959472223513036, 0.10984753163565797, 0.1219669979796223, 0.12656407952993687, 0.13722707442855242, 0.12576355409300066, 0.1234719032301076, 0.1285337406126007, 0.16392810599611096, 0.158789188047893, 0.2642443169742288, 0.2579388614641197, 0.24481857563479603, 0.2712173870120145, 0.24534057308988333, 0.27978540833333787, 0.2992591094013165, 0.2597490008406548, 0.27387296893789526, 0.2073439623184108, 0.20483445340864814, 0.17879508830125324, 0.1872353423506261, 0.19884948886995502, 0.1673070618998852, 0.22216655105812255, 0.2165380745394906, 0.19791869034894882, 0.17932170154043126, 0.1717236303951276, 0.16637614812624868, 0.17146861351415554, 0.18555181952404898, 0.1579586682960833, 0.18063973552359225, 0.18125163596324212, 0.16596955562303117, 0.18028997613079012, 0.19256735678482395, 0.21011799799815667, 0.17582992731284863, 0.18629975656867437, 0.18338582641225776, 0.20886526798771077, 0.1946432133444942, 0.2493824704327693, 0.4322808908904441, 0.445761549169747, 0.1822905772232697, 0.37616431289218366, 0.17854053147502547, 0.37211988251643446, 0.5161758232632839, 0.18764912143507573, 0.3881907655908208, 0.41916700860541634, 0.4791380354415774, 0.1512523027069077, 0.22518618157253778, 0.19652563450611815, 0.17961343178121547, 0.1962503362107777, 0.3387151245728254, 0.1992819878364418, 0.15756279084584768, 0.1857332014575811, 0.16650264229351963, 0.1723179740035261, 0.16311353358006586, 0.16376419124889885, 0.1670317960633334, 0.17009051220184612, 0.15944188951987615, 0.06862213789329707, 0.06536418573363068, 0.0684905576529854, 0.06984828331965276, 0.06759324375488562, 0.06423919500053654, 0.0700342348327847, 0.059627814805192636, 0.06394565502184546]}, "mutation_prompt": null}
{"id": "cf5740eb-6fdc-4705-a463-a069a3a05134", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "EnhancedHybridDifferentialEvolution with dynamic population resizing and local search boost for improved convergence.", "configspace": "", "generation": 58, "fitness": 0.21359880786736005, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.47997421116134986, 0.4715210896499693, 0.43574926714653306, 0.46762170060032826, 0.42112157117118343, 0.45184856474919366, 0.46611904311448416, 0.4531847303868348, 0.4584895809732391, 0.19203197863620602, 0.20645380112745548, 0.1671833916465243, 0.19576411254238157, 0.18389402590861859, 0.19553236507139982, 0.17884446353660255, 0.18360432583059805, 0.19182090630144766, 0.09291480191258783, 0.12186083948313886, 0.11737327193030456, 0.11913110358652435, 0.13047167319825603, 0.12073487363202018, 0.14371173890074673, 0.16687538796959123, 0.11393983117104145, 0.09475133217183807, 0.09882648062114585, 0.09673374952887448, 0.10223602471040927, 0.1005042893093332, 0.08553175264469848, 0.0879899281323927, 0.08780315374536951, 0.09661288229295528, 0.9058563914235943, 0.7639031089460537, 0.8837629854607948, 0.8547905807735721, 0.838474316250986, 0.8698445789702893, 0.8434548636553248, 0.6378435993707232, 0.988644359535393, 0.22295110608809943, 0.19595527083813502, 0.1620908661142817, 0.2176307395640783, 0.19820341762505034, 0.2088283906584567, 0.2272305844059097, 0.20593806866052156, 0.1876877635105748, 0.26038792915328524, 0.3856769838520365, 0.2646470790081188, 0.5935915343497649, 0.3436216746570552, 0.26949444906155207, 0.3249517042122112, 0.3668191961559649, 0.37019090297280044, 0.12524089826892792, 0.1546497010614183, 0.1277131318239142, 0.12872742904397871, 0.12399024508282641, 0.12657482496757655, 0.13377472441731975, 0.12287782345791709, 0.12046818171736229, 0.1447868122401751, 0.0652770038246917, 0.11598199834989209, 0.13695572867883532, 0.1302540186279142, 0.10573517970968938, 0.09895213260923741, 0.1396904068977085, 0.1155294061776092, 0.024677219427096886, 0.05560871820259794, 0.0378658725781601, 0.08229730809116864, 0.0001398557474986406, 0.05488306806002907, 0.05679468517121189, 0.02968585918652311, 0.034964798736848435, 0.16884109158032656, 0.19149854928039411, 0.13965084897907531, 0.14566932505525287, 0.12281443582299711, 0.16083010310103074, 0.17722174595466478, 0.17990455793592608, 0.20679482996085163, 0.0079387442819292, 9.999999999998899e-05, 9.999999999998899e-05, 0.030142033252013478, 0.005245872448848776, 0.02517320575677917, 0.0008109503071429547, 0.005075041592651597, 0.0032087248438052995, 0.0857660200559236, 0.10598544141668331, 0.09079085786662966, 0.10368607913470351, 0.117264331501032, 0.1131607057147328, 0.10548616260540389, 0.09658955114768308, 0.09129596883372615, 0.40551947630788776, 0.35417829529825273, 0.38613230935263887, 0.38058793087701426, 0.3603957150152467, 0.3815419774286096, 0.40907201224466894, 0.3643498752612513, 0.37932716167996394, 0.08848369428054126, 0.08716964066491617, 0.0812759722677101, 0.08177754164373441, 0.10894597235760106, 0.0783189220435292, 0.08028334369174095, 0.07135608069806254, 0.0777958752138147, 0.13515182359822175, 0.15709311141074267, 0.23920523332387655, 0.10224203069199989, 0.12858769126510394, 0.139614464992329, 0.11258527235169313, 0.1293863586066203, 0.132487182310412, 0.2656466501740382, 0.22219969989445165, 0.2573897593608392, 0.270766465174786, 0.23065370408128183, 0.2584899153863892, 0.2557959745596685, 0.28548715107565636, 0.2634285320892873, 0.18385909165987546, 0.167132870012073, 0.1671737039508393, 0.19768162283297408, 0.1909880207224598, 0.2000730273209731, 0.21626469465496334, 0.18998753113621603, 0.17669364472439575, 0.172185516516431, 0.19763827813009582, 0.20992309284206556, 0.18811821525984462, 0.17940883444277278, 0.22682338775128585, 0.18933663950820678, 0.1869167964450843, 0.18697946521957742, 0.17766653667309495, 0.20163793881807035, 0.17650603205238224, 0.19617017229345113, 0.1616249846168839, 0.25423740980553144, 0.18558859439941544, 0.17517179112708636, 0.18454040085773804, 0.1413556190263211, 0.38543686723597925, 0.358121896039165, 0.16178703626849167, 0.18630990266946057, 0.4042877632063837, 0.15715538192320677, 0.1886377775247412, 0.4798841392550829, 0.4139408254314624, 0.4339244645108745, 0.37175832059293723, 0.38811313812175363, 0.3800712089287277, 0.1811366113469246, 0.5292140413881274, 0.26692482688540153, 0.1845453730513339, 0.16211448265744455, 0.1702310516828318, 0.17246101518779977, 0.17489384909950823, 0.16050782999744928, 0.17945381661866555, 0.17790251197376894, 0.16863155021300869, 0.19471841801624645, 0.07855797747446192, 0.06808297756799875, 0.076915759793452, 0.06655555626354526, 0.06825923409716328, 0.06603735994616489, 0.06657140616611501, 0.058387800015082036, 0.06502669836577801]}, "mutation_prompt": null}
{"id": "deddd7cc-4c08-48e1-aca3-28f561c2d105", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                # Added adaptive random walk\n                proposal += np.random.uniform(-0.1, 0.1, size=self.dim) * (1 - evaluations / self.budget)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced a dynamic scaling of CR based on diversity and adaptive random walk for improved exploration.", "configspace": "", "generation": 59, "fitness": 0.20834147888124985, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.4821817540320842, 0.4057583720623299, 0.4195803812281278, 0.46208526102132674, 0.441061010639323, 0.47872566528060556, 0.4610331568064444, 0.4553081549078867, 0.4469140446821248, 0.17002184505366547, 0.20427558061347983, 0.14933159792882011, 0.18208301381148295, 0.18425055466790252, 0.19712640382816826, 0.1609388944253486, 0.17216679285949577, 0.2139788837165968, 0.12006534653391754, 0.12158139527613276, 0.1044208318276626, 0.11561041902347025, 0.09416674084482624, 0.11492420513037127, 0.11479555431486754, 0.09845253153555567, 0.17918484867378193, 0.09415154778777379, 0.10818970210466561, 0.09882036024264507, 0.10195384628734461, 0.09877321316211707, 0.11123342986566898, 0.1466928430228499, 0.0974011403399565, 0.08391516561193602, 0.7783136277445555, 0.8599588243443503, 0.5241931399774271, 0.817782741071177, 0.8218059442641688, 0.7300107354852616, 0.82533613157154, 0.5829807934472895, 0.988644359535393, 0.21734859372546167, 0.192802338359353, 0.22124752521574176, 0.23474170899478608, 0.2025446454045121, 0.20361118999084327, 0.08325429373642124, 0.22048227924840946, 0.21409845495347568, 0.2901401966257937, 0.3135926464897043, 0.3775149594857452, 0.28285448268043734, 0.33713756877684875, 0.35803375805873516, 0.29618222105248637, 0.3868206742944318, 0.45754281604592584, 0.14304057458398134, 0.12154917511961372, 0.1088827872624255, 0.11244697697601735, 0.1123938187054464, 0.1700780082472365, 0.10719030829044474, 0.09501548807397231, 0.12478079198682213, 0.11174098952920863, 0.05114087563986702, 0.10581828056670906, 0.13693361332697152, 0.11585220026903875, 0.14355183339375255, 0.11669251106909573, 0.1279747508136676, 0.1039770720396842, 0.03471556780325269, 0.034941251462199396, 0.02589891230583674, 0.08747344966937998, 0.03190664594459236, 0.054016120364284714, 0.0265290267466467, 0.024108583179919152, 0.026606736450294877, 0.1473898979479774, 0.05917083530063405, 0.12360650369537418, 0.10883201938972564, 0.07190686349667141, 0.08998151724148196, 0.1872960187538374, 0.14036025472031977, 0.2001252433851327, 0.007123463345800163, 0.0035931334245097313, 0.011288461394136307, 0.002714509786485353, 0.002926238133478143, 0.03207017487720221, 0.004428765393692302, 0.023069238699097494, 0.014955018780178797, 0.1019313601002696, 0.09939816277040081, 0.0850270409202254, 0.11275491023104389, 0.10999572422793968, 0.11061477094483907, 0.0988968069512488, 0.10631821543410969, 0.11675648371551484, 0.41772348282945804, 0.3956109957257501, 0.4168927584377904, 0.3654534637889916, 0.3957178229675754, 0.34462510044649575, 0.4000979728857066, 0.37771197658306843, 0.3794638984730164, 0.06973391397867201, 0.08238074887208546, 0.08746139060623914, 0.10615139578106392, 0.07144057210382926, 0.08634866702145083, 0.08799074960176423, 0.07851406945268968, 0.07388260934273205, 0.1343821157679651, 0.17867462945790813, 0.13926577441124754, 0.19949713096572608, 0.12193255919136681, 0.15176841756797144, 0.2831024952352962, 0.12563418115561908, 0.24585759296147092, 0.23522075352342176, 0.25715299579342354, 0.25776055681996746, 0.2433356658384137, 0.23849497315056067, 0.24029407274272707, 0.281844964105592, 0.27433087701227243, 0.29133710231351506, 0.1695815668275139, 0.1617450757301705, 0.1902659599984622, 0.19444038289980559, 0.1904734765485694, 0.17145135849959647, 0.18799446488860627, 0.2243623006499006, 0.2214206102035048, 0.19876721635019434, 0.17095267826306648, 0.19751070837106643, 0.16792590728330525, 0.1771736013393045, 0.16784430085156887, 0.21232949266087053, 0.16850802430022904, 0.22354604247854148, 0.2038870066338112, 0.17604645985977863, 0.21287082370385046, 0.17360970878430704, 0.17796576530081365, 0.19516647652133967, 0.18051833508247472, 0.1813451818569367, 0.22687649928746756, 0.4349043904227228, 0.45185256880230495, 0.19178609428017357, 0.45636704043312704, 0.18481496144717435, 0.1667514512687347, 0.3536575886658715, 0.17776384031885994, 0.5527265857500963, 0.3688081600983426, 0.19026330176279072, 0.3584366229964039, 0.36957961496268177, 0.2488737144633979, 0.1796029280381234, 0.30300102090440806, 0.18570886894492789, 0.19233741910527147, 0.16861377566834435, 0.15733658244843207, 0.1831510407110204, 0.18035751595567184, 0.1776965930879817, 0.1849820577851825, 0.23017574624264758, 0.19168907717492834, 0.15814667231111978, 0.07216968778395716, 0.06525591650213358, 0.05616945542436458, 0.06949690805778552, 0.06924801738878539, 0.07975410193933952, 0.06136010711302953, 0.06425580568596234, 0.06507720970324049]}, "mutation_prompt": null}
{"id": "6c404724-9b06-4022-9ac8-8c3db507f4eb", "solution": "import numpy as np\n\nclass EnhancedHybridParticleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.C1 = 1.5  # Cognitive component\n        self.C2 = 1.5  # Social component\n        self.CR = 0.9\n        self.F = 0.7\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def __call__(self, func):\n        evaluations = 0\n        personal_bests = np.copy(self.population)\n        personal_best_fitness = np.full(self.population_size, float('inf'))\n        \n        while evaluations < self.budget:\n            current_fitness = np.array([func(ind) for ind in self.population])\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if current_fitness[i] < personal_best_fitness[i]:\n                    personal_best_fitness[i] = current_fitness[i]\n                    personal_bests[i] = self.population[i]\n\n                if current_fitness[i] < self.global_best_fitness:\n                    self.global_best_fitness = current_fitness[i]\n                    self.global_best = self.population[i]\n\n            r1, r2 = np.random.rand(2)\n            self.velocities = (self.velocities +\n                               self.C1 * r1 * (personal_bests - self.population) +\n                               self.C2 * r2 * (self.global_best - self.population))\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if evaluations >= self.budget:\n                break\n\n            new_population = np.zeros_like(self.population)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.global_best_fitness:\n                    self.global_best_fitness = trial_fitness\n                    self.global_best = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                self.population = new_population\n\n        return self.global_best, self.global_best_fitness", "name": "EnhancedHybridParticleDifferentialEvolution", "description": "Hybrid Particle Swarm and Differential Evolution for enhanced exploration and exploitation utilizing dynamic adaptation.", "configspace": "", "generation": 60, "fitness": 0.1346675504696904, "feedback": "The algorithm EnhancedHybridParticleDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.3374833013974653, 0.1767324741929971, 0.2288583845147768, 0.31027022695784556, 0.21158750872036425, 0.26418638352652557, 0.2698362970397957, 0.14051845550925846, 0.17586278577954384, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06124250195061909, 0.043732960423773726, 0.04696787071883479, 0.06000452531888345, 0.03953959012421038, 0.0482706164453266, 0.0573618630262277, 0.06916346881713564, 0.07783054727832783, 0.05375383280434198, 0.023105689033178334, 0.03993550083853148, 0.02930118457202857, 0.03638386271796956, 0.03463343478850822, 0.02764956835940502, 0.03927670966802055, 0.0322341627240621, 0.9854378005203497, 0.985169467357443, 0.981805558407224, 0.959542300278779, 0.9714065987683868, 0.9645626048650581, 0.9836586170947632, 0.9837144278591482, 0.9727093593938736, 0.1453269028321993, 0.05083371786080548, 0.05370657913343335, 0.08081811167891317, 0.10266123770163271, 0.09882792001835428, 0.07673989230062783, 0.08534428663780669, 0.07610042236415082, 0.16341010935708078, 0.1334450217977926, 0.15835311244756844, 0.2202053996892257, 0.10545492775126608, 0.16905572668349522, 0.06282790032499108, 0.14381120054077945, 0.12117508125098808, 0.08514023650904834, 0.033254948128647266, 0.005706687775338337, 9.999999999998899e-05, 0.0493153172324613, 0.024928356442730504, 0.00013513026527944838, 0.01703803788477254, 0.04753423079595831, 0.12450940723068193, 0.04794731804394903, 0.047653185387964925, 0.016873551362886596, 9.999999999998899e-05, 0.06415501595951822, 0.06107414535175271, 9.999999999998899e-05, 0.04650188179382131, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04044260649548903, 0.005332011547606763, 0.020992684117336124, 0.02364246790700164, 9.999999999998899e-05, 0.017131570696879872, 0.028876046117765508, 0.0301704091842937, 0.03317412551494414, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002099206194147163, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01345585692493989, 0.028907570003855132, 9.999999999998899e-05, 0.009755402815327163, 0.15116188232731786, 0.23923889876266102, 0.22193466420619568, 0.20191493345967415, 0.17416276977093315, 0.20522136060599783, 0.22834030057750399, 0.12077612770373902, 0.21199554013476718, 0.060061363289115044, 0.053562480307023375, 0.05973419149477399, 0.035181996533822146, 0.030761230582212584, 0.06101881767478623, 0.04277926366992357, 0.036505643787095865, 0.05246255599371785, 0.1090526394768514, 0.1170207993878053, 0.11872451972081066, 0.14004961903274693, 0.11885350279773466, 0.14048696386569914, 0.13847375425051245, 0.13240511541111932, 0.18068095909592663, 0.16402559703392272, 0.1553596833948575, 0.18487490175251198, 0.16392317371983667, 0.14481274945160005, 0.1858501281572097, 0.20894809980028695, 0.202416878243749, 0.20975795607203485, 0.12897833827441751, 0.1050452870948666, 0.157574829738788, 0.12477464746495803, 0.1303744464062927, 0.12785086530605694, 0.11752466272979911, 0.14462626931201794, 0.13732768511298088, 0.16435276376598373, 0.12982427682929376, 0.16532969219495264, 0.15325481166919908, 0.12668560241069549, 0.14635045592944373, 0.15807422556103723, 0.16779444244221153, 0.18200587542438784, 0.14493373401995524, 0.1348213203670111, 0.1656028051253836, 0.1585584532624671, 0.15278807891875534, 0.15185597302358178, 0.15227338479023678, 0.15269754495089094, 0.16062076538633885, 0.42497209426919236, 0.15988751044359784, 0.15174394542437908, 0.21094928210102093, 0.17084333421256437, 0.1687329603061688, 0.1182833938289759, 0.16760793774027172, 0.18054646373054206, 0.2509475177311127, 0.16415173756728296, 0.14116468685998518, 0.1828550798165557, 0.2098668629082986, 0.13942255516775326, 0.1838326953746523, 0.18631533391674981, 0.1799660523979172, 0.1741929477628562, 0.17998606957158514, 0.1768695291787521, 0.18104652320694625, 0.18336846161565912, 0.1825279923458385, 0.17320834236709703, 0.166885524236144, 0.1826412651454249, 0.048264092186639185, 0.03970648847889735, 0.06396496905110094, 0.050683706094706404, 0.04017386895941144, 0.05987289762462111, 0.0517813533008018, 0.047541507134634564, 0.04966750606275383]}, "mutation_prompt": null}
{"id": "dfb419cd-a4cd-45f5-8926-df13b9dbe17f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:  # Introduced variability\n                    F_dynamic = np.random.uniform(0.45, 0.85)  # Adjusted bounds\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4 + 0.2 * population_diversity))  # Adjusted factor for exploration\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced adaptive scaling for crossover probability to enhance diversity and exploration.", "configspace": "", "generation": 61, "fitness": 0.21359880786736005, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.47997421116134986, 0.4715210896499693, 0.43574926714653306, 0.46762170060032826, 0.42112157117118343, 0.45184856474919366, 0.46611904311448416, 0.4531847303868348, 0.4584895809732391, 0.19203197863620602, 0.20645380112745548, 0.1671833916465243, 0.19576411254238157, 0.18389402590861859, 0.19553236507139982, 0.17884446353660255, 0.18360432583059805, 0.19182090630144766, 0.09291480191258783, 0.12186083948313886, 0.11737327193030456, 0.11913110358652435, 0.13047167319825603, 0.12073487363202018, 0.14371173890074673, 0.16687538796959123, 0.11393983117104145, 0.09475133217183807, 0.09882648062114585, 0.09673374952887448, 0.10223602471040927, 0.1005042893093332, 0.08553175264469848, 0.0879899281323927, 0.08780315374536951, 0.09661288229295528, 0.9058563914235943, 0.7639031089460537, 0.8837629854607948, 0.8547905807735721, 0.838474316250986, 0.8698445789702893, 0.8434548636553248, 0.6378435993707232, 0.988644359535393, 0.22295110608809943, 0.19595527083813502, 0.1620908661142817, 0.2176307395640783, 0.19820341762505034, 0.2088283906584567, 0.2272305844059097, 0.20593806866052156, 0.1876877635105748, 0.26038792915328524, 0.3856769838520365, 0.2646470790081188, 0.5935915343497649, 0.3436216746570552, 0.26949444906155207, 0.3249517042122112, 0.3668191961559649, 0.37019090297280044, 0.12524089826892792, 0.1546497010614183, 0.1277131318239142, 0.12872742904397871, 0.12399024508282641, 0.12657482496757655, 0.13377472441731975, 0.12287782345791709, 0.12046818171736229, 0.1447868122401751, 0.0652770038246917, 0.11598199834989209, 0.13695572867883532, 0.1302540186279142, 0.10573517970968938, 0.09895213260923741, 0.1396904068977085, 0.1155294061776092, 0.024677219427096886, 0.05560871820259794, 0.0378658725781601, 0.08229730809116864, 0.0001398557474986406, 0.05488306806002907, 0.05679468517121189, 0.02968585918652311, 0.034964798736848435, 0.16884109158032656, 0.19149854928039411, 0.13965084897907531, 0.14566932505525287, 0.12281443582299711, 0.16083010310103074, 0.17722174595466478, 0.17990455793592608, 0.20679482996085163, 0.0079387442819292, 9.999999999998899e-05, 9.999999999998899e-05, 0.030142033252013478, 0.005245872448848776, 0.02517320575677917, 0.0008109503071429547, 0.005075041592651597, 0.0032087248438052995, 0.0857660200559236, 0.10598544141668331, 0.09079085786662966, 0.10368607913470351, 0.117264331501032, 0.1131607057147328, 0.10548616260540389, 0.09658955114768308, 0.09129596883372615, 0.40551947630788776, 0.35417829529825273, 0.38613230935263887, 0.38058793087701426, 0.3603957150152467, 0.3815419774286096, 0.40907201224466894, 0.3643498752612513, 0.37932716167996394, 0.08848369428054126, 0.08716964066491617, 0.0812759722677101, 0.08177754164373441, 0.10894597235760106, 0.0783189220435292, 0.08028334369174095, 0.07135608069806254, 0.0777958752138147, 0.13515182359822175, 0.15709311141074267, 0.23920523332387655, 0.10224203069199989, 0.12858769126510394, 0.139614464992329, 0.11258527235169313, 0.1293863586066203, 0.132487182310412, 0.2656466501740382, 0.22219969989445165, 0.2573897593608392, 0.270766465174786, 0.23065370408128183, 0.2584899153863892, 0.2557959745596685, 0.28548715107565636, 0.2634285320892873, 0.18385909165987546, 0.167132870012073, 0.1671737039508393, 0.19768162283297408, 0.1909880207224598, 0.2000730273209731, 0.21626469465496334, 0.18998753113621603, 0.17669364472439575, 0.172185516516431, 0.19763827813009582, 0.20992309284206556, 0.18811821525984462, 0.17940883444277278, 0.22682338775128585, 0.18933663950820678, 0.1869167964450843, 0.18697946521957742, 0.17766653667309495, 0.20163793881807035, 0.17650603205238224, 0.19617017229345113, 0.1616249846168839, 0.25423740980553144, 0.18558859439941544, 0.17517179112708636, 0.18454040085773804, 0.1413556190263211, 0.38543686723597925, 0.358121896039165, 0.16178703626849167, 0.18630990266946057, 0.4042877632063837, 0.15715538192320677, 0.1886377775247412, 0.4798841392550829, 0.4139408254314624, 0.4339244645108745, 0.37175832059293723, 0.38811313812175363, 0.3800712089287277, 0.1811366113469246, 0.5292140413881274, 0.26692482688540153, 0.1845453730513339, 0.16211448265744455, 0.1702310516828318, 0.17246101518779977, 0.17489384909950823, 0.16050782999744928, 0.17945381661866555, 0.17790251197376894, 0.16863155021300869, 0.19471841801624645, 0.07855797747446192, 0.06808297756799875, 0.076915759793452, 0.06655555626354526, 0.06825923409716328, 0.06603735994616489, 0.06657140616611501, 0.058387800015082036, 0.06502669836577801]}, "mutation_prompt": null}
{"id": "ed61f15f-82af-472f-abb1-cafddc61ef18", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.7, 1.2)  # Slight increase for exploration\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(*self.mutation_factor_bounds)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.03 * population_diversity)  # Slight reduction for more stability\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Improve convergence by adjusting mutation factor bounds and refining crossover rate dynamics.", "configspace": "", "generation": 62, "fitness": 0.19624515544029328, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.45152414978230626, 0.3782202961636216, 0.41499659683095413, 0.446052767998222, 0.43191800808569647, 0.4392166661807202, 0.44612154961829076, 0.42836709008800955, 0.406437089288354, 0.16870346557418647, 0.14146640483207362, 0.13368145595849712, 0.12513635073881613, 0.1685218967266563, 0.1711006499151888, 0.13808636873331637, 0.14515697359873925, 0.17122084609923438, 0.15182359376071397, 0.11189889853658974, 0.09048109604638033, 0.09070406687160126, 0.09336813775662611, 0.12754157193578486, 0.11128993921475394, 0.13087400328044152, 0.10374266754351558, 0.0956619406048369, 0.10127768526931191, 0.09976212376126548, 0.1306941352308535, 0.10412031972966884, 0.0907430236473783, 0.09031865209122902, 0.09517872276530437, 0.11270329190216832, 0.9779632043893686, 0.7912470729425958, 0.8832453917314268, 0.875594033283576, 0.9181352937155786, 0.8237387078053691, 0.8886795243023008, 0.7586458111792148, 0.8804456019009468, 0.17082822085926197, 0.18393261599187805, 0.17009494842393158, 0.1998243066484905, 0.16325370168716513, 0.18236634505930427, 0.18352810994458402, 0.17354340196236862, 0.17331504554315014, 0.43868620763343147, 0.185248737627707, 0.20598433403531857, 0.3655955358004893, 0.2498332135987158, 0.23603316790361228, 0.2671232371465595, 0.4631074550397435, 0.29896992450888316, 0.1229508813572231, 0.09978145766736302, 0.1161619705882696, 0.12239126138146295, 0.1174020540770403, 0.11664104513498474, 0.12187869406274476, 0.0980572656759714, 0.10977459783991983, 0.09656764871909496, 0.09237962260778898, 0.08442304734100603, 0.1405726734053787, 0.12241680669376387, 0.1298719259204878, 0.1087765502685254, 0.10095194610204761, 0.10927183494438963, 0.012533531561599198, 0.0170201176374154, 0.03323680925941752, 0.02730072703744968, 0.061416624213336046, 0.0050557677057333494, 0.0005404814427716342, 0.04211074232405265, 0.021103629445543115, 0.15826874143495429, 0.11436408396391251, 0.14536119108282997, 0.14763897996495357, 0.07820276144897675, 0.10349646357469677, 0.15099228724887492, 0.12381085352939958, 0.19741032996608998, 0.0009643721342639244, 0.0005701777171019939, 0.004958528225677217, 0.015631459057479646, 0.016105429527760284, 9.999999999998899e-05, 0.014633061681121773, 0.01918766578671971, 0.0035103003838715674, 0.09185954789938955, 0.11110243378189921, 0.0935737783566547, 0.07730581478959597, 0.070926797633595, 0.09818111230077997, 0.07674460327862109, 0.08111464269690061, 0.06493404972259631, 0.35611962797146957, 0.3765607225868105, 0.3777648881715382, 0.357636929915794, 0.3455332792471941, 0.3522636583520714, 0.35337107188478156, 0.3571445288001355, 0.37258963558442304, 0.08181393047884145, 0.10419128601265581, 0.07875114696475993, 0.07128038179781471, 0.09072777860569037, 0.08506131306793263, 0.08497283746195239, 0.07451008666197356, 0.06423590922536837, 0.10221983171046345, 0.1592614610805937, 0.15111667671829687, 0.1553740692854383, 0.11893927668103876, 0.1732871925497962, 0.14661302372419083, 0.1698940543313231, 0.16433714145991218, 0.25799620718793026, 0.23233888803810598, 0.2368202227910582, 0.25324675817479014, 0.23302385196448572, 0.2398772295839805, 0.2860633323686338, 0.2727197560223038, 0.2774491446268814, 0.18909017393866556, 0.16784562115967816, 0.17569824728358585, 0.1718662266036396, 0.14968272915764969, 0.1556218832434494, 0.1934964412070308, 0.19848189357857104, 0.20229949380605772, 0.18102178055990326, 0.16342055436302072, 0.14456958357279126, 0.1666194826391968, 0.2064523706969017, 0.17607723029500666, 0.2218644773245444, 0.1564450955364275, 0.19868622157858473, 0.20050655238945247, 0.17312433218690915, 0.16479529374031776, 0.20276022663980608, 0.16690493346784807, 0.1883225691568554, 0.16810636287580727, 0.21461683523241692, 0.1847754251867667, 0.21817130199518608, 0.1529963508558101, 0.1672235561405121, 0.4433941632711016, 0.17583489333551294, 0.16751223852777386, 0.43639458218242866, 0.16688077307518945, 0.17193187999581405, 0.49255104776530767, 0.18864200370471407, 0.32014937508327324, 0.16745835852440905, 0.1509506391349148, 0.15850207416717077, 0.17473669122040425, 0.19878017156224348, 0.19216839410978825, 0.1651358160184243, 0.1745095777920893, 0.19100586324751778, 0.19338197201669505, 0.17811316473429828, 0.18397821293764582, 0.1663583750886275, 0.18953602594719432, 0.19810824761423484, 0.049135715414936, 0.06263039983735852, 0.060450917188387354, 0.06256106366778402, 0.06609049746957896, 0.059234592059112745, 0.0686460780388779, 0.07273755890590727, 0.06618700553203394]}, "mutation_prompt": null}
{"id": "c7b9c748-0078-402e-a9a1-3dcee7c0708e", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.88  # Adjusted crossover rate\n        self.F = 0.72  # Adjusted mutation factor\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.27 * (success_rate - 0.4) + 0.05 * population_diversity)  # Adjusted factor\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Slightly adjusted mutation factor and dynamic crossover rates for enhanced adaptability and convergence speed.", "configspace": "", "generation": 63, "fitness": 0.2047213761900286, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.17.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.4859373744414478, 0.44035774566982044, 0.473135623507822, 0.46191309305219597, 0.5024873511758207, 0.446212521089151, 0.4603603655325532, 0.4314407175290852, 0.46408951545610644, 0.19241940006928704, 0.20265898570370022, 0.13773021942378183, 0.17493352746876722, 0.1495647770814501, 0.19079354271734017, 0.16715159591869289, 0.17525424973162862, 0.19269659030513397, 0.16392980210872188, 0.10587693308848733, 0.11396668727094761, 0.11220314775260376, 0.11003814956591451, 0.12191503046148178, 0.1336374105606083, 0.11589034140652443, 0.12589399474485818, 0.11915305935438014, 0.1033738444144161, 0.09714251068939772, 0.10324394495241873, 0.08762081776142183, 0.08217963616913115, 0.09555544285892392, 0.10275792680746876, 0.10196667720111141, 0.8228202499813451, 0.7402876795156725, 0.8744474708111067, 0.6682433354240922, 0.800600613851817, 0.8398773951991615, 0.9246740596772396, 0.7963919403997791, 0.9886469633918227, 0.25614907856592184, 0.20200463131397906, 0.1763499027656712, 0.1747157844792122, 0.19338255612278255, 0.161620872205418, 0.2095114938333298, 0.1757783323537997, 0.18695649826061533, 0.39810051920294665, 0.24557740174165887, 0.26339195814761773, 0.6205979333748479, 0.3824289142977203, 0.19765098893380872, 0.45227843004002866, 0.428529875181312, 0.26071159665119115, 0.12131847283566188, 0.0771050975802482, 0.12273814249639747, 0.13652217524624521, 0.13099072171747028, 0.10982701006708373, 0.14246434197629965, 0.10472977418586593, 0.11155867320232304, 0.15350452383931046, 0.11587075346917863, 0.11161061617452783, 0.112797338334364, 0.11423793856652154, 0.11341424181037385, 0.09536958849723032, 0.14249110561749112, 0.12626389032543028, 0.021628008156801437, 0.032579152023477054, 0.03631911032283697, 0.04746945437802075, 0.04247275904945158, 0.03785078177293144, 0.03387704404534364, 0.018633310109701262, 0.023815122194028815, 0.10517535882349005, 0.14312006161495572, 0.11105639951097945, 0.1540043090067802, 0.08104104254500144, 0.12706964599732196, 0.18199176226354097, 0.1385781550567382, 0.1254349581501607, 0.009295958937532656, 0.0027707101958818203, 9.999999999998899e-05, 0.02963852451556581, 0.001688310487138911, 0.00084653800193768, 0.005931778478280969, 0.013210407951328662, 0.0010541025177799312, 0.09066199007731301, 0.09084698218073461, 0.0830842214372145, 0.07548850699056586, 0.09363752357226929, 0.11807904102861866, 0.10944354762311281, 0.1186611672848954, 0.10005011477102177, 0.4244146630654254, 0.388591051094365, 0.3894622019569237, 0.40984275534116754, 0.34206715058743653, 0.38548495217978673, 0.43965538302450746, 0.36043431516442037, 0.3743146610835816, 0.07739825970380121, 0.09393237338315341, 0.08500437167565145, 0.10102205854912061, 0.10331746028933175, 0.10289611965040713, 0.1070276013135073, 0.08496533813758067, 0.10096433489398737, 0.16065947288932003, 0.14790887866326052, 0.17754147029030842, 0.14359542884547338, 0.13754331990265456, 0.12192200724232283, 0.1463830300402431, 0.13334528379354615, 0.16077685544713516, 0.24928995757657912, 0.24738942179013135, 0.2546716255088969, 0.2961503931107965, 0.22088220891076737, 0.2502869484553899, 0.2583780535529907, 0.28458065002711463, 0.2675992738569184, 0.21743473171975913, 0.22276331658353743, 0.157511755234362, 0.1770684640893191, 0.18053344641263502, 0.169068224146685, 0.2154756321669168, 0.18809318040858825, 0.21692429347995212, 0.18079959970864568, 0.17902970058618684, 0.19451968046759116, 0.1810153231901751, 0.15422914471814042, 0.17408785782738212, 0.1607736768119432, 0.17271925906503893, 0.15958082619791203, 0.17446168250967453, 0.17678622784861087, 0.18227801301599156, 0.19536231619983213, 0.1963935739302478, 0.2018575661934653, 0.16198662953217702, 0.18898273811085375, 0.1911503625673442, 0.16495998698141534, 0.19201889172727016, 0.18313812816490171, 0.349454589428022, 0.17829572471865507, 0.44858695094819734, 0.149004362310855, 0.18063536299326333, 0.5217608349942511, 0.44473777748557164, 0.18832141862367047, 0.17496980017820718, 0.19474760156989213, 0.17014117690071362, 0.17808596163209256, 0.18138080147592073, 0.2179220687346396, 0.19681455053925678, 0.15731638440853735, 0.17308916015610065, 0.16934744768734433, 0.17246769991208677, 0.17728468551748588, 0.15698360450770632, 0.18056319752542804, 0.18653600080266375, 0.16451111374572847, 0.06749364797427937, 0.06820178058646764, 0.08060198929503093, 0.06473724387722157, 0.0681761409676257, 0.06734562336049454, 0.07912196573217756, 0.065755750026675, 0.06809198205407407]}, "mutation_prompt": null}
{"id": "367e3223-fc43-423d-9cd9-6c6d72811d7d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n            \n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:  # Introduced variability\n                    F_dynamic = np.random.uniform(0.5, 0.85)  # Slight adjustment\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)  # Adjusted factor\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced mutation factor adaptation for improved convergence speed in differential evolution.", "configspace": "", "generation": 64, "fitness": 0.2090415335564528, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.47517703108459686, 0.419929598558638, 0.4394120328378146, 0.45233671120363983, 0.4438485769523428, 0.4645305570981495, 0.4294174265392905, 0.45883358479440006, 0.47398117513059324, 0.18408666590707357, 0.16926733744846312, 0.1935076825042078, 0.16871610717994823, 0.20107786522946558, 0.1918046674709808, 0.16168537793519067, 0.1937054057145038, 0.19409139022121713, 0.1239501073238305, 0.1413392159817931, 0.12147093068606296, 0.09261351228856807, 0.14730830574876796, 0.10984330826021238, 0.15113569469941157, 0.10696880939663966, 0.17572900001015135, 0.10939278225151816, 0.10622103134073513, 0.08493628849263513, 0.09401835250526003, 0.09479469964754572, 0.10062798190992106, 0.10125042477091173, 0.08958278256075425, 0.08594681316864716, 0.7875967818033407, 0.7663693226335854, 0.8738512836668652, 0.7830904626533399, 0.8993208075978425, 0.8285774568916057, 0.8443232348547355, 0.6447183443845735, 0.9886487721200898, 0.17928008964783781, 0.1999192791293648, 0.19807521308284992, 0.22052139321232522, 0.19878206299806278, 0.19414380665877518, 0.19838352870334042, 0.197107165569666, 0.19654509323422287, 0.40811827872848483, 0.3040984276408154, 0.32649376275856035, 0.5426875566405645, 0.28072703260668364, 0.32334179486338566, 0.2878842243802987, 0.21711079283120216, 0.41432754814224904, 0.12755472148978608, 0.16918274844042536, 0.11747481919396796, 0.12533398971317222, 0.1142337359862069, 0.13546669013452284, 0.13151541244903597, 0.12266658413691589, 0.1298376018214411, 0.12731166965243523, 0.11292226670154248, 0.07855701969794515, 0.12171095298494672, 0.13624487459214574, 0.09496785844789868, 0.13882496598321814, 0.10090389328452987, 0.11546363043433672, 0.029769043032016773, 0.09620447220418005, 0.04521123877910327, 0.04907991597942396, 0.016552838671376247, 9.999999999998899e-05, 0.04226071287539379, 0.06841560893740828, 0.05390094699300729, 0.15716148667623853, 0.13782517595136012, 0.19062979406875558, 0.15674777593158729, 0.14950805932786992, 0.17984602508231473, 0.1386755266952696, 0.17521061046755804, 0.19091165098356644, 0.009023824880264097, 9.999999999998899e-05, 0.006518924612694543, 0.021981209154651515, 0.02649824183947913, 0.00419851108625513, 0.01533127153000824, 0.004821148956365651, 9.999999999998899e-05, 0.10152002545688243, 0.101454261407523, 0.08754514750897291, 0.09733432768786787, 0.12584374798287012, 0.10166764371280657, 0.12465509088537141, 0.09027706607986097, 0.09351995512816214, 0.3871364612592062, 0.37414813213058074, 0.38208893740603234, 0.3903820514317282, 0.3723745371873529, 0.3644925420144809, 0.4000887689983337, 0.3899171851539397, 0.3824875505422417, 0.08623015061434602, 0.07648033450844982, 0.10155496041687462, 0.08194231464958701, 0.07476207868432339, 0.07924159163449329, 0.07903122709023369, 0.08380852814412942, 0.08429183679453123, 0.14486381423804018, 0.15882210044866873, 0.16447350894071933, 0.12447972942102314, 0.26056295835106213, 0.1529739392531595, 0.1258960159489061, 0.14143139763252366, 0.13554518396392667, 0.2526242796896754, 0.24872585611609999, 0.24595159588570448, 0.2559835325974279, 0.2492664693925456, 0.23527914103997905, 0.2619994760278842, 0.31299279241898437, 0.27183065699985876, 0.1580848542793738, 0.17164185174479463, 0.17590135896036385, 0.1995712233486242, 0.18991735314462765, 0.15766024884348384, 0.2298652131170591, 0.23353124856691243, 0.17311067428471794, 0.18941031417796206, 0.17813266778596626, 0.1624558416150823, 0.164473751226756, 0.16085398566656894, 0.15794645828654208, 0.17972698667643505, 0.16659394761351232, 0.18584713383235574, 0.18701306382620864, 0.1920500226357974, 0.1908508551857494, 0.23935497969370345, 0.1833243859519802, 0.20489103271751974, 0.1842604404922199, 0.16457581459943904, 0.18850900434634388, 0.17429427793132923, 0.45711342036335945, 0.5609867265975008, 0.35605935683103207, 0.1803787536515138, 0.1683582219315204, 0.13753515630178714, 0.1881599342913246, 0.16990336719361998, 0.3450450759631174, 0.4079462104788705, 0.3464050570672844, 0.36277107649404416, 0.1957075572856033, 0.17181187084703964, 0.19366872992590234, 0.12081644963579219, 0.43738248821196934, 0.16056834397482234, 0.1710083083446392, 0.17168372791388442, 0.17286760226611353, 0.15075965435985494, 0.1643113470894101, 0.17216436121838163, 0.18480167516012191, 0.16646320716820795, 0.06059861323575222, 0.0600993253247154, 0.07093176203944873, 0.07431379496372392, 0.06025047828578445, 0.06049778207191481, 0.07681554402086677, 0.0738845997417491, 0.0757335723651611]}, "mutation_prompt": null}
{"id": "56119820-b2e3-454e-b43a-18971afc039c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.3 * (success_rate - 0.4) + 0.05 * population_diversity)  # Small increase in diversity factor\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced diversity and mutation adaptation for improved convergence in Differential Evolution.", "configspace": "", "generation": 65, "fitness": 0.21134213815711356, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.5116093315690988, 0.4410520964365048, 0.4164057122100444, 0.43594196695270115, 0.45126268476033937, 0.4711489161279937, 0.48932249738466793, 0.436496836041968, 0.4398254087147634, 0.1741138874835102, 0.2480028897504658, 0.1849262802781454, 0.19837196767403198, 0.19983284126212997, 0.212768734051604, 0.21660812093143844, 0.17420338098189914, 0.18593067354890402, 0.11739261829772263, 0.1367261703553877, 0.10733094031454515, 0.1206054051848956, 0.1022870052235727, 0.1161997873657572, 0.12753937665160942, 0.10886329500066771, 0.117598274344207, 0.10656210531614774, 0.09735097006664473, 0.10550903956216262, 0.092887725438632, 0.10262693057068484, 0.08551787444033165, 0.10492236890843509, 0.1012998132772227, 0.07724818067330597, 0.7432318990397448, 0.758892792471543, 0.8837629854607948, 0.7658430483224858, 0.838474316250986, 0.8698445789702893, 0.8434548636553248, 0.6951006167939024, 0.988644359535393, 0.22634326470048016, 0.20658463913945768, 0.1891087279945628, 0.22993262620912436, 0.1728549506971665, 0.13452794770764942, 0.2008027401439726, 0.22885698210367544, 0.1775984043519453, 0.27649299499447744, 0.4693299171763988, 0.2895820609864721, 0.29430861143540865, 0.40557881919379624, 0.28299012167598214, 0.3649457313796499, 0.30871671503238796, 0.4021410763097196, 0.19329950036822618, 0.11655744924646239, 0.10800306383892333, 0.15864304031860066, 0.11869090179806008, 0.13321459703063065, 0.10378965481384461, 0.09875872867799917, 0.11626437708419779, 0.1504161667468561, 0.10359456644453602, 0.16193577223727407, 0.1272729523075874, 0.1396388670986458, 0.1279161735361507, 0.11171267000056728, 0.11143293919170305, 0.09929655374737634, 0.05661670557208631, 0.03759017252249597, 0.018070705577850288, 0.05690161861758647, 0.03290928776982005, 0.031210311235141508, 0.03172924137407407, 0.03928582917425083, 0.02620685987219329, 0.16106280491351777, 0.08872151446231724, 0.09998542582874792, 0.1479512503579835, 0.10100658901555148, 0.18013294053708628, 0.09225767441221722, 0.16176252610486086, 0.22583679747864283, 0.010847456943420708, 0.006542112406375922, 0.001236397429129621, 0.035121961313972716, 0.001846929859976587, 0.01863509249767159, 0.000761237769129175, 0.010970934009188249, 0.012040060349500892, 0.08620111807790876, 0.08372838524222515, 0.10801950905995905, 0.09372863633318085, 0.08987934384314267, 0.10876436414565838, 0.07684669401403066, 0.10308992412092544, 0.0736071987893312, 0.3868602918299944, 0.39625887029240026, 0.38140560919394595, 0.3634211720703412, 0.35467294447598263, 0.352579524767356, 0.424870158337191, 0.3675349221657144, 0.39576656983425107, 0.0801728562897801, 0.07235968696922535, 0.10538521527454792, 0.07690121990722687, 0.08765156030239563, 0.08273295980327111, 0.09441768215378776, 0.07085489861512728, 0.1009632622562191, 0.1349395462245473, 0.17259390345099668, 0.20067518801793494, 0.10355487946941888, 0.1312836226139258, 0.11455227095590403, 0.10362248648743477, 0.12302941314229299, 0.1453205479326647, 0.2486166119096198, 0.21797496486696732, 0.2766823795282758, 0.23480671665692754, 0.2719740826556707, 0.24944683164307702, 0.2632306166440711, 0.3051667033777875, 0.25857226426045277, 0.1713160139055535, 0.1715621042351293, 0.19123006451363633, 0.20255168109492305, 0.20632278173178253, 0.18743203217942728, 0.2238977114248103, 0.2116603921559801, 0.18988186291676934, 0.1757062635743747, 0.18079304168187826, 0.17913191096502012, 0.16890621054617005, 0.18865927064940358, 0.16945722493266735, 0.20906434445471545, 0.18439641040932575, 0.19382155781525479, 0.19746706382727675, 0.17859148944314673, 0.20516229241494244, 0.16598347381491785, 0.21567638408127232, 0.19386168675967486, 0.18944633601053673, 0.21473167177728414, 0.21851178201066135, 0.41620910925686183, 0.48761520007124837, 0.1846615627523881, 0.36050278073408604, 0.15612317631889416, 0.16376510185698245, 0.13513844732628622, 0.18536458730985972, 0.2284083210970902, 0.48340869607545434, 0.3454708747899654, 0.42383900867932767, 0.16225816853282993, 0.4505861726587854, 0.13354961729003412, 0.5909208736003908, 0.2878467634478473, 0.5170421368304601, 0.16974387185779527, 0.190253150771441, 0.16054118730610756, 0.1750870340316022, 0.16157369850473202, 0.1791383951570057, 0.15780056917925545, 0.15840806992452305, 0.18092014930147782, 0.069613652260752, 0.0678482712047811, 0.07586767194783606, 0.06221000625314732, 0.06337643888633793, 0.06174670905943036, 0.0677300084619672, 0.07144719081261153, 0.07202819027993734]}, "mutation_prompt": null}
{"id": "65e35264-d645-4349-b87d-cd0861935156", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.3 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced adaptive scaling of CR based on success rate to improve convergence speed while maintaining diversity.", "configspace": "", "generation": 66, "fitness": 0.21134213815711356, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.5116093315690988, 0.4410520964365048, 0.4164057122100444, 0.43594196695270115, 0.45126268476033937, 0.4711489161279937, 0.48932249738466793, 0.436496836041968, 0.4398254087147634, 0.1741138874835102, 0.2480028897504658, 0.1849262802781454, 0.19837196767403198, 0.19983284126212997, 0.212768734051604, 0.21660812093143844, 0.17420338098189914, 0.18593067354890402, 0.11739261829772263, 0.1367261703553877, 0.10733094031454515, 0.1206054051848956, 0.1022870052235727, 0.1161997873657572, 0.12753937665160942, 0.10886329500066771, 0.117598274344207, 0.10656210531614774, 0.09735097006664473, 0.10550903956216262, 0.092887725438632, 0.10262693057068484, 0.08551787444033165, 0.10492236890843509, 0.1012998132772227, 0.07724818067330597, 0.7432318990397448, 0.758892792471543, 0.8837629854607948, 0.7658430483224858, 0.838474316250986, 0.8698445789702893, 0.8434548636553248, 0.6951006167939024, 0.988644359535393, 0.22634326470048016, 0.20658463913945768, 0.1891087279945628, 0.22993262620912436, 0.1728549506971665, 0.13452794770764942, 0.2008027401439726, 0.22885698210367544, 0.1775984043519453, 0.27649299499447744, 0.4693299171763988, 0.2895820609864721, 0.29430861143540865, 0.40557881919379624, 0.28299012167598214, 0.3649457313796499, 0.30871671503238796, 0.4021410763097196, 0.19329950036822618, 0.11655744924646239, 0.10800306383892333, 0.15864304031860066, 0.11869090179806008, 0.13321459703063065, 0.10378965481384461, 0.09875872867799917, 0.11626437708419779, 0.1504161667468561, 0.10359456644453602, 0.16193577223727407, 0.1272729523075874, 0.1396388670986458, 0.1279161735361507, 0.11171267000056728, 0.11143293919170305, 0.09929655374737634, 0.05661670557208631, 0.03759017252249597, 0.018070705577850288, 0.05690161861758647, 0.03290928776982005, 0.031210311235141508, 0.03172924137407407, 0.03928582917425083, 0.02620685987219329, 0.16106280491351777, 0.08872151446231724, 0.09998542582874792, 0.1479512503579835, 0.10100658901555148, 0.18013294053708628, 0.09225767441221722, 0.16176252610486086, 0.22583679747864283, 0.010847456943420708, 0.006542112406375922, 0.001236397429129621, 0.035121961313972716, 0.001846929859976587, 0.01863509249767159, 0.000761237769129175, 0.010970934009188249, 0.012040060349500892, 0.08620111807790876, 0.08372838524222515, 0.10801950905995905, 0.09372863633318085, 0.08987934384314267, 0.10876436414565838, 0.07684669401403066, 0.10308992412092544, 0.0736071987893312, 0.3868602918299944, 0.39625887029240026, 0.38140560919394595, 0.3634211720703412, 0.35467294447598263, 0.352579524767356, 0.424870158337191, 0.3675349221657144, 0.39576656983425107, 0.0801728562897801, 0.07235968696922535, 0.10538521527454792, 0.07690121990722687, 0.08765156030239563, 0.08273295980327111, 0.09441768215378776, 0.07085489861512728, 0.1009632622562191, 0.1349395462245473, 0.17259390345099668, 0.20067518801793494, 0.10355487946941888, 0.1312836226139258, 0.11455227095590403, 0.10362248648743477, 0.12302941314229299, 0.1453205479326647, 0.2486166119096198, 0.21797496486696732, 0.2766823795282758, 0.23480671665692754, 0.2719740826556707, 0.24944683164307702, 0.2632306166440711, 0.3051667033777875, 0.25857226426045277, 0.1713160139055535, 0.1715621042351293, 0.19123006451363633, 0.20255168109492305, 0.20632278173178253, 0.18743203217942728, 0.2238977114248103, 0.2116603921559801, 0.18988186291676934, 0.1757062635743747, 0.18079304168187826, 0.17913191096502012, 0.16890621054617005, 0.18865927064940358, 0.16945722493266735, 0.20906434445471545, 0.18439641040932575, 0.19382155781525479, 0.19746706382727675, 0.17859148944314673, 0.20516229241494244, 0.16598347381491785, 0.21567638408127232, 0.19386168675967486, 0.18944633601053673, 0.21473167177728414, 0.21851178201066135, 0.41620910925686183, 0.48761520007124837, 0.1846615627523881, 0.36050278073408604, 0.15612317631889416, 0.16376510185698245, 0.13513844732628622, 0.18536458730985972, 0.2284083210970902, 0.48340869607545434, 0.3454708747899654, 0.42383900867932767, 0.16225816853282993, 0.4505861726587854, 0.13354961729003412, 0.5909208736003908, 0.2878467634478473, 0.5170421368304601, 0.16974387185779527, 0.190253150771441, 0.16054118730610756, 0.1750870340316022, 0.16157369850473202, 0.1791383951570057, 0.15780056917925545, 0.15840806992452305, 0.18092014930147782, 0.069613652260752, 0.0678482712047811, 0.07586767194783606, 0.06221000625314732, 0.06337643888633793, 0.06174670905943036, 0.0677300084619672, 0.07144719081261153, 0.07202819027993734]}, "mutation_prompt": null}
{"id": "7499e623-9567-4a97-8fb0-ee73668587c7", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.72  # Slight adjustment to mutation factor\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.07 * population_diversity)  # Adjusted factor\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Fine-tuned mutation factor and additional dynamic crossover adaptation for enhanced convergence speed.", "configspace": "", "generation": 67, "fitness": 0.21029190609558646, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.4616946273121727, 0.405944096669802, 0.4453055028089984, 0.440289006101511, 0.43874257747828127, 0.48567251678789447, 0.46593826324291354, 0.46130192157920746, 0.46055302132563425, 0.21042304630407438, 0.1843709334223801, 0.16932942973548815, 0.16221672418187405, 0.19900945274673387, 0.1762944770676288, 0.1739340954474703, 0.20373810722617247, 0.20119077768450766, 0.10603279186575876, 0.1105448140247638, 0.13525347393369214, 0.12709727411834992, 0.12044207421572972, 0.1316251994365697, 0.11400375050464373, 0.12541161426946834, 0.17659942850358568, 0.10669892627985722, 0.10955190575993512, 0.09993892928561088, 0.11163928674995205, 0.08919526491073482, 0.10239328827844563, 0.0738493357135821, 0.10351597403829638, 0.08872104746765508, 0.926370566808999, 0.4975457589228216, 0.8721713146722759, 0.8655129076653438, 0.8004436074654039, 0.8946440239197414, 0.8625444360869494, 0.5403640536085561, 0.9886469633918227, 0.21747713565699966, 0.1792896697067845, 0.23393015837100573, 0.21365578381164818, 0.20452077481446762, 0.1874554113497321, 0.2664740641320045, 0.1851062816500436, 0.22065657093210034, 0.2749068871076523, 0.5376509357570547, 0.3859045509374638, 0.23601102731250267, 0.3520337343574159, 0.5395057809377461, 0.40370629691555415, 0.2741599641989857, 0.3598946181430741, 0.13461548122107148, 0.1378649869131997, 0.10095556637909431, 0.14235242133551618, 0.14086077855137813, 0.11133423744235182, 0.13300418097137712, 0.1414857387993519, 0.12435814745455642, 0.10322285816609278, 0.09946745127231515, 0.11239870939777152, 0.10332335945502003, 0.12752667511543236, 0.12545779112396283, 0.11304020228665668, 0.10331830882759219, 0.10047995168100077, 0.08293698417269602, 0.06766142037012746, 0.043150275851172815, 0.08528681327118537, 0.045510741177905434, 0.06870854293708761, 0.0311900209475251, 0.04057788868849088, 0.041731932554253004, 0.18936220185934438, 0.19405506358896663, 0.16602320692283612, 0.21087426984505686, 0.16998988025005313, 0.19611798761956312, 0.17295166325186961, 0.1787546469139546, 0.17905695420620382, 0.013311313867287011, 0.01670165086267461, 0.007143931996974273, 0.02931637101150575, 0.027321956268270164, 0.01448244443552793, 0.025470339957066046, 0.0006876798409998219, 0.034446776932087975, 0.0965795666926309, 0.07785544962640545, 0.09158570899341667, 0.11481014255302668, 0.10879487550268896, 0.11582270490883384, 0.12672088841266682, 0.11630754034381374, 0.09391294079356072, 0.3921426947920591, 0.37997096338007574, 0.37253333835658764, 0.3844105070455689, 0.37580579866007846, 0.39618663563193335, 0.4069809770091415, 0.36117560406707117, 0.3950798075255194, 0.0882737249412725, 0.0813432636092668, 0.08225191770417717, 0.08172416614725153, 0.07111039655852325, 0.0775716523384743, 0.11317774210422071, 0.08448872334919633, 0.11065734600886967, 0.14739531670147576, 0.15527838717361142, 0.12165243095836209, 0.12122995836129702, 0.11275450669339893, 0.1322011784148972, 0.13881070151894204, 0.14040366969107343, 0.15821225934167793, 0.24817422636460673, 0.26627280867807923, 0.2439634370099497, 0.25897170302730377, 0.25101166651193785, 0.2589164430771682, 0.28533017187575693, 0.21308045289152833, 0.2714720713886568, 0.2045404343653252, 0.16064740695645063, 0.17167705018075397, 0.17961493458870792, 0.16964252352156872, 0.18409798718623782, 0.23041464306084003, 0.23340913466632585, 0.18163956208584575, 0.18031970652305795, 0.1756565242897381, 0.19348158292792927, 0.1637362901981222, 0.16550997877805618, 0.18315515547264216, 0.17113012474436673, 0.15595953148877562, 0.18401904876753583, 0.1807022842175462, 0.17575795489969237, 0.1669448717331834, 0.20979922413781904, 0.15689206117553056, 0.18059743783555438, 0.1827951300634697, 0.1791423822223307, 0.1752679206842691, 0.15813558556485874, 0.17043701705512848, 0.2855397043976271, 0.16286821558775477, 0.18537182290049437, 0.42670233966064053, 0.49339679480840115, 0.18402365247133534, 0.1715434448141132, 0.4578714256024202, 0.30697566179887936, 0.30053929098134136, 0.4415813334879043, 0.32875163235182747, 0.2873635116700317, 0.18266604049633972, 0.12064147740382947, 0.19346614885177216, 0.15613778961290337, 0.18751009258294304, 0.20323613056580903, 0.17109187450613572, 0.16069693750817804, 0.17406080176562932, 0.17133668598881413, 0.16320980020851328, 0.1725346737074016, 0.05930212425845671, 0.05334614327599341, 0.08373992523460516, 0.07537614763663858, 0.06210179689286199, 0.06730336887187283, 0.06889320175334346, 0.06142161836212168, 0.06798410939407384]}, "mutation_prompt": null}
{"id": "92815b56-7f63-4b87-a361-0202d9b8bb10", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3 + 0.01:  # Slightly increased variability\n                    F_dynamic = np.random.uniform(0.45, 0.85)  # Adjusted bounds\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)  # Adjusted factor\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced exploration using adaptive strategy for mutation factor to improve convergence speed.", "configspace": "", "generation": 68, "fitness": 0.21644077985586493, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "9ed4347b-e2cd-4e11-91e3-1e5f4a59a17a", "metadata": {"aucs": [0.44516910234451834, 0.43623799669175356, 0.45416677518201776, 0.4632565959231656, 0.4583255233872594, 0.45111447273935923, 0.5049823636541455, 0.4848509435802336, 0.4298051115083078, 0.20258746840007857, 0.19524073097573102, 0.1882941014611883, 0.24311023648408192, 0.20938939638438803, 0.19896700456798633, 0.19417445828621194, 0.16714978963585814, 0.17765199550361432, 0.10966568140981758, 0.11964830874630994, 0.1039670215626547, 0.1007559086145271, 0.1222533421241303, 0.1569023967424953, 0.11535500109766039, 0.12215753541784469, 0.13658006207308304, 0.07545724809409349, 0.13106646999244298, 0.08849285093743942, 0.09708133258546747, 0.11485022265489364, 0.11204155909015046, 0.08539221686674825, 0.09600196573724695, 0.08393663896822723, 0.9026289629307421, 0.7597936749833099, 0.8837629854607948, 0.48171553759769226, 0.883048957510383, 0.7299237089263514, 0.8455574475839079, 0.6620620130832136, 0.988644359535393, 0.19413466832820803, 0.21114567194107847, 0.18405991715098224, 0.22333070290753354, 0.18446053153699382, 0.22894407661056626, 0.21697746388957861, 0.16428592108882367, 0.2164757303017978, 0.5545100428275307, 0.4224745838508688, 0.2561251220578874, 0.5437646274471509, 0.4203474247762734, 0.321732247157839, 0.5227684053743786, 0.36387277612988633, 0.5608139586042243, 0.10544348408663884, 0.19250816085738187, 0.11449866712263501, 0.1287284624476801, 0.133539434565905, 0.100283015284368, 0.12378758852912142, 0.1104640024616036, 0.11687529109346195, 0.10678818224831754, 0.09691765789204432, 0.08070065924537362, 0.1125645267016333, 0.12150353156421789, 0.10453589907160588, 0.0944973861158045, 0.11609662961582745, 0.10380487177096531, 0.03192895914242999, 0.049743464603743126, 0.05041072912178446, 0.060717731815246534, 0.045070326914291026, 0.03321777465228348, 0.040432722131481746, 0.02788181503668674, 0.05326693456943632, 0.13657659800255384, 0.19497462742456373, 0.13151156594374114, 0.20768814726122942, 0.14301741292305692, 0.14732682398215746, 0.19895850830474415, 0.1585608536682297, 0.19358698401197794, 0.013485713021747836, 0.006612838910831642, 0.004434124024193631, 0.014697501153761894, 9.999999999998899e-05, 0.02400467814536822, 0.00758643402138659, 9.999999999998899e-05, 0.0020846044421901633, 0.08504653645554094, 0.08683999922623731, 0.11109244715164535, 0.0948988697914489, 0.10322925911015735, 0.10997880280391181, 0.08823827495961323, 0.12393506772848162, 0.08508674527564475, 0.36692903046135605, 0.37284513468197256, 0.40342546371786825, 0.41236223113632275, 0.3694652227477644, 0.38212110562028123, 0.38590898925493333, 0.3801195208083049, 0.37491520723679606, 0.07121560313512076, 0.07201833651328182, 0.07832730508392416, 0.07368556389281167, 0.08976733171592899, 0.07987506971975322, 0.11084473415364449, 0.0971500479858356, 0.09008647574395667, 0.12025755792380444, 0.15973694129866411, 0.23011029047807374, 0.15709906509976335, 0.13126736654208804, 0.1305654500442337, 0.10813841991414286, 0.17383930100112943, 0.12624547203457204, 0.255141616135962, 0.256680549492574, 0.2342285543535656, 0.26345854608490815, 0.24824934170580004, 0.24708150711871035, 0.2710526857427149, 0.292551221545314, 0.2745034992641485, 0.17943924519308874, 0.16725071770213984, 0.18271129346995152, 0.1928547518051862, 0.21319445866808118, 0.19588134057895923, 0.20058614900093585, 0.20741030937016047, 0.1802865542497848, 0.16055812226424204, 0.17001832176848564, 0.19716475535537437, 0.1857522536005446, 0.15159235442479346, 0.16071302755556738, 0.18769693770188056, 0.16552209364210324, 0.15742741211162214, 0.19162158909667493, 0.20709334787856992, 0.1852804037320347, 0.18646453339737767, 0.22970857143958934, 0.1838530706055186, 0.16383232257412728, 0.18559611373925144, 0.16249574847649417, 0.14715534727546442, 0.6124064449454067, 0.3573960488480836, 0.5412512661112361, 0.4949769292524504, 0.1777043719866549, 0.12995501134226983, 0.18724709848537824, 0.5103081881040483, 0.2757775795729335, 0.4368043028806895, 0.4880208452384298, 0.37998911679117764, 0.16896458385273905, 0.27644475900449794, 0.19619103792676107, 0.4027122036512283, 0.1852083477018226, 0.17864511122586535, 0.15404203030971952, 0.19634976542349158, 0.1757317661989657, 0.16076593734879097, 0.1698721997213961, 0.17074567320472944, 0.18408414625081715, 0.19471841801624645, 0.06975245870104063, 0.05460712382724309, 0.06756224418289625, 0.11047804414812168, 0.06243814594016983, 0.05876656707796579, 0.06671845968611756, 0.05771144013905938, 0.07312720027544617]}, "mutation_prompt": null}
{"id": "b48bf3aa-7fd1-4cae-87de-d5675c616483", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3 + 0.01:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.choice(range(self.population_size), p=[0.8/self.population_size if j != i else 0.2 for j in range(self.population_size)])  # Modified selection for elite\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced exploration with adaptive mutation factor and elite preservation for faster convergence.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('probabilities do not sum to 1').", "error": "ValueError('probabilities do not sum to 1')", "parent_id": "92815b56-7f63-4b87-a361-0202d9b8bb10", "metadata": {}, "mutation_prompt": null}
{"id": "3da12675-6449-4f38-bb75-85d3ee2e7179", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.3 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:  # Slightly increased variability\n                    F_dynamic = np.random.uniform(0.4, 0.9)  # Adjusted bounds\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.3 * (success_rate - 0.4) + 0.05 * population_diversity)  # Adjusted factor\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced diversity and adaptive mutation in differential evolution for faster convergence.", "configspace": "", "generation": 70, "fitness": 0.21063401391998637, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "92815b56-7f63-4b87-a361-0202d9b8bb10", "metadata": {"aucs": [0.4477139261934574, 0.4941536738402389, 0.45776419104703925, 0.47323934084210517, 0.44021379124162174, 0.43282944206192875, 0.4986443134098669, 0.4705419683462849, 0.4673863753877874, 0.1686892102742542, 0.2029608761931676, 0.18664044745476072, 0.21201876221113403, 0.1707983971328917, 0.1860033395203855, 0.18076683715940822, 0.20544239339691506, 0.2388154742833941, 0.1191754378115345, 0.11145696875141275, 0.0927117213509897, 0.225138040137718, 0.12793676798652942, 0.11878614486537986, 0.11579335864066576, 0.10333278269486423, 0.11414815007650725, 0.10098316695826415, 0.10457475649280457, 0.09779742250845103, 0.0941337279131722, 0.08925082415356522, 0.10599048857120374, 0.09280513760287612, 0.09437429696525723, 0.08880999780540844, 0.8679798689166907, 0.8044927054625243, 0.7531828690053344, 0.5714244353370118, 0.8552114191365503, 0.9003115716039598, 0.7647838417507082, 0.6315415546009415, 0.9885883356623912, 0.21297683824036862, 0.22078717955031224, 0.18477880412891978, 0.19972352619058464, 0.12980369011906623, 0.1746956583370728, 0.18958731194126965, 0.22832365458296655, 0.20639060507841145, 0.35591654050577615, 0.28766964247827975, 0.3768810884971595, 0.4626957642334777, 0.5647390790951097, 0.440297606040439, 0.27205332497605306, 0.34267479491140906, 0.2761729278295213, 0.1848310217253989, 0.10186686582536053, 0.11879439842440565, 0.13357215144951373, 0.13483439535362196, 0.1057808574121436, 0.12338579075550227, 0.1310049236900913, 0.16827583564503168, 0.09783193817758218, 0.04565124922528774, 0.15537125119086437, 0.1271911696025756, 0.09421784023036328, 0.09844510167246989, 0.12026829169986908, 0.11534693997201795, 0.11383736620216844, 0.06557518886081637, 0.04328019421028728, 0.04235235816874228, 0.03411393700873411, 0.07038772175580721, 0.04066046851441152, 0.03948683764096517, 0.01871331960728817, 0.03875600326951312, 0.14159969584901078, 0.16689748482047073, 0.18430389367873012, 0.12229745330209241, 0.10242172958982809, 0.13577060159540655, 0.22718986517725948, 0.18119055125769878, 0.2039261640215263, 0.038985871714716236, 0.007114802914805485, 0.003680066652981595, 0.0014863987436188886, 0.026229136377368567, 0.013752662813120375, 0.0002571821842805022, 0.03394714676653454, 9.999999999998899e-05, 0.10777545626154172, 0.09633305486010757, 0.10602836791455195, 0.09567960903623263, 0.12595973907861513, 0.10285828906910843, 0.10627496632849509, 0.11163116221664404, 0.1042193008366088, 0.40205394171296516, 0.3938758570390566, 0.3757856358825111, 0.3484093038407624, 0.4013381243448405, 0.3642489452854277, 0.38438895404094964, 0.3950839932225345, 0.3730492853194127, 0.12146470396171405, 0.0788694489059022, 0.11060930728952045, 0.08497138970657325, 0.07887686609806044, 0.0788819865869671, 0.09092812847808984, 0.08028406619358652, 0.07349047109357221, 0.13288373892301275, 0.16455788810350236, 0.129372973533179, 0.14711588469903358, 0.1585927149311972, 0.11795609694583742, 0.17586987701764323, 0.13520543490828274, 0.13928866198548118, 0.24932775592099288, 0.24610756132345646, 0.23974103090449284, 0.2475082145925328, 0.24260021076277904, 0.24631660878943418, 0.28589084815205024, 0.30991674149279946, 0.26754343359520294, 0.17091820121566093, 0.18038421089461587, 0.2068965047836684, 0.17773070677557956, 0.1573085251909555, 0.18789149663877758, 0.22624941653896613, 0.2289860411845147, 0.19814016984926153, 0.19312928727093892, 0.170968201822994, 0.1786141138065337, 0.16732937288929628, 0.1613888984677797, 0.17113379128629935, 0.2029355226490538, 0.1457953529557945, 0.20740918143438603, 0.18173524298836718, 0.22932625243283877, 0.26493999566120574, 0.1904277111925986, 0.1809009591284042, 0.2135062751588208, 0.17597349114271166, 0.17037994882801977, 0.17403998464759007, 0.1647909724093961, 0.5610807421106594, 0.1875823463675511, 0.542175016289187, 0.18189482940448443, 0.1700259866487781, 0.1548660598428827, 0.4201416860009709, 0.40871732134340355, 0.38140056211372053, 0.19436472936312432, 0.1483914809159167, 0.459375938408883, 0.1520993494355375, 0.17634538371973374, 0.18533978263090622, 0.36909003481674785, 0.1908462003150858, 0.18186237311260556, 0.1776072137684077, 0.16660627257549188, 0.18016628085947084, 0.17727679153731957, 0.15420293473068758, 0.1561794097795588, 0.1913425449502426, 0.16712926727960897, 0.06761364713583629, 0.06415805395963525, 0.06374437732881666, 0.06108889103039494, 0.07857863583357971, 0.06419495119546503, 0.0668828810924369, 0.06472331289631916, 0.07096514324748004]}, "mutation_prompt": null}
{"id": "e633bb78-d5d0-4e23-85a9-a571d786523d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3 + 0.01:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05) # Added dynamic scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2): # Enhanced elitism integration\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced dynamic scaling for mutation factor and enhanced elitism integration to balance exploration and exploitation.", "configspace": "", "generation": 71, "fitness": 0.23186072391745471, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "92815b56-7f63-4b87-a361-0202d9b8bb10", "metadata": {"aucs": [0.5432614142695434, 0.6053196079660932, 0.6061240368907423, 0.5944858115957694, 0.5160633780039942, 0.5442954472547341, 0.5810761091394945, 0.5964853559518457, 0.6195055504252378, 0.2787643586039118, 0.2534094981617083, 0.1977056231743789, 0.07684042576636407, 0.23003893823345123, 0.22595155084113683, 0.2891584573341478, 0.28073981342904086, 0.26065137381157755, 0.08874849353489678, 0.1154107446781405, 0.1287748071010445, 0.09223645009357262, 0.09945547824628342, 0.09981477844530273, 0.12682267374208545, 0.11523228409341901, 0.11956677739474142, 0.15973552510509403, 0.13231188100389446, 0.1162914407614859, 0.10222531505608534, 0.1267551026880579, 0.10674023764210416, 0.10813628780908113, 0.09394457988945815, 0.10922983681746157, 0.7602609726438176, 0.9357438149723706, 0.7217909098273545, 0.09771849390922815, 0.9000917776577946, 0.812236083730276, 0.9131712170429682, 0.6373777965054709, 0.9465783503103227, 0.1546195554889056, 0.2374362490397821, 0.2801645173160563, 0.256594975640666, 0.1377496864099661, 0.2607950599151021, 0.20334388020543914, 0.24908234429353648, 0.2625705096595894, 0.3080498584297384, 0.3177171651978987, 0.3219042594601942, 0.630090538495986, 0.2004088812680922, 0.24564817976878006, 0.6395313025872267, 0.25075881424035695, 0.339232408449906, 0.10950282272741729, 0.16236118215632556, 0.17750325754066798, 0.1314986395533062, 0.16143792314663574, 0.09794755102366326, 0.14079556184035769, 0.19077587528939277, 0.16327145727812054, 0.020701534306078573, 0.009686333170105033, 0.10483830908293112, 0.1552360400892281, 0.12711593804402033, 0.14071957783505473, 0.1044403698221853, 0.17310728240148632, 0.1153269054447359, 0.07698673411606638, 9.999999999998899e-05, 0.11232500083587149, 9.999999999998899e-05, 0.02070796473462777, 0.07942159438774166, 0.028044526655408797, 0.023598768812082893, 0.04873734672157881, 0.11543548693785766, 0.20014333866838696, 0.13742958721365361, 0.09665550252364441, 0.18965670476593455, 0.05158589618873377, 0.09407753969912336, 0.2937699381165729, 0.15817778181532316, 0.03436574485357102, 0.05032127657555918, 0.053953107886254625, 0.1015356021763566, 0.03880591788573984, 0.058906752770315096, 0.07031594200781288, 0.09830982228765495, 0.04102762230145085, 0.1600180216174074, 0.14158949116645636, 0.11253891155198636, 0.1807721653976112, 0.10466805989024686, 0.10356506474213911, 0.1530526171828105, 0.14067431763311433, 0.13021472029501746, 0.42914560423910975, 0.3983482690708805, 0.43811057369527817, 0.44975475915946594, 0.4305982919483822, 0.409805130059124, 0.461371486383067, 0.44471108404138127, 0.44905396004777454, 0.07568965818137618, 0.08663862181378301, 0.3247515250755787, 0.0883122916566772, 0.08274933167332055, 0.08827260609457122, 0.13347715015492123, 0.10899502027170715, 0.0773531409528252, 0.09669234896377588, 0.11024966079775711, 0.15030559976291913, 0.3273061812400865, 0.10852972522114035, 0.1354488563699533, 0.12602814723001354, 0.14598137564717195, 0.12314726261972919, 0.3150446197448238, 0.27153813676265803, 0.27809854823453173, 0.27716515624506344, 0.29883499274882763, 0.31643926576784, 0.22865500638137626, 0.21979087033046318, 0.27723625315609146, 0.20852064750772648, 0.24900256359649253, 0.20084664885556092, 0.1945909642652689, 0.25152556405474225, 0.2483082644595198, 0.14727495207009655, 0.2408518648564416, 0.20989074639379168, 0.19714625698614185, 0.17735691660585817, 0.20069682210618234, 0.1665670928252122, 0.17447190690482184, 0.17806267141482968, 0.20664610124791527, 0.19824090248926862, 0.14611740589160405, 0.18806190847688975, 0.1798805087611014, 0.19771675816408718, 0.18514452385122582, 0.20787985102461604, 0.1770653891611388, 0.17875490079276746, 0.3650305042794125, 0.1840676449736819, 0.6482836839037607, 0.1630897559053761, 0.7104838394780255, 0.7165412471101555, 0.18846338732634638, 0.16880152434455975, 0.1358289208396416, 0.13480364563286062, 0.19923297943364804, 0.6234777396437685, 0.29780799200419183, 0.5613885174842905, 0.4736441223117196, 0.4596440660280102, 0.15903502156143623, 0.1369918144166038, 0.12089312818737286, 0.5921201057117773, 0.17135193839745277, 0.17560822564271716, 0.16371756642504953, 0.16750697157896643, 0.19264137860467945, 0.15520353944366938, 0.21081357439947102, 0.15565446651366566, 0.182226425608096, 0.06558424157023568, 0.057939302410324856, 0.07194431791695477, 0.06288545615541519, 0.0767157682470816, 0.059587920091848545, 0.06675471152157264, 0.08528658863623972, 0.07677920933535698]}, "mutation_prompt": null}
{"id": "7b90308a-a35e-4da3-a17d-4513f21a8c25", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        best_indices = np.argsort([func(ind) for ind in self.population])[:3]\n\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3 + 0.01:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic += (0.02 if np.random.uniform(0, 1) < 0.1 else 0)  # Small dynamic adjustment\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced diversity preservation through dynamic crossover adaptation and improved selection.", "configspace": "", "generation": 72, "fitness": 0.2308909360330037, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "e633bb78-d5d0-4e23-85a9-a571d786523d", "metadata": {"aucs": [0.6502092621447871, 0.5807347204745814, 0.5690290299302372, 0.6005801320944588, 0.5246495859674944, 0.5382584585157958, 0.5732716667790259, 0.6088365758208719, 0.4842580399453734, 0.25398314615292517, 0.1719470575396188, 0.2185871302662128, 0.05109139941845642, 0.22513234277479466, 0.2974012003208443, 0.17702698608525624, 0.22799931644583538, 0.05123818442250927, 0.1224626039028417, 0.14501223701116162, 0.12456161392437448, 0.12946418286932437, 0.14468078504798942, 0.13423015380419145, 0.124470213456921, 0.1189278577490599, 0.10263709592608372, 0.0885958262049431, 0.07901302590454673, 0.08768291167824682, 0.08465757558305997, 0.09627241544342557, 0.0903814948504581, 0.09278768859932152, 0.11984280545207493, 0.08249637995467252, 0.7843115058560155, 0.8462802807027773, 0.904358139423991, 0.8924655420017329, 0.5529638371994524, 0.8900084588948389, 0.8194353334092475, 0.8483313430969219, 0.9558829737419959, 0.22853685119957112, 0.24903748936745518, 0.19547203959937998, 0.23343067098772896, 0.13011854890295893, 0.26084939481817027, 0.3108147469988458, 0.274750150687867, 0.2326838910856306, 0.32057117884032427, 0.5566315844044522, 0.6342292687936605, 0.2006382506603933, 0.6539054242590304, 0.23851537120991606, 0.32349811233268333, 0.2230314065050446, 0.20879379272711363, 0.23714205525933807, 0.11135470222818, 0.13464170367709538, 0.11405109967817373, 0.0987449531121316, 0.19899963940339382, 0.16173224810724152, 0.14267491949124178, 0.16141236771382372, 0.13717872044022683, 0.14030236813454267, 0.11368562976306418, 0.13751724900549966, 0.15075542171431366, 0.14750269753638334, 0.16118843055485776, 0.1201857089832139, 0.12295074627086955, 0.06465080089659025, 0.11533818227661652, 0.05076908268927238, 0.07828746147446475, 0.06860591256322646, 0.03206555846543069, 0.08543813885251261, 0.022964256546342376, 0.0702518044799012, 0.13075135219421719, 0.11482043686241272, 0.11546206786139046, 0.17657666271585637, 0.045334842167708445, 0.12280140888479962, 0.13499103396952195, 0.09862328743421445, 0.16011234726441637, 0.16506457904388794, 0.06287373093139192, 0.06286117816370573, 0.05956629597429086, 0.03152237369354283, 0.07226297664154868, 0.04224671768616883, 0.029850794475054454, 0.08171153222421834, 0.14227265203163875, 0.13989482591167657, 0.11597209154940169, 0.149389241286916, 0.14656502278261518, 0.031708504068254095, 0.1178797770379788, 0.16486209181492828, 0.1495770043973449, 0.4556574052166401, 0.43760517634621254, 0.4110125800665012, 0.4744327069634867, 0.4468553946837972, 0.40464328115169423, 0.4765250562667729, 0.4673337976323241, 0.45287411540399436, 0.06509678242263595, 0.0896486447839907, 0.06494580093900937, 0.053351909186486246, 0.08556686515789336, 0.09085448722032363, 0.08076009322509636, 0.060799612173461304, 0.06896863581023605, 0.09800187572738961, 0.1652697215065807, 0.1356775215949232, 0.10568724420970088, 0.12272104926588168, 0.13487484885099588, 0.23947016160619405, 0.12661572642436203, 0.1292159988522924, 0.29034796314529143, 0.24856760132736877, 0.24143543778891996, 0.3146647874993871, 0.24628781988556703, 0.3165662877674136, 0.3092326188523017, 0.31489247408890353, 0.31358108152051367, 0.22455227254412635, 0.21371096348837293, 0.1931016340519366, 0.20040816628896796, 0.12814686818376353, 0.23947824285165942, 0.17791231579220967, 0.20271637797098807, 0.16313014329912823, 0.17172658362288296, 0.17070609234729384, 0.14726739350769535, 0.17411346617008927, 0.15906698033298783, 0.16204357916523127, 0.20271435579660657, 0.1838799522854655, 0.15718599470438932, 0.17784442912500054, 0.1729808346249363, 0.18465894745586697, 0.19112888349445645, 0.1955860873304166, 0.16301846934723485, 0.1775634368299418, 0.17144834354534055, 0.16119569261240996, 0.6168597682726342, 0.17262862326390171, 0.1440294309219864, 0.47324562839167816, 0.7347786175319821, 0.6658791980803067, 0.14035912909514958, 0.6198298467316585, 0.6478778956182434, 0.5917433679643691, 0.19861125303101157, 0.12346928648783773, 0.6058788775947204, 0.15089242785811852, 0.11018692790134121, 0.18575130712029875, 0.14844772167031572, 0.1923685528531841, 0.16931161965844344, 0.18840081468076886, 0.17613637818898875, 0.17225901738420946, 0.18928831949013725, 0.1471147132694548, 0.1663674525071025, 0.18378779025652558, 0.1596938567181414, 0.06632628373544813, 0.07637817582936002, 0.06966007061513935, 0.05468277323229087, 0.07625213110064943, 0.06235783149749585, 0.06436164791906307, 0.05909096681166104, 0.07290202995521433]}, "mutation_prompt": null}
{"id": "b4130c06-b1e7-48e2-8df3-daa9f60c8bbc", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        fitness_improvement_rate = 0.0\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3 + 0.01:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_adaptive = CR_dynamic * (1 + 0.15 * fitness_improvement_rate)  # Adaptive crossover rate modification\n                cross_points = np.random.rand(self.dim) < CR_adaptive\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    fitness_improvement_rate = 0.9 * fitness_improvement_rate + 0.1 * (self.best_fitness - trial_fitness) / abs(self.best_fitness)\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced adaptive crossover rate based on fitness improvement trends to enhance solution diversity and convergence speed.", "configspace": "", "generation": 73, "fitness": 0.193262001208253, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "e633bb78-d5d0-4e23-85a9-a571d786523d", "metadata": {"aucs": [0.5636968634566899, 0.4973157895122836, 0.5297095498831201, 0.587979653498323, 0.5374771302962047, 0.5187790776430324, 0.5232231002127905, 0.5059970803226272, 0.6088041801713626, 0.23582928659424374, 0.2220365091452281, 0.2416444077320139, 0.18831280990774613, 0.012027267711149037, 0.19879374532437777, 0.22770697858781008, 9.999999999998899e-05, 0.29210117034617156, 0.1473627154341859, 0.18057887400771322, 0.21055179354238496, 0.14575315725968319, 0.2655246517739477, 0.21113904157984176, 0.22812986399184065, 0.17419101895570965, 0.14118610564831868, 0.1516800367782315, 0.12271453475436012, 0.14783478216369816, 0.13694964790221298, 0.1480291396688308, 0.10219506811864809, 0.12117784092573891, 0.17209089446356962, 0.1259204354147394, 0.8643832506625897, 0.8370337946793623, 0.8713006595649146, 0.8497345687176188, 0.8353682567415907, 0.8818749615175896, 0.9045928218866821, 0.8697727648095523, 0.8546073736872758, 0.13338367607358792, 0.1246679460844976, 0.21403916309270876, 0.15037192475982042, 0.1165544381758149, 0.17689000822659895, 0.17792526092397842, 0.10747438449021152, 0.1649133548702697, 0.15239269242595288, 0.15243382345822143, 0.14972015752428325, 0.2592749449353732, 0.17680360203294077, 0.21773694932711363, 0.17939728057548876, 0.15885375019524695, 0.16409266854616544, 0.23642453471913483, 0.10723596288891457, 0.11831884035151474, 0.13857564634806163, 0.19737552868829344, 0.11507039504108618, 0.14571663312884087, 0.1095128698983191, 0.13180847971728848, 0.10590224351279254, 0.12624610596087915, 0.10037927368393285, 0.09381284799116563, 0.11872005664158802, 0.16070018693080856, 0.036639354328080076, 0.09721028440309254, 0.14660685173394827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003733561753417436, 9.999999999998899e-05, 0.013439573717322628, 0.05303203897916842, 0.054134701220826864, 0.06119792337221752, 0.05037097779380273, 0.02479835377612183, 0.05096266782593428, 0.05616758818671641, 0.05371956211061257, 0.031861375292545735, 0.032017828681030536, 0.007903030464897154, 0.005927380803872673, 0.04468497158624307, 0.027517498768397708, 0.0070142740408869475, 0.04199891791913213, 0.011012097801612275, 0.029474292801505042, 0.06717371951765416, 0.028085434621239025, 0.06520829809734263, 0.0108143523172064, 0.03905374157293118, 0.034826980117022344, 0.12135502749633065, 0.1037639457803321, 0.0869014248980926, 0.3615902109132396, 0.3634141208735787, 0.3869467393627827, 0.3228332344386283, 0.3414608042853362, 0.32326830125265005, 0.41532097506625154, 0.37897675701744005, 0.3572177174537472, 0.06845385860840503, 0.06903429663329075, 0.07078319148671086, 0.08318443581864743, 0.0488281922872964, 0.07827014221934658, 0.07255603406131195, 0.10498783681014734, 0.08069240131546618, 0.13652297803104352, 0.15827329179532557, 0.15084589215503752, 0.15894381334875685, 0.1397320241787824, 0.17244606877631463, 0.15987602761256403, 0.13582284670753275, 0.21009210787164323, 0.15923973786514212, 0.22370591173659082, 0.19347245887472198, 0.17006908739690552, 0.19850525726970503, 0.19947059945347934, 0.23098911078830808, 0.24282154601077766, 0.21904934546156019, 0.12385479978734315, 0.10307179973167391, 0.11683401393102177, 0.14596141281799868, 0.11323902122032936, 0.15533985685275387, 0.1889048466062685, 0.19776566772932247, 0.1641808348017073, 0.19023250621754106, 0.1851292811306383, 0.16348208057311564, 0.18241600383255085, 0.16652529350292045, 0.18162929234487402, 0.1721494334481708, 0.15940633253164538, 0.18099393526894902, 0.29478481324997263, 0.17972950246588393, 0.23710307426621635, 0.18067835468461835, 0.16607437866560082, 0.18762220560051024, 0.19124580874310793, 0.1734160929776779, 0.18273169559592783, 0.1670341896676173, 0.245919334119591, 0.14469124901148933, 0.48909431030119077, 0.18443969033345176, 0.3259943600094072, 0.1555139988210389, 0.2834001910555507, 0.21274143206259077, 0.3379285432113761, 0.18941200181737272, 0.24939752514594793, 0.18627152791492174, 0.1803349557392392, 0.1538156210468824, 0.12675058290316354, 0.27303980398075856, 0.19218926828211902, 0.1614327435906494, 0.1700858915591249, 0.1730196246254846, 0.17818832766415382, 0.162714337367878, 0.15896795231835092, 0.16433011646229856, 0.16280866466110366, 0.19577880887813026, 0.055151100597317204, 0.06508506471662023, 0.0785032481897373, 0.05193199016021177, 0.06722055987509978, 0.047430081237533006, 0.08643432560192432, 0.06489512423313426, 0.05519970200693147]}, "mutation_prompt": null}
{"id": "56e6a41b-9564-4dc5-9ba4-4d2bf22cc5fd", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                fitness_variance = np.var([func(ind) for ind in self.population])\n                if fitness_variance < 0.01:\n                    self.population_size = max(self.dim, int(self.population_size * 0.65))\n                else:\n                    self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3 + 0.01:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced adaptive population size adjustment based on fitness variance to enhance exploration-exploitation balance.", "configspace": "", "generation": 74, "fitness": 0.23186072391745471, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "e633bb78-d5d0-4e23-85a9-a571d786523d", "metadata": {"aucs": [0.5432614142695434, 0.6053196079660932, 0.6061240368907423, 0.5944858115957694, 0.5160633780039942, 0.5442954472547341, 0.5810761091394945, 0.5964853559518457, 0.6195055504252378, 0.2787643586039118, 0.2534094981617083, 0.1977056231743789, 0.07684042576636407, 0.23003893823345123, 0.22595155084113683, 0.2891584573341478, 0.28073981342904086, 0.26065137381157755, 0.08874849353489678, 0.1154107446781405, 0.1287748071010445, 0.09223645009357262, 0.09945547824628342, 0.09981477844530273, 0.12682267374208545, 0.11523228409341901, 0.11956677739474142, 0.15973552510509403, 0.13231188100389446, 0.1162914407614859, 0.10222531505608534, 0.1267551026880579, 0.10674023764210416, 0.10813628780908113, 0.09394457988945815, 0.10922983681746157, 0.7602609726438176, 0.9357438149723706, 0.7217909098273545, 0.09771849390922815, 0.9000917776577946, 0.812236083730276, 0.9131712170429682, 0.6373777965054709, 0.9465783503103227, 0.1546195554889056, 0.2374362490397821, 0.2801645173160563, 0.256594975640666, 0.1377496864099661, 0.2607950599151021, 0.20334388020543914, 0.24908234429353648, 0.2625705096595894, 0.3080498584297384, 0.3177171651978987, 0.3219042594601942, 0.630090538495986, 0.2004088812680922, 0.24564817976878006, 0.6395313025872267, 0.25075881424035695, 0.339232408449906, 0.10950282272741729, 0.16236118215632556, 0.17750325754066798, 0.1314986395533062, 0.16143792314663574, 0.09794755102366326, 0.14079556184035769, 0.19077587528939277, 0.16327145727812054, 0.020701534306078573, 0.009686333170105033, 0.10483830908293112, 0.1552360400892281, 0.12711593804402033, 0.14071957783505473, 0.1044403698221853, 0.17310728240148632, 0.1153269054447359, 0.07698673411606638, 9.999999999998899e-05, 0.11232500083587149, 9.999999999998899e-05, 0.02070796473462777, 0.07942159438774166, 0.028044526655408797, 0.023598768812082893, 0.04873734672157881, 0.11543548693785766, 0.20014333866838696, 0.13742958721365361, 0.09665550252364441, 0.18965670476593455, 0.05158589618873377, 0.09407753969912336, 0.2937699381165729, 0.15817778181532316, 0.03436574485357102, 0.05032127657555918, 0.053953107886254625, 0.1015356021763566, 0.03880591788573984, 0.058906752770315096, 0.07031594200781288, 0.09830982228765495, 0.04102762230145085, 0.1600180216174074, 0.14158949116645636, 0.11253891155198636, 0.1807721653976112, 0.10466805989024686, 0.10356506474213911, 0.1530526171828105, 0.14067431763311433, 0.13021472029501746, 0.42914560423910975, 0.3983482690708805, 0.43811057369527817, 0.44975475915946594, 0.4305982919483822, 0.409805130059124, 0.461371486383067, 0.44471108404138127, 0.44905396004777454, 0.07568965818137618, 0.08663862181378301, 0.3247515250755787, 0.0883122916566772, 0.08274933167332055, 0.08827260609457122, 0.13347715015492123, 0.10899502027170715, 0.0773531409528252, 0.09669234896377588, 0.11024966079775711, 0.15030559976291913, 0.3273061812400865, 0.10852972522114035, 0.1354488563699533, 0.12602814723001354, 0.14598137564717195, 0.12314726261972919, 0.3150446197448238, 0.27153813676265803, 0.27809854823453173, 0.27716515624506344, 0.29883499274882763, 0.31643926576784, 0.22865500638137626, 0.21979087033046318, 0.27723625315609146, 0.20852064750772648, 0.24900256359649253, 0.20084664885556092, 0.1945909642652689, 0.25152556405474225, 0.2483082644595198, 0.14727495207009655, 0.2408518648564416, 0.20989074639379168, 0.19714625698614185, 0.17735691660585817, 0.20069682210618234, 0.1665670928252122, 0.17447190690482184, 0.17806267141482968, 0.20664610124791527, 0.19824090248926862, 0.14611740589160405, 0.18806190847688975, 0.1798805087611014, 0.19771675816408718, 0.18514452385122582, 0.20787985102461604, 0.1770653891611388, 0.17875490079276746, 0.3650305042794125, 0.1840676449736819, 0.6482836839037607, 0.1630897559053761, 0.7104838394780255, 0.7165412471101555, 0.18846338732634638, 0.16880152434455975, 0.1358289208396416, 0.13480364563286062, 0.19923297943364804, 0.6234777396437685, 0.29780799200419183, 0.5613885174842905, 0.4736441223117196, 0.4596440660280102, 0.15903502156143623, 0.1369918144166038, 0.12089312818737286, 0.5921201057117773, 0.17135193839745277, 0.17560822564271716, 0.16371756642504953, 0.16750697157896643, 0.19264137860467945, 0.15520353944366938, 0.21081357439947102, 0.15565446651366566, 0.182226425608096, 0.06558424157023568, 0.057939302410324856, 0.07194431791695477, 0.06288545615541519, 0.0767157682470816, 0.059587920091848545, 0.06675471152157264, 0.08528658863623972, 0.07677920933535698]}, "mutation_prompt": null}
{"id": "048b9d18-a3fa-41af-8b6f-d79bb4d44e7c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3 + 0.01:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05) # Added dynamic scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = max(0.1, CR_dynamic - 0.1 * (1 - success_rate)) # Adaptive adjustment\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2): # Enhanced elitism integration\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "EnhancedHybridDifferentialEvolution with adaptive crossover probability adjustment for improved convergence.", "configspace": "", "generation": 75, "fitness": 0.2289097559118527, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "e633bb78-d5d0-4e23-85a9-a571d786523d", "metadata": {"aucs": [0.6154451274396862, 0.5697587206441306, 0.5716489050154817, 0.5683849086820174, 0.56332095556896, 0.5522744739962767, 0.5877002902597744, 0.5943062803826715, 0.5900308552475277, 0.25937120590434337, 0.342107041928293, 0.32355027313723017, 0.23441644374499937, 0.277809502737688, 0.2515246565136038, 0.33534229514438807, 0.24535818689858213, 0.2920879756039193, 0.10179625387137203, 0.12557013725153543, 0.11863126764043408, 0.1253754151841806, 0.1268066277880463, 0.11872386078170982, 0.14081887176665353, 0.09824946415017388, 0.11601085260859745, 0.11195900143563853, 0.06911598487355697, 0.08251896422995197, 0.09730012890579331, 0.11772587906033749, 0.09802803004753291, 0.09467202286985177, 0.09676074020229386, 0.13411333222531174, 0.8066423493152118, 0.933916320517031, 0.807302402014286, 0.8506309233786371, 0.9550458935185299, 0.8968243172966928, 0.8941543478757721, 0.8247442425896955, 0.9214543422885699, 0.2814926138786251, 0.26882327159854935, 0.23777094592810089, 0.2530087071132653, 0.2426534065172392, 0.19798722411499803, 0.272849107156361, 0.26440656772473636, 0.23701133656162576, 0.22306818532636175, 0.2641941890171404, 0.19873376476070548, 0.31917917771000803, 0.2375095549447659, 0.492765197885466, 0.28495183832294346, 0.5193421986756594, 0.20892992402934008, 0.13067575717960522, 0.10958251176222533, 0.13612145640119655, 0.11516063443640578, 0.13236650565582353, 0.12901145733922204, 0.11865695451557456, 0.16403909659749893, 0.10138193066331191, 0.1625765453773833, 0.03934456731521274, 0.0989364636511002, 0.14678630871607168, 0.12475073500293254, 0.14308194685929665, 0.1493251453515284, 0.1434631204154755, 0.10929329703229052, 0.059958994413420785, 9.999999999998899e-05, 0.03141595306126821, 0.02873430504520824, 0.03090973378187356, 0.03624456852212876, 0.029305928339270593, 9.999999999998899e-05, 9.999999999998899e-05, 0.103083297995614, 0.10437451560462707, 0.10499823084953419, 0.11875006937622534, 0.11552789991510959, 0.0679452653989896, 0.24185274320017303, 0.08222933166886437, 0.17841916546251269, 0.034738886026892346, 0.039354189560467434, 0.032164625787908685, 0.0809425098125437, 0.04702146439707211, 0.08890926897692208, 0.11334056062985487, 0.05022610103215153, 0.07672870317778036, 0.12238063126996634, 0.09582633960305631, 0.06709534689928864, 0.07587440472429441, 0.10410882256266762, 0.12864768842549457, 0.16717058623728043, 0.09336665536483246, 0.13570434089253325, 0.39041635262250607, 0.39926239008044573, 0.42110237586996113, 0.42015635305608023, 0.40034333074112904, 0.4329537080512712, 0.442318953933035, 0.43220083799081443, 0.44293875949090267, 0.09481434102217678, 0.10018999396498507, 0.07587977158811587, 0.08459742559791994, 0.0954530056947378, 0.10320301692874945, 0.10121278548199386, 0.06234557596917656, 0.07861340134095884, 0.12722789249108557, 0.13839245688173518, 0.139717123130771, 0.15836470607558117, 0.1973609357506113, 0.1575865275295406, 0.1240148676525108, 0.12967431035718058, 0.18412915978961342, 0.22257179335683142, 0.2591978285712756, 0.28832063089134186, 0.2099140621620429, 0.2208444453338959, 0.32316871576854145, 0.2713950821699693, 0.34941424950582145, 0.3021491538784923, 0.1887945172526373, 0.2413877200753315, 0.227203813272848, 0.21324843552654815, 0.1739503921527652, 0.24405484700289115, 0.19675278034752253, 0.2514721824363997, 0.23589839191158812, 0.17480257770235053, 0.15827663374355905, 0.1682932833683548, 0.16814494170919114, 0.17405014032670751, 0.1695478115060276, 0.15075033004033644, 0.17895710208995985, 0.18329719306617953, 0.22878693733995914, 0.17796595685491978, 0.18343172565764676, 0.1709819322073325, 0.19538845850895514, 0.20233246999899523, 0.24226517243436096, 0.1965021567051637, 0.21963813144254118, 0.17301400873199835, 0.1467685043843887, 0.14876170132982514, 0.26509678318962326, 0.19280859568369435, 0.16621231093069222, 0.13989432824853776, 0.57112512520864, 0.6963664401147185, 0.5798684794201905, 0.49335628045595403, 0.5744543004730167, 0.38724876459364854, 0.18204364578272292, 0.2184853505760459, 0.13812274018900095, 0.25550181450868936, 0.43457102943056125, 0.19157788010660515, 0.18080919875726154, 0.17926685714639534, 0.16808216203392823, 0.16378395295218484, 0.1731116245238412, 0.16141240207133, 0.15666338548438707, 0.16351793320346097, 0.05988408526547628, 0.0771564447493418, 0.06472536723990219, 0.07446572681457597, 0.09238962610953894, 0.09812693359705738, 0.06820228370238235, 0.0642742249274133, 0.059521783529429384]}, "mutation_prompt": null}
{"id": "178d7330-f638-4a2a-9897-ade2cb302b70", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                neighbors = np.random.choice(indices, 5, replace=False)  # Enhanced neighborhood selection\n                a, b, c = self.population[np.random.choice(neighbors, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3 + 0.01:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity + 0.02 * np.random.randn())  # Adaptive CR modification\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced neighborhood selection strategy and adaptive CR modification to improve convergence speed.", "configspace": "", "generation": 76, "fitness": 0.21616056345867793, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "e633bb78-d5d0-4e23-85a9-a571d786523d", "metadata": {"aucs": [0.5878263631043618, 0.5663883736586887, 0.6201933029710416, 0.5258053468112364, 0.5383464387576495, 0.5573836163741639, 0.5753102715705307, 0.6153982846560648, 0.49564037932431704, 0.25149846252323804, 0.28444466313089933, 0.2805005154466661, 0.2722574041106455, 0.2242218283884132, 0.2991396948211472, 0.245190667508014, 0.2887581476543881, 0.3237753974253491, 0.09890985661917606, 0.13279673304574136, 0.10624063191341393, 0.12846885724634594, 0.10632568859959524, 0.11223704222711717, 0.11095431731380034, 0.14686261447895466, 0.13244448410436926, 0.0937195014622022, 0.11988814525921154, 0.11056598558471853, 0.10333515975953356, 0.06786820773639646, 0.12104387105797743, 0.12738316545878858, 0.1858079906627368, 0.11987964948576679, 0.9231651055089062, 0.8048875985220965, 0.8031315012059144, 0.924317086061526, 0.737250187227894, 0.09882310643712533, 0.7851849342381743, 0.919974210504325, 0.9438476419906893, 0.22689308884486958, 0.256049880292048, 0.1858276206570576, 0.21441800313346115, 0.1396491746790769, 0.24134082739050522, 0.19640945551898836, 0.25743027300592936, 0.25831887928747377, 0.21720555986620294, 0.30880808630364487, 0.20657145027598467, 0.33553585293248844, 0.6497296915622895, 0.27491499991532486, 0.6422490943615727, 0.29523302914290994, 0.2999728606523566, 0.13431503628854136, 0.1937492921716406, 0.1439017138155344, 0.069215222610441, 0.1418387753287279, 0.11470172630759568, 0.1354743377163895, 0.14957995258990053, 0.15082036792496833, 0.2149829081251995, 0.11662715355309283, 0.11199613656527851, 0.1451165106929, 0.14999512345501154, 0.10348688247044868, 0.10449956962611673, 0.011290601567908065, 0.11649259663779377, 0.04319385396786657, 0.07143015003827113, 0.08676127864905536, 0.12602866752901387, 0.03042962529497162, 9.999999999998899e-05, 0.027059525271880158, 0.10030469288776023, 0.020144548757354608, 0.05194379914934866, 0.11152338370655979, 0.20501510915289545, 0.12944640308416688, 0.06676179884501521, 0.07971379479035445, 0.19222303579503275, 0.1113582563967146, 0.07254883292177816, 0.05171878750697012, 0.04031497985567034, 0.11541892015744593, 0.10040705073940537, 0.07008566688465856, 0.09178399986854624, 0.05377893890447116, 0.09020475581411902, 0.08851935073828243, 0.14950786559955065, 0.1575823796915773, 0.08879830578008718, 0.1345297067187443, 0.1640324506330253, 0.149899239665775, 0.17121997986605197, 0.16248380004853913, 0.13116528409309014, 0.4288438272321079, 0.45984668139845264, 0.43698278783811706, 0.45276974196608166, 0.42462411069029293, 0.40725542916169266, 0.41446746539181967, 0.456629521689527, 0.4380963124706384, 0.07292785033091964, 0.09211959922290136, 0.12060625465596075, 0.06508081225319451, 0.06595256500118196, 0.0824546862748784, 0.11410012913458845, 0.08682663679440394, 0.08407368764491707, 0.09513540109202279, 0.08609370887012069, 0.12564127920761925, 0.09855305120391278, 0.10852972522114035, 0.12472910591617314, 0.08855799680085952, 0.14594863518502044, 0.11986974395009653, 0.23359950924474238, 0.28099268315616055, 0.2811444616481229, 0.27571645495026154, 0.2921860924873295, 0.2551260863264827, 0.21384030087060713, 0.27217780602713815, 0.2942395518037534, 0.2299761415614825, 0.16797320136882954, 0.19783017017531923, 0.18917559055609767, 0.16872733504310455, 0.19320028032924952, 0.21466289622360168, 0.24523450097732225, 0.23190937742816287, 0.19850445476827716, 0.16699575342018436, 0.13345086981341736, 0.20209791740192173, 0.14046747703382967, 0.17121578789931868, 0.16904481950822914, 0.16902196972711203, 0.16306783892998866, 0.17198746326180425, 0.17393945413514322, 0.19696173488777202, 0.20806616923276067, 0.1706704437630162, 0.18946240786200952, 0.18428110078107507, 0.19372233985527088, 0.19258024622081904, 0.1534274166341305, 0.12183486026366086, 0.13789766197220654, 0.166315897865547, 0.1925190767564955, 0.15898242783576966, 0.6664112933572626, 0.1564723920343991, 0.23265542454988242, 0.20602801923828973, 0.20284553578171016, 0.1402154148125504, 0.3895894061283901, 0.18838340428174039, 0.11845402116522197, 0.1916207967883724, 0.17177344365433944, 0.188247273356979, 0.17109083818073179, 0.15772520077272234, 0.14763022729676545, 0.16900641732264232, 0.1669948374403133, 0.16499100091790408, 0.24426635630957205, 0.14966059706375323, 0.15637022104479348, 0.06084315555454689, 0.06818464151302672, 0.0625145285264731, 0.06650453535696177, 0.07342798281194463, 0.06096805328932986, 0.05980090804919114, 0.04987409097749296, 0.07771452686793001]}, "mutation_prompt": null}
{"id": "79edb7d3-25af-4124-bc6b-f21bf92d1ef7", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3 + 0.01:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                # Modified part: Adaptive crossover probability based on success rate\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)  # Added adaptive adjustment\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced adaptive crossover probability based on population success rate to improve convergence speed.", "configspace": "", "generation": 77, "fitness": 0.23231333887932468, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "e633bb78-d5d0-4e23-85a9-a571d786523d", "metadata": {"aucs": [0.5882857724994897, 0.5706621032493737, 0.6089607733197808, 0.5808964889179936, 0.5713539482490988, 0.5258748015837797, 0.6117079036580465, 0.5056003403876288, 0.539784378782628, 0.31172939592889715, 0.22991156997679618, 0.3135095525908492, 0.22968644420017725, 0.07512684599379205, 0.2636829870463382, 9.999999999998899e-05, 0.29607381585761783, 0.32372468318281944, 0.1674426865723595, 0.13448062077462786, 0.11904320442117133, 0.09802283045578375, 0.13408549606463893, 0.13020122515841936, 0.10162860875537572, 0.11244029580190196, 0.11281036216246598, 0.0888361433834769, 0.10023294360046697, 0.08111055143880008, 0.11067247502210897, 0.09222838558270907, 0.10730467291540846, 0.10183416069043838, 0.07711140204366607, 0.09929389806332933, 0.9110320533106557, 0.9026824957181843, 0.9126505653396296, 0.7704015730876834, 0.8539899351696882, 0.8966280554935893, 0.9017474347740269, 0.9166241350943086, 0.9309568341387969, 0.1821486269400453, 0.227919487869933, 0.2686043693454514, 0.2922732486948688, 0.2752009061995456, 0.13655100929905917, 0.29739820450887977, 0.24808698006276753, 0.23947921082511126, 0.2050820196031814, 0.30003074906353855, 0.2967618630389107, 0.30136389597986946, 0.1927906608993155, 0.60273979951592, 0.20822376840305512, 0.2201967763253352, 0.29358062793854833, 0.1340153221587692, 0.11553157606703512, 0.1352626537802214, 0.12955415634380607, 0.19372277757143852, 0.12270875226887223, 0.3060255773070414, 0.13095621986673212, 0.15947448369380923, 0.1084906436855787, 0.09703889922944164, 0.10686813420045926, 0.1298479430741094, 0.1454061599883153, 0.14846162131287088, 0.11870065575503452, 0.16316618149581086, 0.12198726602916432, 9.999999999998899e-05, 0.04218503328952228, 0.04725630515727919, 0.04658203260705873, 0.09277517842136274, 0.12258270146870198, 0.031028228137473524, 0.01665565062348273, 0.03559949064189549, 0.18637993422047894, 0.15336782411845684, 0.08827485681099911, 0.16739732755565073, 0.06363580736303154, 0.0743937168369152, 0.2081414895493081, 0.11652808727720443, 0.10676414145705526, 0.027313172191048785, 0.034933453988578944, 0.044286628707755904, 0.05402548448038069, 0.0484590309069064, 0.08823921481172203, 0.04811553131671553, 0.07945607723628878, 0.10850765627457082, 0.1483899487906547, 0.13456742538057764, 0.16829487989807435, 0.14778413189921047, 0.17124353861350305, 0.13922009844473449, 0.08534874743825038, 0.1255327555606367, 0.14474953957732162, 0.4509399130205086, 0.4775772235559962, 0.45596388479648753, 0.4129010621427983, 0.4383603463413267, 0.44226103924700044, 0.513562691365931, 0.45664195406105823, 0.44676040275763773, 0.07670638447168765, 0.07161595644772711, 0.08160412772761305, 0.08193542745097437, 0.08164784601586905, 0.0971816081502056, 0.09124147190899656, 0.07740922778618353, 0.0820349274316059, 0.12440934703072604, 0.13665693176391036, 0.12560419879378837, 0.11488328909107526, 0.11755121910586408, 0.1349794513740208, 0.13560894481281116, 0.1529361427072008, 0.11569750865509143, 0.27008045106189116, 0.26297597100432235, 0.292016243831283, 0.2819380750716842, 0.3051293760032472, 0.2798735936681347, 0.3293873705061293, 0.3079040617336869, 0.32704652128466905, 0.15845491970637382, 0.14783729887651076, 0.23508686364763132, 0.22682642541678766, 0.2342157110175782, 0.21963677683804894, 0.20732153613465554, 0.2057448865823871, 0.2246927898922555, 0.1917443874902559, 0.17241137131704598, 0.18999771548439826, 0.13336411610159138, 0.20541653478446031, 0.1664575900841292, 0.18252300037869051, 0.190587881112544, 0.17886103296887812, 0.1847439419808954, 0.17323446899151496, 0.19331414052763174, 0.19289281095548572, 0.1989416895107874, 0.1616894457377973, 0.17608295390084383, 0.2185967394786429, 0.17339060269974105, 0.5927611036736217, 0.35657520155389233, 0.1479661873473629, 0.7574729914414591, 0.7047258415892638, 0.1862258726465542, 0.13782890309500584, 0.16299341582931848, 0.6401986848562596, 0.664684853611266, 0.2036040183469121, 0.4134186923206872, 0.41326373264671, 0.1638057411155227, 0.1456515066202454, 0.198115023687634, 0.18795053182826826, 0.2623069836627443, 0.17436151583016812, 0.1593083175725476, 0.17631924300825774, 0.15455676408060737, 0.17344565057763572, 0.16521492042262909, 0.15506674034886347, 0.17896925244158046, 0.18649072234174424, 0.0682822984200735, 0.06467398039924188, 0.06736515870328985, 0.05213744074490767, 0.06266610811536577, 0.09172683525808278, 0.06673621895251891, 0.07756920822462254, 0.1042185129690828]}, "mutation_prompt": null}
{"id": "fe932906-1c0a-468f-962e-c0d97024cb6d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                # Modified part: Dynamic adaptation of F based on population diversity\n                population_diversity = np.std(self.population)\n                F_dynamic = self.F * self.weight_decay * (1 + 0.30 * (success_rate - 0.3) + 0.04 * population_diversity)\n                if np.random.rand() < 0.3 + 0.01:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                # Adaptive crossover probability\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance convergence speed by introducing a self-adjusting dynamic adaptation mechanism to fine-tune the mutation factor based on population diversity.", "configspace": "", "generation": 78, "fitness": 0.2274970331615473, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "79edb7d3-25af-4124-bc6b-f21bf92d1ef7", "metadata": {"aucs": [0.6074925957845355, 0.5480076960902605, 0.5706929723884842, 0.49147092636729994, 0.5124762114348544, 0.599679559149395, 0.5713728318919713, 0.5588591028867924, 0.5489454844106034, 0.24972957085055958, 0.23152316608862467, 0.2793078170846788, 0.3066112767890792, 0.16840861406376695, 0.3588852008972405, 0.2640269514956364, 0.2860244230413215, 0.3060432329988386, 0.1130668778317977, 0.14071783316338382, 0.11427566261590838, 0.11482874266176135, 0.0826840545232651, 0.16337276559481273, 0.09257110976018923, 0.15183509705171583, 0.12365484272364724, 0.07475082864772542, 0.12237661620887996, 0.08797699750377064, 0.0968278517890292, 0.11001800496704384, 0.09920485014594682, 0.07870633958513995, 0.08945813008128356, 0.10959829799862131, 0.8848602610930774, 0.8394810083159125, 0.8975357749312606, 0.8351784761069528, 0.8707221248398314, 0.8947322541364483, 0.907400797821639, 0.8611616744980909, 0.9345997983619846, 0.15620192160480106, 0.3222377972671666, 0.2012814732686783, 0.22238854944131026, 0.1418662216340303, 0.2298193183806314, 0.21759187847848327, 0.25011773650746916, 0.26211502741554027, 0.21495750800326252, 0.47862262967508684, 0.2089979284807041, 0.20441014908170851, 0.19158537620073934, 0.19289154718074808, 0.30384301952015447, 0.21544318542556073, 0.6255529862236907, 0.14063102555448004, 0.11232639771871877, 0.16698047739016875, 0.12653343266220995, 0.12065511123447903, 0.1352600365330192, 0.14182908875365485, 0.15021360026591535, 0.15834756592408483, 0.1215579142054296, 0.1452298546262899, 0.11938282134978129, 0.11142684482591247, 0.11481182525485512, 0.13902722354275043, 0.17037782867963125, 0.17024437572153672, 0.1203661745871345, 9.999999999998899e-05, 0.06500909778022412, 0.0691173091386389, 0.012290545390080676, 9.999999999998899e-05, 0.09320314969044574, 0.07791981670239767, 0.04317562948216369, 0.07013580605161973, 0.03844149395248919, 0.04686742651890052, 0.04078083403796939, 0.1548108003144102, 0.09011543618076556, 0.07791292132227323, 0.08343063058480837, 0.1580877869888867, 0.163804004403454, 0.036634528644615916, 0.052003263146945033, 0.0935486509115423, 0.14320443759809964, 0.06244489678309151, 0.054910832288504574, 0.07130100942124484, 0.03636393028669549, 0.06950484671637824, 0.14216417874951226, 0.12360482884346058, 0.16181063965654008, 0.14944441862092006, 0.09975967426471455, 0.13451222400607543, 0.0820876732921153, 0.11818436940986288, 0.12314015342760831, 0.4300030775254431, 0.39462591308697603, 0.44868748944633974, 0.4541333472293312, 0.40037416600040765, 0.41295453222937917, 0.47972362050511397, 0.4544883135586786, 0.4286351865740984, 0.10868581317971093, 0.05718319972040786, 0.12336120752543434, 0.11746400656502543, 0.06066554172558647, 0.09508274216786938, 0.056688504242347504, 0.09944710117556554, 0.07951706077525034, 0.1168926759342247, 0.17266843507578067, 0.11842175776968311, 0.19866013944278882, 0.14668815300205063, 0.13699541024853168, 0.1068053517493377, 0.1268115219954309, 0.15326086369104974, 0.25741075736906693, 0.25192396407833706, 0.21615153046826363, 0.2770375847844897, 0.32099327540155853, 0.29102685956052143, 0.24338893319541932, 0.2233824853642724, 0.276530986106889, 0.24462027867212677, 0.22247445300634094, 0.20147357846185887, 0.1260094998206096, 0.15924743363730343, 0.2582285865935541, 0.15704549212821184, 0.2312996922297752, 0.2673738889106191, 0.1749990197242951, 0.14170128626701517, 0.16732318938213941, 0.1710172650972681, 0.1615033676371268, 0.18113625751474982, 0.1708120080626735, 0.15942222580415133, 0.17512641655552252, 0.16926374384711618, 0.1848110843845271, 0.18480094453680063, 0.18251288643537522, 0.2203739297912779, 0.21784287460675733, 0.21382692572951267, 0.19317262227675558, 0.18448650912023357, 0.1873439786948472, 0.1649777032978993, 0.5602947861299361, 0.6962196682338969, 0.15026192018723628, 0.17566191918100615, 0.166635055788401, 0.5894030888567076, 0.6457068986319756, 0.2933858085646759, 0.1627879767491851, 0.3955355934632063, 0.6679653826910897, 0.15737660419293265, 0.09495110644637461, 0.19387171809966264, 0.16829403058329462, 0.6668590212821153, 0.15468613682209942, 0.19568607220516343, 0.16634357514038078, 0.18109835639724947, 0.16750950263541486, 0.16044705822090422, 0.1527112651640915, 0.16861437101925836, 0.14689007985489466, 0.06509482880834327, 0.053197401143091905, 0.05517776980569966, 0.06652463784692098, 0.053523642572776975, 0.06215713692274405, 0.066580960571888, 0.05968515278728048, 0.07101418129687609]}, "mutation_prompt": null}
{"id": "ebb4b68a-1146-4c8f-9023-d22bcf11e81f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:  # Adjusted probability for adaptive scaling\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced adaptive scaling for mutation factor to enhance search efficiency.", "configspace": "", "generation": 79, "fitness": 0.24065091659083723, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "79edb7d3-25af-4124-bc6b-f21bf92d1ef7", "metadata": {"aucs": [0.611826901416435, 0.5664017119030765, 0.5798624650410489, 0.5474538339275943, 0.5387124563558152, 0.5034704199766261, 0.5530023265659592, 0.5703621871754108, 0.5048067751810327, 0.2354019947921594, 0.24007413952033885, 0.34674033310992636, 0.17321006361322688, 0.25580394946358176, 0.17925654862534335, 0.25916064537039507, 0.3232713300442669, 0.3169881204464188, 0.07995068741790223, 0.0995612571029878, 0.12714347559124994, 0.0942387746454062, 0.07231253829380568, 0.08958203395921738, 0.11384474447997817, 0.12439932728144143, 0.14318140267743784, 0.10290126685941692, 0.10387461889778116, 0.08402647879212377, 0.08057579997474928, 0.10580873370054544, 0.09763661612287633, 0.11337751863096168, 0.10599394502635695, 0.09499858093601965, 0.9216394760622905, 0.8434824271241788, 0.9218073914704191, 0.8845394700490784, 0.8685545523630019, 0.9120196668717792, 0.8625055328208134, 0.896548380557474, 0.9797559896482724, 0.06996793999284023, 0.24771659700248705, 0.2599025103461198, 0.27754111288700833, 0.2847291112361582, 0.2501087665942635, 0.25507774730362154, 0.22470216210386185, 0.27255825488146723, 0.53413118989001, 0.42364839991376735, 0.5492266051944432, 0.7418155373936235, 0.57791056553589, 0.28674496486646506, 0.2776455527119479, 0.33639667166507337, 0.3268846899886195, 0.14411372768652508, 0.12737059479432844, 0.15691984771134937, 0.12891032491735244, 0.15469046012180665, 0.1547038035945365, 0.14618297038386485, 0.11055769769225843, 0.13392098529692398, 0.1814399246069356, 0.18461724866993678, 0.09268131471103624, 0.11012782695043477, 0.09455126376448497, 0.11230417853778052, 0.11618716889783032, 0.16245653181719777, 0.09656375475355727, 0.0406178180813902, 9.999999999998899e-05, 0.05402327723416889, 0.013979184842691228, 0.10937010751629728, 9.999999999998899e-05, 0.03310779537260766, 0.0785310652930975, 0.034257507030060474, 0.15898215096537482, 0.10379010649689213, 0.18269686045137046, 0.14735352709425475, 0.09803269963878669, 0.09052370385661002, 0.16598983800225375, 0.14301433719945145, 0.24588766654274352, 0.06022836511320462, 0.0251952889956365, 0.03255026621466384, 0.048537625530215345, 0.06794260428392063, 0.051650650347251914, 0.04518378731349726, 0.07427404198506504, 0.06507302512073276, 0.18102165215725918, 0.10015048672788529, 0.14276033543623257, 0.16726571385719102, 0.14349133641326628, 0.12913421272771197, 0.1311573405457741, 0.07215773768060918, 0.08799279192219833, 0.46314737447593013, 0.43749451422021124, 0.5089590142723984, 0.544595256658843, 0.4203257573099676, 0.4499652674016982, 0.47380669285890986, 0.4025620888381457, 0.45326529541544236, 0.0676965484164399, 0.11480491943659776, 0.07203754204879531, 0.08121562740504085, 0.0865803992905021, 0.0965622012448828, 0.09101933255336225, 0.1268170793843787, 0.09416484299865968, 0.1665739860683949, 0.12287550387582946, 0.1184217577696689, 0.09855305120391278, 0.10852972522114035, 0.10086134521181522, 0.1424679822222401, 0.19782127640443092, 0.14255755861941144, 0.2918524509312356, 0.3067405322582657, 0.3063124341350998, 0.2851542328608261, 0.30412694611439617, 0.2589953552061164, 0.3276646625765195, 0.2561825420310554, 0.2807256992579369, 0.19421323902940024, 0.20010049075036063, 0.25098196099552916, 0.20944863515508683, 0.15919693956045633, 0.1933600835617103, 0.18651062885606573, 0.18343006637759673, 0.21618053232356205, 0.16650900869161178, 0.19733776908121592, 0.1834004755538714, 0.14493761263396376, 0.1782348051631436, 0.1757822499595757, 0.17628701831145333, 0.17563527783859356, 0.2005920017856443, 0.1778513165140484, 0.2030988779165207, 0.20364933014534004, 0.18316739775769475, 0.18469412430507293, 0.156243788204542, 0.1710887826796883, 0.18189306730789667, 0.17588037283084357, 0.6207581833961419, 0.14957461451612963, 0.5918755828449795, 0.636030843173427, 0.6573478634287246, 0.4215029314752504, 0.12434461618224046, 0.16094755703121788, 0.6560546568768977, 0.634534980735806, 0.20223235170683118, 0.6196280417410566, 0.5772759727358483, 0.15959700431935797, 0.19063903878643929, 0.10481250339272974, 0.1885290068371197, 0.14132096795634064, 0.22165822455101358, 0.16726192607425505, 0.16821839056355714, 0.16097414074556327, 0.15139548149897164, 0.1735253884616279, 0.1708630855029909, 0.1697489556228633, 0.1619880112170764, 0.0683358072916308, 0.07859924188769496, 0.05612284233434717, 0.04987479612897405, 0.05863245772631709, 0.07065528948879696, 0.07919192626670823, 0.0713272053882934, 0.07287564395222779]}, "mutation_prompt": null}
{"id": "e5f54b7a-38df-4a3e-a67f-296e5934e2c0", "solution": "import numpy as np\n\nclass AdaptivePopulationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * self.dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.8\n        self.F = 0.6\n        self.min_pop_size = int(self.dim / 2)\n        self.max_pop_size = int(15 * self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        \n        while evaluations < self.budget:\n            if evaluations > self.budget / 4:\n                self.population_size = max(self.min_pop_size, int(self.population_size * (1 - 0.2 * success_rate)))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * (1 + 0.3 * (0.5 - success_rate))\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.1 * np.random.randn())\n                CR_dynamic = np.clip(CR_dynamic, 0.2, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.8 + 0.2\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.8\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.2**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "AdaptivePopulationDifferentialEvolution", "description": "Introduced dynamic population scaling and self-adaptive crossover to enhance exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "ebb4b68a-1146-4c8f-9023-d22bcf11e81f", "metadata": {}, "mutation_prompt": null}
{"id": "bb516da6-fc7d-4bef-8671-50d6249cf367", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        success_history = []\n\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                \n                # Dynamic mutation step adjustment based on success history\n                if len(success_history) > 5:  \n                    recent_success_rate = np.mean(success_history[-5:])\n                    if recent_success_rate > 0.3:\n                        F_dynamic = self.F * (1.2 - 0.5 * recent_success_rate)\n                    else:\n                        F_dynamic = self.F * (1.0 + 0.2 * recent_success_rate)\n                else:\n                    F_dynamic = self.F\n\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                    success_history.append(1)\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n                    success_history.append(0)\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced dynamic mutation step size adjustment based on historical success rates to enhance convergence speed.", "configspace": "", "generation": 81, "fitness": 0.22557410296970165, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "ebb4b68a-1146-4c8f-9023-d22bcf11e81f", "metadata": {"aucs": [0.584229510342736, 0.5158223850914175, 0.5940934215528973, 0.5695297796018173, 0.5252446736130523, 0.5480308364728315, 0.5559851220417167, 0.5538224231305371, 0.5418974183266583, 0.3119388047458205, 0.3057961145575582, 0.2655011642368983, 0.2859125938547874, 0.22659298975755848, 0.26041363705837794, 0.10595988799841383, 0.3307908906949717, 0.31871282894694364, 0.10485843412324425, 0.12176541568169852, 0.11419472729506797, 0.11679910620742362, 0.13796926688453137, 0.09122541223399372, 0.08171983581986353, 0.11060716564849915, 0.29102395949514326, 0.13985252069297527, 0.11755229562923941, 0.08879992793443758, 0.0817468768960603, 0.0935237006555546, 0.09350636277887969, 0.11180247612983307, 0.10040062137043892, 0.08955220814280362, 0.9471144075690695, 0.8608736604460481, 0.8756708682319981, 0.9130237733232334, 0.8922786350973884, 0.9042420572835549, 0.8465298630325236, 0.8967173947912301, 0.9797470590786037, 0.07007157058126434, 0.25843065794207076, 0.24565591090580063, 0.30039594490075894, 0.10600059064574885, 0.1416236213893386, 0.25808319207817, 0.3059238664652931, 0.20814725213659713, 0.28504015870826427, 0.19423740335860185, 0.6253961699530046, 0.32535557502671664, 0.6063055753716755, 0.6036852204115347, 0.5231214107808138, 0.21123806693005132, 0.436865764705074, 0.14493797395688068, 0.1360603908003044, 0.13169214422958453, 0.10972487009328902, 0.2632076309468272, 0.11698131400352707, 0.14705325138666614, 0.10884237448659895, 0.31022315841814396, 0.18114675265207303, 0.14381627292017607, 0.03921935750444683, 0.14337475476465866, 0.13338753948805893, 0.1404578408602798, 0.1102350778961505, 0.10434628129859824, 0.11327786058204015, 0.030407166089675086, 0.07567672164867512, 0.05893725114530246, 0.01763024947595282, 9.999999999998899e-05, 0.057700904564115585, 0.0010813708967274405, 0.054504964356509644, 0.11169754001323473, 0.145944084425511, 0.14584929751230125, 0.15908716463789918, 0.146754989352337, 0.09667320804280155, 0.17142585825723433, 0.059369123865251616, 0.07698363485877069, 0.09006946035553487, 0.026312001762505477, 0.021956998121083204, 0.0526165545710513, 0.11191226039910585, 0.051874506324613545, 0.05336666475894092, 0.09834104144819189, 0.07427565422309834, 0.052663389789574855, 0.12361839127583518, 0.0415736604540099, 0.0726796239258174, 0.11896801836196591, 0.17987917252772345, 0.13509350469688286, 0.12289294287916475, 0.15369109855884822, 0.13906461496434475, 0.44600029668707597, 0.45780293541087325, 0.45188542469277715, 0.4973698011142379, 0.4175939154748993, 0.4444291842078927, 0.45634814501112253, 0.40788123101323415, 0.4168719369571465, 0.09912310299087967, 0.08186488856734575, 0.11080699930559823, 0.10302971787900495, 0.07956812487590015, 0.08437217635505967, 0.06559813635558953, 0.07732329370877555, 0.08079769164118789, 0.17159014794922534, 0.19574644816797804, 0.1184217577696689, 0.19549138790205445, 0.17455334600770311, 0.11603291973322516, 0.11120333595208065, 0.10387719724966482, 0.14212316781663958, 0.2503222678307979, 0.2660396757529171, 0.23628933447805733, 0.2781873108669086, 0.22320627002633442, 0.2463941646047897, 0.2685903632881258, 0.3544589918768327, 0.3192997195290209, 0.18559584736038737, 0.2370293579179985, 0.18317441733136153, 0.22762838341604075, 0.18357832496481497, 0.21271388494919785, 0.17283281102053893, 0.24877154992026995, 0.21278316215266002, 0.1866016961119319, 0.15528129195438856, 0.16408177477532337, 0.19350522095461742, 0.14356787133504934, 0.1611196007423057, 0.17301473292421166, 0.19417615610897376, 0.15365554827807115, 0.18972752873666454, 0.1795749516708396, 0.17698623846217743, 0.17477452769878654, 0.20495850490971457, 0.1694385379137513, 0.21926698366260622, 0.17906553807004455, 0.17834778377023575, 0.1790167604336239, 0.1204724599831043, 0.5851072768378107, 0.1554671700640654, 0.18958154553551854, 0.15490590266141613, 0.11112623075378047, 0.1624046369470763, 0.30395797255959467, 0.15847097518112985, 0.30558053739176216, 0.3567747487647662, 0.15441595458318313, 0.2903614923855501, 0.1990733536110838, 0.12025707088218318, 0.1954134605414376, 0.21836293661728834, 0.21658393831293898, 0.18212425532649945, 0.1640962136471399, 0.1924901414346647, 0.1691015170522584, 0.15308196777505856, 0.15411491824861623, 0.15380746513545362, 0.16379729880617977, 0.05491568702205529, 0.0547107257049263, 0.06508130397270306, 0.057717149644054944, 0.07881776984357147, 0.05309918340342734, 0.06748298409451015, 0.07300068593801368, 0.07987711257750374]}, "mutation_prompt": null}
{"id": "b6401327-5fc6-4a6a-8fd4-75e88338a6b1", "solution": "import numpy as np\n\nclass DynamicLeadershipDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.85\n        self.F = 0.75\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.95\n        self.leadership_prob = 0.2\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.7))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite_idx = np.argsort([func(ind) for ind in self.population])[:5]\n            leaders = self.population[elite_idx]\n            elite = leaders[0]\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(leaders, 3, replace=True)\n                F_dynamic = self.F * self.weight_decay * (1 + 0.2 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < self.leadership_prob:  # Leadership-based mutation\n                    F_dynamic = np.random.uniform(0.5, 0.9)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.2 * (success_rate - 0.4))\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            self.population = new_population\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.2**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            for elite in leaders:\n                random_idx = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_idx]):\n                    self.population[random_idx] = elite\n\n        return self.best_solution, self.best_fitness", "name": "DynamicLeadershipDifferentialEvolution", "description": "Introduced dynamic leadership selection and elitist crossover for improved convergence.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "ebb4b68a-1146-4c8f-9023-d22bcf11e81f", "metadata": {}, "mutation_prompt": null}
{"id": "9517d690-2878-4d90-a250-0392bb16cd74", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                \n                # Dynamic adjustment based on evaluation progress\n                F_dynamic *= 1 + 0.1 * (1 - evaluations / self.budget)\n\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced dynamic mutation factor adjustment based on evaluation progress to enhance convergence speed.", "configspace": "", "generation": 83, "fitness": 0.2292198375823268, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "ebb4b68a-1146-4c8f-9023-d22bcf11e81f", "metadata": {"aucs": [0.5647044084282664, 0.5012805222261902, 0.5605721833068413, 0.5711479912866184, 0.5184379079444702, 0.5166329012216686, 0.5930663147823093, 0.5109258785247139, 0.48655738921681746, 0.214883725029691, 0.2821223502716168, 0.25122444173749725, 0.2447093918225851, 0.1501161345319466, 0.25656985486780937, 0.2318579050641718, 0.24305351479255444, 0.31184235682095773, 0.1324665413128141, 0.08854269109942525, 0.1170325419940087, 0.07777975010455429, 0.12806984216500206, 0.12622508048178693, 0.13256713657135077, 0.1068901453629334, 0.07915224835978008, 0.07014527091926681, 0.10167306455608627, 0.12366460204890284, 0.10272157341176513, 0.11938633200187942, 0.08932175104140183, 0.10550958772443997, 0.09277007035719276, 0.058308406078089514, 0.9149414369031637, 0.9223721327185656, 0.9221192747205419, 0.9275983124635231, 0.9135294730070798, 0.9055485747011893, 0.8897486950818793, 0.8863300663651593, 0.9797474627646043, 0.06968944159570933, 0.2146195372659424, 0.21137385352486748, 0.1368689504830638, 0.08398373265189052, 0.23522352243548772, 0.20166667058413623, 0.2152637296687746, 0.22790373241191575, 0.6724612715903152, 0.2821676407828928, 0.48529414851139896, 0.4733581961631159, 0.341790390237237, 0.22940182860434344, 0.5828832866008868, 0.4805568365913411, 0.5312017613658839, 0.14930177139877887, 0.13373878872410916, 0.11032078862480577, 0.09166075951779162, 0.2101854543913082, 0.10301601293364204, 0.15771591126927542, 0.10542333356903832, 0.11286128629624159, 0.15994846685768793, 0.09353596026939703, 0.00924697447384637, 0.12869161842010268, 0.13483625292484558, 0.1295527041858754, 0.12942876084174004, 0.12710874063188116, 0.11292113491258915, 0.01075173953283115, 0.04177704449686248, 0.10336534347698745, 0.04912584776497675, 0.0768191276396708, 0.060662603788598224, 0.02001338216923465, 0.023150346365567342, 0.06510272697411368, 0.15291662956156737, 0.0952984495642506, 0.07845564368413704, 0.10053038138216852, 0.1186442572434857, 0.031110177295241792, 0.17779859931807185, 0.16521029462526293, 0.1385067937517066, 0.03389627408053475, 0.07695603039251309, 0.026122582018637708, 0.05001684334594847, 0.06685813646081151, 0.09947107722127513, 0.030932609629576113, 0.03055982807405422, 0.03705937686708749, 0.12830889148495406, 0.11462228017178044, 0.11966526731394311, 0.12234298355691442, 0.1434595721968539, 0.13317362831620871, 0.12292524957983442, 0.12988389745005025, 0.11745587029135274, 0.48206956928107625, 0.4340494254919379, 0.46644812556970594, 0.4428626177160899, 0.38278470270556486, 0.406397482797354, 0.4722370839830775, 0.4363103507634214, 0.40796937417164514, 0.06038072597713451, 0.11020116579718198, 0.08541466805876008, 0.0957663925854384, 0.08252572261565638, 0.08002081170703967, 0.12369064621575543, 0.06074269690854217, 0.12116580491605056, 0.09364797626900911, 0.1641324283043687, 0.1184217577696689, 0.09855305120391278, 0.17687847644898536, 0.1933863105318434, 0.09584271092271734, 0.09872016509081438, 0.14581213580988261, 0.26174285724955515, 0.27833639610294136, 0.2911987876839409, 0.24780203335962803, 0.30879934897798955, 0.2932270134779441, 0.2988175125395828, 0.2912645646299349, 0.3028418874656963, 0.19651351752359136, 0.20303324115370847, 0.194094406374688, 0.2124345915346031, 0.22146994432957412, 0.1577353707213499, 0.21510104077773895, 0.19736133476805817, 0.22130377510747734, 0.17969618037056223, 0.19248036131639235, 0.15750892036373787, 0.15196944045804028, 0.16176605886769868, 0.18483774810636222, 0.16427602080269899, 0.16833851799693877, 0.19789123602318937, 0.17871034718506962, 0.17674694326497886, 0.17089452096912883, 0.17298525796095676, 0.1791312017088409, 0.16996314927202216, 0.19545803744581058, 0.3058393121367454, 0.37369805567591585, 0.14498495861229532, 0.16370376074165904, 0.6626158664228189, 0.5532928987792164, 0.16891614972814206, 0.19097251689424322, 0.13966328449404208, 0.15645480543099843, 0.19909473246278342, 0.14638160039154868, 0.19906656770750153, 0.4126053820554053, 0.23429375967582577, 0.20177365212666332, 0.528632589682708, 0.17844096979839508, 0.5026866095714388, 0.6671200631443353, 0.1789909727599881, 0.19031277782842537, 0.16747554704399426, 0.14745260233547286, 0.16293994154374558, 0.16338243953089404, 0.17259314298175288, 0.1823972668248136, 0.16800907654761543, 0.0771639353257233, 0.06439263603555923, 0.05153659224545193, 0.07186248089988545, 0.05217385405816677, 0.0796692767488636, 0.07143206346006503, 0.07234830032648765, 0.08293025565760359]}, "mutation_prompt": null}
{"id": "e2e4ae1e-758c-414a-a8f8-6e477af4ae72", "solution": "import numpy as np\n\nclass StochasticRestartDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.8\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.5, 1.0)\n        self.weight_decay = 0.97\n        self.restart_prob = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if np.random.rand() < self.restart_prob:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n            \n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite_index = np.argmin([func(ind) for ind in self.population])\n            elite = np.copy(self.population[elite_index])\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F * self.weight_decay * (1 + 0.3 * (success_rate - 0.3) + 0.1 * np.log1p(success_rate))\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.2 * (success_rate - 0.4) + 0.1 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic, 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "StochasticRestartDifferentialEvolution", "description": "Introduced stochastic restart strategy and dynamic parameter adaptation to enhance convergence robustness.", "configspace": "", "generation": 84, "fitness": 0.13590032331680474, "feedback": "The algorithm StochasticRestartDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.16.", "error": "", "parent_id": "ebb4b68a-1146-4c8f-9023-d22bcf11e81f", "metadata": {"aucs": [0.21947668445620938, 0.21216982701064313, 0.2599956501463644, 0.284445192681579, 0.2267994975362907, 0.24028230103415016, 0.25160101026415105, 0.17911428314951494, 0.24750770030938507, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0028632709155995695, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03139605340245166, 0.07501309487028829, 0.05434376749835812, 0.06673424518729354, 0.06965983010464627, 0.05616597562266612, 0.06818322370950392, 0.053280394601701864, 0.0691692691794853, 0.07113467814714991, 0.06633709799099685, 0.04548928317553147, 0.04650849339464824, 0.056650172113911657, 0.04864511500225088, 0.054016099556635666, 0.050458198601199156, 0.04380976050432617, 0.04982097468127722, 0.9263219861328004, 0.8383151848558267, 0.8825567602214779, 0.835914497371234, 0.6206800597035371, 0.8815232142487746, 0.9239808420563916, 0.7935768880288903, 0.8318014201025947, 0.08870209430145948, 0.09355071463445097, 0.08064321034718958, 0.0866707124617857, 0.08493408745044528, 0.13101682854423757, 0.10086256170974373, 0.0927799765580134, 0.08796373946590008, 0.15702187789911937, 0.12436127405724351, 0.14310631019371323, 0.1501640507393993, 0.1381532061351367, 0.17392134509956048, 0.1843896283520513, 0.16794822504728113, 0.15846947969807812, 0.04557106074225792, 0.048121337379609, 0.05563554263078219, 0.051445107329461504, 0.03855245436781862, 0.03712751931514868, 0.07438644029686825, 0.015998715308814693, 0.02342619229557663, 0.0776145587259347, 0.04059863414013121, 0.03349216173130953, 0.08343311896498895, 0.021984492258742105, 0.03733213709066929, 0.06846350792109479, 0.019157916000405617, 0.08043403384213854, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09184203661218049, 0.0540615111823467, 0.060129706970584396, 0.04792976661522552, 0.04783193591854906, 0.09481785007089727, 0.05888220009524936, 0.06296784192674332, 0.06885625614044566, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02285296015086402, 0.005641357009823933, 0.011891543188467635, 0.03553799832817184, 0.0038664816296731797, 0.02010320859043091, 0.01106208115326568, 0.002816766816291061, 0.020360042728232997, 0.22832430623803635, 0.22678151879889163, 0.24387942439661836, 0.2753615980228662, 0.22741270662030533, 0.28223814394817726, 0.2627301576608576, 0.22862711891245935, 0.22884843419143208, 0.046334266849729966, 0.07685911207670526, 0.06284160461054922, 0.07467596876986549, 0.05732009702269547, 0.07563649125907812, 0.05521075914023399, 0.04937466390160039, 0.07396668814628826, 0.1279268525652878, 0.14900718995878903, 0.17985301827712574, 0.11734856113089298, 0.13803821973500785, 0.1343027346765583, 0.13054242639870517, 0.14593483914043404, 0.11323525053732741, 0.19399285413498002, 0.17642277613521218, 0.2149508177542433, 0.19641537616013616, 0.1799523253536599, 0.17713798046171092, 0.19423062267881397, 0.17523977849417183, 0.17510137429684458, 0.15041572676834059, 0.10866696819328281, 0.15494957467025883, 0.13584441384642176, 0.1281489125264197, 0.1276544041187433, 0.11242628248213093, 0.11021286811157838, 0.13989046584239784, 0.15986636897187467, 0.14692493792409478, 0.1592092716408371, 0.1590174912962743, 0.14600942163965702, 0.17937807781787118, 0.16183567506926833, 0.15141654117088277, 0.15251922216963498, 0.15639923623998997, 0.1468319723196051, 0.1518188551556504, 0.13336672583381937, 0.1599282556559658, 0.15351057554039615, 0.15513419119345362, 0.14816807034884294, 0.15375046550687932, 0.15206682213503642, 0.16790700969601935, 0.16784710436169425, 0.15198239313823192, 0.2713436623854363, 0.166366677237912, 0.1378700678971403, 0.1508764197454846, 0.17700167528742006, 0.16452139602093196, 0.15603681795396518, 0.21532755590580555, 0.1740848668726256, 0.1524507902861726, 0.13883585092285156, 0.14102202496550287, 0.1645040494504939, 0.1954677459851486, 0.16814029807198239, 0.16918379079952905, 0.1829854658199772, 0.17028283482251627, 0.1883929506669898, 0.16438289039618525, 0.17766244400904396, 0.17767000004228484, 0.1996588226963607, 0.056125333500909425, 0.06704464795302434, 0.05140060619463549, 0.05405377608803652, 0.053943527468912955, 0.07046621681258569, 0.0570388466495515, 0.05550863822894103, 0.048536989715879275]}, "mutation_prompt": null}
{"id": "bb787049-3527-43e6-a5e8-a157715996c5", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 4 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.7))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n                F_dynamic = self.F * (0.9 + 0.1 * success_rate)\n                if np.random.rand() < 0.4:\n                    F_dynamic = np.random.uniform(0.5, 0.9)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolutionV2", "description": "Utilized dynamic population resizing and adaptive mutation strategy to enhance convergence speed.", "configspace": "", "generation": 85, "fitness": 0.2294229570161932, "feedback": "The algorithm EnhancedHybridDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "ebb4b68a-1146-4c8f-9023-d22bcf11e81f", "metadata": {"aucs": [0.6199697904628424, 0.5907615703504978, 0.608974960025159, 0.5449132625570969, 0.5604462292921973, 0.574731669495433, 0.5666406778660729, 0.524441289974483, 0.5721002343500734, 0.30124398777385497, 0.3047418659378631, 0.32013892848985626, 0.3223220699454419, 0.27918151028858784, 0.306248772181268, 0.05900043096790142, 0.28175716261597783, 0.3356991125827711, 0.08517688020343517, 0.09401829315833765, 0.14220337688014206, 0.10659010474998487, 0.10539043524371405, 0.13781535669039202, 0.1022199082410078, 0.07265855063169002, 0.13549761133142768, 0.09247682362446652, 0.10845870078301467, 0.11177960289748257, 0.08177074556595165, 0.06874122073862765, 0.07220117282975047, 0.09621254313257399, 0.07690587127345694, 0.09354925747697085, 0.9066815987951127, 0.9542253806773474, 0.8169597696986628, 0.8689335600481214, 0.8642848817508119, 0.8917786566617452, 0.8800642066449768, 0.8831591203169052, 0.9797545953382651, 0.21450303397718606, 0.23040503907989274, 0.24591235290989244, 0.28345671353648916, 0.13353338762014444, 0.1354136258742734, 0.2525400883520009, 0.2528675641924404, 0.08332697501515307, 0.16170912385060765, 0.235807868144, 0.2985005085478457, 0.559593824785265, 0.291890232876873, 0.1951858307952471, 0.20285956096667512, 0.6344808509593994, 0.20707753053073819, 0.11379740165527252, 0.10918283088852276, 0.16239752890532344, 0.11137937839198908, 0.11089067167627331, 0.1663749669290654, 0.11514015292302482, 0.12657580647390132, 0.11953952151530722, 0.12135248873425042, 0.009126476108299197, 0.13149465634077473, 0.09386535107596772, 0.13411456799715704, 0.14448393023486206, 0.15785310172696865, 0.12843426382207568, 0.23297463940402563, 0.08784713907507735, 0.006183162664905262, 0.03769714073842456, 9.999999999998899e-05, 0.021396510695965265, 0.07858060798649913, 9.999999999998899e-05, 0.04129244942375354, 0.006634820861325164, 0.1390631468200032, 0.18266868453226903, 0.1715284088547312, 0.09126897692551794, 0.04671804765243759, 0.038233816691501166, 0.11721879400844026, 0.14010612259247324, 0.03802750615599837, 0.08635443684448751, 0.04655000751023397, 0.0461517053949132, 0.06351657656450882, 0.038369834242040324, 0.0870994676924205, 0.08924353828790466, 0.04956117180936648, 0.059609606477256216, 0.17099183514567762, 0.15046324437496061, 0.12248564893796432, 0.1153579197099105, 0.12395835139122302, 0.08929591294352779, 0.12778663153413672, 0.10666044856754198, 0.10709391593823325, 0.45237407889968606, 0.4031635180445905, 0.46738353578543446, 0.4712797283270257, 0.446633928392408, 0.4359552930351659, 0.4408114583023591, 0.4301297165020047, 0.424367645341872, 0.10926271682796318, 0.12149475353561612, 0.08593970578057375, 0.13307690935527605, 0.08862264980775303, 0.0688643108882645, 0.08021243382912813, 0.08422126147952735, 0.11733249929928713, 0.15800711775555487, 0.15391159407528043, 0.12970439732569794, 0.09855305120391278, 0.10852972522114035, 0.14158626742509972, 0.14567187043903973, 0.12505122841077643, 0.1574992644822576, 0.23302203832598312, 0.30102788668258784, 0.29022769131075365, 0.296330000440274, 0.3275572518043226, 0.29372761401648173, 0.27104147118556643, 0.3312020252819622, 0.2696816554909538, 0.1789636821952506, 0.22122912097661163, 0.22249893650759367, 0.22342044357597657, 0.14513776433280823, 0.22452088551484028, 0.17581145838560552, 0.149922932321916, 0.13379683626065375, 0.15341224765680905, 0.22228133748279966, 0.19801697475916402, 0.15781294937527912, 0.1535591210778906, 0.1648530147519892, 0.18118819067311143, 0.18016034608432985, 0.17593453310455331, 0.17800702769543564, 0.1768151259043378, 0.20801418221653944, 0.1797396468143435, 0.16471482097099943, 0.15425878244398739, 0.1723430381331238, 0.26024439503721486, 0.2199284336910199, 0.6123733213578719, 0.15501842502480834, 0.6208880799603933, 0.6492777270378705, 0.18563599924023877, 0.6475056646174884, 0.1079007081034924, 0.15493079924510167, 0.19630888971630933, 0.3787417889710578, 0.19593790836544922, 0.6945740343361342, 0.21470143197458746, 0.19595829002723975, 0.5083986784446682, 0.19898333608494978, 0.2696823413962284, 0.4224475616978368, 0.1749891507353254, 0.18461239857911227, 0.17946311841280072, 0.15603451478603347, 0.16737244498869874, 0.1727278153876759, 0.16472788159839746, 0.17305397076629037, 0.15174394691509674, 0.04565577391231268, 0.07472839600486836, 0.08815309264941207, 0.09008894442112036, 0.05369374912812419, 0.06704560449932129, 0.06398265712135309, 0.05404141936748996, 0.07785514196224064]}, "mutation_prompt": null}
{"id": "9887bdb7-7881-4581-ba28-693e4fde289b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.5 * progress_ratio) * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced adaptive mutation factor scaling based on progress percentage to enhance convergence speed.", "configspace": "", "generation": 86, "fitness": 0.24902433639598553, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "ebb4b68a-1146-4c8f-9023-d22bcf11e81f", "metadata": {"aucs": [0.628289618084204, 0.5958963714767858, 0.5560599105353949, 0.5830632992580873, 0.518865795883121, 0.5572423705629599, 0.5767830731913637, 0.5514936560572767, 0.5085001333275928, 0.28867491736540307, 0.3021471231322894, 0.38707781035388467, 0.2678388122374561, 0.23453985971315527, 0.18039496341556716, 0.3043866943060022, 0.3310795610564782, 0.3141266418301437, 0.1183220330692426, 0.11682140956332898, 0.13543521049682217, 0.08331058708455252, 0.1258616073657437, 0.26816272090183724, 0.13254836160253325, 0.14821815844975883, 0.13562289770886748, 0.10034539376364615, 0.10636913383699431, 0.11974592408416085, 0.09760372643689175, 0.11093481303108543, 0.11212221911370834, 0.08616119169573977, 0.0827106652519215, 0.09588341618793006, 0.9209341914127738, 0.8430174359891783, 0.9218040539568676, 0.8844369438330322, 0.908396482942227, 0.8888889795497722, 0.8625115222431249, 0.9013275457181393, 0.9797562835573884, 0.23511488866646446, 0.250224687396404, 0.12741593548193664, 0.28483466871283214, 0.20789195690952722, 0.28160383030539615, 0.2181421537659416, 0.2636617782593834, 0.27808104903830755, 0.20671315285889225, 0.5175902276847067, 0.28826461144217275, 0.6687503027442486, 0.6876008586800832, 0.19187489173015693, 0.6502032060579663, 0.7425586507746755, 0.6728355726506765, 0.15094131893589802, 0.1815191502531741, 0.14546990096661505, 0.12174026190369658, 0.1570829115483432, 0.10293890531986927, 0.12756407065529196, 0.12092987022833912, 0.10917218486980296, 0.14854034834794438, 0.13872388313101724, 0.12438869941245667, 0.11116169517111196, 0.14245989709419482, 0.12453803390056406, 0.12015217699957825, 0.15787585769605905, 0.12356371196031235, 0.008102559767110717, 0.0664774340350558, 0.016494707608108783, 0.00016779565275082398, 0.06653020150293487, 0.009137081451310536, 0.057265181692742084, 0.0027029865511263296, 0.03216658854837684, 0.14495946867433773, 0.11405075390198804, 0.17169675610069912, 0.13120468762692927, 0.08505776777072283, 0.11821296249704705, 0.24497307850543215, 0.20625241170815967, 0.16061848384757782, 0.0873335136940423, 0.042236635770429576, 0.018355401174055208, 0.032492342482090875, 0.07424187257522008, 0.054271839762836005, 0.049656998678517805, 0.08882012776582338, 0.05457414825054385, 0.15777730533374923, 0.14504913110375095, 0.1508445256123938, 0.16216328097233546, 0.13630944356367147, 0.14476427349695264, 0.13386409568073, 0.07265156103776227, 0.09059559048146093, 0.4433786876133592, 0.441577511837119, 0.44329327137923225, 0.5625184078336256, 0.43732395693230397, 0.4174403173416251, 0.48666441324879206, 0.41651075086331446, 0.4110224761090351, 0.10331815324795157, 0.07496079025118962, 0.08302238484371172, 0.09988123410244876, 0.08079607800762101, 0.10311690057989398, 0.08169623110477209, 0.11815481799481298, 0.08545016861471266, 0.13845221518567996, 0.12364742517312277, 0.1184217577696689, 0.19311014895408318, 0.10852972522114035, 0.10330109231470197, 0.15653047021943, 0.13089696247084015, 0.11535727559413389, 0.25415931808030745, 0.3061862714784416, 0.3366476604970039, 0.30680727699494614, 0.3026402265104765, 0.30242208230293177, 0.3406443106460558, 0.3158795862346204, 0.3335369012393481, 0.17761339272313803, 0.2611131835057324, 0.2003199778922754, 0.2484150613478212, 0.1617356996082261, 0.23891954405137772, 0.27459890973504586, 0.3156887783741418, 0.2117636997094895, 0.1792440327945356, 0.17913825166141628, 0.17682656388462725, 0.17598185737515926, 0.1837790930372808, 0.1820294763386341, 0.1692828880682391, 0.17309135329580838, 0.20035596476576334, 0.19598769170686703, 0.20207304288604755, 0.19592603990604707, 0.16686112962814637, 0.20182438022352445, 0.1801897425380966, 0.16801244503555024, 0.17347559892164977, 0.1738421434280113, 0.5245653471507755, 0.1497217365449819, 0.707780379435272, 0.672460531457894, 0.18976082272774697, 0.6608511485884825, 0.12439004454031033, 0.16246943473321263, 0.6463118432359749, 0.6095055819384904, 0.20312474450559626, 0.7487286460046279, 0.5165713444742368, 0.1596083523735895, 0.1449809272936533, 0.1062023034346048, 0.48296482005945396, 0.1390760474268321, 0.17007376602560997, 0.1625943872404212, 0.17494764901456183, 0.18297474516815515, 0.1481448039713703, 0.16618427718059414, 0.16596162515130108, 0.17358955076373006, 0.16703376576238393, 0.06867791926290867, 0.07751060322177838, 0.07626828947659992, 0.05675747400684528, 0.050761328292230457, 0.0675996247332078, 0.05981756606465627, 0.061119525966605526, 0.07686668600182178]}, "mutation_prompt": null}
{"id": "9dee7c60-3ec4-4c96-a429-f06c41b9f34a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.8\n        self.F = 0.7\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.3\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and np.std(self.population) < self.diversity_threshold:\n                self.population_size = max(self.dim, int(self.population_size * 0.5))\n                self.population = self.population[:self.population_size]\n                \n            new_population = np.zeros_like(self.population)\n            current_best_index = np.argmin([func(ind) for ind in self.population])\n            elite = np.copy(self.population[current_best_index])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                F_dynamic = self.F + 0.1 * (success_rate - 0.5) * np.random.randn()\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR_dynamic = self.CR * (1 - evaluations / self.budget) + 0.1 * success_rate\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            self.population = new_population\n            elite_indices = np.random.choice(self.population_size, 3, replace=False)\n            for idx in elite_indices:\n                if func(elite) < func(self.population[idx]):\n                    self.population[idx] = elite\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Incorporated adaptive population resizing and dynamic mutation factor scaling based on fitness landscape analysis to improve convergence speed.", "configspace": "", "generation": 87, "fitness": 0.20503865003009955, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.4315847071847747, 0.4094074042752779, 0.47520526025521503, 0.4770242400119298, 0.4962321473798377, 0.4386391829402332, 0.4430517252688755, 0.5388652355069359, 0.4561182017537764, 0.19793294009443962, 0.15350330149890068, 0.16015020737396357, 0.20872259407964588, 0.18048791736285041, 0.18659269584317228, 0.18403278485831742, 0.1889869591856549, 0.22997710698634977, 0.13796474201615005, 0.14832104514626188, 0.1373307941943176, 0.10235341214834859, 0.12236384937438383, 0.1108818563731615, 0.1281087107955804, 0.12000579240708609, 0.11784177191895762, 0.099566175251242, 0.07796894575281754, 0.09249059534980153, 0.10343426961775748, 0.11677794742385672, 0.12482559476157473, 0.10904920281945762, 0.11508635611452789, 0.08729802764828931, 0.8856250754212971, 0.8546036515031736, 0.8760266168908359, 0.8988231432599915, 0.8847094929665974, 0.926809861452348, 0.8052200355372492, 0.8596116118615473, 0.9591712796919021, 0.1946855020781637, 0.1806352176053988, 0.2074998990063065, 0.2047844726539476, 0.1899776523616319, 0.17416205187661615, 0.23106523747835417, 0.21738993388402228, 0.21749223653049832, 0.27995549756569726, 0.2508414905628984, 0.22994479276962998, 0.24515485656037372, 0.22129119471282843, 0.2094726908779173, 0.29719415342007005, 0.28099377456066355, 0.28626841806511794, 0.13229971581525402, 0.09769251910600574, 0.11128856110720076, 0.1449703485935273, 0.21233515733895036, 0.12106064982532949, 0.10765571753016245, 0.15618880443906014, 0.14235191164331285, 0.14865621185126965, 0.16061038840255437, 0.08381720404909865, 0.1088244474929545, 0.12304656113023871, 0.09982131972061903, 0.15353980250916555, 0.08629908549433019, 0.11631269776253561, 9.999999999998899e-05, 0.00888322555302934, 9.999999999998899e-05, 0.00016085969596080218, 9.999999999998899e-05, 9.999999999998899e-05, 0.003959301408566707, 0.01767861857670161, 0.03197952542860494, 0.09018324810272604, 0.0444060092134998, 0.05715594073572261, 0.09817043838543726, 0.06699572482681737, 0.03522763483133606, 0.10641418631469912, 0.10065530038141479, 0.06083160272368404, 0.035380059556506915, 0.023804089340318524, 0.019324745221021455, 0.042138359778630896, 0.004066053196268737, 0.018658613909641963, 0.058535709400259095, 0.010640406791845303, 0.0311376126725168, 0.09969869463119174, 0.08726091232664168, 0.1043448695277146, 0.07166984586401837, 0.07500209222468368, 0.09901759333955629, 0.09810754206432137, 0.04472556186842469, 0.07958426195008395, 0.34502552078660986, 0.3841951863308526, 0.3858310690760258, 0.3429438516438318, 0.3572473662224471, 0.38166538109235504, 0.41675560117346155, 0.36054792292855486, 0.36411866464739695, 0.07559807581527622, 0.08638704144626175, 0.08659081016993553, 0.07321954538823228, 0.09309886522789834, 0.08478971942496705, 0.09852163828250637, 0.055685486861307476, 0.0700685224110974, 0.1272746623415707, 0.11024263020735903, 0.12470405593840128, 0.1310162129653787, 0.12593983933633623, 0.20351218847284624, 0.11336328499678516, 0.17945134141171004, 0.16026368399055757, 0.22820611293680726, 0.26456566431297013, 0.2758672333923017, 0.24575546456682185, 0.25407397985793045, 0.24885674085917786, 0.279077115257264, 0.24724320744934414, 0.25897525356290485, 0.18424060641768414, 0.1807808067444504, 0.22979618682275638, 0.14345031607234582, 0.21683979497958916, 0.16084987244288096, 0.18793388183414106, 0.18575050151999117, 0.18960218056854095, 0.16766158735127135, 0.17292127683984804, 0.1913407707949465, 0.1882049656785868, 0.18806784434486112, 0.16647780798787548, 0.17155194488647052, 0.15326434134311273, 0.196089283472084, 0.1757176482847721, 0.17937113262703241, 0.1878429935324909, 0.18083411852800313, 0.20571259781051454, 0.18416732305133388, 0.19447135373097058, 0.1762188723637801, 0.18000265215160505, 0.16448220476847997, 0.14953198521931188, 0.1982799545884878, 0.6246432401116822, 0.17705731994070595, 0.2894184988789863, 0.5100260789533207, 0.15404969147701808, 0.665809618550562, 0.5073440979396, 0.19022122416917275, 0.26396533556379254, 0.44454069360491844, 0.4185106588220586, 0.13172080075535086, 0.13754031321056914, 0.19347361298358234, 0.2832157333122224, 0.19137335111499554, 0.15774239694508474, 0.1708338325545814, 0.18853190159597466, 0.18161282283533153, 0.17418385836640282, 0.16994621010645372, 0.1793591520218244, 0.1905653214112586, 0.0688543374699282, 0.060999716619028366, 0.0674530634403896, 0.06669411676926207, 0.06401618066120174, 0.06348374310182847, 0.07274949608792414, 0.06801606918666947, 0.05769688461390743]}, "mutation_prompt": null}
{"id": "fac18747-791c-4fd1-91d8-1a2f73f25d22", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.5 * progress_ratio) * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            dynamic_pop_size = int(self.initial_population_size * (1 + 0.1 * (success_rate - 0.25)))\n            self.population_size = max(self.dim, min(self.initial_population_size, dynamic_pop_size))\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced exploration and convergence by introducing adaptive population size adjustment based on success rate, maintaining diversity as a key factor.", "configspace": "", "generation": 88, "fitness": 0.2426826220496121, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.5825052523985956, 0.5193135711818242, 0.5820729563797337, 0.615624969538215, 0.5973430196230685, 0.580355017492735, 0.5587772882107838, 0.5802263459247313, 0.5598813213961438, 0.2873859758782914, 0.30390085357409524, 0.3675517146945836, 0.2821763383330286, 0.3348992680445776, 0.27619166695352837, 0.23185386917391138, 0.31396707425148684, 0.31404268005357183, 0.08560266357400392, 0.10822313439637399, 0.1429785837823605, 0.10164917230856518, 0.12227205469705715, 0.0852630317371732, 0.07812595186577675, 0.11391897607737389, 0.11673485672520933, 0.10784001390505438, 0.11185427254912883, 0.1257105576103772, 0.1330200032434372, 0.12013177682392429, 0.10916874732706583, 0.09058025308407047, 0.08541120840001726, 0.1308198209807826, 0.9209341914127738, 0.9057201406384043, 0.8903469744002387, 0.8844369438330322, 0.8747941010627297, 0.8888889795497722, 0.8625115222431249, 0.881670074060487, 0.9797562835573884, 0.26195967340798343, 0.2068035606429819, 0.18507568563575139, 0.2651913872072883, 0.2027388460362568, 0.2747225712681396, 0.24593033206386905, 0.23929433186798543, 0.29276473102230416, 0.24194611539395106, 0.2843725314953046, 0.20608288446518763, 0.28924971037704394, 0.24365070954428003, 0.5587639833034623, 0.6612225224566128, 0.3391153858540783, 0.6699748064924178, 0.20781111455414747, 0.19279273594996016, 0.2785349648263016, 0.12366621272001377, 0.11760732610140434, 0.10747984075905914, 0.15723875597179304, 0.10751788557379627, 0.11082382764136933, 0.09688781182857675, 0.12145615603748161, 0.16153126457615397, 0.258635277311843, 0.10529953863071984, 0.16642943626648155, 0.15567720786553185, 0.18931480763115394, 0.18449728670362253, 0.07244460521524743, 0.04991716817599667, 0.06289294793193545, 0.04822062465073118, 0.0077275184931945295, 9.999999999998899e-05, 0.11700528813688249, 0.047256843145319416, 0.03286318734021698, 0.1644709635587316, 0.1233195776328434, 0.09994765551559537, 0.04888383539744556, 0.15517974998122186, 0.16752536028752407, 0.07748252229077024, 0.26670271024443115, 0.06142314459811948, 0.0841966234120961, 0.050454458639925925, 0.05292972012159969, 0.05733002871756676, 0.07343305991068116, 0.058421753141319255, 0.0412024699756941, 0.07880080632139252, 0.05468424830949259, 0.18509992810794285, 0.10656155455181959, 0.15207374551903396, 0.10741349171975778, 0.16020038751097876, 0.13256281076708343, 0.11654221852961089, 0.08185904973045421, 0.16120462517780454, 0.4306695846949652, 0.48498804259251205, 0.46862281234835834, 0.45543656343127636, 0.42003776559767525, 0.4194683224390112, 0.44780063633939216, 0.4004980264388345, 0.4189290537992608, 0.08364840845490085, 0.08072938327861834, 0.06379354612963029, 0.09431971273383954, 0.1106807713254826, 0.10857209754666419, 0.08065857693074341, 0.10578602596587083, 0.11682508707686245, 0.10722446056646806, 0.1332295432580699, 0.14005050062749436, 0.15593778150459547, 0.10978262644903936, 0.09914296330644157, 0.23192786715105063, 0.1594198131749266, 0.17111306800498494, 0.28668443332155225, 0.2738963142941431, 0.2557936072874729, 0.3035810617570758, 0.274184760195919, 0.2855178827500092, 0.23139112142368956, 0.3654667132119179, 0.26746910253875844, 0.2048395617020714, 0.2508088643286541, 0.1518186885266427, 0.2237974056695733, 0.1401268255438577, 0.2930331844809949, 0.19436922760016928, 0.2346370030258934, 0.16632924128722115, 0.25277768211004115, 0.2477147206357938, 0.2529065578666242, 0.2482820677462051, 0.24678645132730836, 0.25578554892274885, 0.24823659274567356, 0.2517795662160096, 0.25634539793654776, 0.19312674002953223, 0.17041718794480598, 0.16285184681051612, 0.1941089700919889, 0.2442462088110774, 0.19187829111401922, 0.16094906495097516, 0.2075785310871, 0.1677072865340311, 0.2566050203175789, 0.1453855875321185, 0.18888935183140243, 0.6734551763073169, 0.19108751629196086, 0.16986266719283816, 0.4438402710252214, 0.1611978131227335, 0.7130510251699812, 0.45143548843118997, 0.19943818136997948, 0.5873245097214689, 0.6503613305416653, 0.15635542923113555, 0.15477804180160637, 0.1969115806770405, 0.19919646583371342, 0.5082410076093722, 0.16180823194595795, 0.16944870681923363, 0.16323931551548465, 0.1488141806855392, 0.16754831441857843, 0.16618427718059414, 0.1745502925448552, 0.1784559119423389, 0.16701244056765863, 0.060260783946894825, 0.06706806493117123, 0.06363566027596868, 0.06373874199950602, 0.0863128800934625, 0.07997376853723304, 0.0531754430546072, 0.06323905720888467, 0.06421769885295547]}, "mutation_prompt": null}
{"id": "56f05878-3898-447d-aca1-4c2d2baf7e84", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.5 * progress_ratio**1.5) * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                elite_guide_influence = 0.1 * (elite - self.population[i])\n                mutant = np.clip(a + F_dynamic * (b - c) + elite_guide_influence, self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced elite-guided mutation and refined dynamic scaling to enhance convergence.", "configspace": "", "generation": 89, "fitness": 0.23497554698131107, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.563644601536126, 0.5832838976339534, 0.5994007600637266, 0.6026940261988345, 0.5769514173060057, 0.5816744562642442, 0.5612459447804078, 0.5584035522753514, 0.5390823764811229, 0.24289332291666832, 0.2514680325927866, 0.29484406174548905, 0.34210791356791004, 0.2920501531131958, 0.31647212512847744, 0.31548022233425455, 0.24542400083685534, 0.3094302164093442, 0.12960764918043677, 0.13959820724497474, 0.13473213639528436, 0.13763217507697934, 0.10479347116303672, 0.13591387172463143, 0.12361198948826313, 0.13084181374310044, 0.11179562466173087, 0.1070282230698345, 0.10824628646371748, 0.11318737905438592, 0.10033715104561758, 0.13384022766531145, 0.11269073742012092, 0.07993028083184817, 0.11788731190417023, 0.08142090535309143, 0.9153552087646896, 0.8691808769850959, 0.8492303957956373, 0.9267081036030711, 0.9358117828234825, 0.9116335611508493, 0.9247524621324983, 0.9061135408501181, 0.9798980650350454, 0.31894423997021704, 0.28833922790646116, 0.22504796051653642, 0.24660477912838985, 0.25328065550077505, 0.2714647404667848, 0.2870066973892371, 0.2802384112240549, 0.2261281031430763, 0.5689565373584566, 0.24603380880698966, 0.2686030370270167, 0.26014573359614857, 0.7297893427168007, 0.30179803225736723, 0.3334446216509933, 0.29999327690844346, 0.6460322316274699, 0.1674950393657466, 0.11012230675040768, 0.13339852122641715, 0.11707658457541059, 0.1410398939466735, 0.09007013292951105, 0.21185549051034958, 0.11502773011945644, 0.12750135852974742, 0.13257750430314552, 0.10028274006980176, 0.22593817736586153, 0.2646197524178656, 0.11880405302717534, 0.1393724283840505, 0.13403631640814506, 0.13061244243718517, 0.10846299799832737, 0.11314984419596441, 0.03241149846737712, 0.04617835834875328, 0.000624801811798692, 0.025886225452969813, 0.04836525851842011, 0.11029679187183705, 0.06110359366941798, 0.010702576453314738, 0.18763081052431085, 0.1623987334762398, 0.22519456758100764, 0.08147261134538475, 0.11531243638589295, 0.04106242397815363, 0.15020975317606644, 0.15794341435062142, 0.24932439112671834, 0.08150243401522295, 0.026470924783044913, 0.0380699507037654, 0.04397988351758253, 0.047244043768809973, 0.11760621641805769, 0.10983075814637122, 0.04619168882253322, 0.060171691568592145, 0.11704431381002545, 0.08668616668186058, 0.1553163379257808, 0.12176773931088469, 0.1784209390120043, 0.10374696382545867, 0.15319432590798665, 0.13970340773503664, 0.14996816515701572, 0.4871805044710217, 0.40353073889835556, 0.42820064475615127, 0.4210090114329198, 0.41598169058929646, 0.47584554671564294, 0.42616428793479877, 0.4720806833513589, 0.4145924112353805, 0.10859102758313022, 0.14999087408349554, 0.1004495865853623, 0.09552760857943199, 0.07263358456144886, 0.09652153286222565, 0.09097526327219152, 0.09075385874299058, 0.10634888679041965, 0.18880240174779006, 0.1464925054191748, 0.23232879107246718, 0.17389319836727646, 0.157374313400913, 0.17700924898907122, 0.22849099025152253, 0.13290727796481006, 0.12801934327062314, 0.2281368505909579, 0.30408315412611664, 0.29994935613965257, 0.2905705229017873, 0.2742749487944288, 0.19824579011378385, 0.31736813103875383, 0.33208842925457205, 0.2153364098250069, 0.10892539185004713, 0.23649682195072197, 0.2167427084428093, 0.19022590748522428, 0.17375418590057234, 0.24776350514554768, 0.14848872782575728, 0.2190056571211435, 0.24301116511583842, 0.23420921738402412, 0.1727414024442181, 0.18018323617814935, 0.14864805382797464, 0.17888352055048795, 0.18975337308734563, 0.19316145133668294, 0.17222505959026935, 0.17675640338313747, 0.1644250585864676, 0.18524847341785733, 0.18038051300334568, 0.1813661119733473, 0.1866809732578889, 0.17032407858568444, 0.2937215331796479, 0.16884370329882115, 0.1847600466482473, 0.14819946935829598, 0.15923564349586283, 0.16289679234296095, 0.6409961067079453, 0.18987504857636373, 0.16593788440664992, 0.13736440877486766, 0.14928596748733725, 0.16329103701613235, 0.5573869170618602, 0.16219760591982335, 0.3133390558350946, 0.15884146050221626, 0.15980363628353444, 0.14561978574044954, 0.42852107354571733, 0.19594856263421223, 0.11696425682879275, 0.16031484414717667, 0.1653497644658548, 0.16704127527186596, 0.21004198563145582, 0.17777345285834822, 0.1659269226660015, 0.17047706542766083, 0.20244996147063343, 0.17182333646673564, 0.07645976631135654, 0.07557703726365306, 0.07884170822190972, 0.07109659204480157, 0.0653396033740391, 0.07145550034121351, 0.08622126281180098, 0.07983498605329986, 0.05985321511511554]}, "mutation_prompt": null}
{"id": "2d44ea92-318b-4dc3-adee-46d4bf261d06", "solution": "import numpy as np\n\nclass MultiStrategyAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.5\n        self.mutation_factor_bounds = (0.4, 1.2)\n        self.weight_decay = 0.95\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > 2 * self.dim:\n                self.population_size = max(2 * self.dim, int(self.population_size * 0.6))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            current_best_index = np.argmin([func(ind) for ind in self.population])\n            current_best = self.population[current_best_index]\n            elite = np.copy(current_best)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - progress_ratio) * self.weight_decay * (1 + 0.2 * (success_rate - 0.25) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.5:\n                    F_dynamic = np.random.uniform(0.3, 0.9)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.3 * (success_rate - 0.35) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.15 * (0.5 - success_rate), 0.1, 0.95)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.8 + 0.2\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.8\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) + 0.01 * np.eye(self.dim)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations > self.budget * 0.75 and evaluations % (self.budget // 10) == 0:\n                restart_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.population = np.vstack((new_population, restart_population))\n                self.best_fitness = min(self.best_fitness, func(self.best_solution))\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            for _ in range(3):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "MultiStrategyAdaptiveDifferentialEvolution", "description": "Utilizing multi-strategy dynamic scaling and adaptive restart to enhance convergence speed.", "configspace": "", "generation": 90, "fitness": 0.22453853023913187, "feedback": "The algorithm MultiStrategyAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.523596002264544, 0.48076295970756033, 0.5495779336393398, 0.6056896835997476, 0.5565801802683561, 0.5183640235806275, 0.5449443203480806, 0.5279592569956533, 0.5020516410655498, 0.15569292773142607, 0.13424471922580272, 0.2939801161674286, 0.2462349933197856, 0.2407966463043455, 0.20083377479945574, 0.2482585659190346, 0.24487460902080582, 0.09825497843010633, 0.11468118038956854, 0.11112815027636591, 0.11283961306126189, 0.1321155366224992, 0.11332824272103648, 0.14819771260980852, 0.10119831882589403, 0.12608215635255116, 0.11595264829281315, 0.09422163082268764, 0.09351255809791781, 0.09191529529703168, 0.08014267443307022, 0.08694660178555369, 0.1102446010941559, 0.09489622413317611, 0.09758930003559985, 0.10665660337871796, 0.829212791581793, 0.8104114593558337, 0.8925031513595603, 0.6847907476511779, 0.7626120120689239, 0.852668205961328, 0.8628420441392558, 0.7762842791059937, 0.922630072766151, 0.2890438863499123, 0.17426329442589517, 0.2050449320884934, 0.15808744880482373, 0.16784725114038357, 0.2526726095474523, 0.21398998599515007, 0.1533044790882726, 0.22129261624567698, 0.20636525465039546, 0.6415486164151079, 0.4942559478965194, 0.23974875912836535, 0.2385522241177741, 0.2699582854151862, 0.13136063812029009, 0.5878032871093694, 0.45165453909012465, 0.14227653692957887, 0.10466009815400379, 0.1405377943103715, 0.12567305378820126, 0.09971463805847036, 0.117033874459333, 0.13861828581615288, 0.10242006642196211, 0.12954638387939799, 0.1579304728394203, 0.09478497905031946, 0.09917170527460695, 0.11585029075089137, 0.10951958085842384, 0.15411593807863277, 0.14385262644284735, 0.13190368526950091, 0.12191923299536334, 0.044550743651736724, 0.04970870908448921, 0.041565130349697776, 0.2005269551568697, 0.02646600674938071, 0.07744390111525612, 0.08930115277083528, 0.05020968298705297, 0.11110474841019313, 0.11629681159655936, 0.15650349221315396, 0.2524170888008763, 0.10218703475991164, 0.11130180260704126, 0.15037037386214158, 0.10963257505350388, 0.15657839480619495, 0.15682497018120178, 0.06808801318184632, 0.045809441293867215, 0.061881050864933784, 0.049273377400241625, 0.07659372329121872, 0.052651760479931364, 0.09716245535959056, 0.05834946793785223, 0.05447016933908233, 0.10828356973091702, 0.14672902474373894, 0.11646327710307847, 0.09587238859076419, 0.14317733510064934, 0.14234444646812894, 0.0764132380220437, 0.13331155896454094, 0.09933708579780143, 0.4097502844400669, 0.44549301391896334, 0.41996896824717733, 0.43412236067083965, 0.4185010402760496, 0.4143073859606168, 0.47106613684038656, 0.4253266330525973, 0.4390427906849358, 0.11078078526238222, 0.10198208487324778, 0.09848212521320743, 0.07248021269397376, 0.08931493033297122, 0.07410603449225872, 0.075045053493351, 0.10542554192778186, 0.0921472847547189, 0.15379495839347368, 0.18386920325518263, 0.14634894079253713, 0.1339911948476432, 0.1222565844262099, 0.1647093021254492, 0.11889464672761929, 0.22023088074714658, 0.14680530412383253, 0.24560031860332288, 0.29754006271443667, 0.3088678965769768, 0.2687394948684352, 0.28918572688061683, 0.25772200445000626, 0.29775374421384393, 0.3075544925308924, 0.2867576711350903, 0.22416493659728842, 0.23071067747294927, 0.22015642785411382, 0.20073692657021547, 0.15675202946115274, 0.17676589845775237, 0.19775022246938823, 0.21446750091411726, 0.24198373794367356, 0.17951035101481427, 0.15971303819782823, 0.17210399622770278, 0.13963520151028974, 0.19118737679572428, 0.18392314477540972, 0.17271973809820707, 0.14700575067819321, 0.16228599963203527, 0.19485109250127208, 0.1636610430270673, 0.19441970372460715, 0.18649719832764977, 0.17432546679869354, 0.20703684555170798, 0.17058296330638745, 0.21209688225068657, 0.1809429162356373, 0.6600854937696271, 0.18918277416994178, 0.5648732255130883, 0.5187552074433931, 0.6480599625057404, 0.16849475785522505, 0.1361773884573828, 0.12257611816671399, 0.5905311212773494, 0.20256195869078997, 0.2001516205082241, 0.19094663507490017, 0.19412007339101944, 0.18827456257229602, 0.19160693410070084, 0.19112685839355503, 0.1909639610013555, 0.48469499593944687, 0.16451777416799573, 0.1834883496643701, 0.1818188525420955, 0.16568594902785994, 0.1716988249506689, 0.1690893093438003, 0.18272334642798327, 0.16250141031242094, 0.17660482179903592, 0.07796882734260813, 0.08188547180762684, 0.07019965760708169, 0.0697280842692104, 0.05888414894166383, 0.07080177733545501, 0.07526853636557351, 0.06532789969912245, 0.08116827883398159]}, "mutation_prompt": null}
{"id": "36ab73e3-2c00-46ef-a32c-e51855101b3c", "solution": "import numpy as np\n\nclass EnhancedFlexDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        learning_rate = 0.02  # New adaptive learning rate\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.5 * progress_ratio) * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * (1 - learning_rate) + 0.15 * learning_rate\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= (1 - learning_rate)\n\n                if evaluations >= self.budget:\n                    break\n\n            elite_index = np.argmin([func(ind) for ind in new_population])  # Diversity-based elite update\n            self.population[elite_index] = elite\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedFlexDE", "description": "EnhancedFlexDE introduces adaptive learning rates and a diversity-based update mechanism to enhance convergence speed and robustness.", "configspace": "", "generation": 91, "fitness": 0.15670959823205902, "feedback": "The algorithm EnhancedFlexDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.3390784027609476, 0.3543604297377664, 0.3458457094132049, 0.35382107990524503, 0.3470880294750648, 0.34296769044189124, 0.34278320958605346, 0.32473218441578533, 0.31846334712754687, 0.08084050279381316, 0.07735902679468343, 0.07823484063665853, 0.0901508182818529, 0.08141786942851015, 0.09930219028612464, 0.09547821310405036, 0.07670245763748629, 0.06897048915289505, 0.07491161828719706, 0.06568398702865308, 0.08764474169601799, 0.07059498123754293, 0.08494526036833328, 0.06843856663609893, 0.07974434244222162, 0.08121876876136225, 0.07725272429813046, 0.055798922746678525, 0.060143719238088256, 0.059544846503397975, 0.07610526914107396, 0.05848273662749348, 0.060153343238271595, 0.06884266117919347, 0.06703787856190391, 0.056051984477375805, 0.5977888178061956, 0.8216035508552981, 0.7141005946820085, 0.930325535453958, 0.8891464491787754, 0.7044893441108879, 0.8247021844226845, 0.5277924082078114, 0.9764246194044539, 0.13077773242301705, 0.13068469368071656, 0.12289374162414646, 0.16110497965728554, 0.13418406648960735, 0.15500658130680278, 0.11989474080141449, 0.1618930260845336, 0.11960432234783891, 0.19000934346897325, 0.1930561435717646, 0.1835133091103246, 0.20790347093034667, 0.21413611910209795, 0.20619506701370371, 0.20671445059043658, 0.20228006322277514, 0.20287459711764655, 0.07155497184221693, 0.07935523541050238, 0.0873796657165703, 0.08434950859153101, 0.0755667002736734, 0.07053822386761954, 0.08997535405243762, 0.07801648801254746, 0.08428332865492172, 0.06328636313199298, 0.08081278253709756, 0.07581044242066437, 0.0807354219923524, 0.07617271274099402, 0.08332204673968113, 0.07752439352531526, 0.0864356424835494, 0.08543111135368286, 0.016927737555923916, 0.01053440143757911, 0.01773537661908231, 0.010413180012627699, 9.999999999998899e-05, 0.006580785434113001, 9.999999999998899e-05, 0.007748786336801983, 9.999999999998899e-05, 0.12848080962200437, 0.11384427851800571, 0.0769980588711272, 0.07396775717982673, 0.09059672956545017, 0.08242815847557905, 0.09066653554897675, 0.11722152801517127, 0.08694301648635605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05383879546230086, 0.047947508999053534, 0.051235814608626584, 0.05673559801243777, 0.05498724369836705, 0.0621955340648952, 0.06774148316353434, 0.04812855899786461, 0.05093287399973745, 0.2886658075222124, 0.28813920405776083, 0.3184819222417211, 0.3183943628418948, 0.3048932342412489, 0.2948293942002641, 0.3227379434210398, 0.3159308612912619, 0.3178699686895585, 0.0688493311361168, 0.07090670102781682, 0.08525127053128467, 0.06674327577920225, 0.0842183150005682, 0.06192198948976779, 0.0660956461408918, 0.05644270287381825, 0.06356558868879603, 0.1348979391826901, 0.11850810769933706, 0.12397053683668913, 0.13337950746736538, 0.12968522377788394, 0.11509069678451744, 0.13902953261707351, 0.12176762440806776, 0.16557069878428832, 0.21519008671753437, 0.21534760318789725, 0.19058798914775343, 0.20852690661887585, 0.19776027256577722, 0.20497900933434543, 0.21103550414618388, 0.21677138825859688, 0.2191333294142913, 0.13473775224362783, 0.16711839269625284, 0.14640986421030866, 0.1507035572912908, 0.14675177572923348, 0.14704052233466414, 0.15099140455418747, 0.1689783616727505, 0.16175870474109233, 0.1655323780752218, 0.1730120222567666, 0.16360817985113862, 0.1825990198045856, 0.1612822284050932, 0.16358639477959058, 0.1591089671506828, 0.1653645361314282, 0.1645616238312423, 0.16588159431862937, 0.1582831860184235, 0.17288629527222799, 0.1569555398597613, 0.14640528248439932, 0.16272314131465426, 0.17931249236669677, 0.16902272763015957, 0.1667323951190287, 0.1563131477556985, 0.13415421522852233, 0.20500004667069782, 0.15942302620448467, 0.159702136383174, 0.15980815952224003, 0.13614250529699512, 0.15448815899517487, 0.20029268468011674, 0.15721623849512512, 0.23669688384393273, 0.16111084271680065, 0.15397242001484068, 0.13075416917369165, 0.13497515355336054, 0.18973709774119274, 0.1871539056794258, 0.188871520856013, 0.16178582051452362, 0.17410756635824876, 0.1807411024232357, 0.1817765784945392, 0.17662206258573565, 0.16391608594778173, 0.17749444275756665, 0.16990425369287054, 0.16579175343600205, 0.058934813240237194, 0.05804073812718902, 0.05237053966636651, 0.06409940431223371, 0.06158251740284593, 0.05437753699465542, 0.05811034968264339, 0.06152810319066471, 0.05988568007148409]}, "mutation_prompt": null}
{"id": "f1c0984c-cfcc-400c-8308-f11db517eec5", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.5 * progress_ratio) * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01) \n                proposal = np.random.multivariate_normal(self.best_solution, current_cov / (1 + progress_ratio))\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            if evaluations % 10 == 0:  \n                for _ in range(3):  \n                    random_index = np.random.randint(0, self.population_size)\n                    if func(elite) < func(self.population[random_index]):\n                        self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced stochastic elite preservation and progressive variance reduction to amplify convergence reliability and precision.", "configspace": "", "generation": 92, "fitness": 0.22942271290194433, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.4927523124970139, 0.5518937872673908, 0.5109147725943642, 0.49869981235369554, 0.48930466342852186, 0.5016151401612254, 0.47534655256175506, 0.5375442213398416, 0.539238773017334, 0.20715128947240402, 0.23961798719455996, 0.3073333884510072, 0.1957479171738884, 0.21559409221201908, 0.19970636706773648, 0.2269463884023296, 0.20431051028710512, 0.19731256713877876, 0.12127940580021479, 0.09168047428435488, 0.09736842714385852, 0.10701151945989673, 0.09002837820648169, 0.12662583306809994, 0.10795127404260363, 0.1222788197561887, 0.12248451867117183, 0.10366887704014238, 0.09584561134005543, 0.10961168908048602, 0.09574480032603228, 0.08986205553456073, 0.13190877158944658, 0.09662379252313336, 0.11919278671804934, 0.11297908422024172, 0.8694320421344324, 0.885443594512211, 0.8826231008483287, 0.9179219345225906, 0.8787963072736178, 0.8617149138844007, 0.9203236112479216, 0.9167358799372901, 0.9801258401960132, 0.236609499135084, 0.2719944725086375, 0.21166710636263042, 0.22956406879471358, 0.23917286746412703, 0.24406863056586403, 0.18231652048954972, 0.22372471822357165, 0.18031464036725575, 0.25298163279500363, 0.48340831637469617, 0.5183017208404397, 0.5158890026115686, 0.5884011861209553, 0.2548873380877933, 0.43156591433864544, 0.5274495140158337, 0.5418565530668945, 0.10540861934386792, 0.11880634796415945, 0.11762135696056553, 0.12141205742678562, 0.1368400020673145, 0.10600830258378424, 0.13330335275056948, 0.16236719786818854, 0.1286544911635672, 0.10151362185482704, 0.1290711892199895, 0.1458475274040999, 0.11345899071702792, 0.1509030931869504, 0.12664135738947502, 0.11260456818101738, 0.14111482770649886, 0.1384479069454887, 0.11472558454988435, 0.047558628241683665, 0.07220634485087307, 0.07273174884161104, 0.14316431488559955, 0.05072948028663382, 0.09755675036832767, 0.05663331148083994, 0.015271475546716484, 0.23202824064971472, 0.1847730337882708, 0.16572310565428539, 0.10616271181618109, 0.11857491707213352, 0.07548747998511407, 0.07395012335562623, 0.1385456857077263, 0.259419895275688, 0.06017787703810207, 0.02094998283553029, 0.02993124748978493, 0.03189446386550787, 0.03303193664386417, 0.042842488275232626, 0.02166251545375275, 0.04937378217333277, 0.034463868119222196, 0.09993093904725958, 0.09798456792791077, 0.10668092229404169, 0.11274619585129642, 0.12422696499350327, 0.13213616517693094, 0.1288854725125841, 0.11216254726655173, 0.09129199239675767, 0.41129154707511884, 0.39657020299862145, 0.40543334922398166, 0.4223626396530543, 0.4307392538075909, 0.3775748281697371, 0.4292159538721102, 0.40349973113821347, 0.3953902356298278, 0.07910150158260798, 0.0943367355909358, 0.09554903989573049, 0.08152815478933795, 0.08239281216856675, 0.07544364924229574, 0.07365455334590065, 0.06261428132702207, 0.09760427092540358, 0.1340603796150679, 0.12126458129615625, 0.11842175776965758, 0.11341244319887878, 0.10852972522114035, 0.11061736932014032, 0.12066141986922918, 0.13819480332451817, 0.15624275177645575, 0.2716560751460153, 0.2787958945796464, 0.2751285011597724, 0.26106042244383876, 0.19128013440073943, 0.24916444389702397, 0.2891604570604641, 0.2815978537162911, 0.22952207616799214, 0.17887063245305923, 0.21010277055537474, 0.21237525664330736, 0.1934885013368175, 0.2128023075673574, 0.17508520873368794, 0.21544504686325228, 0.2441259465391309, 0.20916711415905087, 0.18002673214775933, 0.17717053605312305, 0.17263819512655432, 0.1710363546933369, 0.17235124037660465, 0.16427033504215582, 0.2038299104612823, 0.19668488148353158, 0.16913358229778297, 0.18114809405903332, 0.2755771572954091, 0.1871071495288944, 0.21634963084516734, 0.16987238821042083, 0.1747573243712901, 0.1595576914883048, 0.19259126240898428, 0.18312182721420445, 0.16319530320283482, 0.3118483346656552, 0.6055884953986352, 0.5682734326342604, 0.14336588203960887, 0.4934927245274926, 0.13568900018924834, 0.5328845158843429, 0.16080661204123425, 0.461440509562862, 0.20209166419770108, 0.6306368144149804, 0.5528109086576837, 0.18524052409678027, 0.18547002809937796, 0.20258476627271238, 0.19611355592998747, 0.24896904662036212, 0.1548859877628791, 0.17644314727269816, 0.1742842044513172, 0.16892959442012834, 0.16444284490164884, 0.16254811589847962, 0.16528547114348624, 0.15526193546787814, 0.1801346920681226, 0.06242174452385574, 0.06837472586117077, 0.04833158279150085, 0.06658703356195816, 0.07583973075150441, 0.07064332584083644, 0.07477167948718344, 0.05307565453747465, 0.06467232868981287]}, "mutation_prompt": null}
{"id": "28c158f6-6213-4dc7-9c46-23df0b64c692", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.5 * progress_ratio) * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05) + 0.02  # Slightly increased random adjustment\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced mutation strategy using adaptive scaling of dynamic factors to boost convergence speed.", "configspace": "", "generation": 93, "fitness": 0.23697466544074275, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.5818810290882022, 0.564222817029322, 0.5922998407914558, 0.5409408962594147, 0.540816653582255, 0.5513755997866363, 0.5418002162759523, 0.6294874296011509, 0.5814158652086345, 0.21809105062409262, 0.23175051554565507, 0.28717260039747894, 0.2806454865386919, 0.2904881035769501, 0.1523620106111515, 0.28748895360863236, 0.29215621469489306, 0.2778594278948694, 0.08291531989263656, 0.08613724282029611, 0.09648224658460514, 0.09582411964604487, 0.09498905595675555, 0.1203725994978404, 0.10685765031371297, 0.10617167321124255, 0.16942537824221104, 0.09393010166327964, 0.11238248997549305, 0.09570347554667658, 0.10046537164893399, 0.08834589477533661, 0.11128220146994683, 0.10376341880120599, 0.09324033166180457, 0.0968658919890637, 0.9145936323199404, 0.8702046509494098, 0.9218921905677716, 0.9273281481573123, 0.892626251493606, 0.8281471599642175, 0.8419708899436054, 0.8983306510071746, 0.9797522999816443, 0.0699485468977813, 0.2508593143187884, 0.2194080915672777, 0.2813435004843515, 0.12492696758311028, 0.2587169759800141, 0.08212613489926168, 0.17917418546314712, 0.24721416013382103, 0.5907019275352381, 0.5898392557350851, 0.2685556861907945, 0.7205075835721926, 0.5866158324254435, 0.3143466222184713, 0.5831490340152143, 0.6531324566132366, 0.24581475214429582, 0.12956660458917213, 0.1304186395736382, 0.1471268906170735, 0.16887848294121255, 0.16963758735365841, 0.10465923873809335, 0.10035170120764558, 0.13949385221974153, 0.11640192366302948, 0.18750426003523812, 0.00956104273358882, 0.11967955007127462, 0.1333362127032207, 0.13666045899193446, 0.1573395209556384, 0.11600757191199351, 9.999999999998899e-05, 0.12542588815099576, 0.04845730448765151, 9.999999999998899e-05, 0.04569143584300617, 0.1468989778682439, 0.032610126334055134, 0.09011364429876634, 0.08415886824677088, 0.07975104222549778, 0.10435575317047385, 0.1263933698179862, 0.08516917557604697, 0.10329030801046357, 0.09726807599410092, 0.06268563415372042, 0.07868973520218736, 0.16433481784895643, 0.12834006940878717, 0.16598612413504776, 0.08595849986094817, 0.05598228240416214, 0.07315565882646258, 0.04093308397947881, 0.08977428874377635, 0.0341002946390383, 0.05045131001794401, 0.06586680750069185, 0.056714245212166725, 0.11682465521454777, 0.11995631550983832, 0.1301968310876187, 0.12773815385651976, 0.16666718922435486, 0.1492394956126516, 0.11896539154362928, 0.0690431951830296, 0.11213187754332177, 0.48179361687395816, 0.4187235222940938, 0.46070572214806194, 0.44665924784853794, 0.4086961941929651, 0.4211112167769726, 0.46658507803945104, 0.44481620970982105, 0.4484867717072787, 0.07470563247787632, 0.0918681153250871, 0.07338541676397747, 0.13788645155315682, 0.07124912375033032, 0.10866155972853098, 0.05913507013857766, 0.07034468084660361, 0.11580392321968336, 0.13188705235943232, 0.09046910410687747, 0.1184217577696689, 0.11417137004678846, 0.15644159489562026, 0.13653683494342728, 0.1768950046369826, 0.1319707718580596, 0.12940400184596312, 0.22513520705879364, 0.2975367215763818, 0.3069167945410094, 0.31898170253195135, 0.2770946163414727, 0.30235927913821947, 0.21967611806434695, 0.2478528630416681, 0.3107318254553123, 0.19708381888245463, 0.22871403296494386, 0.22314124365777177, 0.16195338404335102, 0.20986459440525163, 0.16717878767072447, 0.12639694125212064, 0.2169709524180644, 0.1484865285207979, 0.17041279001901788, 0.20717714467167547, 0.18534990444940191, 0.1833746073337701, 0.15199991262576062, 0.18117894281384095, 0.1829663304474991, 0.15949792171287458, 0.14577465939054168, 0.17731789883787186, 0.17938623238363216, 0.5087614223857084, 0.17601905861409883, 0.19271583500597866, 0.16887885041255535, 0.15438314708322454, 0.18048500193945494, 0.19422163425697236, 0.156007367210809, 0.16210391846536443, 0.719418171528786, 0.22114165798053786, 0.6509185048675286, 0.17266597064457945, 0.1401435199364901, 0.16243418025233713, 0.6979034590484466, 0.37865831942053285, 0.20253232906336405, 0.6821074117519387, 0.49130542062649685, 0.11923364412673987, 0.1914647328280531, 0.37765984099051353, 0.20611423213852287, 0.5908404701408168, 0.1649914349851893, 0.16748980202872832, 0.14763022729676267, 0.16195809526888794, 0.15524169814205457, 0.1737872123742007, 0.17135576708615208, 0.16754243005603153, 0.2016232737521274, 0.051214043746685256, 0.05780554437416141, 0.049277631441153824, 0.08086780409284333, 0.06438287726754865, 0.07299533745260256, 0.055050397381049554, 0.049926618080617824, 0.05916309553165555]}, "mutation_prompt": null}
{"id": "5258c103-0f3f-4006-b251-0afb55b27153", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.5, 1.2)\n        self.weight_decay = 0.97\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        dynamic_population = True\n        \n        while evaluations < self.budget:\n            if evaluations > self.budget / 4 and self.population_size > self.dim and dynamic_population:\n                self.population_size = max(self.dim, int(self.population_size * 0.7))\n                self.population = self.population[:self.population_size]\n                dynamic_population = False\n\n            new_population = np.zeros_like(self.population)\n            elite = self.population[np.argmin([func(ind) for ind in self.population])]\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * ((1 - 0.4 * progress_ratio) + 0.3 * (success_rate - 0.2))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(0.5, 0.9)\n                F_dynamic = np.clip(F_dynamic, self.mutation_factor_bounds[0], self.mutation_factor_bounds[1])\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - 0.5 * progress_ratio) * (1 + 0.3 * (success_rate - 0.3) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic, 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = 0.7 * success_rate + 0.3\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.7\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.2**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolutionV2", "description": "Integrates adaptive population resizing and self-adaptive parameter tuning to enhance convergence and maintain diversity.", "configspace": "", "generation": 94, "fitness": 0.21526598876946113, "feedback": "The algorithm EnhancedHybridDifferentialEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.4820222552316852, 0.4931757976573842, 0.5273090047898876, 0.5062857266596508, 0.4615864309869091, 0.4797716131299983, 0.4657888770245787, 0.4783723928139798, 0.4368353494060887, 0.17161132243461796, 0.2173635571130228, 0.2268601480458382, 0.16829285343371736, 0.19406999148579507, 0.19848855837129786, 0.15759282040864742, 0.18750170912768727, 0.16005711413605805, 0.08934478080220598, 0.09288998952517413, 0.12138428210645891, 0.11978109542140924, 0.1074038806832125, 0.09113505483321604, 0.12486116960931104, 0.08926389077448982, 0.11257378510716554, 0.09760777883976024, 0.08830784946731551, 0.07884582056618694, 0.10806993327195435, 0.07842896231966756, 0.10028151445952282, 0.10589106505174573, 0.11055378684958617, 0.06683452128718059, 0.8488582559018645, 0.8793017909294483, 0.9119472504851833, 0.9507581090085166, 0.962258419860044, 0.8709546793139773, 0.8765511136502397, 0.8679978505396038, 0.885588639265087, 0.22199092773344997, 0.21771993931999045, 0.19981839141823132, 0.18947599584514796, 0.23872926115961546, 0.12642122229263952, 0.24932592108174134, 0.2254152951096775, 0.17093838787787785, 0.4636697906947532, 0.5962423477672181, 0.2767802945894231, 0.42701010487684954, 0.5994061340331232, 0.45409696652650555, 0.2863639855471305, 0.5226124533425212, 0.531236588155408, 0.20408488722901352, 0.12824095829659965, 0.13078793130585853, 0.11859954685603458, 0.1605862245725138, 0.10567890390998635, 0.10961949813193128, 0.1096255755304153, 0.10261264753151722, 0.1182724160837253, 0.08889689567084191, 0.15758366972188087, 0.10337966684096667, 0.14149078010398553, 0.12920944188135597, 0.10364064241622017, 0.11342992343034364, 0.2034384454460867, 0.05971897861702469, 0.08348218662801077, 0.054690448648122, 0.0008589006808884525, 0.023645668340996795, 0.025755094857005334, 0.051762486546072295, 0.09725435392303405, 0.04282640607485555, 0.13249983771992213, 0.18136420901113115, 0.1797907539513801, 0.11676376737247174, 0.20969375896957432, 0.1267283520194984, 0.10174666140155564, 0.2017871900413558, 0.09872111343288381, 0.014007974271415868, 0.03315699889748136, 0.014023209870559161, 0.03349911342862999, 0.06530749328868701, 0.026774615601855345, 0.04946914798951452, 0.06496722783784059, 0.053229653023089685, 0.10078407037764991, 0.1088297836619635, 0.12206976774306255, 0.09955709812186919, 0.12010946703858094, 0.12023055448630782, 0.12602566244222235, 0.11095224038280316, 0.13971602624953117, 0.3810939466943931, 0.4122895176943252, 0.40353061430922577, 0.3911089558916294, 0.3503863201438513, 0.3565676307537382, 0.445963814403011, 0.3726995237132553, 0.3787157565406295, 0.06568107862929029, 0.08167233808644614, 0.10158307765483587, 0.0717848659196556, 0.08860588734146368, 0.08831850527657936, 0.07029084528822283, 0.04976104181649166, 0.07663853072085891, 0.0976921850397755, 0.11733930020996053, 0.19735568449141339, 0.1606213272950454, 0.1471112039920245, 0.10798713552666539, 0.1363224175538147, 0.16270652578119138, 0.13897680280525182, 0.23947416257766974, 0.27880499243085155, 0.29229719371009544, 0.23946865454406463, 0.18751293358140764, 0.2426952628826462, 0.28687767004139086, 0.2543355476518494, 0.2726526671405558, 0.197698111434779, 0.16754828337059957, 0.2205455345596219, 0.2066074211665606, 0.1712336449900982, 0.17154115709943085, 0.2169131198677614, 0.1931043400819924, 0.1883635027817283, 0.17879876085387092, 0.17970104651302632, 0.17324229668571, 0.16857699486913902, 0.17545485111224202, 0.149417238254973, 0.1509890258843143, 0.17498419837218193, 0.17411159704901025, 0.1846220656060512, 0.17773997017006826, 0.180872843138977, 0.19482464665500743, 0.19586299900044835, 0.1644851496450157, 0.17145395981965117, 0.16999168644557194, 0.1601796274847611, 0.16824946075358405, 0.15104919656230886, 0.1816453286622991, 0.17393130035221416, 0.18567464528443034, 0.1699271771918589, 0.17502670442209256, 0.5772391644836863, 0.15402620399048206, 0.5193499952051284, 0.19514635409416237, 0.16312583554252502, 0.1832125886598952, 0.18374045584179377, 0.4475686279791141, 0.19850673233033045, 0.40861810656988296, 0.18737199673865512, 0.17716877562244304, 0.18859320531794432, 0.16436171936838673, 0.17072619690237678, 0.15319869374520967, 0.16651391319496034, 0.15735908203183846, 0.16400097098235022, 0.16143151852570425, 0.04958171148450752, 0.0534927465027033, 0.07884498938197215, 0.07714291008893892, 0.07496075123058776, 0.052952721158687543, 0.06855190152309665, 0.06131068609480739, 0.07917008787067603]}, "mutation_prompt": null}
{"id": "dc1cc06a-c768-4fb0-8bcd-29183c7c7de8", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.5 * progress_ratio) * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                F_dynamic = np.random.uniform(0.55, 0.9)  # Adjusted range for stochastic scaling\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.03, 0.03)  # Reduced randomness range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate) - 0.05, 0.1, 0.9)  # Fine-tuning cross probability\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce stochastic adaptive scaling for mutation factor and dynamic crossover probability to enhance convergence speed.", "configspace": "", "generation": 95, "fitness": 0.2218889446508428, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.5893285231219112, 0.5657268300964183, 0.49341482508048284, 0.5424256938067372, 0.5393622143553212, 0.5991610630881885, 0.536334570174166, 0.5523167646017526, 0.5686729583908186, 0.25119051631560974, 0.2554423205155658, 0.2876845311341545, 0.26936297930069764, 0.1715606085659629, 0.2674703360528615, 0.22360533044140596, 0.2843803821803671, 0.2917610977380679, 0.13344854083295654, 0.09966466436636767, 0.10606052862089, 0.11721605071926955, 0.12539915220305498, 0.14170048784750944, 0.11378483792663852, 0.11688932390152096, 0.115218154780522, 0.11534873226090625, 0.11029185838189282, 0.10913691235165335, 0.1200780408930956, 0.07910860890077043, 0.10662948466686517, 0.07645851928486569, 0.10545187982320836, 0.09681268786475117, 0.9279496084595852, 0.9174027477503057, 0.8327863683463603, 0.8357447037892098, 0.9034440352218008, 0.9015762290572212, 0.8639796913057609, 0.9124148538084027, 0.9498431126499058, 0.2586130070388578, 0.2314728635576374, 0.24187643276378745, 0.2652644072163076, 0.22018077215337295, 0.32357763056427835, 0.23301257195066694, 0.2573624371861156, 0.2472178410652317, 0.20310708482468398, 0.21202633461486053, 0.2501850405532188, 0.20111030132126406, 0.2936122271486221, 0.48086980374962096, 0.45593973892479744, 0.16829405887159532, 0.423305350889834, 0.14048008868958517, 0.18269767207579357, 0.1415878327803317, 0.18162078256605296, 0.10853458167117791, 0.1358044380588479, 0.16689368186000197, 0.12297115647837742, 0.13609023661195185, 0.12295427739523368, 0.15932989500342887, 0.14743133464456915, 0.17380825627962182, 0.13482238098537414, 0.1820596345893396, 0.12364303970460222, 0.11551404732739279, 0.11360843397596543, 0.06860500494173516, 0.03571520263324657, 0.007264178587486403, 0.004119389031112641, 0.04862113875813556, 9.999999999998899e-05, 0.065757528849267, 0.05102343368838791, 0.017694749983567126, 0.24412689993765457, 0.18206567624918557, 0.09764429273851727, 0.11622118664022019, 0.01859988821151415, 0.07451879459432476, 0.08947883758164332, 0.10781208353178573, 0.1608528438296687, 0.0709867663736029, 0.019836940035114825, 0.06996724158046852, 0.06938648445367235, 0.03911137894642491, 0.05234288893075878, 0.028235148033351143, 0.05304170050482482, 0.04067741588983376, 0.1357124292298526, 0.13876828737309788, 0.09058798336274887, 0.16839142758944892, 0.14655706569926474, 0.2193186170702467, 0.11759898448252482, 0.11305414302558292, 0.09476257617266093, 0.42514576100162604, 0.45618543982662174, 0.3668791844911671, 0.41641113422150733, 0.3966181423048514, 0.39948046477662824, 0.44599858715707175, 0.44555051359365583, 0.4134054143685667, 0.0979920608499042, 0.09496372036073686, 0.09227463412355608, 0.09505517444532363, 0.0884746595495206, 0.06424277823622337, 0.06914764389416506, 0.1148667842140445, 0.07522025193720783, 0.1479643033971344, 0.1108780440921322, 0.1331446511993003, 0.2711136179973862, 0.19668322644802283, 0.107112193740871, 0.14671939578260318, 0.16843947753859234, 0.10604909642394555, 0.18194982295952244, 0.2494783144215117, 0.29029246123791697, 0.3205999386921138, 0.29980075407999607, 0.24017306926969284, 0.21208339869111492, 0.212599715794914, 0.330282957496256, 0.20353422002132882, 0.20801085193595292, 0.22903666550036483, 0.15951065637710016, 0.18288695415215994, 0.189028137598391, 0.21046487441831752, 0.22072312667285698, 0.2883487324492787, 0.17174396350274457, 0.20370821430787245, 0.1853393625288774, 0.15256446789436218, 0.17185562850591418, 0.1608423923736818, 0.20539310002608235, 0.17325643242308741, 0.15380207118439726, 0.23207580233000324, 0.18987278427699616, 0.16721867741973495, 0.22849183287957409, 0.15739121074735818, 0.17177770516529145, 0.1908947660222955, 0.1729119211481942, 0.18865527769472845, 0.30016382587313195, 0.17167061259061434, 0.18013221205568375, 0.7166064056387729, 0.18946897540226015, 0.14587407529386276, 0.17650592020534384, 0.1595220814958911, 0.5044446118758246, 0.11040265245322212, 0.1997030533896239, 0.18134565642100575, 0.593000393676973, 0.17711559727913295, 0.15239459686215573, 0.1939733792784899, 0.1470935012459348, 0.15192437035956208, 0.16341261293690645, 0.15584229514560888, 0.17375977870851966, 0.16375924767266603, 0.17073950492443313, 0.1812182639245149, 0.168123226552491, 0.1654334936793861, 0.16261415472931018, 0.053482767657262564, 0.06659953517608974, 0.05862623492296648, 0.05365238703537978, 0.06112295495277997, 0.06946703171549473, 0.06991913581478915, 0.07654756955081121, 0.07125366530368427]}, "mutation_prompt": null}
{"id": "130a8f40-98e7-4ebc-a2d7-4d33e3a79f39", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.8\n        self.mutation_factor_bounds = (0.5, 1.2)\n        self.weight_decay = 0.97\n        self.success_rate = 0.3\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            if evaluations > self.budget / 4 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.7))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite_index = np.argmin([func(ind) for ind in self.population])\n            elite = np.copy(self.population[elite_index])\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                dynamic_F = self.F * (1 + 0.3 * (self.success_rate - 0.5))\n                mutant = np.clip(a + dynamic_F * (b - c), self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    dynamic_CR = self.CR * (1 - evaluations / self.budget)\n                else:\n                    dynamic_CR = np.random.uniform(0.5, 0.9)\n\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, self.population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    self.success_rate = self.success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    self.success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.0**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            self.population[np.random.randint(0, self.population_size)] = elite\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Introduced adaptive population resizing and learning-based mutation strategies for improved convergence speed.", "configspace": "", "generation": 96, "fitness": 0.17236876019161487, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.34144807040297387, 0.3269614174886205, 0.3524424458578532, 0.3468160056025851, 0.36099981288918703, 0.38310198204314827, 0.3817849545242942, 0.3562434802447798, 0.3596936476893319, 0.0907269807003569, 0.1041285536682095, 0.13228930550238016, 0.11641618199739334, 0.10220324778425671, 0.09883388224997014, 0.08851441635679769, 0.09142964000014597, 0.10597649933414544, 0.09646970604475158, 0.09783784604671242, 0.09089299729264455, 0.08461978531747805, 0.09956937593384696, 0.08976715975954908, 0.10381186803125819, 0.08179798787505954, 0.11449930549608711, 0.08242129612736293, 0.06780604976808136, 0.08307852472425126, 0.09673063131182569, 0.07376473250524085, 0.07686113817117934, 0.08556148060919799, 0.07218584042245946, 0.06955204612887245, 0.85545592776986, 0.7955321142570486, 0.8798049291230146, 0.8328280782627601, 0.8570389938208471, 0.8482018830188187, 0.8967517350064389, 0.8768639157900886, 0.8449677889878852, 0.13906507493704034, 0.12502121384074216, 0.11542564721823878, 0.14521887924126753, 0.13240656016641694, 0.1530742521298213, 0.14457075908357042, 0.13659636625143978, 0.1682305262532705, 0.21993056582035497, 0.25551737596255997, 0.17309596980549413, 0.2420904964070575, 0.2189054933637251, 0.23440487346866934, 0.2163149385128299, 0.23690132470773873, 0.21051932813819163, 0.10302684776278781, 0.07398483238761167, 0.10154546306740198, 0.08161386554477135, 0.0962545610209008, 0.1288381805593123, 0.09549190494320714, 0.08870263718169258, 0.104617945596023, 0.0684889441260007, 0.05308717887923342, 0.050729289107713016, 0.09704586661449344, 0.09700629489561963, 0.06957626800654193, 0.07774216532972, 0.07147383258863882, 0.08300120436392922, 0.001839440815916693, 9.999999999998899e-05, 9.999999999998899e-05, 0.003273920114652773, 9.999999999998899e-05, 9.999999999998899e-05, 0.00368446609770412, 0.021450851504372426, 9.999999999998899e-05, 0.12294471499224968, 0.11159098596953176, 0.09013379826522228, 0.08168026708935161, 0.06652848720350468, 0.07061316894714487, 0.0679102563132361, 0.10004391219215047, 0.07773881166398877, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0022269200204174666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07414564231739063, 0.07129253220720144, 0.06673289195401266, 0.05649628468588508, 0.0460601569441389, 0.07071775644277456, 0.07697588236229991, 0.05271105252242647, 0.07231982329518816, 0.3188134142533834, 0.3411579292107777, 0.3493913781259008, 0.33586674241542047, 0.33389824302137994, 0.3249578451468875, 0.33805540906968323, 0.3220456543926007, 0.3432644103974172, 0.07554693557681547, 0.07811668604813982, 0.07067967190904567, 0.06598697845856294, 0.08702269466854995, 0.07272275664398242, 0.0743005197515646, 0.06195081339418085, 0.06779091964978012, 0.1705707830061729, 0.131454975121296, 0.13203015192894452, 0.13044455067258298, 0.15459237068257226, 0.1327742000225144, 0.17874800261263446, 0.13049400697067193, 0.1873896120572316, 0.22348131071597255, 0.20319271360543467, 0.20942376432354393, 0.23399876519867435, 0.19477498084059186, 0.21773803532041336, 0.24204212820270044, 0.24411263861847787, 0.2177186538372604, 0.149028437944571, 0.14753484728233912, 0.1675952874478298, 0.14859540992239506, 0.14671158333443868, 0.16784223945676036, 0.1465743802456715, 0.1574550437165153, 0.15864564071185128, 0.17090800902992087, 0.16210570780663636, 0.17387700861070554, 0.17069218191423474, 0.1658381650437214, 0.16464917883537578, 0.18035846974122138, 0.15466173119501603, 0.19206165044347623, 0.16060993316941674, 0.1605714436169554, 0.1655522006001522, 0.16953527024866466, 0.1749082095793263, 0.16349143324011506, 0.1816424055509953, 0.1824464647890024, 0.17120301551564243, 0.22843569256749396, 0.2450746969530061, 0.16596662232729742, 0.29392883198470665, 0.31955745776191535, 0.17442205744884798, 0.16020487076119394, 0.1503019747922797, 0.36441426455233605, 0.30017768971348624, 0.17401092189094503, 0.2309751920469355, 0.2801714275889421, 0.15238339359442687, 0.16876471520838676, 0.1775602232180532, 0.19362301390718717, 0.22538201809411207, 0.17026834288956305, 0.1674949343477372, 0.18398074249301977, 0.17558542816904554, 0.17832881644153475, 0.17115889173708532, 0.18816469856753126, 0.18629392865326555, 0.16422364307747195, 0.06352193257503591, 0.062450569628182295, 0.06817412224481889, 0.06314036285366642, 0.06485071700832834, 0.06469599236399026, 0.061532858302138616, 0.0713317207123213, 0.054840826903969186]}, "mutation_prompt": null}
{"id": "def7d7d3-0400-4830-89ef-3db63298b7b9", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.5 * progress_ratio) * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                CR_dynamic *= (1 + 0.1 * progress_ratio) # Modified line for adaptive CR scaling\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduced adaptive crossover rate scaling to enhance exploration-exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.24543280449329832, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.6481407678594554, 0.5603565922563728, 0.581001239103949, 0.5792920512382139, 0.533817482029396, 0.5224575160916445, 0.6040871688614884, 0.5617567945242434, 0.5698542378649996, 0.31518241597317687, 0.30727517741762667, 0.2975394628667506, 0.23600729290337186, 0.25608408401465965, 0.24760324399182954, 0.3196121437816316, 0.3324208261005118, 0.2898695537097824, 0.0762554504333135, 0.10103158652579947, 0.1496507757708183, 0.0877661678580085, 0.11616872093953712, 0.12264990577721169, 0.13275459417038693, 0.11137426434262421, 0.11768330076018352, 0.12598245902978056, 0.09447927005435519, 0.09009853568959203, 0.09509469620389477, 0.09971172634489289, 0.08331667864475023, 0.09091276677090243, 0.08633000345582309, 0.03820164699021278, 0.9209341914127738, 0.8430456969179791, 0.8911750274970383, 0.8844369438330322, 0.908396482942227, 0.878266611967462, 0.8625115222431249, 0.9013275457181393, 0.9797562835573884, 0.0944244121515252, 0.26778760942527813, 0.1565923307216126, 0.2827762917042319, 0.2286559752633036, 0.2947617872321625, 0.2430613032572766, 0.24688318862352332, 0.28112967923396304, 0.20671315285889225, 0.27124466005264347, 0.6014602876492154, 0.7263761324954507, 0.5654438398169012, 0.19926814037909202, 0.6323855997169467, 0.604458973143956, 0.3305893075006693, 0.14884471207890804, 0.12137107699176064, 0.13293577574791893, 0.1228357489697317, 0.1486258678806578, 0.10782041080417326, 0.1267220800430412, 0.11360629762269636, 0.09929300063746271, 0.133097941018955, 0.12414205487663699, 0.1004328357500417, 0.10872142876544444, 0.14571693218512194, 0.1128994524085134, 0.12785636574618697, 0.15090780898366907, 0.22688863940377513, 0.06856769703603716, 0.05111572091405636, 0.029815079424230007, 0.00010389298158119953, 0.06448600440622099, 0.048823999427779596, 9.999999999998899e-05, 0.029772178014735418, 0.009602712853399087, 0.14558149665306896, 0.11396879622148315, 0.2128242239969238, 0.08262492587090797, 0.16239288382688555, 0.060646777714169375, 0.27498402817469403, 0.16984407225237796, 0.281423760946064, 0.08773353671166406, 0.03551954379702349, 0.052784816125383105, 0.078138865131127, 0.039858872848134164, 0.06263700104721415, 0.11808384653493553, 0.09253315426858277, 0.08278260398640391, 0.20747127373533192, 0.1414195534646524, 0.14661504632536848, 0.16251744230202458, 0.12175844255847135, 0.11625518796753453, 0.1446767716965085, 0.13580299726964418, 0.12573567618633918, 0.44166775946111625, 0.47162421393815934, 0.43566253779014663, 0.50770601092782, 0.4455652490331572, 0.443713803582619, 0.4847746298381469, 0.43613342536673194, 0.448019625908482, 0.08348340856772196, 0.07358364338872547, 0.08596398233078928, 0.09573019075041034, 0.076425804007624, 0.10878101239436944, 0.0812337366793845, 0.11850515420853713, 0.09248812131083595, 0.13845221518567996, 0.12364742517312277, 0.1184217577696689, 0.1643002461854285, 0.10852972522114035, 0.10330109231470197, 0.15541556947693402, 0.13090547648885276, 0.11535727559413389, 0.3034026866212586, 0.30714781009067615, 0.24263534699556388, 0.2708659400882094, 0.2251826380523715, 0.26532129402561566, 0.31870504455476856, 0.3335130019031036, 0.32571074183282334, 0.18775827995258465, 0.23349962456509143, 0.24899758125695481, 0.25473582527277105, 0.23219085695464592, 0.24959594337044622, 0.24588530169180356, 0.2098368553723735, 0.21773153779163523, 0.18400747656266314, 0.16510504248087676, 0.15221093776667172, 0.15431582282113543, 0.16574754160759408, 0.15104763860292858, 0.1692828880682391, 0.17309135329580838, 0.18705950514572267, 0.18561514441003724, 0.1802818389414449, 0.20311023528040073, 0.16388155450162645, 0.20446672870363214, 0.19427050139154745, 0.17941988440375045, 0.17557955529337232, 0.1968298833929244, 0.5833059093045889, 0.1497137308644485, 0.6470658946790219, 0.6742281321551848, 0.19034153999917724, 0.15417001877706804, 0.12439490538900622, 0.16246982594070125, 0.6535114380191027, 0.673829012035562, 0.20314334859394068, 0.6547873369705519, 0.5975279757730654, 0.15960169737569008, 0.14911764684962636, 0.15655381355547948, 0.4338953386707618, 0.6078325946277554, 0.17007376602560997, 0.18411870867641733, 0.17092420494869853, 0.18297474516815515, 0.1481448039713703, 0.16618427718059414, 0.1667350426355224, 0.17358955076373006, 0.17464196961582823, 0.07192586656306066, 0.08413438792830075, 0.06291354486512324, 0.05287466333687496, 0.050761328292230457, 0.04975186996669512, 0.07378964155215995, 0.05345802542624789, 0.056161387844918864]}, "mutation_prompt": null}
{"id": "bb94e4c4-2757-42c5-8abb-8d36cb70e2f7", "solution": "import numpy as np\n\nclass AdaptiveCovarianceDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 6 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.85\n        self.F = 0.65\n        self.mutation_factor_bounds = (0.55, 1.0)\n        self.weight_decay = 0.95\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.3\n        while evaluations < self.budget:\n            if evaluations > self.budget / 2 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.7))\n                self.population = self.population[:self.population_size]\n\n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.4 * progress_ratio) * self.weight_decay * (1 + 0.2 * (success_rate - 0.25) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.3:\n                    F_dynamic = np.random.uniform(0.4, 0.8)\n                F_dynamic += np.random.uniform(-0.04, 0.04)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.2 * (success_rate - 0.35) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.12 * (0.5 - success_rate), 0.1, 0.95)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.9 + 0.1\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.9\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.6**2 / self.dim + 0.02)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveCovarianceDifferentialEvolution", "description": "Introduced a dynamic population resizing strategy and utilized a covariance matrix adaptation technique to improve exploration and exploitation balance, enhancing convergence speed.", "configspace": "", "generation": 98, "fitness": 0.22697288804005705, "feedback": "The algorithm AdaptiveCovarianceDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.698140104976694, 0.7102771505132837, 0.68442572228344, 0.6968881433457614, 0.6502933532986213, 0.6792341148557299, 0.7166438569698694, 0.6963651356143221, 0.7185167669128221, 0.42698728822860677, 0.4901337455655914, 9.999999999998899e-05, 0.23263827519199665, 0.11718134366231503, 0.0007188764936505443, 0.3930471533847292, 0.3227828469264916, 9.999999999998899e-05, 0.11224318000936162, 0.1324979289580469, 0.13415825054170094, 0.13756089573969343, 0.10134792224916944, 0.11771477371010663, 0.11987459846812232, 0.11211551985063906, 0.07024302236329472, 0.10364164414097832, 0.09940788473404849, 0.07575806989918643, 0.1141649165079458, 0.1207518651619035, 0.10539954071264024, 0.10104329104900867, 0.08316535907790945, 0.10350845876669701, 0.9335095472487585, 0.8728037441521244, 0.8663507321459907, 0.7223093051476996, 0.9129798185519078, 0.7661095880461686, 0.8880505950712385, 0.9262604124763394, 0.9177926918548098, 0.270494497120793, 0.0733354761234355, 0.1669019552691241, 0.14009328373678676, 0.17235854477413215, 0.2722139054612954, 0.2846410200844093, 0.2528112041735562, 0.16758154817566506, 0.2229577500037161, 0.19633995495257772, 0.32372870328102676, 0.2286367432144948, 0.712166122238952, 0.2035821785450289, 0.730610378991885, 0.2121025699821948, 0.3263518327833468, 0.1789659466083856, 0.17626982507269406, 0.15925823067321476, 0.12788984211534693, 0.15848814709666126, 0.23809111312637599, 0.20292896669843574, 0.2215867568612626, 0.14628884028234312, 0.13092549338971549, 0.11173947800497752, 0.13048574452974737, 0.13797825049363, 0.17455907007176097, 0.14770294460190236, 0.1347009336415118, 0.1319669705830505, 0.14260412176751724, 9.999999999998899e-05, 0.066180270897785, 0.051304337418185186, 0.06562744322004221, 0.033397249779424376, 0.04927359052764657, 0.03680228634511584, 9.999999999998899e-05, 0.06156781616578577, 0.06428098267846016, 0.0344595385995804, 0.18083988405116336, 0.08895978060106224, 0.12802062738812092, 0.3125876226700951, 0.09681092850088957, 0.19482733699684218, 0.07135357588741031, 0.13515538607548983, 0.1021845265764072, 0.11035924052462254, 0.04952688310565523, 0.06199150262870301, 0.10791024806243077, 0.16416319313007421, 0.16888270256821292, 0.04946565157197125, 0.12076587230717728, 0.10754678052251077, 0.10405155117863019, 0.21098466035281438, 0.13207423581774203, 0.04961461907192277, 0.12431520664466245, 0.15248633061860406, 0.20688925760504717, 0.5345703356795753, 0.45921782255909616, 0.43376766866898475, 0.4537094752313945, 0.4572442965810841, 0.409525412386057, 0.5284242883336707, 0.43224626659725196, 0.4498336270251273, 0.09016684881711678, 0.09208306224870144, 0.07102388288679362, 0.06844544776778327, 0.05211271675787088, 0.09522777000837346, 0.06975454567402173, 0.08132981771522974, 0.07945046407178269, 0.17674533004341553, 0.08797469804707547, 0.11686403241011267, 0.12139507595661325, 0.11961995181632212, 0.1262196754947147, 0.09972490019264191, 0.09983660750849632, 0.12788910040346746, 0.23391060474801229, 0.17555534987445554, 0.27698327945707335, 0.20620316707578745, 0.24206564438673828, 0.34122425433163683, 0.23423086353447242, 0.2478824962845141, 0.38113745954371603, 0.15028816553405233, 0.19581363594450107, 0.25030959377500295, 0.22260396829082774, 0.1396730209539433, 0.2549721623608022, 0.22050130281841862, 0.20113796355432245, 0.2314702394544904, 0.17851057212929067, 0.1938972270146101, 0.18032987485509488, 0.17133519064065073, 0.16364080575796702, 0.20408956878469908, 0.18099206870568474, 0.1432658072437083, 0.17217587614082785, 0.17371216405387768, 0.19866228086616544, 0.2403680552006745, 0.16102616281038118, 0.18492813419303233, 0.17215317374374461, 0.18027680073072583, 0.22417238381808513, 0.18098299492890102, 0.16428949201861853, 0.18015531289943232, 0.14898342679730647, 0.16286869590218578, 0.19412807016699762, 0.19088953362738925, 0.11910201960362954, 0.1647067816638753, 0.31587636364832083, 0.45586586740364876, 0.15350080598717264, 0.20275078440765082, 0.06578678967686569, 0.1974631736004403, 0.1860799351302429, 0.14571909212823375, 0.12439157135654078, 0.8045938870897134, 0.16458377115677325, 0.15974936779124205, 0.147630227296774, 0.14175005530092022, 0.15588822810037273, 0.20634321557443325, 0.14969714796693134, 0.20099454845112863, 0.16093106687024572, 0.06036010015114168, 0.05549271949036161, 0.05884346456628098, 0.06220549439645218, 0.06183817208057352, 0.07561324273091374, 0.14937139421287626, 0.06355466139631405, 0.03982300210600764]}, "mutation_prompt": null}
{"id": "1503c1a3-b93e-42f3-9bbd-cf3f7d2ab531", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * self.dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.CR = 0.9\n        self.F = 0.7\n        self.mutation_factor_bounds = (0.6, 1.1)\n        self.weight_decay = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        success_rate = 0.25\n        adaptive_resize_threshold = 0.15  # Added adaptive resizing.\n        \n        while evaluations < self.budget:\n            if evaluations > self.budget / 3 and self.population_size > self.dim:\n                self.population_size = max(self.dim, int(self.population_size * 0.75))\n                self.population = self.population[:self.population_size]\n            \n            new_population = np.zeros_like(self.population)\n            elite = np.copy(self.population[np.argmin([func(ind) for ind in self.population])])\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_ratio = evaluations / self.budget\n                F_dynamic = self.F * (1 - 0.5 * progress_ratio) * self.weight_decay * (1 + 0.25 * (success_rate - 0.3) + 0.05 * np.log1p(success_rate))\n                if np.random.rand() < 0.35:\n                    F_dynamic = np.random.uniform(0.45, 0.85)\n                F_dynamic += np.random.uniform(-0.05, 0.05)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                population_diversity = np.std(self.population)\n                CR_dynamic = self.CR * (1 - evaluations / self.budget) * (1 + 0.25 * (success_rate - 0.4) + 0.05 * population_diversity)\n                CR_dynamic = np.clip(CR_dynamic + 0.1 * (0.5 - success_rate), 0.1, 0.9)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                    success_rate = success_rate * 0.85 + 0.15\n                else:\n                    new_population[i] = self.population[i]\n                    success_rate *= 0.85\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                current_cov = np.cov(new_population.T) * (2.4**2 / self.dim + 0.01)\n                proposal = np.random.multivariate_normal(self.best_solution, current_cov)\n                proposal = np.clip(proposal, self.lower_bound, self.upper_bound)\n                proposal_fitness = func(proposal)\n                evaluations += 1\n                if proposal_fitness < self.best_fitness:\n                    self.best_fitness = proposal_fitness\n                    self.best_solution = proposal\n\n            if evaluations >= self.budget:\n                break\n\n            self.population = new_population\n            elite_index = np.random.randint(0, self.population_size)\n            self.population[elite_index] = elite\n            for _ in range(2):\n                random_index = np.random.randint(0, self.population_size)\n                if func(elite) < func(self.population[random_index]):\n                    self.population[random_index] = elite\n            # Added adaptive population resizing to further enhance convergence.\n            if success_rate > adaptive_resize_threshold:\n                self.population_size = min(1.1 * self.population_size, 2 * self.dim)\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Implemented adaptive population resizing and enhanced crossover strategy to improve convergence speed.", "configspace": "", "generation": 99, "fitness": 0.1274122653900127, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.17.", "error": "", "parent_id": "9887bdb7-7881-4581-ba28-693e4fde289b", "metadata": {"aucs": [0.23116507038071976, 0.2794746071206706, 0.24081574777257975, 0.3316782611345266, 0.2001182282218913, 0.19513997577704445, 0.18999548823046375, 0.2617362301002303, 0.19485924324771509, 9.999999999998899e-05, 0.07444032872537065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04730338548244639, 0.0393392012594701, 0.09139906421426225, 0.06997533389085597, 0.06806874134349017, 0.04483877367137734, 0.018967339704773267, 0.08893120634217666, 0.05236186048743108, 0.030629785083881145, 0.01338745821964571, 0.01081573628217447, 0.05218820210822395, 0.04242488034937564, 0.029965439338866195, 0.04426692679352251, 0.024625850335586286, 0.05907828946372906, 0.930366609297183, 0.9306301296163177, 0.8982373037129283, 0.9305027241850494, 0.09764006574115025, 0.337891939579517, 0.9491340248071943, 0.9071508326562376, 0.9562279131302632, 0.0651430335455867, 0.07104176798042061, 0.03867842451374659, 0.02155420227245175, 0.05662689030924817, 0.11041439085435378, 0.11802840376486512, 0.05869850616151073, 0.025692252210297695, 0.1556032547102877, 0.08740741514073125, 0.13370934308140658, 0.15031752529528308, 0.14913186640920462, 0.09152096705045765, 0.08795398102729801, 0.11681517638861638, 0.10975887801841122, 0.0465456063785914, 9.999999999998899e-05, 0.04680999760350968, 9.999999999998899e-05, 0.012976902317991312, 0.0379148887899855, 0.0906405844487368, 9.999999999998899e-05, 0.010972417047651839, 0.06366007768762538, 0.08618907722724412, 0.09567298762759124, 0.06469438699054064, 0.05742676163208671, 0.07753197773829013, 0.1501632529351078, 0.05742676163208671, 0.10698579193413338, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05383476998994463, 0.05743497726266866, 0.04121951924696987, 0.05982737021796436, 0.004078655809193532, 9.999999999998899e-05, 0.0230536450754546, 0.13939217463652254, 0.05123991519376836, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017214936929302316, 9.999999999998899e-05, 0.08124619748899642, 0.07811106424644754, 0.08385890623692227, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20080932988666966, 0.18316860734674478, 0.26595902047677455, 0.20356328861186834, 0.15836455694903784, 0.25825038884181617, 0.24474996984324238, 0.34313865872702043, 0.1684976537270817, 0.05580140048901516, 0.050790060122448466, 0.0382615133067995, 0.03310809345098842, 0.03269565645933248, 0.07798409827939068, 0.030403017042556657, 0.05089185316838307, 0.05077783808379732, 0.09746705235470687, 0.08752841452202687, 0.14174324521628967, 0.12215609293727625, 0.10852972522114013, 0.09548274481213737, 0.10206895973026908, 0.13044199973837345, 0.09283599326209702, 0.17626437263173744, 0.19394731893529937, 0.16356848404014745, 0.1668781969395352, 0.15589668426681746, 0.13866874264753404, 0.1543265671159928, 0.22717177301970526, 0.1376677381608824, 0.11779133613363135, 0.12911983643250513, 0.13617843761674553, 0.1295005953546855, 0.09884001834358203, 0.09001241257732817, 0.13372125284057146, 0.0997711199450243, 0.11597873342235165, 0.2573254343397544, 0.2568549548178135, 0.2578890336603781, 0.2572005851689093, 0.2569995852827932, 0.2571007309196084, 0.25745972527746996, 0.2565646964718301, 0.25751127171911126, 0.16051748072372318, 0.11571193316596562, 0.14712249803298494, 0.1578010831019363, 0.10999038985396714, 0.16900853590753306, 0.17686869549311646, 9.999999999998899e-05, 0.15720642441543098, 0.14596209083562717, 0.1299202645629033, 0.241438722286052, 0.16715343734120092, 0.1675506301754709, 0.10809707135770785, 0.16290558423834722, 0.1444162607429298, 0.16678563698424187, 0.3002904215596185, 0.11046432742806833, 0.10446296521973686, 0.1443076837670364, 0.10938681792372573, 0.10570980839868571, 0.19234360612295665, 0.19719588213577322, 0.1648205816457814, 0.1516509862122155, 0.14651868485335184, 0.1494618109140763, 0.1526871262201177, 0.16728222448178698, 0.1424824241655811, 0.17125254076239893, 0.1517895082003139, 0.15184883281335948, 0.040582302440101525, 0.03781346466247559, 0.036335645399399485, 0.052582478545453726, 0.05430537099625998, 0.04946738744690993, 0.054281847226877344, 0.057198164904395665, 0.0767987390202749]}, "mutation_prompt": null}
