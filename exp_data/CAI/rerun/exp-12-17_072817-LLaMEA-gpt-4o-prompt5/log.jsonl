{"id": "30b87229-dc01-47cd-a8c4-d8bb0f2087ba", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Multi-Strategy Particle Swarm Optimization with Adaptive Mutation integrates PSO with adaptive mutation for robust exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.30123815356313693, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8694598673001765, 0.8528109907176165, 0.8529008493252219, 0.8641294096431247, 0.8570184337738794, 0.865720669994956, 0.8544478883406991, 0.8604237430596051, 0.8659531216137697, 0.6241957935261796, 0.6675746873339443, 9.999999999998899e-05, 0.6647786626603183, 0.046085863393319104, 0.6895228242489603, 0.4700706860630445, 0.700580757235642, 0.6825397061883856, 0.1833211805897913, 0.16060752931420808, 0.1677317252384819, 0.1408541040105663, 0.17768545464405872, 0.12844197579922856, 0.15658029058019018, 0.12513226674185407, 0.15040157497780182, 0.10127965936309336, 0.13192551860500623, 0.1083091497570835, 0.13020033437236456, 0.09379806430300108, 0.1482988378490856, 0.12610355006893192, 0.12051080494100241, 0.1541267716492417, 0.9844712884638271, 0.9922777224368696, 0.9851777633208493, 0.9693688947487025, 0.9855871110853952, 0.974732635658836, 0.9877275719770138, 0.9851318985216958, 0.9838907555985201, 0.68777954113363, 0.6476535727381171, 0.05909089383989774, 0.15287596320978936, 0.6736595638327803, 0.5684648644525103, 0.6603415207311605, 0.659185047865497, 0.664765396905439, 0.22754712014461798, 0.13908824320638746, 0.17247210796834245, 0.27548392854002224, 0.21368982314759066, 0.19865014116177482, 0.24439094222534385, 0.20181975293959953, 0.46373285818589627, 0.27896539739567516, 0.21765862647327716, 0.21367002117141565, 0.21264340738034926, 0.21703641256860706, 0.20356689995470234, 0.22366843492288646, 0.22735860575584899, 0.2198543982657849, 0.25765888642449675, 0.2308681439664788, 0.1174292386858593, 0.22754124492657335, 0.1129088099232256, 0.2972481259188732, 0.2466459171617693, 0.25599940738193017, 0.12592081409644829, 9.999999999998899e-05, 0.002909540167574942, 0.025938808248822, 0.00010166830554914075, 0.000125814212074693, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06031205364708547, 0.07047333212722129, 0.06028211801820649, 0.07905879859652964, 0.09442560188012428, 0.022023074634003437, 0.05393961082802601, 0.04743598395733317, 0.05681606154821861, 0.048216831870151466, 0.19456996702615947, 0.0476042089904084, 0.2288402780350296, 0.13280413656186552, 0.24514429280756178, 0.07461301011588295, 0.15856269901777664, 0.07096750226911896, 0.06942487542447329, 0.16542503693650146, 0.2175208326439002, 0.07008630333326671, 0.0819345830767042, 0.13745648457681459, 0.1728734436255116, 0.08831598948600072, 0.05587537853046998, 0.08144525118457202, 0.5517776327546005, 0.5562644493609796, 0.5285193128484258, 0.5462916061135046, 0.5065677169488957, 0.5039980415545009, 0.5370471873732225, 0.5675593116879697, 0.5522996175144127, 0.08530781175797897, 0.07061992246977511, 0.07813473403700044, 0.1052971108572972, 0.0819352000199679, 0.12194320668233871, 0.07758483487197809, 0.11593829327661764, 0.13927314430764526, 0.3489244621641986, 0.1796027057643803, 0.2306384951150242, 0.2114601901508688, 0.22927637359834285, 0.33573205229960545, 0.181860235011857, 0.22200425713746663, 0.3338526958171908, 0.28712003526122476, 0.23649449924431787, 0.4688822017839338, 0.5258405358751878, 0.27157476883908027, 0.22376065933788147, 0.407336329741375, 0.49198368187897135, 0.5063675325907562, 0.23085792403602057, 0.22406776895094538, 0.2548283424901252, 0.2087790371641698, 0.2499972826599317, 0.29078324762877705, 0.14013051525127462, 0.2640012872703663, 0.2766276402351231, 0.20027567708589367, 0.1612628148691181, 0.21588223899426962, 0.21057022231071965, 0.1846568538241179, 0.177759396439788, 0.25021508324731745, 0.2398085504825641, 0.2230449666603478, 0.21113028746202167, 0.21810402508106697, 0.24337174799523387, 0.19602768310790109, 0.2142779472762646, 0.18493153044596755, 0.23799210985419972, 0.22436404438922786, 0.773591515363882, 0.8970580077177397, 0.8741278349937919, 0.1544437772406151, 0.900386479855142, 0.2014429995105662, 0.17045959036350145, 0.14275433251731662, 0.1703453329427388, 0.9108134098924193, 0.799101548731011, 0.2134415823014415, 0.15239194807674217, 0.2080010069633228, 0.16897819339079434, 0.1534431506689381, 0.10384402935518833, 0.10389577635920177, 0.7888963538523515, 0.1978535073699509, 0.21457774919463402, 0.22634712381421507, 0.2269916109022707, 0.19450231147300678, 0.18932922501139748, 0.22292457807931987, 0.18372160356387846, 0.19906445873532663, 0.1149785801130132, 0.06569513569681129, 0.10792825656018756, 0.07492338626835082, 0.09080219656597133, 0.08552243760377864, 0.09083224780444743, 0.09822750433678362, 0.08773727986492175]}, "mutation_prompt": null}
{"id": "e927ab79-9fb4-45a9-8ff2-dc80e8828dba", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced PSO with dynamic inertia weight for improved convergence and exploration.", "configspace": "", "generation": 1, "fitness": 0.18176787660215668, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "30b87229-dc01-47cd-a8c4-d8bb0f2087ba", "metadata": {"aucs": [0.36681537713690093, 0.31692940421080595, 0.3897332295943037, 0.4380841658654543, 0.4446838633959075, 0.41479673518853577, 0.35297388033987076, 0.3932003995479889, 0.4003936253107365, 0.016365088412111484, 0.0002220453524277577, 9.999999999998899e-05, 0.05250897733053339, 0.014960152667542581, 0.02007274240611845, 0.0019066738023674201, 0.021181535750524727, 0.0567418703508884, 0.07703090384350086, 0.09186979126071271, 0.0669793174045673, 0.09716209637544437, 0.07603194147504544, 0.09661173157525338, 0.08123947130665332, 0.10708499575043684, 0.07947519840058848, 0.08075638646709538, 0.08245616464960404, 0.09847050781482503, 0.100290197013019, 0.06728586336893327, 0.09003969650689869, 0.07460337866652211, 0.07377317747945178, 0.09613895479378987, 0.9865590201944608, 0.9922743022748115, 0.9864220182254145, 0.9769616610124999, 0.9879879968486185, 0.9782139582610462, 0.987764636406702, 0.9877233163028892, 0.9857301712307043, 0.19351831947620501, 0.21187251761205672, 0.10885979057941675, 0.1491163660667535, 0.1688906266802127, 0.1387203400207021, 0.12163655780372462, 0.08658176137289608, 0.21411699421823327, 0.28861474621542693, 0.20695498816897184, 0.1725744799890202, 0.25771871477108044, 0.2564568752455093, 0.19433279830717454, 0.12722673583933597, 0.12529221868096208, 0.264370124599436, 0.1411814200511371, 0.0982409436156313, 0.1268260967963255, 0.08615866449044862, 0.13374131434857095, 0.11337618058634746, 0.11823938147722401, 0.13430663814348887, 0.10769885458799966, 0.12320184612940754, 0.08548761510060265, 0.04669332742681909, 0.1448400350043375, 0.0795573053767552, 0.11974353714497699, 0.12185986916560254, 0.08881649649188839, 0.1158147822154133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0066454284938488595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00020809282436096144, 0.05686511339457778, 0.05070253173613515, 0.06219023542175606, 0.06836911567201409, 9.999999999998899e-05, 0.0048151737796769956, 0.055651651514102896, 0.03552877530288756, 0.06628776809990344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01735964946012114, 0.03473123424098701, 0.0015815372899771196, 9.999999999998899e-05, 0.0020525291128921097, 9.999999999998899e-05, 0.0633369220900919, 0.060342065180654436, 0.060916322356372454, 0.011251756975758198, 0.07417372190300797, 0.06614526009728439, 0.09008105234912567, 0.04339265513927859, 0.0429793145356725, 0.36793186023909896, 0.3512830791336511, 0.35563379155631847, 0.32175555406851364, 0.35831405197224475, 0.3611475536552149, 0.33481304217163976, 0.34412187570652586, 0.33072596860192716, 0.07090035173552, 0.07344388158614623, 0.06069926634160061, 0.10156415776236916, 0.08499799455375434, 0.0776866692325131, 0.07925182387279472, 0.0666597778535557, 0.09428675139407205, 0.18165095240468, 0.15293683511395517, 0.18621309508143646, 0.1807299790142468, 0.19295000119454908, 0.22364836550818812, 0.1964484316841698, 0.18940748685253694, 0.15819325337374956, 0.24375190679639092, 0.22694897177995244, 0.22600458722638272, 0.21294592857501804, 0.19340675029277676, 0.2151576041931068, 0.2434428563274782, 0.25648823701025036, 0.28501160791210434, 0.161302869579792, 0.16053106682266938, 0.1546580077704175, 0.20145765073561295, 0.16025140517583436, 0.18571059646003318, 0.16316279619499596, 0.22386750347720308, 0.17792600009068915, 0.20555069488795885, 0.17775579117281082, 0.20506395774203257, 0.17776879318859207, 0.1967969123205896, 0.18377582220208033, 0.19360394724648922, 0.1705548573894744, 0.19853186686890534, 0.20508518373755813, 0.22202403650167646, 0.18173828685622595, 0.18912668687385936, 0.18935314150431437, 0.19120302965259062, 0.18189150096450524, 0.17505955493857395, 0.17466332622490277, 0.38746230011222893, 0.16707707261744786, 0.15436690641225936, 0.5021134482411239, 0.21075176606910095, 0.1955854973407546, 0.14130099644096494, 0.1698689169116484, 0.20630865927475484, 0.3344981764025228, 0.2092744643223431, 0.14784879721136257, 0.20225921051496798, 0.21642442307075038, 0.15181497374490427, 0.1926429180647753, 0.10965866631944465, 0.24567207143512215, 0.19311086877696693, 0.1797569086783224, 0.17861919934167492, 0.17345618846692323, 0.18599065730886477, 0.18274745365398148, 0.188569441786252, 0.19543810243605853, 0.1817152592472323, 0.068935376700901, 0.08551078734461659, 0.07338892329845237, 0.09843634464058393, 0.07450678943513667, 0.06922377745613428, 0.0727362493501107, 0.0828036455572978, 0.06486272737794785]}, "mutation_prompt": null}
{"id": "f8c1e98a-3386-42d8-a501-2fe09c96005d", "solution": "import numpy as np\n\nclass DualStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.crossover_prob = 0.3  # Added crossover probability\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Genetic crossover integration\n            if np.random.rand() < self.crossover_prob:\n                for i in range(0, self.population_size, 2):\n                    if i+1 < self.population_size:\n                        crossover_point = np.random.randint(1, self.dim)\n                        pop[i][:crossover_point], pop[i+1][:crossover_point] = (\n                            pop[i+1][:crossover_point], pop[i][:crossover_point])\n\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "DualStrategyPSO", "description": "Dual-Strategy PSO combines swarm intelligence with crossover-based genetic diversity to enhance convergence speed and solution quality.", "configspace": "", "generation": 2, "fitness": 0.29114003493094237, "feedback": "The algorithm DualStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "30b87229-dc01-47cd-a8c4-d8bb0f2087ba", "metadata": {"aucs": [0.8548903008439506, 0.8302555131193097, 0.8545502585759499, 0.8685768963742598, 0.8466899448295282, 0.855192670030299, 0.8568722192876775, 0.8742860177348386, 0.844741316693663, 0.6416838288248246, 0.04068432218035034, 0.6674656975821776, 0.6447428125565358, 0.04466845945869102, 9.999999999998899e-05, 0.6166421554416505, 0.6760488682198036, 0.6507116055809203, 0.176783039210895, 0.15805089995926824, 0.14694612069942758, 0.1414262449157182, 0.32941344771647674, 0.31513817290691915, 0.16216308681015434, 0.12179941981158648, 0.15408189690633445, 0.10841664207450263, 0.1388548157325762, 0.11866684619967949, 0.1515646159874634, 0.16739538656710173, 0.1267243518228437, 0.14872712873836957, 0.1462532917035655, 0.1312649285595766, 0.9845687250555989, 0.9922769705925867, 0.9856982726100258, 0.9727166487901193, 0.9813380550816126, 0.9671132753698791, 0.9875574400263994, 0.9852115012623739, 0.9779687777459215, 0.6342390079672413, 0.6914437508867589, 0.5154133102702971, 0.37600011844452663, 0.4929095874860575, 0.1537605346492894, 0.12558527122135477, 0.6132137579528958, 0.6691826891456579, 0.2435424421072646, 0.3801059638677319, 0.17206658497133398, 0.28097084103910597, 0.3791411959363088, 0.19336419157093088, 0.19417546144395315, 0.2324891395141041, 0.36979183028189677, 0.13079819130169157, 0.1285590615947283, 0.2031255640276165, 0.20396374544883733, 0.1324632579410676, 0.12657254143181818, 0.42494677915033663, 0.3454792029538909, 0.2999368300577685, 0.23158144553276327, 0.21316093438986217, 0.21676485271138723, 0.13118002759701575, 0.19673252566960697, 0.1982500344043715, 0.23934602214022294, 0.13570235776274753, 0.11768543507412232, 9.999999999998899e-05, 9.999999999998899e-05, 0.03379022478472493, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041690882423888076, 9.999999999998899e-05, 0.022067935625828095, 0.06996798044012598, 0.07441443892287547, 0.059694515307041396, 0.06369277538806706, 0.0036224513724409935, 0.007164729670487424, 0.03790258575759575, 0.151639449859307, 0.06299581169732915, 0.04729551065481574, 0.0341950800808245, 0.12133024997438535, 0.07783062655082773, 0.21751806524525485, 0.08750418285300854, 0.22350725884756717, 0.1745417594805756, 0.08663385085883524, 0.17112684625441288, 0.12101909328036109, 0.05687763789395561, 0.02283670644512381, 0.08339207952965044, 0.07862693637965024, 0.13257691433005114, 0.05810306516779706, 0.08311075978106897, 0.5094888815441646, 0.5146378706556308, 0.5435390000190545, 0.5046049069187144, 0.5481034221691485, 0.5325057480306845, 0.5375802419593892, 0.5618574788142883, 0.5516780152477492, 0.08640629393804466, 0.09474345925898886, 0.10336859893207162, 0.14068747714669994, 0.1364032236758127, 0.11192017336988958, 0.12423240195181062, 0.11081389111783413, 0.11490554891543436, 0.22476303422211685, 0.23974299028874912, 0.17609452997140074, 0.23375498375172588, 0.33708288424638855, 0.22092851309953931, 0.2221519240603984, 0.1963213863378125, 0.27543716270679264, 0.28827588968168927, 0.24041256622415674, 0.32494208564285, 0.3516825835030122, 0.26191681366139696, 0.3310372573193404, 0.32733488199721805, 0.4907136776391866, 0.6535474658936369, 0.2987523179667393, 0.2009317251167263, 0.2240710783547456, 0.22090763403131408, 0.2804861708928794, 0.2122590591740643, 0.30570674877436244, 0.29429735834095105, 0.2119642762103403, 0.20988475351859304, 0.14363134580754555, 0.19202058362751073, 0.19935959904156486, 0.1928821547381433, 0.19139449991221547, 0.19600017757163601, 0.1879866268157887, 0.25516562783401886, 0.24391282400120817, 0.24673832901252168, 0.6608935059175945, 0.20720544983227696, 0.2216600142081414, 0.22550393708820882, 0.2280220612759949, 0.20352602175456203, 0.2011943973454825, 0.885537288285042, 0.16868417608609088, 0.15424760141395455, 0.9072574537346394, 0.20130337623783956, 0.17036191499762843, 0.14152610025899048, 0.1699184709267907, 0.9036386722650591, 0.7334000508322694, 0.21326264248118998, 0.15427466365489273, 0.21007483384577164, 0.16901838586744, 0.15372804119968553, 0.10474909270124644, 0.10465619706153861, 0.7472071200232998, 0.18273021997832783, 0.1938829459662822, 0.1839284357025487, 0.19814147762896916, 0.20948849472246966, 0.18949785386948437, 0.18930990727005326, 0.21405869852210713, 0.179379934803504, 0.11926399299444401, 0.08670823745454925, 0.08965036020280603, 0.0985526789697333, 0.0845344660628421, 0.08572552288801794, 0.08480499697210764, 0.09115057541551941, 0.08477933871262633]}, "mutation_prompt": null}
{"id": "6497e98c-b0ef-4f25-a114-53fa0f753acc", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update population size dynamically\n            if evaluations > self.budget // 2:  # 1 change\n                self.population_size = max(10, self.population_size // 2)  # 2 changes\n                pop = pop[:self.population_size]\n                velocities = velocities[:self.population_size]\n                personal_best_positions = personal_best_positions[:self.population_size]\n                personal_best_scores = personal_best_scores[:self.population_size]\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Multi-Strategy Particle Swarm Optimization with Adaptive Mutation and Dynamic Population Scaling refines PSO by adjusting population size adaptively for better resource allocation.", "configspace": "", "generation": 3, "fitness": 0.3010422204427285, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "30b87229-dc01-47cd-a8c4-d8bb0f2087ba", "metadata": {"aucs": [0.8694598673001765, 0.8528109907176165, 0.8529008493252219, 0.8641294096431247, 0.8570184337738794, 0.865720669994956, 0.8544478883406991, 0.8604237430596051, 0.8659531216137697, 0.6268705586589824, 0.6681345511633909, 9.999999999998899e-05, 0.6645298736106873, 0.0460858633933543, 0.6894669655957244, 0.5130810360898279, 0.7011121117310555, 0.6835541256865022, 0.18332118061224356, 0.1606271336494035, 0.15634364510074772, 0.14085410404131604, 0.17768545474959996, 0.1284419759512424, 0.15866384206543338, 0.129239972463557, 0.14631331485037335, 0.10128072853541381, 0.12608298083281166, 0.10830914975572614, 0.1302003343495326, 0.099048994330739, 0.14857798940317501, 0.12610355010278285, 0.12051081029721122, 0.15412677164033906, 0.9844712884638271, 0.9922777224368696, 0.9851777633208493, 0.9693688947487025, 0.9855871110853952, 0.974732635658836, 0.9877275719770138, 0.9851318985216958, 0.9838907555985201, 0.6935351933640487, 0.671572918466987, 0.10718644811834366, 0.15287578215326736, 0.6845120995318008, 0.5804774889101569, 0.6526501652150488, 0.6814233172547943, 0.6645472011875133, 0.22754712014461798, 0.1588995756677961, 0.17247210796834245, 0.27548392854002224, 0.21368982314759066, 0.2288033947034679, 0.2523634596536316, 0.20181975293959953, 0.31050696442236014, 0.27581415689433875, 0.2100698723645542, 0.20878821355620736, 0.20379147653200635, 0.20461587338538823, 0.1914810421477453, 0.21372173331374666, 0.2174126120659151, 0.21678599314407598, 0.255270689219398, 0.22316052390031504, 0.11743717154053102, 0.21368324385688398, 0.1126617989055112, 0.29711230920974807, 0.24846671560439804, 0.2572472073794806, 0.12579988637351003, 9.999999999998899e-05, 0.004375726788963918, 0.027327197450543794, 9.999999999998899e-05, 0.00020918240872069838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0604381155809699, 0.06982155860336459, 0.055400382416617266, 0.08198246457121239, 0.09978673259124626, 0.02571702835301548, 0.03873913429115727, 0.04703343900795098, 0.06765184616435382, 0.04777594562194176, 0.19456516982829597, 0.04759297782393335, 0.22882860963106144, 0.1327967918965729, 0.24514332973642983, 0.07461301011806465, 0.1585547329477015, 0.07096750227109783, 0.06942487542494002, 0.16542509134825067, 0.21752069719017286, 0.07008630974680186, 0.0819346028732687, 0.1374564440384256, 0.17287364421961215, 0.08831602906519109, 0.055875383080616126, 0.08144524928754748, 0.5469824895446925, 0.5514089128826298, 0.5264690595160633, 0.5330406498862312, 0.5128286944361131, 0.5058260796085408, 0.5418342304549046, 0.5675168514107872, 0.550552621961122, 0.08561550658979289, 0.07351884204558878, 0.07813473403707194, 0.10529801918342696, 0.081935200021649, 0.10628099389056711, 0.07758483487267187, 0.11593829323723348, 0.1392731263983431, 0.3489545572278867, 0.17661818648262195, 0.23049761658871926, 0.21254546840292154, 0.22926113931502168, 0.3355018193335111, 0.18183738670455973, 0.2202947305458045, 0.33411891338876853, 0.28720036960256234, 0.2365045013753283, 0.46902304231724434, 0.5068643602283899, 0.27165490472857123, 0.2253457681419373, 0.48823732407309195, 0.4927268683899484, 0.47970571431957454, 0.23095553142319347, 0.22407959226067453, 0.25521040659909044, 0.20873432044750684, 0.24868936555745946, 0.2908524683571643, 0.14008583619746928, 0.26352319129914503, 0.27551289986008876, 0.22273978348234746, 0.15999439109146973, 0.21522494187440133, 0.2115274252915259, 0.18041921895016588, 0.18160027235758058, 0.24464239560520862, 0.2381787731739725, 0.22499070403785126, 0.21113028746179752, 0.21810417235344137, 0.24337175090004426, 0.19602768310792862, 0.2138400709971635, 0.19434191393840905, 0.22466574240864345, 0.22436404438932767, 0.773591515363882, 0.8970580077177397, 0.8741278349937919, 0.1544437772406151, 0.900386479855142, 0.20144299951056832, 0.17045959036350145, 0.14275433251731662, 0.1703453329427388, 0.9108134098924193, 0.795458207658543, 0.21344158230144228, 0.152391948077642, 0.20800100696365087, 0.16897819339079434, 0.15344315079350002, 0.10377489553907293, 0.10389577635920177, 0.7888945455737311, 0.19489401087878633, 0.21457353028700532, 0.21302832114052894, 0.2199687394586003, 0.20246298538851437, 0.18921130078144044, 0.21367063894769545, 0.18371821139230948, 0.19729138523256828, 0.11426735937156596, 0.07006312478067578, 0.10792447409037975, 0.0750378628879722, 0.09157358179699093, 0.08749234907513437, 0.08556208556722578, 0.09823600979387848, 0.08893796373270468]}, "mutation_prompt": null}
{"id": "3da123a8-5de6-4ee9-8a53-fb6590a151d7", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w_max = 0.9  # maximum inertia weight\n        self.w_min = 0.4  # minimum inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Dynamic inertia weight\n            w = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced Multi-Strategy Particle Swarm Optimization with Dynamic Inertia adjusts inertia weight dynamically for adaptive exploration-exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.2656674442998471, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "30b87229-dc01-47cd-a8c4-d8bb0f2087ba", "metadata": {"aucs": [0.7514647541361172, 0.7222652155353526, 0.7524413897824411, 0.7919090388949499, 0.7537381170000493, 0.7412987376471675, 0.783553664832304, 0.7644548073086521, 0.7095676250723697, 0.03463021107656783, 0.4440591516668505, 0.41797005155814526, 0.5565191543919283, 0.41459064421447345, 0.4860098907587349, 0.4112134687676303, 0.0430639902678831, 0.5386850069460762, 0.15750210259028485, 0.1302507714856591, 0.14816597704055823, 0.11140938592887428, 0.1280267516017255, 0.14301906989723479, 0.15714320382608604, 0.13790874915949247, 0.13216424221251977, 0.10603552891426893, 0.10556281955470237, 0.15203668283029614, 0.1252509803514431, 0.1104148348280296, 0.1149254386475923, 0.14096779321297948, 0.1612899780694208, 0.3918134358886286, 0.9865396123393906, 0.9922743290078392, 0.986415152924615, 0.9769677869661074, 0.9879876772935716, 0.9782069178002143, 0.9877640049374744, 0.987708205257247, 0.9857262921076065, 0.5830300122301356, 0.4530469814230028, 0.07881424791590785, 0.1489451847861425, 0.18758597792481646, 0.14622864416128323, 0.12504198029126035, 0.38897901891015296, 0.28744425896383763, 0.2234293868052698, 0.1671161892279075, 0.17254965916672305, 0.35703992840375176, 0.1912219888567983, 0.1912361856072966, 0.1401876958458741, 0.6160435692420143, 0.17219402539277073, 0.18422736071702517, 0.18576104058866172, 0.1834149037959436, 0.09857333637813193, 0.18818729057706574, 0.20283299836333912, 0.18797071058669823, 0.1679853705058364, 0.18547428790372056, 0.2430771846073594, 0.1994672495553358, 0.05700448627597221, 0.1833818185974999, 0.10893184474476769, 0.12699761379391605, 0.2052329548445635, 0.1271254263040733, 0.12265992980274643, 9.999999999998899e-05, 0.028536353818613303, 0.00937788535828854, 0.04590238318203321, 0.011991179290065657, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011555363943224206, 0.03678944214769053, 0.03460069261007337, 0.07369881464386652, 0.0756835621339702, 0.009731784081274286, 0.011873737382165017, 0.051421710333191206, 0.022399913084759304, 0.0969621837823994, 0.03975418898197436, 0.022660905586916802, 0.12601136965740878, 0.22497843169151854, 0.07579988667837423, 0.060522133633643005, 0.07915486144106765, 0.05639120354765037, 0.05493006343769502, 0.11159584667461642, 0.1209506252683401, 0.20020592660740433, 0.039523648399204414, 0.12199797782866861, 0.1157783407616707, 0.08542020009057183, 0.04497944419875277, 0.052618893050581206, 0.5108306739323089, 0.49782522489566816, 0.5016525373712293, 0.5035838603768624, 0.46964958086716957, 0.445836610386107, 0.49379854534003453, 0.47027628787453046, 0.5473632241733243, 0.09378383215385533, 0.11571435118109619, 0.07276441790561727, 0.5005023540573103, 0.0889974598370471, 0.11994873693520947, 0.11049598445011966, 0.09214157691831826, 0.14581151050344965, 0.159090514520007, 0.2000231633020666, 0.18306614560013834, 0.19656321201380655, 0.25655199971462295, 0.22629616079961545, 0.3629755472713626, 0.3137810571500309, 0.3405457093704003, 0.3458820496441922, 0.2056834228438874, 0.33771156749367603, 0.2840932890579737, 0.24438327425289952, 0.3189664642119844, 0.48392738000185864, 0.3590391835146265, 0.45970632579432036, 0.17944980319292647, 0.19564874573534774, 0.22922996326276057, 0.32687936742566903, 0.14670188588393707, 0.3026309637360801, 0.308252458058351, 0.2982006278451058, 0.36384126556048235, 0.21529011205337278, 0.1800740511210499, 0.200174362090894, 0.19839298939706773, 0.19081314873567345, 0.20764955588622636, 0.194622195963023, 0.19322597500427696, 0.19608898471823333, 0.23169080101034456, 0.24010360765763294, 0.19975465155392846, 0.21136227671090768, 0.23668526894946784, 0.2117182572635523, 0.21955631835701028, 0.20198168651312598, 0.4703706845989052, 0.8313006374681196, 0.16758012932140487, 0.15428162505156395, 0.8210689592671275, 0.19941317925879487, 0.1983209054648971, 0.1416800778568431, 0.1701451883070607, 0.5470310245950927, 0.6573522069446931, 0.2122821478626078, 0.14876495204503715, 0.20647440763658687, 0.4474669763909318, 0.18338186141286716, 0.20583867505609132, 0.20506098900828673, 0.6337914878410205, 0.19534852015397508, 0.1947018668699474, 0.17673267304144225, 0.18828602605719458, 0.1791241764782413, 0.17824480706193113, 0.19352130229529063, 0.19233554640081818, 0.18106205907969886, 0.10637125600467823, 0.08759141262628967, 0.08331268496320443, 0.08982752694221019, 0.09411322347143636, 0.08687295723287713, 0.08101172795444689, 0.08161616218226886, 0.08005285175198551]}, "mutation_prompt": null}
{"id": "f6a31f61-4a74-40d2-b9f5-a8de96a198da", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.99  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced Multi-Strategy PSO with Adaptive Mutation and Dynamic Mutation Probability for improved exploration-exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.3012985164466947, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "30b87229-dc01-47cd-a8c4-d8bb0f2087ba", "metadata": {"aucs": [0.8565008167073208, 0.8501450439204283, 0.8529008493252219, 0.8661710108294705, 0.8579773491457847, 0.8766273192023404, 0.8544478883406991, 0.8603041738435117, 0.8607769426185168, 0.6223799070591602, 0.6453921298539034, 9.999999999998899e-05, 0.6574881387342932, 0.04608818657513292, 0.6939621304576866, 0.053068878589212054, 0.6937718993615185, 0.6795573210125926, 0.18332238076480212, 0.44120367686884787, 0.17596137388978894, 0.13557590046363788, 0.1776930156226716, 0.10789208281827245, 0.16310011934495672, 0.11923666239237685, 0.14694976430201712, 0.11879782343543155, 0.1238385273100393, 0.0940212535372118, 0.13565578417216817, 0.1014484598257972, 0.11452927765861332, 0.12610535485703, 0.12051115749653074, 0.15383812107779882, 0.9844712884638271, 0.9922777224368696, 0.9851777633208493, 0.9693688947487025, 0.9855871110853952, 0.974732635658836, 0.9877275719770138, 0.9851318985216958, 0.9838907555985201, 0.703179153485617, 0.6941900491052049, 0.12345066480615075, 0.1528713049865248, 0.6982682587036851, 0.6336540065968452, 0.6633642888139266, 0.667120431214574, 0.6647823070254834, 0.2275807173122636, 0.1930003357201655, 0.17247210796834245, 0.2733157334818095, 0.21368982314759066, 0.19284356799229185, 0.21908277766283635, 0.22954016422397705, 0.5319891065841249, 0.263809834782601, 0.21700269387204496, 0.21388364032129437, 0.2129553584142132, 0.21045761741926294, 0.224243335735127, 0.2284256125276526, 0.22843898492638193, 0.2228764101691294, 0.25968603321438477, 0.22802749406017941, 0.11639948014152857, 0.22852509244693786, 0.11291121510049451, 0.3016132485457901, 0.23560344057054472, 0.2564147128684596, 0.12614949345278603, 9.999999999998899e-05, 9.999999999998899e-05, 0.05485747536972829, 0.00034482495393273194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05748829778376274, 0.05988192880360199, 0.06364140447485045, 0.06039292866081125, 0.08193569063724904, 0.015075746595702877, 0.05758684660469626, 0.04475788692270544, 0.02729082100551805, 0.034787680138217536, 0.19457074994858015, 0.04754031410197801, 0.24606719235143926, 0.12612307703841574, 0.24883939286863266, 0.0744473980092647, 0.1584747199357891, 0.07096750134763696, 0.07057291137099475, 0.16645066266267805, 0.21751868741426816, 0.06994622539210882, 0.08193449635683059, 0.13745638216534484, 0.16696667678595645, 0.08912521300559928, 0.055877882774947873, 0.08140281526818527, 0.5397939380850846, 0.5551156200780292, 0.5275762480764439, 0.5418220719439679, 0.5008854649341178, 0.5624571727498798, 0.5634034075960641, 0.5649727346477504, 0.5564784404527017, 0.08122411047393474, 0.06107598644120171, 0.0781350319268328, 0.0924719433029828, 0.0820259464059363, 0.10683227956297703, 0.06918830333147985, 0.1159409969492754, 0.14064490876642777, 0.698726803319299, 0.17893210991235753, 0.23503561662931938, 0.18973734516730578, 0.22946323411778047, 0.3448384136663011, 0.1912482491992865, 0.22924921156553324, 0.33484803282368736, 0.2915677099372621, 0.23352934998992658, 0.4006502245533816, 0.39630088550039055, 0.2657420092235647, 0.19738760963777602, 0.4238253223873505, 0.32736487042184614, 0.5591189017239515, 0.22917027252584277, 0.2240108403401374, 0.26770679766171523, 0.20910321339098126, 0.24848210788149938, 0.2756153534532214, 0.14012958576345425, 0.2700196462086848, 0.3191606419608455, 0.21508052454414406, 0.16959037444715308, 0.21555050258325048, 0.20870490501253147, 0.18970515580748915, 0.1869112420975375, 0.21209543000602094, 0.2030174801119199, 0.21503126510624437, 0.2350421451364284, 0.2126411376129298, 0.19280612005569941, 0.19602589791261282, 0.24473518116851833, 0.19194089630395705, 0.22466574252887583, 0.22436439570138078, 0.7508389346803673, 0.8970580077177397, 0.8551836934683879, 0.15444377142012178, 0.9099326344953548, 0.2014429967402035, 0.17045959135883382, 0.1427547009409862, 0.17034542190675295, 0.9024082578959729, 0.7629156610471335, 0.21344158235603305, 0.1518638231719842, 0.20800100687238277, 0.168978177319005, 0.15340852665338012, 0.10377489545859553, 0.10457279953417875, 0.7527917778687006, 0.19664435133580238, 0.2140918469189904, 0.25048457903219046, 0.17662150271798305, 0.2028208934437179, 0.19296792792558792, 0.23598813880401348, 0.1904935242375415, 0.2170106355662378, 0.0969096920548016, 0.06607888421821717, 0.09067023090315107, 0.08663663134682686, 0.09917791686802979, 0.09323151767242766, 0.09320362148919303, 0.09848528449035765, 0.09498006035423967]}, "mutation_prompt": null}
{"id": "b5946815-7232-4fed-ae86-283441651a8a", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Modified Multi-Strategy PSO by adjusting inertia weight decay and mutation scale for enhanced convergence.", "configspace": "", "generation": 6, "fitness": 0.3075678664165583, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "f6a31f61-4a74-40d2-b9f5-a8de96a198da", "metadata": {"aucs": [0.8594866256762339, 0.8501413042482374, 0.8651708430875564, 0.8661620297156811, 0.8451272271994559, 0.8828777491193274, 0.8723039561803035, 0.859594645529616, 0.8642362062970209, 0.6576436162733184, 0.03698682563384392, 9.999999999998899e-05, 0.6512579866006528, 0.046088184078251104, 0.6792502064935828, 0.6576084876502553, 0.6846165669972124, 0.6905670393306302, 0.1824574479154003, 0.1700664524059986, 0.43912554622476474, 0.155854519404516, 0.3718970135982078, 0.11702912768727924, 0.16049934187973158, 0.12555329912834645, 0.17260138294086735, 0.12756916703979693, 0.11252936260433721, 0.10034285934557796, 0.15007457226730891, 0.10547848847382613, 0.10035873988396193, 0.13719568482950695, 0.15051521144988944, 0.1691197917074242, 0.984470224907953, 0.9922777224368696, 0.9851777633208493, 0.9693928710724962, 0.9855871110853952, 0.974732635658836, 0.9877271446170244, 0.9851318985216958, 0.9838907555985201, 0.7204575459266155, 0.6804599357990931, 0.059090991387418246, 0.6034319092651339, 0.7093809875376733, 0.7055348226794873, 0.7057580837941926, 0.6585205341860592, 0.7013608976663824, 0.22733888704976002, 0.13865422658836402, 0.17247210796834245, 0.21511823773313876, 0.21368982314759066, 0.2057311846573534, 0.28719313179575634, 0.240903409369011, 0.3778896487487191, 0.3338833509327602, 0.20739111849431158, 0.2312396448981221, 0.23156430805713912, 0.2220804128619952, 0.21722932503832915, 0.2148437597558681, 0.22024245952799903, 0.21589366753503603, 0.3222926615351285, 0.22960401046647583, 0.11718013885898637, 0.22992438108450375, 0.11267973724029312, 0.30162689150830824, 0.2330074906047771, 0.25465219087971813, 0.12616814101098772, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0022432184550256196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11564456918689481, 0.05792168492184935, 0.06892579710700897, 0.07252389142990634, 0.08698392304430602, 0.03342208511681821, 0.0395187416393854, 0.04386662438380262, 0.03814623836135811, 0.036851556355464, 0.19861643239778293, 0.04746959472312151, 0.24005498080537158, 0.11587345644458202, 0.2427262893388492, 0.07525269697205206, 0.16083820742698085, 0.07120208264783556, 0.07002524209232819, 0.21235792141141951, 0.21267404835790604, 0.07065004330778246, 0.06563140816788382, 0.13579121369187053, 0.1094386643707288, 0.09140963415509018, 0.051059295427099416, 0.08186692355701075, 0.526094960310952, 0.5473710488483956, 0.5577925121032538, 0.5368284036246241, 0.48077876653590257, 0.5488900696676768, 0.5570174309467232, 0.5600545218978865, 0.5379402820655684, 0.08258478888425302, 0.060258778353186604, 0.10185930410016808, 0.10221664676549735, 0.0820166558646015, 0.10692965900758522, 0.11873570311395865, 0.11595928484998497, 0.1409410921105838, 0.5336950257343744, 0.19762267794812882, 0.2307271852435473, 0.21221855718470617, 0.23427287097303373, 0.27514936752305696, 0.20029419615604693, 0.2218082591333561, 0.24128016767790117, 0.2931300059411256, 0.2410679666293809, 0.40087685028969733, 0.47231618640903184, 0.2380343177257862, 0.23197205960085043, 0.43232797742460793, 0.3537025632738645, 0.3609872466257984, 0.32079620305629086, 0.2283968240274027, 0.23877830837725234, 0.18957619673971227, 0.30687601574905643, 0.2747763594782837, 0.14004842065614398, 0.2769857507241722, 0.3966823551284928, 0.21281849662015762, 0.164644819803759, 0.22022859990774935, 0.23601700298040373, 0.2028830890755513, 0.22744337550135862, 0.24143984067647484, 0.21297882814688462, 0.2463533667643132, 0.24515273891212352, 0.20618888240101163, 0.19278794341593775, 0.23387126109794165, 0.6937978049837683, 0.19524077113473992, 0.24456012078647404, 0.22437560197431727, 0.6650550443646557, 0.8987869018650929, 0.8804800548494354, 0.15444438422926354, 0.9187709420769287, 0.2014431377878121, 0.17045929775281743, 0.1427273289750126, 0.1703454144713069, 0.913614365683444, 0.7336660910815699, 0.21344682181216024, 0.1527674178478583, 0.20854704449465555, 0.16897817732097664, 0.1530337199883206, 0.10377097703073723, 0.10389454056327307, 0.7748635431645228, 0.20733623691005154, 0.1913652013605901, 0.20068405572748793, 0.23627337341454868, 0.18756510480470123, 0.21001951872279834, 0.1923997351203549, 0.19026860231970233, 0.21665727029153148, 0.14483734102834822, 0.08780263839446156, 0.09906537777880309, 0.09600164004210054, 0.09325137881789691, 0.09947935473014435, 0.10205228307442338, 0.0861392356773758, 0.09486106673065808]}, "mutation_prompt": null}
{"id": "edae2f77-da1c-4f9d-98d6-d3c7d5100841", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n            # Adjust inertia weight dynamically\n            self.w *= 0.99\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Modified Multi-Strategy PSO with adaptive inertia weight decay for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.2874559760347555, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "b5946815-7232-4fed-ae86-283441651a8a", "metadata": {"aucs": [0.9025915061420202, 0.892705937910101, 0.8964126630916298, 0.9025859478383911, 0.9007985279931594, 0.9044369088818528, 0.9043138198488865, 0.9060683772259442, 0.819210258265754, 0.04006266651725743, 0.7002349140530153, 9.999999999998899e-05, 0.05273133388963325, 0.04728384392135909, 0.4516650407337687, 0.051367204290419965, 0.5341317493879563, 9.999999999998899e-05, 0.1313063748395119, 0.13589493566983946, 0.07291226073598223, 0.12233349563640472, 0.12050990560259522, 0.12164387721899872, 0.15941233798315912, 0.17586705244419687, 0.15362180062749864, 0.10909902350820977, 0.09338377182083735, 0.10994955347565405, 0.13014766656240284, 0.09809739839803222, 0.10898551616220664, 0.11980867519580918, 0.10978899987798174, 0.15949109760553215, 0.9844573643242741, 0.9922776987954036, 0.9851568888674588, 0.9681737910496001, 0.9855754658416296, 0.9746961142806486, 0.9877265086965434, 0.9851243345869906, 0.9838831272347633, 0.807666763785219, 0.71000972923473, 0.42707674085492675, 0.15307436490252002, 0.24127344727268973, 0.7093974304849276, 0.613827751640926, 0.23765639004863326, 0.6818209923969738, 0.9033862594424007, 0.13891491469963935, 0.1724572526834951, 0.27404550942390804, 0.21309246859561848, 0.19298646381947526, 0.13102127774197725, 0.14910762656688525, 0.2249890889770244, 0.39968671020968627, 0.1585169712037432, 0.18729462375318207, 0.26628423966518344, 0.17443502862283478, 0.1735918270147142, 0.1722393092389466, 0.18608849107485892, 0.1677873582799586, 0.3403700476642899, 0.1830218770682418, 0.11965578328136872, 0.16787678583197263, 0.1316134016077467, 0.17026787951674793, 0.2106029295901365, 0.1880303973880315, 0.1278888761072371, 9.999999999998899e-05, 9.999999999998899e-05, 0.03467525362804569, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05569522669435023, 0.05794153376311273, 0.0802199989566037, 0.137644984359523, 0.055555473011696055, 0.009458585389284235, 0.015437913102825718, 0.05825260726740544, 0.06691725504171575, 0.05165625930514672, 0.19667753151598044, 0.03909753801448912, 0.2096054072096698, 0.09822622924962943, 0.09767408397319122, 0.09179986867565026, 0.154614042872663, 0.0742790241686545, 0.07326101316984024, 0.13268251789898078, 0.04078992084566957, 0.10030227018190763, 0.14423752233788034, 0.12015232861672243, 0.09635398576780152, 0.1066451778816041, 0.056154737450521464, 0.08362506735812114, 0.5162649507996575, 0.556355538639275, 0.5227229182120345, 0.46949127493044973, 0.49512007192309104, 0.5273830549702021, 0.5834659638481151, 0.5903530476672576, 0.5187318255741823, 0.07995323495828122, 0.09801132203088891, 0.07667719570351728, 0.1416388836669885, 0.09696338924370063, 0.10125015576008556, 0.07938799890632331, 0.11109328661653084, 0.08792325839915316, 0.3016723710712612, 0.23627463445486518, 0.24385148117135158, 0.2984298220107442, 0.23801391845234343, 0.28504852431652883, 0.17192827973301317, 0.22701758663998206, 0.17992428163922758, 0.3732714095854742, 0.26288613210481715, 0.35720420533960084, 0.3938724329657739, 0.2905445944660412, 0.4381191930492343, 0.5772040868009025, 0.5433608746531249, 0.5657481904384289, 0.23771963994808765, 0.23787492242210817, 0.3226332028159211, 0.17527554908588494, 0.24558159536131374, 0.28435846014152066, 0.18677979600970196, 0.3095206784220038, 0.2656667067417027, 0.21206259531189542, 0.18251862998366408, 0.24363397060662195, 0.19745285590776007, 0.18044769081646594, 0.2203028588855298, 0.20372428865115055, 0.19718770331741386, 0.22551079687259057, 0.22563339696833196, 0.20504438664077607, 0.20304001910765923, 0.18107339330715178, 0.2088776611988481, 0.20976115916095406, 0.21060822283776015, 0.25147047908738507, 0.2091872261974701, 0.9198569988183256, 0.9152574691271663, 0.1544773896606152, 0.9188812108827265, 0.2015047327015531, 0.17047045971456154, 0.1427524150151066, 0.1703800026829193, 0.9296841036297122, 0.6660008897444712, 0.2135604220841868, 0.6378999592009613, 0.20977097558215752, 0.16876091710654728, 0.1541677250382354, 0.10380110361762362, 0.10494985792528422, 0.8281937505871528, 0.18417252353673796, 0.1989805028833932, 0.2353815480112299, 0.24378121397972097, 0.1844570912821435, 0.2193730586731535, 0.18781232361468858, 0.22166015128882854, 0.21856941179472844, 0.12453311538233958, 0.08384280207138073, 0.0953919662275734, 0.10516757586066161, 0.07753459071760971, 0.10560129560503739, 0.09867702135190959, 0.09651392982175222, 0.09504693730201708]}, "mutation_prompt": null}
{"id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.98)  # Dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced mutation strategy by adjusting mutation scale dynamically based on the exploitation phase.", "configspace": "", "generation": 8, "fitness": 0.30785061336826786, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "b5946815-7232-4fed-ae86-283441651a8a", "metadata": {"aucs": [0.864479092998411, 0.850140620029051, 0.8597352371131471, 0.8661620981977867, 0.8398193200134826, 0.8828777491193274, 0.8623285780486994, 0.8529963068247753, 0.8685849877895699, 0.6307941804591071, 0.036977507054351544, 9.999999999998899e-05, 0.6586685645654415, 0.04608818556857697, 0.6981209129121367, 0.6214065970780396, 0.6915103815148713, 0.7011705455772177, 0.18134872105046163, 0.17246812288450364, 0.15813936297730946, 0.5909999623423007, 0.4404464428992916, 0.11313869504003504, 0.14175223454998265, 0.16712648298747868, 0.42987893544698086, 0.10831860480681077, 0.11339621730402816, 0.10943312224527157, 0.10954855903264837, 0.10366193874671148, 0.11156762059149039, 0.14945171099194232, 0.17157951039020958, 0.1789194918796988, 0.9844700345197134, 0.9922777224368696, 0.9851777633208493, 0.9693974851034751, 0.9855871110853952, 0.974732635658836, 0.9877270682473911, 0.9851318985216958, 0.9838907555985201, 0.714581035113687, 0.6405387087824328, 0.05909099462875911, 0.1527712126556089, 0.701419375730362, 0.6357846396669768, 0.6726600003336961, 0.6627907487087679, 0.6976030061271705, 0.3730080039758763, 0.13865422658836402, 0.17247210796834245, 0.21511823773313876, 0.21368982314759066, 0.20189637529654936, 0.6989902518062148, 0.22691320110212354, 0.37834946957991256, 0.2856277983228689, 0.21480014060151276, 0.23224741852883402, 0.22955136382013908, 0.2220803722483039, 0.21841882132799206, 0.20907429080576256, 0.22710437506223868, 0.21139870516985404, 0.2913636001588631, 0.2293608670258367, 0.11898195226696551, 0.23292007449144225, 0.11243229265291554, 0.305259705376448, 0.22001418836804154, 0.25520168624341566, 0.126234752134609, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00020665671626152182, 0.0023032618027259977, 9.999999999998899e-05, 0.00012080456400309636, 9.999999999998899e-05, 0.11567402381575198, 0.04793668539692697, 0.06960470943955988, 0.06869271048375303, 0.09755448731490635, 0.021568231746650013, 0.03261668574867038, 0.04131574985130593, 0.03815488851024618, 0.027089118307107696, 0.19878282498132926, 0.04909978784317026, 0.24001539373792224, 0.11090749281980805, 0.24271378432391788, 0.07459973489008465, 0.16192195254778907, 0.07091146051564756, 0.0701002722841324, 0.19798958667784894, 0.18708408296426893, 0.0737986595661081, 0.09064974132399639, 0.13637309219002403, 0.10626397343027183, 0.09387241033073457, 0.05421772609352704, 0.08186680403782942, 0.5203115832283309, 0.5549602788501222, 0.5121654045587694, 0.5055264309018632, 0.44346661328721515, 0.5189702976243105, 0.5624108266217155, 0.5449660735465172, 0.5539705178409373, 0.08400852989472096, 0.0552951629840589, 0.11288636826513088, 0.09236211301939601, 0.08203230144886997, 0.11149398281287792, 0.15076636147747668, 0.10947784290434448, 0.14157464232723582, 0.37345853450006505, 0.42851081395755775, 0.21974299190761748, 0.20706979109255175, 0.23456451890137286, 0.19932284192062855, 0.5418352659875179, 0.24594659621161397, 0.38451933842917896, 0.3439689215359415, 0.24655487806943455, 0.3981956755856474, 0.3397291030762364, 0.25773782024760516, 0.1954064135493454, 0.2751292289004359, 0.4179414386451956, 0.572054271979635, 0.28202770516665876, 0.19220492133657674, 0.2385292879322094, 0.18888482271660323, 0.2629555302349117, 0.2730222702244808, 0.14015293173959942, 0.27070992425375406, 0.3623579477004425, 0.23237354419439538, 0.16603534740994796, 0.22774574540029402, 0.22362352741764524, 0.1988483335448472, 0.2148712719935335, 0.19087577780211995, 0.22044267802168593, 0.23068759109351578, 0.24717264206957823, 0.20619361333699515, 0.19278794331616522, 0.19102547458727082, 0.24348480337186518, 0.19210935952959862, 0.24280947010350018, 0.22437691569408413, 0.6198211234724897, 0.8979285480251946, 0.8633003846240133, 0.1544445627601777, 0.9081338719674766, 0.20144313778852507, 0.1704590652445851, 0.14272314733732205, 0.1703454144713069, 0.913614365683444, 0.8571701418252802, 0.21344682181216024, 0.15269535967440862, 0.20921067301340046, 0.16897817732094267, 0.15328380676486852, 0.1037769487145892, 0.10389460880876122, 0.7800747243103147, 0.20469928271753213, 0.2160181023999782, 0.2633772977775348, 0.20353358048053094, 0.2152627328803579, 0.2060050526001338, 0.19711750219564772, 0.21250108039085047, 0.24271484325839288, 0.10251849913514266, 0.08618313398663502, 0.10067716268241989, 0.08766815918363768, 0.08722016866080662, 0.08941066732563885, 0.08536362543902831, 0.09952367695060149, 0.08211018624617716]}, "mutation_prompt": null}
{"id": "cd9cb01a-30dc-45d6-a4d5-67ad2df276e8", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # inertia weight, increased for initial exploration\n        self.c1 = 1.5  # cognitive parameter, slightly increased\n        self.c2 = 1.5  # social parameter, slightly increased\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.98)  # Dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n            # Adjust dynamic weights\n            self.w = 0.4 + 0.5 * (1 - evaluations / self.budget)  # Dynamic inertia weight\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved exploitation and exploration by incorporating a diverse initialization and adaptive dynamic weights.", "configspace": "", "generation": 9, "fitness": 0.26488528698310954, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.7403010128452525, 0.7391793355033988, 0.7138002246273174, 0.7481706641539848, 0.7465168420816737, 0.7613214112874327, 0.7250799023515977, 0.7301270751589819, 0.7399043254215605, 0.4898008909810355, 0.498938263242254, 0.017161341527509477, 0.5024770331520728, 0.45946820309173153, 0.05506173309959683, 0.5062000454024236, 0.5117889339323594, 0.03913215562360506, 0.29297323049253465, 0.1074506881379782, 0.11872897978428532, 0.10318611340398931, 0.14406339536293888, 0.1330376928962994, 0.15053151257102604, 0.14097583071574105, 0.11799401306267232, 0.11508857026983499, 0.1536507858126095, 0.14172192109008497, 0.15134887566971522, 0.13319893639015568, 0.12001658483626776, 0.15282259846245339, 0.1311707178349163, 0.1290815218177298, 0.9877006392808101, 0.9922885143206828, 0.9885656962243586, 0.9803483446292129, 0.9880424508473136, 0.9781950648545216, 0.9877964543947745, 0.9885805696390214, 0.9857942625888253, 0.5250751860928604, 0.5006924974545992, 0.4776452640268819, 0.14794394784888232, 0.36938502427889597, 0.45681422943572825, 0.474886250609041, 0.5484914420380451, 0.5169935429167707, 0.22196256867401387, 0.160558004838932, 0.20990670359732722, 0.26327111504726786, 0.15848929045503524, 0.19069950805199876, 0.17928200971518615, 0.19103387302632424, 0.2770898457309856, 0.2884177842973742, 0.17510701016261465, 0.1687576648654081, 0.09362742105579835, 0.19039939719976873, 0.11203304946217052, 0.21819580594825538, 0.17543058715448445, 0.18931270502230357, 0.18860792187509434, 0.17223303187653405, 0.14621756312097045, 0.12029189450230371, 0.14162203500656145, 0.12092568556802585, 0.19094518906561564, 0.12536004685050206, 0.183098573516433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024409748946232268, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04188654552411608, 0.04339810194317706, 0.06672579372399556, 0.05774917717878847, 0.03409994660543125, 0.0008541033613368443, 0.00481129003591052, 0.06300583844300689, 0.05400820244623761, 0.06542358122214775, 0.039700380819962855, 9.999999999998899e-05, 0.08392075239310692, 0.09723177306257835, 0.07280908777708284, 0.05984251977249222, 0.07502497788145412, 0.053502352452392876, 0.056401082459666574, 0.009581293815068448, 0.10178263468496807, 0.14637878738188537, 0.005492432146818604, 0.0946507596406102, 0.06855249848038203, 0.0693323458148063, 0.04698612485340914, 0.07303014000816588, 0.46766480943608013, 0.5212144397361562, 0.4903466174928137, 0.4946799509798854, 0.4847820987914463, 0.49664234412567143, 0.48963614150997514, 0.5087085135543412, 0.48858470154292943, 0.07595034186553462, 0.1308976370810233, 0.06745039377468076, 0.08703334444780908, 0.13056601798521883, 0.1349129976772998, 0.11775058754967904, 0.10749865146451398, 0.0891142575853675, 0.19357742976936398, 0.22146938939665062, 0.20246402036055933, 0.23113661595885926, 0.3054449843359074, 0.32122468430760964, 0.19777967105637706, 0.24422768214091117, 0.3890072422305718, 0.372319545836883, 0.22885130283135224, 0.2397251839186727, 0.3642891754939799, 0.3338242814355208, 0.3937228601933622, 0.42204494560696915, 0.40875558212219343, 0.2743988500253176, 0.1858276122782473, 0.21576908252679394, 0.18129265715779574, 0.20288054127135824, 0.19386472543934774, 0.30275512172476515, 0.24093062734496573, 0.2662188599362807, 0.18158010867511387, 0.1853149903554866, 0.22203412865175387, 0.24291779515533451, 0.22296944818112185, 0.19281743961490194, 0.20352746314765813, 0.20469743892802172, 0.21411651595148917, 0.21629718057679914, 0.22562393206920994, 0.22707028107090765, 0.21902939356140494, 0.1992832617038408, 0.22843534433314405, 0.5805803072779627, 0.22561289832691933, 0.1960047380725043, 0.18599836897101885, 0.8015706407867431, 0.1495763911882746, 0.15381530094562246, 0.8048324794798247, 0.18543620252748594, 0.16985665761440705, 0.6510108589528972, 0.1695292213322146, 0.8285947191773426, 0.6444065303089459, 0.2106295491250959, 0.14778895127767722, 0.20400212680289798, 0.2499408828544054, 0.15172566286731126, 0.20051476318609174, 0.1974694268975805, 0.2047866872480003, 0.2105218907382247, 0.1769703793221612, 0.20098680557779225, 0.18759231847550895, 0.18612488794346838, 0.1911637641929439, 0.19113617676682892, 0.21260500458664633, 0.19097243039984946, 0.11493435319632062, 0.09324325970265979, 0.09510824202009482, 0.08930578456899874, 0.08578021917056644, 0.08454698598366517, 0.09852011253686688, 0.07969065572099931, 0.08840480681084828]}, "mutation_prompt": null}
{"id": "c0cc165a-4c23-4ae8-ba13-8dff4b0ad35a", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        # Historical velocity trend variable for adaptive acceleration\n        velocity_trend = np.zeros_like(velocities)\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocity_trend = 0.5 * velocity_trend + 0.5 * velocities  # New line (1)\n            adaptive_c2 = self.c2 + 0.3 * np.tanh(np.linalg.norm(velocity_trend))  # New line (2)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          adaptive_c2 * r2 * (global_best_position - pop))  # Modified line (3)\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.98)  # Dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved exploration by integrating historical velocity trends for adaptive acceleration adjustment.", "configspace": "", "generation": 10, "fitness": 0.273339364933555, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.8365597739755849, 0.8273051387452415, 0.8452874946347907, 0.8364024583159048, 0.8403576059587188, 0.8309881167188289, 0.8476902320773559, 0.8321957096592109, 0.8269358782394453, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.6241430225123821, 0.03266310653223137, 0.06118737097628468, 0.04999902272367285, 0.6543403670970811, 0.6613922954719156, 0.4574369163689518, 0.15230521013400689, 0.1768765313266507, 0.1227214850222359, 0.2777498708662888, 0.5068904094987443, 0.13127406216874316, 0.14761682192840686, 0.15578518154765353, 0.1582185901365014, 0.12469611710448314, 0.1260847764358365, 0.1033193501608024, 0.1420130998087158, 0.13141727629636357, 0.17531537445343148, 0.12876612500591622, 0.14089659413268563, 0.9873436468457996, 0.99231465562249, 0.9889990783657393, 0.9716400387682009, 0.9856133943394688, 0.9785790692654207, 0.987795949136022, 0.988614299048942, 0.9861524134900795, 0.6477420235022079, 0.5687172377977618, 0.05926290589034722, 0.15235408454978183, 0.1526068056175922, 0.15170461960465254, 0.5980180120935972, 0.13382071223530434, 0.614584760007099, 0.22818854733324578, 0.1584248404748081, 0.631908368115818, 0.19465092057609024, 0.21368017037908782, 0.20565995672614257, 0.23126538268822583, 0.1678647576595258, 0.17534675462700122, 0.22579287753782562, 0.45817200121790325, 0.21058324115479665, 0.09946241954788893, 0.2051001082221252, 0.22225254487183355, 0.2247225164080765, 0.1111182501344603, 0.2022858623849435, 0.1304328782814952, 0.1277903927958418, 0.12893048221059034, 0.20384618996105153, 0.14444300958932688, 0.21599293177822965, 0.13093815166256006, 0.1169686946659726, 0.11901142829779143, 9.999999999998899e-05, 0.04678800727980903, 0.010260703296530838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05974784021521684, 9.999999999998899e-05, 0.06926279166198679, 0.13962629636891888, 0.044840163447445236, 0.05067689250121277, 0.09392641140615365, 9.999999999998899e-05, 0.028501210522670406, 0.01367258628607071, 0.09690907295663853, 0.04387073182546042, 0.14604460123804497, 0.0004995660997443307, 0.13405789103115617, 0.07295849459360448, 0.07445075787291078, 0.07213464066203601, 0.09358610673728585, 0.09502117562417312, 0.07109309310350831, 0.12448797131136835, 0.04279881475835934, 0.1468209461293687, 0.006428220215271008, 0.038669731798093965, 0.13147125095833123, 0.08154389400530637, 0.04842977136938975, 0.08203770126943022, 0.5419753184023957, 0.543205994051768, 0.5226143027151071, 0.5589943359916038, 0.568286556247181, 0.5309727421789021, 0.5496808629630839, 0.5934425180190492, 0.5597960324628144, 0.09555366232375506, 0.0978494166361692, 0.09876745440325807, 0.14035238481616052, 0.15343588696220944, 0.12393380956849209, 0.06641750745221231, 0.08795204973088677, 0.1038220218585093, 0.1812791804174696, 0.17277310679499913, 0.21396379878826188, 0.1848475217330745, 0.19722463635222864, 0.24317643734679595, 0.23930324726112429, 0.2317932944030644, 0.26078295037901156, 0.4363190768641022, 0.3155856965489262, 0.35905024276912034, 0.35268247621438353, 0.4109027325281549, 0.14049144506832922, 0.5252472168500044, 0.42272812342426236, 0.5513191666515174, 0.23398369449467582, 0.1757462646598157, 0.24072002895516398, 0.2982887821899396, 0.23604895885524024, 0.39407789925791126, 0.27092576114368827, 0.3674914245223636, 0.29737579287861726, 0.21944599169517054, 0.19869779872913973, 0.205952558867459, 0.2028713412801043, 0.17143660074853395, 0.18232878068355773, 0.20960307624659358, 0.2676132538218905, 0.1983708468694596, 0.23363849839235185, 0.19456567693013804, 0.20881643147635198, 0.727688203754717, 0.20720389676114448, 0.21103415272811765, 0.2249008313059938, 0.19958547937812987, 0.2249569105309387, 0.26378585265807986, 0.19818973388561112, 0.15346256044617035, 0.855404195647826, 0.2005291117570811, 0.20102256337517888, 0.14242064047847658, 0.17017251869920202, 0.9032085256086695, 0.6503490280957906, 0.21327436956213108, 0.15372626247301235, 0.21088247416634576, 0.16616375265246586, 0.15389395521506288, 0.20965586242586143, 0.10443857500448506, 0.7488378319948936, 0.21122449881590355, 0.20383237963871248, 0.19650880276857918, 0.1957204449088612, 0.20328816400658112, 0.20484150972376514, 0.1886105862903964, 0.19484552788590137, 0.1883411543606609, 0.08792369836705238, 0.1046308346581254, 0.07954750612131323, 0.10080338043135673, 0.09180450922872119, 0.0839452554058735, 0.09338028770999973, 0.0903708854539127, 0.08332733332648534]}, "mutation_prompt": null}
{"id": "692f11ab-e5f4-4fb3-93ad-4182a9740e27", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.72  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.98)  # Dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved exploration-exploitation balance by slightly increasing inertia weight for better convergence.", "configspace": "", "generation": 11, "fitness": 0.29401825879495713, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.8589252945479675, 0.8464858139912234, 0.856282513306025, 0.8323572134240336, 0.8555206213315008, 0.8603877701305738, 0.8531494616084073, 0.8513636971003207, 0.8422370871257072, 0.03947316478943552, 0.038729130656310895, 9.999999999998899e-05, 0.04546551078986105, 0.044911741641370684, 0.6443670035991511, 0.6698182755301149, 0.6539589102635122, 0.3758831668169328, 0.16361967222565532, 0.11040307449090214, 0.17054505713082146, 0.1643584264822906, 0.1412725317220953, 0.13982604909128293, 0.13658502109945436, 0.1396222026852385, 0.16884313725085065, 0.11482851911879133, 0.10363508577349567, 0.1046076023459771, 0.18091397443744384, 0.1368333923725764, 0.09803079723286123, 0.19910996222854493, 0.1071290945151615, 0.13520280839495513, 0.9845102592301677, 0.9922773620247218, 0.9862561482456011, 0.9696549271213959, 0.9856168627958783, 0.974967375740945, 0.9877307329706076, 0.985144150954473, 0.9839178894078301, 0.680362923007885, 0.6641684186448501, 0.5632587038277396, 0.5187052309703557, 0.4139226939618187, 0.6528765446973326, 0.6008552044339341, 0.6104182499943367, 0.658642731859651, 0.2265425796659214, 0.20166628696248035, 0.22605013233638127, 0.21448219146408543, 0.8215327673920303, 0.20803697021839374, 0.12465419200295724, 0.3765149417132827, 0.21373680822091423, 0.26798691802673136, 0.20851512478068257, 0.21183196485549316, 0.2109107359197787, 0.21261878865971562, 0.22418811684215512, 0.20523229577180757, 0.20339768133114244, 0.2060166009205906, 0.22804201473775043, 0.23350916496678664, 0.11891643009270414, 0.24022282007623086, 0.11348004728427663, 0.3214140299766589, 0.22834401258135228, 0.127077184328813, 0.2511155340637383, 9.999999999998899e-05, 9.999999999998899e-05, 0.14227271233932137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006089681733101093, 9.999999999998899e-05, 0.03443830146250115, 0.04782883997260834, 0.0678213488132049, 0.08752137795156834, 0.024307101614055915, 0.0021740873281621553, 0.018734023993154048, 0.051812752605262746, 0.06792689672770247, 0.05423929638442182, 0.19689902884460664, 0.03078654077063603, 0.29242226110827463, 0.08895052717857121, 0.2680622744581064, 0.0717315280419909, 0.23255786028546022, 0.06523033639288334, 0.06950822073987406, 0.18497845335985963, 0.12094468732992991, 0.08406139654814782, 0.3656004019922976, 0.21596191377398277, 0.14895755573830427, 0.08122394303758229, 0.04783605629471621, 0.1895721436036556, 0.5677523240593698, 0.5769087459951778, 0.5196693626306281, 0.5444330848394795, 0.4765378601037824, 0.5912169384297363, 0.5539557196187119, 0.5642417685560791, 0.6274315927855827, 0.0654368113368875, 0.07472245207326045, 0.07189907280266816, 0.148905736965263, 0.09755936162963097, 0.1322095159374156, 0.12607027221899914, 0.08819613709968965, 0.14236104254409143, 0.1918024661219101, 0.18292689946605822, 0.23063306233640546, 0.27273708824862786, 0.26469020672583143, 0.19539616764495227, 0.26562607505935243, 0.2190118766623741, 0.34097415483032767, 0.43841393236112647, 0.3881840716063335, 0.26497194421629156, 0.26377536328679385, 0.2530023286191846, 0.43166763222045457, 0.4890687958719434, 0.5811460358940352, 0.3541973675196406, 0.34016440535530756, 0.24454304382012437, 0.20186854951676836, 0.2854896082676971, 0.26391798887354845, 0.2447028148630619, 0.37727655753345457, 0.2740252026118084, 0.1517543298843924, 0.21247883313621818, 0.16117972319881324, 0.19803725431532881, 0.2324494305556013, 0.16074179002740097, 0.2149987395425632, 0.24013741038436354, 0.1915662175566326, 0.19065297746119314, 0.24800581682130118, 0.22224180621541212, 0.21122348638895916, 0.19327642826627467, 0.2184393426946395, 0.19601662000209685, 0.225233660254489, 0.20136223555599286, 0.21959329186053567, 0.8904729573833683, 0.1267848887403037, 0.15432642350952697, 0.9254761061230307, 0.20108427858421696, 0.17040123566218512, 0.14236220612874217, 0.1703363245367504, 0.9022822324144858, 0.8538860702880328, 0.21334412929422797, 0.15217368841033363, 0.20885044530211982, 0.16901865205942945, 0.1536600929381846, 0.10407232958052537, 0.10465277635722725, 0.7481281850995605, 0.20196337481327087, 0.22264976395552072, 0.1840354114063134, 0.21225242918479437, 0.18493381841617673, 0.20240947153900846, 0.19478506292896558, 0.1754741786469518, 0.21832276901952719, 0.16847114953521236, 0.09801030878507644, 0.10237536382350387, 0.08287813533956123, 0.1028036385951051, 0.101086229908956, 0.08286610891843083, 0.0913613007521844, 0.08568444769068462]}, "mutation_prompt": null}
{"id": "8ceef30d-284b-49c6-ab93-0abbfadeb921", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # initial inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.98)  # Dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n            # Adaptive inertia weight\n            self.w = 0.5 + (0.4 * (self.budget - evaluations) / self.budget)\n\n            # Elite selection\n            elite_idx = np.argpartition(personal_best_scores, 5)[:5]\n            elite_position = np.mean(personal_best_positions[elite_idx], axis=0)\n            if func(elite_position) < global_best_score:\n                global_best_position = elite_position\n                global_best_score = func(elite_position)\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduce adaptive inertia weight and elite selection to enhance convergence and exploration balance.", "configspace": "", "generation": 12, "fitness": 0.27106310501354375, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.7537564877748668, 0.740912676198898, 0.760189699940097, 0.7786239206865877, 0.7853925091223029, 0.7678710109075791, 0.722560246866226, 0.7729326285857282, 0.7807894696304032, 0.45081931167239975, 0.4627465822495518, 9.999999999998899e-05, 0.46726850905007855, 0.34394305011263526, 0.5144921829235936, 0.48273779115789217, 0.5418521531266856, 0.48773512766682947, 0.15301493890464757, 0.11670244715885347, 0.147516347837781, 0.1706898849038011, 0.15324068764060195, 0.15928724295664565, 0.1218443113572446, 0.14849929897522218, 0.1251034602196216, 0.13124739757572335, 0.09829017551405772, 0.10481039883106424, 0.11576794963239867, 0.11081245382388916, 0.12204709086945009, 0.11254873936701004, 0.1251578352570899, 0.11837042127198161, 0.9863648757908032, 0.992181015410765, 0.9862375117045429, 0.9765301672786122, 0.9878088932826687, 0.9777692256856602, 0.987590584772486, 0.9875277564490291, 0.985542809205551, 0.5023273962613102, 0.46141559054154435, 0.057826321720674256, 0.1478586484213783, 0.25216185060460705, 0.14720797224351534, 0.4976812582270832, 0.5176254307967227, 0.12542886945194165, 0.22566214630897552, 0.5673374351296052, 0.17253727221335668, 0.2180804307559947, 0.21406428818355705, 0.1997789496101514, 0.22723591698938694, 0.21823516240387164, 0.33475492049209965, 0.19496644355107506, 0.19478366636655908, 0.20149016164993472, 0.10259767187550861, 0.1302755674125965, 0.1756201487680752, 0.18597302913526148, 0.11239744702831012, 0.18186478911952475, 0.12529803473401968, 0.18459510824661207, 0.164356689372954, 0.18556376308871925, 0.16011095860786484, 0.1863462570819534, 0.21578536528460923, 0.1472198840780462, 0.22895956696751518, 9.999999999998899e-05, 0.04297000116988925, 0.11019370397834904, 0.0501694691724589, 0.010501876295622048, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12167581239041869, 0.10871754761828434, 0.07227880095642247, 0.13676090041420863, 0.09054256789199977, 0.025209525131902222, 0.007782992504511976, 0.0728425653389102, 0.09946264565756524, 0.01699929736521788, 0.18582632370265384, 0.04517104488985002, 0.11920072813646276, 0.06505551005538202, 0.07373498075622897, 0.0662740986923045, 0.11124292014721593, 0.128739849108504, 0.05793919917821344, 0.15217179405635384, 0.09665714926237756, 0.0992497548498481, 0.07909688479166366, 0.0651661142618406, 0.06185408158875583, 0.07781908758669254, 0.04393774183727406, 0.09086911961559851, 0.4878325160728545, 0.5183243769382161, 0.5067860407516271, 0.5322895884838899, 0.5097438744763334, 0.48759868687410557, 0.5589960877948709, 0.5105509277085645, 0.49600186625400455, 0.09592556310683142, 0.06760603453600345, 0.05977443050627462, 0.1300115491068613, 0.09318900840418665, 0.14571967966996813, 0.09097206085665277, 0.1200094347733266, 0.09458715219442548, 0.1656776903415168, 0.19064277209391556, 0.30169233394892636, 0.33600146769628236, 0.3184363994784516, 0.2612337473526587, 0.2554628006139539, 0.24509109783428962, 0.3190292376924333, 0.3409747633164244, 0.2695945051100984, 0.3762162543121743, 0.38692823397382947, 0.33799491706572204, 0.37928625471702404, 0.38898606362818866, 0.4745087641862942, 0.2947363156052374, 0.24394543156290327, 0.21652676513914315, 0.2194820658991341, 0.18989022221259244, 0.1998656918556504, 0.24031339673169028, 0.2430448867571794, 0.27213550640075823, 0.2898708846975542, 0.21143550449266768, 0.1548377984498981, 0.19242215646742777, 0.19187148836297463, 0.2048691966725652, 0.20449881812373227, 0.2163571711867427, 0.2161317925222711, 0.23596644552950408, 0.19126130209503012, 0.20775528459553938, 0.18857862738441766, 0.19923428514304242, 0.2071844443226052, 0.1992422728938259, 0.18855101809000085, 0.18557189799613372, 0.560983739279127, 0.8458845418364277, 0.12553960566244005, 0.15468127663043574, 0.8437201442347695, 0.20102783780428468, 0.199214499733256, 0.14279354446405068, 0.17048070658384895, 0.8327796481623567, 0.6474593142743262, 0.21397211201559796, 0.15071860873883725, 0.2086035117393169, 0.3906408887786943, 0.15166571783852856, 0.20148725201441597, 0.10507601737749628, 0.607208134536483, 0.19112030671574265, 0.18096705662220847, 0.1906584425670188, 0.18329194079996036, 0.19109465110535562, 0.18733614325159176, 0.20205550543625872, 0.21121034000043848, 0.20557887215317128, 0.09081828055255248, 0.09628210641511648, 0.09554411275418129, 0.08659542072080895, 0.0882126765630934, 0.09984546413490347, 0.09281463865809092, 0.08442590373021763, 0.0894190855011866]}, "mutation_prompt": null}
{"id": "6ac1f1e6-d79f-4754-92ef-a4d3ad0e9135", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.5  # cognitive parameter (increased from 1.4 to 1.5)\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.98)  # Dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced mutation strategy by slightly increasing the cognitive parameter for better exploration.", "configspace": "", "generation": 13, "fitness": 0.298319489472418, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.8460977674904476, 0.8395740253826958, 0.8592563692003276, 0.8557788317505701, 0.8515856847307064, 0.8632116145784526, 0.8626026842400899, 0.8611644350666688, 0.8566237675909951, 0.04017598953225421, 0.036848035920753475, 0.4309550462621059, 0.633784844713168, 0.04688611506063045, 0.6751242486608089, 0.5948685489991523, 0.0564119335626061, 0.6406773619671918, 0.17698300915317744, 0.20613270982918952, 0.07433562313875719, 0.17388277422457377, 0.1461490395145354, 0.1371588043391383, 0.14823357319495267, 0.14474322984400056, 0.17664210034679495, 0.14210015916126917, 0.14016192431308372, 0.13727093599604956, 0.11840888960870521, 0.13506962907484288, 0.1482351123232929, 0.09969677078892314, 0.140491333906418, 0.1351912564975184, 0.984469992419858, 0.9922777224368696, 0.9851777633208493, 0.9693991885588701, 0.9855871110853952, 0.9747327961476843, 0.9877273808119058, 0.9851318985216958, 0.9838957969608728, 0.6726360446041455, 0.6731045316569088, 0.649125007976087, 0.40771564859868437, 0.6991162255631587, 0.635455521626038, 0.6838486988015047, 0.6572146103600156, 0.6262595763246811, 0.828887342004175, 0.31532352384437345, 0.22871479952595797, 0.21469288992613123, 0.27806455249510476, 0.19267600704422017, 0.2404538771875956, 0.1265471876814872, 0.7616912413106036, 0.21507721354242448, 0.22115771305033716, 0.2664531359202785, 0.12973794657268212, 0.21848014717526953, 0.21121453527578604, 0.20878826712100884, 0.21034487810369096, 0.20408539113520607, 0.1312644006360164, 0.20439775357219425, 0.11731886322168006, 0.24056998829473275, 0.1116808057795381, 0.2220241681968077, 0.23746806113613395, 0.1159232477847254, 0.13167765240539808, 9.999999999998899e-05, 9.999999999998899e-05, 0.06376060880700463, 0.0003901724859948219, 9.999999999998899e-05, 9.999999999998899e-05, 0.004567817281351361, 9.999999999998899e-05, 0.08498643764680602, 0.042929783513125264, 0.037144266287692185, 0.14533518067640305, 0.07135471293186602, 0.00707058524975368, 0.010321783498969617, 0.05042574629184837, 0.09309442858567762, 0.028320718464009076, 0.17096710435470774, 0.0336013586585967, 0.17454864635261236, 0.07914265607012816, 0.09131430601239532, 0.07454452000620226, 0.10869616205897403, 0.0724548240747026, 0.07215361597980341, 0.20036924001275735, 0.10071179641642825, 0.06632396118510875, 0.18748834715651974, 0.10509268939811667, 0.0814527510735279, 0.09267424040754957, 0.04611516437660246, 0.08231367901867359, 0.5404784847775455, 0.5651045948701339, 0.5121099139143584, 0.5342221199016448, 0.5382579758984427, 0.5093965304085744, 0.5469973894937036, 0.5738859856076827, 0.5851681680273415, 0.05949353659401879, 0.06149173060135493, 0.07177104044242766, 0.18392747559635558, 0.12439980420914776, 0.11966944153157788, 0.10210799775857193, 0.09981821286442905, 0.13157510565318375, 0.26780221049391795, 0.33251566190829573, 0.22081849840324652, 0.21421778324576868, 0.6167783672572762, 0.23225875998021206, 0.26165289268064384, 0.3331164703961673, 0.21183611460434426, 0.21714353686861354, 0.23444101919138027, 0.3093072598529151, 0.4116783463142808, 0.24761979227098663, 0.3721036795223036, 0.4426309999382747, 0.4654824415393587, 0.512951722700355, 0.2953828030100384, 0.24053691676642808, 0.27703930501877216, 0.269398129026574, 0.40337058925348124, 0.1608093021853203, 0.2593851987308906, 0.26342647858882584, 0.2737966501336626, 0.20698929545648592, 0.16795468678635028, 0.1956242357608321, 0.21002893569806336, 0.19636964478377916, 0.20139949149590164, 0.19675533806411594, 0.21116590924654888, 0.2736963266797321, 0.20105298583096265, 0.225851004594546, 0.24562659152373723, 0.1992036089778394, 0.20617453802619856, 0.22156312976964387, 0.2450462022313542, 0.2466601054748958, 0.2025263479536259, 0.9160683673212473, 0.18134125201939966, 0.1545082237994546, 0.9133388915865271, 0.2013357830600918, 0.4966479251465896, 0.14275921672292768, 0.17035047700606776, 0.9102914511089907, 0.6630371661076799, 0.21324606440390503, 0.15313967922563532, 0.20922436704109826, 0.16898598073384308, 0.15407094097813878, 0.10463761534334659, 0.1988402878207286, 0.7911968949110302, 0.17965136941584114, 0.20237506981043174, 0.18958724732603538, 0.21273583258480544, 0.1793124054078049, 0.1896430337098013, 0.21429376652972298, 0.20020377306942239, 0.22096750085066164, 0.09683544274212508, 0.09293135429095778, 0.08104404031447976, 0.07082246855691532, 0.08848767278926994, 0.09916474501449835, 0.09323247768377896, 0.08117027259234633, 0.09019326261171667]}, "mutation_prompt": null}
{"id": "fabe8e7e-be15-4f99-8b9f-8d7d5cb3da84", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.98)  # Dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced mutation strategy by adjusting mutation scale dynamically based on the exploitation phase.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.864479092998411, 0.850140620029051, 0.8597352371131471, 0.8661620981977867, 0.8398193200134826, 0.8828777491193274, 0.8623285780486994, 0.8529963068247753, 0.8685849877895699, 0.6307941804591071, 0.036977507054351544, 9.999999999998899e-05, 0.6586685645654415, 0.04608818556857697, 0.6981209129121367, 0.6214065970780396, 0.6915103815148713, 0.7011705455772177, 0.18134872105046163, 0.17246812288450364, 0.15813936297730946, 0.5909999623423007, 0.4404464428992916, 0.11313869504003504, 0.14175223454998265, 0.16712648298747868, 0.42987893544698086, 0.10831860480681077, 0.11339621730402816, 0.10943312224527157, 0.10954855903264837, 0.10366193874671148, 0.11156762059149039, 0.14945171099194232, 0.17157951039020958, 0.1789194918796988, 0.9844700345197134, 0.9922777224368696, 0.9851777633208493, 0.9693974851034751, 0.9855871110853952, 0.974732635658836, 0.9877270682473911, 0.9851318985216958, 0.9838907555985201, 0.714581035113687, 0.6405387087824328, 0.05909099462875911, 0.1527712126556089, 0.701419375730362, 0.6357846396669768, 0.6726600003336961, 0.6627907487087679, 0.6976030061271705, 0.3730080039758763, 0.13865422658836402, 0.17247210796834245, 0.21511823773313876, 0.21368982314759066, 0.20189637529654936, 0.6989902518062148, 0.22691320110212354, 0.37834946957991256, 0.2856277983228689, 0.21480014060151276, 0.23224741852883402, 0.22955136382013908, 0.2220803722483039, 0.21841882132799206, 0.20907429080576256, 0.22710437506223868, 0.21139870516985404, 0.2913636001588631, 0.2293608670258367, 0.11898195226696551, 0.23292007449144225, 0.11243229265291554, 0.305259705376448, 0.22001418836804154, 0.25520168624341566, 0.126234752134609, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00020665671626152182, 0.0023032618027259977, 9.999999999998899e-05, 0.00012080456400309636, 9.999999999998899e-05, 0.11567402381575198, 0.04793668539692697, 0.06960470943955988, 0.06869271048375303, 0.09755448731490635, 0.021568231746650013, 0.03261668574867038, 0.04131574985130593, 0.03815488851024618, 0.027089118307107696, 0.19878282498132926, 0.04909978784317026, 0.24001539373792224, 0.11090749281980805, 0.24271378432391788, 0.07459973489008465, 0.16192195254778907, 0.07091146051564756, 0.0701002722841324, 0.19798958667784894, 0.18708408296426893, 0.0737986595661081, 0.09064974132399639, 0.13637309219002403, 0.10626397343027183, 0.09387241033073457, 0.05421772609352704, 0.08186680403782942, 0.5203115832283309, 0.5549602788501222, 0.5121654045587694, 0.5055264309018632, 0.44346661328721515, 0.5189702976243105, 0.5624108266217155, 0.5449660735465172, 0.5539705178409373, 0.08400852989472096, 0.0552951629840589, 0.11288636826513088, 0.09236211301939601, 0.08203230144886997, 0.11149398281287792, 0.15076636147747668, 0.10947784290434448, 0.14157464232723582, 0.37345853450006505, 0.42851081395755775, 0.21974299190761748, 0.20706979109255175, 0.23456451890137286, 0.19932284192062855, 0.5418352659875179, 0.24594659621161397, 0.38451933842917896, 0.3439689215359415, 0.24655487806943455, 0.3981956755856474, 0.3397291030762364, 0.25773782024760516, 0.1954064135493454, 0.2751292289004359, 0.4179414386451956, 0.572054271979635, 0.28202770516665876, 0.19220492133657674, 0.2385292879322094, 0.18888482271660323, 0.2629555302349117, 0.2730222702244808, 0.14015293173959942, 0.27070992425375406, 0.3623579477004425, 0.23237354419439538, 0.16603534740994796, 0.22774574540029402, 0.22362352741764524, 0.1988483335448472, 0.2148712719935335, 0.19087577780211995, 0.22044267802168593, 0.23068759109351578, 0.24717264206957823, 0.20619361333699515, 0.19278794331616522, 0.19102547458727082, 0.24348480337186518, 0.19210935952959862, 0.24280947010350018, 0.22437691569408413, 0.6198211234724897, 0.8979285480251946, 0.8633003846240133, 0.1544445627601777, 0.9081338719674766, 0.20144313778852507, 0.1704590652445851, 0.14272314733732205, 0.1703454144713069, 0.913614365683444, 0.8571701418252802, 0.21344682181216024, 0.15269535967440862, 0.20921067301340046, 0.16897817732094267, 0.15328380676486852, 0.1037769487145892, 0.10389460880876122, 0.7800747243103147, 0.20469928271753213, 0.2160181023999782, 0.2633772977775348, 0.20353358048053094, 0.2152627328803579, 0.2060050526001338, 0.19711750219564772, 0.21250108039085047, 0.24271484325839288, 0.10251849913514266, 0.08618313398663502, 0.10067716268241989, 0.08766815918363768, 0.08722016866080662, 0.08941066732563885, 0.08536362543902831, 0.09952367695060149, 0.08211018624617716]}, "mutation_prompt": null}
{"id": "81fb6957-5118-4a78-aa20-5e64a6c66420", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # Adjusted inertia weight for better exploration\n        self.c1 = 1.4\n        self.c2 = 1.4\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97  # Adjusted dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.99)  # Adjusted dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced inertia and mutation dynamics with a decay schedule to balance exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.18432477991147492, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.41269735088753634, 0.33751901843650545, 0.3908971694466944, 0.5127307939317045, 0.4432213334816649, 0.3916257673809479, 0.4232970293397089, 0.41042418839377515, 0.18235161571831038, 0.02686819429406373, 9.999999999998899e-05, 9.999999999998899e-05, 0.022816184032368625, 0.022582377389790742, 0.01624304497826412, 0.016027962717274025, 0.04132093042381202, 9.999999999998899e-05, 0.09191098880690352, 0.08594624645139515, 0.10654257564925851, 0.08704987423968669, 0.0720695209832265, 0.14296602168843398, 0.10793209640481327, 0.12037618395526839, 0.06623590407831348, 0.09827503214037847, 0.09567789547766192, 0.105237792381771, 0.09286159862358834, 0.09331227542577947, 0.0777753237708132, 0.08162582611438007, 0.07194888676959033, 0.10047149142266842, 0.9865586386223121, 0.9922743022748115, 0.9864220182254145, 0.9769645816585205, 0.9879879968486185, 0.9782139582610462, 0.987764636406702, 0.9877233163028892, 0.9857301712307043, 0.20937336672123907, 0.22839836438869165, 0.0585468037415261, 0.14968054191548652, 0.14465587407115088, 0.13903755513158444, 0.18404273851189235, 0.16484720452114687, 0.12159095911479889, 0.1723897639228651, 0.22593921200670342, 0.1725744799890202, 0.2869810872075621, 0.2622659512354988, 0.1953001397077656, 0.12667427065718717, 0.18527034191282143, 0.29616434833310534, 0.13806962472100714, 0.11106700195724517, 0.11873719412747108, 0.1232895994907125, 0.13163815187538308, 0.12390858453476217, 0.11925049885807182, 0.11982868185751117, 0.13386708067912845, 0.14234112448113212, 0.11010289702252518, 0.016307165162261494, 0.11567476133946042, 0.030796494495153648, 0.12142166820763156, 0.1173417277653721, 0.07069190067818731, 0.1415280603140815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035935351780157165, 0.02349164932789749, 0.12355155339140822, 0.07973579487981386, 9.999999999998899e-05, 0.0025482171329572756, 0.05693114064398086, 0.045934151449721905, 0.057204170715678404, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017764166012292137, 9.999999999998899e-05, 0.0008473795015710994, 9.999999999998899e-05, 0.042171999669519344, 0.07435472276041055, 0.09741205990554735, 0.07284146540321967, 0.0042129964379628015, 0.07584429616808908, 0.04684364329054058, 0.062053554530609345, 0.04289285489747996, 0.04675430504305278, 0.3462954478169564, 0.3545565378078691, 0.34137810292694637, 0.3391384765101738, 0.3411903884707679, 0.3231173944804968, 0.3657836882849299, 0.32290166615498705, 0.3940605990732895, 0.09176423615579898, 0.06465095289430645, 0.05362740056957427, 0.08578919682446173, 0.08513424305206663, 0.0939454502123126, 0.09404615789001469, 0.08324568401904764, 0.06829937650506346, 0.18688962900395922, 0.1438425989019133, 0.16158210194393252, 0.17291413649733145, 0.19977066104675933, 0.16688439706373515, 0.1712782230490546, 0.1869150769270067, 0.2048044300138696, 0.2556389061023596, 0.21594820492308442, 0.24977058651244233, 0.23545205368869226, 0.20355456784100778, 0.23379268481644666, 0.28113811952179457, 0.2668831947150665, 0.2646668164494421, 0.14837187902282767, 0.16720268009881334, 0.19932953504389428, 0.20374207265670274, 0.17691849834272522, 0.20220741617425997, 0.19883804332472377, 0.22158768236732618, 0.20551079673194672, 0.18288399052087712, 0.18612299839207314, 0.20506395774203257, 0.17740117053141768, 0.16234642168281732, 0.19540651392804798, 0.1880578944463338, 0.2036599683896274, 0.19853186686890534, 0.18759909884320813, 0.18612736171543875, 0.17389226953279813, 0.17949290278170704, 0.18861388883659091, 0.1865696833089856, 0.19330736910299695, 0.17268039280232572, 0.1691622570026522, 0.543863802703441, 0.16658322621467758, 0.15436177843478782, 0.4840708834312788, 0.19688072748731877, 0.19765146703685454, 0.14075497023181394, 0.16999563786584038, 0.2067047889629985, 0.4221139340609228, 0.2097846947726676, 0.14603356244166876, 0.20786872691046032, 0.22704214319067195, 0.1536208807823809, 0.20293077089837797, 0.10484112171802973, 0.2561510855113944, 0.19467913456793629, 0.1843647669830344, 0.19730830316829495, 0.18766773654842295, 0.187110336932511, 0.17193674839032724, 0.18960662298027464, 0.19152072452886815, 0.17348877751513303, 0.08281751775386803, 0.07782183762497863, 0.07340607588927628, 0.08764831477049206, 0.07360046930362862, 0.0730135742310748, 0.06880910850155464, 0.08077654876170104, 0.07674285224617905]}, "mutation_prompt": null}
{"id": "f8460816-1be8-443e-bd62-e28c5c68c7ec", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.w *= 0.99  # Dynamic inertia weight adjustment\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.98)  # Dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Fine-tuning inertia weight dynamically to balance exploration and exploitation more effectively.", "configspace": "", "generation": 16, "fitness": 0.29071334168425694, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.28.", "error": "", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.9023277474393514, 0.8918200821958931, 0.8963679678199318, 0.9060576038846245, 0.8932990692797992, 0.904875406342097, 0.9022257541001015, 0.9065018533882059, 0.8161827789451912, 0.0400594820935396, 0.35899770459219715, 9.999999999998899e-05, 0.060231348251971184, 0.04728371453960423, 0.4508989197858083, 0.051367247440010755, 0.46222513013383904, 9.999999999998899e-05, 0.13134731723830573, 0.12056242437894504, 0.07344958536968837, 0.21737891107768914, 0.12048953834507559, 0.11374641905792504, 0.1759297825019086, 0.5999786403575655, 0.1410970479963891, 0.10479124968762299, 0.09338377150473298, 0.15574037341325708, 0.12313894282640847, 0.0980844687924447, 0.1139864478431476, 0.14051727241345557, 0.10978901436604716, 0.15935552601944603, 0.9843420318966881, 0.9922776987954036, 0.9851568888674588, 0.9682203585312491, 0.9855754658416296, 0.9746961142806486, 0.9877264323037555, 0.9851243345869906, 0.9838831272347633, 0.5472876607995107, 0.6469980482935845, 0.7150107913589056, 0.1531227080031593, 0.24125721785450593, 0.8244301807972976, 0.5945789579705086, 0.3513753722216245, 0.6307728733804778, 0.9092422327718441, 0.13891491469963935, 0.1724572526834951, 0.27299243647461013, 0.21309246859561848, 0.1929830032151889, 0.13102127774197725, 0.1303470971552113, 0.2249890889770244, 0.3981885697718889, 0.16123548801611542, 0.18695166144197817, 0.26769575752435926, 0.18257296344292684, 0.1881823458618902, 0.179930698594865, 0.21596352235012795, 0.17121764905454784, 0.34210380705331, 0.1877352233315709, 0.11974431532028085, 0.18145554727998336, 0.1323177334134592, 0.17094386475446222, 0.17979367580103844, 0.18260690036101412, 0.1279322061457575, 9.999999999998899e-05, 9.999999999998899e-05, 0.012624012578284605, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0557128894834954, 0.05776715937665755, 0.08356256798565631, 0.06048162855866179, 0.05510131063241386, 0.009599922613225731, 0.027414084028979824, 0.05815116024782219, 0.07150928918487842, 0.05217871249713113, 0.20187929194657261, 0.039146353853125815, 0.20960538710136578, 0.09965021340344993, 0.09767411275230331, 0.09155773561178926, 0.1545876420801673, 0.07427902416863841, 0.07319157717974156, 0.13920348179890174, 0.04705021601007242, 0.10009268395570292, 0.1590308015322759, 0.11948387220124879, 0.09686253055747673, 0.10935705194915879, 0.05639751983696062, 0.08360077140060107, 0.619777445241054, 0.5404205555267108, 0.5374405393637465, 0.4861628915857775, 0.4922972733935469, 0.5191644393226139, 0.5436167238044572, 0.6169690943240038, 0.5644460205133193, 0.08991853472942235, 0.0805698289933181, 0.07226808109018179, 0.14174702641488168, 0.09697054162940277, 0.1306004891068746, 0.07922608636433559, 0.11109494223464678, 0.0918544814820943, 0.42913169913132443, 0.22396746683926938, 0.2275116856540198, 0.2535908659992626, 0.22684485191803294, 0.26500840383324786, 0.1696838056187291, 0.2528618238424989, 0.17636193032517766, 0.47449264436861727, 0.26282078171447343, 0.3732177131155887, 0.3430122121291159, 0.22769822844361065, 0.4751366900866332, 0.3786799009707237, 0.8040530631567164, 0.47685956516546035, 0.26400181306342985, 0.24710933779611433, 0.3603402093868592, 0.1750891777785104, 0.24562637054258307, 0.28296226173168393, 0.18666818918289596, 0.3151099556204414, 0.2348637638786779, 0.2204775155591857, 0.18332246696740429, 0.255147426201465, 0.22881638316687336, 0.17496359027313813, 0.18567438684915383, 0.2288567168531589, 0.1933263154122199, 0.23843720524602008, 0.22393716229288074, 0.19624066514908434, 0.20304054055405973, 0.18107368185679573, 0.208877951364129, 0.20976115921457983, 0.2106117432686876, 0.25146779063623537, 0.2091808699609332, 0.9162435909758845, 0.9170428650391493, 0.15447406894233828, 0.9246164845646027, 0.2015047327015531, 0.17047040685277026, 0.14275101781570487, 0.1703800026829193, 0.9325042118803567, 0.8941007651142732, 0.21356042208790937, 0.6665061526221074, 0.20953171343830912, 0.16876091710654728, 0.1543581292114854, 0.10377656482806485, 0.1049499180389557, 0.7530829784382872, 0.22913256215884625, 0.2056361750969239, 0.23210892080318102, 0.21430250456353184, 0.19095617787152697, 0.1826902793983589, 0.20042275557480815, 0.20240558012638432, 0.20408737551269662, 0.11920491781821196, 0.09327048444784891, 0.10133942495279002, 0.07577051066100571, 0.0944797874119837, 0.09139795111827587, 0.09011058138900829, 0.09770187988816292, 0.10439650262331912]}, "mutation_prompt": null}
{"id": "bdc4e775-0124-40dd-9fcd-00e2bfc64ab0", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n\n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob = 0.1 * (1 - evaluations / self.budget)  # Adjusted mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.max(scores) - np.min(scores) + 1e-12)\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.98)  # Dynamic mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved adaptive mutation by adjusting mutation probability based on iteration progress for better exploration-exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.30738085375289403, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.8655375761440414, 0.850140620029051, 0.8501811311493628, 0.8633670445526832, 0.8584738952138292, 0.8715056350687178, 0.8683160047289455, 0.8620181260892388, 0.8686194361375031, 0.6206037795017083, 0.03699137078621484, 9.999999999998899e-05, 0.6514386823577192, 0.046085863393930726, 0.680744475431446, 0.6822862333269419, 0.6753000186630387, 0.7063378939129923, 0.272486918929024, 0.2974205469007173, 0.1755508023243334, 0.4743281908747864, 0.14171066267161547, 0.11625135044658286, 0.451079677330704, 0.16197714111365347, 0.15614493174809518, 0.09783222614906029, 0.11237659357247098, 0.09332399354163023, 0.13563922036264286, 0.10767614748817489, 0.13588814264792815, 0.13992018930607752, 0.15171544563517292, 0.1403136702746156, 0.9844700345197134, 0.9922777224368696, 0.9851777633208493, 0.9693974851034751, 0.9855871110853952, 0.974732635658836, 0.9877270682473911, 0.9851318985216958, 0.9838907555985201, 0.7053288475240245, 0.6307057255417012, 0.34873910839920297, 0.15276370696397734, 0.6923933208593702, 0.6543165327688645, 0.7034816121627843, 0.6542942287206315, 0.704042928224552, 0.35051605668475727, 0.13908824320638746, 0.17247210796834245, 0.2659588124371388, 0.21368982314759066, 0.20189637529654936, 0.38079204583557047, 0.33802676652370056, 0.37834946957991256, 0.27086627421849563, 0.21615521987433017, 0.21481990444716326, 0.23314413782686272, 0.21433081318758762, 0.20959934823834214, 0.22148381349866408, 0.22400733997202638, 0.2209894273420282, 0.30242160876877044, 0.2311505407630574, 0.11907579884074726, 0.2340962062165729, 0.11222904169724102, 0.30539361050635694, 0.20968006679621654, 0.2548337229867875, 0.1263471566464145, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012170678017919823, 0.0004290687699495255, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08938163109344788, 0.056754379653663256, 0.05866579472989719, 0.06813319919156458, 0.10101814351922855, 0.030582601295028544, 0.03545751759788951, 0.03468556692595359, 0.04861797037779603, 0.035404860016384876, 0.19839602446946003, 0.049023112045693984, 0.2117930471871199, 0.11382263173918639, 0.24586595474297224, 0.07497425767641375, 0.1615652871800547, 0.06834120378974129, 0.06907888657592409, 0.19808184175898103, 0.18653608560325574, 0.07264041993144532, 0.09304954968553503, 0.1363198186492216, 0.155416723084027, 0.09381568661085016, 0.054276032313468225, 0.08185451307678215, 0.5263169097192415, 0.5496510533188927, 0.5153860674033579, 0.520524745275819, 0.546847374690177, 0.5675810039059597, 0.5666463605205663, 0.5634857518022116, 0.5455584418860517, 0.07748795852697199, 0.05529516298406556, 0.11235885729726247, 0.09236206158178828, 0.08203229660502953, 0.1066645965533709, 0.10920547896451338, 0.10891265144354634, 0.14114730841769574, 0.4090929857281099, 0.3023872271929543, 0.22633325492446443, 0.20850595405334515, 0.27511471411433597, 0.20573112358658907, 0.37672537088237124, 0.2487981459577392, 0.4314859096155049, 0.3439694310928808, 0.23505245413345677, 0.39109108505585677, 0.3395697629496184, 0.2550435136296595, 0.1936569812884592, 0.2751492478299058, 0.4419960210954351, 0.5029448594031465, 0.2823704322529125, 0.18221884592002302, 0.2835995791462529, 0.17758472875661302, 0.3055306342964169, 0.27413744115093663, 0.1401348022640716, 0.354547366245227, 0.3328859090874785, 0.21149598951951387, 0.15892683491956483, 0.22775784074162542, 0.23782399809601107, 0.1895816689769153, 0.20851103131771298, 0.20179506896079824, 0.20602605642417093, 0.22799023590094414, 0.24438322217244224, 0.21410452704465255, 0.19284003103338432, 0.20505833258997197, 0.24336938303274303, 0.19337419638807873, 0.19870081310274212, 0.22437668301421632, 0.661242998599098, 0.8891445978307146, 0.8796003201062341, 0.1544437553753687, 0.9071075146125607, 0.20144299766367557, 0.17045905861914712, 0.14272299380929365, 0.17034533174167776, 0.9070052249004416, 0.7932608023888811, 0.21344158232385857, 0.15232401431427045, 0.20921055955530976, 0.1689781797801223, 0.15328371377448635, 0.10377694870675191, 0.10389460880876833, 0.7572937446987894, 0.19291241203750786, 0.223651769966295, 0.2682159525997888, 0.1843761118811389, 0.20076974251395974, 0.2166582139786084, 0.19286157763656486, 0.2213546041266824, 0.23531947787250362, 0.12075595292027597, 0.09561659951462553, 0.0999339038909105, 0.08895019811272598, 0.09133615821710428, 0.09140169950508914, 0.08288707508686444, 0.10070467572770636, 0.07808218960031021]}, "mutation_prompt": null}
{"id": "47d608d9-a47c-4b20-bf15-24482c3bb455", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)  # Changed line\n                self.mutation_scale = max(0.1, self.mutation_scale * 0.99)  # Dynamic mutation scale and changed line\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 0.9, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Hybrid mutation strategy with adaptive scaling and probability control for enhanced PSO performance.", "configspace": "", "generation": 18, "fitness": 0.3078940054492418, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "5232db92-d94c-434e-ab3a-17a0b1442cea", "metadata": {"aucs": [0.8609382512608793, 0.8400838371376014, 0.8528363440604714, 0.8516058966992572, 0.8579062979988566, 0.8557507446855488, 0.8501637411055682, 0.8621772138154021, 0.852166400924502, 0.6615024133554137, 0.033889056702593345, 9.999999999998899e-05, 0.04434049784228755, 0.6017630037816195, 0.6834685088123487, 0.05042587876280813, 0.6720157590023792, 0.6921750530756383, 0.16668786372404687, 0.20902682058123456, 0.17215763892097147, 0.14787326390991928, 0.150460396054254, 0.15770888038882747, 0.40608741449071506, 0.15050230155227495, 0.5159940314793232, 0.1641853517259444, 0.09497577776101951, 0.11825897710793232, 0.14491661859086402, 0.11946943641890828, 0.14029623136137348, 0.13697424037273942, 0.11712838830385086, 0.11431165223208595, 0.9850127763287233, 0.9922777224368696, 0.9851777633208493, 0.9781863623197485, 0.9855871110853952, 0.974732635658836, 0.9853809279358188, 0.9851318985216958, 0.9838907555985201, 0.6486381711249458, 0.6865285967081173, 0.5416907074303062, 0.641432164509454, 0.6716779177942893, 0.658463716468839, 0.6790174610626099, 0.6213246151331453, 0.6825071926748663, 0.3729317817435709, 0.13897758399772464, 0.17247210796834245, 0.22115138722740535, 0.21359169409762002, 0.20404816076860943, 0.24149185174356635, 0.1760946158864345, 0.7572257306407008, 0.21338829152343886, 0.21488323291842693, 0.19531361666059788, 0.21990400012127087, 0.22010129507209564, 0.21855270629041101, 0.21386279921019447, 0.2250660835668904, 0.21296881215931718, 0.23330766448171913, 0.19920566600474554, 0.11826371437525485, 0.21193321277971122, 0.11015025536705358, 0.22428187295945035, 0.269257697980528, 0.24559330183287076, 0.12820556377540926, 9.999999999998899e-05, 0.030985183246720394, 0.00246494387357854, 0.03163052482761364, 9.999999999998899e-05, 9.999999999998899e-05, 0.00027930680616028436, 9.999999999998899e-05, 0.09185948657459941, 0.06727722391985391, 0.0475449740087972, 0.07401202257807893, 0.07319988049459136, 0.012608175852785508, 0.05646816353248196, 0.10364883259899382, 0.058314447756915966, 0.029948624617552433, 0.04784706307054987, 0.04425042067069973, 0.257306929535688, 0.07517396389599484, 0.24434198847843458, 0.07299587720776768, 0.09486873937312079, 0.07006773806776068, 0.06998669590938311, 0.05989370055101095, 0.21846712907871102, 0.06854144737098067, 0.13922587381952412, 0.11722845642411428, 0.19066735824259784, 0.0803540695031163, 0.046746736703174196, 0.08084744006709332, 0.5995849333483747, 0.5447605924908518, 0.5576054505757788, 0.5518964680551011, 0.5784962477609056, 0.5136017650436635, 0.535436840898726, 0.5620991917212625, 0.5869654595547575, 0.12749022626648543, 0.08088411139967666, 0.11344283953606682, 0.15338869592998328, 0.08653771542459654, 0.13328545928216828, 0.12386703036826652, 0.12187031158133066, 0.1259313739293928, 0.32698198934014144, 0.34443502007110205, 0.1873967146648865, 0.2624782497630709, 0.2576452316200901, 0.2616793504452828, 0.20093792583657277, 0.23231376115823965, 0.23766312167381998, 0.3174768241236777, 0.22484086439599327, 0.36613193912480546, 0.5506804165037336, 0.23543460887805745, 0.19859998192754857, 0.58445951878487, 0.5463446239669472, 0.2784645471420374, 0.2530888406795877, 0.2568659527985151, 0.37528062259049966, 0.23462998019132242, 0.3337987583026917, 0.27644876349481007, 0.27107070262553534, 0.4027405357206568, 0.28240200970324714, 0.20146048952902795, 0.1724219476459219, 0.22582665341541652, 0.20206882238957657, 0.18413119663113253, 0.1885468968741869, 0.2615214021650789, 0.2570516641827273, 0.2135301810590582, 0.20582022318141002, 0.2060856041705138, 0.20776513681810316, 0.21224936776275483, 0.2494469006282769, 0.2227553443415219, 0.21061831012789334, 0.2252035165091354, 0.20833790850975054, 0.9033264243532346, 0.8866673762702428, 0.15450542238889287, 0.9025536112947846, 0.2013186112963603, 0.17045662688616536, 0.8806829055236605, 0.17034726366781505, 0.9197266978704571, 0.7739650463276759, 0.21342654391308025, 0.15222704592159242, 0.2075021557522222, 0.16897688794390375, 0.15302520873534964, 0.10468198513308813, 0.10389409127758553, 0.7402766127197715, 0.21707764476050306, 0.17878175623328063, 0.19601545482148008, 0.1779943693995618, 0.1837369817000798, 0.2016051913209661, 0.18964656455865503, 0.18593918206766902, 0.20412683859545577, 0.10673714662767597, 0.09175836007225657, 0.0955309963629124, 0.07971097853715314, 0.08096975740095202, 0.09831902764570588, 0.09769786787940682, 0.09714667345544403, 0.0938119337602793]}, "mutation_prompt": null}
{"id": "f382c9e2-6ca1-4a40-a19a-da231d23167b", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)  # Change 1: Clipping velocities for stability\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)  # Change 2: Further reduced mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)  # Change 3: Adjusted mutation vector\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced Multi-Strategy PSO with adaptive velocity adjustments and refined mutation control for improved convergence.", "configspace": "", "generation": 19, "fitness": 0.31710137742707145, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "47d608d9-a47c-4b20-bf15-24482c3bb455", "metadata": {"aucs": [0.8752902749170869, 0.8654054133322393, 0.8777942575073041, 0.8526162983885475, 0.8431411892710066, 0.8622812110574927, 0.855958598912802, 0.8642022835123847, 0.8626131039984173, 0.6836007506059525, 0.7214599225269742, 0.6858156795193064, 0.6713141597133672, 0.6711869318428128, 0.6808373071501165, 0.7219460848470909, 0.6653900878942924, 0.6679737390728131, 0.09014821869856604, 0.15915264189301592, 0.10491389128392492, 0.13820722773174698, 0.15661032509474904, 0.14809311867091768, 0.089781181769648, 0.13706394537755517, 0.11311587784928001, 0.10754795661870287, 0.11898007163579771, 0.09221778346681075, 0.11742727027808231, 0.10615096849553263, 0.10952949279854929, 0.09860337087032456, 0.13230344350379908, 0.08071141720721475, 0.9182235713350091, 0.9033226538619297, 0.906272525524709, 0.9064753778308081, 0.8860513875177785, 0.9132015912530559, 0.9002464105285254, 0.8857018378092784, 0.9081748034025547, 0.7249135188400728, 0.7444677189667707, 0.6172377845829701, 0.7121521901390335, 0.6886252669136929, 0.6750094428631763, 0.7237087714733648, 0.6982393847720012, 0.663788299805846, 0.8019868495480746, 0.17057044899611828, 0.2184746389800022, 0.22007526218740425, 0.20699633458969324, 0.37328854985597304, 0.14979935973233938, 0.15183475617116293, 0.38892351529769, 0.21728032509524975, 0.21125910781229718, 0.2470770543444566, 0.2629371602823709, 0.21169043294943735, 0.2506247860390045, 0.22128534268679023, 0.22075464149307478, 0.20996541925883427, 0.2389998068034539, 0.22377712702082952, 0.213660768235575, 0.2342013715948983, 0.25588560992561693, 0.13457832153936766, 0.3437095796175439, 0.255630342984435, 0.24388919530392272, 0.046798403931685106, 0.18925307760518606, 9.999999999998899e-05, 0.06618217912327273, 0.006106620250717842, 9.999999999998899e-05, 0.008329186428279733, 0.00012904817928915957, 0.01203590319424963, 0.20662280069191774, 0.07878690788222453, 0.10102229799017182, 0.061383553655008694, 0.013650002904064595, 0.04046265514823677, 0.07752005941324036, 0.08900253519924461, 0.08441669510941208, 0.26612941528217526, 0.1943756158063633, 0.13019758800877057, 0.14100044460777283, 0.17012897502780921, 0.22579251715412352, 0.10537156403739878, 0.10041798045492256, 0.25038943060105523, 0.13567207899128098, 0.13694750829361746, 0.16210413259424372, 0.09267244282400955, 0.4133853663732957, 0.11808552767478564, 0.0796087156951153, 0.39590851726560505, 0.08215297839561098, 0.5138484727866144, 0.5280775326963507, 0.5373029601240142, 0.5827993942319473, 0.524463496502726, 0.6055371691759124, 0.5815927975107835, 0.5549177935915912, 0.6187751071236975, 0.06630754939895045, 0.050203301952736146, 0.060433860798369654, 0.12157887738205286, 0.11503982551996628, 0.099786642235287, 0.12411100072547399, 0.14852482962658775, 0.14274821777693814, 0.2631712940333726, 0.17260016174539905, 0.3744052793520778, 0.2420165980664487, 0.26696457699111387, 0.3486954553699222, 0.2100472013830691, 0.32117361697355706, 0.16142556037661926, 0.19881245089078614, 0.32487877363780204, 0.2044531633693475, 0.44781298418107784, 0.35723747211227175, 0.3283685457580263, 0.2597849469411282, 0.4015162173757817, 0.2919976319656187, 0.23656332313811845, 0.33722529261748135, 0.22407379738466238, 0.21305084626818993, 0.2369417783901132, 0.2892412517382271, 0.23905334744339002, 0.27027475830578407, 0.23833289871037755, 0.23241513820318194, 0.2407381076891274, 0.20506517911383426, 0.19743187765885928, 0.21942040695811238, 0.26569835694125943, 0.28177349644464655, 0.21008868316820195, 0.21785006340714885, 0.1980159160855447, 0.22037636472867383, 0.190376640793275, 0.19016788671994067, 0.19680208300790436, 0.19220406945695556, 0.208220411919944, 0.2088339233400005, 0.21566779209643439, 0.12608521146044782, 0.17595405511982676, 0.13303407155730496, 0.9110899308141853, 0.16848353560339469, 0.20000911497306995, 0.16139463239297713, 0.9110853974565645, 0.9397348990544566, 0.6113305542098384, 0.1567117922599195, 0.8136388704184749, 0.20741820285081836, 0.16826205424316398, 0.15403103423335285, 0.16514768149288395, 0.10457001847236502, 0.7598054341969789, 0.21750875006404735, 0.18711895839398085, 0.2443896659585657, 0.20257500944991558, 0.20494745101724532, 0.19135224318487065, 0.2093712559957137, 0.1942527117203353, 0.21791785905515149, 0.06653775763059566, 0.10590911853982121, 0.08156053337329217, 0.10769462426305398, 0.10004684793710616, 0.09886985925873926, 0.1293363323781188, 0.08494182961199748, 0.08786890531746872]}, "mutation_prompt": null}
{"id": "23a7be48-6dee-436e-bc7a-9c2ad0fe7b53", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n            # Periodic global reinitialization\n            if evaluations % (self.population_size * 10) == 0:  # Change 1: Trigger reinitialization every 10 generations\n                pop = np.random.uniform(lower, upper, (self.population_size, self.dim))  # Change 2: Reinitialize the population\n\n            # Velocity direction adjustment\n            velocities += np.random.uniform(-0.05, 0.05, velocities.shape)  # Change 3: Introduce slight random direction changes in velocities\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adaptive Multi-Strategy PSO with velocity direction tuning and periodic global reinitialization to enhance exploration and convergence.", "configspace": "", "generation": 20, "fitness": 0.24680098258865796, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "f382c9e2-6ca1-4a40-a19a-da231d23167b", "metadata": {"aucs": [0.4533799862240946, 0.5531049026356476, 0.5757780378612001, 0.5412837539122135, 0.5286086233223958, 0.528322076766323, 0.516554218784529, 0.5199078730139239, 0.5322548584523323, 0.14679039268850613, 0.09328481974660208, 0.1051991097099193, 0.09447892508471722, 0.07036241003452992, 0.10225184422998823, 0.05068060821167819, 0.0318777342694162, 0.04928907128147131, 0.11386147629806054, 0.09892653194760803, 0.08741547486435086, 0.12096373641826852, 0.11605138893361566, 0.11008483425704052, 0.10713900731535775, 0.0992967712562246, 0.14963057725121687, 0.10419194578682056, 0.08052738736923803, 0.1280329883007395, 0.12800161100976615, 0.09990165041439492, 0.0760620801128089, 0.09813854010487633, 0.10172921816669145, 0.08342667550109784, 0.922197853080813, 0.9178070405829956, 0.8918459049101481, 0.9088456863880168, 0.8957548569130824, 0.8882624824546526, 0.9010142942099529, 0.8849831572106205, 0.9002778228186906, 0.3905029642511416, 0.3770444084833088, 0.3550735734914844, 0.39374328524857816, 0.36708438915070374, 0.3998425966948109, 0.39363495610506694, 0.39515504419826053, 0.37929379320269463, 0.22548801102494598, 0.17070360168906296, 0.22631466285828716, 0.279719207632258, 0.27763007932749983, 0.24943000140287364, 0.17449707472758824, 0.21025055962401196, 0.23531991810327424, 0.24740475365129078, 0.16563912177292273, 0.1266266242077445, 0.18182806162312848, 0.22013499514989776, 0.11317737278409912, 0.19420672966034014, 0.2818018703882481, 0.12974631381441648, 0.1991989734718682, 0.17158170105343873, 0.23235153549685061, 0.1456816811087288, 0.18359087841003396, 0.19579500500913338, 0.23587564235846037, 0.1839846059288397, 0.2044275820382836, 0.00013593448648863138, 0.09463354552517356, 0.12228471635636073, 0.04477697930118263, 9.999999999998899e-05, 0.005934641260162632, 0.01630147034114393, 9.999999999998899e-05, 0.05573051438863419, 0.1368433964722, 0.07807443544817383, 0.13132367110002452, 0.08421364226938222, 0.03925491834834027, 0.021977807729235077, 0.13052987007180017, 0.06942440916465475, 0.0707475352407404, 0.0083053242731288, 0.019479170944872726, 0.023761799837204833, 0.0057269422797493474, 0.01789195664545573, 9.999999999998899e-05, 0.013589825388677146, 0.0015031695301027659, 0.010444662698291696, 0.09921738852309758, 0.11113133521486762, 0.10434002137478215, 0.06942549970864365, 0.16294152085571312, 0.12944042198946515, 0.09507030528537597, 0.14622349472567076, 0.08102827875999519, 0.48203507878508034, 0.4913617428741822, 0.5002911092039533, 0.5025913884900566, 0.4562465955219972, 0.4784072203557771, 0.49398889210091856, 0.4825577341226627, 0.48555620972679614, 0.05036442208433234, 0.07732006682328396, 0.07483163080785926, 0.07094256385299125, 0.09110785044951486, 0.10135053731916921, 0.08993618919401125, 0.1362575150927614, 0.10931067431164954, 0.24925895087082872, 0.33092950379190655, 0.33751373337035395, 0.30982666802069936, 0.30484812421809304, 0.1801869722828633, 0.22773010483546563, 0.35237754654769404, 0.19081614844268646, 0.21769722042820872, 0.33124884663307064, 0.21036070961770725, 0.33941780553218526, 0.23931102466996268, 0.3269140909554994, 0.21278435339750768, 0.3429210751662847, 0.3221816728444743, 0.21779666658848484, 0.2377564996125373, 0.12895235673042205, 0.2999289709779026, 0.20353902579504324, 0.24014169569101862, 0.2162752015631767, 0.2767266580021618, 0.21718561189639818, 0.20164304094720542, 0.23043056856538946, 0.22416155062539034, 0.22206766706382874, 0.22422816845353521, 0.2383889197568515, 0.22410176716902175, 0.28577730402696266, 0.2608049421140447, 0.20715112613569653, 0.1974326702578567, 0.18785939962438214, 0.19006320198991744, 0.17869721535005834, 0.18098646002245544, 0.1967633953619612, 0.22323263576755958, 0.18453047989649907, 0.12642363845211801, 0.17658228024566214, 0.13288190734695693, 0.8477939216495991, 0.16845227659943374, 0.7684010056492541, 0.16166705497369893, 0.8417593363619728, 0.8455707461980391, 0.5013725520403869, 0.15635320975548417, 0.5819470188664586, 0.7504906049255466, 0.16761481777707177, 0.1533794494781585, 0.591186976251995, 0.5481940260089266, 0.6208403010066896, 0.20467236812140133, 0.17805189483890804, 0.1750027705605729, 0.20091548910907808, 0.17884982000927008, 0.18638664873671162, 0.17320405141599715, 0.1817387887630162, 0.18927613044102587, 0.08505283022974641, 0.08088329569969777, 0.08080547463467425, 0.09183066824871533, 0.08276189009360735, 0.08734162548070634, 0.09159233559917013, 0.08592725432415149, 0.09283218573896479]}, "mutation_prompt": null}
{"id": "9f6b9f65-27b6-4a8a-9596-0096c4813e78", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.5  # Changed social parameter from 1.4 to 1.5 for enhanced global search\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)  # Change 1: Clipping velocities for stability\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)  # Change 2: Further reduced mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)  # Change 3: Adjusted mutation vector\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Slightly increased the social parameter to emphasize global exploration.", "configspace": "", "generation": 21, "fitness": 0.30879130874155963, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "f382c9e2-6ca1-4a40-a19a-da231d23167b", "metadata": {"aucs": [0.8600929990488884, 0.8756937063339234, 0.8555127862227584, 0.851105665766413, 0.8278680026303048, 0.8501356849551273, 0.8527954239956307, 0.8654536187844523, 0.8597427435630538, 0.698329833665067, 0.6916588705859371, 0.6356333772750169, 0.6797719424594835, 0.6580659679463677, 0.6869745495984635, 0.6406163377210687, 0.6762983517181465, 0.6384888615216878, 0.12300781697721208, 0.4384611372688789, 0.11790710150441464, 0.10118896179375936, 0.11569208393905306, 0.12230360895024173, 0.10929269880019998, 0.1605251008390427, 0.12139488738125925, 0.0844166107265788, 0.12100043876812472, 0.08714909002001037, 0.1038454875189051, 0.08639536067573572, 0.11236994554213775, 0.11422987136676166, 0.10102994519818476, 0.11037975815127465, 0.9213801626853493, 0.9007576331421819, 0.8956257370315902, 0.908182345808676, 0.9058681896319734, 0.9204672702856314, 0.90268586669089, 0.8898908978418363, 0.9037079796069778, 0.7097610730081136, 0.6882768974565139, 0.6425418038973513, 0.6846697392222385, 0.7166204056577263, 0.6661904170684486, 0.6808243189313969, 0.6734070875118692, 0.67322241143129, 0.3852473627555102, 0.17032055718169614, 0.1369594631562322, 0.27891832944973427, 0.2710617776109122, 0.3714630994319702, 0.16209159259246275, 0.17798304988651104, 0.2357540052068876, 0.21419943385549056, 0.19799764939400133, 0.2755770060333027, 0.22017808986532605, 0.17144450026465363, 0.2355401027755596, 0.2095491845058165, 0.2216009528899694, 0.17948629667442728, 0.13424627758192642, 0.21713966877655133, 0.21092981330739302, 0.22225099213996125, 0.26848904581263133, 0.1344387596089779, 0.33421865908761017, 0.2511700171435036, 0.2689105128535517, 0.07425422873559873, 0.06417590831179754, 0.06847323291083762, 0.05628414728735531, 0.05237854689536148, 9.999999999998899e-05, 0.042060707599567704, 0.00010171591120344825, 0.014012691152982204, 0.11936334980126828, 0.10212616158545973, 0.08917594992164046, 0.05406640601352952, 0.005466624643339468, 0.04612245870775111, 0.07783079537438298, 0.055004102207852346, 0.10309597985353736, 0.20598375779405576, 0.19873866145224206, 0.13408512246790072, 0.14047286945175952, 0.18708577781915303, 0.19093269542828284, 0.10955783566403465, 0.09248838136692339, 0.09210203012915519, 0.13905322820487487, 0.15729078555299125, 0.1253319387595957, 0.06039846320973519, 0.2188222460393494, 0.1404147264307838, 0.0798628217044215, 0.22693665459208456, 0.08272636429802949, 0.5653541482325826, 0.5132326729983295, 0.550938684492885, 0.5808631514869047, 0.5846422575995595, 0.5542162511106667, 0.5666378582874085, 0.5373378193253766, 0.5780447177472188, 0.051825731112844164, 0.05173703088169335, 0.0614119957671424, 0.09075933882894349, 0.07192282317748089, 0.12239751000379928, 0.12830231114708135, 0.1039493715765446, 0.1821625794476407, 0.1738697628326592, 0.16189776779010956, 0.2083810074606085, 0.30190442058430766, 0.26925630081763774, 0.43163564664571474, 0.296676907280245, 0.2521438348539815, 0.32005270024218446, 0.16679020980524095, 0.33875304072439316, 0.3481860201853264, 0.45443462549318125, 0.25626951660876207, 0.3294347348896274, 0.22039541324543277, 0.4193539020836764, 0.2541081373965689, 0.2093623881129767, 0.26467665645642857, 0.20043632960031432, 0.2706833711827641, 0.21702868677645892, 0.22448870391492415, 0.236971316629757, 0.3467201580803907, 0.2354792002974675, 0.22547268624275285, 0.23023570013024452, 0.21531216958515753, 0.22759699239180553, 0.21725871781200212, 0.23013817037423956, 0.24829272114115886, 0.22776090261766757, 0.24409996310895832, 0.19805899622440526, 0.22366182295512493, 0.18353795034758624, 0.19175542509723675, 0.17693586518628468, 0.18063795018517537, 0.20835055702556626, 0.2513697244169927, 0.2436005837067533, 0.1263118361454426, 0.17654243360473887, 0.13353033901592826, 0.9134514283677017, 0.1684295638237483, 0.20002372474355512, 0.1610246856289741, 0.9171543506718516, 0.9394338590825128, 0.6828613420919658, 0.15649051168721184, 0.6509173666067889, 0.20845081094026718, 0.1681887465505455, 0.15267609215368372, 0.16469875552356994, 0.10459197050020153, 0.772104364126596, 0.17745288377635393, 0.21500961761394943, 0.2021837535867208, 0.22152359435494984, 0.19417735639525058, 0.20284933989898013, 0.20132693493059928, 0.1925388118841267, 0.21870515101824162, 0.09204677021262941, 0.08136289237187433, 0.07683605118429859, 0.07815198535069667, 0.09753875821166125, 0.08088753682284877, 0.08280557191357785, 0.0829555048661832, 0.09203164750927284]}, "mutation_prompt": null}
{"id": "a6a04d99-abaa-4a88-b393-9f434f61764f", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.7  # inertia weight\n        self.c1 = 1.4  # cognitive parameter\n        self.c2 = 1.4  # social parameter\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)  # Change 1: Clipping velocities for stability\n            pop = pop + velocities\n            # Apply bounds\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n            \n            # Adapt inertia weight based on convergence\n            self.w = 0.9 - 0.5 * (evaluations / self.budget)  # Adjust inertia weight dynamically\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98  # Dynamic mutation probability\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)  # Change 2: Further reduced mutation scale\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)  # Change 3: Adjusted mutation vector\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduced self-adaptive inertia weight adjustment to improve convergence dynamics.", "configspace": "", "generation": 22, "fitness": 0.30246510615967714, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "f382c9e2-6ca1-4a40-a19a-da231d23167b", "metadata": {"aucs": [0.7900767039846494, 0.7796354000576309, 0.8050875218038644, 0.7983990450265082, 0.7941923611922747, 0.8061351046852226, 0.7983630368331359, 0.7965540658947841, 0.8085608211931479, 0.599675070544783, 0.589738729572474, 0.6060463668629359, 0.5394495028738553, 0.562644779250608, 0.5773179493030646, 0.5532088757463356, 0.5703066825295717, 0.5289423189017384, 0.12301449652028151, 0.16109686768011855, 0.08572668821181562, 0.11537622912650791, 0.369218159835759, 0.17657572957967127, 0.15024618952487867, 0.15268203144317727, 0.10431060572413042, 0.12615825523842128, 0.11788173852194506, 0.10644277784729417, 0.10212586636722698, 0.10774982994034288, 0.10790802334772853, 0.09882819133165854, 0.15541480470957358, 0.13379597340210492, 0.9180203079425844, 0.8928852353725631, 0.9021474541187657, 0.9171980013758464, 0.9069931362396353, 0.9120583790664614, 0.9270998406481009, 0.907117128588486, 0.9120616188778037, 0.623101252853747, 0.6242314100609638, 0.5871036239733706, 0.5988206729520491, 0.56493549601377, 0.6500907851498865, 0.5955624110628401, 0.6205542092366017, 0.6380111666385861, 0.22669600740864482, 0.16995906316674247, 0.13982811244020144, 0.36693214914057926, 0.2742160057930224, 0.3735972509542722, 0.22953323393920877, 0.17786727462732566, 0.17806120242271883, 0.21421149599694522, 0.13413296276528996, 0.22605186679735867, 0.2392454424017143, 0.1967813807261799, 0.16630855601230943, 0.24410829614265706, 0.20032450587104333, 0.19772114971254662, 0.16757073763952324, 0.21752738081093825, 0.18972605699739753, 0.22160192970059367, 0.23812751648854724, 0.13217097665168198, 0.23872783640301298, 0.2311128689492823, 0.2198084527013413, 0.10075837290801137, 0.07964352066802582, 0.01002182468447499, 0.04928366155020103, 0.012499214742059839, 9.999999999998899e-05, 0.004142081802257058, 0.009411821190565162, 0.04286931841047514, 0.1316635470543328, 0.06906564746858368, 0.12663498846940913, 0.0643155405755832, 0.047819511032548556, 0.039850922404339184, 0.07981544536632756, 0.09487521252838393, 0.15567260251491877, 0.15361588051375763, 0.1550971351303313, 0.182167305559363, 0.08822540957815161, 0.18834857036982489, 0.10023990158730867, 0.086614449929874, 0.11442443322171147, 0.06611042490157049, 0.089836209499908, 0.4007873780634217, 0.3818236669096433, 0.1014014058508943, 0.20515087958941325, 0.11986130734422129, 0.09548742083148687, 0.13094716457901956, 0.08236137704757163, 0.5677428215436073, 0.5027490599585416, 0.5018487554242358, 0.5260191776948813, 0.5269803522954288, 0.49320599683452004, 0.5386397669106547, 0.5468470069633377, 0.5305707152291599, 0.09213857362891942, 0.06207357077676556, 0.06251264497774978, 0.13443038687011755, 0.11468260867715341, 0.09330651472636764, 0.12007803945847006, 0.14144521110020447, 0.11270632764917443, 0.21668539399426823, 0.2303114992171581, 0.19461322522474933, 0.19919138461436947, 0.25512557305275063, 0.4609614764000044, 0.26739413255297606, 0.37217128411252287, 0.4288710887577736, 0.19347917040359708, 0.3875533462108598, 0.2982054964155053, 0.421691417725766, 0.4697974873082883, 0.4537404344782092, 0.24186903448044716, 0.43869809212795385, 0.2812347022198207, 0.2341185329058959, 0.30652989137855435, 0.19487750098411405, 0.2952800860366126, 0.20188033792283444, 0.3153311517646764, 0.23186068341208865, 0.3349185270314007, 0.2579391918547722, 0.22745204699813182, 0.2002087209328327, 0.2395754289927281, 0.23920801584188522, 0.23120679437301372, 0.23934931412795823, 0.2385538834605525, 0.279805967986964, 0.2373623634104295, 0.19532496014487644, 0.18839967237664623, 0.20848381236250746, 0.24998803833772976, 0.20092605674829633, 0.19181439146316692, 0.20601745888132794, 0.2019735474061456, 0.19588105399096223, 0.12634375316538293, 0.17700783263480824, 0.13381328036840678, 0.8751485875284077, 0.16847357326788204, 0.19959037156662396, 0.16174659814256664, 0.8672878291889656, 0.8946612647496607, 0.7360590926126713, 0.15647440320635286, 0.7055205655761829, 0.2082273483507222, 0.1687152923214289, 0.15335365229559372, 0.16610424347967478, 0.10459611716631134, 0.7163903790373731, 0.20770212785847975, 0.19528460965731742, 0.18646001984525262, 0.19676701829964172, 0.21300416597020244, 0.19923709737694895, 0.2082581478469897, 0.2022968217978448, 0.1763369114240244, 0.07773785267947297, 0.10124790189438249, 0.08924890314157019, 0.10960035888533204, 0.0983336588345044, 0.09820349220260483, 0.07804620241823645, 0.08671754957054179, 0.0948545136641673]}, "mutation_prompt": null}
{"id": "b4bd8841-494b-4993-9b86-467366ab2ad9", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.5  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n\n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.4 + (0.5 * np.random.rand()) \n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced PSO with dynamic neighborhood topology and stochastic inertia adaptation for robust optimization performance.", "configspace": "", "generation": 23, "fitness": 0.3337739854828868, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "f382c9e2-6ca1-4a40-a19a-da231d23167b", "metadata": {"aucs": [0.8759956643056533, 0.8615278000113429, 0.8902260062707293, 0.8467130778054333, 0.8275179549134605, 0.8639994066796403, 0.856954332592753, 0.8500226308354846, 0.8749873039696842, 0.6823908879526328, 0.7256249081877861, 0.6807481204062066, 0.6328127442439373, 0.6413640789939506, 0.638158253698071, 0.6338830070456536, 0.6578286250918306, 0.6937698206199878, 0.1130017751400414, 0.15556945678862844, 0.07448185688036824, 0.09590895448815229, 0.11488592497528693, 0.11410104330660065, 0.08569273332586913, 0.15963720945995608, 0.14009650659209294, 0.0918402984187765, 0.12293070077712032, 0.11303412163619464, 0.09956546486350015, 0.07292013021984478, 0.07823116252395235, 0.10890787836752336, 0.10975515926727963, 0.09435185300013249, 0.9253363197560667, 0.9175592115486876, 0.8861516100668594, 0.9158142489580012, 0.8989179585068217, 0.9156411440204351, 0.9121652209441043, 0.8879532262565737, 0.8807648369115908, 0.7479250996922939, 0.7616365908440307, 0.6663826766685581, 0.7602004720420689, 0.6836499884945341, 0.7208481576419405, 0.7033428671899755, 0.7222319954790337, 0.7142090125464347, 0.22189080890934243, 0.14039583414046175, 0.1401491311874019, 0.2771152924818955, 0.374912014552751, 0.6705132992530163, 0.1507826039091753, 0.17754602962360022, 0.17788656337223396, 0.2704102206699439, 0.1307654084095511, 0.25160695897858554, 0.2730734920215706, 0.2761441474550852, 0.2635647326924919, 0.4424841646743216, 0.4057468864641116, 0.26285886359056265, 0.24850414626334627, 0.24513093064655989, 0.13348335602073913, 0.28674691606633773, 0.26972845397391343, 0.32710472503492793, 0.29061755459020444, 0.2820549693705535, 0.13329139763153341, 0.03200088124784106, 0.08762588121574466, 0.15051193615959513, 0.05545071133134538, 0.04917643964597063, 9.999999999998899e-05, 0.06223697586199284, 0.07953816926757284, 0.007551536383186064, 0.09285575645468747, 0.07936109144523418, 0.17680055844200393, 0.05423152764628636, 0.05344785167952182, 0.04781272199319797, 0.15857325803630906, 0.11445089634675787, 0.06296672019263683, 0.2106069947818633, 0.09392073594993566, 0.15265534296803596, 0.16477513203041072, 0.12911212126831084, 0.36799122179207366, 0.10031402643318776, 0.11952941306719, 0.13749352205902265, 0.10796747261011119, 0.10587192638367449, 0.31894857667629384, 0.12653633509799378, 0.24859785809839563, 0.08621108587175219, 0.17117874180167636, 0.18213467273826645, 0.08338172298312951, 0.5253676478658449, 0.5525414805368054, 0.5246897077280792, 0.612379014219919, 0.5520151978672584, 0.5568701066168831, 0.5886507674419836, 0.5742397129640131, 0.5851557715717326, 0.06308292232047019, 0.07093679257314123, 0.08439104593913671, 0.07743241898697784, 0.08784913918239401, 0.09692865160518427, 0.10967555310217281, 0.09197718790023124, 0.0914416181356753, 0.21924921774616213, 0.7233637148683156, 0.2029708664330938, 0.2455694239455133, 0.46915216739976484, 0.24520936118833492, 0.6443262601297168, 0.23089291609268814, 0.644233981059795, 0.20302229627092094, 0.44168699140983936, 0.39322171812209894, 0.5637723543965136, 0.3563998723279085, 0.4601260632703654, 0.2574007847774846, 0.41609231816183134, 0.26621809228008964, 0.21004243544731804, 0.3415417759285102, 0.21845360547452541, 0.2683567478672617, 0.223371798538461, 0.26961679466088806, 0.20736625147559185, 0.23754143890682766, 0.21116121017170353, 0.25055985288889737, 0.23533001355876115, 0.21719678971826784, 0.23432536601173248, 0.18925908923899193, 0.22499779714076062, 0.26778357306692846, 0.2342559143099271, 0.26231367682833007, 0.18074129725221588, 0.1765360055349371, 0.17987882832588442, 0.16982586071014305, 0.2076225534016356, 0.18767205340433402, 0.1775375584903679, 0.21022512128342763, 0.17481683196295872, 0.12643636533233804, 0.17660512029560427, 0.14646790365942763, 0.9366068083607805, 0.2007726708473183, 0.9362261542603711, 0.14251380085925225, 0.9212270842571977, 0.9301063998827334, 0.8727048026673248, 0.15643427557911438, 0.9017291496427251, 0.20905066442818643, 0.167693585968817, 0.15460752436447223, 0.7995020374649044, 0.10483098574609417, 0.8317912453423768, 0.2060586873105701, 0.20797608657533695, 0.2481827720022417, 0.22602515168847348, 0.19537194111913236, 0.20510476327269922, 0.21273216038033083, 0.20233494221730475, 0.28917409528262594, 0.09021204571016606, 0.09572041082657201, 0.08397953865935948, 0.0962515573565288, 0.10995941189728087, 0.10536764176703928, 0.11198191949660652, 0.09879012548656041, 0.10119144708874883]}, "mutation_prompt": null}
{"id": "45f978cb-734f-415a-8f25-147452468097", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.5  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n\n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.4 + (0.5 * np.random.rand())\n\n            # Dynamic social parameter\n            self.c2 = 1.5 + 0.5 * np.random.rand()  # Updated line\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduced an additional dynamic adjustment to the social parameter to enhance convergence adaptability.", "configspace": "", "generation": 24, "fitness": 0.3156915210668334, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "b4bd8841-494b-4993-9b86-467366ab2ad9", "metadata": {"aucs": [0.8556761613234705, 0.8372055359536396, 0.8304077507206304, 0.8358701809889215, 0.8376977893888831, 0.8370153239834547, 0.80328403805621, 0.8532675289269982, 0.8410052317129385, 0.6817624955795938, 0.6607556755060964, 0.6458655678359116, 0.6339528682763204, 0.6793695320335467, 0.5981334291302811, 0.6630625366514677, 0.611759334200252, 0.6305349124935378, 0.08077814576802578, 0.18645287225031892, 0.09123275860669888, 0.0858653777704621, 0.09892221785845556, 0.18403795064502115, 0.09652768930837974, 0.14068821741987925, 0.09356468889156366, 0.11590484505913023, 0.09395777843092312, 0.1068472064567737, 0.09494392822487263, 0.11392232260118795, 0.08625991116911358, 0.08127561192007071, 0.1037325988885961, 0.08193283376978311, 0.9176388211672181, 0.9138853669776625, 0.8970224140844427, 0.9154760339712816, 0.8986052090024428, 0.9201690013835414, 0.9178454055307473, 0.8914916839845252, 0.9184431118793862, 0.6855879464582338, 0.6518291770660907, 0.6314523810364927, 0.6992467378177769, 0.6581400744905113, 0.6728436972766825, 0.7007348354969443, 0.6702975284613271, 0.6778818573727243, 0.3908678345980503, 0.1402106470447939, 0.13983872759842542, 0.27998226835807594, 0.19110651498625453, 0.27781878411723904, 0.17692984351880736, 0.17732091151666263, 0.23098178166432504, 0.18537450395102328, 0.3168202348551138, 0.2569275763556136, 0.21278537213064874, 0.3300271475774279, 0.26206372190040483, 0.35675051363899357, 0.327457329658402, 0.25521101710990346, 0.26035285954445175, 0.24367630668015883, 0.12389112340542174, 0.2689088631644653, 0.2705659263504613, 0.2578349386904045, 0.2672690968630257, 0.2469796952570359, 0.27273941168528804, 0.10667115404304095, 0.010275443870262801, 0.06020896043508217, 0.005711636353898597, 0.009781890570965901, 0.06325176056225357, 0.08142452395966215, 0.006892643175460789, 0.012375141465034933, 0.1450542032754396, 0.13358169346390425, 0.08265785074209997, 0.07706224118547067, 0.009548544984711804, 0.04763491601967229, 0.24689028878993136, 0.0852453709229769, 0.09041806046421375, 0.2025306705172214, 0.1465586282222272, 0.17048172589245658, 0.09793936717997809, 0.12213505430746796, 0.14083636113849352, 0.12120376529040444, 0.23692326737146963, 0.23919454283301544, 0.16197376772561334, 0.08829350729668983, 0.07760415363194662, 0.2147407465226847, 0.1371759347129755, 0.09198307313581644, 0.2231288116658391, 0.08258288130027391, 0.10470977166171702, 0.5791756854452281, 0.5514104959979976, 0.5228483767409425, 0.5584099180051695, 0.5434039090089109, 0.5752054569310265, 0.5675040725953724, 0.5547012958703257, 0.5808476406955907, 0.05658789038046996, 0.06677394187918939, 0.08313932800146573, 0.08074276478601916, 0.0796396919152641, 0.08843875032086745, 0.15564386192867818, 0.09545483052282255, 0.09222061682980254, 0.22900139191979607, 0.4017724551259988, 0.2306946967011816, 0.3287839001097279, 0.33265216881700677, 0.19954108364145973, 0.22897766313128753, 0.22628468445021632, 0.2666051302951441, 0.21910850507533486, 0.2263020236356964, 0.2367801556057446, 0.36660747640653013, 0.2756553868107132, 0.4210036884555086, 0.4323240799555259, 0.46680977533445367, 0.2616280347676103, 0.21749883404842607, 0.2618649430398281, 0.20954436715586922, 0.2400345443155908, 0.23592707713273464, 0.2654440453024317, 0.2617334944885934, 0.35914668899218605, 0.2369280706166449, 0.23235340727468368, 0.2633214706195822, 0.16670664060372942, 0.23757209131615153, 0.19080474725955354, 0.2732153450728023, 0.283777590142813, 0.18383736858251865, 0.22314630991092177, 0.17411373794726748, 0.19517898069264084, 0.17689857875901294, 0.20322270954068422, 0.19379500848945186, 0.19871985402491865, 0.18408650672857152, 0.22514165705527167, 0.18882724684390673, 0.1267234124862312, 0.17682242466990006, 0.1349768875541607, 0.9291683147730383, 0.1680810810129615, 0.20028277903994807, 0.1421250929782929, 0.9052306882078444, 0.9229936447289412, 0.8643906366995205, 0.15701580079976252, 0.7787664447290236, 0.2061782609488052, 0.16808401262880757, 0.15341821905152175, 0.1046284509627845, 0.8656088171068939, 0.8149403419388194, 0.23331797249184572, 0.22741061476056834, 0.23632835508755, 0.22632027468296823, 0.2218188059370274, 0.20698839302694816, 0.24319622098733662, 0.23751627775188566, 0.21916539489357445, 0.1038956215620761, 0.10664269304895202, 0.09808630340365487, 0.10974628913177709, 0.07909115380099174, 0.0926702465431839, 0.14348934669408808, 0.06979770054177481, 0.08148999355099662]}, "mutation_prompt": null}
{"id": "29c358f9-f228-496b-8dea-ac61e12331ec", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.5  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n\n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.4 + (0.5 * np.random.rand()) \n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - np.mean(pop, axis=0)))  # Modified to use mean\n            velocities = np.clip(velocities, -0.5, 0.5)\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Refined the velocity update to include a more diverse neighborhood influence, fostering exploration.", "configspace": "", "generation": 25, "fitness": 0.296834666171186, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "b4bd8841-494b-4993-9b86-467366ab2ad9", "metadata": {"aucs": [0.7396310165754859, 0.7254018011474579, 0.7204403565226947, 0.7713973295264935, 0.7809333450576741, 0.7220449548293058, 0.7549090673301225, 0.7318973812647559, 0.7417119121881575, 0.5220043837156829, 0.039812810144548294, 0.3610516768849369, 0.3329897509977132, 0.3483088826306239, 0.4193948539865713, 0.41026321739330085, 0.40968261626659397, 0.04793421584583479, 0.14255690388727726, 0.11109292396534531, 0.17557457175882607, 0.15211753843097997, 0.11042480279151279, 0.1436126718212517, 0.0787467645576777, 0.14052364025703068, 0.14846545515659437, 0.13621401583417103, 0.10446579687794277, 0.11453668322568555, 0.1026632535357831, 0.059842845267411904, 0.101326103913853, 0.06367578751346215, 0.13593603802233756, 0.09685538050635423, 0.961238893515165, 0.9724078398113134, 0.9126161286850982, 0.9552544470644554, 0.9311041802469978, 0.953507084168294, 0.935849779151112, 0.9254842366680317, 0.9337802861225631, 0.5912695656123865, 0.6134933706891581, 0.5366869448914678, 0.5303437037103438, 0.14970928857617893, 0.1491778543782888, 0.5781281381628152, 0.6093260582080889, 0.5737279559753097, 0.7919595378625411, 0.16679448387933649, 0.20930122075902868, 0.3545862330383962, 0.26803774361134824, 0.1894852091929735, 0.8345446595450834, 0.23597605352990492, 0.7638730521886218, 0.27526307409370665, 0.2883660430452645, 0.31044383818136856, 0.24816326075649353, 0.29884399598167777, 0.30669262828319555, 0.2305425049051013, 0.23489007510726578, 0.25567040534335816, 0.23705112586996535, 0.2507142529312574, 0.22204287051463323, 0.30855828491032034, 0.2912403302833384, 0.31604083605036026, 0.29569258101717444, 0.26396538499176336, 0.2690757392663291, 0.022136812627405522, 0.022311493280811057, 0.007624459051616017, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007021261220070407, 0.03226445644237064, 0.018102820052912638, 0.1099301338282006, 0.11483637411837011, 0.10760760152635163, 0.1368705902816273, 0.04391736553316328, 0.0675513530613403, 0.08364416764827731, 0.1337130024624874, 0.04144749495978517, 0.04733241711704994, 0.0932358178343149, 0.060351823980987485, 0.03633359506501421, 0.06626412163132078, 0.13405466152897627, 0.06761306098346265, 0.0788461629299283, 0.06993061314862192, 0.03877439288066542, 0.13539338942515056, 0.24908514523592995, 0.1848971433011849, 0.2107399088821671, 0.14420657557510808, 0.2173916547981788, 0.07751666603941032, 0.14546664490251404, 0.16099352771409792, 0.4968946524864315, 0.508603998711055, 0.5089058737962892, 0.5204235785632199, 0.5640140315253753, 0.5701226853075556, 0.5462216494024833, 0.5187200471309275, 0.5258997750155423, 0.09595847751052877, 0.15718324792139704, 0.07799275747043033, 0.09354856991659477, 0.09044780253779627, 0.08599576220446892, 0.10390739744682975, 0.10213207921767475, 0.11548789042087138, 0.20294778665919877, 0.48686240346782417, 0.24728131347682847, 0.4512588478941527, 0.5348392424847228, 0.3981479903616706, 0.2632464247025843, 0.47395251252166315, 0.28000544790028314, 0.4342948159055542, 0.3977228696391325, 0.394670350635568, 0.24641170553109382, 0.2083765015830994, 0.3904066325171076, 0.2517229454211114, 0.44899944136568004, 0.29510933572020825, 0.21637769231878567, 0.320956915327655, 0.1378764373612794, 0.21328804942804613, 0.2366856361998253, 0.2075474293197469, 0.3160867286793214, 0.18611220723146948, 0.24051860183268414, 0.20248789697186265, 0.2122508082655138, 0.18309854501690803, 0.22915537644527062, 0.21165097506337294, 0.2588469829609168, 0.2469476956900326, 0.1865018236567556, 0.21130759409549715, 0.22070621636064724, 0.16623370822665728, 0.1783568745180537, 0.22174673727912264, 0.23886145343876464, 0.19175996362284464, 0.242570196247599, 0.2184563110536315, 0.19029983487453506, 0.12571289945998032, 0.17508794783600456, 0.15197748373661957, 0.14780434387604913, 0.19813832718414848, 0.8718291736973043, 0.14043120530736686, 0.1678692847270331, 0.16661921117169165, 0.7696180401063187, 0.20890618612929268, 0.15287212263125294, 0.8338882282288618, 0.12732423767278034, 0.14771960364196335, 0.8269415622312373, 0.8274648358312823, 0.7606482333785017, 0.19253832378686886, 0.23002349983339798, 0.2026001307647891, 0.19814346309416686, 0.30443840458436344, 0.24576443705645545, 0.2124430394423087, 0.27300503084765726, 0.28502113857954015, 0.10123742320835649, 0.09252914914105692, 0.09917307719291335, 0.11186060694017941, 0.07884535469734988, 0.07227207538061398, 0.07629053576167921, 0.07512958422137106, 0.09806465135652742]}, "mutation_prompt": null}
{"id": "30847a4b-821f-4489-8f95-9b9231467bcc", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.5  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n\n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            # Adaptive inertia weight\n            self.w = 0.4 + (0.6 * (1 - evaluations / self.budget))  # Modified formula\n\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i]:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved inertia weight adaptation formula to enhance exploration and exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.30248914433005086, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "b4bd8841-494b-4993-9b86-467366ab2ad9", "metadata": {"aucs": [0.6783652731183353, 0.6979399934560142, 0.6990083238794067, 0.661931705199796, 0.6911966157820655, 0.6820946436171571, 0.6983933144651382, 0.67478107230935, 0.6747923921791144, 0.42189841159923647, 0.3868882909434146, 0.41784415098161054, 0.371211895692093, 0.3817997333100088, 0.3917288201834974, 0.39483979883469, 0.39750497777151694, 0.3703232308484907, 0.09713112419565861, 0.11396794338913618, 0.1403804214862031, 0.11779037573251694, 0.13806781091840092, 0.1104894826009204, 0.09195785192241768, 0.1542177026832916, 0.129850503975541, 0.10840588019707287, 0.12064217426251123, 0.1215870853688873, 0.09305280519918635, 0.11108808060458308, 0.10177744822023471, 0.09402197372938559, 0.08637952006985128, 0.10600230077728323, 0.9295066282144736, 0.919602465347424, 0.9315224544309578, 0.9256470117586258, 0.9128252139876205, 0.9017460172685532, 0.9270422134064287, 0.9043002080752597, 0.9017327994494952, 0.5579524727491942, 0.5597219729353734, 0.5600256688602931, 0.535124468568241, 0.533165181457691, 0.5613282194260398, 0.5498695921477359, 0.5570618712495711, 0.5600394757347087, 0.3662567037710639, 0.7109624011242998, 0.13977974797211623, 0.27434662424167866, 0.3295580347437749, 0.6440217101806528, 0.2303914801544361, 0.388470028790892, 0.789868298452751, 0.2411091914116279, 0.22059529947896162, 0.23724528667556388, 0.22608724058015672, 0.2270047947462167, 0.28213836360654965, 0.23059174760640277, 0.2249689365202283, 0.12946406486508855, 0.13026661615755786, 0.21084670986882725, 0.12212378115031874, 0.24134179883789308, 0.2299356122049957, 0.1295750121744823, 0.4031352529296969, 0.23310777893663115, 0.25152548607034175, 0.0597316649431987, 0.09774479284108206, 0.07621352161554218, 0.03763676441479369, 0.05408935518718849, 0.0018732105451374492, 0.04505407891501634, 0.05339547659834165, 0.08071024506685753, 0.19423156447620726, 0.047573729066706205, 0.13013812003925374, 0.10493081654043257, 0.03196094800012217, 0.03794502212564199, 0.0710149327256977, 0.08817799390341896, 0.10216837338034579, 0.08810939864780087, 0.047101372371891936, 0.13429430222602168, 0.10897378255037382, 0.06088469362977844, 0.19994875174151983, 0.05240131701016293, 0.07427456650787967, 0.05455044745098658, 0.11327591286792249, 0.18737909714838796, 0.14033743510156416, 0.238282081246181, 0.1637499482231335, 0.11598339026215221, 0.07432477336824228, 0.18493148844848506, 0.07792094797890825, 0.5159622377139768, 0.4991411504900909, 0.48767472854830585, 0.5295582843977937, 0.48261870161816933, 0.5074845465645841, 0.4978508028291062, 0.5377097029755417, 0.4943879733641283, 0.09086102812033203, 0.06323498102752312, 0.10720860194816328, 0.12452586547630495, 0.10922543062947265, 0.14372216491088408, 0.14558717532051446, 0.09644672045471558, 0.12810576885205482, 0.4954558206172913, 0.23588599365804397, 0.20744781361852538, 0.4651182464058504, 0.20864712808745, 0.293204912696719, 0.35369279445667257, 0.46240560081581483, 0.3395816601644026, 0.17302308028317714, 0.3634113010332988, 0.41861425007447817, 0.41000505865040426, 0.36073474170909436, 0.3409595312461897, 0.24943805150045462, 0.43022217941916574, 0.24066088836835742, 0.19196189487979365, 0.3436629268953896, 0.2253266907021113, 0.2932455807652463, 0.2094731040881156, 0.16708269502759343, 0.2210379512067614, 0.28998048530515497, 0.21016100079765043, 0.20649623415309482, 0.19707177759216354, 0.2053325639504866, 0.2998538037199241, 0.23285296433477654, 0.265058007959305, 0.22981050292060223, 0.2923755735625537, 0.24575579602044395, 0.19366349728564258, 0.2208158533641028, 0.20420474726258442, 0.1935656987687071, 0.1940179171542008, 0.19322065840221392, 0.2034097336397218, 0.2189622438344323, 0.18426368252497816, 0.7911185164038206, 0.176784806071544, 0.13308227331194433, 0.8232342719628898, 0.16815948466299957, 0.8351461153810276, 0.14206825954672297, 0.8313037407250226, 0.8123255165535052, 0.7673299317542169, 0.21205479148084783, 0.7754391925833698, 0.20571132876155518, 0.16777769747678817, 0.15368053437715457, 0.10462535267019157, 0.7517104724548093, 0.6671812805891353, 0.2579257150643971, 0.20995655072498198, 0.1943025812654332, 0.19454402031510332, 0.25107690777268865, 0.22645249220476882, 0.21660197630070177, 0.2054952116303066, 0.23403226040607616, 0.0670850001713863, 0.09995667196430602, 0.09529914225057234, 0.09979650924062367, 0.10420800833730615, 0.08586279571090505, 0.12906132594881004, 0.09716715045582913, 0.07401939960315651]}, "mutation_prompt": null}
{"id": "88c54d46-834f-4f6a-8d23-dd82317ea7aa", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.5  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved PSO with adaptive swarm diversity control and enhanced mutation strategy for better exploration and exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.3346965669373902, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "b4bd8841-494b-4993-9b86-467366ab2ad9", "metadata": {"aucs": [0.8615774383608783, 0.8615264111865188, 0.8516638990001208, 0.8473537378094795, 0.8385301228451734, 0.8322639997137122, 0.8619454848253241, 0.8500226308354846, 0.8485145362780557, 0.6764869457673889, 0.7256249081877861, 0.6563103067671207, 0.673693806119908, 0.6586931290321156, 0.6666173192789812, 0.7072544398622466, 0.6842147827009459, 0.6573555910923723, 0.12228573192484127, 0.15556945678862844, 0.06914866349920923, 0.07620123425709402, 0.11488592497528693, 0.18243379706372143, 0.08712091256353383, 0.15963720980060048, 0.1030285226635197, 0.09184028382857146, 0.12293070077712032, 0.10078307059538072, 0.09956546486350015, 0.07129340008260532, 0.10977271061151861, 0.10837343286211687, 0.10975515926727963, 0.10920781708970351, 0.9204225178691664, 0.9175592115486876, 0.8993931432621279, 0.9073788804387288, 0.8989179585068217, 0.8922887715550172, 0.8958974573840143, 0.8879532262565737, 0.8975210552558772, 0.7319670533222522, 0.7616365908440307, 0.6662666537162524, 0.72903194930438, 0.6836499884945341, 0.7353530180825643, 0.7068950668202361, 0.7222319954790337, 0.7050210926520949, 0.166947974739167, 0.14039583414046175, 0.16950212594935032, 0.8627778824974702, 0.374912014552751, 0.37789552697386697, 0.15055875988002954, 0.17754602962360022, 0.17757270830368377, 0.27911947977738905, 0.13100792427916608, 0.26887274712044307, 0.25289354038856604, 0.2822033213349141, 0.2615516726744508, 0.3605412631669017, 0.40338072564583005, 0.263757884940128, 0.2462091455716675, 0.24513093064655989, 0.13246430845517243, 0.27484179343537385, 0.26972845397391343, 0.288850791694221, 0.29061755459020444, 0.2820549693705535, 0.28104787559177014, 0.07026965286790654, 0.08089490228598284, 0.1680847669824318, 0.05434484610533963, 0.04977562033530214, 0.04531266135694334, 0.024546477874680006, 0.07953816926757284, 0.0709243608122282, 0.12035094319594375, 0.08432950545157347, 0.20190017239659264, 0.06967589880916913, 0.05344785167952182, 0.0409434194966225, 0.11608567293602778, 0.11445089634675787, 0.061947851542156096, 0.2558834964611143, 0.09392073594993566, 0.14621224231325292, 0.24677081311269156, 0.12910781942388816, 0.23341430353410486, 0.09854098120182464, 0.11952941306719, 0.15011848310899512, 0.1530760943792251, 0.10587192638367449, 0.31894857667629384, 0.12653633509799378, 0.24859785809839563, 0.16633199444930158, 0.11139385354240172, 0.18213467273826645, 0.08334969758516053, 0.570307875517436, 0.561211849766243, 0.5508509910786514, 0.5604930972456883, 0.5484453984349783, 0.5856935879705575, 0.6109984262141325, 0.5742397129640131, 0.55431149429736, 0.07584305042447614, 0.07093679257314123, 0.07454241132693806, 0.07725142635606497, 0.08784914405886224, 0.09664235653639519, 0.10967555310217281, 0.09184688619491721, 0.0914416181356753, 0.2152352346989238, 0.695622643008369, 0.23407664735562006, 0.3038568378296075, 0.4028144497996702, 0.41166127582202217, 0.26596102248391773, 0.23088922435457315, 0.42961669162990157, 0.17827054738176662, 0.5113125523483337, 0.37594131217734783, 0.38058212251338996, 0.3563998723279085, 0.43980316284824517, 0.25224501301747215, 0.41609231816183134, 0.25721313639590304, 0.22824935718999617, 0.37346101248544605, 0.21845360547452541, 0.30019950624158775, 0.223371798538461, 0.3143038451850825, 0.22588652928504938, 0.23754143890682766, 0.23277299560823117, 0.25055985288889737, 0.23533001355876115, 0.21719678971826784, 0.23432536601173248, 0.18925908923899193, 0.2485025837063377, 0.26778357306692846, 0.2342559143099271, 0.2631031135410805, 0.18042254194515717, 0.1765360055349371, 0.17715194493241537, 0.16983272138341599, 0.2076225534016356, 0.18773404271806016, 0.19204563825662757, 0.21022512128342763, 0.17481552789780996, 0.12633595528034403, 0.17660512030463038, 0.14607859720432248, 0.9366068083607805, 0.2007726708473183, 0.9378370215067777, 0.1425323265374394, 0.9212270842571977, 0.9274483696661386, 0.8426852112648511, 0.15643427557911438, 0.8536367112061586, 0.20900845219447117, 0.167693585968817, 0.1541478076899746, 0.8016671951052805, 0.10483098342942654, 0.8786286426482742, 0.2674180635768021, 0.20797608657533695, 0.2848629606913462, 0.22043446509969467, 0.19537194111913236, 0.21856104536120224, 0.21273216038033083, 0.20233494221730475, 0.2832605841276089, 0.09021204571016606, 0.09572041082657201, 0.08397953865935948, 0.0971267994180014, 0.10995941189728087, 0.09767523906830777, 0.11198191949660652, 0.09879012548656041, 0.10895086089692341]}, "mutation_prompt": null}
{"id": "6c658671-f6db-4d5d-ae8f-5c346c68c2f1", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.5  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.5 + (0.4 * np.random.rand())  # Adjusted inertia weight update\n            \n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.6, 0.6)  # Changed velocity clipping range\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            self.mutation_prob *= 0.98\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:\n                        mutation_vector = np.random.normal(0, self.mutation_scale * 1.2, self.dim)  # Enhanced mutation scale\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced adaptive mutation and velocity update for improved convergence and exploration.", "configspace": "", "generation": 28, "fitness": 0.3303137051958607, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "88c54d46-834f-4f6a-8d23-dd82317ea7aa", "metadata": {"aucs": [0.8515599132511957, 0.838544098812692, 0.8106743802968397, 0.8374497074276036, 0.8116957779217129, 0.793452655831182, 0.8162271749158171, 0.8225843011240527, 0.8444766117564435, 0.6069164850346804, 0.6258161069482705, 0.5920759065260194, 0.5618294449922027, 0.5707477853302708, 0.6559805479809806, 0.6345530523902329, 0.6272854029128863, 0.5455383945135288, 0.10858485780739335, 0.10041447758778455, 0.12777401309769665, 0.11446674761011688, 0.141106282245275, 0.13718781029075422, 0.11087394099866976, 0.14111325698996458, 0.10349694068093662, 0.09379726743999528, 0.09352575908251615, 0.10279387105585247, 0.13997159542350823, 0.10365470966359003, 0.09857200820676937, 0.11257075775257341, 0.10836590014392256, 0.10268179091281038, 0.9249631182783642, 0.9275702569954188, 0.9223246528552895, 0.9340101649080312, 0.9210382271460221, 0.9129132208817597, 0.9267370522903469, 0.9130570780857955, 0.9263016422695831, 0.7153141474511322, 0.6801811607711654, 0.6202610901497845, 0.6227338134937788, 0.6882041423646735, 0.6922435370890399, 0.6451262880894554, 0.6297503179274337, 0.6599327025829385, 0.38367209345035835, 0.11724812804625939, 0.16499494381791813, 0.897462816284189, 0.8225635561570572, 0.8208882368083409, 0.6202971083358739, 0.23294460429956731, 0.23046892914943273, 0.25471172115317353, 0.13044915055441708, 0.23238999797637327, 0.2709462229524222, 0.3133615726961585, 0.3040646503994626, 0.3006732403275074, 0.27037973195693876, 0.230514685630406, 0.26262325087041805, 0.24621105728889492, 0.12555068598939745, 0.2586078105331969, 0.2787370158626319, 0.1313713901219138, 0.30867578856729727, 0.26533586569829015, 0.13249666478718558, 0.007792883130661732, 0.15265627921838765, 0.1396503455928314, 0.0471066375783572, 0.01521578597811546, 9.999999999998899e-05, 0.08509323952613301, 0.0067453425852614934, 0.008892198731112466, 0.13592735631251995, 0.08162536929724862, 0.1312689725460947, 0.05915015257770795, 0.020868944968001735, 0.06165727200374471, 0.13017863367403626, 0.1361868427232883, 0.08734434139576575, 0.420898155004524, 0.08532326496879084, 0.09933738775098644, 0.3631170949226976, 0.16722229630993246, 0.16802412438407477, 0.08957930727886976, 0.18076441522532427, 0.08037102526699091, 0.1047052466064371, 0.1680209006866047, 0.07541163760743153, 0.07441263499299311, 0.3261495271619783, 0.08732863495124388, 0.16677604697644188, 0.21404572999718408, 0.14887574285175142, 0.5467276012818573, 0.5481605145528896, 0.5540649017359658, 0.5398019367425787, 0.5235518461677137, 0.5086037884826922, 0.570693488151476, 0.5398743430657118, 0.518136494165344, 0.1241066334482317, 0.11768955055910368, 0.06061888298872509, 0.1151119521421119, 0.1542157242460691, 0.10697144440975459, 0.1278471673857886, 0.08529490309090781, 0.09087676201105388, 0.14214842939484806, 0.5423937313371645, 0.5259590192005452, 0.25512373133314314, 0.3541971782838861, 0.2174532769892773, 0.4425929221573076, 0.21732857345281653, 0.5173216825592835, 0.22259672393049845, 0.2785076601531835, 0.42568456479548344, 0.35786017160476824, 0.46549895099925587, 0.38492962502814376, 0.2488291045825205, 0.33726841349927417, 0.26608195389610845, 0.25317043671517536, 0.33210462891237924, 0.2172201949404846, 0.4066375207791151, 0.21895386553546192, 0.2878679386186187, 0.2566699621343572, 0.3596318700093535, 0.21952966069328728, 0.2386141862964667, 0.26604399617381136, 0.2357048635827781, 0.24357865739173978, 0.2727973463238532, 0.23862398199814594, 0.2535732269985975, 0.20832389969911824, 0.22241152318843405, 0.1740532918369343, 0.20209140185097274, 0.19731382059277336, 0.21136438599227714, 0.2081490327905008, 0.18173417800887293, 0.19459503012117052, 0.21002461753078094, 0.1972350133094558, 0.12630370975370375, 0.17679832290683295, 0.18623916701629561, 0.9245436475726722, 0.20065766531171136, 0.20014063551148198, 0.1426841556427325, 0.9029032023930068, 0.9157040544644203, 0.8127900829547572, 0.21255952429935765, 0.8331989380232405, 0.20859992976308173, 0.16780994709861918, 0.15380627603138675, 0.7763670138894303, 0.10487022724299655, 0.7951611887492597, 0.20839124139717857, 0.28144435194281214, 0.2554342185374986, 0.20927623675914697, 0.20282240669035778, 0.283828763788625, 0.20055500069339116, 0.22416753913170218, 0.223511626233449, 0.07900516632111121, 0.11001119282799332, 0.07022087750772221, 0.10041191638209146, 0.08379913096787472, 0.09557747073005707, 0.07254064005794769, 0.09853941710406255, 0.07845621767213418]}, "mutation_prompt": null}
{"id": "19ab547e-463b-46fc-967d-428c15ee31eb", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 40\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.5  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "MultiStrategyPSO is improved by adjusting mutation probability decay rate for better exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.3446928720442506, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "88c54d46-834f-4f6a-8d23-dd82317ea7aa", "metadata": {"aucs": [0.8615774383608783, 0.857232758066158, 0.8604541752975192, 0.8605825258639407, 0.8522527453349324, 0.8334007456298258, 0.8709115162440504, 0.8565360322926222, 0.8539399663261084, 0.6867962352865349, 0.7196711200948075, 0.6562743171825798, 0.673693806119908, 0.6746942272359109, 0.6736389364972329, 0.6946528517594077, 0.7053451112293362, 0.6658388976429878, 0.12228538152602408, 0.15625481419066123, 0.06905262994870187, 0.07620123488887987, 0.10981882001475551, 0.1567904493013128, 0.08712091256273291, 0.15968956568111847, 0.10377318369812294, 0.09183953499807063, 0.12301247753859812, 0.09077311450072212, 0.09956145139408767, 0.0713690070948273, 0.1096239239360699, 0.1083917966902056, 0.10975616087378548, 0.0951913193323255, 0.9204225178691664, 0.9175592115486876, 0.8999930999290575, 0.9073788804387288, 0.8989179585068217, 0.8922887715550172, 0.8990131976703118, 0.8879532262565737, 0.9000519039557777, 0.7522094560833287, 0.7584829503598453, 0.6704331451185879, 0.7626588545668361, 0.7367274287254453, 0.7098266671068904, 0.6862261148787374, 0.7364133477916199, 0.6897834293074838, 0.166947974739167, 0.14039583414046175, 0.16950212594935032, 0.8627778824974702, 0.8489618165578887, 0.6743106994144459, 0.15055875988002954, 0.17754602962360022, 0.17758510065112298, 0.309335208138941, 0.13129759775398886, 0.28438319589393246, 0.27331405854019253, 0.3180753743936494, 0.3028329476431122, 0.3632036958238495, 0.413591040426592, 0.27460238818458194, 0.27564633207047307, 0.26876738133040967, 0.1326395771230402, 0.27484179343537385, 0.2914335813898322, 0.28559035252851594, 0.30109640032506135, 0.3063339029139188, 0.2645493584436627, 0.08462108452441075, 0.08849020451801881, 0.14763552885112408, 0.05434816543139309, 0.04927425172708466, 0.04445491837899118, 0.04001778268472789, 0.09191050935791645, 0.06995602292324676, 0.11994732202635405, 0.0811538927157529, 0.20838400556040082, 0.061609120230420755, 0.05678709125423065, 0.0501972216778136, 0.11601089250914665, 0.10746485238405235, 0.07119168821705812, 0.25473112222888417, 0.09923834211060512, 0.1466106890609492, 0.24547789934252984, 0.12929499553858825, 0.23336765400103776, 0.09854098120182464, 0.11986283464133318, 0.1468530730041241, 0.16081642521931483, 0.1074072558734055, 0.2699795085220671, 0.1287614171405086, 0.23919527822135944, 0.1813853312177789, 0.11133340714309548, 0.18162068525462738, 0.08336751474209991, 0.5692330417605498, 0.5654115424607592, 0.5748786082552192, 0.5641086519352145, 0.6248867910782362, 0.6142310119741683, 0.612040160138519, 0.5972350174426847, 0.6021713097769624, 0.07590735859924791, 0.055615916770174634, 0.07460863727293632, 0.07725238755347308, 0.08786093338427503, 0.09674543617921905, 0.10967421459488091, 0.06352547764710803, 0.09118269503537069, 0.2152352346989238, 0.4890454188862663, 0.2229945232949283, 0.266422656549135, 0.4540847321359357, 0.7170109254844319, 0.2634862971507661, 0.23378375949160968, 0.4977352705492042, 0.17827054738176662, 0.4493985864906924, 0.545539397565416, 0.5318822837976795, 0.42904572685206854, 0.4176590716897234, 0.25429067257381943, 0.6489736208801846, 0.25851336727853913, 0.2346617564010729, 0.34761663973388, 0.23352050283042458, 0.29614474445710914, 0.22606537024187967, 0.2914578320403819, 0.2269313554958856, 0.23848513900075852, 0.2238649307504027, 0.25368638501090945, 0.23660877089977062, 0.21364418556462705, 0.23040374685023168, 0.19847537326496223, 0.25664364273827867, 0.2698985255295113, 0.25083831316122884, 0.24458003356461422, 0.18042245337520924, 0.1765342000720459, 0.196880482303478, 0.16983078676846763, 0.20767245590388994, 0.18764286556732845, 0.19204563825662757, 0.2102390149486275, 0.18188584270248565, 0.12634716380726185, 0.1766224481838644, 0.1460238194436242, 0.9366068083607805, 0.20077255669846894, 0.9384721973333695, 0.1425323265374394, 0.9178654094767117, 0.9271924459489481, 0.8514864465251634, 0.15643470839502394, 0.8645611808426886, 0.20903355502945065, 0.16769360109946696, 0.1541461799259367, 0.8066448680405457, 0.10483096708361028, 0.8544252452697654, 0.21197072028498098, 0.32782995265380366, 0.2018402412484197, 0.2281538171166766, 0.25657692637801033, 0.1998837059367522, 0.2553097808649011, 0.21747446725031327, 0.3212628601404349, 0.09056760766408767, 0.09677485949944642, 0.08136688674334147, 0.0971600367915082, 0.11217510210955839, 0.09401578480718831, 0.12648391945664839, 0.09915740202560286, 0.10158336498655429]}, "mutation_prompt": null}
{"id": "51a240e9-25f0-45fe-8380-69193384c510", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.5  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.5, 0.5)\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "MultiStrategyPSO is enhanced by decreasing population size for faster convergence with minimal exploration-exploitation impact.", "configspace": "", "generation": 30, "fitness": 0.34513599179285587, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "19ab547e-463b-46fc-967d-428c15ee31eb", "metadata": {"aucs": [0.8791484607533986, 0.8616996524981752, 0.8890095003949245, 0.8757486547776355, 0.8730736606518137, 0.8740398327547866, 0.86884209859176, 0.8831768300975105, 0.8613423393053724, 0.7148863740261799, 0.7238235871906882, 0.6967059833562639, 0.7090301384191084, 0.6854637386790241, 0.6994799053088735, 0.7121701004453737, 0.7383816639625382, 0.7090071309988588, 0.07089826088858442, 0.1586555750286378, 0.07537792993173187, 0.1105007101822788, 0.12392531721258149, 0.11071932346200497, 0.10143627801780164, 0.14426274890480073, 0.1447718240468836, 0.11530480123594422, 0.07951990854980284, 0.0631693668999238, 0.10981221336223645, 0.11635313974006023, 0.11500375251422879, 0.12300114768652981, 0.09892517272530787, 0.07096528945790637, 0.9156437548912132, 0.9098359721743088, 0.9200781520927686, 0.911802329062419, 0.9149661038740922, 0.8939186700058129, 0.9268034103868785, 0.9080538820045978, 0.9167588391659186, 0.783619947454872, 0.7515047499100851, 0.7264586820236816, 0.7806380150883026, 0.7422677675600748, 0.740408478036334, 0.7816637904881836, 0.7646111999231577, 0.7525663452458168, 0.8595942758352568, 0.13981152207371528, 0.16942804192777672, 0.2803034734132902, 0.2121832189977495, 0.19037575700069387, 0.13114816269758844, 0.18926583019821264, 0.2164813126424494, 0.2540082235325357, 0.1314454993273677, 0.2694693811677492, 0.3007447838838907, 0.1306449356067102, 0.4081532401348271, 0.3931777100517966, 0.13350115859181455, 0.288209088606037, 0.29418253149682616, 0.2730795780755847, 0.2723557316006928, 0.3392345852139649, 0.328275641646781, 0.13532708001453264, 0.31911403382289694, 0.3327336397194104, 0.3263782073130622, 0.03082757581741047, 0.09887231287063425, 0.04894223988626345, 0.036350961699046835, 0.0129038332829432, 0.041975197675184206, 0.06227454183053849, 0.03003874557844788, 0.03491163879083303, 0.1269846706719865, 0.06294487024962969, 0.12240267624092971, 0.11279588625567538, 0.0348405593916139, 0.01613488696152232, 0.1811327937694578, 0.09396510414131465, 0.10288563945777207, 0.1647029194776627, 0.38304939566810425, 0.16658162958192102, 0.1046611316740691, 0.20407993229878407, 0.1546115133036412, 0.10997401641401683, 0.25954223632187645, 0.0905875531937631, 0.188429754596797, 0.06938431987128002, 0.3557943595374061, 0.10618989443388216, 0.15156469349882196, 0.15119650190171907, 0.14235088411617403, 0.15254968288849557, 0.11446912344709126, 0.5607895583244322, 0.5927802620932826, 0.5859788517369738, 0.6000507910654744, 0.5256763088549908, 0.5836177270057034, 0.6010528447899111, 0.5811485012055331, 0.6166894317782885, 0.09895695167642748, 0.12777188116622706, 0.09155683606878084, 0.15682605756677603, 0.0821468089090387, 0.09641968284023239, 0.14079522669264022, 0.08544357436770822, 0.08553924530561163, 0.2006882284204755, 0.2877347808162346, 0.21197915497392494, 0.19868106285060916, 0.28179570079768823, 0.20531673360337777, 0.41855392686527226, 0.14266031654351408, 0.16399276450064604, 0.240243705144487, 0.35554917884487247, 0.20773138178668227, 0.5054845912148072, 0.42817527201716854, 0.4316842303541686, 0.19978367176593126, 0.5725056019381997, 0.6262369076891323, 0.23542983504787796, 0.3469066616267964, 0.22745178777966168, 0.2850981643700279, 0.23446788862926637, 0.14138496878951046, 0.18542371793404344, 0.2899349216520595, 0.14141435450292505, 0.23471433993837587, 0.2970282668212312, 0.224067893855318, 0.20160701268409775, 0.18737857463342578, 0.28796429176748684, 0.2194381583601328, 0.21214941468867, 0.21540754252690986, 0.18025948601492492, 0.20784080161368157, 0.189145637741015, 0.18149878959093613, 0.19353641031725477, 0.20251614970199106, 0.2113118515152621, 0.17479317926056304, 0.18896999118069957, 0.12641898083782432, 0.12633608443091549, 0.18747096614603098, 0.928225209408745, 0.20005304404278446, 0.9260387364491444, 0.14270717672179323, 0.924947467167785, 0.9365618609531396, 0.840218181406059, 0.8612599162305341, 0.7983577817255729, 0.20911513951851624, 0.1667883177277767, 0.8613526731166903, 0.8471391678252697, 0.8620033974324357, 0.8061296951983721, 0.28486372409689953, 0.24596280673417092, 0.24986354436599345, 0.2502352174492878, 0.2312963310940862, 0.23992167517393792, 0.2737021995705379, 0.2864341796980653, 0.2632808514627115, 0.11319681418796612, 0.09088258722269038, 0.06761068647786161, 0.09866347386031138, 0.086083181200722, 0.09216829569860951, 0.09067171633243343, 0.08078386247625635, 0.09468861685759689]}, "mutation_prompt": null}
{"id": "3af3c2e4-f1cc-4557-bbae-9005fcdbdbf2", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.5  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7, 0.7)  # Adjusted velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced MultiStrategyPSO by adjusting velocity clipping range for better balance between exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.35439675812806826, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "51a240e9-25f0-45fe-8380-69193384c510", "metadata": {"aucs": [0.8847981013751129, 0.8689331909769986, 0.8784082471140421, 0.8661325190939904, 0.8627714887250147, 0.869231548235955, 0.8614126765879172, 0.8809492568769586, 0.8572894185310729, 0.7451359981963384, 0.7311822239587068, 0.7231039040277578, 0.6999029697557181, 0.7017679569367552, 0.7212407689705704, 0.7221034284580798, 0.7218089999813777, 0.7229294276790477, 0.09193364110809488, 0.10034802741723903, 0.0815800851728582, 0.12202250052747654, 0.14231759934456734, 0.11535922847340752, 0.12027755398962803, 0.1434745862150496, 0.096435476594114, 0.09335389886136725, 0.12204605080767827, 0.09261655963986448, 0.10936201462822026, 0.1102104857617604, 0.04403220621751458, 0.12299299455488322, 0.1096995915960226, 0.10716372868729263, 0.9348648592724521, 0.9378740745204505, 0.9355637650534538, 0.9455595495310277, 0.9342901036971341, 0.9277531595217625, 0.949076647589396, 0.9219164792453324, 0.93812403982294, 0.798261048261122, 0.7572411166695145, 0.7012359301429815, 0.7886400460151567, 0.7727607686048964, 0.755846616629565, 0.7737941443487049, 0.7288373807446941, 0.7578302662031393, 0.23001968209948442, 0.1405908469954924, 0.14054924809413083, 0.8610626588797574, 0.21230770150150335, 0.21199637969306073, 0.1763632582685727, 0.15172934320432907, 0.23695600221101598, 0.24381234239603766, 0.30709102829810897, 0.13144107337325917, 0.3208998158249563, 0.36400502010912406, 0.294165792566624, 0.3149499324891234, 0.28194884529954445, 0.2835765714100583, 0.13524858425079145, 0.275841002685665, 0.13253722480898722, 0.31479851770658196, 0.31875514598988586, 0.32546415220965774, 0.3176626586705036, 0.30049830192689064, 0.19573425328298033, 0.0652467223312313, 0.18222686742930982, 0.07300728652764743, 0.06931552189786072, 0.015593044216761887, 0.002764062506034115, 0.1082197306283208, 0.06616425677521531, 0.15159021427119224, 0.09737764321960807, 0.10580906593366557, 0.17383955569441767, 0.07310302396541646, 0.05582664406107629, 0.05668018374154449, 0.14716737936496338, 0.08054045161493195, 0.032536070741852385, 0.12445347642560278, 0.19935596539797185, 0.18729324157992855, 0.3477792744036642, 0.07687535570921522, 0.21289138567101917, 0.09971409892730498, 0.08866396514466923, 0.10222894415568773, 0.11962014469314797, 0.12837994196876656, 0.20850949297341137, 0.07684336071704478, 0.08283934233739365, 0.10678755189587064, 0.15891077393438557, 0.1598011979318228, 0.20368422656131857, 0.6415333852740595, 0.6878817275378541, 0.5655714392486131, 0.5873502301272745, 0.5664134528640208, 0.703665586916915, 0.5623008052860383, 0.5946810486006646, 0.6206756735687872, 0.06319501839738118, 0.09342703450854206, 0.07800555060686531, 0.13315362925227214, 0.10412611402589644, 0.16082497519165095, 0.0922692865717627, 0.1279674472067689, 0.08087216607727643, 0.2713789825694103, 0.2355023096831116, 0.4525640654337485, 0.2686468036167615, 0.4488721802547109, 0.3901853012471107, 0.3269007669788856, 0.2638822572055406, 0.6647090495052875, 0.2616235561884078, 0.45320535217976, 0.2665182120172923, 0.4214863073124119, 0.5026603265679482, 0.46025662828051894, 0.28215591624292624, 0.5874019671395277, 0.2548177035569341, 0.26077265634051827, 0.3590121700182406, 0.18875260187653742, 0.2847623499165073, 0.23548339153305586, 0.33231014934787473, 0.1691058471629232, 0.31830184985361665, 0.19097381039774997, 0.20407880655185984, 0.22676221441013966, 0.19499712139405645, 0.2500168062742931, 0.21688524112110297, 0.29126511504684593, 0.22610884538214326, 0.296382007960872, 0.20778584271983047, 0.19846675172929285, 0.17680804191010413, 0.1724443569256291, 0.17606749176280012, 0.19432039865437578, 0.19929723257684706, 0.18313958595434232, 0.22580239910172495, 0.1718761027446537, 0.12630667267578066, 0.17852570750881935, 0.1536475995955845, 0.919263163524356, 0.20025967049088855, 0.9312413022279915, 0.9098512218858453, 0.92104040012725, 0.9308477241152333, 0.9297971348900695, 0.21326177130193558, 0.8834063281430897, 0.9195721394877546, 0.15404489625802287, 0.21135879873543195, 0.8429480721525632, 0.8484606635585179, 0.8700224251865599, 0.2810334211767944, 0.2201766912405816, 0.17481065402622575, 0.2145462252808349, 0.24496765006664867, 0.24897389978119022, 0.25971989165416254, 0.32523324635877393, 0.2143536561931707, 0.09442974978971652, 0.09339252256217145, 0.08838631693946886, 0.07724519064398117, 0.08718144660762173, 0.07952412925632801, 0.10802446185302728, 0.08828020780585488, 0.11146005610204135]}, "mutation_prompt": null}
{"id": "df27390e-9be2-496f-ba49-10d0a957dfd2", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            \n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7, 0.7)\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            self.mutation_prob *= 0.96  # Changed decay rate from 0.95 to 0.96\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Refine MultiStrategyPSO by slightly adjusting the mutation probability decay rate for better balance in exploration.", "configspace": "", "generation": 32, "fitness": 0.3516787290495001, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "3af3c2e4-f1cc-4557-bbae-9005fcdbdbf2", "metadata": {"aucs": [0.8847981013751129, 0.8689331909769986, 0.8784082471140421, 0.8656678191746483, 0.8627714887250147, 0.869231548235955, 0.8598167423883384, 0.8766483902238328, 0.8572894185310729, 0.7451359981963384, 0.7063296498601335, 0.7224496409337109, 0.7105531174709452, 0.7043352563100338, 0.7082784081220321, 0.7221034284580798, 0.7071237526350369, 0.7229294276790477, 0.09192299759097766, 0.15853264993425586, 0.09034214788272898, 0.12202250052747654, 0.14231759822087042, 0.11535922847340752, 0.1132522008224367, 0.1434745862150496, 0.096435476594114, 0.08185258278686924, 0.14188627766654516, 0.0926235343696058, 0.10754581005883179, 0.11050729410365945, 0.11749695983027009, 0.12299299455488322, 0.1096995915960226, 0.10738971421482002, 0.9348648592724521, 0.9378740745204505, 0.9355637650534538, 0.9455595495310277, 0.9342901036971341, 0.9277531595217625, 0.949076647589396, 0.9219164792453324, 0.93812403982294, 0.798261048261122, 0.7346190923653679, 0.6911562548477532, 0.7886400460151567, 0.7663702641501645, 0.755846616629565, 0.7737941443487049, 0.7339054344359734, 0.7544186510078659, 0.23001968209948442, 0.1405908469954924, 0.14054924809413083, 0.8610626588797574, 0.21218302596100125, 0.21199637969306073, 0.1763632582685727, 0.15174895456244308, 0.23695600221101598, 0.24381234239603766, 0.30709102829810897, 0.13144107337325917, 0.3208998158249563, 0.3579790951175098, 0.294165792566624, 0.3149499324891234, 0.28194884529954445, 0.2835765714100583, 0.13524858425079145, 0.2512181199238197, 0.13253722480898722, 0.28121664066463203, 0.31508200922297835, 0.32546415220965774, 0.2923934417875246, 0.30435307172404424, 0.19573425328298033, 0.0652467223312313, 0.17672196290031494, 0.07515924125242057, 0.06931552189786072, 0.015392642863778616, 0.002631285266695871, 0.1082197306283208, 0.05181292112682856, 0.15159021427119224, 0.09737764321960807, 0.12352155328696501, 0.16160263140876363, 0.07310302396541646, 0.03463629230651444, 0.05668018374154449, 0.14716737936496338, 0.08337112529261415, 0.032536070741852385, 0.12350271382012434, 0.19933710057742282, 0.18729324157992855, 0.27752889508723044, 0.07688428948490733, 0.21289138567101917, 0.09971409892730498, 0.08866927891348408, 0.10222894415568773, 0.10820863447661289, 0.09389948891915134, 0.20850949297341137, 0.07684336071704478, 0.08176817076918796, 0.10678755189587064, 0.1742866185800731, 0.1598011979318228, 0.20368422656131857, 0.6415333852740595, 0.6089245578730402, 0.6324941548943861, 0.5424853537547121, 0.5664134528640208, 0.6537580384600323, 0.5813167631032208, 0.612914987736306, 0.6206756735687872, 0.07434009269111852, 0.09718624740982174, 0.08577811526612422, 0.13315362925227214, 0.1041261140872557, 0.16074540592892828, 0.09207768657257986, 0.1279674474734449, 0.08083236729731202, 0.2769436783419976, 0.2353387776844914, 0.5234025190784886, 0.2326373734897178, 0.44781874742002514, 0.3243265913955824, 0.3269007669788856, 0.2631281102788583, 0.42643830076035016, 0.2616235561884078, 0.3508954767477508, 0.26798999153974756, 0.4214863073124119, 0.3926303084765851, 0.37551259930089964, 0.3243121036533533, 0.5036888341646202, 0.2548177035569341, 0.26077265634051827, 0.3797924764017381, 0.18875260187653742, 0.46353239931589074, 0.23548339153305586, 0.3375388679546317, 0.1691058471629232, 0.31830184985361665, 0.19170103184391862, 0.2277994930830054, 0.22676221441013966, 0.19498051449596354, 0.2683373389728123, 0.21688524112110297, 0.2906257165340377, 0.22090390900799284, 0.296382007960872, 0.2076837301550527, 0.19846675172929285, 0.17680789098713245, 0.1724443569256291, 0.17598255050511957, 0.19432039865437578, 0.19928792895442704, 0.18313958595434232, 0.2258044512802332, 0.17189520574098183, 0.12628170727682353, 0.17852570731522466, 0.15364755271474606, 0.919263163524356, 0.20025966432878417, 0.9312413022279915, 0.9098512218858453, 0.92104040012725, 0.9308477241152333, 0.9297971348900695, 0.21326177130263269, 0.8834063281430897, 0.9195721394877546, 0.154044818247699, 0.21135879873543195, 0.8429480721525632, 0.8484606635585179, 0.8700224251865599, 0.24397452914158013, 0.22005035812321028, 0.24002811555639358, 0.2145462252808349, 0.24496765006664867, 0.22202393552533517, 0.24497241200017028, 0.32523324635877393, 0.21907818200472062, 0.09902225840918433, 0.09339252256217145, 0.08828448126130972, 0.07724519064398117, 0.08718144660762173, 0.08006036894026147, 0.10119799254551343, 0.08828020780585488, 0.11013123751311704]}, "mutation_prompt": null}
{"id": "ec3b3c68-1307-4a50-9734-61a0aae93042", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7, 0.7)  # Adjusted velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved exploration by adjusting the cognitive parameter for better individual learning in MultiStrategyPSO.", "configspace": "", "generation": 33, "fitness": 0.3544055018058607, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "3af3c2e4-f1cc-4557-bbae-9005fcdbdbf2", "metadata": {"aucs": [0.8522225571601376, 0.868906122792983, 0.8591967275723418, 0.8554497633411701, 0.8684051000575277, 0.8617422258795627, 0.8310811053605741, 0.8670497622637371, 0.8655665617696354, 0.7139807720996623, 0.6829095341244753, 0.7186889548256494, 0.6843117352561618, 0.6717366382045589, 0.6872093504393226, 0.6894190405891968, 0.6870520511439062, 0.6325072070656999, 0.11484890103942125, 0.13253182353276804, 0.10883816001804392, 0.11420256483232116, 0.11708363991871062, 0.10055271591967463, 0.12210333636654902, 0.15684780006585297, 0.13302171260300544, 0.11586977928469822, 0.1143292606284001, 0.10989111904063487, 0.12061080201523622, 0.1566950990850583, 0.06269661228289825, 0.0992739675977995, 0.09642172890619471, 0.09516351251445321, 0.9355579912140928, 0.939759399877218, 0.937530458240113, 0.9455897555933384, 0.9309055153367393, 0.9275838121501918, 0.9499542806458066, 0.9220223318081276, 0.9435735486057016, 0.7404091360124979, 0.7389483439405553, 0.7001295011333789, 0.7119355566037333, 0.7362430919538706, 0.7318511001734495, 0.7663254843380419, 0.7398548624562995, 0.6696680104436867, 0.8680028593775141, 0.1403493557746126, 0.13997911862124823, 0.9046975805547052, 0.277627259274554, 0.2195111945857654, 0.14450705105817596, 0.18241699085159468, 0.247467163460235, 0.2427248732163887, 0.2345858405915381, 0.33215229503038035, 0.26596121699169295, 0.10718011097822633, 0.13279479975789776, 0.272290527143618, 0.286093994681512, 0.26441080177946774, 0.1355503776694219, 0.2709167621260009, 0.13468631954543164, 0.3028041336375443, 0.31174622471015956, 0.28159672550046244, 0.27087478845553736, 0.2858364632619945, 0.20465305610413953, 0.018982539906321705, 0.05945778801346857, 0.021037591119789423, 0.08768928300584489, 0.06560949277934724, 0.05698359543316833, 0.07356932229687696, 0.007297726734447729, 0.0817797140578157, 0.06189380114908638, 0.16449129709709254, 0.2060238300547056, 0.1281293676144707, 0.03355336215538063, 0.09864349644882986, 0.11727705423163348, 0.09096805472803249, 0.03080233653012543, 0.20299936227872628, 0.15435977469193107, 0.1718958303911179, 0.1279547098411471, 0.0871763474170475, 0.1941568862526314, 0.09707759211390476, 0.17425547987746215, 0.10015036344542838, 0.13710142445633045, 0.17586986394746074, 0.10178460208242213, 0.35795973284063265, 0.11619212383090727, 0.10933287057687446, 0.2470597544876426, 0.14238743168912282, 0.1433856482927537, 0.5489051685017796, 0.5544683330501401, 0.6336863962989647, 0.5663431409105653, 0.5412931492537449, 0.5526476116231214, 0.5803782812099201, 0.5656683835183807, 0.6096756776349408, 0.10835365314723455, 0.09140245116511292, 0.13962478888366026, 0.1216648583047738, 0.0718464114172368, 0.1825453298595452, 0.07944019677420455, 0.09160950906637388, 0.08833508555104108, 0.3651269985713389, 0.4556878915657082, 0.3559049464114028, 0.5646063626311332, 0.4866622046919563, 0.3659441180567157, 0.22188962925471367, 0.20727299974549263, 0.6589484664528444, 0.4349388401175528, 0.3384934249318352, 0.5479231949624747, 0.44285817775198066, 0.19581900919376016, 0.6353041674134068, 0.4512771490129551, 0.47530457296151485, 0.3820133780018796, 0.22403327039568477, 0.27776439094823546, 0.21007986099834008, 0.3102544814793937, 0.22806138770983908, 0.3165528138695983, 0.1810304707399243, 0.23354533378379205, 0.2271295936751293, 0.2601538818077366, 0.23574546421010723, 0.2464001391388153, 0.33471808140573545, 0.1901522341895966, 0.21611819421198852, 0.25105121911082573, 0.22015260125498304, 0.19234628847911683, 0.19909951308655405, 0.18982664687853812, 0.19130939165530703, 0.20329179474147563, 0.18295348698015046, 0.18219045873716055, 0.22552561351434974, 0.24902978472941273, 0.2064021451548178, 0.1261279132370986, 0.17825919592537687, 0.1536624936680553, 0.9227925568585672, 0.2003710044284458, 0.904126111145996, 0.9204448083414725, 0.9237341617424699, 0.9377200725511617, 0.8931422402793467, 0.21309152821588762, 0.8712929843829234, 0.8531098698808584, 0.15390667135254166, 0.2115130412850541, 0.8631690628410429, 0.8741417869823401, 0.8627835758503448, 0.23783584396543556, 0.2576955370041607, 0.20353066780701423, 0.24192353338944228, 0.2407748930695579, 0.19803682268488587, 0.2527626154105491, 0.27982169442883864, 0.24428220789572386, 0.0731880359098348, 0.08473301783608145, 0.07896125833000334, 0.08012721659660926, 0.08115084648642368, 0.10008811055645417, 0.10514687605869844, 0.0867450735482238, 0.09964529659831933]}, "mutation_prompt": null}
{"id": "7463a2db-4dc9-498f-8e22-39f14aa01868", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7, 0.7)  # Adjusted velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best with randomness\n            if np.random.rand() < 0.05:  # 5% chance to introduce randomness\n                global_best_idx = np.random.choice(self.population_size)\n            else:\n                global_best_idx = np.argmin(personal_best_scores)\n                \n            if personal_best_scores[global_best_idx] < global_best_score:\n                global_best_score = personal_best_scores[global_best_idx]\n                global_best_position = personal_best_positions[global_best_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced global exploration by introducing randomness in global best position selection in MultiStrategyPSO.", "configspace": "", "generation": 34, "fitness": 0.3356434886442654, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "ec3b3c68-1307-4a50-9734-61a0aae93042", "metadata": {"aucs": [0.859222307365008, 0.8752360118530034, 0.8800725215648644, 0.8852671261431767, 0.8676388125227066, 0.8749811920043349, 0.895010259901698, 0.8746377210355695, 0.8721258134916473, 0.6971290112593267, 0.6870156787678945, 0.7485636981184332, 0.6722844515980049, 0.6998589966198229, 0.7062430817145323, 0.7083610346862224, 0.6557114907744866, 0.6662435914882207, 0.10133279634710268, 0.08814961114360742, 0.14339414920572113, 0.14172304689330562, 0.11575433634527255, 0.11595687948924971, 0.11451867873637345, 0.1246732280870112, 0.14287157131055606, 0.09647793778515168, 0.12407475297106085, 0.0820832602302266, 0.1397845992501332, 0.06960133274574198, 0.11626657991430023, 0.15704965670269744, 0.08581882408911135, 0.0942014153914954, 0.9429936124608999, 0.9290993570894348, 0.9452600416304378, 0.9385976625801679, 0.9378654528173402, 0.9377858135054636, 0.945695393902156, 0.937344512054721, 0.9376812271728642, 0.7408714541212041, 0.7332057780440218, 0.7582258084534201, 0.7377752124859951, 0.7624288160553876, 0.7391368326325634, 0.7417152457216281, 0.7353244751034587, 0.7596243007349868, 0.22734137801351484, 0.2265820150856317, 0.22785953428112649, 0.3794172245080155, 0.21359180960867907, 0.2797472232801538, 0.15249290692303408, 0.17839962945774224, 0.23668005495095135, 0.13227068121556607, 0.13224565440156144, 0.2610575653191761, 0.2594477055966252, 0.2504365663281889, 0.2525988476071427, 0.28148349510902704, 0.26711892594059883, 0.32530773730320783, 0.273810442084676, 0.2714601449615367, 0.1339884587275495, 0.3162674819996121, 0.29110300688285284, 0.3086770658978555, 0.27966879835343295, 0.2842183883444144, 0.30783963557122174, 0.02370209793594491, 0.0655375437914929, 0.07180987664523386, 9.999999999998899e-05, 0.01360084047166854, 0.09978450858604826, 0.04455492604181022, 0.013898455827369038, 0.08198809136227503, 0.1928089429527513, 0.13401784915938864, 0.24041727123120704, 0.0950665759506164, 0.028518059022746844, 0.05455526604129757, 0.22078282601607357, 0.12720274019207756, 0.08326280426703891, 0.09769586684239506, 0.18912275863139916, 0.16657266066759457, 0.11106064050512032, 0.14249282427557497, 0.12834839236031237, 0.09961275143312709, 0.10928898676444765, 0.07790989880769339, 0.21761163249311333, 0.13792113483870394, 0.18810594611717535, 0.16303503093901928, 0.19703733394200384, 0.0720134506482435, 0.11844083968146502, 0.11911621893559188, 0.12236357022020616, 0.5496811295293924, 0.587385437470432, 0.56963231298731, 0.6111079566625839, 0.5560618970335449, 0.6237411755958084, 0.5950505920962541, 0.5674675634064934, 0.5825646496450092, 0.11526246276333152, 0.06289818347168641, 0.14179190634127803, 0.11095853014175949, 0.11621743724072842, 0.14524784228442766, 0.11642020734338654, 0.10969395502226964, 0.11906823068934158, 0.23136263421658287, 0.2751549233881502, 0.5109515405961149, 0.3168233891136103, 0.3445692146606, 0.38895177622891575, 0.2828336195485085, 0.21697972689851186, 0.6696736114453913, 0.37950662166129545, 0.42597263503886873, 0.33253943565567, 0.34461726445594765, 0.44996801401239694, 0.5414359853425585, 0.2794369479843398, 0.4905933193883263, 0.269532109561044, 0.24873950026811487, 0.2870149311606587, 0.19726676411023703, 0.3026987466250475, 0.24694296751006284, 0.32544549574848447, 0.21216818919554503, 0.2529976425133025, 0.1592541317103069, 0.2497405163580957, 0.2281499966173307, 0.23809744127478216, 0.2664656106842348, 0.27949329030956815, 0.251937064812944, 0.2600964857441105, 0.21988616120460103, 0.193388268318204, 0.21117542360735186, 0.2190036859986333, 0.18264544056459708, 0.1742417644556744, 0.17866165438127501, 0.21069220342062178, 0.17809571305821226, 0.22615770067033614, 0.1820094408417361, 0.12650512046971596, 0.17835313481712034, 0.17656419965728087, 0.9192069894569548, 0.20063105155198413, 0.9447335924008537, 0.14289340199110667, 0.1695857950532258, 0.928679252371873, 0.8398027845563534, 0.21376610541932217, 0.12603915040124158, 0.21099446816991163, 0.1688027198311267, 0.21100138671960678, 0.8443623022312254, 0.8518750062460277, 0.8777238798297926, 0.2402295413883232, 0.2261258299328479, 0.2413113619408742, 0.20734935776325125, 0.31184677194036037, 0.20199601614715412, 0.24651458063743026, 0.2360216220923338, 0.2525895722515442, 0.08895830258648008, 0.10758032303078602, 0.08626052244842664, 0.10091123647299283, 0.1053948260074149, 0.0875004673335843, 0.07623966034895513, 0.08499294758870113, 0.11159235052466121]}, "mutation_prompt": null}
{"id": "efc8ffc6-3a28-4443-b8ea-27b36810d244", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7, 0.7)  # Adjusted velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n            for i in range(self.population_size):\n                dynamic_topology = max(3, int(self.local_topology * (1 + diversity)))  # Adjust local topology size\n                local_indices = np.random.choice(self.population_size, dynamic_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved exploration by dynamically adjusting the local topology size based on swarm diversity in MultiStrategyPSO.", "configspace": "", "generation": 35, "fitness": 0.3473514030636788, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "ec3b3c68-1307-4a50-9734-61a0aae93042", "metadata": {"aucs": [0.8621618410320764, 0.870343069458793, 0.8498702829305396, 0.8475950979255464, 0.8614282326027224, 0.8535331327193464, 0.8380581981116272, 0.8608056672210416, 0.8722112134470679, 0.7152691350023577, 0.7336986746464639, 0.7478184092421727, 0.7175272195022768, 0.6935264635022028, 0.6948708993650735, 0.6478282747660455, 0.7088591515646946, 0.648894185120978, 0.11022839708292154, 0.15977584981770465, 0.11703255246048427, 0.09974650736235813, 0.09586817203038611, 0.11212044062638327, 0.0856152844369148, 0.1342652835218614, 0.13280864814527582, 0.11955107080403471, 0.1572393596962235, 0.11514725851792229, 0.11527776002870527, 0.10923986848663458, 0.1235748499225412, 0.14955977213550764, 0.12273404064933524, 0.08345345161777018, 0.9449534662330106, 0.940413052948346, 0.9406277789111366, 0.9459231912143898, 0.9307177080190956, 0.9314515519705204, 0.9487907146801011, 0.9268185801697033, 0.923626107716154, 0.7194693598583581, 0.7252474633123877, 0.6820983765042498, 0.7650905080680184, 0.732878144762882, 0.728297194132075, 0.7495666570711952, 0.7232119242353241, 0.6787906327452595, 0.22897030149896958, 0.2252376735155731, 0.1700958915060261, 0.9008658981105674, 0.21263600326940912, 0.21326854766722958, 0.1764845464151169, 0.8399610056401322, 0.848441307890016, 0.41984675417925077, 0.32317689700341545, 0.2662382905895274, 0.28930897795549804, 0.4563461534174984, 0.41859666489482494, 0.2540219180664597, 0.3104006615296232, 0.2805117910009297, 0.13551025581941412, 0.28188415885937523, 0.27954690689391204, 0.31344680187104235, 0.292505014946852, 0.13453205912473676, 0.28794804771978244, 0.1317419020824787, 0.2026265865310124, 0.09872921219550768, 0.06529450938013615, 0.08823625395587531, 0.07733264579949117, 0.015628520792011713, 9.999999999998899e-05, 0.027673051985265595, 0.015215639158340899, 0.08260610064132379, 0.059327786202685306, 0.10991533450993685, 0.09716919865860363, 0.08789533930812776, 0.04147848389634923, 0.02504433256044869, 0.1108934539846943, 0.0688057165381446, 0.10303681681754606, 0.13662266950303725, 0.35760413684618775, 0.19124131788973397, 0.12052693599697362, 0.09968369755438256, 0.2255753181475474, 0.13137109041566786, 0.1462673384446993, 0.08187455481445816, 0.12830302110072644, 0.13452777769899127, 0.15454580998368694, 0.16739026346514418, 0.12582597621990754, 0.08112143106962244, 0.13584736719445356, 0.1994109613637437, 0.34658056848236685, 0.5656663929620023, 0.5524764349499334, 0.5773896230103879, 0.6038432399034022, 0.5789160045536403, 0.565819652332074, 0.5667367218591699, 0.5700853714040055, 0.6001383807506928, 0.10213153735565961, 0.07871881675853132, 0.10764932194302268, 0.12141412123285267, 0.12095689316118774, 0.09785324959031272, 0.12788842686082058, 0.10926809569590445, 0.11148178508838646, 0.22451783310710893, 0.22880310431507678, 0.22713275778859254, 0.17148009023673438, 0.5616507968870389, 0.6409113378686575, 0.40447691582696454, 0.28611544954556634, 0.2302961834403725, 0.2542564829799079, 0.2054245792823689, 0.22987969989292822, 0.46964371387583237, 0.2617477470883116, 0.4963703103517013, 0.289367049575179, 0.4063275152503998, 0.2407771590472636, 0.24951961494020725, 0.34836124740257923, 0.20741466157687916, 0.3335902586155979, 0.3159737083611919, 0.30244058668448814, 0.19874378716416818, 0.2174971556392884, 0.29092629016518023, 0.22646151313443097, 0.22991397714242168, 0.21786485168792158, 0.2585102005747085, 0.2723163253079539, 0.21534978215245115, 0.2741516922876056, 0.21218169085938332, 0.19662522283155004, 0.22562939059525178, 0.25279922885808703, 0.17822579653714532, 0.18581793459532692, 0.19401863116141382, 0.20828500003950545, 0.17389705322462357, 0.20932085505995413, 0.18160865183478336, 0.12662575219403116, 0.177677047922024, 0.15388921194760496, 0.9272947512570611, 0.20042777306077764, 0.9356368207416867, 0.14292723735255763, 0.9207999150480435, 0.9409517992690682, 0.8480987708476541, 0.2134707325913543, 0.12685688881541424, 0.8563102071172277, 0.155675156398286, 0.21154009087120862, 0.8777364777817633, 0.8420679409627168, 0.8109436335412702, 0.23302017455403812, 0.23182196594040527, 0.3497656221282124, 0.22075216663172237, 0.21890800475575212, 0.3004303286632537, 0.24600293034158371, 0.2431036055692587, 0.2040933512580132, 0.06453857776977656, 0.0995945794738653, 0.09717456447905715, 0.09703136118355848, 0.09891871864244095, 0.08400160424628134, 0.0895689657489438, 0.09155856720707145, 0.08526608260484536]}, "mutation_prompt": null}
{"id": "cbff364c-9578-4ad6-97cd-39acaf384e39", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * evaluations / self.budget)  # Dynamic inertia weight\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7, 0.7)  # Adjusted velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduced a dynamic inertia weight to enhance exploration and convergence capabilities in MultiStrategyPSO.", "configspace": "", "generation": 36, "fitness": 0.35317914534040584, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "ec3b3c68-1307-4a50-9734-61a0aae93042", "metadata": {"aucs": [0.9303429832093991, 0.9125308408917007, 0.9144927483712868, 0.9131701154087921, 0.908356943400253, 0.9144792508047014, 0.9050244533270907, 0.9124096129088062, 0.9125476086018275, 0.8253248661909008, 0.8102465630422797, 0.7915453887080994, 0.7937241911615742, 0.7941336144411322, 0.8224782749348336, 0.7905259029162031, 0.8070421061410994, 0.7633518566881097, 0.1006506843250885, 0.1246856993140224, 0.08609622828733732, 0.1254141803983353, 0.11821115396488435, 0.11753943903547492, 0.0806502704366936, 0.16255973849917915, 0.10211239375121117, 0.1061903461951168, 0.11179221716386434, 0.09246013300083045, 0.08588451271704667, 0.08623816731391931, 0.03578264909908446, 0.14661088560704882, 0.09230451291804953, 0.12421709670703585, 0.9399463365481596, 0.9344846475153199, 0.9340675097333329, 0.9244177845231656, 0.9176099681865323, 0.9294777702766864, 0.9444224332962563, 0.909380472207761, 0.9296059947935683, 0.8414137059116501, 0.8467933070592176, 0.8030330687175339, 0.8339957752656498, 0.8245686204911447, 0.8601665452471203, 0.8290850703664321, 0.7975928816202799, 0.8117614264048345, 0.22696614285305727, 0.13921611939559042, 0.1405656597341466, 0.2820570881542983, 0.27963166246561755, 0.20931391067448368, 0.2094776021308713, 0.2347214811881052, 0.15182422344643454, 0.25497733548109913, 0.13192873750407597, 0.2950303031440492, 0.3218950325355169, 0.29205081010702527, 0.3573458925429799, 0.32892130945615994, 0.13460781969356705, 0.31896253710506695, 0.28383447171476284, 0.2742058499873491, 0.1268535562655475, 0.32209157970382774, 0.34254644189680405, 0.3432684240531212, 0.13032321631482813, 0.32420481511118393, 0.3005786800960428, 0.09276499789700099, 0.06737047587721134, 0.03785062535234429, 0.10844261207443706, 0.11741958096734617, 0.10120251002215142, 0.06486015896587882, 0.03203032036170428, 0.029087326613413067, 0.07041770699111116, 0.055280138018755864, 0.1449518396535494, 0.05395618935035529, 0.024038220082230666, 0.07980696461908576, 0.16651303078201019, 0.12366655844915364, 0.04733835868200842, 0.1437908643898259, 0.21206575082714185, 0.1768911682778942, 0.1676208709687398, 0.10173148968067014, 0.12043595842940868, 0.1270815745969659, 0.0920232436670565, 0.11367274576328834, 0.5324063486218711, 0.32137084566821916, 0.14527773306069525, 0.0688187234629769, 0.08734221675505593, 0.1250894695899628, 0.11094833088592315, 0.2800430774758077, 0.08564622263784605, 0.6128597707569446, 0.5678677074247793, 0.5993952485256814, 0.601988998156205, 0.5763548133383671, 0.5877881408195761, 0.5808932813044402, 0.6074244369008659, 0.6610668754317071, 0.13083837800156728, 0.06183436144393051, 0.07310482465565205, 0.11649653386879177, 0.09510329420398178, 0.1459834822033521, 0.11173783695195183, 0.09624772233146706, 0.13374417592175325, 0.27824187621969, 0.23925581542118768, 0.18200773811423343, 0.26227932996874137, 0.4344416643812111, 0.5227486471613175, 0.2003687113143814, 0.2003416959778096, 0.2994246910812729, 0.18411261758128517, 0.19492122158940828, 0.20821794884655187, 0.24668813430317327, 0.28077658558754837, 0.4870921200836975, 0.26739333279866495, 0.6350388011897499, 0.2785846167551551, 0.25012349131925116, 0.23585941486011963, 0.11847104993974023, 0.30063640590459895, 0.1996415815114544, 0.34270377656076767, 0.2454342435706678, 0.2755509047556628, 0.23323257760660776, 0.27221703778754414, 0.2794312807229611, 0.19550881570310974, 0.20404966589950047, 0.21511680777201314, 0.2325363882232273, 0.3027308728258076, 0.2151117903062837, 0.2567533144560571, 0.19700089769151152, 0.18035516332545287, 0.1989497784604709, 0.21317567463219333, 0.19448141374611905, 0.18543617693896575, 0.18299034766673383, 0.1834301146199131, 0.1890506325990805, 0.12665647031280536, 0.1778280902449394, 0.17702122166450118, 0.9268169755757152, 0.20132930004917193, 0.9493962912706154, 0.9411680893211567, 0.9396569409089063, 0.9498655316306625, 0.897364784292931, 0.21394534184249892, 0.8670060958978776, 0.8640217333236504, 0.1549343766457354, 0.9018556271127449, 0.10450813587889551, 0.8919180020984219, 0.8744635035891162, 0.24037349473234038, 0.20744324198003106, 0.1960780922047084, 0.3527302462664623, 0.27489796971827407, 0.20093776064400237, 0.2631666703280522, 0.2018238499796553, 0.22418355879557417, 0.07872197655447111, 0.09824098286113225, 0.11714950163547988, 0.07425076238017791, 0.09044400629852534, 0.0808166883507705, 0.07485089288020719, 0.09040289148205993, 0.07817534443181562]}, "mutation_prompt": null}
{"id": "402c121e-28d2-4b43-a49b-290f01a9473a", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.45 + (0.5 * np.random.rand())  # Increased minimum inertia weight from 0.4 to 0.45\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7, 0.7)  # Adjusted velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introducing a small increase in the inertia weight decay to enhance exploration without losing convergence speed.", "configspace": "", "generation": 37, "fitness": 0.34388042816210923, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "ec3b3c68-1307-4a50-9734-61a0aae93042", "metadata": {"aucs": [0.8436715779795774, 0.832522395888109, 0.8508511412750214, 0.8150530103872387, 0.854455946503849, 0.8250478794898036, 0.7801714065610574, 0.8370537155959499, 0.8145153333035425, 0.621064460550182, 0.6872899989243373, 0.6564904666167071, 0.6786959637908347, 0.6271898233074314, 0.5874821246836455, 0.6271649201006897, 0.5956757912140267, 0.6473410877895973, 0.09880696076752227, 0.10055714622001544, 0.10783105518106217, 0.1808159322122952, 0.14300525538179898, 0.15765652341149528, 0.1040559348925355, 0.15906673655032022, 0.12198939552132904, 0.11584148840228281, 0.11422962013186955, 0.09556434310737805, 0.11613538191086337, 0.11644355587396316, 0.11998988118874077, 0.10725452700403948, 0.1098724016849576, 0.10397088655859499, 0.9415139394491575, 0.9376829717235762, 0.946410101321232, 0.9444077730124435, 0.9401833951145115, 0.9352545047159126, 0.9456662055686009, 0.92771680902043, 0.942160042120089, 0.6929602250607697, 0.6845552182414931, 0.6405417609385027, 0.714786391362562, 0.6352638896960352, 0.660507350278941, 0.6616523098166069, 0.6387564006974904, 0.6632460575156885, 0.2286348936993966, 0.3739956834216789, 0.1704339959980401, 0.3803232194475007, 0.21257053556836258, 0.2768619163400875, 0.5313968592682607, 0.2318750003687715, 0.8777879089950794, 0.24510504796727006, 0.25845683671809605, 0.25147532808879036, 0.23979034939264743, 0.31947293231688967, 0.24920444957406807, 0.31712388730124774, 0.25472169270757095, 0.2654541421817447, 0.20558008447383613, 0.2596877290771614, 0.13336689249144507, 0.30213466125940613, 0.28140680209721036, 0.26204497037057695, 0.27697544766565874, 0.2789258894907568, 0.20585475077925286, 0.07643674471508366, 0.20216114584682077, 0.06716240260033213, 0.04701853565819003, 9.999999999998899e-05, 0.009876268353458562, 0.05452285999889572, 0.004738256715275724, 0.12330173775138753, 0.1361123139309368, 0.19785037916872972, 0.19265844332865345, 0.0751021906765924, 0.10744493075611428, 0.07409213697326211, 0.13872021589641514, 0.10868397538383257, 0.06576485443971636, 0.11232714190854853, 0.18776341167331034, 0.15792100997779068, 0.1303606162304093, 0.19400437142179672, 0.41232108383367105, 0.0993412609983676, 0.16441687894910906, 0.07619419190440058, 0.13926860708454114, 0.18825828410593826, 0.1105864062417724, 0.11181073644648043, 0.1335141420437238, 0.1287064963381237, 0.1391619107790517, 0.202247564372125, 0.10845135862387267, 0.5209033010458166, 0.5365941506384142, 0.5721638812233598, 0.5707917282117927, 0.5551941433236743, 0.548633782641712, 0.5709104052337508, 0.5779952648886554, 0.5566959702392228, 0.09990103549857887, 0.08092477406833876, 0.15735344578368948, 0.14190401528110763, 0.0934454554616142, 0.12043965914949673, 0.07880027070172857, 0.10870823812710351, 0.06263987959905992, 0.34095402195462954, 0.6049047183924745, 0.20918477215292408, 0.2636323963098449, 0.40261150871754925, 0.48560416344124335, 0.22329631154159446, 0.5482770375735176, 0.3335196004225526, 0.22822912872836199, 0.24591001108630084, 0.454247737584777, 0.43588047287105924, 0.4248474837272046, 0.5189856711563614, 0.40530384704508116, 0.5047027136477209, 0.2443872618312617, 0.1906882181533549, 0.26672062209483915, 0.23196205117107804, 0.2843705882571663, 0.3437180006944336, 0.29599705412311983, 0.31032256891374255, 0.24731762674375468, 0.20272897529044498, 0.2589058260738296, 0.1892380447367843, 0.21077547591951573, 0.2596866755813051, 0.20287609318289235, 0.23286876976844706, 0.3227095433146677, 0.177302680032708, 0.24754531711450434, 0.19858656196055358, 0.21018892148009238, 0.19215038114948357, 0.22456622061427822, 0.19386057639691, 0.1897327658585245, 0.16762192767018735, 0.22516063864470248, 0.18840294548074066, 0.1264579949416409, 0.17833906477869332, 0.15349417414726563, 0.9228949954335054, 0.20056066638136616, 0.9249283418142284, 0.14257572717748335, 0.9223039366228702, 0.9124947252193983, 0.7864716208943833, 0.21257225200496, 0.8585280599991928, 0.8535937042956937, 0.15405275899527437, 0.21189972499079535, 0.8489846146648248, 0.79250209117778, 0.7654975107959423, 0.1914445290908755, 0.25939033443521564, 0.21765351755057405, 0.29573043027884294, 0.2824896378776277, 0.21461131894771557, 0.22542026040182683, 0.24547203634038883, 0.26206754193843984, 0.08590002512144657, 0.1006553168936738, 0.09610392035760762, 0.0825681951549343, 0.10792106536612467, 0.06738134087865677, 0.08769517980536057, 0.11433873649642623, 0.10153961421667812]}, "mutation_prompt": null}
{"id": "85914277-5d83-4f89-886f-ee47feaae43f", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7, 0.7)  # Adjusted velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = (np.abs(global_best_score - scores) + np.std(pop, axis=0).mean()) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced adaptive mutation by adjusting mutation strength based on swarm diversity in MultiStrategyPSO.", "configspace": "", "generation": 38, "fitness": 0.35295302093211134, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "ec3b3c68-1307-4a50-9734-61a0aae93042", "metadata": {"aucs": [0.8390310955625615, 0.8543391785371779, 0.8683444478465161, 0.8282998307422129, 0.8162132601213529, 0.8324503392372246, 0.8446338366715803, 0.8791233408538403, 0.8701729127420321, 0.7139807720996623, 0.6829095341244753, 0.7186889548256494, 0.6843117352561618, 0.6717366382045589, 0.6872093504393226, 0.6894190405891968, 0.6870520511439062, 0.6325072070656999, 0.11484890103942125, 0.13253182353276804, 0.10883816001804392, 0.11420256483232116, 0.11708363991871062, 0.10055271591967463, 0.12210333636654902, 0.15684780006585297, 0.09220395632810763, 0.11586977928469822, 0.10850117725524555, 0.10990093687566116, 0.12093076991780816, 0.1566950990850583, 0.06269661228289825, 0.12018728155421687, 0.11468983373606756, 0.09516351251445321, 0.934795997440251, 0.9443843224913407, 0.942692523512236, 0.9448264812197176, 0.9309055153367393, 0.9272358041535639, 0.9503712430685558, 0.9241486596190219, 0.9345076753322253, 0.7404091360124979, 0.7389483439405553, 0.7001295011333789, 0.7119355566037333, 0.7362430919538706, 0.7318511001734495, 0.7663254843380419, 0.7398548624562995, 0.6696680104436867, 0.8625457845213735, 0.16999034097857912, 0.1549852192148422, 0.9290060420528403, 0.277627259274554, 0.2195111945857654, 0.13787159249948722, 0.5057466650736979, 0.24851934036148138, 0.2427248732163887, 0.2345858405915381, 0.33215229503038035, 0.26235071064478865, 0.10718011097822633, 0.13279479975789776, 0.272290527143618, 0.286093994681512, 0.2762787376418534, 0.1355503776694219, 0.2709167621260009, 0.13468631954543164, 0.3028041336375443, 0.2911449212844923, 0.28159672550046244, 0.27087478845553736, 0.2812231876296979, 0.20465305610413953, 0.018982539906321705, 0.05945778801346857, 0.021037591119789423, 0.08768928300584489, 0.06560949277934724, 0.05698359543316833, 0.07356932229687696, 0.007297726734447729, 0.0817797140578157, 0.06189380114908638, 0.16449129709709254, 0.2060238300547056, 0.1281293676144707, 0.03355336215538063, 0.09864349644882986, 0.11727705423163348, 0.09096805472803249, 0.03080233653012543, 0.20299936227872628, 0.15435977469193107, 0.1718958303911179, 0.1279547098411471, 0.0871763474170475, 0.1941568862526314, 0.09707759211390476, 0.17425547987746215, 0.10015036344542838, 0.13710142445633045, 0.17586986394746074, 0.10178460208242213, 0.35795973284063265, 0.11619212383090727, 0.18389777815672592, 0.2470597544876426, 0.1396146916048152, 0.1433856482927537, 0.5848356050278863, 0.5282256091355595, 0.5612485215857823, 0.5436198476316473, 0.5484686437579447, 0.5871195689149692, 0.5642053989890341, 0.56650606915438, 0.6249195581253753, 0.10835365314723455, 0.09140245116511292, 0.11921957499743929, 0.1216648583047738, 0.0718464114172368, 0.15832006399454457, 0.07944019677420455, 0.07668810228075185, 0.08833508555104108, 0.326520110192126, 0.48520271765724665, 0.26385393782447164, 0.5646063626311332, 0.4866622046919563, 0.3659441180567157, 0.22188962925471367, 0.38825916251722303, 0.6589484664528444, 0.3081227884543052, 0.20434095269172892, 0.4764402316865354, 0.4025929787846375, 0.3382869464713366, 0.36944672081982155, 0.19551331775754655, 0.38667722906620405, 0.26658836386888896, 0.22403327039568477, 0.3248305232334183, 0.2075082372760617, 0.37058115204236197, 0.36715405338159957, 0.3165528138695983, 0.17906300960083021, 0.24745966154258225, 0.2271295936751293, 0.24482679934764517, 0.2887782946028127, 0.2464001391388153, 0.33471808140573545, 0.2808538010951658, 0.21611819421198852, 0.22034713320565247, 0.2114904055645398, 0.19234628847911683, 0.19909951308655405, 0.2083805936033153, 0.19130939165530703, 0.20329179474147563, 0.18295348698015046, 0.18219045873716055, 0.22552561351434974, 0.24874118634028797, 0.2064021451548178, 0.1260287672276188, 0.17825919592537687, 0.1536621699940237, 0.9226957453122107, 0.20072427183793629, 0.915490599782044, 0.9160875427290912, 0.9081610231988083, 0.8990900467292302, 0.8931422402793467, 0.21308026882828013, 0.8547689188047842, 0.908429374362474, 0.15390667135254166, 0.2116158635083515, 0.8542603447214634, 0.8619622653477571, 0.8306767482325228, 0.23783584396543556, 0.22625102881480508, 0.24150995984674095, 0.2468207040378051, 0.26424995606253265, 0.23618620578720018, 0.2501819565929325, 0.23793706763739964, 0.24428220789572386, 0.0731880359098348, 0.08473301783608145, 0.07896125833000334, 0.08012721659660926, 0.08115084648642368, 0.10008811055645417, 0.10514687605869844, 0.0888218240457509, 0.09964529659831933]}, "mutation_prompt": null}
{"id": "6074a0ef-36a6-449e-8a54-b5367cda6034", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7, 0.7)  # Adjusted velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced velocity update by incorporating time-varying acceleration coefficients for improved balance between exploration and exploitation.", "configspace": "", "generation": 39, "fitness": 0.36008077003368055, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "ec3b3c68-1307-4a50-9734-61a0aae93042", "metadata": {"aucs": [0.8455387666770733, 0.8802334250821745, 0.8376802982400811, 0.8293923856069509, 0.8607094955920015, 0.8503061914399122, 0.8088140409135887, 0.86779632380193, 0.8402457889808145, 0.724408029822839, 0.7357715992752786, 0.7093605878534935, 0.6581404784890608, 0.6652505046897288, 0.7050116101957121, 0.6551663066708842, 0.6872095364314117, 0.6875590700522227, 0.08166959451673939, 0.1803566091822144, 0.10866637981539407, 0.14212446005013135, 0.11574204796774212, 0.1224517586366537, 0.09287140930505555, 0.7064537249276195, 0.15584435328059043, 0.09539358360449568, 0.14150394987464876, 0.09718637561270349, 0.11984459545157644, 0.09530579510115222, 0.11328911405439046, 0.11134811857385651, 0.11193861818556994, 0.12845170627894187, 0.9348103043415114, 0.9356250859080839, 0.9340526443880635, 0.9299391043466467, 0.9305521659737848, 0.9350831166824638, 0.9427271215843813, 0.9147538570892783, 0.9355932031240941, 0.7091112325545086, 0.7417860997134258, 0.6827847495988801, 0.7135704644386238, 0.7315368622456886, 0.7216717264175405, 0.7545590570916383, 0.7262006605635434, 0.6918810642357778, 0.8096370231454804, 0.22789986198129497, 0.17061948812261707, 0.8919368988551122, 0.3728129083671231, 0.2779175223935587, 0.2298309377247223, 0.17773645806625138, 0.2358539014507849, 0.3405964549049113, 0.13044366358822335, 0.2738608644765045, 0.257066912241241, 0.4469528227374008, 0.27145066814095686, 0.26854659621724686, 0.27586178216112534, 0.26998546730912176, 0.2530228084344306, 0.2667820790844162, 0.26940673141481986, 0.27692401091427354, 0.33253317502936375, 0.1350118594032037, 0.296035242261101, 0.261689071842778, 0.28233019384560565, 0.027781756724724382, 0.045204237476114906, 0.16254813733628037, 0.11035805038339408, 0.058998506511756976, 0.08594722953939216, 0.07641574966556997, 0.080255699537912, 0.23585438031467088, 0.11457714581714262, 0.05880330630696384, 0.1436134440112572, 0.09915956823161565, 0.04266126580248253, 0.042699780189420555, 0.19978930158856623, 0.07745576399227794, 0.10144213939039004, 0.1565945563144151, 0.2420513846993141, 0.3016272889282464, 0.09910948056565394, 0.0966310482577728, 0.1764669506207216, 0.13479470137064165, 0.13101089045263958, 0.0747528580769502, 0.23049370107888412, 0.11107161084419026, 0.08105518813053258, 0.0888033095165589, 0.14101551110819543, 0.2203269154195, 0.13416443280159673, 0.308275612586727, 0.13704693137539903, 0.5815942239423615, 0.5850133686254113, 0.5441392004863825, 0.5606071906109464, 0.5481325371342631, 0.5536680168529221, 0.5681796260334671, 0.5701152518615312, 0.6724725873679127, 0.10875578559788557, 0.0908253964194713, 0.13746947107422325, 0.11557191382970355, 0.07801023979718325, 0.08510263328656853, 0.09071077914237613, 0.1582347078619497, 0.12832803525794678, 0.6268775672225045, 0.4432376406812737, 0.2741990012035196, 0.22259402774701653, 0.17316892680878804, 0.19081764834391923, 0.26846002248572043, 0.223076135316582, 0.4729801666439818, 0.3835473026755136, 0.44248342939272967, 0.3703324257543843, 0.458015304536483, 0.3981753640687383, 0.4885313407448776, 0.2698948244283327, 0.46461471484037575, 0.26547538599960485, 0.2448103359178273, 0.27783981988498774, 0.22643908687439296, 0.3030098016145931, 0.20830028423621805, 0.2790093700545516, 0.20361937518708206, 0.29969456675548, 0.1902294844517003, 0.28299120787033794, 0.19667526961902448, 0.21253599493598552, 0.29617978025113856, 0.2697379022125549, 0.19673534834066653, 0.2138338032389706, 0.2301498377318093, 0.22932627832477326, 0.19691500903164882, 0.2156683586477749, 0.19406682038605805, 0.25199112320163786, 0.2251441802252817, 0.17662470604399694, 0.20688033310505327, 0.18528454680043205, 0.17841074391644018, 0.1845659841983298, 0.17851147871858952, 0.18646038917387664, 0.9202926390482074, 0.20028336232396948, 0.9088687304474817, 0.9130440405713486, 0.9192257531233328, 0.9297932674093053, 0.8562456881939259, 0.8545368285703835, 0.8277228014975906, 0.8720066162669242, 0.15416664926721024, 0.8880533842749273, 0.8838992565163064, 0.10441711517549046, 0.8009579206457575, 0.3359892536372535, 0.18857257573777375, 0.21915267223133517, 0.20811102668632986, 0.2542220313931359, 0.26911834757963127, 0.2507286863508451, 0.2508620514936809, 0.2512647687801841, 0.08503956013245861, 0.08728133636782809, 0.09891078473360526, 0.08487596932192887, 0.08823737257185926, 0.07963332745826168, 0.1083846276536844, 0.07276009695837093, 0.0888559762125013]}, "mutation_prompt": null}
{"id": "31031757-28d8-492c-84bf-7520c0c7e2db", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduced adaptive velocity clipping based on convergence to maintain diversity and prevent premature convergence.", "configspace": "", "generation": 40, "fitness": 0.3700812151229539, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "6074a0ef-36a6-449e-8a54-b5367cda6034", "metadata": {"aucs": [0.8406740422027519, 0.8617582375369951, 0.8510405008974489, 0.8524878048201878, 0.844529074688867, 0.8410221644757262, 0.8484793182861803, 0.8522297439740052, 0.8641978536084022, 0.7249007063258479, 0.7349207658103305, 0.6981320002360573, 0.6907358039188846, 0.688712505670146, 0.5688550699737205, 0.6456411603303203, 0.686425131997451, 0.6687249754330324, 0.07962047654138182, 0.1548514221649384, 0.06349746597589834, 0.12905223901562568, 0.1541512778312215, 0.18086162503909453, 0.09757371222708788, 0.15773938382042074, 0.15457624981458518, 0.12133688356933003, 0.12349613445704577, 0.10871789423281075, 0.10972204199633484, 0.12148743162677367, 0.11098567331501508, 0.09899196178293201, 0.12919166860779718, 0.15168006752154028, 0.9345880906888336, 0.9339759101538107, 0.9364186474361187, 0.9298813113334564, 0.9304273158200768, 0.9248579570460072, 0.9418440893296037, 0.9032923328764481, 0.9334110652860707, 0.6995765100590534, 0.6867746310148455, 0.6802988176056478, 0.7119038922816842, 0.7646557799532503, 0.7366816985112015, 0.7201789308772252, 0.7179806916402922, 0.7004193722224796, 0.9218789207379645, 0.22723559787651604, 0.22613387954007735, 0.9148711310298052, 0.2123832418856204, 0.2773276876196943, 0.8229685698364106, 0.2280271809352068, 0.8724676784613998, 0.33125167925821586, 0.13026541287580384, 0.280930644310449, 0.2963527359214567, 0.4270525624166779, 0.24760263129577764, 0.26922578861914914, 0.2708368487948811, 0.29799255292414284, 0.2502652316531506, 0.2657320983792564, 0.25049995315844786, 0.2738690687399853, 0.3105102077588624, 0.1342568977759473, 0.2889065631494936, 0.29517656522877567, 0.2939153760274247, 0.045830444453175745, 0.08785071091580443, 0.0597843409376404, 0.05702885947934533, 0.08609344400348706, 0.07305879583178398, 0.07589891583532682, 0.02537136703163667, 0.1790081816367165, 0.09915404240114423, 0.09889703079454326, 0.14427424760094387, 0.10689081345131435, 0.07362468671077316, 0.06791554011427237, 0.18000865078781314, 0.1608368240191851, 0.06810946980427723, 0.1498533946460826, 0.16877146235338947, 0.4056183676694186, 0.1080173238134281, 0.11270402734109408, 0.38197600384318287, 0.11933894189894345, 0.12842692125478317, 0.07683380106733662, 0.3900352251636128, 0.1641478465825117, 0.11703767946260324, 0.09843556580193003, 0.0976043365154795, 0.20667185560742718, 0.21287405465633524, 0.1753370657022546, 0.12805179895133356, 0.5544810617910687, 0.5874474465810855, 0.5568460796652501, 0.5745953850859977, 0.5759260884326315, 0.5601355690304701, 0.5798283293514745, 0.588243857675846, 0.5897915539187095, 0.10126893908503787, 0.11400779418238527, 0.12496817208975008, 0.11955627537270053, 0.08453998531958151, 0.07653127589099007, 0.12108059213695865, 0.11396616461568487, 0.07252234715272843, 0.2667126048908087, 0.34251962612969866, 0.5137709152183751, 0.22908941256832183, 0.1592963867102659, 0.4647061756651538, 0.26371791700042246, 0.3313900347626141, 0.4588564156305649, 0.46060956251459606, 0.48680119006582245, 0.5066591789239279, 0.4430160061451742, 0.44144128261748006, 0.4781910350706845, 0.48353576772591245, 0.43851538832496395, 0.5070591423556423, 0.26200051188150475, 0.2811653002868554, 0.21488075416142183, 0.34027076097768194, 0.23421752993893719, 0.3077109851131582, 0.20006494437414646, 0.4896757543649628, 0.21395876398187486, 0.238009539273077, 0.2319870865535758, 0.27443267902544277, 0.226358862679512, 0.18595653053178973, 0.24906496054079197, 0.27090952036108973, 0.2615079231896492, 0.19801859784678177, 0.1974946312391178, 0.21546427955889713, 0.18302746688870752, 0.2522153418835106, 0.21215173912302787, 0.18097563538077044, 0.175801290125838, 0.21269215593824042, 0.17097366530832192, 0.1845847086713378, 0.17849075389174052, 0.18647222034149125, 0.9136853913593306, 0.20030922497587467, 0.9030242834602213, 0.9151532250930016, 0.8877206259942152, 0.9128653629269479, 0.8912075968731102, 0.8585871778884231, 0.839053098954615, 0.8675503189045128, 0.1542457860770724, 0.9212702436744986, 0.8399472892877322, 0.10443322997804572, 0.7785987095343823, 0.22990616026976862, 0.19202640458108222, 0.27705292165353446, 0.22741104573676418, 0.2656468708013111, 0.22315404767757574, 0.3486632921100289, 0.21636116657756166, 0.2701947454715574, 0.0995732459561528, 0.08050168402618418, 0.15716770532260893, 0.08490673334866894, 0.09272168784961465, 0.1531914694358435, 0.07583326528860712, 0.09864337744578533, 0.10729896667816052]}, "mutation_prompt": null}
{"id": "aa3f74b8-cb77-4a11-b1d0-141b2620a4e6", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.985)  # Adjusted decay rate from 0.98 to 0.985\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced the mutation scaling factor decay rate for improved exploration in later phases.", "configspace": "", "generation": 41, "fitness": 0.3616812468476586, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "31031757-28d8-492c-84bf-7520c0c7e2db", "metadata": {"aucs": [0.8254171510171937, 0.8618869275165248, 0.847319309011682, 0.8254358816377905, 0.8798238897788881, 0.8523997031398741, 0.8346943377372971, 0.8640067288094584, 0.8582792829984496, 0.7024616614117516, 0.7376138024628718, 0.6971771014874881, 0.6712430779905635, 0.6912527513994986, 0.0634849268285207, 0.7099300565135993, 0.6687681352957437, 0.6533799304146717, 0.091083898710838, 0.14289849616511185, 0.14887657979728497, 0.12147676777684613, 0.10926538873603864, 0.15611033712730515, 0.10647710179173586, 0.18344841714703775, 0.13960495515213822, 0.11420503257759806, 0.14137586051070306, 0.10913222369581776, 0.09282706235477667, 0.11589539923683934, 0.107112802387894, 0.09897605065892434, 0.13984631825780125, 0.10607693733300783, 0.9346124216968916, 0.9338148708686232, 0.9364218077738401, 0.929811794409693, 0.9304413977406257, 0.9240644156108088, 0.9420885937400412, 0.9031440235482093, 0.933420266789112, 0.7157865379678562, 0.7043631074334535, 0.675229195719583, 0.7164260144245991, 0.7207035846607037, 0.741407228107316, 0.7455810632062734, 0.6917198122052721, 0.7132154666051488, 0.9218789207379645, 0.3761182169709124, 0.22529865777376157, 0.9148711310298052, 0.3759435077261073, 0.27628788540767524, 0.22595901962703935, 0.3779844483313395, 0.2350934715317079, 0.3408730943810855, 0.13048853886705858, 0.2783165705867149, 0.2789624257398232, 0.3294896045897848, 0.2552723886250712, 0.28295091824078966, 0.26330216337276746, 0.26099482098061666, 0.24776599986197634, 0.2655186712108768, 0.2543219863580062, 0.27350102890630346, 0.31087361076791475, 0.13479122742485217, 0.2900995796768946, 0.28942716992537165, 0.2970217588799413, 0.06067901682662524, 0.03944331021391967, 0.07441676593138746, 0.09079111283632157, 0.015868021575737523, 0.05703127309870071, 0.08441939660241948, 0.025466158186517873, 0.1232219377859275, 0.1133785470367149, 0.10516939124805891, 0.12873197258963787, 0.12081539897620441, 0.03199326255819812, 0.051323994420079955, 0.19390534854813424, 0.11845185891083365, 0.11487326891577776, 0.1508707069780466, 0.28086833144475143, 0.35678380133261856, 0.11335877312904286, 0.10221539256793277, 0.3928160478861852, 0.12101191148511825, 0.14369490759134662, 0.06981325454903797, 0.18746831547020715, 0.14312017509920827, 0.15166259295006423, 0.10536173972429175, 0.18790899740160405, 0.19276112542134582, 0.07933096223056402, 0.19192742802729412, 0.13312572342500717, 0.5371408183806652, 0.5408018472372057, 0.5548940919534686, 0.5732426484108382, 0.6066468625673289, 0.5692256942947663, 0.5866839103780579, 0.5810902881139883, 0.5698703353499674, 0.09824525484447555, 0.11379616730259934, 0.10287092213006521, 0.13033046309008134, 0.09444549168711747, 0.0897394703161517, 0.11504293969960089, 0.11397621266874958, 0.1195012360024964, 0.5136549367606955, 0.39582521590036035, 0.44954130475655296, 0.18895913524761576, 0.173644991169563, 0.4296390285611904, 0.28094815139814533, 0.1967146055580502, 0.7039404945665009, 0.4484710306914681, 0.4339130851159866, 0.31587079839124343, 0.4623765778899793, 0.2345760227541186, 0.4222479893387976, 0.342799376245394, 0.3125503460444157, 0.6053988599102835, 0.265939440965276, 0.3215635119272323, 0.2230508080978646, 0.3249113756658034, 0.3015989892827905, 0.39607394879468605, 0.21871992145151675, 0.269819653478225, 0.20323730757901204, 0.22385998748213265, 0.23243308945526064, 0.28696274583901993, 0.1961747056215314, 0.22986159745683477, 0.2038106025068529, 0.2860123031971722, 0.25375814781272954, 0.23418085290341528, 0.19754695027921287, 0.2506517812265956, 0.18323854428028363, 0.2524751295608745, 0.25007677108774895, 0.1918088615716047, 0.1758056032934897, 0.20692400312855375, 0.18181993167560673, 0.18441292252085473, 0.17841324278250792, 0.18642969009807075, 0.9074634427108996, 0.2003008810299579, 0.9061632680156713, 0.9075071911205048, 0.9004737483231962, 0.9101800844226153, 0.8899947452295648, 0.802382675452918, 0.8230410318963214, 0.8598912952636512, 0.1544242992366075, 0.889983409486106, 0.8788417714694722, 0.10443359774122618, 0.7942428378675105, 0.20210149491721818, 0.4120227536359369, 0.1888390726080934, 0.3126270221846862, 0.29873837725559793, 0.3254509459651935, 0.2652482424831978, 0.24176185107449588, 0.24375839947893785, 0.11369107090101538, 0.1050171592087763, 0.12980015862420857, 0.08640389854565489, 0.08685519377663953, 0.119306884904393, 0.10365818505257629, 0.10908353399417281, 0.10026884158186988]}, "mutation_prompt": null}
{"id": "0c73bc3b-eb4e-4cd1-8e83-8c75ebbb784d", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97  # Changed decay rate from 0.95 to 0.97\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjusted the mutation probability decay rate to enhance exploration and maintain diversity for longer during optimization.", "configspace": "", "generation": 42, "fitness": 0.3602201108852652, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "31031757-28d8-492c-84bf-7520c0c7e2db", "metadata": {"aucs": [0.8432960238669238, 0.8617582375369951, 0.8510405008974489, 0.8574089315213286, 0.8331538351190763, 0.8410221644757262, 0.8598370767889336, 0.8441504029230712, 0.8641978536084022, 0.6776399063868757, 0.7280372443887062, 0.6468349432966536, 0.6874049898638923, 0.6814018931564345, 0.5688550699737205, 0.6934673694843999, 0.6459900117011865, 0.6636676488436407, 0.09390401819632699, 0.15485166495862757, 0.06352968147348548, 0.15128783918950173, 0.13600261082919174, 0.17654617949975238, 0.08789714775668578, 0.15773938382042074, 0.15465102750710846, 0.11288007025553382, 0.12331582613274317, 0.10830048164453288, 0.09320766451938234, 0.10928315576591807, 0.1105099880793563, 0.10399038228563406, 0.12919166860779718, 0.15539808571721492, 0.9327266423030293, 0.9339759101538107, 0.9364186474361187, 0.9323961008133496, 0.9304273158200768, 0.9248579570460072, 0.9424883779503119, 0.9032923328764481, 0.9334110652860707, 0.7225108119298629, 0.6975177140774499, 0.6988553727977935, 0.7275096416352789, 0.7299900712146561, 0.7366816985112015, 0.7147390439843715, 0.6938524181308828, 0.7004193722224796, 0.39152677768566213, 0.22723559787651604, 0.22606021012205668, 0.3895319366644473, 0.21907358712996472, 0.2773276876196943, 0.17680796820483413, 0.2331776576970479, 0.8724676784613998, 0.2955924248325893, 0.13027597255167023, 0.2917799019682218, 0.26969531657587076, 0.4127754246759999, 0.24760263129577764, 0.24518976793633362, 0.3030770368870255, 0.29799255292414284, 0.256661119672297, 0.24628677155667722, 0.25049995315844786, 0.2698073457386204, 0.32029806834658303, 0.1342568977759473, 0.29653775682427996, 0.29517656522877567, 0.2853475572106169, 0.05878800694279851, 0.042106864030351576, 0.0597843409376404, 0.031741649461541566, 0.12486208561604561, 0.07305879583178398, 0.08718777542614553, 0.016614667753372503, 0.1790081816367165, 0.0900103297389887, 0.07451308917711597, 0.14427424760094387, 0.10625398847073741, 0.0710284963035861, 0.054474254785385146, 0.2170194082963678, 0.14523931929539735, 0.08260550038412606, 0.21988479533234118, 0.16877146235338947, 0.4056183676694186, 0.11295962482007438, 0.11272688210071047, 0.38197600384318287, 0.14059024676768384, 0.12782371419652394, 0.07683380106733662, 0.27837652471222096, 0.1640882083246108, 0.11703767946260324, 0.12336526284396165, 0.09755663755539734, 0.20667185560742718, 0.08196585849512139, 0.2546775296859951, 0.12616338683146155, 0.535314728056177, 0.6019720251409246, 0.5477070727356699, 0.5730718476513017, 0.575189850034067, 0.5601355690304701, 0.5677668629911802, 0.588243857675846, 0.5897915539187095, 0.12135457089136703, 0.13010739141636518, 0.11371894662087867, 0.15701438163217685, 0.11349489858763662, 0.09074145486688834, 0.11600837161998356, 0.10339630773342467, 0.09441594243153117, 0.2240207272350373, 0.3250584226115467, 0.535067557996441, 0.22518696439181396, 0.1590754041486071, 0.3888493412623033, 0.2734540153436946, 0.5963420472352017, 0.4588564156305649, 0.3513622594175162, 0.3761301467434187, 0.5066591789239279, 0.4864548881076537, 0.48133360466939057, 0.40940840896621544, 0.4107526066205297, 0.27521419284857884, 0.28754562167836106, 0.24264040922451058, 0.3598908982220689, 0.21488075416142183, 0.3271468932505457, 0.4079860019748811, 0.26686668519265977, 0.22019314620994868, 0.4896757543649628, 0.22169184376054663, 0.2501315924071419, 0.24164751619698044, 0.25084942418623857, 0.25714013597267416, 0.23743958285461964, 0.2549390095786127, 0.2609506851435661, 0.27500836026268694, 0.23899459173081394, 0.19776645903451984, 0.19427049252319195, 0.1828522946432085, 0.2117209872504543, 0.21221446154357737, 0.18097563538077044, 0.17934783051288994, 0.21269108649023427, 0.17097366530832192, 0.18446779021564919, 0.17858909266864198, 0.18646907675140234, 0.922256993849623, 0.20030917024667094, 0.9101336726430369, 0.9153989706513237, 0.8964131096940245, 0.9199630935938563, 0.8710738501014204, 0.8465102950581824, 0.859833923781242, 0.838296248501055, 0.15424562799184083, 0.9256572730205034, 0.8560278025103295, 0.10443322938006527, 0.7785987095343823, 0.19115313316521965, 0.21062630508915348, 0.21385985952882636, 0.23847216690637274, 0.1961201441460907, 0.26444335185260837, 0.40165436946945443, 0.2241903927485691, 0.22910328131641766, 0.1199576923983483, 0.08336966391676126, 0.15207651547712087, 0.09009768043724764, 0.09913900814735155, 0.1509929196357238, 0.10220557818247011, 0.09203985057217356, 0.10681798954483679]}, "mutation_prompt": null}
{"id": "7ef641cc-4049-49e8-9582-0b3814f20fb0", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95  # Changed decay rate from 0.98 to 0.95\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.97)  # Modified decay rate to 0.97 for better dynamics\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced adaptive mutation scale dynamics to improve exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": 0.3600780620813253, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "31031757-28d8-492c-84bf-7520c0c7e2db", "metadata": {"aucs": [0.8358281571040387, 0.8679167478890013, 0.8362024358456911, 0.8347881741393106, 0.8495086995597726, 0.846596851891685, 0.8493369390242949, 0.8557895027260205, 0.8508834857045622, 0.6960581614523558, 0.7210584605847242, 0.7452693986868701, 0.6997943331620291, 0.6781123147156366, 0.6543317153616814, 0.667713419679512, 0.6505897556230942, 0.6789931046125648, 0.08748048480355397, 0.15585435937867698, 0.12801961285147756, 0.11251929140551342, 0.15475699954076805, 0.1087803294128904, 0.11956441924505745, 0.15452476592794906, 0.1811921673591027, 0.11974687942759321, 0.12116396328825174, 0.10799620506883623, 0.11007402610312078, 0.11997565687182199, 0.09281747429600706, 0.09911930344692321, 0.13883421500845017, 0.1402777616904144, 0.9345994004072825, 0.9340379527944693, 0.9363328276561157, 0.9298944776692853, 0.9305276449867442, 0.9251871760162669, 0.94172473802468, 0.8998831202454959, 0.9331313468545172, 0.7076747274310013, 0.7317253775118822, 0.6726033065410935, 0.7356284399942963, 0.7110865959214991, 0.7481066976142383, 0.7210323320305361, 0.6968725831676528, 0.7120636358377697, 0.39739384873884853, 0.3647983289285176, 0.17056952246800938, 0.9148711310298052, 0.37304801477584737, 0.2773933687330846, 0.23398376061317816, 0.23515473310197854, 0.2353585787099174, 0.30824207227207423, 0.12894877348252398, 0.28504481769700607, 0.27002644657730446, 0.3505133164410268, 0.2715300803360152, 0.2589121952776141, 0.31031551286730474, 0.254520375173941, 0.25164484092268247, 0.259013716868551, 0.24926865695656542, 0.27820292873240726, 0.3317743929034598, 0.13505893528636514, 0.28348796651192776, 0.259824183503058, 0.29949118030697675, 9.999999999998899e-05, 0.17845861421020437, 0.12489678621291511, 0.0755238476851946, 0.10111531863495771, 0.07379408551884026, 0.09812106698314726, 0.014027824264265631, 0.08165903271716068, 0.10156925520351834, 0.06059686865413916, 0.15679984712633255, 0.11868110257181796, 0.03743786835911056, 0.05271542566458287, 0.2099047447119492, 0.11158427854121478, 0.12830206346866213, 0.14292398431413056, 0.20701597640130076, 0.35745404540713666, 0.10828390789596565, 0.09431321849926921, 0.24796912462690834, 0.12086671611566457, 0.13275173593674827, 0.08350031544318115, 0.2714631107250902, 0.12537261794884635, 0.07124741696761194, 0.11567703590024958, 0.06787668038101513, 0.20780906198168858, 0.08667538544647702, 0.2814577466626299, 0.1151274582847358, 0.5179637492141785, 0.5227975422049747, 0.5301298259129696, 0.5372183359260272, 0.5915968585047175, 0.5449509742738957, 0.5974801889681511, 0.5768091456031267, 0.5723246492548791, 0.10935238143189485, 0.11081460636038942, 0.15252803108024504, 0.18088387705209097, 0.08793629714723683, 0.07613877137695002, 0.12201509348462847, 0.10257477304493001, 0.13876727411912815, 0.47011281172277497, 0.5689004320331631, 0.44454772865534564, 0.19637999622784696, 0.17369704279618758, 0.3279928451397004, 0.27604795410113314, 0.21202222698050344, 0.5772427032902432, 0.5342524383026501, 0.46484730080452463, 0.3606334993589969, 0.427033027918326, 0.47816948234720724, 0.4352277302455886, 0.4620375264407728, 0.5687352990769869, 0.24434984397828907, 0.25183961883381667, 0.2891283315037513, 0.24384412351316664, 0.29131919084014735, 0.3223527234674669, 0.3666907342911333, 0.1831355319387824, 0.26558886253298264, 0.22113814117060182, 0.2731306668250272, 0.24817282776208638, 0.2529845470511223, 0.20584374844999087, 0.22473179741523763, 0.24217005910450173, 0.2805712417163835, 0.22243374727397835, 0.2249993648683446, 0.19760452355533997, 0.2160077025818925, 0.1978155964997813, 0.2522439274869902, 0.21088740673423823, 0.19548197171083947, 0.18087041016913286, 0.2226940252734948, 0.17422620383730714, 0.18457030892127868, 0.17852247176462643, 0.18648770529672787, 0.9044716250754201, 0.20030809512092052, 0.9140227070888214, 0.9140763945304153, 0.8880671303321451, 0.917422498555307, 0.8805010140013679, 0.8067302483415323, 0.8037571199327209, 0.868439562838597, 0.15404267636450697, 0.9196141261546346, 0.8678246554708756, 0.10438990881652155, 0.8061961737692663, 0.23275143826324207, 0.17727317578046986, 0.2254374828922624, 0.25220682339342004, 0.2995388766004464, 0.24099436913803984, 0.2711121166536262, 0.26573264911229943, 0.2225142511261995, 0.09950817198564232, 0.10312651005395368, 0.11715949241062373, 0.09690339811974114, 0.09046776994664851, 0.10481012769102782, 0.08159251759950259, 0.10627952770441917, 0.1125417956541016]}, "mutation_prompt": null}
{"id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved adaptive mutation by linking mutation probability decay to budget ratio for enhanced exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.37049445545846926, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "31031757-28d8-492c-84bf-7520c0c7e2db", "metadata": {"aucs": [0.8565307570407155, 0.8617582375369951, 0.8510405008974489, 0.8540322277854197, 0.844529074688867, 0.8410221644757262, 0.8484793182861803, 0.8623225519658878, 0.8641978536084022, 0.7249007063258479, 0.7345758959112277, 0.7038259974839052, 0.6907358039188846, 0.6730992782900473, 0.5688550699737205, 0.6456411603303203, 0.632941918669104, 0.648682169520959, 0.08673772666438706, 0.15583772248630534, 0.06350730926424653, 0.12075444172466232, 0.1405503340537705, 0.1570160712312385, 0.09146745839527426, 0.15773938382042074, 0.1308500012446402, 0.09894712320681753, 0.12372145218792907, 0.10902056129726512, 0.11025491601036197, 0.12167332315822732, 0.11084955199897717, 0.09899196178293201, 0.12919166860779718, 0.1544189296312718, 0.9345880906888336, 0.9339759101538107, 0.9364186474361187, 0.9298813113334564, 0.9304273158200768, 0.9272043430545186, 0.9418440893296037, 0.9032923328764481, 0.9334110652860707, 0.6995765100590534, 0.683360671949222, 0.7001963789471979, 0.7119038922816842, 0.7220101656220428, 0.7366816985112015, 0.7201789308772252, 0.7179806916402922, 0.7004193722224796, 0.9218789207379645, 0.8580756719516889, 0.22608210792150762, 0.9148711310298052, 0.2123832418856204, 0.2773276876196943, 0.8229685698364106, 0.7285965710724815, 0.8724676784613998, 0.33125167925821586, 0.1298161848396605, 0.26961466763838215, 0.2963527359214567, 0.4270525624166779, 0.26446337007009046, 0.27446981645975066, 0.2729551635111628, 0.26237575683632863, 0.26473483565082523, 0.2694895651406536, 0.25049995315844786, 0.2738690687399853, 0.3105102077588624, 0.1342568977759473, 0.2889065631494936, 0.29517656522877567, 0.2939153760274247, 0.045830444453175745, 0.08785071091580443, 0.096180400752501, 0.05702885947934533, 0.08609344400348706, 0.07305879583178398, 0.07589891583532682, 0.024771220441833997, 0.1790081816367165, 0.09915404240114423, 0.07602953685806568, 0.14427424760094387, 0.10689081345131435, 0.07202368244179502, 0.05372883524667271, 0.18000865078781314, 0.1608368240191851, 0.10523509358871053, 0.1498533946460826, 0.16877146235338947, 0.4056183676694186, 0.1080173238134281, 0.11270402734109408, 0.38197600384318287, 0.11933894189894345, 0.12842692125478317, 0.07683380106733662, 0.3900352251636128, 0.1641478465825117, 0.11703767946260324, 0.09843556580193003, 0.0976043365154795, 0.20667185560742718, 0.10662189722085114, 0.20151182276945334, 0.14198914663705964, 0.6147199820626874, 0.54745215510277, 0.544570318605345, 0.5681310973108991, 0.5658642997843849, 0.5484683741864111, 0.5798283293514745, 0.588243857675846, 0.5897915539187095, 0.12731277094224192, 0.11388776858013494, 0.07628777447797142, 0.11955627537270053, 0.08453998531958151, 0.07651937514113671, 0.12157259212665905, 0.1143413855794968, 0.09672076928855533, 0.2667126048908087, 0.34251962612969866, 0.37866648419529114, 0.22908941256832183, 0.1592963867102659, 0.3300521776826114, 0.26484805284590485, 0.3313900347626141, 0.4588564156305649, 0.3499205753448317, 0.5186050602165427, 0.5066591789239279, 0.4430160061451742, 0.44144128261748006, 0.3712625582512682, 0.48353576772591245, 0.28470562727664206, 0.29563667934860327, 0.26200051188150475, 0.2726271089487866, 0.2199913866547104, 0.4068218771565435, 0.23922260543460083, 0.28565121715986275, 0.1790679369259668, 0.2590247847283996, 0.22371177401167708, 0.238009539273077, 0.23703002890158442, 0.25032701564587134, 0.22983951279533954, 0.18595653053178973, 0.25675594366878096, 0.2705156970189849, 0.25515208998999284, 0.23325576094003686, 0.1974946312391178, 0.21547469240221462, 0.17909189579333873, 0.2522153418835106, 0.21215913477824255, 0.18097563538077044, 0.175801290125838, 0.1916385951423748, 0.17126257200096118, 0.18463400314696732, 0.17849293264349997, 0.18648363407141688, 0.9136853913593306, 0.20030922497587467, 0.9032844165336555, 0.9151532250930016, 0.8984053350953086, 0.9224131667404529, 0.8912075968731102, 0.8686160348582954, 0.8484673534481175, 0.8675503189045128, 0.1542457860770724, 0.9242161536139321, 0.8399472892877322, 0.10443322997804572, 0.7785987095343823, 0.22990616026976862, 0.19202640458108222, 0.3683976152094266, 0.22741104573676418, 0.3049273794432944, 0.23464476101299692, 0.3486632921100289, 0.21705535855258218, 0.2705141725511496, 0.11175104045151651, 0.08393410511512356, 0.1510722956912146, 0.08420302046387407, 0.0963440039218807, 0.15280965838498817, 0.08396592682840309, 0.09098455159411245, 0.10703716731066582]}, "mutation_prompt": null}
{"id": "526debe0-afd4-4b81-b8ff-b567a4e37311", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Increase the mutation probability slightly for better exploration.", "configspace": "", "generation": 45, "fitness": 0.3625894929665447, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8483398574932853, 0.8617582375369951, 0.8510405008974489, 0.8574089315213286, 0.844529074688867, 0.8410221644757262, 0.8466344686816957, 0.8623225519658878, 0.8641978536084022, 0.6776399063868757, 0.7345758959112277, 0.7038259974839052, 0.6874049898638923, 0.6730992782900473, 0.5688550699737205, 0.6934673694843999, 0.632941918669104, 0.648682169520959, 0.09335796977017796, 0.15583772248630534, 0.06350730926424653, 0.11538797230562925, 0.1405503340537705, 0.1570160712312385, 0.09181387570327004, 0.15773938382042074, 0.15224349150238192, 0.11288007025553382, 0.12372145218792907, 0.10902056129726512, 0.09320766451938234, 0.12167332315822732, 0.11084955199897717, 0.10399038228563406, 0.12919166860779718, 0.1544189296312718, 0.9327266423030293, 0.9339759101538107, 0.9364186474361187, 0.9323961008133496, 0.9304273158200768, 0.9272703426169294, 0.9424883779503119, 0.9032923328764481, 0.9334110652860707, 0.7275418209226429, 0.683360671949222, 0.7001963789471979, 0.7275096416352789, 0.7220101656220428, 0.7366816985112015, 0.7147390439843715, 0.7179806916402922, 0.7004193722224796, 0.8973584761479048, 0.22723559787651604, 0.22608210792150762, 0.3895319366644473, 0.2123832418856204, 0.2773276876196943, 0.17680796820483413, 0.7285965710724815, 0.8724676784613998, 0.2955924248325893, 0.13026541287580384, 0.26961466763838215, 0.26969531657587076, 0.4270525624166779, 0.26446337007009046, 0.27443497449740795, 0.27001242482752197, 0.26237575683632863, 0.24357061379718192, 0.2694895651406536, 0.25049995315844786, 0.2698073457386204, 0.3105102077588624, 0.1342568977759473, 0.29653775682427996, 0.29517656522877567, 0.2939153760274247, 0.05878800694279851, 0.08067952468905337, 0.0597843409376404, 0.031741649461541566, 0.08609344400348706, 0.07305879583178398, 0.08718777542614553, 0.024771220441833997, 0.1790081816367165, 0.0900103297389887, 0.07602953685806568, 0.14427424760094387, 0.10625398847073741, 0.07202368244179502, 0.05372883524667271, 0.2170194082963678, 0.1608368240191851, 0.06810946980427723, 0.2281675770382977, 0.16877146235338947, 0.4056183676694186, 0.11319240233834571, 0.11270402734109408, 0.38197600384318287, 0.14059024676768384, 0.12842692125478317, 0.07683380106733662, 0.19652996703321712, 0.1641478465825117, 0.11703767946260324, 0.060889290893984205, 0.0976043365154795, 0.20667185560742718, 0.08210379194606576, 0.20151182276945334, 0.13240743170153657, 0.517755387199001, 0.54745215510277, 0.544570318605345, 0.5988628174665673, 0.5759260884326315, 0.6346538369743653, 0.5889920778220561, 0.588243857675846, 0.5897915539187095, 0.12081253978725381, 0.11388776858013494, 0.09982137877615482, 0.18205463643896014, 0.11365258094753994, 0.07651937514113671, 0.08835398090625823, 0.1143413855794968, 0.09672076928855533, 0.20748763109628232, 0.3285914820307012, 0.37866648419529114, 0.21294695405315922, 0.1592963867102659, 0.3300521776826114, 0.26879110524547933, 0.4935738998861555, 0.4588564156305649, 0.4293865006822034, 0.5186050602165427, 0.5066591789239279, 0.3594543623505201, 0.44144128261748006, 0.3712625582512682, 0.5527744016389116, 0.28470562727664206, 0.29563667934860327, 0.2554619947039902, 0.2726271089487866, 0.2199913866547104, 0.35497431616220865, 0.23922260543460083, 0.28565121715986275, 0.17312549556129309, 0.37748392017919663, 0.22371177401167708, 0.25521719428688994, 0.23703002890158442, 0.25032701564587134, 0.2803811013822317, 0.24339728427273755, 0.25675594366878096, 0.2833325327985008, 0.25515208998999284, 0.23325576094003686, 0.19776645903451984, 0.21547469240221462, 0.17909189579333873, 0.2117209872504543, 0.21215913477824255, 0.18097563538077044, 0.187880388731251, 0.21269215593824042, 0.17126257200096118, 0.18447165835327506, 0.1785819375898967, 0.18648363407141688, 0.922256993849623, 0.20030922497587467, 0.9032844165336555, 0.9153989706513237, 0.8984053350953086, 0.9171881661536753, 0.8710738501014204, 0.8686160348582954, 0.8484673534481175, 0.8573769016741087, 0.1542457860770724, 0.9242161536139321, 0.8560278025103295, 0.10443322997804572, 0.7785987095343823, 0.23284765781992822, 0.19202640458108222, 0.3683976152094266, 0.24524324666410602, 0.3049273794432944, 0.23464476101299692, 0.2548186294458702, 0.21705535855258218, 0.2705141725511496, 0.09969527138380363, 0.08393410511512356, 0.1510722956912146, 0.08867121273524281, 0.0963440039218807, 0.15280965838498817, 0.09550069866088706, 0.09098455159411245, 0.10703716731066582]}, "mutation_prompt": null}
{"id": "c6c872c4-297d-4661-8711-3a529927c4e3", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.8 + 0.3 * eval_ratio, 0.8 - 0.3 * eval_ratio)  # Refined velocity clipping boundary\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Refined velocity clipping boundary adaptation to enhance convergence by slightly adjusting the adaptation formula.", "configspace": "", "generation": 46, "fitness": 0.3540818835958217, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8747838571267457, 0.8707545928687439, 0.8627645242919033, 0.8392249028076738, 0.8445718972605447, 0.8318102679886572, 0.8621750983252005, 0.8373776054684748, 0.8317877669569558, 0.694102218277401, 0.7129568414937365, 0.7165224649783225, 0.6598832820919288, 0.653846682728395, 0.648496110541717, 0.6597606180750977, 0.647535174353352, 0.6462782695632947, 0.10900088498916616, 0.12605186966065574, 0.11550641596766309, 0.15378612547403958, 0.14325657796491287, 0.13688442359053166, 0.07406578754456516, 0.15682165956492533, 0.18104989742380417, 0.12220721852322913, 0.1133924141735515, 0.10677275050596913, 0.1445725839940405, 0.12163221297678284, 0.09686468380074709, 0.11539287890404082, 0.11596490930780834, 0.11781867810287128, 0.9401483148080937, 0.9427034115211185, 0.9459084549112614, 0.935828054858484, 0.9358446236827102, 0.9432419046867793, 0.9437695725104419, 0.9266565578563813, 0.9423378768979536, 0.7137881476535335, 0.7061715451858679, 0.7097501102780828, 0.7504727114894979, 0.7221555280503096, 0.7056681130876783, 0.7206602315584009, 0.706668856465261, 0.7129438716458503, 0.3906679150822816, 0.16955160868290897, 0.38035938842959927, 0.8914983660466471, 0.19263876294519133, 0.21276969622691855, 0.8401844054425354, 0.17839586618192138, 0.2360899356532392, 0.22169439174723715, 0.23922729287764655, 0.12967303536167418, 0.26763542668949536, 0.13450971738324202, 0.26845070854128184, 0.30562359447025234, 0.2854868079580114, 0.26965543867207376, 0.2532549266715408, 0.25908949245429813, 0.2602690866027306, 0.2999320872293959, 0.30730422671050583, 0.13076546217940688, 0.30694256314989243, 0.2808934435387781, 0.28161534091109075, 0.08843794917045511, 0.13990199698591677, 0.050100133481899456, 0.09172329459632989, 0.12063686104957849, 0.13613896880695886, 0.04440157591584104, 0.010763838983969487, 0.12717849432011152, 0.20284189390664786, 0.07794588410682557, 0.21342286110503417, 0.05975976609508338, 0.049046595629457235, 0.14398486005967648, 0.11235125770854015, 0.13833284219555864, 0.10479023255279496, 0.10611005804378348, 0.2429675131478365, 0.2221546586897758, 0.085617403268061, 0.0897054942185177, 0.2649574819780348, 0.1709434813150308, 0.2807553038530669, 0.10059799948644177, 0.1786387123293267, 0.1351191751538512, 0.11063464084514618, 0.21331884509310972, 0.30939256363702283, 0.10677152585746552, 0.0833999917978352, 0.2227665610475945, 0.15653614359030887, 0.5600287950392244, 0.5398268471823298, 0.5433607897298132, 0.5974864031516047, 0.5918321083585297, 0.546322895125388, 0.5629325241830787, 0.6046027918432428, 0.5865366156687386, 0.12718518504428955, 0.0780647079670509, 0.10465897236548405, 0.17193976051755266, 0.09064107221654794, 0.13935844124977304, 0.12070394163869569, 0.14163452062713766, 0.1427260503265757, 0.6292228587281835, 0.24873047046172692, 0.2098651012072602, 0.6581207543431578, 0.5433542005461762, 0.3012654228645695, 0.31769030634545803, 0.4320785690650859, 0.21637614566896113, 0.424272634299823, 0.5757937293462199, 0.5311636727367695, 0.3353859951001691, 0.39546474094950457, 0.44423240491311844, 0.24483331317342816, 0.44896277462694467, 0.40381351062697934, 0.23033403386178064, 0.3039977565265475, 0.22309142181138364, 0.40609841572455585, 0.23531269726143733, 0.3623308083049064, 0.2514378087190732, 0.2604994384642977, 0.25979433087131065, 0.27716267355318547, 0.29887489747207097, 0.24656413219685913, 0.20916519800128175, 0.23372468571101868, 0.1999874927714006, 0.2502813598852446, 0.22762916758571405, 0.26210131286840277, 0.1986161789557066, 0.209209008024413, 0.19805796707958911, 0.2080442556132447, 0.19792737490346968, 0.19900001919003563, 0.1888281186956864, 0.19793318204893195, 0.19147830689644374, 0.126265799832894, 0.1785715785296319, 0.15345048502364844, 0.921029916909095, 0.2001681067184009, 0.9113152443484287, 0.1425271430895697, 0.9210127900832757, 0.9131526734147416, 0.9112086966558605, 0.825627946629768, 0.12683640465390256, 0.2933575264446857, 0.154767922284061, 0.8791187836743694, 0.8440263158060451, 0.10448806278056277, 0.7791208214938747, 0.2716305291168364, 0.21729552602052826, 0.1897685463199782, 0.29277679157921166, 0.23935433072536905, 0.31043500567373783, 0.2459428089656559, 0.2669529979045334, 0.24036208181209462, 0.09020169003498724, 0.11159843905095645, 0.07187004855030843, 0.09430771506810365, 0.10673246421975457, 0.10293451555639954, 0.10498836220126306, 0.07204313073347834, 0.091776701877059]}, "mutation_prompt": null}
{"id": "2de5fc33-df2f-4b94-929a-43bbc7de4600", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 5  # Increased local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Refined dynamic neighborhood topology by increasing local topology size for enhanced information exchange.", "configspace": "", "generation": 47, "fitness": 0.3576352678205516, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8486274396721474, 0.8721407320923338, 0.8759457936012504, 0.8483635332539217, 0.8406509923574194, 0.8407598534772063, 0.8234268753137344, 0.8453424286875312, 0.8462620160066006, 0.688913602591732, 0.7069530197410379, 0.6634089914759088, 0.7358821065308571, 0.6736515255501293, 0.6688985813418431, 0.6633656890587363, 0.6694202151970752, 0.6763769454756641, 0.10236905232107785, 0.14182734285570164, 0.05794508384410113, 0.11524190618451924, 0.12398042726646563, 0.1431888192761307, 0.077284601279476, 0.1161650846845752, 0.11337460598613491, 0.11511032519326803, 0.09388822892910542, 0.115633936428858, 0.11013082526890572, 0.10695234583611712, 0.08600566083145145, 0.10916771549629689, 0.10815428974944608, 0.12124944115339498, 0.9346527572635708, 0.9344759475453859, 0.942174702620965, 0.9304906152570611, 0.9334710496930027, 0.9319307086049816, 0.9425076334068396, 0.9171673729324539, 0.9372210169993744, 0.7267335820809091, 0.7241663993374798, 0.7315020716266947, 0.6951563874983844, 0.7353076247392221, 0.7257139436209284, 0.7438311213742116, 0.7343093599109813, 0.6839025895992198, 0.8174651780655845, 0.22780017754595105, 0.2251497317258303, 0.3827288786518823, 0.2116440858968902, 0.21228156405621668, 0.2242596645759799, 0.17668363875402626, 0.39545443667123636, 0.2783008763009599, 0.12817452339573643, 0.2921375096978108, 0.29932403963781873, 0.28331913761131244, 0.43833233046257214, 0.3085858987548781, 0.3374007530102826, 0.29431827754314643, 0.26986740114984786, 0.2088963977011804, 0.1313507448769402, 0.13379082728219205, 0.28795119968964566, 0.293610137452045, 0.29297668369127816, 0.28283344564044277, 0.27999328460934525, 0.05916057474220138, 0.14412527977719125, 0.013894406626512312, 0.08294001795261663, 9.999999999998899e-05, 9.999999999998899e-05, 0.04183075150681548, 0.005448813225885307, 0.1859280065898592, 0.09277728767331117, 0.09524784153235089, 0.1336149907693598, 0.05703836371862692, 0.010973304086983049, 0.04928733845358202, 0.16424403306524893, 0.13217340559907065, 0.10607147432515429, 0.09084693492283002, 0.10323452361564245, 0.19698345685196816, 0.10834617264090107, 0.08233917471854457, 0.2619263337263712, 0.1279674504925682, 0.119651386815403, 0.08762230005474791, 0.13470621901949964, 0.18893552896260968, 0.08670374505642908, 0.12933887410128975, 0.12988311168838795, 0.1035711678439104, 0.0824849474365561, 0.16497285799578398, 0.08312330419620373, 0.572261541031502, 0.562859655438662, 0.5861962675955099, 0.5946246284660861, 0.5969058444388626, 0.5418243556288076, 0.6093430972611468, 0.6315861360210226, 0.6416430404941889, 0.11985368287741915, 0.06644982467349125, 0.12867999247349982, 0.15716871858781833, 0.07772401330574463, 0.08403323241436522, 0.07971222995645877, 0.09473115937814969, 0.138363953811102, 0.19784481801081633, 0.19812273188714524, 0.6636076789336073, 0.6977177279033795, 0.2662563804051502, 0.19998349776573032, 0.4148783588972532, 0.16904930607976, 0.7019149764508461, 0.1857256445387293, 0.41311396426214975, 0.39272060179222157, 0.5699195069070102, 0.5029681098175289, 0.432462919187672, 0.2657847794220637, 0.5088775906358629, 0.360776636870465, 0.25513577508155627, 0.40345974437824783, 0.2082608628213264, 0.25969423268837377, 0.2854867408139411, 0.272382135266232, 0.23464920431890035, 0.3848724949730298, 0.22365329364861863, 0.23238191945451936, 0.253489891563516, 0.2642406203408749, 0.20798843747067053, 0.2269350290612474, 0.26394502371191275, 0.2921064681240908, 0.27154238337045666, 0.212319741241355, 0.20873544646811537, 0.7338175482470046, 0.19774543364305863, 0.20843747736972884, 0.2287695438256957, 0.2520690706865263, 0.18919129322656136, 0.1918456292046663, 0.1952043946879396, 0.18732034917698115, 0.1875751612643165, 0.18748684160838924, 0.9189823964812025, 0.20027177170911892, 0.8921044849164855, 0.905797992526743, 0.9048928628624756, 0.9122393901139897, 0.8811875115220109, 0.8720594877449941, 0.8211401695024059, 0.21035265092460909, 0.15391600761829705, 0.9218028045618186, 0.8513229522593034, 0.8269988156730346, 0.8348383169958461, 0.200303359554884, 0.1804261787571244, 0.24332610064770832, 0.3086572269280359, 0.20632417418630233, 0.20775111839082094, 0.2790328238419554, 0.18694466435886925, 0.310080670338554, 0.10199115040844697, 0.08455331318613857, 0.09233709219969333, 0.09625517097788239, 0.10320077494124547, 0.08818118675365638, 0.08436894999396116, 0.10296477398076964, 0.09518359066441684]}, "mutation_prompt": null}
{"id": "b07c5e1b-efa0-4293-9310-a27efd888416", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.985)  # Adjusted mutation scale decay\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved mutation scale decay rate for enhancing adaptive mutation effectiveness and exploration.", "configspace": "", "generation": 48, "fitness": 0.3678870897290992, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8670554276650123, 0.8618869275165248, 0.847319309011682, 0.8593370275987637, 0.8798238897788881, 0.8523997031398741, 0.8346943377372971, 0.8651654495837626, 0.8582792829984496, 0.7024616614117516, 0.7281316275533954, 0.6698903973009883, 0.6712430779905635, 0.6871836843813348, 0.0634849268285207, 0.7099300565135993, 0.6531053456397803, 0.6272398426837771, 0.08773553360138708, 0.14290804060746976, 0.14876246037310104, 0.12092183675026813, 0.10922408850278442, 0.17966212077501875, 0.09475371391028309, 0.18344841714703775, 0.11340162222087768, 0.1129260855732317, 0.14155665861426936, 0.10905884768666818, 0.10922621756651074, 0.1159245225491572, 0.10672660452520866, 0.09897605065892434, 0.13984631825780125, 0.11080876808883244, 0.9346124216968916, 0.9338148708686232, 0.9364218077738401, 0.929811794409693, 0.9304413977406257, 0.9271881620253112, 0.9420885937400412, 0.9031440235482093, 0.933420266789112, 0.7157865379678562, 0.7058878537412098, 0.7327845793158982, 0.7164260144245991, 0.7106627200960403, 0.741407228107316, 0.7455810632062734, 0.6917198122052721, 0.7132154666051488, 0.9218789207379645, 0.22805701046249727, 0.2249651075031016, 0.9148711310298052, 0.744565180721708, 0.27628788540767524, 0.22595901962703935, 0.8299634651479636, 0.2350934715317079, 0.3408730943810855, 0.13108051197330728, 0.26310617106198686, 0.2789624257398232, 0.3294896045897848, 0.278263767290408, 0.2790282425934629, 0.2836375181972568, 0.28427546691755956, 0.2646709465330529, 0.26584114932170155, 0.2543219863580062, 0.27350102890630346, 0.31087361076791475, 0.13479122742485217, 0.2900995796768946, 0.28942716992537165, 0.2970217588799413, 0.06067901682662524, 0.03944331021391967, 0.27598566398808555, 0.09079111283632157, 0.01588695238560356, 0.05703127309870071, 0.08441939660241948, 0.020997363966085536, 0.1232219377859275, 0.1133785470367149, 0.09650963818840319, 0.12873197258963787, 0.12081539897620441, 0.03991814017674, 0.06413243666486546, 0.19390534854813424, 0.11845185891083365, 0.09684512647869437, 0.1508707069780466, 0.28086833144475143, 0.35678380133261856, 0.11335877312904286, 0.10221539256793277, 0.3928160478861852, 0.12101191148511825, 0.14369490759134662, 0.06981325454903797, 0.18746831547020715, 0.14312017509920827, 0.15166259295006423, 0.10536173972429175, 0.18790899740160405, 0.19276112542134582, 0.08820359941367628, 0.18812047542047983, 0.13404376101171533, 0.538184397560755, 0.5553363854040978, 0.6025417679548865, 0.5543766571709374, 0.5618365017740632, 0.6211002155859138, 0.5866839103780579, 0.5810902881139883, 0.5698703353499674, 0.1405739486195926, 0.11375103946939868, 0.12527003399807013, 0.13033046309008134, 0.09444549168711747, 0.08957745728634636, 0.1160234504798544, 0.11406850490613873, 0.12091734318697767, 0.5199656793544327, 0.39582521590036035, 0.44976217525562434, 0.18895913524761576, 0.173644991169563, 0.4589739698712715, 0.28094815139814533, 0.1967146055580502, 0.7039404945665009, 0.4484710306914681, 0.39765235640781005, 0.31587079839124343, 0.4623765778899793, 0.2345760227541186, 0.6215578848749188, 0.5314899864296432, 0.440076925851012, 0.5330370696974909, 0.265939440965276, 0.2912440992813454, 0.20711726185711832, 0.3249113756658034, 0.30136696421988396, 0.3703623652908684, 0.16174902350780795, 0.3249177438212175, 0.19522946177806888, 0.22385998748213265, 0.23243308945526064, 0.26868247051450134, 0.1961747056215314, 0.22986159745683477, 0.2162561322071519, 0.27032983591412707, 0.26064153704977056, 0.25990001925288764, 0.19754695027921287, 0.2505786518202838, 0.19024473571343425, 0.2524751295608745, 0.25007963095037444, 0.1918088615716047, 0.1758056032934897, 0.18027026781804556, 0.19268494832693794, 0.18451613680260714, 0.1783868311004433, 0.18646081119564062, 0.9074634427108996, 0.2003008810299579, 0.8950657215087158, 0.9075071911205048, 0.9004737483231962, 0.9137342029924713, 0.8899947452295648, 0.802382675452918, 0.8208934617760862, 0.8598912952636512, 0.1544242992366075, 0.8776439225164258, 0.8788417714694722, 0.10443359774122618, 0.7942428378675105, 0.20210149491721818, 0.4120227536359369, 0.2404865486619493, 0.3126270221846862, 0.23945379483959883, 0.2525151350227306, 0.2652482424831978, 0.24456561810575006, 0.24773355901008254, 0.09947110861232211, 0.10511319614977843, 0.11949544263677492, 0.09000340558803765, 0.07749606598870473, 0.1387036806494849, 0.08700564029975844, 0.10752928224174396, 0.10203930925491911]}, "mutation_prompt": null}
{"id": "0d3fbbca-6385-464a-9b7c-f2c3f40c9cc3", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-2, 2, (self.population_size, self.dim))  # Changed from (-1, 1) to (-2, 2)\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced exploration by increasing the initial velocity range for diverse search directions.", "configspace": "", "generation": 49, "fitness": 0.36043989340579435, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8551344909832217, 0.8681098003523814, 0.8498746657315636, 0.8472845486829015, 0.863819230399433, 0.8611208966526771, 0.8536679071165786, 0.8637878928715301, 0.8487081176028819, 0.697731478940631, 0.6869586340173329, 0.6923718817610789, 0.6337145004481071, 0.7154163566580214, 0.6525633400709501, 0.7072606919556846, 0.6362082476756884, 0.6455033522451257, 0.12358635514092331, 0.09873293128524163, 0.07627432690462865, 0.11597283351484167, 0.1006464117880943, 0.11592006063830174, 0.11312316860862315, 0.11011832340654015, 0.14089609798773617, 0.11333423399522868, 0.10932685610058579, 0.1145003950528729, 0.11234434541014293, 0.07883448465231468, 0.1212578784442534, 0.11971159997901526, 0.13043311022218185, 0.13036315188553071, 0.9351677329263137, 0.9339353750893713, 0.9373723783910937, 0.9177981651448208, 0.9292887296247119, 0.9322390036762314, 0.9366280763718511, 0.9086940552382218, 0.9344386700665437, 0.7292925407350088, 0.744741072143573, 0.6776151422773795, 0.7336660885499229, 0.7402723879160078, 0.6912895977149833, 0.7220668105888306, 0.7273331782027079, 0.6869968106379704, 0.3568767579909715, 0.22888592834623855, 0.22561291800361727, 0.8939468257521863, 0.27973824173592843, 0.20636554265242035, 0.7467863583218821, 0.23456433813586053, 0.3871933788008798, 0.2507733925866622, 0.1322219475738028, 0.28283233624875936, 0.29119786895444344, 0.26805333235666107, 0.2560533566987828, 0.2663624952798659, 0.2932589503881594, 0.30025814599151057, 0.13491139389249474, 0.2644863036543955, 0.27238366911498757, 0.2841339266347802, 0.2662812212580875, 0.2658520796969195, 0.2890011442839787, 0.2874253381835937, 0.2911337215109173, 0.014591590045656133, 0.1045160865335063, 0.02393210207361296, 0.06780487597398022, 0.14472214494124858, 0.0845245991678949, 0.19660489700146744, 0.013516737951323576, 0.029644732115015393, 0.10807875272180989, 0.0764971002124466, 0.123381056401633, 0.04366701081561719, 0.011141869195411935, 0.06554890604733188, 0.29230818753856047, 0.15074658988435585, 0.09442525171345839, 0.11770665042213535, 0.16339834868953662, 0.14255926555956722, 0.1117749920317832, 0.1543441166783397, 0.09867060551363016, 0.16857497276704836, 0.361133022318353, 0.0673023977724937, 0.40365858206401395, 0.19143732577470363, 0.06744347850977084, 0.09737294437488597, 0.13177610569783405, 0.12869443288311666, 0.08213042551446836, 0.2092163927155054, 0.107659070128717, 0.5422381827282026, 0.5462067960469588, 0.5804824895218271, 0.5526046318507145, 0.5931723933349762, 0.5831009447399393, 0.5631605957549807, 0.5554432373493505, 0.5866711932258695, 0.15356049945148553, 0.09183743993174098, 0.10850944935191742, 0.13120613386551616, 0.1186266561782231, 0.08169502818636831, 0.10192630056564356, 0.10905609761793278, 0.11611436507909134, 0.4108661413398227, 0.5269902732878669, 0.330712670335659, 0.6753163114095259, 0.536841013033617, 0.4179513975987569, 0.34853413243054343, 0.2192743349211842, 0.275791420102384, 0.3837191922632557, 0.5152783129969835, 0.4439566943503549, 0.3226536802355374, 0.344110321018107, 0.35033303905046, 0.24401847657164788, 0.4701617677523535, 0.47344180893657983, 0.2750330708126357, 0.2881547489151498, 0.2394641706395224, 0.2605043802257513, 0.3265862335412376, 0.34889976939217915, 0.2077432688379357, 0.32033099580673585, 0.18582431134245347, 0.26146070219275497, 0.27733575490618956, 0.262259052116108, 0.254450201149267, 0.2097936143252913, 0.18518232920087818, 0.2570614009241685, 0.22664364578740637, 0.23209868102475684, 0.20140539221525766, 0.2227507173575396, 0.18447504853315, 0.19670755764312187, 0.24877999170971088, 0.22314983042711067, 0.2080210830053778, 0.2105060653520885, 0.188407476763375, 0.12561398766350174, 0.1785646367892274, 0.15372751882523572, 0.9127349649056518, 0.20042758203258604, 0.9132342291899871, 0.9031094787998293, 0.16992194784225645, 0.9336368149427023, 0.8732239477120121, 0.8531596252490721, 0.8155884798755975, 0.8808545057164617, 0.7807560583215976, 0.8599632200611265, 0.8439120032464167, 0.16680677393111232, 0.8211325152431583, 0.21464532351195098, 0.2081364732475568, 0.33838438230574486, 0.28607401788318143, 0.20986669933623603, 0.22731874157543264, 0.2762076490989077, 0.2699348554422448, 0.2556276476327456, 0.08048008311833543, 0.1101980616248075, 0.07936062316811454, 0.11425303354369754, 0.0623958703992068, 0.12002767883837118, 0.1631892276378567, 0.10796715613305274, 0.10544329596666646]}, "mutation_prompt": null}
{"id": "308631ba-ce2d-492f-9813-c56c3df5d9d1", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.97)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced exploration by slightly increasing the mutation scale decay rate to improve diversity.", "configspace": "", "generation": 50, "fitness": 0.36057744087715593, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8630016875466611, 0.8679167478890013, 0.8362024358456911, 0.8668378847981493, 0.8495086995597726, 0.846596851891685, 0.8493369390242949, 0.8532825860456474, 0.8508834857045622, 0.6960581614523558, 0.7308576805576525, 0.6816649159574188, 0.6997943331620291, 0.6847118940001826, 0.6543317153616814, 0.667713419679512, 0.662282916705275, 0.05005932889530973, 0.08408364588955497, 0.15585435937867698, 0.13923231606895448, 0.11289605710306094, 0.15444739628114235, 0.15198024696138146, 0.09582509765111713, 0.15452476592794906, 0.1577506843359313, 0.11381110835522756, 0.12122012168029883, 0.10810010906760303, 0.11007402610312078, 0.12729353236462027, 0.09283423959044956, 0.09911930344692321, 0.13883421500845017, 0.14016944379261642, 0.9345994004072825, 0.9340379527944693, 0.9363328276561157, 0.9298944776692853, 0.9305276449867442, 0.9271962559999083, 0.94172473802468, 0.8998831202454959, 0.9331313468545172, 0.7076747274310013, 0.7316115889473105, 0.6905967492454799, 0.7356284399942963, 0.708880259217298, 0.7481066976142383, 0.7210323320305361, 0.6968725831676528, 0.7120636358377697, 0.39739384873884853, 0.8187087018960657, 0.17056952246800938, 0.9148711310298052, 0.3747465061437373, 0.2773933687330846, 0.23398376061317816, 0.23515473310197854, 0.2353585787099174, 0.30824207227207423, 0.13089570338176237, 0.28100492251945197, 0.27002644657730446, 0.3505133164410268, 0.2814427034716228, 0.27733368108465795, 0.2936159806518053, 0.2699999495273617, 0.270889185639016, 0.26305724629127514, 0.24926865695656542, 0.27820292873240726, 0.3317743929034598, 0.13505893528636514, 0.28348796651192776, 0.259824183503058, 0.29949118030697675, 9.999999999998899e-05, 0.17845861421020437, 0.13490444932483714, 0.0755238476851946, 0.10111531863495771, 0.07379408551884026, 0.09812106698314726, 0.02614488547323157, 0.08165903271716068, 0.10156925520351834, 0.06174928560128845, 0.15679984712633255, 0.11868110257181796, 0.029173570609929977, 0.0757955817731325, 0.2099047447119492, 0.11158427854121478, 0.09538446012365553, 0.14292398431413056, 0.20701597640130076, 0.35745404540713666, 0.10828390789596565, 0.09431321849926921, 0.24796912462690834, 0.12086671611566457, 0.13275173593674827, 0.08350031544318115, 0.2714631107250902, 0.12537261794884635, 0.07124741696761194, 0.11567703590024958, 0.06787668038101513, 0.20780906198168858, 0.10156003044916506, 0.2799939385437943, 0.11309248174770203, 0.5382891886977312, 0.5407814412762533, 0.5954198333697815, 0.5503447289363789, 0.561381709772037, 0.59679308514576, 0.5974801889681511, 0.5768091456031267, 0.5723246492548791, 0.10935238143189485, 0.10630492812428327, 0.1128785977762915, 0.18088387705209097, 0.08793629714723683, 0.07620415644279388, 0.12235845605944706, 0.10291236797095027, 0.13081568530980348, 0.47011281172277497, 0.5689004320331631, 0.49263937911722333, 0.19637999622784696, 0.17369704279618758, 0.35177265546722014, 0.2784438620467624, 0.21202222698050344, 0.5772427032902432, 0.42045285021663326, 0.4569631952278901, 0.3606334993589969, 0.427033027918326, 0.47816948234720724, 0.35067892088228747, 0.5027034356253689, 0.5687352990769869, 0.3714073335401795, 0.25183961883381667, 0.2902005808788328, 0.25694788024363346, 0.28424111762618165, 0.2994056780511145, 0.4001917696737479, 0.2290655264000131, 0.2538724803171082, 0.22177707853775097, 0.2731306668250272, 0.24817282776208638, 0.23829206760228006, 0.21721406233141016, 0.22473179741523763, 0.2586020148383048, 0.2782380031233742, 0.21523992126636304, 0.24412943017592648, 0.19760452355533997, 0.2160412200887697, 0.19653366091595603, 0.2522439274869902, 0.2108733637180069, 0.19548197171083947, 0.18087041016913286, 0.19865225045770807, 0.17095541623894117, 0.18463022939524198, 0.17852728421345587, 0.1864911563261732, 0.9044716250754201, 0.20030809512092052, 0.9137956685507832, 0.9140763945304153, 0.8880671303321451, 0.9139518999574909, 0.8805010140013679, 0.8067302483415323, 0.8391308713575605, 0.868439562838597, 0.15404267636450697, 0.9099555215278736, 0.8678246554708756, 0.10438990881652155, 0.8061961737692663, 0.23275143826324207, 0.2577666522817931, 0.20689458714052744, 0.25220682339342004, 0.2995388766004464, 0.20747072158142932, 0.2711121166536262, 0.2037251508032466, 0.24782212853890062, 0.10049110240877235, 0.10712526640136999, 0.10466018953767275, 0.0853412499193309, 0.09042544619920412, 0.10513761732523275, 0.08159251759950259, 0.11231896764000082, 0.11417656193257175]}, "mutation_prompt": null}
{"id": "ee38d70b-2b1a-4f3d-9333-f6739fc8ca19", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.4 * (np.mean(personal_best_scores)/self.budget))  # Enhanced adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced adaptive velocity clipping by dynamically adjusting based on the mean result of personal best scores to maintain optimal exploration-exploitation balance.", "configspace": "", "generation": 51, "fitness": 0.26727225118220527, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.30.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8345714277624323, 0.8656484940346996, 0.8563180043513501, 0.8614786406251888, 0.8524854102221561, 0.8589479576794816, 0.8487234847158563, 0.8592657573143287, 0.8447819204640957, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15548263484749636, 0.15676620369276972, 0.06509549625204802, 0.15441723602696222, 0.12880003390993566, 0.10947205775302571, 0.09422342572895781, 0.1585583146109082, 0.11023151835369005, 0.1092510149611835, 0.09963483735859169, 0.08295734838489133, 0.15369493489641284, 0.09438596797732757, 0.1139690708222677, 0.09563183053804203, 0.09462741594876611, 0.11133802503587431, 0.9347685533886307, 0.9342874037361825, 0.9342916502676841, 0.9266491994152252, 0.9327156887275923, 0.931700150530635, 0.9420800842066921, 0.9002607490718435, 0.9339141287917626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.7259066958249156, 0.7020714950544045, 0.6737633583563823, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.3909670877774838, 0.24105709687263033, 0.22503265897910074, 0.3592471568478297, 0.3714378622023482, 0.21236766170125343, 0.2294506254456824, 0.2254703557189195, 0.3934647177812044, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.22508915547309005, 0.10377654504130984, 0.09079621826111384, 0.07677023754517265, 0.11997846917185595, 0.13648372893289873, 0.08281793631867329, 0.20234088601791533, 0.08307378449034308, 0.6052527281150324, 0.5469366522418502, 0.607643453261953, 0.54836735033175, 0.5742208915849222, 0.543008453203448, 0.6014658478767727, 0.5669785770688454, 0.5777291793870629, 0.06882059516263583, 0.0677128369029113, 0.12560181913075918, 0.15478382678832858, 0.10066711898218272, 0.1398323424179967, 0.11876471118875775, 0.11050897860765252, 0.13990227079859674, 0.4898500512731341, 0.3182151715689585, 0.1772760871766199, 0.22534707279076993, 0.3391238096393705, 0.4309326755892351, 0.32063971043653905, 0.2590295351324535, 0.6430140508948821, 0.4448314685831286, 0.4171127107463011, 0.4716028163331786, 0.3900769329621997, 0.44818161537866563, 0.5001077230971807, 0.5606910698141805, 0.5582268983960043, 0.250966104069972, 0.3073528764143746, 0.2846902455414321, 0.21740442472190702, 0.3407483226819684, 0.22203872058540974, 0.4255474685937245, 0.2330286830153212, 0.28212208586011855, 0.18933627810482845, 0.22323965746935825, 0.2588581544962071, 0.287413611657908, 0.27449359402605467, 0.27330842450288484, 0.2474567546933284, 0.24055287789941304, 0.26190875890244525, 0.24736604309829935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2045804293149639, 0.1931361020399326, 0.24256701620057963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1846236675411047, 0.17856232149308926, 0.18653402954045706, 0.9075147376437596, 0.20039947812079173, 0.9085187085932555, 0.9144408638855394, 0.9160943369142933, 0.9350749153675072, 0.8908734087612329, 0.8852597129160628, 0.8064014764014824, 0.8456912618500254, 0.16753237161677448, 0.8783906121203255, 0.8290243092359613, 0.10443004378642073, 0.8114893622925374, 0.342169927327145, 0.21243901636469487, 0.23732466614132364, 0.24143904942665617, 0.34652177504080095, 0.24641593227833192, 0.2825705201011711, 0.2752973767424579, 0.2657897270807864, 0.07250623627425756, 0.10685174326158597, 0.07720920407595677, 0.0859070831085813, 0.09323523324032756, 0.1035804331097836, 0.06878820360928461, 0.0868008908998138, 0.10394681252404281]}, "mutation_prompt": null}
{"id": "aaf74fac-aa0f-4375-b033-4838125d14ae", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.8 + 0.3 * eval_ratio, 0.8 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved convergence by adjusting the velocity clipping range adaptively based on evaluations.", "configspace": "", "generation": 52, "fitness": 0.3540818835958217, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8747838571267457, 0.8707545928687439, 0.8627645242919033, 0.8392249028076738, 0.8445718972605447, 0.8318102679886572, 0.8621750983252005, 0.8373776054684748, 0.8317877669569558, 0.694102218277401, 0.7129568414937365, 0.7165224649783225, 0.6598832820919288, 0.653846682728395, 0.648496110541717, 0.6597606180750977, 0.647535174353352, 0.6462782695632947, 0.10900088498916616, 0.12605186966065574, 0.11550641596766309, 0.15378612547403958, 0.14325657796491287, 0.13688442359053166, 0.07406578754456516, 0.15682165956492533, 0.18104989742380417, 0.12220721852322913, 0.1133924141735515, 0.10677275050596913, 0.1445725839940405, 0.12163221297678284, 0.09686468380074709, 0.11539287890404082, 0.11596490930780834, 0.11781867810287128, 0.9401483148080937, 0.9427034115211185, 0.9459084549112614, 0.935828054858484, 0.9358446236827102, 0.9432419046867793, 0.9437695725104419, 0.9266565578563813, 0.9423378768979536, 0.7137881476535335, 0.7061715451858679, 0.7097501102780828, 0.7504727114894979, 0.7221555280503096, 0.7056681130876783, 0.7206602315584009, 0.706668856465261, 0.7129438716458503, 0.3906679150822816, 0.16955160868290897, 0.38035938842959927, 0.8914983660466471, 0.19263876294519133, 0.21276969622691855, 0.8401844054425354, 0.17839586618192138, 0.2360899356532392, 0.22169439174723715, 0.23922729287764655, 0.12967303536167418, 0.26763542668949536, 0.13450971738324202, 0.26845070854128184, 0.30562359447025234, 0.2854868079580114, 0.26965543867207376, 0.2532549266715408, 0.25908949245429813, 0.2602690866027306, 0.2999320872293959, 0.30730422671050583, 0.13076546217940688, 0.30694256314989243, 0.2808934435387781, 0.28161534091109075, 0.08843794917045511, 0.13990199698591677, 0.050100133481899456, 0.09172329459632989, 0.12063686104957849, 0.13613896880695886, 0.04440157591584104, 0.010763838983969487, 0.12717849432011152, 0.20284189390664786, 0.07794588410682557, 0.21342286110503417, 0.05975976609508338, 0.049046595629457235, 0.14398486005967648, 0.11235125770854015, 0.13833284219555864, 0.10479023255279496, 0.10611005804378348, 0.2429675131478365, 0.2221546586897758, 0.085617403268061, 0.0897054942185177, 0.2649574819780348, 0.1709434813150308, 0.2807553038530669, 0.10059799948644177, 0.1786387123293267, 0.1351191751538512, 0.11063464084514618, 0.21331884509310972, 0.30939256363702283, 0.10677152585746552, 0.0833999917978352, 0.2227665610475945, 0.15653614359030887, 0.5600287950392244, 0.5398268471823298, 0.5433607897298132, 0.5974864031516047, 0.5918321083585297, 0.546322895125388, 0.5629325241830787, 0.6046027918432428, 0.5865366156687386, 0.12718518504428955, 0.0780647079670509, 0.10465897236548405, 0.17193976051755266, 0.09064107221654794, 0.13935844124977304, 0.12070394163869569, 0.14163452062713766, 0.1427260503265757, 0.6292228587281835, 0.24873047046172692, 0.2098651012072602, 0.6581207543431578, 0.5433542005461762, 0.3012654228645695, 0.31769030634545803, 0.4320785690650859, 0.21637614566896113, 0.424272634299823, 0.5757937293462199, 0.5311636727367695, 0.3353859951001691, 0.39546474094950457, 0.44423240491311844, 0.24483331317342816, 0.44896277462694467, 0.40381351062697934, 0.23033403386178064, 0.3039977565265475, 0.22309142181138364, 0.40609841572455585, 0.23531269726143733, 0.3623308083049064, 0.2514378087190732, 0.2604994384642977, 0.25979433087131065, 0.27716267355318547, 0.29887489747207097, 0.24656413219685913, 0.20916519800128175, 0.23372468571101868, 0.1999874927714006, 0.2502813598852446, 0.22762916758571405, 0.26210131286840277, 0.1986161789557066, 0.209209008024413, 0.19805796707958911, 0.2080442556132447, 0.19792737490346968, 0.19900001919003563, 0.1888281186956864, 0.19793318204893195, 0.19147830689644374, 0.126265799832894, 0.1785715785296319, 0.15345048502364844, 0.921029916909095, 0.2001681067184009, 0.9113152443484287, 0.1425271430895697, 0.9210127900832757, 0.9131526734147416, 0.9112086966558605, 0.825627946629768, 0.12683640465390256, 0.2933575264446857, 0.154767922284061, 0.8791187836743694, 0.8440263158060451, 0.10448806278056277, 0.7791208214938747, 0.2716305291168364, 0.21729552602052826, 0.1897685463199782, 0.29277679157921166, 0.23935433072536905, 0.31043500567373783, 0.2459428089656559, 0.2669529979045334, 0.24036208181209462, 0.09020169003498724, 0.11159843905095645, 0.07187004855030843, 0.09430771506810365, 0.10673246421975457, 0.10293451555639954, 0.10498836220126306, 0.07204313073347834, 0.091776701877059]}, "mutation_prompt": null}
{"id": "f062f192-57bf-4c35-bd54-b3b8937dfc5d", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.8 + 0.3 * eval_ratio, 0.8 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced the exploration capabilities by slightly increasing the range of adaptive velocity clipping during early evaluations.", "configspace": "", "generation": 53, "fitness": 0.3540818835958217, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8747838571267457, 0.8707545928687439, 0.8627645242919033, 0.8392249028076738, 0.8445718972605447, 0.8318102679886572, 0.8621750983252005, 0.8373776054684748, 0.8317877669569558, 0.694102218277401, 0.7129568414937365, 0.7165224649783225, 0.6598832820919288, 0.653846682728395, 0.648496110541717, 0.6597606180750977, 0.647535174353352, 0.6462782695632947, 0.10900088498916616, 0.12605186966065574, 0.11550641596766309, 0.15378612547403958, 0.14325657796491287, 0.13688442359053166, 0.07406578754456516, 0.15682165956492533, 0.18104989742380417, 0.12220721852322913, 0.1133924141735515, 0.10677275050596913, 0.1445725839940405, 0.12163221297678284, 0.09686468380074709, 0.11539287890404082, 0.11596490930780834, 0.11781867810287128, 0.9401483148080937, 0.9427034115211185, 0.9459084549112614, 0.935828054858484, 0.9358446236827102, 0.9432419046867793, 0.9437695725104419, 0.9266565578563813, 0.9423378768979536, 0.7137881476535335, 0.7061715451858679, 0.7097501102780828, 0.7504727114894979, 0.7221555280503096, 0.7056681130876783, 0.7206602315584009, 0.706668856465261, 0.7129438716458503, 0.3906679150822816, 0.16955160868290897, 0.38035938842959927, 0.8914983660466471, 0.19263876294519133, 0.21276969622691855, 0.8401844054425354, 0.17839586618192138, 0.2360899356532392, 0.22169439174723715, 0.23922729287764655, 0.12967303536167418, 0.26763542668949536, 0.13450971738324202, 0.26845070854128184, 0.30562359447025234, 0.2854868079580114, 0.26965543867207376, 0.2532549266715408, 0.25908949245429813, 0.2602690866027306, 0.2999320872293959, 0.30730422671050583, 0.13076546217940688, 0.30694256314989243, 0.2808934435387781, 0.28161534091109075, 0.08843794917045511, 0.13990199698591677, 0.050100133481899456, 0.09172329459632989, 0.12063686104957849, 0.13613896880695886, 0.04440157591584104, 0.010763838983969487, 0.12717849432011152, 0.20284189390664786, 0.07794588410682557, 0.21342286110503417, 0.05975976609508338, 0.049046595629457235, 0.14398486005967648, 0.11235125770854015, 0.13833284219555864, 0.10479023255279496, 0.10611005804378348, 0.2429675131478365, 0.2221546586897758, 0.085617403268061, 0.0897054942185177, 0.2649574819780348, 0.1709434813150308, 0.2807553038530669, 0.10059799948644177, 0.1786387123293267, 0.1351191751538512, 0.11063464084514618, 0.21331884509310972, 0.30939256363702283, 0.10677152585746552, 0.0833999917978352, 0.2227665610475945, 0.15653614359030887, 0.5600287950392244, 0.5398268471823298, 0.5433607897298132, 0.5974864031516047, 0.5918321083585297, 0.546322895125388, 0.5629325241830787, 0.6046027918432428, 0.5865366156687386, 0.12718518504428955, 0.0780647079670509, 0.10465897236548405, 0.17193976051755266, 0.09064107221654794, 0.13935844124977304, 0.12070394163869569, 0.14163452062713766, 0.1427260503265757, 0.6292228587281835, 0.24873047046172692, 0.2098651012072602, 0.6581207543431578, 0.5433542005461762, 0.3012654228645695, 0.31769030634545803, 0.4320785690650859, 0.21637614566896113, 0.424272634299823, 0.5757937293462199, 0.5311636727367695, 0.3353859951001691, 0.39546474094950457, 0.44423240491311844, 0.24483331317342816, 0.44896277462694467, 0.40381351062697934, 0.23033403386178064, 0.3039977565265475, 0.22309142181138364, 0.40609841572455585, 0.23531269726143733, 0.3623308083049064, 0.2514378087190732, 0.2604994384642977, 0.25979433087131065, 0.27716267355318547, 0.29887489747207097, 0.24656413219685913, 0.20916519800128175, 0.23372468571101868, 0.1999874927714006, 0.2502813598852446, 0.22762916758571405, 0.26210131286840277, 0.1986161789557066, 0.209209008024413, 0.19805796707958911, 0.2080442556132447, 0.19792737490346968, 0.19900001919003563, 0.1888281186956864, 0.19793318204893195, 0.19147830689644374, 0.126265799832894, 0.1785715785296319, 0.15345048502364844, 0.921029916909095, 0.2001681067184009, 0.9113152443484287, 0.1425271430895697, 0.9210127900832757, 0.9131526734147416, 0.9112086966558605, 0.825627946629768, 0.12683640465390256, 0.2933575264446857, 0.154767922284061, 0.8791187836743694, 0.8440263158060451, 0.10448806278056277, 0.7791208214938747, 0.2716305291168364, 0.21729552602052826, 0.1897685463199782, 0.29277679157921166, 0.23935433072536905, 0.31043500567373783, 0.2459428089656559, 0.2669529979045334, 0.24036208181209462, 0.09020169003498724, 0.11159843905095645, 0.07187004855030843, 0.09430771506810365, 0.10673246421975457, 0.10293451555639954, 0.10498836220126306, 0.07204313073347834, 0.091776701877059]}, "mutation_prompt": null}
{"id": "e9b125dc-ec68-4c94-ac1f-1295b649c2db", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 36  # Increased population size for better exploration\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved convergence by slightly increasing the population size to allow for better exploration.", "configspace": "", "generation": 54, "fitness": 0.34694096408990516, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.852091784552485, 0.8428999681701904, 0.8504781974135471, 0.8632439550918564, 0.8310107556403715, 0.846793510763564, 0.8636307419433549, 0.8471081943576623, 0.8556274805322921, 0.7277399427726836, 0.6642389793524408, 0.7027949849728465, 0.7230562186816568, 0.6898777575130877, 0.6789779452367057, 0.6408444529344399, 0.6818285844914376, 0.6197439138301006, 0.09048971750967971, 0.13224207467810156, 0.1406480029551791, 0.09699700835923009, 0.1228979399503134, 0.1155426465577557, 0.11596563830533668, 0.12397492619011297, 0.12270745483021728, 0.11452457669042271, 0.11357621265290385, 0.12202186442605811, 0.16043153859182802, 0.14307343952313623, 0.11137317376781664, 0.11665033683118342, 0.0831676723538487, 0.07769097735398589, 0.9306746023357798, 0.9346201018114082, 0.9318798337833777, 0.939330700201359, 0.9248660103850652, 0.9184165241603683, 0.9391133284611741, 0.9187429223441308, 0.9451419868933517, 0.7009159928803752, 0.7126609223152742, 0.7254473785140946, 0.7195686631432593, 0.7210336350815296, 0.7273745066517265, 0.7095987855322397, 0.7220561983722313, 0.7311460093356095, 0.22938485789578222, 0.38496544582013303, 0.22748027728850118, 0.3442750506344783, 0.8199146253692136, 0.2126200645137737, 0.2276619040590535, 0.23253838559865148, 0.8167272136372927, 0.13287109362033223, 0.12999190663948335, 0.5276875878197189, 0.3303581566291355, 0.1354186629994123, 0.22758253613960278, 0.2907462737966975, 0.2822963332189422, 0.36696271381343737, 0.24788494778122494, 0.26673641605926013, 0.12802424083986774, 0.30352251380274453, 0.30436350378972843, 0.2586599049868463, 0.27648468152514927, 0.2765260425511432, 0.30574339929676675, 0.06041244914511934, 0.05139695897022578, 0.03994419754791656, 0.002501820991727799, 0.07110601235369973, 0.031774997407858385, 0.05469193255157989, 0.012796427947963873, 0.20074106995680163, 0.12553557037607732, 0.12180126474110586, 0.12269435497917713, 0.10295431099950036, 0.06259053836632444, 0.09981105380150401, 0.08418416241441296, 0.09733789470385623, 0.1161741058872593, 0.1762312949501016, 0.23181267696602093, 0.22713351248952707, 0.11317966043110794, 0.12631739844264134, 0.09529718537509058, 0.19158723248673315, 0.17177070113606718, 0.15640269380440042, 0.11833228248634009, 0.09723582649607487, 0.16672292741204509, 0.14345482763366202, 0.2772826241336951, 0.20197877609989812, 0.2609274615313095, 0.15447105958948792, 0.08405524394441077, 0.6207827377098398, 0.5550042603060485, 0.5372070175373447, 0.593859067735661, 0.5692433307749236, 0.6200760008353431, 0.6127622148127404, 0.5932361208146526, 0.6106750025158801, 0.12123204358017814, 0.08988499149191498, 0.09859214223446666, 0.13954822555280388, 0.08726590339040607, 0.10703454208941676, 0.08792198337924417, 0.11490766163101307, 0.13804471007903762, 0.17127093898761503, 0.34605950906872285, 0.5492077708928735, 0.21282633095549364, 0.5494365138331156, 0.4641351217276507, 0.6436767373055525, 0.1582585032325775, 0.30983893883111546, 0.5541886220458694, 0.37945631487955456, 0.40255400509624384, 0.5688936537580257, 0.3312343881943798, 0.36011470152586833, 0.2644920591029577, 0.5981309970390439, 0.621200929653623, 0.2243995518278441, 0.33445376660496395, 0.31209449925177024, 0.3713875249016442, 0.23798611345517817, 0.32133242193138967, 0.25505820861640294, 0.3166785506609622, 0.22283645404043095, 0.2720929265230617, 0.25923815838447894, 0.2210301772746528, 0.2631946932548277, 0.285120007833747, 0.23396837129107795, 0.2688914380174765, 0.22624325828381553, 0.24930911701003544, 0.19980023542958503, 0.22477708722955436, 0.17524574088146927, 0.25032411745505534, 0.22324733456414203, 0.19649090708681816, 0.208583425899605, 0.22487571155883435, 0.1806457154648946, 0.187944322557972, 0.17816467271723013, 0.1530460254449616, 0.9244578003908768, 0.20082610679118762, 0.11483537666836274, 0.14229785334293887, 0.16904352511982956, 0.16823663142197498, 0.7946172543621086, 0.8198911282092451, 0.8674121501043499, 0.2094171240892161, 0.168088911941782, 0.15483307531505364, 0.8296027809439401, 0.8295023550981755, 0.8612216945153952, 0.31183924698425214, 0.2147121532652544, 0.2442981202687119, 0.21527781011738156, 0.20606328016967124, 0.22166235465066175, 0.2711214965860189, 0.3221008814020715, 0.2468552955606801, 0.09821674657664847, 0.09156962232183397, 0.11111710794734175, 0.0881957294006801, 0.08857449325957056, 0.11327545530665906, 0.10030621675422025, 0.09741485443781062, 0.10302716138323742]}, "mutation_prompt": null}
{"id": "fb7856f4-5f0f-4c53-88a7-22c224f7c928", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            self.population_size = int(15 + (20 * (1 - eval_ratio)))  # Dynamic population adjustment\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced swarm exploration by adjusting the population size dynamically based on evaluations.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (34,5) (35,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (34,5) (35,5) ')", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {}, "mutation_prompt": null}
{"id": "2435bb33-b601-4796-956c-1cc3e51d2b41", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n\n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n                    personal_best_scores[i] = personal_best_scores[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced convergence by fine-tuning the personal best update mechanism for dynamic neighborhood topology.", "configspace": "", "generation": 56, "fitness": 0.3468477021124227, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8691182588678568, 0.8830460053853483, 0.8737540050858058, 0.8584211383066592, 0.8485846949045334, 0.8512373114685409, 0.8545324299270456, 0.8636610057172488, 0.8696740208553462, 0.7012632689128486, 0.7221247877239936, 0.6761166583196447, 0.6737764489660607, 0.045311731365305974, 0.6932235468251136, 0.6771112908961826, 0.6629208030996262, 0.6728805488812726, 0.1306282665785362, 0.140247836415884, 0.07284997164971141, 0.11826239869334221, 0.1865175338451589, 0.6898523001438559, 0.11045619782446503, 0.18838394201680597, 0.093288002221528, 0.08003338744424149, 0.0631484851022488, 0.07843145976829513, 0.11000820736087102, 0.05503592901672816, 0.11486619808461218, 0.10092640544284337, 0.10337314170476108, 0.12084741279661726, 0.9410035782357782, 0.9469565112734135, 0.9367137497193211, 0.9365936574727205, 0.937020421968731, 0.936253649550629, 0.9486180846431976, 0.923782009713546, 0.9405816565868832, 0.7933234232280195, 0.7641029912029483, 0.7595347487151751, 0.7596882230562054, 0.15184911568815784, 0.7453187768238326, 0.7894024042547617, 0.7534165022193453, 0.7512352231197992, 0.8922433156438149, 0.2265905599615302, 0.36267580866583915, 0.3839236067710373, 0.2125758804914013, 0.192637055453187, 0.15194586275530986, 0.234413606237181, 0.8829061600657229, 0.4711288414257401, 0.3016791783861632, 0.2745579708989555, 0.2939425368198413, 0.27961630652075387, 0.2840758110616839, 0.2915750262015666, 0.317265223408005, 0.3257167410237627, 0.2744747287316335, 0.2619818445556932, 0.1215211324314519, 0.3489052058108798, 0.3130970942260868, 0.31764560628423155, 0.31377901478691417, 0.3037950401683439, 0.2970792417831182, 0.07582296976901903, 0.11967391191952192, 0.01162164786429909, 0.052574349692938616, 9.999999999998899e-05, 0.09370555183325646, 0.1560005259007241, 0.03991075677335698, 0.03313438105344979, 0.12761954565770461, 0.029852446802769883, 0.13868362372248522, 0.10028091387655336, 0.01896751567417887, 0.02704290049167757, 0.1442566359274322, 0.0997490952878628, 0.056993507161623325, 0.3444647255512846, 0.20119999929707977, 0.25302370340185676, 0.12296559815255081, 0.09482777504141782, 0.14020813318240144, 0.09907379413599027, 0.20783528518706906, 0.12946978855729596, 0.29262673320973376, 0.10915127316351991, 0.12046212170884751, 0.13238977627781257, 0.2255873469351396, 0.06614841275662875, 0.1056717371230419, 0.40498775519563723, 0.15810794476701961, 0.5560598180125595, 0.5824909225689168, 0.5666786333515277, 0.5676830601597449, 0.6130738742652257, 0.5559608063357074, 0.6340906980742025, 0.5820273136085257, 0.6001723644157935, 0.05808848363678354, 0.06501923933859088, 0.033410753805022564, 0.09935001222939532, 0.055241711224530476, 0.10045707536659798, 0.09919433103895603, 0.11587355299149782, 0.09239719211008501, 0.20818678094375276, 0.16996395467597214, 0.27245997805502864, 0.22577903154200574, 0.49843468960827564, 0.41732514135544785, 0.2850817286374825, 0.49364487456126993, 0.2092979457571833, 0.44702573265470746, 0.31435056620495394, 0.20638834672855721, 0.3484070308859275, 0.28983870385367094, 0.4503839805021923, 0.26758268244512595, 0.4100932895135495, 0.26112092532486975, 0.24499349002028126, 0.2656506450095266, 0.19879453673822833, 0.31070283436175095, 0.2904977936383595, 0.22898278007826134, 0.2449209321731708, 0.34354693010337145, 0.2136622661148273, 0.21572713235346241, 0.18443664532222048, 0.2572899166842306, 0.1962744066258748, 0.20843436426411366, 0.24738637624983095, 0.23175127700878406, 0.2391330476724738, 0.2310952706125644, 0.17913978910597728, 0.2017698594026649, 0.19330917138205017, 0.17861414290636768, 0.25265030209927186, 0.2089045260826491, 0.17690252184425204, 0.20951558887929334, 0.174061504456257, 0.18766151073709936, 0.17864202809924268, 0.18784437857348768, 0.19947779736623605, 0.20035364630126928, 0.9245432041018338, 0.14286608310931392, 0.9188648334430253, 0.913703061410837, 0.8130040547959265, 0.8057592202218918, 0.12568397100140338, 0.8939376272257613, 0.15362021369607426, 0.8690958832236302, 0.8788957382465095, 0.871878992937779, 0.7948846521472623, 0.21054212892237267, 0.2007034542052526, 0.24497932797543742, 0.23183251133740046, 0.26659201177692704, 0.2571897966763591, 0.22221449623141687, 0.2624323993524805, 0.2522022017430269, 0.0783599852877469, 0.08287697676735828, 0.05828181351399875, 0.10806195391372897, 0.10729751268123533, 0.10194484099001855, 0.07640041026452904, 0.08530873619668622, 0.09513258212057485]}, "mutation_prompt": null}
{"id": "a6361f37-c6dd-4b6e-bb83-24ab527dfb7d", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop) +\n                          0.01 * (personal_best_positions - global_best_position))  # Added momentum term\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced velocity update by incorporating momentum from previous best positions for smoother convergence.", "configspace": "", "generation": 57, "fitness": 0.37017845806105626, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8610202230931479, 0.8482237778788534, 0.8678255302489434, 0.866244157060297, 0.8680694347280107, 0.8683023636048893, 0.8388968814545514, 0.8660735487642007, 0.8489150939422827, 0.6999160390588489, 0.6956145192921848, 0.7155215592578623, 0.6742196423813398, 0.6675386669657181, 0.6658902988597616, 0.6172338443191627, 0.6932460542606922, 0.6411413456087574, 0.11530752805293087, 0.1519492552868167, 0.12363763068344702, 0.1416543852629205, 0.09882035221196639, 0.18080489583760984, 0.08555811499726573, 0.14073646876199852, 0.10821233797304719, 0.1122917966114757, 0.13502909338211244, 0.10864365973715029, 0.107988528242983, 0.1138172683791121, 0.1378810282446682, 0.10835643144687201, 0.11410878841545913, 0.10578891892515219, 0.9369549805359542, 0.9336665858395196, 0.9365867457232853, 0.926176081242184, 0.9279863130671078, 0.9293300335061149, 0.9426717060117549, 0.9085249400121036, 0.9337237383704932, 0.7284089767747608, 0.7533839934971571, 0.7105204033644568, 0.7309020562219123, 0.6938799963666076, 0.7459798363238848, 0.7173393143102578, 0.6835722287143227, 0.7161769099751613, 0.927879392570871, 0.2277552955861757, 0.1566654191469128, 0.917760544206617, 0.3708740465584387, 0.21275716103147158, 0.23231913986347108, 0.30178481620463415, 0.8795596176364946, 0.4160341478744892, 0.12829086221136277, 0.2513626127871832, 0.29388542289957975, 0.37954162395819724, 0.2836093792320624, 0.2441511589816031, 0.27339556458913217, 0.25507421066010905, 0.2687982919991957, 0.2706154743895458, 0.25213680752221845, 0.2721812788885175, 0.29243817992264554, 0.28918340738237147, 0.28676511209265754, 0.30152239436021355, 0.2553713625749737, 0.017003439955412425, 0.10290118249748981, 0.09732010549750181, 0.04788630878334532, 0.06077287735978465, 0.010850761683210974, 0.031127196002767588, 0.00565666067607562, 0.1399122797226342, 0.174659320473445, 0.07469306215488636, 0.15391516966904706, 0.08029588535127552, 0.028413629936329232, 0.03986709317819637, 0.13669929828663374, 0.15793810619130177, 0.1043627455354097, 0.13851549288784226, 0.16334988396091543, 0.256936073387512, 0.1102346283393999, 0.09594190146205306, 0.14897138375767682, 0.17945765965457883, 0.20985509746318254, 0.09714242248782634, 0.24470767273647642, 0.14349180410214868, 0.1310317057971846, 0.20035757016306377, 0.15890247139170388, 0.21109630303985794, 0.08814853959193569, 0.1289437784223635, 0.2290976782810058, 0.5859633324124836, 0.6056902069607439, 0.5776811748010722, 0.5842720381323243, 0.5695521934832124, 0.607835209714704, 0.5785457656202169, 0.5644003710605929, 0.6186696775708369, 0.09448385248225788, 0.09062018497189561, 0.09757236093681398, 0.1540709135996261, 0.09628529417649256, 0.1307703389065613, 0.09431032019302732, 0.6800847028241823, 0.178396272311649, 0.5420139724819701, 0.4521649827116905, 0.562493113396739, 0.2453279951776357, 0.4207912584934872, 0.424195773705476, 0.40731486014968066, 0.2133880767545323, 0.42678408824207403, 0.32549963069262844, 0.42566218785901966, 0.5822506241369424, 0.40780099128522485, 0.4150675609915445, 0.45500100864625903, 0.30445989206702917, 0.5427937408072638, 0.2637478526470244, 0.2303971162093288, 0.3225604371661518, 0.21510345440110912, 0.2966473970561867, 0.31499883317624644, 0.33468142262493883, 0.2630280258798571, 0.2572213185271678, 0.26820875873739336, 0.28328663918558405, 0.26667384192103405, 0.2429261077715006, 0.2662180686749973, 0.28284813447061674, 0.21095886346740633, 0.22659269418882544, 0.27558785469806746, 0.2674004360170833, 0.19792724601213896, 0.21565386313284396, 0.19777551172712116, 0.22332969862263374, 0.20932414434354307, 0.18307038905539286, 0.18907423288948388, 0.18108000095332655, 0.18643233928248903, 0.18700661114344053, 0.17849106441491347, 0.18793127525229447, 0.9150193577788782, 0.20039358058285106, 0.8984683769890173, 0.9006387649608955, 0.9159053055611143, 0.9191670818194377, 0.9168139799674127, 0.8370297504008641, 0.7863977119886632, 0.8112880625126679, 0.15462856617493903, 0.8929685849895752, 0.8791256055216208, 0.10440578760827479, 0.8206813614397394, 0.3554829020518818, 0.24682161669436564, 0.1783605830845909, 0.2459102986120829, 0.20608933716202615, 0.21490375770537817, 0.2385420611313782, 0.2475461879362697, 0.21987445832282404, 0.10458271589702528, 0.10857983530139359, 0.10058550455597359, 0.0876333058534563, 0.08932787072641168, 0.11719179190761808, 0.08881019435606452, 0.09104607214778737, 0.08349474993549377]}, "mutation_prompt": null}
{"id": "71ce91f6-dda0-49a8-8aa6-7425f04c8063", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.6 * np.random.rand())  # Modified inertia weight adjustment factor\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced swarm diversity by tuning inertia weight to boost exploration.", "configspace": "", "generation": 58, "fitness": 0.3428765910901396, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8292708937250096, 0.8272877286645725, 0.8327593351564783, 0.8275004504641734, 0.848315010965521, 0.818973709553262, 0.7828429357193147, 0.8381897561140659, 0.8067307562122563, 0.6633845913354632, 0.6630489642635911, 0.6182046515430581, 0.641964600596751, 0.611924710136077, 0.6934085990440775, 0.05114159037313659, 0.6509353358840775, 0.6061255069134918, 0.12112573411988958, 0.1529265460756113, 0.14747302060589373, 0.12258369407174052, 0.18302091831017486, 0.17772321645205902, 0.11845264269869782, 0.18736400344273874, 0.09340736764026225, 0.11160976105752074, 0.09335291649597965, 0.09440895855902542, 0.10829069218652965, 0.10660427288983898, 0.13440568986389667, 0.11419408719664148, 0.14147527309081798, 0.10697786567952772, 0.9349527644610984, 0.9369914361943301, 0.9397937024346266, 0.9328992733443517, 0.9337102763703573, 0.9336642457650766, 0.945107085488949, 0.90851521740864, 0.9307297141739967, 0.6755890604783567, 0.6512648692715659, 0.05748672494026563, 0.6789293710645434, 0.68830572047841, 0.6604100192495412, 0.6879641073286018, 0.6563380038814791, 0.6531287009014265, 0.22866125735434661, 0.22668132803039553, 0.15644312187163245, 0.37923154623259825, 0.1925768295635959, 0.19244258204931652, 0.3598331572220064, 0.17542309976098858, 0.7811273131611423, 0.22746896454050836, 0.12953523043229398, 0.241181749720616, 0.22739484651588748, 0.2635278446760779, 0.24376109366714127, 0.26491673228994705, 0.266111984720965, 0.2686682974008203, 0.22533149806727037, 0.24862845845257986, 0.13389122426900268, 0.29300692363592973, 0.25503440464787064, 0.2707553785772078, 0.2721252991227956, 0.27326659530341324, 0.25973620690948496, 0.021021234797140465, 0.05494918075001842, 0.23612662510582927, 0.06742474316610425, 0.14686323488266084, 0.046370814872228716, 0.06183626754017313, 0.07494222962357378, 0.15107617535888695, 0.21237750529591093, 0.12166876427956741, 0.10180232159884561, 0.04577440782678299, 0.0483853645768606, 0.08914033018770684, 0.1521448290414904, 0.13877163684992033, 0.10665889527586803, 0.1605254570705974, 0.17956592803791904, 0.1963946658153286, 0.116589337832536, 0.07456832227138588, 0.08485136885665379, 0.2979235863207076, 0.08136101811740848, 0.06689594763909823, 0.18284476050284948, 0.08540174198370443, 0.05608650662484871, 0.13145387786121665, 0.13917897990778383, 0.20229374325657745, 0.1185096495778587, 0.17367892609237046, 0.15259323150998771, 0.5886823592760098, 0.5464503414970399, 0.5506740844913105, 0.5537774410799814, 0.5707163520675516, 0.5566310645735886, 0.5368697289482572, 0.5637991047078126, 0.5758130999556874, 0.1280041819736789, 0.10603325283057163, 0.09268867206054932, 0.12917186504526146, 0.15270489087186612, 0.09791135794831296, 0.11249815358024484, 0.11970256370408239, 0.09242952978657581, 0.22536979430311854, 0.1774622787633744, 0.45898272022637365, 0.21895411441063073, 0.41356772153535537, 0.20454640167137117, 0.4441254657369329, 0.4375191348668309, 0.43700352497120043, 0.352826281783569, 0.4569759819638005, 0.5105571020305493, 0.35916857527583346, 0.4042163103900569, 0.3398604257521437, 0.44934368269802394, 0.5366574601465288, 0.3715629591548688, 0.34031921591463155, 0.19530116996789015, 0.28503215804087556, 0.3286993228628716, 0.24110165353368196, 0.3313686526550945, 0.2107618424030454, 0.3037556305064073, 0.2431579356321517, 0.2575959513742435, 0.24127485192918585, 0.2105339521012426, 0.2570038206645081, 0.23911536094627162, 0.2161775091103888, 0.20015305611934786, 0.2638815237379062, 0.24240400312590737, 0.1887047208331144, 0.209839161522408, 0.2225060793588015, 0.24278532162193323, 0.20251691303397612, 0.17570419341924748, 0.2264783647660782, 0.20230696238611334, 0.20533524920963542, 0.1255476090337736, 0.17821013113798545, 0.1879852335277563, 0.9245036463646925, 0.20052520786398587, 0.9162729255153996, 0.9220929641718374, 0.8891596913498981, 0.9142198942735754, 0.8633466590272132, 0.7990963592022173, 0.8386428118283821, 0.8055090877952047, 0.16759449480079114, 0.8621719211078479, 0.8458082295177244, 0.10437266718622318, 0.8078980462316359, 0.33970855407088174, 0.27151202631830806, 0.20254270240815053, 0.26989820401875775, 0.2411860301528984, 0.20961618101779322, 0.2801048894936943, 0.24598165134293448, 0.25425156720712416, 0.0981613519763318, 0.10900686435883022, 0.06218060118702762, 0.10250707390931624, 0.09787257089066592, 0.09079668940477337, 0.08749931595534521, 0.11153534797654197, 0.10895125814765483]}, "mutation_prompt": null}
{"id": "217646e7-7dfd-452b-b3e4-02f72329d0cd", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio + np.std(pop, axis=0).mean() * 0.05, 0.7 - 0.3 * eval_ratio)  # Enhanced velocity clipping with diversity\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98)\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced velocity adjustment by incorporating diversity measure for improved convergence dynamics.", "configspace": "", "generation": 59, "fitness": 0.36837569006234755, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8438054259491132, 0.8627890263921087, 0.8465456113788231, 0.8546976185171823, 0.8686615795854201, 0.8592029611861631, 0.851259397071355, 0.8453774805946268, 0.8535175813362718, 0.7113897632521946, 0.7208135571321381, 0.7358782625918392, 0.7176837126917881, 0.677206076507161, 0.6649581275949011, 0.6926384329803752, 0.6801832334071082, 0.6914340164278183, 0.11436125543483, 0.15275628009022935, 0.10853407647625424, 0.10889203663358238, 0.0678930396883981, 0.14601868915464422, 0.11387096032490751, 0.15618603186938218, 0.14247857004283737, 0.09576168725616752, 0.0985876617367274, 0.10554878950179991, 0.10900881648753291, 0.12861343741500209, 0.09014724128498053, 0.09426063220668857, 0.11554730952828396, 0.10487459735255122, 0.9317180370115895, 0.9309419836622157, 0.9365782565664816, 0.9268801386098459, 0.929389783171212, 0.9249022048499864, 0.9343511237666575, 0.9074276839208004, 0.9279169834848962, 0.7103030580697562, 0.7384011641815948, 0.7181120778408479, 0.7415610584091503, 0.688472291810325, 0.7008665941022547, 0.7220378588484994, 0.6929298442591827, 0.7195575127446678, 0.8576973296607865, 0.8700298984979948, 0.1704170154236706, 0.8589914286063621, 0.27714511336287107, 0.2200752443266435, 0.17804073568926526, 0.17752896627556658, 0.3851773472200585, 0.29815885588138924, 0.12800625494209983, 0.28420976309971424, 0.27336318796883474, 0.575251291003944, 0.2907917857819027, 0.29720933919736114, 0.3110917248465268, 0.24132929264285796, 0.24721436410638464, 0.26873644998856283, 0.28798080634008283, 0.30901021652214, 0.3025743415164953, 0.31168060468006165, 0.30093087030909726, 0.29613649256695296, 0.29958005808647825, 0.04666302103154807, 0.09187132107114537, 0.038594157587440114, 0.06382967534236106, 0.0641782288575018, 0.09299029106029344, 0.048021447253538296, 0.03149638326058779, 0.08252362864895624, 0.11993056570895733, 0.08288119569328778, 0.17477200016447536, 0.07841286951020687, 0.01759275499081636, 0.07059756802686812, 0.11346058297397543, 0.11222611223620638, 0.17191617406507487, 0.11715459795811023, 0.18289185070837555, 0.24712689175972058, 0.12087868178041083, 0.2164784242720058, 0.11409895692377792, 0.09028178907287243, 0.10197835547059075, 0.09583931759683273, 0.3539857496158638, 0.16900051507143776, 0.1157912716503191, 0.17788062770621782, 0.11682329512636602, 0.14925420271685275, 0.08066754467686021, 0.1454823278732189, 0.08069465029505063, 0.5440786256055132, 0.5612069945136269, 0.5746387249452265, 0.5934250375163042, 0.5918261689771303, 0.6154010896813402, 0.5660738442384352, 0.6105507399754717, 0.5450737978316655, 0.10818720719734498, 0.09354745648508833, 0.13882215300140743, 0.15794391899161309, 0.09664135928411544, 0.6646706936714938, 0.10002480262970004, 0.08118910567611604, 0.12308651719436348, 0.22436681396305902, 0.23519776650316448, 0.32924852842261876, 0.33687992841611303, 0.3351095488153508, 0.5222803739711808, 0.42054482038807306, 0.38976342553648435, 0.7520861268999562, 0.5952718280894302, 0.46140478773750815, 0.4879253707928658, 0.37255449053111767, 0.28133198748311516, 0.4184800696021975, 0.43705076748287597, 0.6090687993255962, 0.584083821986251, 0.29419201280607576, 0.3625012778344209, 0.2300352215875464, 0.30836710143580814, 0.24270184855168342, 0.32659397313566574, 0.1966217574174126, 0.2473507924762226, 0.15882021729446172, 0.2873033899995461, 0.24715783216830212, 0.18754142570492172, 0.26426701061736024, 0.24007670679323778, 0.22349326985617324, 0.18282839879449542, 0.2270996013591534, 0.2626314252893407, 0.16167696578171076, 0.207555325832954, 0.19744181100034397, 0.21221456393905236, 0.20039501927336545, 0.20185100097594688, 0.2018782709075022, 0.7732839047564233, 0.19072500252022728, 0.1871517162363181, 0.187444541789774, 0.18695859241962653, 0.9201559763814814, 0.2001286603254473, 0.927166561393947, 0.14247953648505596, 0.8793895593558357, 0.9236561394234872, 0.8140349179784958, 0.8325719419415888, 0.8614250036102455, 0.21053170617213357, 0.1544246139533918, 0.8641419032873474, 0.8309826492653141, 0.8248860714204513, 0.8099736937680988, 0.22127919898354953, 0.2366809364004686, 0.21147166087378377, 0.22235913086259984, 0.25494642820202384, 0.2716579814495663, 0.23731343209916855, 0.3614545977592476, 0.22769112415624004, 0.08195377765477829, 0.1000479886479414, 0.07785697601704633, 0.10478680130618045, 0.10136161755422712, 0.08586663376280135, 0.10514787183323537, 0.11100520582672291, 0.09276484470380819]}, "mutation_prompt": null}
{"id": "4a7c9ab1-8a47-46c1-8c28-4e7e43914edc", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Added adaptive mutation scale based on global best score to enhance exploration in high-dimensional spaces.", "configspace": "", "generation": 60, "fitness": 0.37361061453364036, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "70feba47-a8a0-4af4-bab4-ecb084296c14", "metadata": {"aucs": [0.8260327733287472, 0.870943859216845, 0.8685500558026841, 0.8559180964626965, 0.857171896810722, 0.8395207518090183, 0.8400922219845267, 0.8535646335817338, 0.8508711234537933, 0.707019696931872, 0.6910108267439059, 0.7088476003355173, 0.6855734101333194, 0.6999410020907099, 0.6460404673266308, 0.7046363009198693, 0.6294237974901054, 0.6307972123815044, 0.08764819486999698, 0.15677377760812983, 0.07097051142827426, 0.15444069162313245, 0.11255022131414139, 0.18072459392481122, 0.08962563106863419, 0.14311068202550448, 0.12928886833647524, 0.10872305248931591, 0.09388369103208738, 0.1134781449361757, 0.11702276841981296, 0.11619653382647577, 0.10571920875440788, 0.10809249495172535, 0.14089868781188564, 0.12013012699877823, 0.9342872585973033, 0.9338176857590511, 0.9357373905503608, 0.9297783082783255, 0.9304343759110976, 0.9277707551761669, 0.9420937759652092, 0.9028460275775857, 0.9354851195345324, 0.7268764386074666, 0.6997281166070268, 0.6663122007825714, 0.7127992192679391, 0.7154992943574325, 0.7242967238988038, 0.729404439231611, 0.7057981685934491, 0.6833694006563539, 0.8684645158266956, 0.3816544263498004, 0.8521588727340106, 0.9047848517051932, 0.21291868153349625, 0.8603177505735394, 0.2203621185517377, 0.7036015221799432, 0.8105215379422539, 0.2996935117032993, 0.13121588808199447, 0.2719537969618545, 0.2651194743031897, 0.34014442776398146, 0.26360230786647876, 0.2828333415284685, 0.30414580834744054, 0.28924353234095646, 0.28054255464372546, 0.2789699665306554, 0.25991163678998197, 0.34105009236505535, 0.30250080344653185, 0.13405907679454887, 0.31371165159938275, 0.3003795407435579, 0.29091879113426855, 0.026133469782773644, 0.10571366101332902, 0.2602268927304069, 0.060840896116596155, 0.09780187367839122, 0.07499443247695325, 0.12446043914365468, 0.01863125978571556, 0.11677431405420335, 0.09598108875449363, 0.07608837893372966, 0.26986034951600035, 0.09815860996495507, 0.03727410629202499, 0.04467243554585398, 0.1971541594303342, 0.13234403783619442, 0.08727804410629103, 0.16125130247964392, 0.1926795709200977, 0.3386174686587754, 0.1173719513684629, 0.09474829532084428, 0.23716366244767884, 0.1158693250555567, 0.14117638228180185, 0.0679111954002759, 0.27411034663339207, 0.12295188563206216, 0.11388118152920634, 0.07705967644133094, 0.1480291513304679, 0.20380341353159404, 0.0914998527082238, 0.18679624099475345, 0.143036116259198, 0.5452496107113807, 0.5718253918065812, 0.5766688370305542, 0.5813187772592833, 0.6548014333498327, 0.616216336407516, 0.5823248533130007, 0.6156994224222887, 0.6212883527577135, 0.11292463939060104, 0.11315064519534812, 0.14697011051487152, 0.15709139956264973, 0.09817661074341744, 0.07637690458047142, 0.11660417947580137, 0.1095827734795859, 0.156801944630369, 0.3949127257134012, 0.3431505145091378, 0.49858702722277226, 0.2193665799358463, 0.17331739761378462, 0.6176122785234772, 0.2696354066768507, 0.24748046665524892, 0.3525992063603287, 0.5445816319306612, 0.3057522913073075, 0.4504773754840711, 0.5094554309852604, 0.44289407569191097, 0.49789687382436565, 0.3936037696551844, 0.5040308944842121, 0.28986813355246, 0.24999179528843218, 0.31400147095694797, 0.20104502898661225, 0.303510627935372, 0.30608848773428643, 0.28127215405210537, 0.16958860154199995, 0.3041325701727834, 0.22488750797932966, 0.24072358112569436, 0.2208013382746149, 0.2231007881675643, 0.2103679890720388, 0.20727060537697573, 0.23070909273426032, 0.2602178891516247, 0.2790698897002002, 0.27912711821990566, 0.19754714976456955, 0.25138622225054374, 0.18264549028789856, 0.2517983568931905, 0.19640853904187783, 0.22286829895549987, 0.1828046107348572, 0.19137148963451123, 0.18218186226315947, 0.18457158712988975, 0.17837119038585847, 0.18646698915760274, 0.9112215131082066, 0.2002781958303006, 0.8995677713691287, 0.910413571837116, 0.8958423793836634, 0.9070049314055157, 0.8742301747141855, 0.8539566931044005, 0.8351504061031576, 0.8426862281608418, 0.15446435431751449, 0.844971882890473, 0.829684120812134, 0.10443529401349827, 0.7824443052588024, 0.21537653623140585, 0.34832364878001376, 0.19350914594243818, 0.24263346901411986, 0.321051179587186, 0.23044462997637938, 0.28637719283118845, 0.2845489365297942, 0.24703408979940733, 0.10329041172499909, 0.07791937112210012, 0.10247794424577628, 0.0795880548377973, 0.10040270446392474, 0.14925609123199013, 0.06317824473388867, 0.10809309543037382, 0.10871928867326186]}, "mutation_prompt": null}
{"id": "158a0233-793b-43f2-8534-79840b10db32", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n            self.w = 0.4 + (0.5 * np.random.rand()) * (1 - diversity)  # Adaptive inertia weight based on diversity\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Refined the velocity update process by adapting the inertia weight based on the swarm's diversity to better balance exploration and exploitation.", "configspace": "", "generation": 61, "fitness": 0.34991400148993573, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "4a7c9ab1-8a47-46c1-8c28-4e7e43914edc", "metadata": {"aucs": [0.8713018871695243, 0.8868957622329519, 0.8505672803870052, 0.8479786498394961, 0.8656234520840216, 0.879527644567065, 0.8751234081245554, 0.8803938244861839, 0.8399977170951922, 0.7285007369921058, 0.7452555866443755, 0.7381030989819368, 0.7286243325400494, 0.7015558094194676, 0.7228362123112972, 0.7248864629550003, 0.7271658327889654, 0.668221124830321, 0.10994702049628335, 0.15921245985178356, 0.15548194150539252, 0.0966966815868393, 0.1583498826443943, 0.18812675278573987, 0.12237091797282351, 0.14494554651642977, 0.13298430158221108, 0.13972685920299532, 0.1213291723961396, 0.09748442886472553, 0.15597961881974354, 0.11573697010848427, 0.11218685850216847, 0.10888949558343153, 0.1424358736516086, 0.10637615770716291, 0.924433381298018, 0.9207641809552579, 0.9335935430767551, 0.9226939654682692, 0.9076891510593252, 0.927626733982293, 0.926143337530949, 0.9077121170044617, 0.9307063544977933, 0.738626607621087, 0.7223334480575456, 0.7250080441900952, 0.7226193078214956, 0.7043116038057825, 0.7220575854082527, 0.7531227113304061, 0.7036026260427094, 0.7030917619767932, 0.8081390957286433, 0.2280234556619528, 0.14036110561110016, 0.3812182759466224, 0.3835247590832218, 0.2799866769557574, 0.17634567227790954, 0.1767861939903178, 0.23631518611413216, 0.3903937537511608, 0.13241660139373057, 0.29480948644766236, 0.28465874161932525, 0.3186973066279559, 0.28042469804797254, 0.2728898859595381, 0.2999768170630003, 0.3248511408237914, 0.26906601976853295, 0.2507307049459203, 0.2550950213772316, 0.2894221521236009, 0.3095694444069146, 0.3198933114397784, 0.3270007880147965, 0.29270801712688854, 0.28929610141701734, 0.1469369516225454, 0.006967623135096801, 0.0661950562465059, 0.059164155074841296, 0.08565503348098191, 0.012648712205544088, 0.10079901857049678, 0.04816590176062929, 0.10334642466923838, 0.11625885111241674, 0.08448467222486711, 0.13664978796755733, 0.10369122660026964, 0.029258857333335775, 0.03806648286000869, 0.10506040460416821, 0.16082143914555402, 0.1403414355023288, 0.14068321768137848, 0.18571750562512568, 0.16925182301358088, 0.09399758662794011, 0.125095531770952, 0.18096722658553588, 0.15456196374099795, 0.14063923889627328, 0.08491020817080985, 0.12011022434855223, 0.16321608909887853, 0.23732280691657226, 0.056701964994705256, 0.12562889536910204, 0.13575150404043124, 0.08188975290624168, 0.10643057985976334, 0.10531995178902254, 0.6294391677853345, 0.5690289961751029, 0.5606532418762246, 0.5446430913037534, 0.6361330091149597, 0.5833143362748414, 0.5958477093433994, 0.6040048656793702, 0.556738251246296, 0.06588408043075955, 0.1436439016021539, 0.09663287472316584, 0.10829179916466314, 0.10846041459827771, 0.12468270033738105, 0.09559038261882802, 0.09175262977060084, 0.1376714664223464, 0.48974603350717094, 0.3718370102135201, 0.174173061896428, 0.23753173006054074, 0.419498997408414, 0.43578243280711315, 0.34543180441064114, 0.2301488004173936, 0.16604733112246628, 0.18439619582306588, 0.4570861359744739, 0.30061720364427624, 0.38517284675574026, 0.4013362503933975, 0.46357304583045567, 0.2407383569139656, 0.5722804623854603, 0.2545848532380851, 0.2663870164242237, 0.2782129508018174, 0.20299095607711293, 0.39298041763221203, 0.2707246972535914, 0.35176602268039037, 0.21078324215387656, 0.26954156798196016, 0.2314944965549044, 0.25932008421364394, 0.233305715030652, 0.2531674140896907, 0.26391130343654945, 0.27213368525399395, 0.195619135448721, 0.31779612042999905, 0.270789681967764, 0.18598913930498506, 0.19190039735758502, 0.20781834595969673, 0.19176089948416297, 0.1786788523517756, 0.22349674349108795, 0.20709084992336624, 0.20683917493635717, 0.22292409227495136, 0.1918190227833304, 0.18670847278564007, 0.18768776652872443, 0.18656911836252799, 0.9269808392442029, 0.20094464041499527, 0.9328898577115847, 0.14250638922111425, 0.8978370228637778, 0.16808493412280545, 0.8377254508133636, 0.2130006541102275, 0.8219336311131411, 0.8246876171354041, 0.1543883446177562, 0.8959537100871707, 0.8491473042312572, 0.8370194585096359, 0.8109778266183467, 0.22226712282018268, 0.2023468443755425, 0.35612880925590373, 0.25550310675174837, 0.24259862184250292, 0.22202906219030982, 0.2541797217856542, 0.3310962594491491, 0.2464670171243567, 0.07365000992009174, 0.09794114483092686, 0.07060027358619225, 0.09908168627693581, 0.1109902021798056, 0.07906267938359557, 0.10797683707777883, 0.08490624447563966, 0.10565339980779098]}, "mutation_prompt": null}
{"id": "f4889baa-4335-4ef4-a6c5-a6afe4cefecf", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) * (1 - evaluations/self.budget)  # Increase weight decay\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Increased inertia weight decay for better balance between exploration and exploitation.", "configspace": "", "generation": 62, "fitness": 0.37277411292100004, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "4a7c9ab1-8a47-46c1-8c28-4e7e43914edc", "metadata": {"aucs": [0.8694322991620599, 0.8727704928773082, 0.8769882418907887, 0.8625328585612477, 0.8478426564956065, 0.8628602287122549, 0.8536323381918286, 0.864763503923951, 0.8586538441431982, 0.7676992515004639, 0.7235040751391173, 0.7412585019682216, 0.7279799254475603, 0.7410243696979959, 0.7005638518198359, 0.7149084241738581, 0.6945411986579639, 0.6994193268638218, 0.09842630801603935, 0.09879943048337259, 0.06728525119636819, 0.13871224107045654, 0.15530653914377213, 0.1599006444547082, 0.07987492254365658, 0.14394811526792217, 0.14000524832753236, 0.12252607701178053, 0.11490610757276987, 0.0814896599198277, 0.12275803626517623, 0.10947980979444216, 0.11732052846712193, 0.09794785817451523, 0.14392173322081858, 0.15130040172684223, 0.9346643984395486, 0.933824049119931, 0.9354908719031979, 0.929887916673006, 0.9300733533748401, 0.924351067085019, 0.9424284951412153, 0.9001142996518854, 0.9335166378067852, 0.7553987565040031, 0.7523795800152914, 0.7435638393037478, 0.7607569036504762, 0.7603149284538029, 0.7549667745243589, 0.7461559304829384, 0.7486496768681674, 0.7523699574056671, 0.9010974842621543, 0.22783252363187467, 0.8136197646661121, 0.9006790333097358, 0.37182210439962327, 0.2784639993609771, 0.15177137091562798, 0.9019494957114755, 0.3618701174457277, 0.2843520830877504, 0.1294556123257785, 0.29228441356444856, 0.28441688845459967, 0.381897659529462, 0.30712273064827844, 0.30114157742061676, 0.3122325352801171, 0.2857247033902235, 0.29428432893240575, 0.25915156476466017, 0.2715172202057119, 0.2995892439801434, 0.32622279089654804, 0.13475662878245365, 0.3021989253770052, 0.3012593937561785, 0.2732901712505341, 9.999999999998899e-05, 0.052796754620665354, 0.05996260047314028, 0.04461247233503951, 0.058103751220610844, 0.009007424526280228, 0.15341599788406435, 0.02131675375209563, 0.0877373107167756, 0.11148241853728158, 0.10376237307725766, 0.15650969459989028, 0.11733663983158371, 0.046601611918455466, 0.04309189008116354, 0.2154300640448873, 0.10269987808412973, 0.09533226200598222, 0.24772600854707438, 0.18753251771396284, 0.3392643940073926, 0.10654713472170219, 0.10244197973118263, 0.2424780445033824, 0.15092967522246203, 0.166168444457085, 0.08617067264879696, 0.2964925294942916, 0.12356608642562095, 0.11875120819709006, 0.12423616648477365, 0.1240577001480675, 0.20074228010621054, 0.0866016165737632, 0.198532266318853, 0.0821999260337607, 0.6214410163634558, 0.5624954098685833, 0.5650688779822608, 0.6333122813663321, 0.5801464220755188, 0.5774433526651651, 0.6045584828741126, 0.5789252467909864, 0.5750450707971081, 0.07970337177410625, 0.09104922608643862, 0.11164229552524485, 0.1418374956353442, 0.0983447012019063, 0.11454800805180143, 0.11483310101370714, 0.13018430728401142, 0.12143437940791224, 0.31851614984459575, 0.3040020867143105, 0.20270750027818685, 0.22959470235876123, 0.1733604899749327, 0.3837892310406352, 0.27653316471274814, 0.47017864316433144, 0.49109477991153405, 0.38938348595210537, 0.5148283118464159, 0.48076920258584765, 0.4241630695918903, 0.5732445306224668, 0.4245883025306453, 0.5499246050859478, 0.5777458223432008, 0.262640287984767, 0.24050767144810903, 0.34906339756551963, 0.19824084529095665, 0.2853619759886802, 0.18899140513288126, 0.3227900267109035, 0.18073403360664175, 0.2678980257590614, 0.24344696403243204, 0.28813879902255357, 0.2611515684694167, 0.22429560357533962, 0.25488684039126763, 0.21640798413409867, 0.25677085269218725, 0.28261720770931265, 0.1932608041093733, 0.2933725816597259, 0.17703510976454617, 0.2096666642932452, 0.180750539311886, 0.2510446232982274, 0.2235702370059739, 0.2080986362644941, 0.1802999760512315, 0.2067078221306018, 0.17326352321858085, 0.18450278064689507, 0.17841495377794636, 0.18654258634430776, 0.9206695264944422, 0.2003122870566333, 0.9251860001310854, 0.912002870680145, 0.9120721113666029, 0.9188024515584514, 0.8352114661490622, 0.8304390802917114, 0.854019395607489, 0.8948227702497099, 0.1540298845499627, 0.8852499608220096, 0.8621563105284755, 0.10443776378035996, 0.8233502533335552, 0.258218406300761, 0.23892466543672453, 0.19975515540975164, 0.2187535731340854, 0.2460746400553091, 0.2740734408396909, 0.24584887657270715, 0.36732922643316357, 0.27093355958629795, 0.07595621540755271, 0.08763384318804146, 0.12836601631082578, 0.09311896292619071, 0.09532217843268487, 0.16073536779186837, 0.08475140431635542, 0.09600010932557146, 0.11080451147192794]}, "mutation_prompt": null}
{"id": "4b1bcc6c-c696-43f0-a7ef-1c9ac1867a52", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * (0.98 + eval_ratio) * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced local search with dynamic mutation rate adjustment based on convergence speed.", "configspace": "", "generation": 63, "fitness": 0.36681218002194144, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "4a7c9ab1-8a47-46c1-8c28-4e7e43914edc", "metadata": {"aucs": [0.8237666106146675, 0.8805214306500149, 0.8627776877096363, 0.8651262934723312, 0.8609087876065242, 0.8443538652017075, 0.8421080288510039, 0.853198291228788, 0.8530848162318574, 0.7166321946531247, 0.7135251589910897, 0.7128754705968542, 0.650268916276209, 0.7055943652847173, 0.644447694086982, 0.6804671026280331, 0.6589456188064619, 0.6696404025940044, 0.09154789152094922, 0.1586160985717746, 0.11175888079197616, 0.13969733244038596, 0.1786607398999993, 0.18278341814845966, 0.09168481484252311, 0.18477009394171795, 0.14190981979075312, 0.11437192742053781, 0.12265282157450874, 0.08581244946236688, 0.0963082285718061, 0.08852401493009332, 0.11091732294130485, 0.09954511195623195, 0.13020731857357626, 0.11475417634671847, 0.9347669558879401, 0.9344504184476058, 0.9363787363087998, 0.9299119524428707, 0.9297672184423862, 0.9237197715973584, 0.942141647810044, 0.9008177787365241, 0.9354886887975358, 0.6901764672839418, 0.6932151500439232, 0.6775942672228976, 0.7091851430110381, 0.7402734866538752, 0.7122982444348243, 0.7268929051062267, 0.7092607413299891, 0.6745005425332888, 0.8298092503888977, 0.22745810580719839, 0.37803709574738464, 0.8926344251979311, 0.21975981503922026, 0.2790163176388871, 0.23285253127959205, 0.7981476664518984, 0.8137136310080118, 0.3781018931947022, 0.1304937526284906, 0.2582118237798936, 0.2594204170300961, 0.3568804320741169, 0.26960487842789527, 0.2717956263380167, 0.2793892407762344, 0.2798625105812015, 0.2651649420158707, 0.28336685042456145, 0.2519719025149575, 0.25625666769903943, 0.30037796433597286, 0.13412217979862906, 0.2969692836979442, 0.2931977022581427, 0.2933874525369201, 0.05508606865601928, 0.04148792474794827, 0.08258673204711087, 0.043161501746134645, 0.11766321877240793, 0.013783252987027428, 0.10611231813516497, 0.014911294292792032, 0.10358993110829673, 0.09253394900217426, 0.05182168501550899, 0.12475391214895959, 0.10882428945700706, 0.03296020298953972, 0.040501263762785844, 0.18418255548470774, 0.1381684240365676, 0.100933140692688, 0.18765683235357022, 0.1935178226607983, 0.20332421584771032, 0.1142662513300371, 0.09793831138363263, 0.20187119271689313, 0.19263568544060006, 0.15184705349003236, 0.07578177311478862, 0.16471840359356316, 0.14254010162393038, 0.08966596347352607, 0.1421560489181909, 0.1466503436092167, 0.21312623006201703, 0.09330435908505152, 0.23334248117902412, 0.11761171876950649, 0.5698504827179041, 0.5439642580670438, 0.599536446730023, 0.5496779238145604, 0.6004729717314072, 0.654822315899501, 0.5888605120557169, 0.6193023099502117, 0.5769302503587077, 0.09057789420244611, 0.09945316404861837, 0.10066713402459992, 0.13037473908029917, 0.08457843483112426, 0.07673394506236364, 0.11572386043282534, 0.08067585747894723, 0.1217467459045416, 0.5048405232805102, 0.2582015209582924, 0.22739918813362348, 0.21942918286025226, 0.17494740981593093, 0.5975488118618048, 0.2706491493291592, 0.403129367385491, 0.6976466130337355, 0.4148829077950835, 0.4400435356156357, 0.36725532335666444, 0.4272956612091462, 0.5873808440475843, 0.5106637640781706, 0.27938495961068177, 0.41285633865678295, 0.5372846096216648, 0.27318683651278997, 0.32076316973251173, 0.23131201440811033, 0.31612059176656515, 0.2430367475652372, 0.3017621508451732, 0.19634886137341923, 0.3902581906949213, 0.21065367807670732, 0.2212916054888563, 0.27319364720441885, 0.2356867467123136, 0.1876040473200148, 0.2201753835795447, 0.28478342672099044, 0.2670303741592869, 0.24517244787317571, 0.24771919712082913, 0.19765768228832126, 0.2511130876794232, 0.18313527178383338, 0.2117108629113199, 0.2103751613334781, 0.19080430444678387, 0.18353055247187444, 0.19750603000222278, 0.17575170771395132, 0.18451346853153305, 0.17838913537997436, 0.18640763086247736, 0.9156631976559699, 0.20029342283690899, 0.905312476043808, 0.9079967791886665, 0.9060848591474611, 0.9173877211915042, 0.8457351332949544, 0.8343358161082692, 0.8326123905242316, 0.8427108265585675, 0.15409587032786598, 0.8817697540279195, 0.8717635396533081, 0.10440389811055284, 0.8532234009262543, 0.22585247791067065, 0.28067277623644227, 0.20497913337422047, 0.24176027903036246, 0.24323223933231586, 0.23969137207062507, 0.27591467354779875, 0.2529490828625802, 0.2712925983660869, 0.10020043718568361, 0.10239902160887082, 0.11686355167564666, 0.09986735722805262, 0.09975835121066579, 0.13373390560160447, 0.07317144027873945, 0.10312799389177785, 0.11216601242246105]}, "mutation_prompt": null}
{"id": "626b4d87-9d38-41bd-80be-602c720eba6b", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 5  # local topology size (changed from 3 to 5)\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.5 * (1 - eval_ratio) + 0.5 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhanced local topology size to improve convergence by focusing on smaller neighborhoods.", "configspace": "", "generation": 64, "fitness": 0.358281062006402, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "4a7c9ab1-8a47-46c1-8c28-4e7e43914edc", "metadata": {"aucs": [0.8471737904909327, 0.8682212309427901, 0.869731167168809, 0.8474583919399269, 0.8482374820754051, 0.858313799382836, 0.8122524190303468, 0.852247008390377, 0.8344010380726041, 0.6933773453088679, 0.6539807704503899, 0.6730713426330228, 0.732713645421935, 0.6486212165410976, 0.6705427569223937, 0.6730809190321614, 0.6751087949015127, 0.6834710447541599, 0.1120993081030871, 0.1409846685146735, 0.10373426587713852, 0.1106435918950206, 0.11038576159897762, 0.18397125077149423, 0.08444942644644637, 0.14327318364985642, 0.08265681549238946, 0.08195337502155708, 0.08714498585803254, 0.13224686177144573, 0.10414066591641713, 0.10723139826504646, 0.09016079253458065, 0.10965771331688978, 0.09537132349672317, 0.11557094834923609, 0.9340242722083688, 0.9344242711822915, 0.9420491879158298, 0.930533798253381, 0.9337236514534257, 0.9320432952910506, 0.9425014477996605, 0.9146551471178817, 0.9385393473053102, 0.706388745986858, 0.7238723090739132, 0.72151226727915, 0.7105681827125797, 0.7323011728512367, 0.7316109118194172, 0.7281870074049566, 0.7020424757706929, 0.6762098501399876, 0.392680998752749, 0.2277705203947592, 0.22500816442802052, 0.38314410071203175, 0.21168429321183824, 0.1927445790457064, 0.7190438453277112, 0.1775496119774258, 0.23529201227316554, 0.28953358547348074, 0.13004143995061224, 0.27843062872020297, 0.2757247095718868, 0.27767605944005314, 0.3974349531763337, 0.27192823838332847, 0.31998582775668716, 0.3206990429712723, 0.24798737158451856, 0.2655795180211571, 0.24995845311299714, 0.13268459802318233, 0.32470772983757357, 0.30388838073222224, 0.2828750042506728, 0.3043894250146102, 0.13341949966815414, 0.06510148313393405, 0.16176459057857262, 0.018544401412738276, 0.07995281780066765, 0.013635160639642763, 0.050484542377815744, 0.08118564068423917, 0.05843031936596832, 0.07554415736987796, 0.10065493345042864, 0.09633207071883076, 0.13200035022712642, 0.07865966993771378, 0.008235221905570356, 0.06610448200668395, 0.2078548210126382, 0.16732404781104926, 0.1384492978957742, 0.10042169831260639, 0.09109931046327313, 0.17032828670956535, 0.10987388075269977, 0.07898042435754282, 0.2810892465675089, 0.16501605693928412, 0.13465243589494535, 0.08223935834670215, 0.14131204200748793, 0.10496702358323495, 0.12148789252871262, 0.14873427022275987, 0.1306569463657541, 0.14717994677510737, 0.08245663150692595, 0.08068373679713425, 0.08457510641431143, 0.569974904068498, 0.5653858405633141, 0.5475991283942971, 0.54717655332638, 0.5381429199265939, 0.5756281392684848, 0.6065563494951507, 0.6104938495359853, 0.5912137728707725, 0.09842781786321408, 0.13641670423918573, 0.09359224370109043, 0.14288447850341401, 0.0483050730938448, 0.06846393173545295, 0.07976887826541024, 0.1304427895451047, 0.13700004012907885, 0.22889745127006023, 0.6841567724740827, 0.5873256213781688, 0.3929189572360683, 0.4977271789722618, 0.331943609554344, 0.42325584662458415, 0.2066346760694726, 0.26736052161044466, 0.3640093024003286, 0.4015409690500419, 0.4217585596777028, 0.5490818676834839, 0.5170142696000047, 0.3752622661846866, 0.2633344455023867, 0.43995643433124276, 0.5130726564834641, 0.29269840910252265, 0.2860780869035985, 0.2116294235678543, 0.4233257730124569, 0.2756173794259603, 0.3720120318761678, 0.19895347670358565, 0.30868557016301645, 0.2511788851029, 0.23620575736714422, 0.19971640650939348, 0.21969268091034178, 0.2070879274942936, 0.2410407496311895, 0.29132408079160343, 0.2279686192219167, 0.2381388988082509, 0.23110961966064847, 0.20879975824960173, 0.19925263227889223, 0.19772491219771104, 0.22231497052029248, 0.7853352939559287, 0.2519807732685251, 0.18928656418915069, 0.1969954926494777, 0.1869047866773048, 0.18733696796515165, 0.18744569763710783, 0.18749469988693268, 0.923348272495041, 0.20025455842584905, 0.896849959707121, 0.9034939023447376, 0.9056207254186, 0.9159819889452279, 0.8579976764495734, 0.8363430527474721, 0.8344444499194645, 0.21040916184200675, 0.15378325258899517, 0.8711497334556764, 0.80643127880808, 0.8149455499817604, 0.8086191788034418, 0.3628244049729267, 0.2505175695037707, 0.24247696377726902, 0.2981932066670365, 0.24621301118938177, 0.2467109116359667, 0.25117196877567727, 0.2557592262737849, 0.2426576959138047, 0.10528729120198388, 0.04680086584752208, 0.09065208817753845, 0.10550330063632918, 0.09930298450164188, 0.0804742620015737, 0.0954399223327328, 0.06509514050952037, 0.09715195458253278]}, "mutation_prompt": null}
{"id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduce a small tweak to the cognitive parameter `c1` formula to improve balance between exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.3753845587201295, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "4a7c9ab1-8a47-46c1-8c28-4e7e43914edc", "metadata": {"aucs": [0.8605019590262813, 0.8718794743826733, 0.8903309415335436, 0.8627250280999227, 0.8604009917863479, 0.8592237888605186, 0.8667844312538512, 0.8720789094800057, 0.8732789851184516, 0.7215323932199004, 0.7418796831128537, 0.7308382947348214, 0.7092425774095139, 0.7045068417972404, 0.6801983246406957, 0.7273854250129792, 0.703260108981087, 0.7399154761266435, 0.08855450590296676, 0.6857178228031242, 0.07329609211274313, 0.12174498153577473, 0.11560144941802042, 0.12850384222185163, 0.08051834315096917, 0.09315867972240233, 0.08908755031834192, 0.12202816553140017, 0.14246824458802043, 0.13076917692397005, 0.13134662619391835, 0.09972219565605867, 0.10795082477805484, 0.09546470997244161, 0.08577606809291771, 0.10771448484730539, 0.9327473937584077, 0.9337364531332549, 0.9366537222545053, 0.9295553931428597, 0.9306047238334422, 0.9352094859275482, 0.9420036986803735, 0.9150482139283173, 0.9353561772238579, 0.7614997534769729, 0.7394168198663701, 0.7425073827260638, 0.761405797726678, 0.7897015941330201, 0.7677332956517278, 0.7364377717025766, 0.7376885043769473, 0.749942218654316, 0.2290513015689004, 0.8595593746458088, 0.22738464895954846, 0.8806660293094688, 0.21206823377965622, 0.2129392839174271, 0.2220412606872192, 0.21973382448448575, 0.8516099814478726, 0.2708262327409653, 0.13119629383756148, 0.1305827097882688, 0.26814252614165335, 0.3182424803258842, 0.28539880057083544, 0.3212147293389238, 0.3208322575863062, 0.27983717838316147, 0.27146490216589525, 0.2774354646405903, 0.25083313868949186, 0.28234090354690733, 0.30000760975228946, 0.3426240001568721, 0.30616637803422286, 0.30649218228713837, 0.3055018619325027, 0.051381703519232325, 0.10493104217514215, 0.03649781905528271, 0.07468753705190434, 0.010119429111052125, 0.09546805850073248, 0.03624826696147032, 0.06450448661716524, 0.08754790379084465, 0.14261073064074115, 0.12220727501965489, 0.1674166763741789, 0.09218704995907123, 0.0549870648026719, 0.05895354135338171, 0.16693988770457113, 0.10090546135398903, 0.10909538636573235, 0.22978807632912523, 0.1826524720367091, 0.25923583337685663, 0.10984949942954658, 0.11318735150688097, 0.18133912611983782, 0.19825365471797385, 0.1867045881251278, 0.12787345924261517, 0.25140963753388346, 0.1322427430975215, 0.08519250069183903, 0.08661682930571535, 0.17748038772479335, 0.18951230338960012, 0.09036482336903773, 0.15596598589109412, 0.12772325351488345, 0.6413532858710946, 0.6015901181576493, 0.5639199770952609, 0.5550710304668058, 0.6658046268827397, 0.5662159879560948, 0.6076784254750442, 0.6102148677191074, 0.6257121487732887, 0.12910056490619248, 0.0636186666764561, 0.10251414322591501, 0.10057894571543002, 0.10945080480104274, 0.13738613848197223, 0.1081104058192417, 0.10774294966458564, 0.10943546530902115, 0.544940064806061, 0.21287919023103385, 0.21467774243123772, 0.2557686725949524, 0.5643252633842335, 0.3733310289866155, 0.279501565864798, 0.7275242028175202, 0.6692315180369967, 0.45811246555881024, 0.42368187141635594, 0.4080406492150972, 0.4906508423770337, 0.5480062618774382, 0.5720569642589368, 0.19980879781556182, 0.5190952742460876, 0.2781376726936189, 0.3329757340796382, 0.27389941004646023, 0.2136538814308685, 0.2645355943658063, 0.22456851500919928, 0.39597073185707055, 0.24482536610120842, 0.2916060077400243, 0.21657475366322299, 0.2674257829918858, 0.2364317511052353, 0.2148028144079378, 0.2906443629171298, 0.23930435921918547, 0.23197586748831367, 0.22545179562170936, 0.3094051689203138, 0.258447916842356, 0.18352559286315373, 0.2053071853003272, 0.2069951964140363, 0.22583561786113837, 0.21093470056672403, 0.21001587033481406, 0.1742805683709483, 0.2212332179781772, 0.22241157379364063, 0.18734370933601852, 0.178210767970159, 0.18791916003464282, 0.9223999593790316, 0.200175241709603, 0.9290661516031341, 0.9154213476707903, 0.9100716569236599, 0.9235848523191406, 0.9033170062038689, 0.7972257906012286, 0.890911169438927, 0.9098454569370474, 0.16756104976932507, 0.9104727542035254, 0.8745556743463331, 0.10449689767073, 0.8252831101614553, 0.2291540990421942, 0.2550470197103284, 0.39891544616718433, 0.22853898161638875, 0.23912578260791018, 0.2396808667346848, 0.33388881639226087, 0.24652721431103208, 0.21232289876683463, 0.15204176922648893, 0.09065032199970269, 0.13619446692741388, 0.08540068277301927, 0.11102930856518001, 0.09311733848285986, 0.08180585180054223, 0.0834162828065762, 0.09112660741432133]}, "mutation_prompt": null}
{"id": "6cbd8743-3bab-4392-925b-ea5d30483e90", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio**1.5)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhance search efficiency by increasing population diversity through a small tweak in the mutation probability formula.", "configspace": "", "generation": 66, "fitness": 0.37170602314835616, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8605019590262813, 0.8703733421753395, 0.8903309415335436, 0.8602321689180006, 0.8604009917863479, 0.8592237888605186, 0.8667720843433384, 0.8720789094800057, 0.8732789851184516, 0.7215323932199004, 0.7418796831128537, 0.7308382947348214, 0.7092425774095139, 0.7045068417972404, 0.7121985183976134, 0.7273854250129792, 0.703260108981087, 0.7399154761266435, 0.08855450590296676, 0.6857178228031242, 0.07329609211274313, 0.12157978890291965, 0.11560144941802042, 0.14254359016509532, 0.09159833860208078, 0.09315867972240233, 0.08908755031834192, 0.12124841218444071, 0.14246824458802043, 0.13076917692397005, 0.1229675323004027, 0.09972219565605867, 0.10795082477805484, 0.09546470997244161, 0.08577606809291771, 0.10771448484730539, 0.9327473937584077, 0.9337364531332549, 0.9288469173005733, 0.9295553931428597, 0.9306047238334422, 0.9352094859275482, 0.9420036986803735, 0.9150482139283173, 0.9353561772238579, 0.7614997534769729, 0.7394168198663701, 0.7425073827260638, 0.761405797726678, 0.7897015941330201, 0.7677332956517278, 0.7364377717025766, 0.7376885043769473, 0.749942218654316, 0.2290513015689004, 0.8595593746458088, 0.22738464895954846, 0.8806660293094688, 0.21206823377965622, 0.2129392839174271, 0.2220412606872192, 0.21973382448448575, 0.8516099814478726, 0.2708262327409653, 0.13119629383756148, 0.1305827097882688, 0.26814252614165335, 0.3182424803258842, 0.28539880057083544, 0.3212147293389238, 0.30123667470647475, 0.27983717838316147, 0.25576351341017767, 0.2774354646405903, 0.25083313868949186, 0.28234090354690733, 0.30000760975228946, 0.2705175777912956, 0.30616637803422286, 0.30649218228713837, 0.3055018619325027, 0.051381703519232325, 0.0604258196371924, 0.03649781905528271, 0.07468753705190434, 0.014519530237322553, 0.00173251362897886, 0.03624826696147032, 0.06450448661716524, 0.08754790379084465, 0.14261073064074115, 0.12220727501965489, 0.1674166763741789, 0.09218704995907123, 0.0549870648026719, 0.05895354135338171, 0.16693988770457113, 0.07294111532868863, 0.10909538636573235, 0.22978807632912523, 0.1826524720367091, 0.25923583337685663, 0.10984949942954658, 0.11318735150688097, 0.18133912611983782, 0.19825365471797385, 0.1867045881251278, 0.12787345924261517, 0.2406555271404116, 0.12592495842535323, 0.08519250069183903, 0.08661682930571535, 0.17748038772479335, 0.18951230338960012, 0.09036482336903773, 0.15596598589109412, 0.14026425414166865, 0.5597895970229179, 0.6015901181576493, 0.5639199770952609, 0.5550710304668058, 0.6658046268827397, 0.5548044939057154, 0.5868015952948817, 0.6102148677191074, 0.6257121487732887, 0.12910056490619248, 0.0636186666764561, 0.09313746174053117, 0.10637001225087528, 0.10945080480104274, 0.13738613848197223, 0.10261920131174596, 0.10774294966458564, 0.15436685249402748, 0.3529190449839844, 0.21287919023103385, 0.19295143258358616, 0.2557686725949524, 0.5643252633842335, 0.3733310289866155, 0.27959240073384195, 0.7275242028175202, 0.6692315180369967, 0.37261839775455197, 0.42368187141635594, 0.4080406492150972, 0.45149983206440203, 0.5480062618774382, 0.4794285621054729, 0.2000473567940566, 0.5190952742460876, 0.2781376726936189, 0.3329757340796382, 0.3254296243624213, 0.2136538814308685, 0.278973235360122, 0.22456851500919928, 0.39597073185707055, 0.203195917359833, 0.2916060077400243, 0.23272525936520938, 0.2676686857011553, 0.2364317511052353, 0.2148028144079378, 0.2906443629171298, 0.23930435921918547, 0.23197586748831367, 0.2437748226695704, 0.3094051689203138, 0.258447916842356, 0.18352559286315373, 0.2053071853003272, 0.2069951964140363, 0.22583561786113837, 0.21093470056672403, 0.21001587033481406, 0.1742805683709483, 0.224412588385125, 0.22241157379364063, 0.18734370933601852, 0.17821940498697897, 0.18791993462458767, 0.9223999593790316, 0.200175241709603, 0.9290661516031341, 0.9154213476707903, 0.9100716569236599, 0.9235848523191406, 0.9033170062038689, 0.7972257906012286, 0.8603095573193713, 0.9098454569370474, 0.16756104976932507, 0.9104727542035254, 0.8745556743463331, 0.10449689767073, 0.8252831101614553, 0.2291540990421942, 0.2550470197103284, 0.39891544616718433, 0.22853898161638875, 0.23912578260791018, 0.2396808667346848, 0.26221550409711203, 0.24652721431103208, 0.21232289876683463, 0.14232279480682375, 0.09065032199970269, 0.13619446692741388, 0.08540068277301927, 0.11102930856518001, 0.09311733848285986, 0.08344285125830542, 0.0834162828065762, 0.09112660741432133]}, "mutation_prompt": null}
{"id": "064c11ab-6cac-49be-88f6-c98e7993fe11", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.3 * np.random.rand())  # Adjusted inertia weight decay rate\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjusted the inertia weight decay rate to enhance the balance between exploration and exploitation phases.", "configspace": "", "generation": 67, "fitness": 0.369507233984822, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.30.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.884589777861109, 0.9015225317659511, 0.8972566689836373, 0.904794668755641, 0.8889622144092131, 0.9033945062511665, 0.8953512454247724, 0.9017763857722304, 0.8975756594389626, 0.7968318435252375, 0.8019381317655924, 0.8094167365933035, 0.7963399408577235, 0.7833007893722881, 0.7859543821829411, 0.787561564590548, 0.7659315519148038, 0.7538761941256225, 0.12207446065032623, 0.11801361099049101, 0.11557060547125786, 0.1175873729282021, 0.1334730427524733, 0.13313872549551908, 0.09556006721875288, 0.12446210673082825, 0.09883591626844956, 0.10421530860732797, 0.0690738845305161, 0.07911986489590217, 0.12454709922875884, 0.077995554210875, 0.08363773246540929, 0.09582900216097912, 0.13206315144776382, 0.05572405830530858, 0.9255514800111942, 0.9229190660134006, 0.9215378175246519, 0.9261841491403044, 0.9174967967701712, 0.9251355467742184, 0.9338649138552882, 0.907949341694798, 0.9263115443063005, 0.788431483770305, 0.8276470306389778, 0.7802950092675451, 0.8299374754048984, 0.8189868939381849, 0.8143837067344913, 0.8174871610688803, 0.7695135627457769, 0.779419444568994, 0.2290388357129869, 0.17067498853295837, 0.21068685669174214, 0.3796874171207041, 0.21919410867907962, 0.2128150736808172, 0.23280733004408793, 0.17787791955054877, 0.2352640960878397, 0.3129500432362453, 0.13019934161163582, 0.3325821159427814, 0.2981054466467594, 0.35240730015841026, 0.3369325480089981, 0.35470504516981904, 0.3575096726700533, 0.3221574198093602, 0.28924632605215617, 0.2707055103917413, 0.2767170507799911, 0.34046568926762033, 0.33821058812312477, 0.30479544239182643, 0.3088090525721817, 0.1329062982343696, 0.32448699645089485, 0.026252760978869638, 0.16467315611591604, 0.004967851458888672, 0.05558748889061915, 0.18165737139161242, 0.04774321128589054, 0.07421862327584183, 0.02014030065947159, 0.17985238698381967, 0.10005441600540832, 0.05735134304145906, 0.08160288684851147, 0.09498657000439437, 0.018419185010077443, 0.10789500958428111, 0.14402730545802933, 0.13434762106770526, 0.17578372125561637, 0.19174821871637626, 0.16833145385587467, 0.21119956684538532, 0.12380959387462276, 0.12081346178924557, 0.17075317588929884, 0.21750427492307445, 0.287864031729411, 0.14084424251712313, 0.2146102401806409, 0.12078381361441992, 0.08349892362633304, 0.16230803948370665, 0.20461189048524753, 0.14242215334939923, 0.08280478074280928, 0.17895005723862945, 0.08396262162935442, 0.6146111378417254, 0.5579050180061551, 0.6850889910493603, 0.6542305216893607, 0.6057756740162025, 0.6166217663600618, 0.6346142391180702, 0.590378154591817, 0.6284932249933315, 0.14045883273565818, 0.09482028078324856, 0.07760349145150935, 0.132072650244483, 0.07951897406428632, 0.10529599239205067, 0.08164434927547504, 0.1308006914309906, 0.14535877703418332, 0.3519277341618686, 0.6302025882951405, 0.24182634992479812, 0.6752273764814954, 0.35132194049028076, 0.4309856992782557, 0.2832419816405103, 0.6813054453521086, 0.21471833055521072, 0.40886249240658745, 0.35331050303331435, 0.48638092154897306, 0.4207672350288968, 0.3015664165967896, 0.47584501222096265, 0.5393470489115456, 0.5382957054480659, 0.2471640891361815, 0.35685322989431256, 0.25122705480935015, 0.24139554083462822, 0.3435035187333899, 0.23176457942280126, 0.4280964849530805, 0.1942975615145558, 0.36312208360919884, 0.21010323840834066, 0.24412557677284752, 0.22412696082639882, 0.23585891632054434, 0.3015625231721576, 0.26020637965626314, 0.23025860652353536, 0.2960000721759346, 0.30006684017471796, 0.2166564992334581, 0.19791041143928523, 0.22633363126321848, 0.17880004286729456, 0.18809340934348584, 0.20328417002499355, 0.22624511814593007, 0.18089131140530013, 0.18489818829354887, 0.20726961101642505, 0.12549735950009966, 0.17803237761318214, 0.1869187398173503, 0.9296062223468744, 0.2004113847596103, 0.933028759050835, 0.14272533470781468, 0.9292499131591541, 0.942351923840174, 0.8733637698889595, 0.901008363078629, 0.8796707120287119, 0.9158343817787575, 0.15433346045671192, 0.917505582142019, 0.8841903265871265, 0.10453197840261252, 0.8599977018249667, 0.20040410118004182, 0.3438356438887671, 0.27194958985590567, 0.2530845259278477, 0.21304975523484126, 0.24788595514366973, 0.253080412107175, 0.3065924292266915, 0.26956422333371166, 0.09415910110147274, 0.11682575399790984, 0.08808558348418283, 0.09005981665427021, 0.09449948091308047, 0.10321284438223743, 0.0970837897816853, 0.08850422087928633, 0.09421677861686317]}, "mutation_prompt": null}
{"id": "a0aeaec9-d23b-410d-be99-343c830e8b90", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 1.5 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better convergence speed\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjust the cognitive parameter `c1` to improve convergence speed.", "configspace": "", "generation": 68, "fitness": 0.36653234579138616, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8912184230895629, 0.8860022309363702, 0.8983020908131696, 0.8865506714332757, 0.8825686286322383, 0.8901905900660164, 0.8806035219820886, 0.884142843607634, 0.8830942825737879, 0.7554632659547721, 0.7788234549671553, 0.7449424916567973, 0.7306495273261084, 0.7338805684774246, 0.7651367045157352, 0.770823681914903, 0.7589303192402309, 0.7585812682880356, 0.11019353734476867, 0.1591213477714939, 0.06331221457422964, 0.10065501535571098, 0.09226164311498086, 0.14034332304029018, 0.09676752077336737, 0.15600594754959507, 0.1107029474096557, 0.08865285707691362, 0.12368945172848833, 0.09132320273220451, 0.12120458795405342, 0.10924953854750474, 0.08069627146748948, 0.11458961394880862, 0.1150017680298634, 0.08136904042403548, 0.9287240798746328, 0.9423149417261952, 0.925093449647419, 0.9241524997781919, 0.9274573643634282, 0.9286239477470286, 0.937359788031987, 0.9107974679884085, 0.9272323467102728, 0.8163412060387755, 0.7920964704049003, 0.7667824109100406, 0.815411717436924, 0.8156762803145053, 0.8039871404609449, 0.8055183694890924, 0.7983516699784037, 0.7553281994450282, 0.22927900167102466, 0.22748458436120578, 0.22763500169139683, 0.39064354344210506, 0.8893144841952358, 0.21245722941722311, 0.13106398139393483, 0.23328471705937004, 0.4505813575651296, 0.3998059910795192, 0.13189430507294964, 0.32267748857651135, 0.3066991434507794, 0.34030830934621004, 0.33490503079054, 0.3798828697777329, 0.3623610718837922, 0.33427132396756076, 0.31311048102062633, 0.2886058396743141, 0.30948208583956816, 0.3616046227022319, 0.34126876723826893, 0.3450078938268625, 0.33198176540139157, 0.1265216595249824, 0.3051497242863349, 0.026942489026213323, 0.05134968817315644, 0.18708672246187896, 0.038717679455801735, 0.06617687950895124, 0.010852649580569418, 0.10083922516088384, 0.07831204129609237, 0.19152795907752163, 0.11998851246915421, 0.08406335338569593, 0.111697326496905, 0.05310727008988181, 0.046526474417852626, 0.034410578580197804, 0.16523279185116502, 0.12324896565300625, 0.12402237649193137, 0.18421758018982615, 0.12557308202611617, 0.47219172856965663, 0.12926049288510189, 0.09092405001591741, 0.1237011611282387, 0.26148263099680347, 0.22889612935624237, 0.13304799989379645, 0.28356506138727855, 0.19171705705953124, 0.05763787262653519, 0.15570461210179143, 0.17631456671018308, 0.17870368076498166, 0.10130604470761095, 0.1862218754196503, 0.10698893631306361, 0.5888849380354969, 0.6173513480046626, 0.6362197149768521, 0.5699890958455607, 0.6080497139163783, 0.5787466526949987, 0.6204995790464896, 0.6193418631330476, 0.6505595315176246, 0.11376125071440235, 0.09151161493028193, 0.08936804551766764, 0.09916573049335398, 0.1168747634163203, 0.07284561028921921, 0.130016389134752, 0.10050658090500508, 0.09701085634741957, 0.20717447461425376, 0.4998548096166249, 0.17603648967109786, 0.22332494557952998, 0.45236944700652004, 0.4633471217677405, 0.32556498980662096, 0.5057491084105002, 0.2636837687325765, 0.44981974422762594, 0.40924239102636994, 0.22695730603789066, 0.46154268954757705, 0.5440866585475646, 0.493442297879785, 0.33633800928740565, 0.5013701506740658, 0.2391446128569672, 0.27045627366798075, 0.3231021737129446, 0.22595583354893445, 0.26834388273880894, 0.2783410313183863, 0.25959466428895195, 0.2093648698978431, 0.22615810512151224, 0.20325990878506095, 0.2684689847586258, 0.19287883837461617, 0.20372957712377326, 0.26757699061530305, 0.24240687137403638, 0.25702355622665485, 0.2643852488489551, 0.25376823882780597, 0.25079014661732624, 0.17454492283256695, 0.2033612559095399, 0.18443470839853193, 0.2518552667666816, 0.1930739224773802, 0.185852588680113, 0.19034967721256546, 0.22403187250132162, 0.18891575659128335, 0.1872120107703641, 0.17841938763015186, 0.18682610599470995, 0.9313516382113463, 0.20045540430916908, 0.9349287535354613, 0.9266722700972593, 0.17019602166101744, 0.16767847023526972, 0.8745901084786938, 0.8361222443015504, 0.8578065907538415, 0.8694551736393153, 0.8453105213299384, 0.9022504192555793, 0.9022590402781899, 0.1045113379923297, 0.8607839044130354, 0.2458928589694983, 0.22107645861548886, 0.21563640774593718, 0.20325449160393205, 0.33740148364094735, 0.2396217064949283, 0.3059179350055652, 0.25277510714690166, 0.2599355340569055, 0.09611165981088865, 0.10073675834527762, 0.0731885951157768, 0.10820881531398796, 0.11086023631724762, 0.1063059901959359, 0.07541637728889128, 0.06634486102300907, 0.0885609856823909]}, "mutation_prompt": null}
{"id": "0a18df25-ac79-4da9-bbda-d1d790cd68f8", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.9  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Increase the cognitive parameter `c1`'s initial value slightly to improve exploratory capabilities at the beginning.", "configspace": "", "generation": 69, "fitness": 0.3753845587201295, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8605019590262813, 0.8718794743826733, 0.8903309415335436, 0.8627250280999227, 0.8604009917863479, 0.8592237888605186, 0.8667844312538512, 0.8720789094800057, 0.8732789851184516, 0.7215323932199004, 0.7418796831128537, 0.7308382947348214, 0.7092425774095139, 0.7045068417972404, 0.6801983246406957, 0.7273854250129792, 0.703260108981087, 0.7399154761266435, 0.08855450590296676, 0.6857178228031242, 0.07329609211274313, 0.12174498153577473, 0.11560144941802042, 0.12850384222185163, 0.08051834315096917, 0.09315867972240233, 0.08908755031834192, 0.12202816553140017, 0.14246824458802043, 0.13076917692397005, 0.13134662619391835, 0.09972219565605867, 0.10795082477805484, 0.09546470997244161, 0.08577606809291771, 0.10771448484730539, 0.9327473937584077, 0.9337364531332549, 0.9366537222545053, 0.9295553931428597, 0.9306047238334422, 0.9352094859275482, 0.9420036986803735, 0.9150482139283173, 0.9353561772238579, 0.7614997534769729, 0.7394168198663701, 0.7425073827260638, 0.761405797726678, 0.7897015941330201, 0.7677332956517278, 0.7364377717025766, 0.7376885043769473, 0.749942218654316, 0.2290513015689004, 0.8595593746458088, 0.22738464895954846, 0.8806660293094688, 0.21206823377965622, 0.2129392839174271, 0.2220412606872192, 0.21973382448448575, 0.8516099814478726, 0.2708262327409653, 0.13119629383756148, 0.1305827097882688, 0.26814252614165335, 0.3182424803258842, 0.28539880057083544, 0.3212147293389238, 0.3208322575863062, 0.27983717838316147, 0.27146490216589525, 0.2774354646405903, 0.25083313868949186, 0.28234090354690733, 0.30000760975228946, 0.3426240001568721, 0.30616637803422286, 0.30649218228713837, 0.3055018619325027, 0.051381703519232325, 0.10493104217514215, 0.03649781905528271, 0.07468753705190434, 0.010119429111052125, 0.09546805850073248, 0.03624826696147032, 0.06450448661716524, 0.08754790379084465, 0.14261073064074115, 0.12220727501965489, 0.1674166763741789, 0.09218704995907123, 0.0549870648026719, 0.05895354135338171, 0.16693988770457113, 0.10090546135398903, 0.10909538636573235, 0.22978807632912523, 0.1826524720367091, 0.25923583337685663, 0.10984949942954658, 0.11318735150688097, 0.18133912611983782, 0.19825365471797385, 0.1867045881251278, 0.12787345924261517, 0.25140963753388346, 0.1322427430975215, 0.08519250069183903, 0.08661682930571535, 0.17748038772479335, 0.18951230338960012, 0.09036482336903773, 0.15596598589109412, 0.12772325351488345, 0.6413532858710946, 0.6015901181576493, 0.5639199770952609, 0.5550710304668058, 0.6658046268827397, 0.5662159879560948, 0.6076784254750442, 0.6102148677191074, 0.6257121487732887, 0.12910056490619248, 0.0636186666764561, 0.10251414322591501, 0.10057894571543002, 0.10945080480104274, 0.13738613848197223, 0.1081104058192417, 0.10774294966458564, 0.10943546530902115, 0.544940064806061, 0.21287919023103385, 0.21467774243123772, 0.2557686725949524, 0.5643252633842335, 0.3733310289866155, 0.279501565864798, 0.7275242028175202, 0.6692315180369967, 0.45811246555881024, 0.42368187141635594, 0.4080406492150972, 0.4906508423770337, 0.5480062618774382, 0.5720569642589368, 0.19980879781556182, 0.5190952742460876, 0.2781376726936189, 0.3329757340796382, 0.27389941004646023, 0.2136538814308685, 0.2645355943658063, 0.22456851500919928, 0.39597073185707055, 0.24482536610120842, 0.2916060077400243, 0.21657475366322299, 0.2674257829918858, 0.2364317511052353, 0.2148028144079378, 0.2906443629171298, 0.23930435921918547, 0.23197586748831367, 0.22545179562170936, 0.3094051689203138, 0.258447916842356, 0.18352559286315373, 0.2053071853003272, 0.2069951964140363, 0.22583561786113837, 0.21093470056672403, 0.21001587033481406, 0.1742805683709483, 0.2212332179781772, 0.22241157379364063, 0.18734370933601852, 0.178210767970159, 0.18791916003464282, 0.9223999593790316, 0.200175241709603, 0.9290661516031341, 0.9154213476707903, 0.9100716569236599, 0.9235848523191406, 0.9033170062038689, 0.7972257906012286, 0.890911169438927, 0.9098454569370474, 0.16756104976932507, 0.9104727542035254, 0.8745556743463331, 0.10449689767073, 0.8252831101614553, 0.2291540990421942, 0.2550470197103284, 0.39891544616718433, 0.22853898161638875, 0.23912578260791018, 0.2396808667346848, 0.33388881639226087, 0.24652721431103208, 0.21232289876683463, 0.15204176922648893, 0.09065032199970269, 0.13619446692741388, 0.08540068277301927, 0.11102930856518001, 0.09311733848285986, 0.08180585180054223, 0.0834162828065762, 0.09112660741432133]}, "mutation_prompt": null}
{"id": "6fbc482b-03a6-4dc6-a20a-8d53f4bc7049", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.99 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Slightly enhance mutation scale update for better convergence control.", "configspace": "", "generation": 70, "fitness": 0.36470667719168076, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8651825749823905, 0.8777822628660654, 0.8721445045446155, 0.8640425968501245, 0.8489635284535666, 0.8615921060955017, 0.8624842024749899, 0.8732798094560632, 0.8606616660784371, 0.7342256221506533, 0.7438551638530577, 0.7285287988317031, 0.711712408244725, 0.7241914463190551, 0.705510288019544, 0.7137750089629112, 0.6906387066127939, 0.7224836707807205, 0.0882452827022635, 0.1111471514093344, 0.07377191522572557, 0.11492278952680013, 0.11684123353562248, 0.12369980071781228, 0.08932035108399528, 0.0928576646092466, 0.08906674100548917, 0.1214380370014444, 0.10823865102845653, 0.12803296081067816, 0.14258086456311925, 0.13114041282489886, 0.10739434725683972, 0.09915230896264693, 0.10942148238411464, 0.11415097239931415, 0.9333438428776362, 0.9310646639459589, 0.9333928458545294, 0.9295450980323935, 0.9246486894815508, 0.9352039310513676, 0.9424218208147502, 0.9148486834785864, 0.9346874985751845, 0.7567518987853794, 0.7307621137046657, 0.7217309600559951, 0.7656153182111567, 0.7816580428234218, 0.767846658196099, 0.767619331957065, 0.7308010982469657, 0.7359468753021415, 0.22903095790255668, 0.2280448069690295, 0.22647822639555015, 0.9111066844178675, 0.21222102173070068, 0.21295217443332748, 0.23226789980813045, 0.22924920335585663, 0.847677777591663, 0.2752966799072951, 0.13150877036026054, 0.2854584080964231, 0.2764842607310011, 0.2976640203724219, 0.2978665838036516, 0.2759309966496888, 0.3251201841855115, 0.3232219735601818, 0.28882622653956647, 0.2753544288654092, 0.13369317877058384, 0.29940963702595313, 0.321256961913148, 0.3042693139177435, 0.2954723391608445, 0.30839297216498884, 0.31595860559628697, 0.0254497275269725, 0.08489723219801815, 0.1355556215911221, 0.05517715329496009, 0.06367040042146854, 0.015158464386748505, 0.03497988509732419, 0.025476717383859593, 0.12501843166780569, 0.14638517835915787, 0.0949188045722722, 0.1401951562952719, 0.07928276640078025, 0.042489093776230225, 0.025513763724869354, 0.15545894554084916, 0.09437562874490324, 0.09077512408152766, 0.3401669376401846, 0.23987461130254728, 0.3383341693577425, 0.11221785510767845, 0.12733471254818574, 0.16811366384896953, 0.1581228578224212, 0.16859831756856858, 0.10819291210133086, 0.2796589328675553, 0.24232928710677037, 0.06503807467817346, 0.09422884973469192, 0.15161228607832378, 0.1643151974922641, 0.09009834388433768, 0.13670056857806923, 0.09728646061813562, 0.5841706127639102, 0.5970356447610425, 0.5718249674591884, 0.5846258648080089, 0.5583206226365214, 0.5649204153805734, 0.5944657990660127, 0.5777881847621391, 0.5759903880524322, 0.1372631477916082, 0.06928917488225561, 0.1181376485775012, 0.09276301087891914, 0.10150642153453082, 0.09955314349993283, 0.11448675770598549, 0.07155655368869196, 0.10981876610572139, 0.6170746770479034, 0.5516705430443292, 0.2274235331060428, 0.2615817141839315, 0.3383527886122153, 0.2740771643192347, 0.27919632296615693, 0.26285993525558804, 0.33513520728390644, 0.570770226164625, 0.5317147762668082, 0.3981354013519466, 0.4665943772821224, 0.5746493989636331, 0.4502166208875653, 0.19932664205252026, 0.31603344183597626, 0.30170618198995536, 0.2795987947684925, 0.3376539782703055, 0.2992307798710315, 0.25482372217450255, 0.2635230578400135, 0.3530449334647623, 0.21009227433516198, 0.3676736339312099, 0.23685064886677543, 0.24277824282639426, 0.23556201741932759, 0.18709996708763543, 0.24766612584584513, 0.29574213315511355, 0.21745284162961653, 0.22466783711157823, 0.2512382216078357, 0.25423555617939864, 0.18357805671565952, 0.22831557623819831, 0.20712513821325818, 0.22595561185544166, 0.21050475996553586, 0.21121447003595528, 0.18416879759090976, 0.20755786011077992, 0.22374703479182279, 0.18733892106873795, 0.1783138299254169, 0.18787455237752015, 0.9263435676996008, 0.20014516904775748, 0.9171978823702874, 0.9169598552126189, 0.920787203225336, 0.9381026995015678, 0.9096260087178274, 0.8552014786927473, 0.8535230208048794, 0.9129274832322897, 0.16758432341010288, 0.8592575395724283, 0.893283782056316, 0.10449249637248226, 0.8733049344750587, 0.26492289295423666, 0.20088752558923006, 0.2114545473666094, 0.22089498538118524, 0.2907762817855545, 0.21961309121401695, 0.24471980139393879, 0.24465961796837077, 0.23801324548877378, 0.0980319997194008, 0.09550630156376405, 0.12397353502707087, 0.08564442473153344, 0.11210941342485226, 0.09223047498995307, 0.08370309293503064, 0.09778158688183647, 0.09073342670741635]}, "mutation_prompt": null}
{"id": "c7af08cb-366d-4628-84a6-d9076347ccb8", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.95  # inertia weight, improved initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improve swarm exploration by adjusting the initial inertia weight.", "configspace": "", "generation": 71, "fitness": 0.3753845587201295, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8605019590262813, 0.8718794743826733, 0.8903309415335436, 0.8627250280999227, 0.8604009917863479, 0.8592237888605186, 0.8667844312538512, 0.8720789094800057, 0.8732789851184516, 0.7215323932199004, 0.7418796831128537, 0.7308382947348214, 0.7092425774095139, 0.7045068417972404, 0.6801983246406957, 0.7273854250129792, 0.703260108981087, 0.7399154761266435, 0.08855450590296676, 0.6857178228031242, 0.07329609211274313, 0.12174498153577473, 0.11560144941802042, 0.12850384222185163, 0.08051834315096917, 0.09315867972240233, 0.08908755031834192, 0.12202816553140017, 0.14246824458802043, 0.13076917692397005, 0.13134662619391835, 0.09972219565605867, 0.10795082477805484, 0.09546470997244161, 0.08577606809291771, 0.10771448484730539, 0.9327473937584077, 0.9337364531332549, 0.9366537222545053, 0.9295553931428597, 0.9306047238334422, 0.9352094859275482, 0.9420036986803735, 0.9150482139283173, 0.9353561772238579, 0.7614997534769729, 0.7394168198663701, 0.7425073827260638, 0.761405797726678, 0.7897015941330201, 0.7677332956517278, 0.7364377717025766, 0.7376885043769473, 0.749942218654316, 0.2290513015689004, 0.8595593746458088, 0.22738464895954846, 0.8806660293094688, 0.21206823377965622, 0.2129392839174271, 0.2220412606872192, 0.21973382448448575, 0.8516099814478726, 0.2708262327409653, 0.13119629383756148, 0.1305827097882688, 0.26814252614165335, 0.3182424803258842, 0.28539880057083544, 0.3212147293389238, 0.3208322575863062, 0.27983717838316147, 0.27146490216589525, 0.2774354646405903, 0.25083313868949186, 0.28234090354690733, 0.30000760975228946, 0.3426240001568721, 0.30616637803422286, 0.30649218228713837, 0.3055018619325027, 0.051381703519232325, 0.10493104217514215, 0.03649781905528271, 0.07468753705190434, 0.010119429111052125, 0.09546805850073248, 0.03624826696147032, 0.06450448661716524, 0.08754790379084465, 0.14261073064074115, 0.12220727501965489, 0.1674166763741789, 0.09218704995907123, 0.0549870648026719, 0.05895354135338171, 0.16693988770457113, 0.10090546135398903, 0.10909538636573235, 0.22978807632912523, 0.1826524720367091, 0.25923583337685663, 0.10984949942954658, 0.11318735150688097, 0.18133912611983782, 0.19825365471797385, 0.1867045881251278, 0.12787345924261517, 0.25140963753388346, 0.1322427430975215, 0.08519250069183903, 0.08661682930571535, 0.17748038772479335, 0.18951230338960012, 0.09036482336903773, 0.15596598589109412, 0.12772325351488345, 0.6413532858710946, 0.6015901181576493, 0.5639199770952609, 0.5550710304668058, 0.6658046268827397, 0.5662159879560948, 0.6076784254750442, 0.6102148677191074, 0.6257121487732887, 0.12910056490619248, 0.0636186666764561, 0.10251414322591501, 0.10057894571543002, 0.10945080480104274, 0.13738613848197223, 0.1081104058192417, 0.10774294966458564, 0.10943546530902115, 0.544940064806061, 0.21287919023103385, 0.21467774243123772, 0.2557686725949524, 0.5643252633842335, 0.3733310289866155, 0.279501565864798, 0.7275242028175202, 0.6692315180369967, 0.45811246555881024, 0.42368187141635594, 0.4080406492150972, 0.4906508423770337, 0.5480062618774382, 0.5720569642589368, 0.19980879781556182, 0.5190952742460876, 0.2781376726936189, 0.3329757340796382, 0.27389941004646023, 0.2136538814308685, 0.2645355943658063, 0.22456851500919928, 0.39597073185707055, 0.24482536610120842, 0.2916060077400243, 0.21657475366322299, 0.2674257829918858, 0.2364317511052353, 0.2148028144079378, 0.2906443629171298, 0.23930435921918547, 0.23197586748831367, 0.22545179562170936, 0.3094051689203138, 0.258447916842356, 0.18352559286315373, 0.2053071853003272, 0.2069951964140363, 0.22583561786113837, 0.21093470056672403, 0.21001587033481406, 0.1742805683709483, 0.2212332179781772, 0.22241157379364063, 0.18734370933601852, 0.178210767970159, 0.18791916003464282, 0.9223999593790316, 0.200175241709603, 0.9290661516031341, 0.9154213476707903, 0.9100716569236599, 0.9235848523191406, 0.9033170062038689, 0.7972257906012286, 0.890911169438927, 0.9098454569370474, 0.16756104976932507, 0.9104727542035254, 0.8745556743463331, 0.10449689767073, 0.8252831101614553, 0.2291540990421942, 0.2550470197103284, 0.39891544616718433, 0.22853898161638875, 0.23912578260791018, 0.2396808667346848, 0.33388881639226087, 0.24652721431103208, 0.21232289876683463, 0.15204176922648893, 0.09065032199970269, 0.13619446692741388, 0.08540068277301927, 0.11102930856518001, 0.09311733848285986, 0.08180585180054223, 0.0834162828065762, 0.09112660741432133]}, "mutation_prompt": null}
{"id": "2d3e9c51-fa0b-4464-992f-be9615e2817a", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.35 + (0.5 * np.random.rand())  # Slightly increased decay rate for inertia weight\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Slightly increase the inertia weight decay rate for improved convergence stability.", "configspace": "", "generation": 72, "fitness": 0.3687822068344837, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.30.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8910595027673461, 0.8967708280107367, 0.8967825563739953, 0.8937433159872543, 0.8703550539709622, 0.8915185565405498, 0.880863935224758, 0.895711990534071, 0.8753384460463687, 0.786107210224188, 0.7608425625054727, 0.7440005826277326, 0.739217146910454, 0.7640324101998668, 0.7387651646877663, 0.7570018287233727, 0.7736610612502318, 0.05047959323788509, 0.1567337269570902, 0.14364106825147405, 0.11202446919621611, 0.10109012164801057, 0.14447128965742917, 0.1324094292096606, 0.09041711880627024, 0.1831977097980706, 0.08264185690080827, 0.11583527208744859, 0.10340811863921173, 0.10937821248400892, 0.14348315237433018, 0.1007985387257293, 0.11504740189316232, 0.07762127482524883, 0.11441737870657731, 0.091869041225776, 0.9313271733014004, 0.927582503100507, 0.9304146736730099, 0.928136713659298, 0.9243814268882631, 0.931488374287968, 0.9369573172433157, 0.9022017876726611, 0.9289776974071488, 0.7967578233251627, 0.8010732176773466, 0.746628882810167, 0.7661358183707644, 0.8008522474308669, 0.7689328044138426, 0.7802656446041203, 0.7879387883492921, 0.7629949020998, 0.5414587217864224, 0.2261442425847111, 0.22508819435472027, 0.9203065390768095, 0.8833454032602766, 0.19276485699602874, 0.177467195648069, 0.21245123361527607, 0.23632088939193185, 0.27630013667510245, 0.13303538889793576, 0.2890296093624912, 0.34954724919836644, 0.31097827775911435, 0.2941694130225584, 0.34666031932591523, 0.37849965147609865, 0.3127191825450959, 0.28142545220162885, 0.280319480204689, 0.13448532598577567, 0.1341895480150046, 0.35603279186762293, 0.29180974527193526, 0.3106137001393867, 0.3137995305921243, 0.325722855659499, 0.04125736999938001, 0.04872753588326473, 0.08369321545112784, 0.055664013223050146, 0.10411731306637773, 0.08745836946058572, 0.08754443602209105, 0.061669370858123296, 0.07030540116409778, 0.11161508937214726, 0.05563802938409668, 0.0679940628906559, 0.09022357220729316, 0.04098680747753547, 0.04481825391506555, 0.17767656254778608, 0.09806957935013694, 0.08596094529047404, 0.20816147566079635, 0.2028117631524997, 0.25523485251583455, 0.11006850915366706, 0.08853923445034417, 0.3507614927821213, 0.1860585362656183, 0.26204913479612313, 0.10921906294762174, 0.1477238236608539, 0.12783487608460853, 0.08548280896899885, 0.06755600162549857, 0.19167177222333753, 0.15399200281187164, 0.0845962255584145, 0.18187467079843933, 0.08382579564557546, 0.5778374507688111, 0.6109739241231298, 0.6007072841022435, 0.6742235329264918, 0.5542347186678653, 0.6078619628077435, 0.5976197413912849, 0.6013959910154436, 0.5964087716145001, 0.10054367012969356, 0.09056414234741916, 0.11865847502898963, 0.15830770616359735, 0.11461221302191948, 0.08655852258723717, 0.10916576324519633, 0.14136332307412036, 0.08013714146826445, 0.7243918722660496, 0.22674855274488348, 0.22366010615841392, 0.23569016496760598, 0.6939923268127648, 0.19147690730714817, 0.4150133713223312, 0.20302682756310608, 0.34694280382221143, 0.416581171319667, 0.3484677185337941, 0.580642871059353, 0.32687656777360696, 0.5091440395730051, 0.40112716774386104, 0.6039231761301165, 0.621862546655709, 0.26605653558174647, 0.2485455696351503, 0.3339895068524631, 0.2747804862094103, 0.3703735052143807, 0.2256179567969866, 0.3151910933156652, 0.21977366659440878, 0.25595483634470595, 0.23142813270480989, 0.24852216538251926, 0.23789423342067118, 0.19863174299869146, 0.2789674117355817, 0.24791162816492818, 0.21369688430367195, 0.22749145807377702, 0.2164141406759832, 0.25891143367295677, 0.20826032752110601, 0.21059942620795524, 0.18898119000557168, 0.2114286458614968, 0.18092828606936906, 0.22515337486932285, 0.18149701656394968, 0.20997174136445051, 0.17703941421425184, 0.187261802959655, 0.18805181663888149, 0.1866599361516028, 0.9283600027592446, 0.2003395564509527, 0.9342169466955221, 0.9198095242860113, 0.9236078964551625, 0.9323769603208294, 0.8590523553109793, 0.856019031317357, 0.8721191078068508, 0.9057170866118273, 0.15444763605462453, 0.9177373892254648, 0.9105801407981785, 0.10450648862790346, 0.8162131067456893, 0.2057685186712731, 0.24576876382392399, 0.2874286003151121, 0.27638953898373975, 0.2487952448090216, 0.19765955041475158, 0.24138613423150257, 0.2239934368321621, 0.2662227490483928, 0.08365825619913358, 0.10802208078797848, 0.09840592873813059, 0.12217590459493444, 0.11089113415684548, 0.07949333080442522, 0.08930286382699082, 0.09732042426123722, 0.09909146883406028]}, "mutation_prompt": null}
{"id": "79ca70d2-d3d4-4fbc-b4b0-d4380cc2938f", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 4  # local topology size, slight increase\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduce a slight adjustment to the neighborhood topology for improved local exploration.", "configspace": "", "generation": 73, "fitness": 0.3636878423859071, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8752226526485007, 0.8484634925218042, 0.8898387491858422, 0.8716991802832104, 0.8732363519934611, 0.8724304138537176, 0.861309280335338, 0.8753713935014656, 0.8667989321346613, 0.7363906864317808, 0.747181130826557, 0.7745210216956411, 0.742745761518627, 0.733094835534893, 0.7105803775151255, 0.7167760159820702, 0.7299591722455718, 0.7262994157522428, 0.13947870754818692, 0.14164908257026232, 0.11443473849268193, 0.10941741173267894, 0.11630967260240521, 0.18725458958460572, 0.0961893697756997, 0.14425332177490946, 0.16039022629674216, 0.12239988429066329, 0.09137157131158435, 0.09450275197390534, 0.08607174451624033, 0.07896426194027995, 0.09331760370664777, 0.09646985973436062, 0.09476869066176274, 0.12028553124978103, 0.9373751229016488, 0.934367100312557, 0.9361301471041648, 0.9276490174137825, 0.9322285182590108, 0.932252558666582, 0.9458557965008053, 0.9089186831343876, 0.9397425880287195, 0.7613882510484233, 0.7582607691395002, 0.7151508192568796, 0.7456101364064947, 0.771949719309931, 0.7338928308903616, 0.7771614246746542, 0.7260522440041799, 0.7281569186697034, 0.22998252322337753, 0.37970637144666997, 0.22806119909924893, 0.3844542617040345, 0.3798042520551139, 0.21312429296088287, 0.2324677352536868, 0.2259605388272773, 0.24729140216589762, 0.2931748245753669, 0.12881098950863712, 0.2959841326467012, 0.29810645056725116, 0.2899202414563735, 0.2984013647944216, 0.3298255986494327, 0.342605278518362, 0.30832969217524264, 0.26507338805670266, 0.28303724028292043, 0.2972701769155469, 0.32956456236243503, 0.333188869598936, 0.30220396395569404, 0.28667604906922317, 0.33150935082977306, 0.13472432583526628, 0.03698458598747478, 0.09300411346323834, 0.08379138032754274, 0.05644040688422702, 0.21162436778927207, 0.05369232625629661, 0.05360719982278028, 0.024607545821901278, 0.12855390745604311, 0.11255057128230106, 0.09426913312474439, 0.10870010536171848, 0.08092948378269826, 0.026970330671019616, 0.01476438536845448, 0.17038168500199846, 0.0926488987184162, 0.1244698168763787, 0.2070398731206159, 0.1118092511222809, 0.18550964187584107, 0.1311338493526253, 0.08353680042436173, 0.1325864611435441, 0.1654408336351828, 0.12350410985418026, 0.1905264933213785, 0.1463391328789435, 0.08429812627449063, 0.1162625127667698, 0.09790316787497355, 0.1002313878250487, 0.17273835677744465, 0.08122904065166914, 0.2624251171100045, 0.1730500896561975, 0.5732080029093785, 0.5574045561220836, 0.5564039178594782, 0.5829850269115818, 0.5739313322512056, 0.5598898619374605, 0.6147821707984451, 0.6258416188935096, 0.5751203856826377, 0.06376972778883061, 0.0873230140558029, 0.09337680950521043, 0.15561856188311562, 0.12352473310878664, 0.0654519905300418, 0.12298419718263032, 0.11103190751881598, 0.09182405143133021, 0.3397443741444166, 0.2089942411682958, 0.33222219650295925, 0.2256668580898995, 0.7566854759137912, 0.491538240670616, 0.40601060743688355, 0.2822796168511893, 0.7339045873989799, 0.3754117071866033, 0.21156935320914816, 0.33283150773642933, 0.5595994769766636, 0.5962028290496735, 0.5116469451177122, 0.5001409400561383, 0.3875736277784484, 0.4278561795792629, 0.1724904382400657, 0.39632941631578467, 0.22275102638847066, 0.45433791941869606, 0.23353975110486547, 0.37822958378964777, 0.24044184924345813, 0.3390296307371091, 0.22034721450968697, 0.24334907084568236, 0.2181703246663529, 0.21800976890306845, 0.198593433836747, 0.19816882934122426, 0.2494387020925266, 0.2743282638096606, 0.24172915661410044, 0.24644073284995238, 0.19757521516691323, 0.8253175693799373, 0.20728683951526228, 0.2518376092867751, 0.22499285269147484, 0.22425248519452867, 0.19070525886933187, 0.22375318895630303, 0.17974814527366212, 0.18735185790740894, 0.187572610069066, 0.18793227674002466, 0.930896429844318, 0.20012017514562308, 0.9203990940061237, 0.9177226787237951, 0.9209461949674503, 0.914163280764892, 0.8985421847512413, 0.7985498466638615, 0.815194195204781, 0.908578312603816, 0.09472539619758136, 0.8859771510320539, 0.10496477330742926, 0.1657941823740453, 0.8527565694408928, 0.18800084088905678, 0.38283075408557155, 0.2538030964954535, 0.23323091193342982, 0.2882566282440223, 0.2552479889185071, 0.2592699003997193, 0.19501441280054, 0.24421174063599094, 0.09030992213292233, 0.072066194779704, 0.07454522851429468, 0.11534759206302825, 0.08895142631541564, 0.07834656614826163, 0.10981527047851036, 0.10008413820013606, 0.09510512865600251]}, "mutation_prompt": null}
{"id": "8af9d061-06fd-4f03-b882-3e841e06eabf", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 5  # local topology size, increased for better information sharing\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Fine-tuned the local topology size to enhance information sharing and convergence rate.", "configspace": "", "generation": 74, "fitness": 0.3652847247833642, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8768284404893698, 0.878023998986264, 0.8838657501519518, 0.8808205280054153, 0.870714534662296, 0.8695826173241838, 0.8703928974533942, 0.8665137967924771, 0.849494348604236, 0.728874287176834, 0.7368201719712314, 0.7183085978147231, 0.760705150709051, 0.7422017854204054, 0.7333033670723288, 0.7005037303091353, 0.7018424535609156, 0.6722210979525174, 0.12141911723415977, 0.08837075788907445, 0.15322252607675868, 0.1250046518321748, 0.09598118088454777, 0.7284377276664262, 0.13964199394987153, 0.1107749494201471, 0.12296324674307979, 0.13910667053182002, 0.049760131839512, 0.09073745333403005, 0.15717380835598993, 0.08533841904924555, 0.1141807813938931, 0.1784653952341616, 0.0956100694462717, 0.09934304328445598, 0.9359486832156877, 0.9254342865434666, 0.939428618584787, 0.935446690512778, 0.9334120090063193, 0.931921884243379, 0.942571152779057, 0.9112217988117481, 0.9372177341959825, 0.7756086771642893, 0.8146266055989514, 0.7455854744470093, 0.7910648155539775, 0.7560207285570809, 0.7790552067533669, 0.7488375702476407, 0.7184816692884255, 0.7368874119331494, 0.33929608028211344, 0.4400713456966636, 0.22788992188152735, 0.9025301065313033, 0.8837018205305439, 0.27564318711650393, 0.17688677448652412, 0.15188959442079908, 0.8787298667923527, 0.286002303334292, 0.13298473649596199, 0.27880804284765215, 0.3092574508061653, 0.28064097322035253, 0.285553868111728, 0.29196572488968187, 0.3426217568561779, 0.3150546493981563, 0.2833094497106937, 0.296899547259753, 0.12287354412252594, 0.1342338401410258, 0.2707741333780468, 0.31217061862999684, 0.31678507823254054, 0.31426947273809713, 0.3027410366875961, 0.03529892620218378, 0.13272087131824883, 0.016566083636689655, 0.013450454817778179, 0.051783899383103904, 0.043441406429098106, 0.12414916294937739, 0.026112016679341488, 0.28667375328938227, 0.14586152549159837, 0.07713570945713633, 0.1035269853319909, 0.08083844013560337, 0.024967760323233223, 0.04605016624206493, 0.22131524453496998, 0.09912293136478079, 0.13833538371963183, 0.3203624230010983, 0.09852908907129732, 0.2408422660109074, 0.1275981436796787, 0.08551708337043495, 0.16258810413866553, 0.21164446901162504, 0.1809787937648708, 0.13526954077822406, 0.16751140333169368, 0.10606615253416074, 0.14868726049041037, 0.09013897968265228, 0.21396296171794893, 0.1372942787730983, 0.08157576124615096, 0.11168293930766249, 0.11345656626119216, 0.5579381105079841, 0.6215357798716443, 0.5771199238709624, 0.5580470742756805, 0.5705948244533158, 0.5753337221824215, 0.6017196505595099, 0.6285561957944246, 0.6272867071630254, 0.0923880345665099, 0.06895764342185706, 0.12834330551972395, 0.14059030533649552, 0.06123260354980398, 0.07021110544274212, 0.10203668443954594, 0.12165739274486365, 0.11232409993434556, 0.20631881754519243, 0.40715275621559543, 0.23035018465885693, 0.22378115040692215, 0.42516014658288626, 0.37504121581333316, 0.27515612022844615, 0.19230890499882503, 0.2553688511711726, 0.21041636510718076, 0.22986313997179508, 0.5147196320467173, 0.39351932308245896, 0.5891585173883955, 0.6610770176519548, 0.2559561819051812, 0.6321920294112818, 0.20097090312681698, 0.2669466739365026, 0.34404969211587544, 0.23315075470639524, 0.41285150227839673, 0.2111901470223021, 0.33741954148458986, 0.37209945272104183, 0.22109530414240308, 0.22937492219123667, 0.18917626329007176, 0.21878279642756548, 0.24170212353854714, 0.21298096252595622, 0.2268201052537997, 0.24083314174170523, 0.23196513260365914, 0.2092377932284063, 0.3052601241980346, 0.17221805439340676, 0.25126532513782474, 0.20919796788322198, 0.2515565145964348, 0.2291450350057851, 0.22422965308457232, 0.183700054233931, 0.1877942107880224, 0.1873045447873889, 0.18731686102893086, 0.18747395255229427, 0.18732975947478603, 0.9225373477375525, 0.20048013243350316, 0.9159541999886671, 0.9233686364671678, 0.9197005282541525, 0.9196739616119833, 0.8618262373472836, 0.7953494679406152, 0.12717174755595695, 0.20958361551539295, 0.09473956061212152, 0.89736192624369, 0.8575326116441229, 0.8380785354414501, 0.8451292815453917, 0.21435514896321528, 0.2294187298144641, 0.18344170303591967, 0.25846218408475097, 0.36603074872251895, 0.2521363349928232, 0.283020059372207, 0.24664664149068716, 0.2445245304662229, 0.08650187420874667, 0.11516287627920341, 0.05970767316763992, 0.11437671298707952, 0.10966951702416172, 0.07829604927711575, 0.0789675762214721, 0.058793350437059244, 0.08568590686517308]}, "mutation_prompt": null}
{"id": "7aa289c8-6187-4166-b29c-ebbda465e8f6", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob = 0.1 * (1 - eval_ratio)**2  # Adjusted mutation probability formula\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjust mutation probability to enhance exploration during initial phases.", "configspace": "", "generation": 75, "fitness": 0.3635306032820356, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.884207005554772, 0.8508130913257338, 0.8925910496731673, 0.834495271610529, 0.8587695301611158, 0.8719792481293303, 0.8481561251416133, 0.8570823550057124, 0.8462685741131504, 0.7312162681082724, 0.697274497291348, 0.688594042624015, 0.7161434028474924, 0.7125267024162414, 0.6999147495862301, 0.7183584538840072, 0.7289742240769921, 0.7172913329739461, 0.08850666052574163, 0.13419434893252857, 0.07135165816466615, 0.10067389674395366, 0.115562296222674, 0.1425990963319531, 0.08055045046480769, 0.09359572373378688, 0.0889360090263479, 0.12429434673842665, 0.11273062706269976, 0.12959883787445414, 0.15605458249239856, 0.11999637092838233, 0.10333744718298199, 0.09588262824005456, 0.09656473130114374, 0.112568419379252, 0.9340993132582481, 0.9312066772661763, 0.9288469173005733, 0.9297490019021782, 0.9277724900782838, 0.9352094859275482, 0.9400449194967558, 0.9109612067249657, 0.9353561772238579, 0.7100046454745275, 0.7266370647741209, 0.7207280774590824, 0.7367352689535482, 0.7634027352361414, 0.7534669552051392, 0.6787910052971788, 0.6864967535700812, 0.7357963199726717, 0.3519559413137914, 0.8543493911967013, 0.22738464895954846, 0.8897441054307236, 0.27513138453794017, 0.8499610872610162, 0.17759089581498044, 0.22897964433974627, 0.23376061689766003, 0.2351827036811004, 0.13025995564316106, 0.13026693248997667, 0.28200314014677197, 0.2846452636374094, 0.25669669113239846, 0.2672704601876903, 0.25630450674247074, 0.29572804929198615, 0.22854144387880126, 0.272152598272421, 0.25016403800381126, 0.25784621114764383, 0.26780962515713125, 0.2848736372106715, 0.28432583485995333, 0.28322667212529995, 0.3022470560795286, 0.013975745384276705, 0.15155860217505668, 0.12512043707527465, 0.11258536993826151, 0.05258980266829416, 0.06249673763717056, 0.03746094411183243, 0.020527973864538418, 0.10101972393462799, 0.20080980573536922, 0.14256701653048964, 0.14305950685978974, 0.08365698506027475, 0.05547899151678248, 0.03172778720422342, 0.18946418614191385, 0.10023424321376229, 0.10020750313586635, 0.1389552412899666, 0.1904921874315082, 0.2395387325406969, 0.12021273393221765, 0.08657819661137489, 0.17451600090856445, 0.16774357303424747, 0.21496523554858082, 0.1276744604350284, 0.24743746513123477, 0.131796790213347, 0.08142832415547763, 0.13657196738879251, 0.17645588034279058, 0.1877836271605643, 0.16072738791581342, 0.13152888700995058, 0.12824625247200805, 0.5453044643948741, 0.5253523996427525, 0.5498934849284067, 0.5614425099930537, 0.5557975179614063, 0.5578005450445094, 0.5595253577605184, 0.5923125699360166, 0.5530542319334322, 0.11358493131904812, 0.07888308975931246, 0.09312697001034576, 0.11345809914015426, 0.11015519983250233, 0.09578177917712949, 0.10696586829515908, 0.12900119105733432, 0.15294983031643727, 0.6280004194949822, 0.20615905688519665, 0.18289080236904842, 0.37881113058684013, 0.40384386600129074, 0.34652433231864355, 0.3203352973408, 0.27286914091731573, 0.6417521979439724, 0.40003901071849257, 0.3966767345259823, 0.402492933670793, 0.3599598030222756, 0.4599244538445809, 0.3386949611612988, 0.2859737828891461, 0.3711105555505768, 0.5117845934717448, 0.2680326043421981, 0.3249991133523157, 0.2231073451981973, 0.26643200367622044, 0.23272463830674228, 0.30538545913306425, 0.3909076129622414, 0.2929426171062187, 0.22478467170771155, 0.3004701592224679, 0.22702650013581083, 0.21334260109141046, 0.2811016055090424, 0.1819040890327034, 0.24517720815208732, 0.22528651114896237, 0.3242899597852281, 0.23897878314045073, 0.18320465179436474, 0.21608863093630049, 0.20841602375732293, 0.22432094323302376, 0.21151483190418474, 0.21043335535811003, 0.1962336829293838, 0.19904774882787712, 0.20131639844791838, 0.1872790973934868, 0.17821370862194108, 0.1879199328922324, 0.9236496023486809, 0.2001710260210683, 0.9280640004753905, 0.9306831166015495, 0.9020782142244279, 0.9338709929851049, 0.8656828355758178, 0.8381562086342733, 0.8839611106601665, 0.8663640036034255, 0.16755932557594877, 0.9160525063298309, 0.867017362815753, 0.10449291524137405, 0.8088940190532645, 0.24889214139090587, 0.23372124008168726, 0.24199599783436365, 0.1952462823974056, 0.27995453613706733, 0.23200197570200976, 0.24465569251817576, 0.2653673137615532, 0.22203698130592087, 0.1302624867778177, 0.10137349658386885, 0.13023267430431718, 0.09951588883657714, 0.09271171513018384, 0.09380979003578271, 0.08213468634111265, 0.09685232725618953, 0.08947632792279292]}, "mutation_prompt": null}
{"id": "779877bc-da7a-4d66-9983-ae42ef3f1bbe", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.7 * (1 - eval_ratio) + 2.8 * eval_ratio  # Minor tweak for improved exploration\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduce a minor tweak to the social parameter `c2` formula for improved global exploration.", "configspace": "", "generation": 76, "fitness": 0.361018108084859, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8735459062829517, 0.865827236681071, 0.8893870844419247, 0.8524904551295164, 0.863482387480943, 0.8661082719278058, 0.8621824829684531, 0.8645313844420106, 0.8694667491213065, 0.7381258196981952, 0.7479712453356027, 0.7164525675335338, 0.7075232082920955, 0.7006382546491552, 0.7217890683528374, 0.6916257076486012, 0.6932953637779284, 0.6990026085578535, 0.1311340516942262, 0.09547244039608394, 0.08849486088128, 0.08696191465085212, 0.1573636687007871, 0.12279845552078272, 0.08334795618032453, 0.15650317498013178, 0.11515583448267974, 0.09461691509506709, 0.10920054771228882, 0.09493658584744025, 0.11603349191313117, 0.07844363393152998, 0.11321322425384495, 0.09928662897934393, 0.11016139675788328, 0.17739766602146245, 0.93195031710683, 0.9392683083862149, 0.9428251088607564, 0.9401152630462917, 0.9370748674933553, 0.9283676161349524, 0.9427986971330237, 0.914398132492754, 0.9369015973922065, 0.717603342717072, 0.7377752913040412, 0.7480799962359329, 0.7501673197284309, 0.7400940491656192, 0.7313930308191133, 0.7025044952289239, 0.7675104321208884, 0.6977261895611164, 0.8665181814881777, 0.3924556123982602, 0.17137968274674364, 0.8578398271882001, 0.2781382378041801, 0.8835464460315812, 0.23354052570718398, 0.1773457924850853, 0.2345773278620028, 0.3024245162715783, 0.3307259109482983, 0.26771869436057716, 0.2810327888290367, 0.13446685696175487, 0.13240631586024376, 0.26334542422150065, 0.2829427599883001, 0.28467650715226933, 0.25375075639493927, 0.26424149836293576, 0.24301022790072369, 0.3103008050041437, 0.31230201759195664, 0.2793616061857368, 0.2918631489027689, 0.2728055469149855, 0.286828705403097, 0.017130458863573783, 0.06490278417581918, 0.04792072482383647, 0.05662510733517734, 9.999999999998899e-05, 0.05231279458128624, 0.013399014831541156, 0.009849358727075375, 0.08975833411289802, 0.20118293426111755, 0.05630296047581973, 0.05786345250286873, 0.07300058551387334, 0.011069723388018038, 0.04775066671218775, 0.14765667992866127, 0.09830227061599328, 0.22031571727936494, 0.3140711881136833, 0.17594645577761547, 0.2528788140171545, 0.09714770852595667, 0.08994853821487636, 0.13692457738877584, 0.1661314019153578, 0.346646728845885, 0.09664425805619525, 0.19542196263625744, 0.10895038034118498, 0.14674515622242235, 0.1051443463669186, 0.1097627632285828, 0.1940435509940993, 0.10420726697388871, 0.2428189637033058, 0.10214656326706595, 0.5714052409844521, 0.589064826722377, 0.5810912587100092, 0.6210675029595774, 0.6182148598733033, 0.627948337571535, 0.5805458461248392, 0.6068384230785695, 0.6071775743238301, 0.11480245508117748, 0.08752531162133925, 0.11245761789822262, 0.15565380612361446, 0.0909438864988531, 0.1330180694830102, 0.08233930004875023, 0.13211330171070546, 0.15763318302530516, 0.35908300245465696, 0.2125230533972663, 0.22780106118706978, 0.19926894661622319, 0.27496188560764623, 0.19843898200895282, 0.2092213460647464, 0.6297097165746512, 0.20767846771252385, 0.26547051078196693, 0.41891393654133624, 0.4129788214513972, 0.4643592315947217, 0.255277709475791, 0.3685347930667916, 0.2045969972956423, 0.4867709155819506, 0.26514478454213586, 0.22238133287359418, 0.2409153637069129, 0.22679725281814922, 0.4296484227229065, 0.39554965590344604, 0.37232865435251283, 0.24414355120121833, 0.488693267326646, 0.1731167712924222, 0.2075629738804966, 0.24730848032990693, 0.2233220510454863, 0.31729028701829065, 0.21910151963787228, 0.2329604909139028, 0.23629394972011164, 0.2185144557673545, 0.2136767619065859, 0.19118927990264512, 0.22741222295523167, 0.18659678779270183, 0.22550795046251237, 0.2075192972029446, 0.19113851991998532, 0.18791571245317706, 0.20959402086585133, 0.17390258809739678, 0.12641653901049887, 0.17851307390155002, 0.1535336069452372, 0.9152676228751132, 0.20011153665956638, 0.9207200749823872, 0.9175678715477295, 0.9270699702244426, 0.9378787501546991, 0.8704937960891319, 0.8487081908885995, 0.8577553292806023, 0.8630542396197266, 0.15483436569292586, 0.9135343134743813, 0.8664010762522696, 0.10446042633772612, 0.8308353993144038, 0.24507646910888736, 0.24632387824672963, 0.20764686052756454, 0.2489091979571859, 0.32320053714671193, 0.25025854417694404, 0.24793248942415191, 0.23995636753687177, 0.2686475532059853, 0.10857194137021287, 0.09521819423282218, 0.08725436110109042, 0.0932579408507167, 0.10004860165252338, 0.09117769054679536, 0.09151812712794383, 0.10752030425692682, 0.09818729981023766]}, "mutation_prompt": null}
{"id": "16e2a24e-25e0-4a3f-9c66-2d059c50659a", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.3 * np.random.rand())  # Adjusted inertia weight decay, was 0.5\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Fine-tune the inertia weight decay formula for better exploration-exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.369507233984822, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.30.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.884589777861109, 0.9015225317659511, 0.8972566689836373, 0.904794668755641, 0.8889622144092131, 0.9033945062511665, 0.8953512454247724, 0.9017763857722304, 0.8975756594389626, 0.7968318435252375, 0.8019381317655924, 0.8094167365933035, 0.7963399408577235, 0.7833007893722881, 0.7859543821829411, 0.787561564590548, 0.7659315519148038, 0.7538761941256225, 0.12207446065032623, 0.11801361099049101, 0.11557060547125786, 0.1175873729282021, 0.1334730427524733, 0.13313872549551908, 0.09556006721875288, 0.12446210673082825, 0.09883591626844956, 0.10421530860732797, 0.0690738845305161, 0.07911986489590217, 0.12454709922875884, 0.077995554210875, 0.08363773246540929, 0.09582900216097912, 0.13206315144776382, 0.05572405830530858, 0.9255514800111942, 0.9229190660134006, 0.9215378175246519, 0.9261841491403044, 0.9174967967701712, 0.9251355467742184, 0.9338649138552882, 0.907949341694798, 0.9263115443063005, 0.788431483770305, 0.8276470306389778, 0.7802950092675451, 0.8299374754048984, 0.8189868939381849, 0.8143837067344913, 0.8174871610688803, 0.7695135627457769, 0.779419444568994, 0.2290388357129869, 0.17067498853295837, 0.21068685669174214, 0.3796874171207041, 0.21919410867907962, 0.2128150736808172, 0.23280733004408793, 0.17787791955054877, 0.2352640960878397, 0.3129500432362453, 0.13019934161163582, 0.3325821159427814, 0.2981054466467594, 0.35240730015841026, 0.3369325480089981, 0.35470504516981904, 0.3575096726700533, 0.3221574198093602, 0.28924632605215617, 0.2707055103917413, 0.2767170507799911, 0.34046568926762033, 0.33821058812312477, 0.30479544239182643, 0.3088090525721817, 0.1329062982343696, 0.32448699645089485, 0.026252760978869638, 0.16467315611591604, 0.004967851458888672, 0.05558748889061915, 0.18165737139161242, 0.04774321128589054, 0.07421862327584183, 0.02014030065947159, 0.17985238698381967, 0.10005441600540832, 0.05735134304145906, 0.08160288684851147, 0.09498657000439437, 0.018419185010077443, 0.10789500958428111, 0.14402730545802933, 0.13434762106770526, 0.17578372125561637, 0.19174821871637626, 0.16833145385587467, 0.21119956684538532, 0.12380959387462276, 0.12081346178924557, 0.17075317588929884, 0.21750427492307445, 0.287864031729411, 0.14084424251712313, 0.2146102401806409, 0.12078381361441992, 0.08349892362633304, 0.16230803948370665, 0.20461189048524753, 0.14242215334939923, 0.08280478074280928, 0.17895005723862945, 0.08396262162935442, 0.6146111378417254, 0.5579050180061551, 0.6850889910493603, 0.6542305216893607, 0.6057756740162025, 0.6166217663600618, 0.6346142391180702, 0.590378154591817, 0.6284932249933315, 0.14045883273565818, 0.09482028078324856, 0.07760349145150935, 0.132072650244483, 0.07951897406428632, 0.10529599239205067, 0.08164434927547504, 0.1308006914309906, 0.14535877703418332, 0.3519277341618686, 0.6302025882951405, 0.24182634992479812, 0.6752273764814954, 0.35132194049028076, 0.4309856992782557, 0.2832419816405103, 0.6813054453521086, 0.21471833055521072, 0.40886249240658745, 0.35331050303331435, 0.48638092154897306, 0.4207672350288968, 0.3015664165967896, 0.47584501222096265, 0.5393470489115456, 0.5382957054480659, 0.2471640891361815, 0.35685322989431256, 0.25122705480935015, 0.24139554083462822, 0.3435035187333899, 0.23176457942280126, 0.4280964849530805, 0.1942975615145558, 0.36312208360919884, 0.21010323840834066, 0.24412557677284752, 0.22412696082639882, 0.23585891632054434, 0.3015625231721576, 0.26020637965626314, 0.23025860652353536, 0.2960000721759346, 0.30006684017471796, 0.2166564992334581, 0.19791041143928523, 0.22633363126321848, 0.17880004286729456, 0.18809340934348584, 0.20328417002499355, 0.22624511814593007, 0.18089131140530013, 0.18489818829354887, 0.20726961101642505, 0.12549735950009966, 0.17803237761318214, 0.1869187398173503, 0.9296062223468744, 0.2004113847596103, 0.933028759050835, 0.14272533470781468, 0.9292499131591541, 0.942351923840174, 0.8733637698889595, 0.901008363078629, 0.8796707120287119, 0.9158343817787575, 0.15433346045671192, 0.917505582142019, 0.8841903265871265, 0.10453197840261252, 0.8599977018249667, 0.20040410118004182, 0.3438356438887671, 0.27194958985590567, 0.2530845259278477, 0.21304975523484126, 0.24788595514366973, 0.253080412107175, 0.3065924292266915, 0.26956422333371166, 0.09415910110147274, 0.11682575399790984, 0.08808558348418283, 0.09005981665427021, 0.09449948091308047, 0.10321284438223743, 0.0970837897816853, 0.08850422087928633, 0.09421677861686317]}, "mutation_prompt": null}
{"id": "5723479b-01c4-49c9-858b-24694afe2063", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 4  # Increased local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Increase local topology size to improve information sharing among particles.", "configspace": "", "generation": 78, "fitness": 0.3636878423859071, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8752226526485007, 0.8484634925218042, 0.8898387491858422, 0.8716991802832104, 0.8732363519934611, 0.8724304138537176, 0.861309280335338, 0.8753713935014656, 0.8667989321346613, 0.7363906864317808, 0.747181130826557, 0.7745210216956411, 0.742745761518627, 0.733094835534893, 0.7105803775151255, 0.7167760159820702, 0.7299591722455718, 0.7262994157522428, 0.13947870754818692, 0.14164908257026232, 0.11443473849268193, 0.10941741173267894, 0.11630967260240521, 0.18725458958460572, 0.0961893697756997, 0.14425332177490946, 0.16039022629674216, 0.12239988429066329, 0.09137157131158435, 0.09450275197390534, 0.08607174451624033, 0.07896426194027995, 0.09331760370664777, 0.09646985973436062, 0.09476869066176274, 0.12028553124978103, 0.9373751229016488, 0.934367100312557, 0.9361301471041648, 0.9276490174137825, 0.9322285182590108, 0.932252558666582, 0.9458557965008053, 0.9089186831343876, 0.9397425880287195, 0.7613882510484233, 0.7582607691395002, 0.7151508192568796, 0.7456101364064947, 0.771949719309931, 0.7338928308903616, 0.7771614246746542, 0.7260522440041799, 0.7281569186697034, 0.22998252322337753, 0.37970637144666997, 0.22806119909924893, 0.3844542617040345, 0.3798042520551139, 0.21312429296088287, 0.2324677352536868, 0.2259605388272773, 0.24729140216589762, 0.2931748245753669, 0.12881098950863712, 0.2959841326467012, 0.29810645056725116, 0.2899202414563735, 0.2984013647944216, 0.3298255986494327, 0.342605278518362, 0.30832969217524264, 0.26507338805670266, 0.28303724028292043, 0.2972701769155469, 0.32956456236243503, 0.333188869598936, 0.30220396395569404, 0.28667604906922317, 0.33150935082977306, 0.13472432583526628, 0.03698458598747478, 0.09300411346323834, 0.08379138032754274, 0.05644040688422702, 0.21162436778927207, 0.05369232625629661, 0.05360719982278028, 0.024607545821901278, 0.12855390745604311, 0.11255057128230106, 0.09426913312474439, 0.10870010536171848, 0.08092948378269826, 0.026970330671019616, 0.01476438536845448, 0.17038168500199846, 0.0926488987184162, 0.1244698168763787, 0.2070398731206159, 0.1118092511222809, 0.18550964187584107, 0.1311338493526253, 0.08353680042436173, 0.1325864611435441, 0.1654408336351828, 0.12350410985418026, 0.1905264933213785, 0.1463391328789435, 0.08429812627449063, 0.1162625127667698, 0.09790316787497355, 0.1002313878250487, 0.17273835677744465, 0.08122904065166914, 0.2624251171100045, 0.1730500896561975, 0.5732080029093785, 0.5574045561220836, 0.5564039178594782, 0.5829850269115818, 0.5739313322512056, 0.5598898619374605, 0.6147821707984451, 0.6258416188935096, 0.5751203856826377, 0.06376972778883061, 0.0873230140558029, 0.09337680950521043, 0.15561856188311562, 0.12352473310878664, 0.0654519905300418, 0.12298419718263032, 0.11103190751881598, 0.09182405143133021, 0.3397443741444166, 0.2089942411682958, 0.33222219650295925, 0.2256668580898995, 0.7566854759137912, 0.491538240670616, 0.40601060743688355, 0.2822796168511893, 0.7339045873989799, 0.3754117071866033, 0.21156935320914816, 0.33283150773642933, 0.5595994769766636, 0.5962028290496735, 0.5116469451177122, 0.5001409400561383, 0.3875736277784484, 0.4278561795792629, 0.1724904382400657, 0.39632941631578467, 0.22275102638847066, 0.45433791941869606, 0.23353975110486547, 0.37822958378964777, 0.24044184924345813, 0.3390296307371091, 0.22034721450968697, 0.24334907084568236, 0.2181703246663529, 0.21800976890306845, 0.198593433836747, 0.19816882934122426, 0.2494387020925266, 0.2743282638096606, 0.24172915661410044, 0.24644073284995238, 0.19757521516691323, 0.8253175693799373, 0.20728683951526228, 0.2518376092867751, 0.22499285269147484, 0.22425248519452867, 0.19070525886933187, 0.22375318895630303, 0.17974814527366212, 0.18735185790740894, 0.187572610069066, 0.18793227674002466, 0.930896429844318, 0.20012017514562308, 0.9203990940061237, 0.9177226787237951, 0.9209461949674503, 0.914163280764892, 0.8985421847512413, 0.7985498466638615, 0.815194195204781, 0.908578312603816, 0.09472539619758136, 0.8859771510320539, 0.10496477330742926, 0.1657941823740453, 0.8527565694408928, 0.18800084088905678, 0.38283075408557155, 0.2538030964954535, 0.23323091193342982, 0.2882566282440223, 0.2552479889185071, 0.2592699003997193, 0.19501441280054, 0.24421174063599094, 0.09030992213292233, 0.072066194779704, 0.07454522851429468, 0.11534759206302825, 0.08895142631541564, 0.07834656614826163, 0.10981527047851036, 0.10008413820013606, 0.09510512865600251]}, "mutation_prompt": null}
{"id": "2aec586d-de39-4e1a-957b-028328604730", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand() * (1 - evaluations / self.budget))  # More aggressive inertia weight decay\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduce a dynamic inertia weight that decreases more aggressively as evaluations increase to enhance convergence speed.", "configspace": "", "generation": 79, "fitness": 0.37501449026101885, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.30.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.9030197054747189, 0.8938444324964225, 0.8867884100147556, 0.8723596586998634, 0.878738772862143, 0.8824636620664336, 0.8711312076563249, 0.8785507284663776, 0.8874134366769458, 0.7648754167855571, 0.7771838212960698, 0.7650973146352028, 0.7703463219765697, 0.7391081165017909, 0.7256405000361739, 0.7287306073260913, 0.7270008630631188, 0.7250988729148966, 0.08878410771088385, 0.12388697230593715, 0.07149177720596667, 0.09990486208111449, 0.11687676134827418, 0.14260529048796655, 0.08065044802914467, 0.11390401633178193, 0.11091769457116807, 0.11742089393671629, 0.15660856154020453, 0.08501084907200296, 0.09833874169689749, 0.08166718619554525, 0.11565042056936259, 0.1005239855087644, 0.11469883608743547, 0.11947210121380702, 0.9319676891496337, 0.9279566577710947, 0.9361417090800892, 0.9263424076949176, 0.9283870704787164, 0.935052762185254, 0.9396675994624264, 0.9121489502514167, 0.934083860154426, 0.7636677569066914, 0.7987578983225521, 0.7622154390031597, 0.784883038148829, 0.8047019048113215, 0.7919827094182994, 0.7697111607396572, 0.7728214380367102, 0.762661646358745, 0.2291698642234672, 0.17095499013535986, 0.2264733931897237, 0.9067301084093473, 0.27743140738541905, 0.8830537664597147, 0.21471463856845052, 0.2236956102818226, 0.865871919289379, 0.2908884580460567, 0.13161158225365066, 0.28035499111232354, 0.3185957716940532, 0.3140664263891203, 0.29081662376518536, 0.35072124113695013, 0.3460414480012498, 0.3182076596896838, 0.2794414964038707, 0.27648129918150655, 0.13423477544956786, 0.3151767584181574, 0.3343429861633862, 0.3188709912056107, 0.3154029698551186, 0.3306101356074802, 0.32450654393201106, 0.006429129463642824, 0.183081164132035, 0.03898793648790666, 0.062145965397474856, 0.005769350038265619, 0.0521481758934117, 0.07494790111517591, 0.047359574460477005, 0.10947508564325859, 0.18307676538343054, 0.09896552568321282, 0.09065940724819721, 0.08514296754433237, 0.01864071885986418, 0.029526944455966597, 0.19819715166805807, 0.09734023818874427, 0.11820461734191812, 0.17704087583521522, 0.24467203143073835, 0.2753392767010874, 0.1353327273752808, 0.09658396920250545, 0.15147533721923923, 0.19879364276236888, 0.18926519912972972, 0.12048166824276618, 0.2935945714889142, 0.12821461067999151, 0.08328768884302173, 0.12895236243900576, 0.2403047936421272, 0.23943510282380787, 0.08864206913415751, 0.13343930223762868, 0.08236878876488152, 0.5706628517535555, 0.6245602533547634, 0.5871634428460553, 0.615356128608909, 0.5503247928462067, 0.581731882137612, 0.6055933259075977, 0.608179058363008, 0.6213122526359063, 0.10274803539998412, 0.06266982725470538, 0.11084192445945196, 0.11518693606854935, 0.10882922848493326, 0.09588871540384858, 0.14301145840610185, 0.1404956522589499, 0.11674955622744432, 0.3247015851793382, 0.1507343559924741, 0.19836979639369456, 0.21221718041544302, 0.735616903519585, 0.6842894948467817, 0.4897023463612258, 0.5875421862270847, 0.6339834083907054, 0.44132414163436284, 0.34903187482582954, 0.34317766977974684, 0.4455797417864623, 0.338703367141272, 0.6087458071047195, 0.215380345379653, 0.4494806882349086, 0.2573424630863025, 0.24617557300455484, 0.37389328486276485, 0.24129190802450817, 0.33405397014978466, 0.23632508797556606, 0.3215394820769296, 0.2668907741118699, 0.24474925690926796, 0.23625319282972346, 0.28723982921580493, 0.20509796966669147, 0.29984112883285774, 0.22829664661725235, 0.25253947283915645, 0.24706499677733218, 0.29516186732728245, 0.1926777960134205, 0.24875503610853722, 0.18987921597076307, 0.2522909339117254, 0.19591515664583992, 0.2508942901958072, 0.1983851616490736, 0.2106569838900818, 0.1830677060420257, 0.20071391208322875, 0.18231550713707934, 0.187355394084312, 0.1785800896963734, 0.18803745919876225, 0.9295723740684904, 0.20030094929794984, 0.9149975303168683, 0.9121133929818714, 0.9298325259852708, 0.9459777969974662, 0.8653052474308529, 0.853177059230199, 0.8277343368948803, 0.9057178132373234, 0.15432518515198312, 0.9118331465773717, 0.906148805065354, 0.10449782146798459, 0.8697522948511571, 0.21389941999914264, 0.22598462470815905, 0.2653391234007386, 0.20025825988209522, 0.2527571403763582, 0.31282165130643125, 0.24885427613801525, 0.2615081589843026, 0.2056677857798107, 0.10912896390318405, 0.08328512927865772, 0.12434689363228257, 0.07377463273835672, 0.08818875894701084, 0.0757759250399751, 0.07586545819233181, 0.088000109652285, 0.088471996278502]}, "mutation_prompt": null}
{"id": "1fc22b77-521d-4365-b49e-3f0595059868", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + 0.3 * (1 - evaluations / self.budget)  # Slightly adjusted inertia weight for adaptive behavior\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduce a slight adaptive tweak to the inertia weight `w` to enhance convergence dynamics.", "configspace": "", "generation": 80, "fitness": 0.3592035929407678, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8667411491497762, 0.8815356921923256, 0.867287850241373, 0.8497112887140452, 0.8597145328039992, 0.8633826539874554, 0.8563583908863769, 0.8609331905158564, 0.8572862367359412, 0.7160973835763154, 0.7332355152785859, 0.7173261066653619, 0.7246149345357811, 0.6955949948356848, 0.6799272576921253, 0.7263231539921426, 0.7070955763778624, 0.668826685723933, 0.12259158181652996, 0.12397360553079562, 0.0843535141868379, 0.1591252294215163, 0.12927239787577183, 0.1428559178940546, 0.08253823976696317, 0.15692688025650947, 0.13144414741873212, 0.12159348889514565, 0.08133155159299499, 0.09420358090534608, 0.11553201289618897, 0.0786558764661931, 0.1153160364347432, 0.12068784496812046, 0.1137441782409625, 0.07154158454841231, 0.9373890955595734, 0.942295550193752, 0.939141269461533, 0.9264690506270261, 0.9330883495765077, 0.9265984096275203, 0.9390444796405781, 0.9186628941379109, 0.9463806594967065, 0.762053959002037, 0.7650973103065247, 0.7543957825289375, 0.7699606041347459, 0.7475213222217114, 0.7552608008291631, 0.7605664748564498, 0.7589800639175256, 0.7638669203644021, 0.8991148275412015, 0.22749692241685626, 0.37300770564088803, 0.373292913947327, 0.897287394583311, 0.2125690662420726, 0.1779760102898421, 0.23557158038117887, 0.8925690132894428, 0.27160321182721514, 0.3054973939911133, 0.30441543023504536, 0.31618257573288633, 0.33561520287008184, 0.2849316574791314, 0.2891855665142806, 0.31647477144557, 0.3192336207901024, 0.27843330287590673, 0.2843968499789108, 0.13203455770986094, 0.3158228231025231, 0.30697903310027697, 0.4284467236130943, 0.2958603396923415, 0.3149170975869442, 0.29631535100952155, 0.06082954740226154, 0.03935120052298591, 0.061731145352858396, 0.022281423589653238, 0.010869699542535582, 0.04597245856398735, 0.11300769574519487, 0.010900656770109207, 0.1272546807106526, 0.1071742770140569, 0.10074617659860541, 0.13957151351641373, 0.09298700331406251, 0.04430809152592896, 0.07051895419763299, 0.2443906179407429, 0.09324160562980977, 0.14828574562301367, 0.1607231916422417, 0.1862448931638131, 0.20727204738168525, 0.1149263694916357, 0.17807263188300326, 0.10354108169444753, 0.18542548376594037, 0.17258217529390352, 0.08331319071074139, 0.2394837269764758, 0.15087668720676406, 0.19016409873993767, 0.15773628962329245, 0.2793959675830432, 0.1217264949973913, 0.08211977651297642, 0.08282559572047832, 0.08380590987925929, 0.6526126133440628, 0.5610117761827373, 0.569059926393698, 0.5817887795353807, 0.5901580953471895, 0.6271308035056797, 0.5986999011720924, 0.6190719600563818, 0.593255067032519, 0.11394432693552758, 0.1293964407127296, 0.07628652793393598, 0.1329563868014606, 0.1524998604706992, 0.1306471608279055, 0.09924506789466558, 0.12975276036466044, 0.08607240919788162, 0.7078655584774813, 0.24685477533961253, 0.14381145350360935, 0.23617517476122818, 0.27027532522131825, 0.3418747712604291, 0.27683723159071105, 0.20975241241547415, 0.43873727516628647, 0.436160772730115, 0.3682218025066232, 0.3655780098391428, 0.5677363826981849, 0.2843963270960811, 0.6974304931146, 0.25568590185579476, 0.5627706649544242, 0.2668249319257444, 0.23892016742491173, 0.28422859026826397, 0.1898470474731071, 0.29408669532505094, 0.22548920008371642, 0.41195160057903135, 0.24308396270995536, 0.2590475519341694, 0.2295351354531635, 0.23977730165093736, 0.2037276935477469, 0.22961283171024338, 0.2603020283690275, 0.2143043796017452, 0.21548455748609607, 0.2212970021063707, 0.183160205746428, 0.25174901505988523, 0.2077265377833888, 0.2220481815958273, 0.20855346511116613, 0.21361015302437303, 0.22543558325167368, 0.20828610289947236, 0.19940127495230753, 0.22160974542026723, 0.21034688878433683, 0.17680036739674365, 0.17795845851341296, 0.1781659049614187, 0.9227425771181434, 0.20058888700476307, 0.918070348749759, 0.14271835703957492, 0.16962136536517647, 0.9141768002745736, 0.8207323323534731, 0.8380569352920217, 0.860796908551456, 0.8826785698843262, 0.1677899065065338, 0.8923337383211659, 0.10464151443843461, 0.1672779431065171, 0.8518473524163384, 0.21822425682066393, 0.4410988211635467, 0.24089283066051637, 0.2641347730939605, 0.23096009445631716, 0.26920026755855453, 0.32424518705820404, 0.28055471924487374, 0.2433684004555463, 0.08686514443489357, 0.10788899984580325, 0.10732386988199849, 0.0867532363523622, 0.08677856962258779, 0.08754201212627755, 0.08490705973577839, 0.10129688801084136, 0.08239834065272478]}, "mutation_prompt": null}
{"id": "1fdd88ef-98d9-4e28-887a-ce9cb9fc20c1", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.45 * np.random.rand())  # Adjusted decay for inertia weight\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Minor adjustment to inertia weight decay for improved convergence speed.", "configspace": "", "generation": 81, "fitness": 0.36391515803425883, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.894631064608326, 0.8932094643356345, 0.8915416359068054, 0.8757894277425443, 0.8709741876721218, 0.8804141786621271, 0.874252438026389, 0.8807640917096623, 0.8765667883854674, 0.7492377471314693, 0.7384924073297447, 0.7530501007761083, 0.7541132505238074, 0.7441142458186484, 0.717266517895595, 0.738842900898368, 0.7391871718732933, 0.7189741847575354, 0.11462327282024942, 0.13113160847248562, 0.11661545376862481, 0.10390352854743579, 0.08525835275752147, 0.15744245181359218, 0.09194332233517666, 0.14216480054365288, 0.1823164105299654, 0.122886934030488, 0.09147035293710848, 0.07889272685245452, 0.14270540624377992, 0.11606218592639816, 0.1082867624337418, 0.09949423789274647, 0.1419060582634587, 0.11480729349396135, 0.9343201806435844, 0.9335856393682563, 0.9332613649746637, 0.9295184818030302, 0.9204701693788802, 0.9320650833768197, 0.9398994618392311, 0.9087620620816423, 0.9304979630261309, 0.7553792893851783, 0.7696685674066833, 0.7623023069222602, 0.7714363536643967, 0.7529252379651635, 0.7848437158057889, 0.7877504800764051, 0.7684991435911158, 0.7441873695902077, 0.3317782819255177, 0.22684625871649589, 0.17078817788706802, 0.8804539903710986, 0.2131772988342714, 0.2777802756444524, 0.1775518314015666, 0.17787381261836055, 0.24335542463002824, 0.28115586438731666, 0.1331866590952261, 0.28328965655272664, 0.2852362652555669, 0.32604239632794396, 0.3010242324627652, 0.30132385644678605, 0.32835224685334796, 0.32110648355453597, 0.2598807509445834, 0.2699799373894819, 0.13407710519481864, 0.3372048596151671, 0.33862956443955516, 0.31505403159059864, 0.2951087036829618, 0.30452827242607805, 0.30037103951622257, 0.07037108920849111, 0.03745069563789016, 0.09875871286625337, 0.08638618545305143, 0.11626290842122267, 0.10777172872482332, 0.06592562960341364, 0.027165422564070618, 0.1551367876782913, 0.1029505724581854, 0.12481714629155227, 0.12598430642346392, 0.06655306743253386, 0.03484552259986773, 0.042108972805112166, 0.13786052828063877, 0.08538786850884028, 0.1448893429208401, 0.23388626468922835, 0.3788127068189988, 0.20349508075578415, 0.12223195066304982, 0.07973569643820644, 0.21030164193473544, 0.19073336405171049, 0.16479915278056356, 0.0912347346513459, 0.15319216108728073, 0.13843136181966598, 0.09053487676297844, 0.08161594470407196, 0.1790535102032591, 0.2573754763223256, 0.08233186231599121, 0.17501241302255788, 0.0835781042903112, 0.5707969558318999, 0.5908102329363748, 0.5393521899645957, 0.5730863931412035, 0.5454980880045519, 0.6630478237099834, 0.5802418699610132, 0.6501013058090712, 0.6736531320290231, 0.09176558941239998, 0.08410722925706837, 0.09632355916023716, 0.1862406225689488, 0.09245695471404092, 0.16180035189377062, 0.11472635597067893, 0.13210516517594784, 0.1233986319082031, 0.2780645339207305, 0.5525074661421145, 0.15592399871636353, 0.16849889374400795, 0.3458386944506965, 0.18921856489516586, 0.27405960364388027, 0.20201006145552447, 0.47321996626595086, 0.269699797730347, 0.3537504075146328, 0.35057189711846093, 0.4630900780820393, 0.2846459508953546, 0.6334523082837107, 0.26899246049368164, 0.543487282523906, 0.2566264784515043, 0.3710621291199625, 0.2950988751225374, 0.21002294433554913, 0.4515401991707494, 0.22944809352158368, 0.41709924546617116, 0.18223136807996765, 0.36593916318081965, 0.23826917009094917, 0.2939385893726747, 0.21677189327613755, 0.24623727596923017, 0.24357615523814358, 0.26567300403262417, 0.18799990248860488, 0.21124416214090358, 0.26372078702838153, 0.2737169349315207, 0.18292906288769728, 0.25107727044536987, 0.2088227493175555, 0.20956213364827825, 0.19138059632193627, 0.19361525204998775, 0.1772629620648406, 0.19723338230535492, 0.19110796194932678, 0.18742250404411231, 0.18806221502672604, 0.18785700517218495, 0.9302086321651345, 0.2003338790555288, 0.9239868145737878, 0.9224248675200215, 0.9286416104004858, 0.9259781049026015, 0.8822047733225761, 0.861193414170315, 0.9159376169687823, 0.9089454645635763, 0.15441387676978224, 0.9080280918474402, 0.8831268402144659, 0.10450296809221038, 0.8525738168003647, 0.2683311737757528, 0.22145391369926415, 0.24556000236909636, 0.35044777433583985, 0.18608481135282395, 0.22236479525148212, 0.25008774656361543, 0.27932934567437273, 0.23762315212796326, 0.08152723429735687, 0.09856849262705092, 0.06838950113828957, 0.09861063102083334, 0.092408042959914, 0.10583706725239794, 0.09324815544759912, 0.0846240006862592, 0.1007377363048858]}, "mutation_prompt": null}
{"id": "597383f3-9b58-46d6-8572-1ea207099314", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.45 * np.random.rand())  # Slightly adjusted decay formula for inertia weight\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))\n                diversity = np.std(pop, axis=0).mean()\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Slightly adjust the inertia weight decay formula for improved exploration-exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.36391515803425883, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.894631064608326, 0.8932094643356345, 0.8915416359068054, 0.8757894277425443, 0.8709741876721218, 0.8804141786621271, 0.874252438026389, 0.8807640917096623, 0.8765667883854674, 0.7492377471314693, 0.7384924073297447, 0.7530501007761083, 0.7541132505238074, 0.7441142458186484, 0.717266517895595, 0.738842900898368, 0.7391871718732933, 0.7189741847575354, 0.11462327282024942, 0.13113160847248562, 0.11661545376862481, 0.10390352854743579, 0.08525835275752147, 0.15744245181359218, 0.09194332233517666, 0.14216480054365288, 0.1823164105299654, 0.122886934030488, 0.09147035293710848, 0.07889272685245452, 0.14270540624377992, 0.11606218592639816, 0.1082867624337418, 0.09949423789274647, 0.1419060582634587, 0.11480729349396135, 0.9343201806435844, 0.9335856393682563, 0.9332613649746637, 0.9295184818030302, 0.9204701693788802, 0.9320650833768197, 0.9398994618392311, 0.9087620620816423, 0.9304979630261309, 0.7553792893851783, 0.7696685674066833, 0.7623023069222602, 0.7714363536643967, 0.7529252379651635, 0.7848437158057889, 0.7877504800764051, 0.7684991435911158, 0.7441873695902077, 0.3317782819255177, 0.22684625871649589, 0.17078817788706802, 0.8804539903710986, 0.2131772988342714, 0.2777802756444524, 0.1775518314015666, 0.17787381261836055, 0.24335542463002824, 0.28115586438731666, 0.1331866590952261, 0.28328965655272664, 0.2852362652555669, 0.32604239632794396, 0.3010242324627652, 0.30132385644678605, 0.32835224685334796, 0.32110648355453597, 0.2598807509445834, 0.2699799373894819, 0.13407710519481864, 0.3372048596151671, 0.33862956443955516, 0.31505403159059864, 0.2951087036829618, 0.30452827242607805, 0.30037103951622257, 0.07037108920849111, 0.03745069563789016, 0.09875871286625337, 0.08638618545305143, 0.11626290842122267, 0.10777172872482332, 0.06592562960341364, 0.027165422564070618, 0.1551367876782913, 0.1029505724581854, 0.12481714629155227, 0.12598430642346392, 0.06655306743253386, 0.03484552259986773, 0.042108972805112166, 0.13786052828063877, 0.08538786850884028, 0.1448893429208401, 0.23388626468922835, 0.3788127068189988, 0.20349508075578415, 0.12223195066304982, 0.07973569643820644, 0.21030164193473544, 0.19073336405171049, 0.16479915278056356, 0.0912347346513459, 0.15319216108728073, 0.13843136181966598, 0.09053487676297844, 0.08161594470407196, 0.1790535102032591, 0.2573754763223256, 0.08233186231599121, 0.17501241302255788, 0.0835781042903112, 0.5707969558318999, 0.5908102329363748, 0.5393521899645957, 0.5730863931412035, 0.5454980880045519, 0.6630478237099834, 0.5802418699610132, 0.6501013058090712, 0.6736531320290231, 0.09176558941239998, 0.08410722925706837, 0.09632355916023716, 0.1862406225689488, 0.09245695471404092, 0.16180035189377062, 0.11472635597067893, 0.13210516517594784, 0.1233986319082031, 0.2780645339207305, 0.5525074661421145, 0.15592399871636353, 0.16849889374400795, 0.3458386944506965, 0.18921856489516586, 0.27405960364388027, 0.20201006145552447, 0.47321996626595086, 0.269699797730347, 0.3537504075146328, 0.35057189711846093, 0.4630900780820393, 0.2846459508953546, 0.6334523082837107, 0.26899246049368164, 0.543487282523906, 0.2566264784515043, 0.3710621291199625, 0.2950988751225374, 0.21002294433554913, 0.4515401991707494, 0.22944809352158368, 0.41709924546617116, 0.18223136807996765, 0.36593916318081965, 0.23826917009094917, 0.2939385893726747, 0.21677189327613755, 0.24623727596923017, 0.24357615523814358, 0.26567300403262417, 0.18799990248860488, 0.21124416214090358, 0.26372078702838153, 0.2737169349315207, 0.18292906288769728, 0.25107727044536987, 0.2088227493175555, 0.20956213364827825, 0.19138059632193627, 0.19361525204998775, 0.1772629620648406, 0.19723338230535492, 0.19110796194932678, 0.18742250404411231, 0.18806221502672604, 0.18785700517218495, 0.9302086321651345, 0.2003338790555288, 0.9239868145737878, 0.9224248675200215, 0.9286416104004858, 0.9259781049026015, 0.8822047733225761, 0.861193414170315, 0.9159376169687823, 0.9089454645635763, 0.15441387676978224, 0.9080280918474402, 0.8831268402144659, 0.10450296809221038, 0.8525738168003647, 0.2683311737757528, 0.22145391369926415, 0.24556000236909636, 0.35044777433583985, 0.18608481135282395, 0.22236479525148212, 0.25008774656361543, 0.27932934567437273, 0.23762315212796326, 0.08152723429735687, 0.09856849262705092, 0.06838950113828957, 0.09861063102083334, 0.092408042959914, 0.10583706725239794, 0.09324815544759912, 0.0846240006862592, 0.1007377363048858]}, "mutation_prompt": null}
{"id": "96773599-9977-4366-8245-08dc99304eae", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 1.5 * eval_ratio  # Changed from 2.5 to 1.5\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjust the social parameter `c2` formula to improve swarm convergence in later stages.", "configspace": "", "generation": 83, "fitness": 0.3703989978851477, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8693977389249299, 0.8757064839121608, 0.8794143875253674, 0.8576617425583283, 0.8541630806301583, 0.8826858751438582, 0.8725507295256838, 0.8700457799869129, 0.8699814046289766, 0.7467315454286596, 0.7362925953393814, 0.7163443678764544, 0.7254957730598666, 0.7613988547563891, 0.06490815313399112, 0.7273128256840875, 0.6860239092812974, 0.7439215772347483, 0.128182514854158, 0.12251183750900596, 0.09465943188189996, 0.10994165800226852, 0.1232959139277422, 0.18505459046170614, 0.08947457691614458, 0.0917813445961898, 0.1411853274844037, 0.11329551090331846, 0.09549555053715686, 0.09608204516189456, 0.11484285126643512, 0.10970556287260647, 0.10874988177426603, 0.09511463578142376, 0.11621244222722904, 0.10859765929960685, 0.9284068742258451, 0.927643987964657, 0.9331421267989974, 0.9262991824774222, 0.9245428283601702, 0.9355128907591262, 0.9397932444414471, 0.9172324988017462, 0.9313600047689299, 0.7773727098824503, 0.7857056977931228, 0.7311700419755335, 0.750783422499013, 0.7452226300626827, 0.7655113754475112, 0.7462031144309135, 0.7327206795125423, 0.7657894766863222, 0.3861874385482824, 0.1709519394965512, 0.22705509871544216, 0.9030531526934903, 0.21222517253465123, 0.2124319929239169, 0.17744663457087717, 0.1774917602363999, 0.872411930491524, 0.34238587306519086, 0.12842475561647337, 0.2944211800205133, 0.29218111392572876, 0.2915377537650127, 0.3078589968309383, 0.28703165949346543, 0.3169574455275419, 0.334886287492833, 0.29057046384229246, 0.2878903206287913, 0.13432618401461116, 0.33337613755597995, 0.31994623251808163, 0.32299465055977006, 0.3075462587685095, 0.3173206520662991, 0.31389526872871265, 0.021940453601671073, 0.10629328349138856, 0.15498515715096306, 0.11723121771830358, 0.04340853860221283, 0.13607223378546118, 0.03816251336154708, 0.028602900464729242, 0.19610463245304877, 0.09342598148723735, 0.09883550998376889, 0.12207233295992737, 0.06420694655740422, 0.0442668050313878, 0.03384715795877857, 0.15469604183569863, 0.16585649905532696, 0.1351901150374888, 0.20149671434023753, 0.15473935453393317, 0.20771080628127647, 0.12486123533946869, 0.07974402518931423, 0.12696582192666117, 0.37439177020245107, 0.29700787227503367, 0.11846640389573149, 0.48550018501200476, 0.1343244591508641, 0.13733396402048803, 0.14879709027273003, 0.2333818003343907, 0.3172766753095001, 0.09985670553860304, 0.3087558146068775, 0.08259536376412946, 0.5726406245019788, 0.6129468880706681, 0.5835519061400958, 0.6274460644630117, 0.5666491347352518, 0.5692501586995106, 0.632856967141783, 0.585271741118524, 0.5890471742515653, 0.1532665453958031, 0.08470777434080479, 0.0897654095869892, 0.15642143654109897, 0.06886506189997832, 0.1564004025460185, 0.10927706427964767, 0.18317919693733575, 0.12065765696728958, 0.5813334861329653, 0.5735785143437747, 0.13514450118797283, 0.3658572557622639, 0.4724874239687452, 0.2730281081509959, 0.6801634810981225, 0.12706965470652776, 0.33521501433899137, 0.29268704759970343, 0.5057237924551533, 0.41604147182536233, 0.4276057407567576, 0.39912243703910655, 0.4617331545322819, 0.5335698985184532, 0.38613682377341396, 0.271034323850724, 0.2612806515841085, 0.3035417708479531, 0.20146778381444952, 0.26376213896835377, 0.2800733853777567, 0.3647473817435811, 0.24415432869234455, 0.36382133674540307, 0.22977183212145935, 0.2265300183828609, 0.17811273366545177, 0.2402424491386268, 0.22618332651224404, 0.28546797836303106, 0.21822467596090378, 0.21484967643341835, 0.20811771640779975, 0.2410857868346925, 0.20790896001973813, 0.19881019563944802, 0.19633418804069502, 0.2500840544854741, 0.210686740528783, 0.22215132837257945, 0.1681015967379852, 0.20612356556668643, 0.19140670312519492, 0.1873156553098202, 0.17860456624081855, 0.1877783107631722, 0.9270882083575149, 0.2002988618606516, 0.9298143707586567, 0.92108959885541, 0.9247650905329841, 0.9324374730922641, 0.8522476904447797, 0.8718272146691755, 0.8005097255765038, 0.8880976693380763, 0.1675569483912206, 0.9121292871462063, 0.8639593251978267, 0.10443677974246313, 0.8480366449890001, 0.22674368484597063, 0.4359555947672378, 0.25066358261634125, 0.28203128844424663, 0.33537958735685947, 0.20206142952170525, 0.2379783499145891, 0.25490294433831884, 0.2575323873617643, 0.08743186429190719, 0.08434846183721056, 0.07834456190646744, 0.09034126561835787, 0.1086792013387401, 0.10746633805988492, 0.08406118424706821, 0.08946809837219993, 0.09218097117771762]}, "mutation_prompt": null}
{"id": "d0f6b1ae-a8ec-4845-98a9-93eb1579cd84", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.5 + (0.4 * np.random.rand())  # Adjusted inertia weight update formula\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Slightly adjust the inertia weight update formula for improved adaptation over iterations.", "configspace": "", "generation": 84, "fitness": 0.3676810940459812, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8694290194754404, 0.872483610246804, 0.862582639756014, 0.8511082577694886, 0.8348614690192147, 0.8245555265433466, 0.8366586189750528, 0.8426682496411965, 0.8451726772635645, 0.6549669947854775, 0.6676499935877939, 0.6817233149454082, 0.6397741488902265, 0.6440364024771752, 0.6387706737930854, 0.6624001981106284, 0.5981986124387955, 0.6928737629194361, 0.09967338917038837, 0.11599292640866621, 0.15432653721150325, 0.11779085598592887, 0.091416567581448, 0.12319702851130843, 0.09303236382673208, 0.10511653040984403, 0.1433996531860683, 0.11112814426423756, 0.11568214885583761, 0.11146143901122318, 0.1102586321357708, 0.12333822040836384, 0.1385663956569062, 0.11420617330247329, 0.08482192128171717, 0.11283799483761559, 0.9330378762838867, 0.9396505261117738, 0.9338572233175652, 0.9362077193800585, 0.9338552103229562, 0.9291188484999509, 0.9445291230784869, 0.9213426222933844, 0.9299568235383029, 0.7340964898394571, 0.712932659769087, 0.7006760317733646, 0.7289135767209565, 0.7120973612050492, 0.7122772951666209, 0.6915142037986198, 0.7009478319279758, 0.6860838453774687, 0.8793666769650578, 0.22680155577725414, 0.22655234882163122, 0.8594436987433789, 0.7062321863227569, 0.7894207607065807, 0.7312204817594264, 0.1770549658591435, 0.23628550542212512, 0.3703777428203463, 0.13059965616034186, 0.2639057456820828, 0.2626815079896043, 0.26024728640747097, 0.2762289666826876, 0.2432173735403791, 0.28236281861474477, 0.2560867600872445, 0.26137083076846435, 0.26282703871620805, 0.1341155527911524, 0.28790501508167654, 0.13336102747143685, 0.26224394932510475, 0.2631759662361738, 0.27513783559993077, 0.27147364113472083, 0.028980915551914177, 0.08740675601427284, 0.02645974762865022, 0.010530761699897973, 0.12097393514595589, 0.013174930725295964, 0.06178450508340594, 0.009968099371855943, 0.14857065756351717, 0.11171102868603322, 0.12310178551662865, 0.12074281198886527, 0.0489788202286745, 0.038619450324796745, 0.061062948552826124, 0.11976100285534408, 0.08786938543466527, 0.21033610812466086, 0.12961012602873123, 0.10752775726679542, 0.16330986565873662, 0.16055519737324087, 0.08690275228113664, 0.13061061459515133, 0.17977807106866128, 0.09832953715057269, 0.09970029414240833, 0.23196404296392692, 0.19051852504918565, 0.10199534384781306, 0.0802204654246822, 0.23997612609146668, 0.15599386642202495, 0.08179594678046431, 0.15745601909671458, 0.15906212504736306, 0.5273489661149259, 0.5641093020469958, 0.6001937307099368, 0.6393586085494635, 0.6108851786833819, 0.5864760024780035, 0.61372206016526, 0.6209004665914382, 0.6024248911625316, 0.09913905753851415, 0.08453175940873248, 0.11216805441876132, 0.12101711249540148, 0.10315934088404732, 0.07897907532089321, 0.10094816986643695, 0.1816829511389172, 0.11295595322269125, 0.3534965702618431, 0.27512105036993784, 0.6322457187120041, 0.6017921555281757, 0.5458606351672355, 0.44485209604136433, 0.5075405063735016, 0.22418782828550188, 0.6590266987485021, 0.5053902780702524, 0.5671528320756389, 0.2813313282165705, 0.48743750759459437, 0.36961059909779614, 0.3832383426377468, 0.4746140255067204, 0.5246567112565846, 0.43359822749508425, 0.3216255551694692, 0.38592594881821696, 0.1937146384457088, 0.30975750418448633, 0.2550812676029619, 0.3276333818628687, 0.23918987871964303, 0.32776839116741974, 0.2191859818041817, 0.18138929753613697, 0.21943238813221355, 0.23020566696036326, 0.2533790717905282, 0.20680381970864115, 0.2846032786207793, 0.30815086942553027, 0.226571159850242, 0.23184177301447617, 0.20149210047062294, 0.2164163502845028, 0.20026413284301514, 0.2253023823364224, 0.2106237495801877, 0.17956684961213432, 0.20184056988432875, 0.2272767423358235, 0.18261686266025423, 0.18751580524180445, 0.1781661081789132, 0.18806793321923942, 0.9090194128671607, 0.2005351383028422, 0.899448973357612, 0.9158925974595025, 0.9130917426650864, 0.9166734786229076, 0.8199864641890445, 0.7597127713130992, 0.8872606228082314, 0.8493058577431656, 0.16763097339770816, 0.8501539227567594, 0.7804973777958271, 0.10443794424227748, 0.8201698992153391, 0.28951222565337376, 0.2860215535537527, 0.2289176535908376, 0.23169997797539188, 0.34838632734313013, 0.2322065053095823, 0.24494596670516455, 0.26957905537808247, 0.20959150190468623, 0.10635845380915265, 0.10570270502646384, 0.09489466464815888, 0.10440161720568197, 0.07359455003030524, 0.08641463088646051, 0.08825925907960608, 0.09100129264409429, 0.09895436139233738]}, "mutation_prompt": null}
{"id": "0cebce8b-8655-4df3-8ae9-e8f161490ec7", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.6 * (1 - eval_ratio) + 2.4 * eval_ratio  # Changed formula for improved balance\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Slightly tweak the social parameter `c2` formula to improve convergence rate and exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.3683446106164843, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8778178248637506, 0.8831899995649355, 0.856323233526143, 0.8737368653637504, 0.8702139825070128, 0.8687541015257346, 0.8651514900804543, 0.862139207713813, 0.8660535370670088, 0.7697559598086207, 0.7365371750538234, 0.7251143306323515, 0.7146703280480933, 0.7393349838116794, 0.6632375926266036, 0.7240354767726237, 0.7447552585873615, 0.695302278095004, 0.10175471007980719, 0.08241819064590905, 0.115937206223939, 0.11616937782549774, 0.11026600161957467, 0.18736913100311936, 0.09652031491681068, 0.15835555963609582, 0.10592160615136503, 0.1071241815357411, 0.08384918423987642, 0.08372681608851695, 0.09667387504308955, 0.09980461180839117, 0.12762367618778103, 0.09548554837023693, 0.12435090641852509, 0.09684659791266736, 0.9291374623740499, 0.9420379102810533, 0.9346242207208206, 0.9334151312929024, 0.9340854151564655, 0.9230603444243793, 0.9448182575725415, 0.9146940114205823, 0.9306790158380932, 0.7526555550323555, 0.7631665171142297, 0.7547708345855576, 0.7363432442113611, 0.7413775062503807, 0.7665887860302558, 0.7616420309648834, 0.7661410382376711, 0.7217272654061155, 0.3911459855837567, 0.22821990528744096, 0.7577387348124114, 0.28230751101845886, 0.21371420458033052, 0.1930674593624362, 0.24001520814105193, 0.7935505673857282, 0.23606110539389358, 0.2993053285300801, 0.13254078404414538, 0.2647196463965311, 0.29680931424179724, 0.13511322002163417, 0.2825721885824426, 0.30380994482108936, 0.2913053405624677, 0.29517218991527616, 0.2631574941407274, 0.3000702814290115, 0.1338423067372101, 0.13172425700334023, 0.30032193731820767, 0.3234553929410994, 0.3179045745106126, 0.3140491358248194, 0.3040847309841641, 0.027352376549355406, 0.04603195368017443, 0.04522850212746221, 0.11247953200074567, 0.05580598782570656, 0.0691836974129455, 0.09112782026780242, 0.08262810551760036, 0.17793144720535803, 0.2624401870526608, 0.08349124238562455, 0.11476643327862335, 0.06990445866447503, 0.029643980726569485, 0.04544910327584839, 0.1980955969342041, 0.12715033071426918, 0.14414378001047534, 0.19794717065452327, 0.19229128394321382, 0.32976196189421725, 0.10106328773158368, 0.09897321111585478, 0.4185188337252356, 0.20286750555711708, 0.20310837789909741, 0.1025423172817651, 0.2212846077480206, 0.10603751708964049, 0.11955218815644197, 0.10811598083577922, 0.3407318460105352, 0.4017207702729384, 0.21305372314700022, 0.08223258497925723, 0.09621807287578665, 0.5520862971490204, 0.6513124979257445, 0.5486678170787411, 0.5969388041259001, 0.5859436650179043, 0.5603763292602355, 0.5818543693195196, 0.5913344297494897, 0.58935707601853, 0.12211542094808814, 0.06464117269613001, 0.1280934039419217, 0.15729252109548175, 0.07369894323172865, 0.1248759057608666, 0.1138364502032766, 0.13085932048904148, 0.09600262240564594, 0.2256979212127609, 0.2107101542981834, 0.2248230850103582, 0.20120232271465321, 0.3860950653313062, 0.5284403045427584, 0.28672853157702927, 0.7287057603667444, 0.1508531441357629, 0.17710880479177882, 0.45127329901718716, 0.4087142452136644, 0.5448154465032925, 0.3624693810495313, 0.43598135440645114, 0.5744490697375771, 0.44947179394770376, 0.266062059257396, 0.24981138881356235, 0.2644503272015083, 0.18951833950767882, 0.2852898773032996, 0.28262175532603284, 0.3398851453833308, 0.2530765087211504, 0.31074825771744263, 0.1882851367927485, 0.24986324018094253, 0.19682590201237127, 0.31411710113947733, 0.24639166562551706, 0.2885574712838611, 0.22340246830446442, 0.27982509123248045, 0.28421216070690447, 0.2539568406568057, 0.20990041418381, 0.8172201590243029, 0.20861435482150703, 0.18360024933000318, 0.18912694765976035, 0.18415637985768651, 0.17627981329209508, 0.2502844865252467, 0.18063015985561814, 0.1260828161297688, 0.17867260780285776, 0.15339416895735358, 0.9301778560660838, 0.20025319007962816, 0.9141391760986234, 0.9155113510317153, 0.9139194925442702, 0.9102684535610408, 0.8390825952265588, 0.8286928550531516, 0.8144771367839185, 0.8711033024247198, 0.15451844412255744, 0.8783232658336293, 0.8591792005154433, 0.10450155320849575, 0.8390344043532125, 0.2168080583803388, 0.3537829096571028, 0.3159581858826259, 0.28216340226641556, 0.21112020155437117, 0.2224304383151583, 0.2649767705536167, 0.3120964605944292, 0.2599224198743115, 0.0899535648858859, 0.08359938384898391, 0.08592205880396209, 0.11278823280102257, 0.1009513114484143, 0.09347159134404792, 0.11208343824990552, 0.10681629571936979, 0.10077867280911812]}, "mutation_prompt": null}
{"id": "eec7511a-32d1-404a-8d4b-3f21320fc40c", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 36  # Slightly increased population size for better exploration\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.1\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Slightly increase the population size for enhanced exploration.", "configspace": "", "generation": 86, "fitness": 0.3488618243652284, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8850878857225334, 0.8764554652541268, 0.8769292472918412, 0.866193829114925, 0.8537688818780851, 0.8681456427765725, 0.8799448066069413, 0.8622958842777254, 0.8695070248283551, 0.7528543749022726, 0.7090080126189651, 0.7218367102803456, 0.7260428819487985, 0.7205422574707439, 0.7021620107334836, 0.7333358978296345, 0.7307676212482312, 0.6950513521841174, 0.14474220009276284, 0.156614989998334, 0.10760751081969688, 0.11559679754103558, 0.14242008465470446, 0.11168842159346604, 0.09299997225152168, 0.7756732735448, 0.15474450935358885, 0.10815962708831661, 0.10507812204037292, 0.069321120275049, 0.17888028613423612, 0.11034527633955149, 0.1276755380658987, 0.11514897363423027, 0.09569203798991854, 0.08757512911912013, 0.9347206299750288, 0.9300864027406371, 0.9342569008263909, 0.9419851739267886, 0.9196094029102998, 0.9204611222658501, 0.9420346509528476, 0.9155218553213565, 0.9343332838840732, 0.7486145368420023, 0.7607687629751798, 0.7381853478848195, 0.7649770351216199, 0.7518224456635325, 0.7649176181763963, 0.7553478813448198, 0.7284342569028628, 0.7676412786245015, 0.39417832778746453, 0.8712696947773959, 0.17081338764531107, 0.2769618764058822, 0.8720140925087373, 0.27310339962729135, 0.22877298831915394, 0.23511238461037398, 0.23419194556014, 0.2783896077471273, 0.33621980994024503, 0.13134269389354158, 0.4117448334477586, 0.13361578915251615, 0.28108059950172914, 0.27498163415938826, 0.26944161844280023, 0.28305034872744195, 0.2706779339834394, 0.27608900533345526, 0.13235532041172815, 0.30038763342563635, 0.13411640131153857, 0.2487504920080409, 0.29103791173704296, 0.36147855339560453, 0.12958098681945318, 0.05975717761138333, 0.06980242657618851, 0.08721001519183535, 0.0033852241665890404, 0.0016321283620965854, 0.10335538180114467, 0.025870877199878684, 0.017411590980889402, 0.045647393348041465, 0.12477556290294001, 0.07663534004413908, 0.10521268854317423, 0.08935963008022296, 0.07407007558057233, 0.09097306839221853, 0.09554472065876429, 0.14603399572375075, 0.09122108763682357, 0.22030856357116668, 0.23275065525722105, 0.29412072400462375, 0.1288891324324961, 0.10472957336967481, 0.18398922183704314, 0.31400244864930615, 0.20944411675707642, 0.1800372138560835, 0.14177714749078663, 0.1855599647146139, 0.11641627462210313, 0.08337855157197116, 0.19867181895491692, 0.1316501144955935, 0.08218223068680397, 0.11343700516924071, 0.12014555916965564, 0.6056535390989757, 0.5990741116921909, 0.5702494204711674, 0.5584397380703975, 0.5436778382254156, 0.6007016759079613, 0.5912012699359183, 0.5453995693645817, 0.590510507451539, 0.1286064544140305, 0.09851964094340093, 0.15316378102183048, 0.10944718716203372, 0.11704873410560779, 0.13926640183171735, 0.13004092731760464, 0.14096493206306682, 0.1419400704787278, 0.14133273557064274, 0.6785910734801497, 0.4972131448978132, 0.24429288254535486, 0.4361335872065869, 0.4145081895772058, 0.16260275972771665, 0.15896745344211027, 0.4493380459631452, 0.1914181880344057, 0.45074736720379005, 0.36692973298200626, 0.5124076377190461, 0.4037456613874455, 0.4217481348292159, 0.2651751656045027, 0.5002419558299014, 0.6613036555589262, 0.22377213475567748, 0.4223761346580853, 0.3331619257072336, 0.41323040192827065, 0.2235443063916993, 0.311056832969268, 0.24386335428765082, 0.2716308163662374, 0.23366186445905623, 0.21808696901899738, 0.25239897792064836, 0.18101858373831747, 0.2618863407942851, 0.20813706948666189, 0.19600813709738296, 0.32117102814195864, 0.2947854668549289, 0.2285977091724406, 0.19935590172804185, 0.2519474677428132, 0.19960516569696352, 0.2225166620104968, 0.18877378839196512, 0.22328782490235266, 0.1904285178345546, 0.22450320939091928, 0.18378095577444797, 0.1880299539875585, 0.17817655135307608, 0.15308870901136162, 0.9397441136178103, 0.20071675180489057, 0.11485679685760875, 0.12314260168659708, 0.16902429976566868, 0.16845726610100287, 0.8733514887679008, 0.15739687963417548, 0.8916811820757427, 0.21034987214157985, 0.16816331078786917, 0.1546956812877719, 0.8626930658979186, 0.8761558078922164, 0.8675485194341644, 0.22348410673145735, 0.2192400099921178, 0.21722701137370903, 0.24758094674063724, 0.24556272260970124, 0.2740758100739027, 0.30334161222392253, 0.274116054328292, 0.29563737298988113, 0.1129176447589918, 0.11214497096453413, 0.10970386990063141, 0.11594939640502466, 0.1006103636920912, 0.12180392814783447, 0.09523632038244201, 0.10221752609825985, 0.10908060909893325]}, "mutation_prompt": null}
{"id": "8500a276-5284-4629-8735-97638cfaf69f", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjust the inertia weight and mutation probability to enhance exploration.", "configspace": "", "generation": 87, "fitness": 0.37976992774497764, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "c967f5f0-d74f-4657-92bc-e8c0bfab129e", "metadata": {"aucs": [0.8926962220325649, 0.8621187210683376, 0.8903309415335436, 0.8392401792325419, 0.8604009917863479, 0.8592237888605186, 0.8607889437863898, 0.8720789094800057, 0.8732789851184516, 0.7339315555420818, 0.7418796831128537, 0.7308382947348214, 0.738166371711064, 0.7045068417972404, 0.7121985183976134, 0.6816707952930634, 0.703260108981087, 0.7399154761266435, 0.08885546003355305, 0.6857178228031242, 0.07329609211274313, 0.10119467385299008, 0.11560144941802042, 0.14254359016509532, 0.09501957160219021, 0.09362246740433111, 0.08908755031834192, 0.12477840008738983, 0.14246824458802043, 0.13076917692397005, 0.15409200626864317, 0.09972219565605867, 0.10795082477805484, 0.09227635581285809, 0.08577606809291771, 0.10771448484730539, 0.9340993132582481, 0.9337364531332549, 0.9315816924588046, 0.9297490019021782, 0.9306047238334422, 0.9352094859275482, 0.9400449194967558, 0.9150482139283173, 0.9353561772238579, 0.7225853013022823, 0.7394168198663701, 0.7425073827260638, 0.759540262876792, 0.7897015941330201, 0.7677332956517278, 0.756892036300021, 0.7376885043769473, 0.749942218654316, 0.8048455892413132, 0.8595593746458088, 0.22738464895954846, 0.8897441054307236, 0.21206823377965622, 0.2129392839174271, 0.17759089581498044, 0.21973382448448575, 0.8516099814478726, 0.2686088320480138, 0.13119629383756148, 0.1305827097882688, 0.2884142164691178, 0.3182424803258842, 0.28539880057083544, 0.2886387489919191, 0.30123667470647475, 0.27983717838316147, 0.26088709555512846, 0.2774354646405903, 0.25083313868949186, 0.26430969600666965, 0.30000760975228946, 0.2705175777912956, 0.30314802287144016, 0.30649218228713837, 0.3055018619325027, 0.024204548192399256, 0.11247877578570298, 0.03649781905528271, 0.11059541857578681, 0.010119429111052125, 0.00173251362897886, 0.05018106692160096, 0.06450448661716524, 0.08754790379084465, 0.2531884285391969, 0.12220727501965489, 0.1674166763741789, 0.08243963787661013, 0.0549870648026719, 0.05895354135338171, 0.19658836297366578, 0.07294111532868863, 0.10909538636573235, 0.12919818120925008, 0.1826524720367091, 0.25923583337685663, 0.1253219963904676, 0.11318735150688097, 0.18133912611983782, 0.1649650657402303, 0.1867045881251278, 0.12787345924261517, 0.2441763029759184, 0.12592495842535323, 0.08519250069183903, 0.12883621461699513, 0.17748038772479335, 0.18951230338960012, 0.12156794262851578, 0.15596598589109412, 0.12772325351488345, 0.5396563828651422, 0.6015901181576493, 0.5639199770952609, 0.5773643959788917, 0.6658046268827397, 0.5662159879560948, 0.5605069540384153, 0.6102148677191074, 0.6257121487732887, 0.1362039452198962, 0.0636186666764561, 0.09674208794819661, 0.10929505886275159, 0.11002265400901778, 0.13738613848197223, 0.08756793697958964, 0.10774294966458564, 0.15436685249402748, 0.7366599112702614, 0.22439645305955247, 0.21467774243123772, 0.40291582730917075, 0.5643252633842335, 0.3733310289866155, 0.5971890471406929, 0.7275242028175202, 0.6692315180369967, 0.35235351328705466, 0.42368187141635594, 0.4080406492150972, 0.42345177421214375, 0.507056761152328, 0.5720569642589368, 0.37460969250310805, 0.5190952742460876, 0.2781376726936189, 0.40448049971491895, 0.3254296243624213, 0.2136538814308685, 0.28101206254269573, 0.22456851500919928, 0.39597073185707055, 0.2726547744812753, 0.2916060077400243, 0.21657475366322299, 0.2918935834182693, 0.2364317511052353, 0.2148028144079378, 0.29388172832341974, 0.23930435921918547, 0.23197586748831367, 0.2720067275343572, 0.3094051689203138, 0.258447916842356, 0.18682279802609014, 0.2053071853003272, 0.2069951964140363, 0.224828761071045, 0.21093470056672403, 0.21001587033481406, 0.18102487570312975, 0.19903891713500765, 0.22241157379364063, 0.18727909835191103, 0.178210767970159, 0.18791916003464282, 0.9236496023486809, 0.200175241709603, 0.9290661516031341, 0.9303645563252086, 0.9100716569236599, 0.9235848523191406, 0.8684409834002598, 0.7972257906012286, 0.890911169438927, 0.8520824739009595, 0.16756104976932507, 0.9104727542035254, 0.8481354573960884, 0.10449689767073, 0.8252831101614553, 0.23828278333067865, 0.2550470197103284, 0.39891544616718433, 0.20845644248206108, 0.23912578260791018, 0.2396808667346848, 0.2462833334950001, 0.24652721431103208, 0.21232289876683463, 0.10437341346010309, 0.09065032199970269, 0.13619446692741388, 0.09918352694395638, 0.11102930856518001, 0.09311733848285986, 0.0897419442508115, 0.0834162828065762, 0.09112660741432133]}, "mutation_prompt": null}
{"id": "8a83f24d-d5a6-4638-ae2b-d7e09923e2eb", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 5  # Increased local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Increase local topology size for improved information sharing among particles.", "configspace": "", "generation": 88, "fitness": 0.3685732165874433, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.30.", "error": "", "parent_id": "8500a276-5284-4629-8735-97638cfaf69f", "metadata": {"aucs": [0.8790213068712841, 0.878023998986264, 0.8838657501519518, 0.8496981142089473, 0.870714534662296, 0.8695826173241838, 0.8351676044916659, 0.8460966718100871, 0.849494348604236, 0.7135454413494502, 0.7368201719712314, 0.7183085978147231, 0.7451288158943995, 0.7422017854204054, 0.7166588123210673, 0.6933754311561351, 0.7018424535609156, 0.6722210979525174, 0.09114042222186602, 0.08837075788907445, 0.15322252607675868, 0.1259920828100809, 0.09598118088454777, 0.7284377276664262, 0.09538843758234838, 0.1107749494201471, 0.12296324674307979, 0.11457855117840443, 0.049760131839512, 0.09073745333403005, 0.14295683630320932, 0.08533841904924555, 0.1141807813938931, 0.14082667719913367, 0.0956100694462717, 0.09934304328445598, 0.9347023444984012, 0.9254342865434666, 0.939428618584787, 0.9357089113442258, 0.9334120090063193, 0.9298817536057065, 0.9427495277010437, 0.9112217988117481, 0.9372177341959825, 0.7447941823035749, 0.8146266055989514, 0.7455854744470093, 0.7892194202147224, 0.7560207285570809, 0.7790552067533669, 0.7734645267954948, 0.7184816692884255, 0.7368874119331494, 0.8855172252727392, 0.4400713456966636, 0.22788992188152735, 0.9176206922101001, 0.8837018205305439, 0.27564318711650393, 0.1768839251400539, 0.15188959442079908, 0.8787298667923527, 0.2616663184603353, 0.13298473649596199, 0.27880804284765215, 0.33001188088508193, 0.28064097322035253, 0.285553868111728, 0.3251092215517132, 0.29494909570905314, 0.3150546493981563, 0.2834053749682711, 0.296899547259753, 0.12287354412252594, 0.1345595098710246, 0.2707741333780468, 0.31217061862999684, 0.3290649491371678, 0.2925171779303426, 0.3027410366875961, 0.06555061310706589, 0.13272087131824883, 0.016566083636689655, 0.012512166070638653, 0.051783899383103904, 0.043441406429098106, 0.026035789376352425, 0.026112016679341488, 0.28667375328938227, 0.20545110430053504, 0.07713570945713633, 0.1035269853319909, 0.08696278784414657, 0.024967760323233223, 0.04605016624206493, 0.18766805914471962, 0.09910572307728038, 0.13833538371963183, 0.43460140875949893, 0.0785190043239753, 0.2408422660109074, 0.12271993756440902, 0.08551708337043495, 0.16258810413866553, 0.2092205173446713, 0.1809787937648708, 0.07673927525204727, 0.19905862019183795, 0.10606615253416074, 0.11250243397447068, 0.32043149483351896, 0.21396296171794893, 0.1372942787730983, 0.17144989715870396, 0.11168293930766249, 0.11345656626119216, 0.5736523927880468, 0.6215357798716443, 0.5771199238709624, 0.5615298263486889, 0.5705948244533158, 0.5753337221824215, 0.6060383192722303, 0.6285561957944246, 0.6272867071630254, 0.09615551935813271, 0.06895764342185706, 0.12834330551972395, 0.14209359590660464, 0.06123260354980398, 0.07021110544274212, 0.07004915957079316, 0.12165739274486365, 0.1123678909689575, 0.1964851517462063, 0.35472499567306126, 0.23035018465885693, 0.18053142552449886, 0.42516014658288626, 0.37504121581333316, 0.27887304045820926, 0.19230890499882503, 0.2553688511711726, 0.4137079215153794, 0.22986313997179508, 0.5147196320467173, 0.5562083074261763, 0.5891585173883955, 0.6610770176519548, 0.2444969723209499, 0.6321920294112818, 0.20097090312681698, 0.2289859262460856, 0.34404969211587544, 0.23315075470639524, 0.3018104934542427, 0.2111901470223021, 0.33741954148458986, 0.22375753403660925, 0.22109530414240308, 0.22515976716339436, 0.1814400678945458, 0.21878279642756548, 0.24170212353854714, 0.21456774957775915, 0.2268201052537997, 0.24083314174170523, 0.20225433718696828, 0.2092377932284063, 0.3052601241980346, 0.20715947201415674, 0.25126532513782474, 0.20919796788322198, 0.22520856543838708, 0.2291450350057851, 0.22422965308457232, 0.18347330455448807, 0.2483027889906635, 0.1873045447873889, 0.18724617534424004, 0.18747395255229427, 0.18732299006185893, 0.9109612476326822, 0.20048013243350316, 0.9159541999886671, 0.9007426083807433, 0.9197005282541525, 0.9196739616119833, 0.9084046783803051, 0.7953494679406152, 0.12717174755595695, 0.20951876034387362, 0.09473956061212152, 0.89736192624369, 0.854547940749418, 0.8380785354414501, 0.8451292815453917, 0.4164515147054393, 0.2294187298144641, 0.18344170303591967, 0.25899620197032536, 0.36603074872251895, 0.26784727742355485, 0.24400018622299302, 0.24664664149068716, 0.2445245304662229, 0.08561328024706161, 0.11516287627920341, 0.05970767316763992, 0.10810400286688404, 0.10966951702416172, 0.07829604927711575, 0.08558124497141961, 0.058793350437059244, 0.08568590686517308]}, "mutation_prompt": null}
{"id": "18a7c482-9f4c-4db7-a4e3-9bede4b0f781", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.5 + (0.3 * np.random.rand())  # Adjusted inertia weight update formula\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.95 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjust the inertia weight update formula to improve balance between exploration and exploitation.", "configspace": "", "generation": 89, "fitness": 0.37787358606124627, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "8500a276-5284-4629-8735-97638cfaf69f", "metadata": {"aucs": [0.8730994287414099, 0.860761880374648, 0.8842766837952224, 0.8541289065483575, 0.8707709239609216, 0.8812320092785019, 0.8731319832309797, 0.8684193920950088, 0.8688590579587929, 0.7146583967460314, 0.7265531611587102, 0.7396636437621775, 0.6993498228397907, 0.7279739817824782, 0.6638163039854368, 0.6974670884805159, 0.7025595465752679, 0.7190350023804888, 0.11434484517654897, 0.15673706015193023, 0.14211955798918896, 0.14202758071843913, 0.09008948447168419, 0.14497414899276206, 0.09499563878327077, 0.131246140445888, 0.14144956654237306, 0.10957981134062378, 0.11887849626773828, 0.10813065535339061, 0.10441278733296311, 0.11551395694574695, 0.10575737371381932, 0.09432732636825081, 0.11513882664758945, 0.10978461720560173, 0.9351410679192453, 0.9391200475489949, 0.9321671589455314, 0.9275415120409829, 0.932292127363348, 0.9332400552174765, 0.9399760631788387, 0.9155731292503468, 0.9363212207906814, 0.7670451596835178, 0.745777806046929, 0.7384066746721751, 0.7697119191435212, 0.713681927912777, 0.7507662425560212, 0.769186032767412, 0.7734601341047314, 0.7098051825331643, 0.9024023052007056, 0.22576521228697266, 0.2184257381202892, 0.8948868123523664, 0.8504004329041077, 0.2128554903731531, 0.7595857448667014, 0.3808883487172888, 0.2346588048610272, 0.47725153361209827, 0.13160339129011223, 0.3073690796487818, 0.2723326763073649, 0.3648409767876919, 0.2773832363603439, 0.32530762647502254, 0.30371321414789665, 0.29327935976353603, 0.27161605708716574, 0.29266766405447286, 0.2559685778641788, 0.1341195357471986, 0.29089488225574445, 0.1350773378882575, 0.3179286878168063, 0.2773616873047017, 0.3096510618243661, 0.03950800271533805, 0.12340579369523508, 0.21964775482140353, 0.05195142436258049, 0.05649500651066919, 0.06085419798733693, 0.03770580738821605, 0.011303428076329003, 0.14310430707337296, 0.10628242897356754, 0.06121374475953778, 0.11697720770185915, 0.06410366366840536, 0.03934894460016092, 0.041655839727376964, 0.20136694341109074, 0.11843830689643986, 0.0986653310015243, 0.16250403658967283, 0.09570190641444043, 0.29612377579102533, 0.1245599172877061, 0.07705997851873236, 0.2885391865337724, 0.19153740385286233, 0.28556911415203556, 0.11194555416204022, 0.1355677651179773, 0.18559204076604696, 0.11159022021953091, 0.1057650854812282, 0.2110013087224224, 0.16285027995255263, 0.082708337028648, 0.2196605810558322, 0.10123198074161754, 0.5768515234506486, 0.5919868121705536, 0.5790520477539418, 0.6111034244632452, 0.5612766230758184, 0.60283609995529, 0.6213107989602654, 0.6225186271782652, 0.5844981582974997, 0.07708504166686658, 0.07124511973987868, 0.1171122384976645, 0.14008046580333122, 0.0791219988248284, 0.10810840433257896, 0.14055987350278176, 0.1567239527025155, 0.11082237159750818, 0.2725536838578617, 0.6713033528590444, 0.3040014426184352, 0.3659228928523759, 0.473425649224007, 0.22385046961102006, 0.712910827454581, 0.27909130692294615, 0.4020870307816903, 0.36650942248885476, 0.5980377132247648, 0.5730596099380418, 0.3776550754658753, 0.5765715445678317, 0.4638388168306379, 0.5308335538316975, 0.4095728987188151, 0.27128132594672405, 0.4508597195044114, 0.3763014682754422, 0.2041119977391761, 0.2949951192691108, 0.2477745046741604, 0.3923326292368311, 0.24866046204268621, 0.27474768103161173, 0.20764968833010722, 0.216925788333463, 0.21223959088429867, 0.24113268174472113, 0.2669150388746704, 0.21087579818653102, 0.21355350773312864, 0.20060880531967273, 0.24832767318461613, 0.193703549371272, 0.2069185496291155, 0.2108610542606043, 0.2085496387015231, 0.18181172839845627, 0.2242149918824301, 0.18814350084422427, 0.24915975209316243, 0.1886720018005693, 0.18737604312584555, 0.18732773382830226, 0.17812800586415456, 0.1879129033247975, 0.9223760196220993, 0.2003614337431815, 0.9221841546407513, 0.9111520920048573, 0.9177185838938713, 0.9377827708187841, 0.9132830801385559, 0.8784141551955278, 0.8528081583113237, 0.855637297736942, 0.15439004299237236, 0.8939440806628933, 0.8087624642594146, 0.10447382268011352, 0.8658441285753187, 0.33924084710092506, 0.2511221013017485, 0.3608253146220546, 0.2513236759597648, 0.20420683717175914, 0.25592936547835965, 0.33206730891070624, 0.23606440602767575, 0.2508437327471601, 0.10563936627229609, 0.11148568101816314, 0.06771243700416685, 0.110470010243083, 0.128619848944323, 0.08393218098220545, 0.0957709940208531, 0.10083160105115929, 0.11563415694381896]}, "mutation_prompt": null}
{"id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhance exploration by slightly increasing mutation probability decay rate.", "configspace": "", "generation": 90, "fitness": 0.3800919444291652, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "8500a276-5284-4629-8735-97638cfaf69f", "metadata": {"aucs": [0.8926962220325649, 0.8621187210683376, 0.8903309415335436, 0.8392401792325419, 0.8604009917863479, 0.8592237888605186, 0.8607889437863898, 0.8772432835590783, 0.8732789851184516, 0.7339315555420818, 0.6969114070161679, 0.7258677519316896, 0.738166371711064, 0.7215725655943594, 0.7121985183976134, 0.6816707952930634, 0.703260108981087, 0.7112328990894562, 0.09181455329755828, 0.6857178228031242, 0.07329609211274313, 0.10119467385299008, 0.11560144941802042, 0.14254359016509532, 0.08053119509717965, 0.09362246740433111, 0.08908755031834192, 0.12477840008738983, 0.09533797024155777, 0.13076917692397005, 0.15409200626864317, 0.10791957432757171, 0.10795082477805484, 0.09227635581285809, 0.08577606809291771, 0.10771448484730539, 0.9340993132582481, 0.9337364531332549, 0.9288469173005733, 0.9297490019021782, 0.9306047238334422, 0.9352094859275482, 0.9400449194967558, 0.9150482139283173, 0.9353561772238579, 0.7225853013022823, 0.749895814968792, 0.720853161735161, 0.759540262876792, 0.7473884272486822, 0.7677332956517278, 0.756892036300021, 0.7376885043769473, 0.7319303907632555, 0.8048455892413132, 0.8595593746458088, 0.22738464895954846, 0.8897441054307236, 0.21210367721467582, 0.37175125906585516, 0.17759089581498044, 0.2307149920489373, 0.8346436066055808, 0.2686088320480138, 0.13119629383756148, 0.1305827097882688, 0.2884142164691178, 0.3182424803258842, 0.26508346413374484, 0.2886387489919191, 0.30123667470647475, 0.3052091151876528, 0.26088709555512846, 0.28343559670321405, 0.2667590726598619, 0.26430969600666965, 0.30000760975228946, 0.2705175777912956, 0.30314802287144016, 0.30649218228713837, 0.3055018619325027, 0.024204548192399256, 0.1399886006171286, 0.11975692220948364, 0.11059541857578681, 0.014519530237322553, 0.00173251362897886, 0.05018106692160096, 0.07295229504336365, 0.09848123499973171, 0.2531884285391969, 0.15905354837947538, 0.1398248720019546, 0.08243963787661013, 0.05885057350105671, 0.0680744980465624, 0.19658836297366578, 0.07294111532868863, 0.10909538636573235, 0.12919818120925008, 0.1826524720367091, 0.22745216140887636, 0.1253219963904676, 0.11318735150688097, 0.1907230090730041, 0.1649650657402303, 0.1867045881251278, 0.12787345924261517, 0.2441763029759184, 0.12592495842535323, 0.08519250069183903, 0.12883621461699513, 0.17748038772479335, 0.18951230338960012, 0.12156794262851578, 0.15596598589109412, 0.12772325351488345, 0.5396563828651422, 0.6059530503651873, 0.5881577289224004, 0.5773643959788917, 0.6658046268827397, 0.5662159879560948, 0.5605069540384153, 0.6102148677191074, 0.6257121487732887, 0.11384812565831814, 0.08541491706134896, 0.09313746174053117, 0.13774864191345426, 0.11002265400901778, 0.13738613848197223, 0.10231052233954019, 0.12787790222383177, 0.15436685249402748, 0.5797235419846941, 0.22439645305955247, 0.21467774243123772, 0.40291582730917075, 0.5643252633842335, 0.3733310289866155, 0.5971890471406929, 0.7275242028175202, 0.6692315180369967, 0.35235351328705466, 0.5076333092038046, 0.4080406492150972, 0.42345177421214375, 0.507056761152328, 0.5720569642589368, 0.2910309390228353, 0.5190952742460876, 0.2781376726936189, 0.40448049971491895, 0.3254296243624213, 0.2136538814308685, 0.28101206254269573, 0.22545691267109225, 0.39597073185707055, 0.2726547744812753, 0.2916060077400243, 0.21657475366322299, 0.31310159934444903, 0.2364317511052353, 0.2148028144079378, 0.29388172832341974, 0.23930435921918547, 0.23197586748831367, 0.2257981914418422, 0.3408268053931838, 0.258447916842356, 0.18682279802609014, 0.21609107670512318, 0.20837641159434483, 0.224828761071045, 0.2114851887545799, 0.21001587033481406, 0.18102487570312975, 0.19903891713500765, 0.2012008801061601, 0.18727909835191103, 0.178210767970159, 0.18791916003464282, 0.9236496023486809, 0.200175241709603, 0.9290661516031341, 0.9303645563252086, 0.9100716569236599, 0.9287640460182045, 0.8684409834002598, 0.7972257906012286, 0.890911169438927, 0.8520824739009595, 0.16756104976932507, 0.9104727542035254, 0.8481354573960884, 0.10449689767073, 0.8539375085873903, 0.23828278333067865, 0.2550470197103284, 0.39891544616718433, 0.20845644248206108, 0.23912578260791018, 0.2396808667346848, 0.2196780713729155, 0.24652721431103208, 0.21232289876683463, 0.10286645586399523, 0.09065032199970269, 0.13619446692741388, 0.0998536996074808, 0.11102930856518001, 0.09311733848285986, 0.0897419442508115, 0.0834162828065762, 0.09112660741432133]}, "mutation_prompt": null}
{"id": "0ba89780-ddae-47eb-802b-c7da6b3827ed", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.98 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjusted mutation probability decay rate for improved balance between exploration and exploitation.", "configspace": "", "generation": 91, "fitness": 0.3776340258531074, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "metadata": {"aucs": [0.8926962220325649, 0.8621187210683376, 0.8903309415335436, 0.8392401792325419, 0.8604009917863479, 0.8592237888605186, 0.8499178186517591, 0.8772432835590783, 0.8732789851184516, 0.7339315555420818, 0.6969114070161679, 0.6735783674516562, 0.738166371711064, 0.7002442661023514, 0.7121985183976134, 0.6816707952930634, 0.703260108981087, 0.6983467697555514, 0.09181455329755828, 0.6857178228031242, 0.07329609211274313, 0.10905463118876502, 0.11560144941802042, 0.14254359016509532, 0.08053119509717965, 0.09362246740433111, 0.08908755031834192, 0.12477840008738983, 0.09533797024155777, 0.13076917692397005, 0.15516551897178033, 0.11145844470377797, 0.10795082477805484, 0.0996509819247452, 0.08577606809291771, 0.10771448484730539, 0.9340993132582481, 0.9337364531332549, 0.9288469173005733, 0.9297490019021782, 0.9306047238334422, 0.9352094859275482, 0.9400449194967558, 0.9150482139283173, 0.9353561772238579, 0.7225853013022823, 0.7580521436507222, 0.6940654237480638, 0.759540262876792, 0.7473884272486822, 0.7677332956517278, 0.756892036300021, 0.7376885043769473, 0.7319303907632555, 0.8048455892413132, 0.8595593746458088, 0.22738464895954846, 0.8897441054307236, 0.8808148864733721, 0.37175125906585516, 0.17759089581498044, 0.23275734350280375, 0.23376061689766003, 0.2686088320480138, 0.13119629383756148, 0.1305827097882688, 0.2884142164691178, 0.3182424803258842, 0.27235801662916237, 0.2886387489919191, 0.30123667470647475, 0.3149792389287078, 0.26088709555512846, 0.2667505387501389, 0.2614616083488225, 0.26430969600666965, 0.30000760975228946, 0.2705175777912956, 0.30314802287144016, 0.30649218228713837, 0.3055018619325027, 0.024204548192399256, 0.1399886006171286, 0.11975692220948364, 0.11059541857578681, 0.014519530237322553, 0.0027099643445208654, 0.05018106692160096, 0.05669711960803747, 0.09888214511791515, 0.2531884285391969, 0.15905354837947538, 0.1398248720019546, 0.08243963787661013, 0.05254706961784372, 0.0680744980465624, 0.19658836297366578, 0.07294111532868863, 0.10909538636573235, 0.12919818120925008, 0.19441817414850215, 0.22745216140887636, 0.1253219963904676, 0.11318735150688097, 0.1907230090730041, 0.1649650657402303, 0.1867045881251278, 0.12787345924261517, 0.2441763029759184, 0.12592495842535323, 0.08519250069183903, 0.12883621461699513, 0.17748038772479335, 0.18951230338960012, 0.12156794262851578, 0.15596598589109412, 0.14026425414166865, 0.5396563828651422, 0.6059530503651873, 0.6130310515239615, 0.5773643959788917, 0.6658046268827397, 0.5682841075671676, 0.5605069540384153, 0.6102148677191074, 0.6257121487732887, 0.11384812565831814, 0.09036100699696437, 0.09313746174053117, 0.13774864191345426, 0.11015823408717473, 0.13738613848197223, 0.10231052233954019, 0.12787790222383177, 0.15436685249402748, 0.5797235419846941, 0.21556499086037784, 0.19295143258358616, 0.27226765446928747, 0.5643252633842335, 0.3733310289866155, 0.5971890471406929, 0.7275242028175202, 0.6692315180369967, 0.3533704996974031, 0.47672320526234924, 0.4080406492150972, 0.42345177421214375, 0.5071683125178268, 0.4794285621054729, 0.2910309390228353, 0.5190952742460876, 0.2781376726936189, 0.2975449388444935, 0.3254296243624213, 0.2136538814308685, 0.2850378608495874, 0.23632736795292064, 0.39597073185707055, 0.2726547744812753, 0.2916060077400243, 0.23272525936520938, 0.31310159934444903, 0.2364317511052353, 0.2148028144079378, 0.293380224994804, 0.23930435921918547, 0.23197586748831367, 0.2257981914418422, 0.21813141802464986, 0.258447916842356, 0.18682279802609014, 0.21609107670512318, 0.2085674328221646, 0.224828761071045, 0.2114851887545799, 0.21001587033481406, 0.18102487570312975, 0.19903891713500765, 0.20126551070108922, 0.18727909835191103, 0.178210767970159, 0.18791995184992993, 0.9236496023486809, 0.200175241709603, 0.9290661516031341, 0.9303645563252086, 0.9100716569236599, 0.9287640460182045, 0.8684409834002598, 0.7972257906012286, 0.8603095573193713, 0.8520824739009595, 0.16756104976932507, 0.9104727542035254, 0.8481354573960884, 0.10449689767073, 0.8527228855272263, 0.23771523204885348, 0.2550470197103284, 0.39891544616718433, 0.1981508217381509, 0.23912578260791018, 0.2396808667346848, 0.2196780713729155, 0.24652721431103208, 0.21232289876683463, 0.10286645586399523, 0.09065032199970269, 0.13619446692741388, 0.0998536996074808, 0.11102930856518001, 0.09311733848285986, 0.08004326063394696, 0.0834162828065762, 0.09112660741432133]}, "mutation_prompt": null}
{"id": "2b058b9a-9c93-4cf8-9a2c-d317ee8d2a8a", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          (self.c2 + 0.1) * r2 * (global_best_position - pop))  # Added 0.1 to improve convergence rate\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjust velocity update to improve convergence rate.", "configspace": "", "generation": 92, "fitness": 0.36888245906909156, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "metadata": {"aucs": [0.8834771592868572, 0.8599145544384468, 0.8644839504477884, 0.8834357064857697, 0.8499815858709585, 0.8449131884271024, 0.832654982748384, 0.8705789484864399, 0.8465891512958545, 0.726091919978622, 0.7214577580443418, 0.7144784758277327, 0.7187523512930952, 0.7214676785785903, 0.6951758173571578, 0.6962362439531092, 0.6909810867963866, 0.7058493129277728, 0.10936333831928735, 0.12281034157932313, 0.1169369169315081, 0.11691526898702609, 0.09583823137516811, 0.1841022841055665, 0.09586031047622656, 0.1607491924590957, 0.10601450694366654, 0.14291017409600193, 0.09898458409261568, 0.07876217622691006, 0.1159450426762274, 0.0843241883484529, 0.15340340653082218, 0.09624884751305107, 0.12459995373261468, 0.08453346206473611, 0.9317401484035739, 0.9420449629320697, 0.9339894834023673, 0.935777487553821, 0.9340018615861005, 0.9225983094027161, 0.9423378460748416, 0.9151507385425937, 0.9306803170813962, 0.7704716229110957, 0.7400759514281474, 0.7274416369875715, 0.7520208533825855, 0.7416358319568325, 0.7789327777920291, 0.7700578878654771, 0.7355879676540169, 0.7327468833725088, 0.8700417503520677, 0.17094574383475958, 0.2284472959872409, 0.2824517322682014, 0.27773909807988495, 0.21245603433876104, 0.14284859223599355, 0.2301658316103179, 0.23610441348812106, 0.28237829347068033, 0.1317030937382273, 0.2701464750881597, 0.28605706942725206, 0.13542085405943693, 0.2753962276590186, 0.29326295273960545, 0.2699447537491204, 0.32652639841362396, 0.25618729816434305, 0.26112483157893807, 0.13349488189732528, 0.13199824157043893, 0.31249105870485117, 0.3098077684488115, 0.32584235136742756, 0.28961750277395437, 0.3033506762248329, 0.03805993686876208, 0.05466073529168858, 0.028440151002199543, 0.034738271903499984, 0.09779331829955995, 0.04552020398072687, 0.07413854025519162, 0.0458889048646397, 0.17140289532106745, 0.14131616437453554, 0.0792999041036393, 0.10801773046169438, 0.05264617411076544, 0.03268464996855214, 0.050448118404921694, 0.24451977695248195, 0.12506989258907286, 0.1241174228536931, 0.33660604212815626, 0.22619135451905337, 0.42265896623894583, 0.09012888861080315, 0.10207844453947068, 0.12609830565133617, 0.18309871438650493, 0.17211545458538136, 0.12669539202973268, 0.2921430898749783, 0.06686088164972481, 0.12205248757230369, 0.12821494057052407, 0.2256520552997726, 0.3324479949027628, 0.10894272197528976, 0.10396932784654112, 0.1294525122323088, 0.6204865062949518, 0.6265444047869748, 0.5333473539665832, 0.5674623819035187, 0.5542373867006221, 0.5927841667652058, 0.5750337813099045, 0.6365273660814965, 0.6100605962332692, 0.09808821523918654, 0.0968703939830935, 0.09745249029985603, 0.13967914955782523, 0.0810397684542924, 0.12425206920346388, 0.07978841797223235, 0.13169131272150503, 0.09661892477030887, 0.22689021491216377, 0.40433281648968444, 0.2187822584777277, 0.2026969596822883, 0.5565013141439702, 0.6557049783083104, 0.7407455421914682, 0.3343178301510986, 0.21885755837294407, 0.3900440746957784, 0.46253877781250585, 0.41423526085189755, 0.41470867297533076, 0.45697614539208975, 0.42293127531723307, 0.5563843195074092, 0.6566841904466262, 0.2666165390776293, 0.40898721544412, 0.31852063428335897, 0.2135078329699457, 0.3450106733256093, 0.2914838547067322, 0.35892346282199394, 0.2572452099858581, 0.35596007432021615, 0.22523584045467226, 0.2886288729183839, 0.27310420958077186, 0.2144888734935857, 0.1982683503614886, 0.20003830061504846, 0.2481308303979779, 0.27668889065048174, 0.2325341696408788, 0.253014889293501, 0.21015165067358144, 0.8069295732112078, 0.1929192365967296, 0.211005689730157, 0.1889007542285558, 0.18435520990747312, 0.16844875579938123, 0.7942328247164412, 0.18088476965107358, 0.12603560117615487, 0.17858305629545834, 0.15345902017579172, 0.9159446401963072, 0.20019906955908218, 0.9270311393789356, 0.9123822181595086, 0.9187683267626999, 0.9210006607944323, 0.791293705847953, 0.8571014795705989, 0.8377793742570883, 0.8580442795574674, 0.15466506623991338, 0.8877388588832262, 0.8363301520702471, 0.1045072912535937, 0.8708686189203576, 0.252473156527391, 0.25006669096822776, 0.23984958441083093, 0.24223657895246065, 0.2498853368775733, 0.24002611390901096, 0.18763546609009196, 0.24970934020988111, 0.2608409090661272, 0.07715186852605327, 0.10190497692378653, 0.10194553348221091, 0.11315934752081191, 0.09441799820650454, 0.07186785424634257, 0.09912429399221911, 0.10395646577392603, 0.08887676478769424]}, "mutation_prompt": null}
{"id": "de08501e-f7e1-4cca-bc24-b037d796e807", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 4  # local topology size, increased for better locality\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Slightly increase the local topology size to enhance local exploration capabilities.", "configspace": "", "generation": 93, "fitness": 0.36722867703193834, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "metadata": {"aucs": [0.860732242083985, 0.8484634925218042, 0.8898387491858422, 0.8735355238773754, 0.8732363519934611, 0.8724304138537176, 0.8786852305295667, 0.8605079187903208, 0.8667989321346613, 0.7241049533254619, 0.7643890180526878, 0.7401700239052614, 0.7461439078150515, 0.7316544648055601, 0.7185818587759587, 0.6990372682558265, 0.7299591722455718, 0.7178406634066987, 0.11450682822146718, 0.14164908257026232, 0.11443473849268193, 0.14040995827498592, 0.11630967260240521, 0.18725458958460572, 0.09610851489245742, 0.14425332177490946, 0.16039022629674216, 0.1213540280114015, 0.09167369742513642, 0.09450275197390534, 0.12354760169323342, 0.12652059793812664, 0.09331760370664777, 0.09231119215747752, 0.09476869066176274, 0.11631908851414796, 0.9388310375479239, 0.934367100312557, 0.9335587575413271, 0.9301061858026732, 0.9322285182590108, 0.9320337957823123, 0.942623752870783, 0.9089186831343876, 0.9397425880287195, 0.7622525001615283, 0.791499851994565, 0.7246537945122686, 0.7508487308017919, 0.7594733270239462, 0.7338928308903616, 0.7628776707082632, 0.7260522440041799, 0.7185785398628535, 0.22912688645493395, 0.38569074455870456, 0.22806119909924893, 0.8625364085928597, 0.8908599293552811, 0.21298476340976324, 0.23686089349457506, 0.2124159585251687, 0.24727346919718507, 0.26029780376934464, 0.12881098950863712, 0.2959841326467012, 0.2723003330551512, 0.2899202414563735, 0.2984013647944216, 0.28196828132856877, 0.33438896088037107, 0.28735416913874956, 0.27489631385071556, 0.2978494499204358, 0.2972701769155469, 0.29512522437641986, 0.333188869598936, 0.3093920777574364, 0.30820450936113253, 0.30404521575994914, 0.30012068279887216, 0.04386258816426236, 0.08876318943037387, 0.03513983729178505, 0.011399656834884864, 0.21162436778927207, 0.057261965631562606, 0.0794126381194552, 0.06427600110624188, 0.12855390745604311, 0.11826216939874246, 0.08669621700325769, 0.13078390731026845, 0.09545991962576938, 0.024992561808791836, 0.0315959579915811, 0.1794362628484769, 0.0926488987184162, 0.09756222292387662, 0.1664714910764642, 0.1118092511222809, 0.19747078573198662, 0.12690970335645613, 0.08353680042436173, 0.1097996414130874, 0.1540018960460411, 0.12350410985418026, 0.1905264933213785, 0.1323540022513312, 0.08429812627449063, 0.1162625127667698, 0.1892171437561616, 0.22459011183183397, 0.17273835677744465, 0.08249816833850487, 0.2624251171100045, 0.11641464839124416, 0.6003261969777511, 0.5673617450936193, 0.630114585034903, 0.5622877551464928, 0.5739313322512056, 0.6267991189908046, 0.5950520991973047, 0.6258416188935096, 0.5751203856826377, 0.08188688647405018, 0.11966938992197285, 0.09337680950521043, 0.09584687673797854, 0.12352473310878664, 0.0654519905300418, 0.18610034170472578, 0.11095942376280565, 0.09182405143133021, 0.47536479515385544, 0.6157928574472051, 0.33222219650295925, 0.16921482647882347, 0.7566854759137912, 0.491538240670616, 0.28391606440537287, 0.2822796168511893, 0.7339045873989799, 0.17828340015464017, 0.37654503091080904, 0.33283150773642933, 0.48691332442851376, 0.4839701577977721, 0.5116469451177122, 0.5465885923243836, 0.3875736277784484, 0.4278561795792629, 0.2256764798045655, 0.3209179211046377, 0.22275102638847066, 0.272631762727375, 0.23331213165232978, 0.36938713672790635, 0.25279421258518986, 0.3390296307371091, 0.22034721450968697, 0.2626596060085661, 0.2181703246663529, 0.21800976890306845, 0.20567279233468694, 0.19816882934122426, 0.2494387020925266, 0.23525892341474242, 0.2474575794346856, 0.24644073284995238, 0.1914221046004717, 0.22774730342318317, 0.20728683951526228, 0.2512896801851451, 0.19789468758675866, 0.22425248519452867, 0.19092655587879248, 0.2229280135400733, 0.17974814527366212, 0.18724689867361366, 0.1875316229338253, 0.18793227674002466, 0.9308549879477486, 0.20012017514562308, 0.9203990940061237, 0.9147273390323337, 0.9209461949674503, 0.9280339604618457, 0.8645554024676725, 0.7985498466638615, 0.8935519207234875, 0.8774944367200764, 0.09472539619758136, 0.8859771510320539, 0.104950057201042, 0.1657941823740453, 0.8349859483293797, 0.21232286868560635, 0.45249213385155773, 0.2538030964954535, 0.24784761106809106, 0.2882566282440223, 0.2552479889185071, 0.2719250450948263, 0.19501441280054, 0.26382277922157227, 0.0757657825528939, 0.072066194779704, 0.07454522851429468, 0.09504483536537844, 0.08895142631541564, 0.07834656614826163, 0.08598016629857941, 0.10008413820013606, 0.09510512865600251]}, "mutation_prompt": null}
{"id": "982fad41-0774-44a0-9d92-56c94e7833a0", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.5 + (0.3 * np.random.rand())  # Adjusted for more balanced exploration-exploitation\n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Adjust the inertia weight dynamics for better balance between exploration and exploitation.", "configspace": "", "generation": 94, "fitness": 0.3734547024220707, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "metadata": {"aucs": [0.8730994287414099, 0.860761880374648, 0.8842766837952224, 0.8541289065483575, 0.8707709239609216, 0.8812320092785019, 0.8731319832309797, 0.8655715725335992, 0.8688590579587929, 0.7146583967460314, 0.7163102030849611, 0.7156784336973767, 0.6993498228397907, 0.7044911778939276, 0.6638163039854368, 0.6974670884805159, 0.7025595465752679, 0.7095056155538249, 0.11434484517654897, 0.15673706015193023, 0.14211955798918896, 0.14202758071843913, 0.09008948447168419, 0.14497414899276206, 0.09499563878327077, 0.131246140445888, 0.14144956654237306, 0.10957981134062378, 0.11439722476878633, 0.10813065535339061, 0.1383529365159779, 0.11551395694574695, 0.10575737371381932, 0.09432732636825081, 0.11513882664758945, 0.10978461720560173, 0.9351410679192453, 0.9391200475489949, 0.9281316927677828, 0.9275415120409829, 0.932292127363348, 0.9313121501096292, 0.9399760631788387, 0.9155731292503468, 0.9363212207906814, 0.7670451596835178, 0.7863559453168081, 0.7141899613180867, 0.7697119191435212, 0.7887514142870135, 0.7507662425560212, 0.769186032767412, 0.7734601341047314, 0.7098051825331643, 0.9024023052007056, 0.22576521228697266, 0.23962386806962022, 0.8948868123523664, 0.27686188470537276, 0.27691270085714137, 0.7595857448667014, 0.17537397253755316, 0.23466642414341765, 0.47725153361209827, 0.13160339129011223, 0.3073690796487818, 0.2723326763073649, 0.3648409767876919, 0.2718645591510672, 0.32530762647502254, 0.35772353425000203, 0.31884055979244585, 0.27161605708716574, 0.3104734443068764, 0.2559685778641788, 0.1341195357471986, 0.29089488225574445, 0.1350773378882575, 0.3179286878168063, 0.2773616873047017, 0.3096510618243661, 0.03950800271533805, 0.0827495295884686, 0.10581076910663001, 0.05195142436258049, 0.05649500651066919, 0.08622645233795101, 0.03770580738821605, 0.011690153596906727, 0.14310430707337296, 0.10628242897356754, 0.07069389029279738, 0.1058458613746539, 0.06410366366840536, 0.02656314796866044, 0.03488225943393808, 0.17883304495474184, 0.11843830689643986, 0.15045578239689072, 0.16250403658967283, 0.09570190641444043, 0.2704628390217132, 0.1245599172877061, 0.07705997851873236, 0.1353977117935794, 0.19153740385286233, 0.28556911415203556, 0.10373024752298865, 0.1355677651179773, 0.18559204076604696, 0.11159022021953091, 0.1057650854812282, 0.2110013087224224, 0.16285027995255263, 0.082708337028648, 0.2196605810558322, 0.10123198074161754, 0.5768515234506486, 0.6249012310935905, 0.6471887360313758, 0.6111034244632452, 0.5612766230758184, 0.60283609995529, 0.6213107989602654, 0.6225186271782652, 0.5844981582974997, 0.09351240433399466, 0.10206908994211517, 0.1171122384976645, 0.13809418966299436, 0.0791219988248284, 0.10810840433257896, 0.12892733194145423, 0.14078993754860347, 0.11082237159750818, 0.2725536838578617, 0.6713033528590444, 0.3040014426184352, 0.3659228928523759, 0.473425649224007, 0.22385046961102006, 0.712910827454581, 0.27909130692294615, 0.4020870307816903, 0.36650942248885476, 0.4946814572068676, 0.5730596099380418, 0.3776550754658753, 0.5765715445678317, 0.4638388168306379, 0.5308335538316975, 0.4095728987188151, 0.27128132594672405, 0.4508597195044114, 0.3249444400885344, 0.2041119977391761, 0.2949951192691108, 0.23891513064638958, 0.3923326292368311, 0.24866046204268621, 0.27474768103161173, 0.20764968833010722, 0.21991877401338078, 0.21223959088429867, 0.24113268174472113, 0.2641827072696833, 0.21087579818653102, 0.21355350773312864, 0.20060880531967273, 0.24832767318461613, 0.193703549371272, 0.2069185496291155, 0.21149130010393646, 0.2085496387015231, 0.18181172839845627, 0.22480334745230046, 0.18814350084422427, 0.24915975209316243, 0.1886720018005693, 0.18737604312584555, 0.18732773382830226, 0.17812800586415456, 0.1879129033247975, 0.9223760196220993, 0.2003614337431815, 0.9221841546407513, 0.9111520920048573, 0.9177185838938713, 0.9283858485867866, 0.9132830801385559, 0.8784141551955278, 0.8528081583113237, 0.855637297736942, 0.15439004299237236, 0.8939440806628933, 0.8375898326295993, 0.10447382268011352, 0.8658441285753187, 0.33924084710092506, 0.2511221013017485, 0.3608253146220546, 0.20226607258342033, 0.20420683717175914, 0.25592936547835965, 0.33206730891070624, 0.23606440602767575, 0.2508437327471601, 0.08893056707277414, 0.11148568101816314, 0.06771243700416685, 0.110470010243083, 0.128619848944323, 0.08393218098220545, 0.0957709940208531, 0.10083160105115929, 0.11563415694381896]}, "mutation_prompt": null}
{"id": "eab2edbf-cd34-4e24-8a35-fe55af1673c9", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 1.9 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Fine-tune cognitive parameter c1 for better exploration-exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.3640405966204688, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "metadata": {"aucs": [0.8972962853938513, 0.8854539266752802, 0.8799207000718667, 0.87882234909979, 0.8571672687229266, 0.8894286025533793, 0.8938202121968157, 0.8681515085578194, 0.8869511001573658, 0.7418483177602189, 0.7301398611511469, 0.6805223393659989, 0.6960731909591458, 0.045984292258868686, 0.7343271809807717, 0.6800852540577214, 0.6727931567320324, 0.6999192481089153, 0.09367911948132313, 0.1409128956446759, 0.17929566815010167, 0.13849289243274765, 0.123053597668769, 0.14207956911939457, 0.08030874828417545, 0.15709204652661923, 0.09259643877788981, 0.10049408570656126, 0.11609344748396255, 0.1297581144663461, 0.15445515142967148, 0.12046347356488774, 0.09557982486664574, 0.08510271015063464, 0.12071876199812703, 0.09531930164481583, 0.9356426879083819, 0.9335734694685907, 0.9350218877881051, 0.929757655677405, 0.9248158693764036, 0.9323126289099279, 0.9397711272858015, 0.91239360352418, 0.936735938305259, 0.7772468759716983, 0.7496483027768837, 0.7345606260889079, 0.737582319489863, 0.8142684319940797, 0.7825893660855354, 0.7371556796956273, 0.7495762088134883, 0.7088423869581622, 0.22903298948761164, 0.1406019519617968, 0.2279886970987448, 0.3851091207586109, 0.2745011269841704, 0.21263274414145128, 0.17729801548113633, 0.7974982549307721, 0.23521670971535602, 0.3881066531227624, 0.13251005476965716, 0.26756408253270525, 0.2802302314120365, 0.3254158344090059, 0.39638559886614533, 0.30202075338154444, 0.3255551068931746, 0.3243177933292798, 0.29685576110364353, 0.27635471988670246, 0.1340793698813323, 0.3187730359067159, 0.3201332604939324, 0.31973140730680294, 0.31669041679233567, 0.30113911588994957, 0.3250944372609128, 0.033590369391869324, 0.09865156088851579, 0.02188480691948791, 0.0699297054574497, 0.052977833199685076, 0.06960598438293641, 0.018516292964835146, 0.04826020101895612, 0.09717613137169134, 0.1255573103209746, 0.07476672741191492, 0.15680492616776087, 0.07694714076059261, 0.05834285927306959, 0.07479630003350779, 0.15125279649206025, 0.11308899836522124, 0.1584525570616666, 0.174448348644068, 0.19523734100013124, 0.20488521261933812, 0.10803165200209564, 0.08600952484093416, 0.118838619302581, 0.1694819951893014, 0.2254782606825665, 0.10661024976744882, 0.26530544827521196, 0.13851128795121515, 0.06960546700821602, 0.078517499017553, 0.12355490687670645, 0.25793205102244043, 0.08196171534417118, 0.135439278151687, 0.0838361573612536, 0.589516323966551, 0.561470077691393, 0.6061554131279654, 0.6200026708724479, 0.5788049982937458, 0.5521423274661744, 0.631328115977124, 0.6108097878845309, 0.581569181395605, 0.12175235271738238, 0.09026306902943904, 0.17489374124118418, 0.13150475829267705, 0.12170660899483787, 0.0914501540554471, 0.10277282020404, 0.11463946139574777, 0.11732853414678268, 0.3355872724810688, 0.7188618083485022, 0.2770059730354526, 0.23429282811431962, 0.7528032833097507, 0.4035155220370551, 0.2890155021437858, 0.5844843144404667, 0.22855129263482277, 0.5152167700106447, 0.41264474710529553, 0.36224370292152575, 0.3875326474275623, 0.5419230116290161, 0.5163943842311773, 0.34437900870384286, 0.6427762541713294, 0.5523150949460194, 0.3022173665088912, 0.21157069681720664, 0.2271810792239266, 0.28841118114168807, 0.24359493999863324, 0.34805973483223673, 0.2582327462791941, 0.32587967811714136, 0.1730885802860065, 0.2378516044878749, 0.21559865479663887, 0.23125691462028686, 0.3558912621323651, 0.21622177528929765, 0.21279881488583618, 0.26157340323280664, 0.22890098026589645, 0.25839788546734266, 0.19641437777317705, 0.21632694010729236, 0.2078685447880796, 0.25196079979842323, 0.19754789692927022, 0.20201613208827873, 0.17199751372200922, 0.19668341233637454, 0.22341802953949164, 0.18729331662729487, 0.17847029269584036, 0.1879365915240364, 0.934138742120961, 0.20018695993503377, 0.9338985520689573, 0.9205865547828369, 0.917225320089483, 0.9349640754638455, 0.8661232215488948, 0.849672374709491, 0.8190135319819326, 0.9088067738976253, 0.09474610592143962, 0.8562844681946542, 0.9087687336653373, 0.10450352577130229, 0.7862748780576179, 0.20473913190922832, 0.18999877632211182, 0.2278418494740757, 0.27364880014932447, 0.24586030137800086, 0.19791568144147265, 0.2463682488084722, 0.25303616486601443, 0.26774106062155434, 0.10604166124075798, 0.0974518430875152, 0.08373275264337532, 0.09746788535846096, 0.1072098402709818, 0.08183057339084265, 0.08623722825522873, 0.10113112717223538, 0.10618669600767028]}, "mutation_prompt": null}
{"id": "82b60a48-2f63-4c83-b75a-801b07feaeb6", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.9  # inertia weight, increased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Slightly increase the inertia weight to enhance exploration early on.", "configspace": "", "generation": 96, "fitness": 0.3800919444291652, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "metadata": {"aucs": [0.8926962220325649, 0.8621187210683376, 0.8903309415335436, 0.8392401792325419, 0.8604009917863479, 0.8592237888605186, 0.8607889437863898, 0.8772432835590783, 0.8732789851184516, 0.7339315555420818, 0.6969114070161679, 0.7258677519316896, 0.738166371711064, 0.7215725655943594, 0.7121985183976134, 0.6816707952930634, 0.703260108981087, 0.7112328990894562, 0.09181455329755828, 0.6857178228031242, 0.07329609211274313, 0.10119467385299008, 0.11560144941802042, 0.14254359016509532, 0.08053119509717965, 0.09362246740433111, 0.08908755031834192, 0.12477840008738983, 0.09533797024155777, 0.13076917692397005, 0.15409200626864317, 0.10791957432757171, 0.10795082477805484, 0.09227635581285809, 0.08577606809291771, 0.10771448484730539, 0.9340993132582481, 0.9337364531332549, 0.9288469173005733, 0.9297490019021782, 0.9306047238334422, 0.9352094859275482, 0.9400449194967558, 0.9150482139283173, 0.9353561772238579, 0.7225853013022823, 0.749895814968792, 0.720853161735161, 0.759540262876792, 0.7473884272486822, 0.7677332956517278, 0.756892036300021, 0.7376885043769473, 0.7319303907632555, 0.8048455892413132, 0.8595593746458088, 0.22738464895954846, 0.8897441054307236, 0.21210367721467582, 0.37175125906585516, 0.17759089581498044, 0.2307149920489373, 0.8346436066055808, 0.2686088320480138, 0.13119629383756148, 0.1305827097882688, 0.2884142164691178, 0.3182424803258842, 0.26508346413374484, 0.2886387489919191, 0.30123667470647475, 0.3052091151876528, 0.26088709555512846, 0.28343559670321405, 0.2667590726598619, 0.26430969600666965, 0.30000760975228946, 0.2705175777912956, 0.30314802287144016, 0.30649218228713837, 0.3055018619325027, 0.024204548192399256, 0.1399886006171286, 0.11975692220948364, 0.11059541857578681, 0.014519530237322553, 0.00173251362897886, 0.05018106692160096, 0.07295229504336365, 0.09848123499973171, 0.2531884285391969, 0.15905354837947538, 0.1398248720019546, 0.08243963787661013, 0.05885057350105671, 0.0680744980465624, 0.19658836297366578, 0.07294111532868863, 0.10909538636573235, 0.12919818120925008, 0.1826524720367091, 0.22745216140887636, 0.1253219963904676, 0.11318735150688097, 0.1907230090730041, 0.1649650657402303, 0.1867045881251278, 0.12787345924261517, 0.2441763029759184, 0.12592495842535323, 0.08519250069183903, 0.12883621461699513, 0.17748038772479335, 0.18951230338960012, 0.12156794262851578, 0.15596598589109412, 0.12772325351488345, 0.5396563828651422, 0.6059530503651873, 0.5881577289224004, 0.5773643959788917, 0.6658046268827397, 0.5662159879560948, 0.5605069540384153, 0.6102148677191074, 0.6257121487732887, 0.11384812565831814, 0.08541491706134896, 0.09313746174053117, 0.13774864191345426, 0.11002265400901778, 0.13738613848197223, 0.10231052233954019, 0.12787790222383177, 0.15436685249402748, 0.5797235419846941, 0.22439645305955247, 0.21467774243123772, 0.40291582730917075, 0.5643252633842335, 0.3733310289866155, 0.5971890471406929, 0.7275242028175202, 0.6692315180369967, 0.35235351328705466, 0.5076333092038046, 0.4080406492150972, 0.42345177421214375, 0.507056761152328, 0.5720569642589368, 0.2910309390228353, 0.5190952742460876, 0.2781376726936189, 0.40448049971491895, 0.3254296243624213, 0.2136538814308685, 0.28101206254269573, 0.22545691267109225, 0.39597073185707055, 0.2726547744812753, 0.2916060077400243, 0.21657475366322299, 0.31310159934444903, 0.2364317511052353, 0.2148028144079378, 0.29388172832341974, 0.23930435921918547, 0.23197586748831367, 0.2257981914418422, 0.3408268053931838, 0.258447916842356, 0.18682279802609014, 0.21609107670512318, 0.20837641159434483, 0.224828761071045, 0.2114851887545799, 0.21001587033481406, 0.18102487570312975, 0.19903891713500765, 0.2012008801061601, 0.18727909835191103, 0.178210767970159, 0.18791916003464282, 0.9236496023486809, 0.200175241709603, 0.9290661516031341, 0.9303645563252086, 0.9100716569236599, 0.9287640460182045, 0.8684409834002598, 0.7972257906012286, 0.890911169438927, 0.8520824739009595, 0.16756104976932507, 0.9104727542035254, 0.8481354573960884, 0.10449689767073, 0.8539375085873903, 0.23828278333067865, 0.2550470197103284, 0.39891544616718433, 0.20845644248206108, 0.23912578260791018, 0.2396808667346848, 0.2196780713729155, 0.24652721431103208, 0.21232289876683463, 0.10286645586399523, 0.09065032199970269, 0.13619446692741388, 0.0998536996074808, 0.11102930856518001, 0.09311733848285986, 0.0897419442508115, 0.0834162828065762, 0.09112660741432133]}, "mutation_prompt": null}
{"id": "3839eb79-06bb-4013-a6b3-a6062704ffc7", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.8 * eval_ratio  # Enhanced social weight for better global convergence\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Introduce adaptive cognitive and social parameters for enhanced exploration and exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.37074908200095485, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "metadata": {"aucs": [0.8814757978217808, 0.8644669623984506, 0.8803861580907519, 0.8276123971806298, 0.8514982909254111, 0.8713170881099794, 0.8772133527235372, 0.8732109669452429, 0.8648992959974502, 0.7444003857201132, 0.7262876715909572, 0.6882426166557564, 0.7421521698135449, 0.6908820392747064, 0.7107178786083808, 0.6837411805957454, 0.7167086159629494, 0.702128726838708, 0.12160911012721409, 0.1589066187474898, 0.07064594087264064, 0.13060174878495123, 0.1144844433947666, 0.12380868082838237, 0.11024788675989006, 0.10109135402343361, 0.17736393433736464, 0.11672037537789914, 0.1512744913156332, 0.10967168980926578, 0.12293019383234327, 0.0911114208675059, 0.08906810144932698, 0.09469780346580392, 0.10921613175232292, 0.07850584585615783, 0.9332779849930781, 0.9335864718912048, 0.9306142004755525, 0.929757535593949, 0.9305451833949097, 0.935216036514007, 0.9418030059784399, 0.9157546992408706, 0.9249596324918777, 0.7787464916548372, 0.7687012684665327, 0.7058855012581615, 0.7569107029838698, 0.7482526393194848, 0.7602091989835044, 0.728563616643819, 0.7484181021155649, 0.7347024738837522, 0.38721674192984934, 0.2164143065018952, 0.22518467767935124, 0.9022982122777996, 0.21211559762778465, 0.21944566382135156, 0.8222508582449921, 0.2342450880939385, 0.7734788592445081, 0.2827454888901112, 0.13271367909513943, 0.28900663958237305, 0.2779198605831501, 0.2838125248995528, 0.2593022954147779, 0.273600994543865, 0.28805973672770335, 0.27246872973135094, 0.261492327793474, 0.26665884573961063, 0.23308862264093744, 0.24589303635064264, 0.28009058783076757, 0.31447940184760315, 0.30776025319102174, 0.3045866896395073, 0.295515374632043, 0.026176759489990764, 0.06020559089848354, 0.0698470336209186, 0.10488226290932379, 0.064906873943671, 0.054386752498656654, 0.02661972729578521, 0.033171240719839235, 0.16560690904485742, 0.16780189002827572, 0.10546989185053135, 0.16621538390606105, 0.06844735194959195, 0.03033440443219737, 0.07505403739421468, 0.1789286906368528, 0.12241750699267284, 0.16763014245856067, 0.20788260078184007, 0.14527258449962444, 0.38309183060418195, 0.10945984249802732, 0.10441554465863623, 0.21463682329626654, 0.18384635568518992, 0.28038112417374783, 0.11438115903774537, 0.41961898935512765, 0.16826598613276877, 0.07718303934479098, 0.19058326651221258, 0.17530619814509663, 0.18229774698443502, 0.2167267527597534, 0.1521191024148273, 0.09167030596620662, 0.5879707521611048, 0.6172449922050361, 0.576734643212444, 0.5980144838810733, 0.5617578699869878, 0.6357344908338391, 0.599084803221246, 0.5938309882221805, 0.6021480255232949, 0.10799384163482051, 0.07280349350468207, 0.10112121747070635, 0.15863291319687922, 0.10869200062058049, 0.0799454379558241, 0.09113134373811138, 0.13996620168819862, 0.11216624854239365, 0.6185821289197866, 0.35534881838179366, 0.1959129470081985, 0.5337962239294006, 0.3920361562619882, 0.24560534061885242, 0.39748959000845074, 0.22654947036212536, 0.5229725180477711, 0.3978541882968014, 0.43599144552624813, 0.37918470716921393, 0.5944864650733632, 0.28730350289371853, 0.3522945543832987, 0.19840600148715537, 0.45276465983788916, 0.2696570852496347, 0.25400258672216847, 0.3916905878810445, 0.23570015331770067, 0.21937336317481337, 0.22500086776431016, 0.3132668862323591, 0.24828836140398913, 0.4609755072753714, 0.16699886979641865, 0.24963203348563479, 0.23765949867435887, 0.17228649666056484, 0.2593352043049174, 0.30541116984206973, 0.23558475216810992, 0.24565974961360038, 0.23062332879594583, 0.2597334602451892, 0.20843347648301858, 0.2520291020187144, 0.20769431330540078, 0.24948780150385041, 0.22458324106820626, 0.19894434919043913, 0.20019275650177804, 0.22384846594105867, 0.1830913833775175, 0.18742121286859226, 0.17834776233164507, 0.18789326360429048, 0.9134694024173303, 0.20021310945452064, 0.9348707416416601, 0.925547112642476, 0.9184851375321543, 0.9299260606462478, 0.8552931606842766, 0.8342201952586245, 0.8586727972493059, 0.85062282278179, 0.15419552055525254, 0.9017106377997743, 0.8564047059133861, 0.1045000188336187, 0.8836301954732886, 0.21089341409712747, 0.41798826772887265, 0.25622250533624813, 0.2161190801473598, 0.2681264348492557, 0.21890669011283048, 0.2474182234153065, 0.2516382716212696, 0.24741601645119193, 0.14969432753312195, 0.0963792526392071, 0.0710280704948244, 0.07966308121466825, 0.10358839539480158, 0.10368791965746227, 0.07546180845872219, 0.09265654763314668, 0.0964633197129886]}, "mutation_prompt": null}
{"id": "17259d98-5aa7-4e3f-8fd7-bafac4bda864", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 35  # Reduced population size for faster convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.965 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Improved adaptive mutation probability decay rate for enhancing convergence.", "configspace": "", "generation": 98, "fitness": 0.3789628635448043, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "metadata": {"aucs": [0.8926962220325649, 0.8621187210683376, 0.8903309415335436, 0.8392401792325419, 0.8604009917863479, 0.8592237888605186, 0.8607889437863898, 0.8772432835590783, 0.8732789851184516, 0.7339315555420818, 0.6969114070161679, 0.7258677519316896, 0.738166371711064, 0.7215725655943594, 0.7121985183976134, 0.6816707952930634, 0.703260108981087, 0.7112328990894562, 0.09181455329755828, 0.6857178228031242, 0.07329609211274313, 0.10119467385299008, 0.11560144941802042, 0.14254359016509532, 0.08053119509717965, 0.09362246740433111, 0.08908755031834192, 0.12477840008738983, 0.09533797024155777, 0.13076917692397005, 0.15409200626864317, 0.10791957432757171, 0.10795082477805484, 0.09227635581285809, 0.08577606809291771, 0.10771448484730539, 0.9340993132582481, 0.9337364531332549, 0.9288469173005733, 0.9297490019021782, 0.9306047238334422, 0.9352094859275482, 0.9400449194967558, 0.9150482139283173, 0.9353561772238579, 0.7225853013022823, 0.749895814968792, 0.720853161735161, 0.759540262876792, 0.7473884272486822, 0.7677332956517278, 0.756892036300021, 0.7376885043769473, 0.749942218654316, 0.8048455892413132, 0.8595593746458088, 0.22738464895954846, 0.8897441054307236, 0.21210367721467582, 0.2129392839174271, 0.17759089581498044, 0.2307149920489373, 0.8346436066055808, 0.2686088320480138, 0.13119629383756148, 0.1305827097882688, 0.2884142164691178, 0.3182424803258842, 0.26508346413374484, 0.2886387489919191, 0.30123667470647475, 0.3052091151876528, 0.26088709555512846, 0.28343559670321405, 0.25083313868949186, 0.26430969600666965, 0.30000760975228946, 0.2705175777912956, 0.30314802287144016, 0.30649218228713837, 0.3055018619325027, 0.024204548192399256, 0.1399886006171286, 0.03649781905528271, 0.11059541857578681, 0.014519530237322553, 0.00173251362897886, 0.05018106692160096, 0.07295229504336365, 0.08754790379084465, 0.2531884285391969, 0.15905354837947538, 0.1674166763741789, 0.08243963787661013, 0.05885057350105671, 0.05895354135338171, 0.19658836297366578, 0.07294111532868863, 0.10909538636573235, 0.12919818120925008, 0.1826524720367091, 0.25923583337685663, 0.1253219963904676, 0.11318735150688097, 0.18133912611983782, 0.1649650657402303, 0.1867045881251278, 0.12787345924261517, 0.2441763029759184, 0.12592495842535323, 0.08519250069183903, 0.12883621461699513, 0.17748038772479335, 0.18951230338960012, 0.12156794262851578, 0.15596598589109412, 0.12772325351488345, 0.5396563828651422, 0.6059530503651873, 0.5881577289224004, 0.5773643959788917, 0.6658046268827397, 0.5662159879560948, 0.5605069540384153, 0.6102148677191074, 0.6257121487732887, 0.11384812565831814, 0.08541491706134896, 0.09313746174053117, 0.13774864191345426, 0.11002265400901778, 0.13738613848197223, 0.10231052233954019, 0.12787790222383177, 0.15436685249402748, 0.5797235419846941, 0.22439645305955247, 0.21467774243123772, 0.40291582730917075, 0.5643252633842335, 0.3733310289866155, 0.5971890471406929, 0.7275242028175202, 0.6692315180369967, 0.35235351328705466, 0.5076333092038046, 0.4080406492150972, 0.42345177421214375, 0.507056761152328, 0.5720569642589368, 0.2910309390228353, 0.5190952742460876, 0.2781376726936189, 0.40448049971491895, 0.3254296243624213, 0.2136538814308685, 0.28101206254269573, 0.22545691267109225, 0.39597073185707055, 0.2726547744812753, 0.2916060077400243, 0.21657475366322299, 0.31310159934444903, 0.2364317511052353, 0.2148028144079378, 0.29388172832341974, 0.23930435921918547, 0.23197586748831367, 0.2257981914418422, 0.3408268053931838, 0.258447916842356, 0.18682279802609014, 0.21609107670512318, 0.20837641159434483, 0.224828761071045, 0.2114851887545799, 0.21001587033481406, 0.18102487570312975, 0.19903891713500765, 0.2012008801061601, 0.18727909835191103, 0.178210767970159, 0.18791916003464282, 0.9236496023486809, 0.200175241709603, 0.9290661516031341, 0.9303645563252086, 0.9100716569236599, 0.9235848523191406, 0.8684409834002598, 0.7972257906012286, 0.890911169438927, 0.8520824739009595, 0.16756104976932507, 0.9104727542035254, 0.8481354573960884, 0.10449689767073, 0.8252831101614553, 0.23828278333067865, 0.2550470197103284, 0.39891544616718433, 0.20845644248206108, 0.23912578260791018, 0.2396808667346848, 0.2196780713729155, 0.24652721431103208, 0.21232289876683463, 0.10286645586399523, 0.09065032199970269, 0.13619446692741388, 0.0998536996074808, 0.11102930856518001, 0.09311733848285986, 0.0897419442508115, 0.0834162828065762, 0.09112660741432133]}, "mutation_prompt": null}
{"id": "6e7d69c7-f338-4078-b169-fd9cb5f3d8fc", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 36  # Increased population size for better convergence\n        self.w = 0.8  # inertia weight, decreased initial value\n        self.c1 = 1.7  # cognitive parameter, slight tweak\n        self.c2 = 1.5  # social parameter, slight tweak\n        self.bounds = (-5.0, 5.0)\n        self.mutation_prob = 0.15  # Increased initial mutation probability\n        self.mutation_scale = 0.5\n        self.local_topology = 3  # local topology size\n    \n    def __call__(self, func):\n        lower, upper = self.bounds\n        pop = np.random.uniform(lower, upper, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(pop)\n        personal_best_scores = np.array([func(ind) for ind in pop])\n        global_best_idx = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_score = personal_best_scores[global_best_idx]\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.w = 0.4 + (0.5 * np.random.rand()) \n            eval_ratio = evaluations / self.budget\n            self.c1 = 2.0 * (1 - eval_ratio) + 1.0 * eval_ratio  # Slightly adjusted formula for better balance\n            self.c2 = 0.5 * (1 - eval_ratio) + 2.5 * eval_ratio\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            velocities = (self.w * velocities + \n                          self.c1 * r1 * (personal_best_positions - pop) + \n                          self.c2 * r2 * (global_best_position - pop))\n            velocities = np.clip(velocities, -0.7 + 0.3 * eval_ratio, 0.7 - 0.3 * eval_ratio)  # Adaptive velocity clipping\n            pop = pop + velocities\n            pop = np.clip(pop, lower, upper)\n\n            # Evaluate population\n            scores = np.array([func(ind) for ind in pop])\n            evaluations += self.population_size\n\n            # Update personal bests\n            better_mask = scores < personal_best_scores\n            personal_best_scores[better_mask] = scores[better_mask]\n            personal_best_positions[better_mask] = pop[better_mask]\n\n            # Dynamic neighborhood topology\n            for i in range(self.population_size):\n                local_indices = np.random.choice(self.population_size, self.local_topology, replace=False)\n                local_best_idx = local_indices[np.argmin(personal_best_scores[local_indices])]\n                if personal_best_scores[local_best_idx] < personal_best_scores[i]:\n                    personal_best_positions[i] = personal_best_positions[local_best_idx]\n\n            # Update global best\n            min_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_idx]\n                global_best_position = personal_best_positions[min_idx]\n\n            # Apply adaptive mutation\n            self.mutation_prob *= 0.97 * (1 - eval_ratio)  # Changed mutation probability decay rate\n            if np.random.rand() < self.mutation_prob:\n                mutation_strength = np.abs(global_best_score - scores) / (np.std(scores) + 1e-12)\n                self.mutation_scale = max(0.05, self.mutation_scale * 0.98 * (1 + eval_ratio))  # Adaptive mutation scale\n                diversity = np.std(pop, axis=0).mean()  # Measure of swarm diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < mutation_strength[i] + diversity * 0.1:  # Enhance mutation chance\n                        mutation_vector = np.random.normal(0, self.mutation_scale, self.dim)\n                        pop[i] = np.clip(pop[i] + mutation_vector, lower, upper)\n                        new_score = func(pop[i])\n                        evaluations += 1\n                        if new_score < personal_best_scores[i]:\n                            personal_best_scores[i] = new_score\n                            personal_best_positions[i] = pop[i]\n                            if new_score < global_best_score:\n                                global_best_score = new_score\n                                global_best_position = pop[i]\n\n        return global_best_position, global_best_score", "name": "MultiStrategyPSO", "description": "Enhance convergence by slightly increasing the population size.", "configspace": "", "generation": 99, "fitness": 0.3478222672233422, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "00385a1b-b1fb-4b06-b8b6-3d27e57dfd0d", "metadata": {"aucs": [0.8821364528212405, 0.8867201543476954, 0.8769292472918412, 0.8362714356983242, 0.8537688818780851, 0.8681456427765725, 0.8582994698492098, 0.8721839422016119, 0.8695070248283551, 0.7187309631702614, 0.7090080126189651, 0.7218367102803456, 0.7381702450732759, 0.7205422574707439, 0.7021620107334836, 0.7024745901100086, 0.7307676212482312, 0.6950513521841174, 0.08396533127210992, 0.14312228822580197, 0.10760751081969688, 0.11437641745943561, 0.13989035857571164, 0.11168842159346604, 0.09588666402977486, 0.7645175343129071, 0.15474450935358885, 0.15547650876959984, 0.10974065750117401, 0.069321120275049, 0.12297306938063068, 0.1101928456532425, 0.1276755380658987, 0.12327215103841282, 0.09569203798991854, 0.08757512911912013, 0.9365392615546267, 0.9300864027406371, 0.9342569008263909, 0.9316781794102924, 0.9196094029102998, 0.9204611222658501, 0.9377555156958363, 0.9155218553213565, 0.9346027398026825, 0.7291322706559171, 0.7607687629751798, 0.7381853478848195, 0.7862076137792101, 0.7518224456635325, 0.7649176181763963, 0.7540647402349936, 0.7284342569028628, 0.7676412786245015, 0.2284508580550102, 0.8712696947773959, 0.17081338764531107, 0.20919564664979606, 0.8720140925087373, 0.27310339962729135, 0.32156282531028957, 0.23511238461037398, 0.23419194556014, 0.29670179611420533, 0.35397977620436905, 0.13134269389354158, 0.28281524656674706, 0.13361578915251615, 0.28108059950172914, 0.2914490442296377, 0.26944161844280023, 0.28305034872744195, 0.2740714792495199, 0.26608844934215004, 0.13235532041172815, 0.29647947002147057, 0.13411640131153857, 0.2487504920080409, 0.30969825971516873, 0.36147855339560453, 0.12958098681945318, 0.05191743532443449, 0.06980242657618851, 0.08721001519183535, 0.00807119263319056, 0.0016321283620965854, 0.07055693410072927, 0.06944175894209115, 0.017411590980889402, 0.04284530885272175, 0.1930457192167654, 0.07663534004413908, 0.10521268854317423, 0.09507642059054089, 0.07407007558057233, 0.09097306839221853, 0.07584413431361059, 0.14603399572375075, 0.09122108763682357, 0.2120062255496209, 0.23905782977206036, 0.29412072400462375, 0.1572278384871164, 0.10472957336967481, 0.16965029976501445, 0.09936870632616335, 0.23463885671255225, 0.28759112609629434, 0.16669522607468168, 0.15715279583195918, 0.11641627462210313, 0.14188177477107033, 0.19487474314876452, 0.1316501144955935, 0.12774738736116342, 0.11308236708580566, 0.12014555916965564, 0.5625155603095455, 0.5646947361321434, 0.5702494204711674, 0.5609048968073773, 0.5422648564503004, 0.6007016759079613, 0.61479256487836, 0.6148904921283622, 0.590510507451539, 0.10234218859707112, 0.12012816144199345, 0.15316378102183048, 0.14138613350635676, 0.11664599896482264, 0.13926640183171735, 0.14042022578071933, 0.15432620515980366, 0.1419400704787278, 0.7570281723405674, 0.27393849414242044, 0.4972131448978132, 0.20113890361628528, 0.38904096890073014, 0.4145081895772058, 0.2718765510561977, 0.1579061333961227, 0.4493380459631452, 0.3843173339465792, 0.38430370700796235, 0.36692973298200626, 0.5277286993937086, 0.48896909310071024, 0.4217481348292159, 0.2669481779243392, 0.37407540060622946, 0.6613036555589262, 0.2317200909463334, 0.3135584321567092, 0.3331619257072336, 0.39307400858633823, 0.22859966078109795, 0.311056832969268, 0.2593504331412718, 0.2707333349112194, 0.23366186445905623, 0.22114519468470284, 0.24928898404509447, 0.18101858373831747, 0.29280388277183833, 0.2133400837039473, 0.19600813709738296, 0.2286113321255595, 0.30359029999555864, 0.2285977091724406, 0.19481901055865025, 0.2519474677428132, 0.19960516569696352, 0.2504257923419867, 0.18877378839196512, 0.22328782490235266, 0.21043678330158866, 0.22450320939091928, 0.18378095577444797, 0.1874614676091685, 0.17817655135307608, 0.15308870901136162, 0.9202384809958747, 0.20071719242559272, 0.11485679685760875, 0.12306114200673746, 0.16902429976566868, 0.16845726610100287, 0.8592811313150357, 0.15739687963417548, 0.8916811820757427, 0.8566323571707921, 0.16816331078786917, 0.1546956812877719, 0.1040498635837146, 0.8761558078922164, 0.8807878892129476, 0.22678889625804866, 0.24516097183811358, 0.21722701137370903, 0.24899393905447365, 0.24449162554610349, 0.2740758100739027, 0.25077817405444613, 0.2524166372928093, 0.29563737298988113, 0.10652654766813974, 0.11177611082493677, 0.10970386990063141, 0.09155517174377059, 0.10063077077934335, 0.12180392814783447, 0.10728976589774608, 0.0864301660127248, 0.10908060909893325]}, "mutation_prompt": null}
