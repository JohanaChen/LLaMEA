{"id": "aeaa04cc-d12d-4a87-9dd8-aa5eabc1fa51", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10\n        self.pso_max_iter = 100\n        self.sa_max_iter = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def pso_init():\n            return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        def sa_init():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def evaluate_solution(solution):\n            return func(solution)\n\n        def sa_acceptance_probability(curr_cost, new_cost, temperature):\n            if new_cost < curr_cost:\n                return 1\n            return np.exp((curr_cost - new_cost) / temperature)\n\n        def sa_optimize(initial_solution):\n            curr_solution = initial_solution\n            curr_cost = evaluate_solution(curr_solution)\n            best_solution = np.copy(curr_solution)\n            best_cost = curr_cost\n            temperature = 1.0\n            for _ in range(self.sa_max_iter):\n                new_solution = curr_solution + np.random.normal(0, 0.1, self.dim)\n                new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                new_cost = evaluate_solution(new_solution)\n                if sa_acceptance_probability(curr_cost, new_cost, temperature) > np.random.rand():\n                    curr_solution = new_solution\n                    curr_cost = new_cost\n                    if new_cost < best_cost:\n                        best_solution = np.copy(new_solution)\n                        best_cost = new_cost\n                temperature *= 0.95\n            return best_solution\n\n        particles = pso_init()\n        for _ in range(self.pso_max_iter):\n            for i in range(self.population_size):\n                particles[i] = sa_optimize(particles[i])\n            best_particle = min(particles, key=lambda x: evaluate_solution(x))\n            if evaluate_solution(best_particle) < evaluate_solution(global_best_particle):\n                global_best_particle = best_particle\n\n        return evaluate_solution(global_best_particle)", "name": "HybridPSOSA", "description": "A novel hybrid metaheuristic algorithm combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to efficiently explore and exploit the search space for black box optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 52, in __call__\nUnboundLocalError: local variable 'global_best_particle' referenced before assignment\n.", "error": "UnboundLocalError(\"local variable 'global_best_particle' referenced before assignment\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 52, in __call__\nUnboundLocalError: local variable 'global_best_particle' referenced before assignment\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "bfe3e8ed-1327-440a-bcbe-b6865811aabe", "solution": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10\n        self.pso_max_iter = 100\n        self.sa_max_iter = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        def pso_init():\n            return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n        def sa_init():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        def evaluate_solution(solution):\n            return func(solution)\n\n        def sa_acceptance_probability(curr_cost, new_cost, temperature):\n            if new_cost < curr_cost:\n                return 1\n            return np.exp((curr_cost - new_cost) / temperature)\n\n        def sa_optimize(initial_solution):\n            curr_solution = initial_solution\n            curr_cost = evaluate_solution(curr_solution)\n            best_solution = np.copy(curr_solution)\n            best_cost = curr_cost\n            temperature = 1.0\n            for _ in range(self.sa_max_iter):\n                new_solution = curr_solution + np.random.normal(0, 0.1, self.dim)\n                new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                new_cost = evaluate_solution(new_solution)\n                if sa_acceptance_probability(curr_cost, new_cost, temperature) > np.random.rand():\n                    curr_solution = new_solution\n                    curr_cost = new_cost\n                    if new_cost < best_cost:\n                        best_solution = np.copy(new_solution)\n                        best_cost = new_cost\n                temperature *= 0.95\n            return best_solution\n\n        particles = pso_init()\n        for _ in range(self.pso_max_iter):\n            for i in range(self.population_size):\n                particles[i] = sa_optimize(particles[i])\n            best_particle = min(particles, key=lambda x: evaluate_solution(x))\n            if evaluate_solution(best_particle) < evaluate_solution(global_best_particle):\n                global_best_particle = best_particle\n\n        return evaluate_solution(global_best_particle)", "name": "HybridPSOSA", "description": "A novel hybrid metaheuristic algorithm combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to efficiently explore and exploit the search space for black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aeaa04cc-d12d-4a87-9dd8-aa5eabc1fa51", "metadata": {}, "mutation_prompt": null}
