{"id": "0ba9df86-d8bf-4fce-9cdb-c6ac2fdf3e6c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.de_f = 0.8\n        self.de_cr = 0.9\n\n    def __call__(self, func):\n        def pso_update(position, velocity, pbest, gbest):\n            new_velocity = self.pso_w * velocity + self.pso_c1 * np.random.rand(self.dim) * (pbest - position) + self.pso_c2 * np.random.rand(self.dim) * (gbest - position)\n            new_position = position + new_velocity\n            return new_position, new_velocity\n\n        def de_mutation(population, target_idx):\n            candidates = [idx for idx in range(self.pop_size) if idx != target_idx]\n            a, b, c = population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.de_f * (b - c), -5.0, 5.0)\n            return mutant\n\n        population = np.random.uniform(-5.0, 5.0, (self.pop_size, self.dim))\n        fitness = [func(individual) for individual in population]\n        best_idx = np.argmin(fitness)\n        gbest = population[best_idx].copy()\n        pbest = population.copy()\n        pbest_fitness = fitness.copy()\n\n        for _ in range(self.budget - self.pop_size):\n            for i in range(self.pop_size):\n                # PSO update\n                population[i], velocity = pso_update(population[i], velocity, pbest[i], gbest)\n\n                # DE mutation\n                mutant = de_mutation(population, i)\n\n                # DE crossover\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Update if better\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < pbest_fitness[i]:\n                        pbest[i] = trial\n                        pbest_fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        gbest = trial\n                        best_idx = i\n\n        return gbest", "name": "HybridPSODE", "description": "An adaptive hybrid optimization algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with dynamic strategy selection based on function evaluations.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 36, in __call__\nUnboundLocalError: local variable 'velocity' referenced before assignment\n.", "error": "UnboundLocalError(\"local variable 'velocity' referenced before assignment\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 36, in __call__\nUnboundLocalError: local variable 'velocity' referenced before assignment\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "21c0ac7b-f129-46bf-b6c5-0b4b5885ea53", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.pso_w = 0.5\n        self.pso_c1 = 1.5\n        self.pso_c2 = 1.5\n        self.de_f = 0.8\n        self.de_cr = 0.9\n\n    def __call__(self, func):\n        def pso_update(position, velocity, pbest, gbest):\n            new_velocity = self.pso_w * velocity + self.pso_c1 * np.random.rand(self.dim) * (pbest - position) + self.pso_c2 * np.random.rand(self.dim) * (gbest - position)\n            new_position = position + new_velocity\n            return new_position, new_velocity\n\n        def de_mutation(population, target_idx):\n            candidates = [idx for idx in range(self.pop_size) if idx != target_idx]\n            a, b, c = population[np.random.choice(candidates, 3, replace=False)]\n            mutant = np.clip(a + self.de_f * (b - c), -5.0, 5.0)\n            return mutant\n\n        population = np.random.uniform(-5.0, 5.0, (self.pop_size, self.dim))\n        fitness = [func(individual) for individual in population]\n        best_idx = np.argmin(fitness)\n        gbest = population[best_idx].copy()\n        pbest = population.copy()\n        pbest_fitness = fitness.copy()\n\n        for _ in range(self.budget - self.pop_size):\n            for i in range(self.pop_size):\n                # PSO update\n                population[i], velocity = pso_update(population[i], velocity, pbest[i], gbest)\n\n                # DE mutation\n                mutant = de_mutation(population, i)\n\n                # DE crossover\n                crossover_mask = np.random.rand(self.dim) < self.de_cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Update if better\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < pbest_fitness[i]:\n                        pbest[i] = trial\n                        pbest_fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        gbest = trial\n                        best_idx = i\n\n        return gbest", "name": "HybridPSODE", "description": "An adaptive hybrid optimization algorithm combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) with dynamic strategy selection based on function evaluations.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0ba9df86-d8bf-4fce-9cdb-c6ac2fdf3e6c", "metadata": {}, "mutation_prompt": null}
