{"id": "e5f7dd8c-9705-444c-9bda-0a99eb75abf1", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.NP = 10  # population size\n        self.CR = 0.9  # crossover rate\n        self.F = 0.5  # scaling factor\n        self.strategy_probs = np.full((dim, 4), 0.25)  # initialize mutation strategy probabilities\n\n    def __call__(self, func):\n        def mutate(target, pop, strategy_probs):\n            rand = np.random.rand(self.NP, 3)\n            mutants = np.zeros((self.NP, self.dim))\n            for i in range(self.NP):\n                j = np.random.choice(range(4), p=strategy_probs[i])\n                if j == 0:  # DE/rand/1\n                    idxs = np.random.choice(range(self.NP), 3, replace=False)\n                    mutants[i] = pop[idxs[0]] + self.F * (pop[idxs[1]] - pop[idxs[2]])\n                elif j == 1:  # DE/current-to-best/2\n                    idxs = np.argsort(func(pop))[0:2]\n                    mutants[i] = target + self.F * (pop[idxs[0]] - pop[idxs[1]) + self.F * (pop[idxs[np.random.choice(range(2))] - pop[i]))\n                elif j == 2:  # DE/current-to-rand/1\n                    idxs = np.random.choice(range(self.NP), 2, replace=False)\n                    mutants[i] = pop[i] + self.F * (pop[idxs[0]] - pop[i]) + self.F * (pop[idxs[1]] - pop[idxs[0]])\n                else:  # DE/rand-to-best/2\n                    idxs = np.argsort(func(pop))[0:2]\n                    mutants[i] = pop[idxs[0]] + self.F * (pop[idxs[1]] - pop[idxs[0]) + self.F * (pop[np.random.choice(range(self.NP))] - pop[i]))\n                for k in range(3):\n                    if rand[i, k] < self.CR:\n                        mutants[i, k] = target[k]\n            return mutants\n\n        bounds = (-5.0, 5.0)\n        pop = np.random.uniform(bounds[0], bounds[1], (self.NP, self.dim))\n        fitness = func(pop)\n        best_idx = np.argmin(fitness)\n        best = pop[best_idx].copy()\n\n        for _ in range(self.budget):\n            mutants = mutate(pop, pop, self.strategy_probs)\n            mutants_fitness = func(mutants)\n            for i in range(self.NP):\n                if mutants_fitness[i] < fitness[i]:\n                    pop[i] = mutants[i]\n                    fitness[i] = mutants_fitness[i]\n                    if mutants_fitness[i] < func(best):\n                        best = mutants[i].copy()\n\n            # Update strategy probabilities based on success of strategies\n            successes = mutants_fitness < fitness\n            for i in range(self.NP):\n                j = np.argmax(np.random.multinomial(1, successes[i] * self.strategy_probs[i]))\n                self.strategy_probs[i] = 0.9 * self.strategy_probs[i] + 0.1 * (j == np.arange(4))\n\n        return best", "name": "AdaptiveDE", "description": "An advanced version of the Differential Evolution algorithm with adaptive control of mutation strategies and parameters.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 23\n    mutants[i] = target + self.F * (pop[idxs[0]] - pop[idxs[1]) + self.F * (pop[idxs[np.random.choice(range(2))] - pop[i]))\n                                                              ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '['\n.", "error": "SyntaxError(\"closing parenthesis ')' does not match opening parenthesis '['\", ('<string>', 23, 79, '                    mutants[i] = target + self.F * (pop[idxs[0]] - pop[idxs[1]) + self.F * (pop[idxs[np.random.choice(range(2))] - pop[i]))'))Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 23\n    mutants[i] = target + self.F * (pop[idxs[0]] - pop[idxs[1]) + self.F * (pop[idxs[np.random.choice(range(2))] - pop[i]))\n                                                              ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '['\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "a68dc086-ba17-4ed3-af00-ce5880081954", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.NP = 10  # population size\n        self.CR = 0.9  # crossover rate\n        self.F = 0.5  # scaling factor\n        self.strategy_probs = np.full((dim, 4), 0.25)  # initialize mutation strategy probabilities\n\n    def __call__(self, func):\n        def mutate(target, pop, strategy_probs):\n            rand = np.random.rand(self.NP, 3)\n            mutants = np.zeros((self.NP, self.dim))\n            for i in range(self.NP):\n                j = np.random.choice(range(4), p=strategy_probs[i])\n                if j == 0:  # DE/rand/1\n                    idxs = np.random.choice(range(self.NP), 3, replace=False)\n                    mutants[i] = pop[idxs[0]] + self.F * (pop[idxs[1]] - pop[idxs[2]])\n                elif j == 1:  # DE/current-to-best/2\n                    idxs = np.argsort(func(pop))[0:2]\n                    mutants[i] = target + self.F * (pop[idxs[0]] - pop[idxs[1]) + self.F * (pop[idxs[np.random.choice(range(2))] - pop[i]))\n                elif j == 2:  # DE/current-to-rand/1\n                    idxs = np.random.choice(range(self.NP), 2, replace=False)\n                    mutants[i] = pop[i] + self.F * (pop[idxs[0]] - pop[i]) + self.F * (pop[idxs[1]] - pop[idxs[0]])\n                else:  # DE/rand-to-best/2\n                    idxs = np.argsort(func(pop))[0:2]\n                    mutants[i] = pop[idxs[0]] + self.F * (pop[idxs[1]] - pop[idxs[0]) + self.F * (pop[np.random.choice(range(self.NP))] - pop[i]))\n                for k in range(3):\n                    if rand[i, k] < self.CR:\n                        mutants[i, k] = target[k]\n            return mutants\n\n        bounds = (-5.0, 5.0)\n        pop = np.random.uniform(bounds[0], bounds[1], (self.NP, self.dim))\n        fitness = func(pop)\n        best_idx = np.argmin(fitness)\n        best = pop[best_idx].copy()\n\n        for _ in range(self.budget):\n            mutants = mutate(pop, pop, self.strategy_probs)\n            mutants_fitness = func(mutants)\n            for i in range(self.NP):\n                if mutants_fitness[i] < fitness[i]:\n                    pop[i] = mutants[i]\n                    fitness[i] = mutants_fitness[i]\n                    if mutants_fitness[i] < func(best):\n                        best = mutants[i].copy()\n\n            # Update strategy probabilities based on success of strategies\n            successes = mutants_fitness < fitness\n            for i in range(self.NP):\n                j = np.argmax(np.random.multinomial(1, successes[i] * self.strategy_probs[i]))\n                self.strategy_probs[i] = 0.9 * self.strategy_probs[i] + 0.1 * (j == np.arange(4))\n\n        return best", "name": "AdaptiveDE", "description": "An advanced version of the Differential Evolution algorithm with adaptive control of mutation strategies and parameters.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e5f7dd8c-9705-444c-9bda-0a99eb75abf1", "metadata": {}, "mutation_prompt": null}
