{"id": "55cfa117-0495-48f3-bb96-c726bac3da8f", "solution": "import numpy as np\n\nclass EMO_DGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.grid_resolution = 20\n        self.grid = np.linspace(self.lower_bound, self.upper_bound, self.grid_resolution)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.budget, self.dim))\n        evaluations = 0\n\n        while evaluations < self.budget:\n            grid_counts = np.zeros((self.grid_resolution, self.dim))\n            for ind in population:\n                grid_indices = np.floor((ind - self.lower_bound) / ((self.upper_bound - self.lower_bound) / self.grid_resolution)).astype(int)\n                grid_indices = np.clip(grid_indices, 0, self.grid_resolution - 1)\n                grid_counts[tuple(grid_indices)] += 1\n\n            grid_densities = np.sum(grid_counts, axis=1)\n            new_population = []\n            for _ in range(self.budget):\n                selected_grid = np.random.choice(self.grid_resolution, p=grid_densities / np.sum(grid_densities))\n                selected_inds = np.where(np.all(np.floor((population - self.lower_bound) / ((self.upper_bound - self.lower_bound) / self.grid_resolution)).astype(int) == selected_grid, axis=1))[0]\n                selected_ind = population[np.random.choice(selected_inds)]\n                new_population.append(selected_ind + np.random.normal(0, 0.1, self.dim))\n\n            population = np.array(new_population)\n            evaluations += len(new_population)\n\n        return population[np.argmin([func(ind) for ind in population])]", "name": "EMO_DGA", "description": "Evolutionary Multi-Objective Optimization with Dynamic Grid Adaptation (EMO-DGA) algorithm that adapts the grid resolution based on the distribution of solutions in the search space.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 21, in __call__\nIndexError: too many indices for array: array is 2-dimensional, but 5 were indexed\n.", "error": "IndexError('too many indices for array: array is 2-dimensional, but 5 were indexed')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 21, in __call__\nIndexError: too many indices for array: array is 2-dimensional, but 5 were indexed\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "647b7078-0818-49dc-a91e-736c7ff48465", "solution": "import numpy as np\n\nclass EMO_DGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.grid_resolution = 20\n        self.grid = np.linspace(self.lower_bound, self.upper_bound, self.grid_resolution)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.budget, self.dim))\n        evaluations = 0\n\n        while evaluations < self.budget:\n            grid_counts = np.zeros((self.grid_resolution, self.dim))\n            for ind in population:\n                grid_indices = np.floor((ind - self.lower_bound) / ((self.upper_bound - self.lower_bound) / self.grid_resolution)).astype(int)\n                grid_indices = np.clip(grid_indices, 0, self.grid_resolution - 1)\n                grid_counts[tuple(grid_indices)] += 1\n\n            grid_densities = np.sum(grid_counts, axis=1)\n            new_population = []\n            for _ in range(self.budget):\n                selected_grid = np.random.choice(self.grid_resolution, p=grid_densities / np.sum(grid_densities))\n                selected_inds = np.where(np.all(np.floor((population - self.lower_bound) / ((self.upper_bound - self.lower_bound) / self.grid_resolution)).astype(int) == selected_grid, axis=1))[0]\n                selected_ind = population[np.random.choice(selected_inds)]\n                new_population.append(selected_ind + np.random.normal(0, 0.1, self.dim))\n\n            population = np.array(new_population)\n            evaluations += len(new_population)\n\n        return population[np.argmin([func(ind) for ind in population])]", "name": "EMO_DGA", "description": "Evolutionary Multi-Objective Optimization with Dynamic Grid Adaptation (EMO-DGA) algorithm that adapts the grid resolution based on the distribution of solutions in the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "55cfa117-0495-48f3-bb96-c726bac3da8f", "metadata": {}, "mutation_prompt": null}
