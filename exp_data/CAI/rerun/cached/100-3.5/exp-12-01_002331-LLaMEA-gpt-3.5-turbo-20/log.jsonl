{"id": "d0ae0ba4-99fd-4497-a29c-288339e0cfe3", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def __call__(self, func):\n        def initialize_harmony_memory(size):\n            return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n        \n        def adjust_bandwidth(hm, bw):\n            return hm + np.random.uniform(-bw, bw, hm.shape)\n        \n        def evaluate_solution(solution, func):\n            return func(solution)\n        \n        def update_harmony_memory(hm, new_solution, new_fitness):\n            idx = np.argmax(hm_fitness)\n            if new_fitness < hm_fitness[idx]:\n                hm[idx] = new_solution\n                hm_fitness[idx] = new_fitness\n        \n        harmony_memory = initialize_harmony_memory(10)\n        hm_fitness = np.array([evaluate_solution(solution, func) for solution in harmony_memory])\n        bandwidth = 1.0\n        \n        for _ in range(self.budget - 10):\n            new_solution = adjust_bandwidth(harmony_memory, bandwidth)\n            new_fitness = evaluate_solution(new_solution, func)\n            update_harmony_memory(harmony_memory, new_solution, new_fitness)\n            bandwidth *= 0.9  # Decrease bandwidth over iterations\n        \n        best_idx = np.argmin(hm_fitness)\n        return harmony_memory[best_idx]", "name": "HarmonySearch", "description": "Harmony Search Algorithm with Dynamic Bandwidth Adjustment for Black Box Optimization on BBOB test suite.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 33, in __call__\n  File \"<string>\", line 22, in update_harmony_memory\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n.", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 33, in __call__\n  File \"<string>\", line 22, in update_harmony_memory\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "aaa526ec-abeb-413e-a79a-87e6e257796a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n    def __call__(self, func):\n        def initialize_harmony_memory(size):\n            return np.random.uniform(self.lower_bound, self.upper_bound, (size, self.dim))\n        \n        def adjust_bandwidth(hm, bw):\n            return hm + np.random.uniform(-bw, bw, hm.shape)\n        \n        def evaluate_solution(solution, func):\n            return func(solution)\n        \n        def update_harmony_memory(hm, new_solution, new_fitness):\n            idx = np.argmax(hm_fitness)\n            if new_fitness < hm_fitness[idx]:\n                hm[idx] = new_solution\n                hm_fitness[idx] = new_fitness\n        \n        harmony_memory = initialize_harmony_memory(10)\n        hm_fitness = np.array([evaluate_solution(solution, func) for solution in harmony_memory])\n        bandwidth = 1.0\n        \n        for _ in range(self.budget - 10):\n            new_solution = adjust_bandwidth(harmony_memory, bandwidth)\n            new_fitness = evaluate_solution(new_solution, func)\n            update_harmony_memory(harmony_memory, new_solution, new_fitness)\n            bandwidth *= 0.9  # Decrease bandwidth over iterations\n        \n        best_idx = np.argmin(hm_fitness)\n        return harmony_memory[best_idx]", "name": "HarmonySearch", "description": "Harmony Search Algorithm with Dynamic Bandwidth Adjustment for Black Box Optimization on BBOB test suite.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d0ae0ba4-99fd-4497-a29c-288339e0cfe3", "metadata": {}, "mutation_prompt": null}
