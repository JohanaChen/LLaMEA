{"id": "4a5e1631-9631-4a89-85ea-8a34794bbcf5", "solution": "import numpy as np\n\nclass DE_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10\n        self.cr = 0.9\n        self.f = 0.8\n        self.Tmax = 1.0\n        self.Tmin = 1e-5\n        self.alpha = 0.9\n\n    def __call__(self, func):\n        def mutate(x, pop, f):\n            a, b, c = np.random.choice(pop, 3, replace=False)\n            mutant = np.clip(a + f * (b - c), -5.0, 5.0)\n            return mutant\n\n        def annealing_acceptance(x, new_x, temp):\n            if func(new_x) < func(x) or np.random.rand() < np.exp((func(x) - func(new_x)) / temp):\n                return new_x\n            else:\n                return x\n\n        def annealing_schedule(t):\n            return self.Tmax * (self.alpha**t)\n\n        pop = np.random.uniform(-5.0, 5.0, (self.pop_size, self.dim))\n        best_solution = pop[np.argmin([func(x) for x in pop])]\n        t = 0\n        while t < self.budget:\n            new_pop = []\n            for x in pop:\n                mutant = mutate(x, pop, self.f)\n                new_x = annealing_acceptance(x, mutant, annealing_schedule(t))\n                new_pop.append(new_x)\n                t += 1\n                if t >= self.budget:\n                    break\n            pop = np.array(new_pop)\n            best_solution = pop[np.argmin([func(x) for x in pop])]\n        return best_solution", "name": "DE_SA_Optimizer", "description": "A novel metaheuristic algorithm combining Differential Evolution and Simulated Annealing for black box optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 35, in __call__\n  File \"<string>\", line 16, in mutate\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n.", "error": "ValueError('a must be 1-dimensional')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 35, in __call__\n  File \"<string>\", line 16, in mutate\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "1ef5466e-2d17-4214-b8bd-ee1f2e4c6aca", "solution": "import numpy as np\n\nclass DE_SA_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.cr = 0.9\n        self.f = 0.8\n        self.Tmax = 1.0\n        self.Tmin = 1e-5\n        self.alpha = 0.9\n\n    def __call__(self, func):\n        def mutate(x, pop, f):\n            a, b, c = np.random.choice(pop, 3, replace=False)\n            mutant = np.clip(a + f * (b - c), -5.0, 5.0)\n            return mutant\n\n        def annealing_acceptance(x, new_x, temp):\n            if func(new_x) < func(x) or np.random.rand() < np.exp((func(x) - func(new_x)) / temp):\n                return new_x\n            else:\n                return x\n\n        def annealing_schedule(t):\n            return self.Tmax * (self.alpha**t)\n\n        pop_size = 10  # Dynamic population size adaptation\n        pop = np.random.uniform(-5.0, 5.0, (pop_size, self.dim))\n        best_solution = pop[np.argmin([func(x) for x in pop)]\n        t = 0\n        while t < self.budget:\n            new_pop = []\n            for x in pop:\n                mutant = mutate(x, pop, self.f)\n                new_x = annealing_acceptance(x, mutant, annealing_schedule(t))\n                new_pop.append(new_x)\n                t += 1\n                if t >= self.budget:\n                    break\n            pop = np.array(new_pop)\n            best_solution = pop[np.argmin([func(x) for x in pop])]\n        return best_solution", "name": "DE_SA_Optimizer", "description": "Improved DE_SA_Optimizer algorithm with dynamic population size adaptation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: SyntaxError(\"closing parenthesis ')' does not match opening parenthesis '['\", ('<string>', 30, 60, '        best_solution = pop[np.argmin([func(x) for x in pop)]')).", "error": "SyntaxError(\"closing parenthesis ')' does not match opening parenthesis '['\", ('<string>', 30, 60, '        best_solution = pop[np.argmin([func(x) for x in pop)]'))", "parent_id": "4a5e1631-9631-4a89-85ea-8a34794bbcf5", "metadata": {}, "mutation_prompt": null}
