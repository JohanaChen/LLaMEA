{"id": "cb7d888d-7bf5-49d1-af4a-5d550477618e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, max(10, dim * 5))  # Dynamic population size\n        self.mutation_strategy = 'rand/1/bin'  # Initial mutation strategy\n        self.CR = 0.9  # Crossover probability\n        self.F = 0.8  # Differential weight\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Select mutation strategy based on remaining budget\n                if eval_count / self.budget < 0.5:\n                    self.mutation_strategy = 'rand/1/bin'\n                else:\n                    self.mutation_strategy = 'best/1/bin'\n\n                # Mutation and crossover\n                if self.mutation_strategy == 'rand/1/bin':\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant_vector = a + self.F * (b - c)\n                else:  # 'best/1/bin'\n                    best_idx = np.argmin(fitness)\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant_vector = population[best_idx] + self.F * (a - b)\n\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                # Dynamic adjustment of CR and F\n                if eval_count % (self.budget // 10) == 0:\n                    self.CR = np.random.uniform(0.5, 1.0)\n                    self.F = np.random.uniform(0.5, 1.0)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm with dynamic population resizing and mutation strategies tailored for efficient exploration and exploitation in black-box optimization.", "configspace": "", "generation": 0, "fitness": 0.44488162501087924, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.8387156958434012, 0.8387156958434012, 0.8387156958434012, 0.8427743583106211, 0.8427743583106211, 0.8427743583106211, 0.8577756852147989, 0.8577756852147989, 0.8577756852147989, 0.7489138995343683, 0.7489138995343683, 0.7489138995343683, 0.7351653198122285, 0.7351653198122285, 0.7351653198122285, 0.7503803561967293, 0.7503803561967293, 0.7503803561967293, 0.1472902409215161, 0.1472902409215161, 0.1472902409215161, 0.15085379909546304, 0.15085379909546304, 0.15085379909546304, 0.509257289462109, 0.509257289462109, 0.509257289462109, 0.12151409740302099, 0.12151409740302099, 0.12151409740302099, 0.46812555995491945, 0.46812555995491945, 0.46812555995491945, 0.14940466732970048, 0.14940466732970048, 0.14940466732970048, 0.9399862095832204, 0.9399862095832204, 0.9399862095832204, 0.9689584930856736, 0.9689584930856736, 0.9689584930856736, 0.9661946411218758, 0.9661946411218758, 0.9661946411218758, 0.6232734520367845, 0.6232734520367845, 0.6232734520367845, 0.6363195368148212, 0.6363195368148212, 0.6363195368148212, 0.6758319099348893, 0.6758319099348893, 0.6758319099348893, 0.8495390110779708, 0.8495390110779708, 0.8495390110779708, 0.8672627348458914, 0.8672627348458914, 0.8672627348458914, 0.7881971254852447, 0.7881971254852447, 0.7881971254852447, 0.4766228346064838, 0.4766228346064838, 0.4766228346064838, 0.509030414919776, 0.509030414919776, 0.509030414919776, 0.3869967288513373, 0.3869967288513373, 0.3869967288513373, 0.42442550637700127, 0.42442550637700127, 0.42442550637700127, 0.43701214404520294, 0.43701214404520294, 0.43701214404520294, 0.43454681917810045, 0.43454681917810045, 0.43454681917810045, 0.4978253399672501, 0.4978253399672501, 0.4978253399672501, 0.4881707530190278, 0.4881707530190278, 0.4881707530190278, 0.551793428738238, 0.551793428738238, 0.551793428738238, 0.6328412515613213, 0.6328412515613213, 0.6328412515613213, 0.6061144554805664, 0.6061144554805664, 0.6061144554805664, 0.6218547142296382, 0.6218547142296382, 0.6218547142296382, 0.23908088141481043, 0.23908088141481043, 0.23908088141481043, 0.22687608671975534, 0.22687608671975534, 0.22687608671975534, 0.2800786617674259, 0.2800786617674259, 0.2800786617674259, 0.3690367506807851, 0.3690367506807851, 0.3690367506807851, 0.42740226410087956, 0.42740226410087956, 0.42740226410087956, 0.3776811031165874, 0.3776811031165874, 0.3776811031165874, 0.7571755172674004, 0.7571755172674004, 0.7571755172674004, 0.7332306928108068, 0.7332306928108068, 0.7332306928108068, 0.7644294275606883, 0.7644294275606883, 0.7644294275606883, 0.1032501085063734, 0.1032501085063734, 0.1032501085063734, 0.11948923994712912, 0.11948923994712912, 0.11948923994712912, 0.11737445754459874, 0.11737445754459874, 0.11737445754459874, 0.15798494623765436, 0.15798494623765436, 0.15798494623765436, 0.15101770780902102, 0.15101770780902102, 0.15101770780902102, 0.23130059244008605, 0.23130059244008605, 0.23130059244008605, 0.4824240822650172, 0.4824240822650172, 0.4824240822650172, 0.4227164703402323, 0.4227164703402323, 0.4227164703402323, 0.4589770007837276, 0.4589770007837276, 0.4589770007837276, 0.2956616855880708, 0.2956616855880708, 0.2956616855880708, 0.2997403751091148, 0.2997403751091148, 0.2997403751091148, 0.333266951039741, 0.333266951039741, 0.333266951039741, 0.17563081249361845, 0.17563081249361845, 0.17563081249361845, 0.19233563688712152, 0.19233563688712152, 0.19233563688712152, 0.2042737606037046, 0.2042737606037046, 0.2042737606037046, 0.461122461844072, 0.461122461844072, 0.461122461844072, 0.4022499666910979, 0.4022499666910979, 0.4022499666910979, 0.41707334904860216, 0.41707334904860216, 0.41707334904860216, 0.8696789944639611, 0.8696789944639611, 0.8696789944639611, 0.19493271778894128, 0.19493271778894128, 0.19493271778894128, 0.15945564938426082, 0.15945564938426082, 0.15945564938426082, 0.7384857924385548, 0.7384857924385548, 0.7384857924385548, 0.19972812148897023, 0.19972812148897023, 0.19972812148897023, 0.19796795806879486, 0.19796795806879486, 0.19796795806879486, 0.1919952072275657, 0.1919952072275657, 0.1919952072275657, 0.16210856231086235, 0.16210856231086235, 0.16210856231086235, 0.1631459512873391, 0.1631459512873391, 0.1631459512873391, 0.08259266928286157, 0.08259266928286157, 0.08259266928286157, 0.07889290653733383, 0.07889290653733383, 0.07889290653733383, 0.08864300584654561, 0.08864300584654561, 0.08864300584654561]}, "mutation_prompt": null}
{"id": "25e1b718-0156-4557-ad9e-ac1c675dc10e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, max(10, dim * 5))  # Dynamic population size\n        self.mutation_strategy = 'rand/1/bin'  # Initial mutation strategy\n        self.CR = 0.9  # Crossover probability\n        self.F = 0.8  # Differential weight\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Select mutation strategy based on remaining budget\n                if eval_count / self.budget < 0.5:\n                    self.mutation_strategy = 'rand/1/bin'\n                else:\n                    self.mutation_strategy = 'best/1/bin'\n\n                # Mutation and crossover\n                if self.mutation_strategy == 'rand/1/bin':\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = population[indices]\n                    mutant_vector = a + self.F * (b - c)\n                else:  # 'best/1/bin'\n                    best_idx = np.argmin(fitness)\n                    indices = np.random.choice(self.population_size, 2, replace=False)\n                    a, b = population[indices]\n                    mutant_vector = population[best_idx] + self.F * (a - b)\n\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                # Dynamic adjustment of CR and F\n                if eval_count % (self.budget // 10) == 0:\n                    self.CR = np.random.uniform(0.5, 1.0)\n                    self.F = np.random.uniform(0.5, 1.0)\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm with dynamic population resizing and mutation strategies tailored for efficient exploration and exploitation in black-box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cb7d888d-7bf5-49d1-af4a-5d550477618e", "metadata": {"aucs": [0.8387156958434012, 0.8387156958434012, 0.8387156958434012, 0.8427743583106211, 0.8427743583106211, 0.8427743583106211, 0.8577756852147989, 0.8577756852147989, 0.8577756852147989, 0.7489138995343683, 0.7489138995343683, 0.7489138995343683, 0.7351653198122285, 0.7351653198122285, 0.7351653198122285, 0.7503803561967293, 0.7503803561967293, 0.7503803561967293, 0.1472902409215161, 0.1472902409215161, 0.1472902409215161, 0.15085379909546304, 0.15085379909546304, 0.15085379909546304, 0.509257289462109, 0.509257289462109, 0.509257289462109, 0.12151409740302099, 0.12151409740302099, 0.12151409740302099, 0.46812555995491945, 0.46812555995491945, 0.46812555995491945, 0.14940466732970048, 0.14940466732970048, 0.14940466732970048, 0.9399862095832204, 0.9399862095832204, 0.9399862095832204, 0.9689584930856736, 0.9689584930856736, 0.9689584930856736, 0.9661946411218758, 0.9661946411218758, 0.9661946411218758, 0.6232734520367845, 0.6232734520367845, 0.6232734520367845, 0.6363195368148212, 0.6363195368148212, 0.6363195368148212, 0.6758319099348893, 0.6758319099348893, 0.6758319099348893, 0.8495390110779708, 0.8495390110779708, 0.8495390110779708, 0.8672627348458914, 0.8672627348458914, 0.8672627348458914, 0.7881971254852447, 0.7881971254852447, 0.7881971254852447, 0.4766228346064838, 0.4766228346064838, 0.4766228346064838, 0.509030414919776, 0.509030414919776, 0.509030414919776, 0.3869967288513373, 0.3869967288513373, 0.3869967288513373, 0.42442550637700127, 0.42442550637700127, 0.42442550637700127, 0.43701214404520294, 0.43701214404520294, 0.43701214404520294, 0.43454681917810045, 0.43454681917810045, 0.43454681917810045, 0.4978253399672501, 0.4978253399672501, 0.4978253399672501, 0.4881707530190278, 0.4881707530190278, 0.4881707530190278, 0.551793428738238, 0.551793428738238, 0.551793428738238, 0.6328412515613213, 0.6328412515613213, 0.6328412515613213, 0.6061144554805664, 0.6061144554805664, 0.6061144554805664, 0.6218547142296382, 0.6218547142296382, 0.6218547142296382, 0.23908088141481043, 0.23908088141481043, 0.23908088141481043, 0.22687608671975534, 0.22687608671975534, 0.22687608671975534, 0.2800786617674259, 0.2800786617674259, 0.2800786617674259, 0.3690367506807851, 0.3690367506807851, 0.3690367506807851, 0.42740226410087956, 0.42740226410087956, 0.42740226410087956, 0.3776811031165874, 0.3776811031165874, 0.3776811031165874, 0.7571755172674004, 0.7571755172674004, 0.7571755172674004, 0.7332306928108068, 0.7332306928108068, 0.7332306928108068, 0.7644294275606883, 0.7644294275606883, 0.7644294275606883, 0.1032501085063734, 0.1032501085063734, 0.1032501085063734, 0.11948923994712912, 0.11948923994712912, 0.11948923994712912, 0.11737445754459874, 0.11737445754459874, 0.11737445754459874, 0.15798494623765436, 0.15798494623765436, 0.15798494623765436, 0.15101770780902102, 0.15101770780902102, 0.15101770780902102, 0.23130059244008605, 0.23130059244008605, 0.23130059244008605, 0.4824240822650172, 0.4824240822650172, 0.4824240822650172, 0.4227164703402323, 0.4227164703402323, 0.4227164703402323, 0.4589770007837276, 0.4589770007837276, 0.4589770007837276, 0.2956616855880708, 0.2956616855880708, 0.2956616855880708, 0.2997403751091148, 0.2997403751091148, 0.2997403751091148, 0.333266951039741, 0.333266951039741, 0.333266951039741, 0.17563081249361845, 0.17563081249361845, 0.17563081249361845, 0.19233563688712152, 0.19233563688712152, 0.19233563688712152, 0.2042737606037046, 0.2042737606037046, 0.2042737606037046, 0.461122461844072, 0.461122461844072, 0.461122461844072, 0.4022499666910979, 0.4022499666910979, 0.4022499666910979, 0.41707334904860216, 0.41707334904860216, 0.41707334904860216, 0.8696789944639611, 0.8696789944639611, 0.8696789944639611, 0.19493271778894128, 0.19493271778894128, 0.19493271778894128, 0.15945564938426082, 0.15945564938426082, 0.15945564938426082, 0.7384857924385548, 0.7384857924385548, 0.7384857924385548, 0.19972812148897023, 0.19972812148897023, 0.19972812148897023, 0.19796795806879486, 0.19796795806879486, 0.19796795806879486, 0.1919952072275657, 0.1919952072275657, 0.1919952072275657, 0.16210856231086235, 0.16210856231086235, 0.16210856231086235, 0.1631459512873391, 0.1631459512873391, 0.1631459512873391, 0.08259266928286157, 0.08259266928286157, 0.08259266928286157, 0.07889290653733383, 0.07889290653733383, 0.07889290653733383, 0.08864300584654561, 0.08864300584654561, 0.08864300584654561]}, "mutation_prompt": null}
