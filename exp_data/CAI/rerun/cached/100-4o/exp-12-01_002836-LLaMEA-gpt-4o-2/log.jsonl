{"id": "4c9d2306-5fec-4164-a895-c9762bbdf454", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.CR = 0.9\n        self.F = 0.8\n        self.history_CR = [self.CR]\n        self.history_F = [self.F]\n        self.memory_size = 5\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        \n        eval_count = self.population_size\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index]\n        best_fitness = fitness[best_index]\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and Crossover\n                idxs = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                mutant_vector = population[idxs[0]] + self.F * (population[idxs[1]] - population[idxs[2]])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial_vector\n                        best_fitness = trial_fitness\n\n                    # Adapt CR and F\n                    self.history_CR.append(self.CR)\n                    self.history_F.append(self.F)\n\n                    if len(self.history_CR) > self.memory_size:\n                        del self.history_CR[0]\n                    if len(self.history_F) > self.memory_size:\n                        del self.history_F[0]\n\n                    if np.random.rand() < 0.5:\n                        self.CR = np.mean(self.history_CR) + np.std(self.history_CR) * np.random.randn()\n                        self.CR = np.clip(self.CR, 0, 1)\n                    else:\n                        self.F = np.mean(self.history_F) + np.std(self.history_F) * np.random.randn()\n                        self.F = np.clip(self.F, 0, 2)\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution, best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Parameters for Efficient Global Search.", "configspace": "", "generation": 0, "fitness": 0.2717673849183803, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.6698312028009167, 0.5769125581824439, 0.6293208964620642, 0.6947004350384525, 0.6371411950541257, 0.6474835128939349, 0.6284194206239397, 0.6443445211351999, 0.6367915034496776, 0.4198854324482819, 0.38875390432102963, 0.3641512636981633, 0.36293805047727545, 0.40711792809544567, 0.3917684936432373, 0.3883188459567265, 0.3640354823247628, 0.40057179202550586, 0.10404549019676745, 0.10005036622374752, 0.10122063856364771, 0.09986776580995116, 0.10644728711641549, 0.10464491460021619, 0.09494150420653591, 0.11037027316408166, 0.09766220546606541, 0.08591154636036391, 0.07580155322218796, 0.09965340439775938, 0.09197920995617026, 0.08831041769845727, 0.08035535203612709, 0.08321273080248248, 0.08519247254451023, 0.07492911085521226, 0.9461315215064545, 0.9235993210786332, 0.9368163085667786, 0.9240512347599379, 0.9692802637556303, 0.9672624114180879, 0.9264936816083903, 0.938142224531006, 0.9830852959017973, 0.26838214807525285, 0.26342899440525913, 0.27235796352979724, 0.26840333873815736, 0.28055876691947657, 0.27714766818958647, 0.3069866865191242, 0.3031168151096807, 0.2990498831272199, 0.47317761186334406, 0.5203194289790701, 0.5536437342756326, 0.5221545685018764, 0.5953472248816243, 0.49354433202278036, 0.5224831618446528, 0.5392116697375275, 0.5236013155291136, 0.22032496826244774, 0.18897531895989883, 0.2125264773108977, 0.1941513867044824, 0.20993484608041557, 0.20929498276104186, 0.20717285774275052, 0.15597744880215325, 0.17617575920962447, 0.2446381269641219, 0.2891326952840698, 0.20857401558056132, 0.17509455152547848, 0.21520388659191303, 0.19516648274228532, 0.18076627090057973, 0.19771357765720787, 0.21490847282506642, 0.10783303200846117, 0.1425909683474672, 0.12672431522867067, 0.14514625354679844, 0.12432612422479539, 0.10670774650792014, 0.14928389447684676, 0.11360750918047546, 0.1353804824402428, 0.21465993250579762, 0.31163811095892413, 0.26914301941435737, 0.2633302804261385, 0.2896543860509878, 0.25724626366633985, 0.30287955227210084, 0.30191442493149245, 0.27964104021225766, 0.020360061023206977, 0.027043819019931248, 0.03496537839171565, 0.024766007989556083, 0.028442995027152418, 0.03259516614347613, 0.031923631693051124, 0.08651867198787389, 0.024884608212460968, 0.15721570726885492, 0.15448769150985586, 0.15583024903158582, 0.14410353768843054, 0.15076237014248706, 0.1725258876293969, 0.1711381763544434, 0.1703790787059838, 0.1653908078273838, 0.49888999674338674, 0.486047292475113, 0.5066974590096114, 0.480675330501089, 0.5015528511353528, 0.5116709493820892, 0.4805071828183711, 0.4765144077557246, 0.4725133166041544, 0.0855615806103428, 0.08887325011573688, 0.0899116324863255, 0.09172416995416166, 0.07322921086355472, 0.07499176005090435, 0.0752836895881539, 0.09059200157818126, 0.0904577230432917, 0.1292841943340476, 0.15145047978958703, 0.1476788302624218, 0.20766077475569522, 0.1558360282663218, 0.13418826234369063, 0.16626167127230707, 0.1804478638960394, 0.15755920679068935, 0.2670692092685406, 0.25683368466130807, 0.2676972648210826, 0.273586092035246, 0.24792481067182448, 0.28633755582496756, 0.27719166693192776, 0.30498918626621907, 0.2917534952034676, 0.19651286156678927, 0.21311314579212504, 0.21464856467661952, 0.19670386755366775, 0.19154927668966826, 0.18466749707320018, 0.21806501461348982, 0.2156860290031528, 0.2134025857423375, 0.18061344906500276, 0.18209923115360493, 0.17765128997412483, 0.19621761080539513, 0.1958646641488252, 0.17167959453510173, 0.19252979719724994, 0.18377771549320476, 0.18201413480153505, 0.17340191038239094, 0.17761709100042922, 0.1809189666211235, 0.18408240149896415, 0.17676917709905338, 0.17824488513975134, 0.17937417599975602, 0.18068807737787518, 0.17799633801087622, 0.658639745397686, 0.6352213451257502, 0.16091757789044148, 0.17711927622234092, 0.41408108866060256, 0.5340318811172404, 0.43506966105512634, 0.5978714735746031, 0.17410972973294936, 0.1937713270352217, 0.19736444105906126, 0.16202212979980957, 0.4043141488301878, 0.19170458825185177, 0.40680155230674, 0.6622301834398993, 0.20576237318324198, 0.1999041747124184, 0.1799595930475052, 0.1789020344708543, 0.1841197162165389, 0.1780540035392174, 0.18699380251213438, 0.1756605795455607, 0.1797117885195001, 0.1870531701305873, 0.18691839178199776, 0.07289762427488844, 0.06771197680702512, 0.0711101717041811, 0.07006422553150349, 0.06872191894141833, 0.0751053678317839, 0.06833661131414015, 0.07255332455440566, 0.06597714394580745]}, "mutation_prompt": null}
{"id": "2e63b0d8-f3ab-4de2-94b1-75683ace1432", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.CR = 0.9\n        self.F = 0.8\n        self.history_CR = [self.CR]\n        self.history_F = [self.F]\n        self.memory_size = 5\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        \n        eval_count = self.population_size\n        best_index = np.argmin(fitness)\n        best_solution = population[best_index]\n        best_fitness = fitness[best_index]\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation and Crossover\n                idxs = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                mutant_vector = population[idxs[0]] + self.F * (population[idxs[1]] - population[idxs[2]])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                eval_count += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_solution = trial_vector\n                        best_fitness = trial_fitness\n\n                    # Adapt CR and F\n                    self.history_CR.append(self.CR)\n                    self.history_F.append(self.F)\n\n                    if len(self.history_CR) > self.memory_size:\n                        del self.history_CR[0]\n                    if len(self.history_F) > self.memory_size:\n                        del self.history_F[0]\n\n                    if np.random.rand() < 0.5:\n                        self.CR = np.mean(self.history_CR) + np.std(self.history_CR) * np.random.randn()\n                        self.CR = np.clip(self.CR, 0, 1)\n                    else:\n                        self.F = np.mean(self.history_F) + np.std(self.history_F) * np.random.randn()\n                        self.F = np.clip(self.F, 0, 2)\n\n                if eval_count >= self.budget:\n                    break\n\n        return best_solution, best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Parameters for Efficient Global Search.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4c9d2306-5fec-4164-a895-c9762bbdf454", "metadata": {"aucs": [0.6698312028009167, 0.5769125581824439, 0.6293208964620642, 0.6947004350384525, 0.6371411950541257, 0.6474835128939349, 0.6284194206239397, 0.6443445211351999, 0.6367915034496776, 0.4198854324482819, 0.38875390432102963, 0.3641512636981633, 0.36293805047727545, 0.40711792809544567, 0.3917684936432373, 0.3883188459567265, 0.3640354823247628, 0.40057179202550586, 0.10404549019676745, 0.10005036622374752, 0.10122063856364771, 0.09986776580995116, 0.10644728711641549, 0.10464491460021619, 0.09494150420653591, 0.11037027316408166, 0.09766220546606541, 0.08591154636036391, 0.07580155322218796, 0.09965340439775938, 0.09197920995617026, 0.08831041769845727, 0.08035535203612709, 0.08321273080248248, 0.08519247254451023, 0.07492911085521226, 0.9461315215064545, 0.9235993210786332, 0.9368163085667786, 0.9240512347599379, 0.9692802637556303, 0.9672624114180879, 0.9264936816083903, 0.938142224531006, 0.9830852959017973, 0.26838214807525285, 0.26342899440525913, 0.27235796352979724, 0.26840333873815736, 0.28055876691947657, 0.27714766818958647, 0.3069866865191242, 0.3031168151096807, 0.2990498831272199, 0.47317761186334406, 0.5203194289790701, 0.5536437342756326, 0.5221545685018764, 0.5953472248816243, 0.49354433202278036, 0.5224831618446528, 0.5392116697375275, 0.5236013155291136, 0.22032496826244774, 0.18897531895989883, 0.2125264773108977, 0.1941513867044824, 0.20993484608041557, 0.20929498276104186, 0.20717285774275052, 0.15597744880215325, 0.17617575920962447, 0.2446381269641219, 0.2891326952840698, 0.20857401558056132, 0.17509455152547848, 0.21520388659191303, 0.19516648274228532, 0.18076627090057973, 0.19771357765720787, 0.21490847282506642, 0.10783303200846117, 0.1425909683474672, 0.12672431522867067, 0.14514625354679844, 0.12432612422479539, 0.10670774650792014, 0.14928389447684676, 0.11360750918047546, 0.1353804824402428, 0.21465993250579762, 0.31163811095892413, 0.26914301941435737, 0.2633302804261385, 0.2896543860509878, 0.25724626366633985, 0.30287955227210084, 0.30191442493149245, 0.27964104021225766, 0.020360061023206977, 0.027043819019931248, 0.03496537839171565, 0.024766007989556083, 0.028442995027152418, 0.03259516614347613, 0.031923631693051124, 0.08651867198787389, 0.024884608212460968, 0.15721570726885492, 0.15448769150985586, 0.15583024903158582, 0.14410353768843054, 0.15076237014248706, 0.1725258876293969, 0.1711381763544434, 0.1703790787059838, 0.1653908078273838, 0.49888999674338674, 0.486047292475113, 0.5066974590096114, 0.480675330501089, 0.5015528511353528, 0.5116709493820892, 0.4805071828183711, 0.4765144077557246, 0.4725133166041544, 0.0855615806103428, 0.08887325011573688, 0.0899116324863255, 0.09172416995416166, 0.07322921086355472, 0.07499176005090435, 0.0752836895881539, 0.09059200157818126, 0.0904577230432917, 0.1292841943340476, 0.15145047978958703, 0.1476788302624218, 0.20766077475569522, 0.1558360282663218, 0.13418826234369063, 0.16626167127230707, 0.1804478638960394, 0.15755920679068935, 0.2670692092685406, 0.25683368466130807, 0.2676972648210826, 0.273586092035246, 0.24792481067182448, 0.28633755582496756, 0.27719166693192776, 0.30498918626621907, 0.2917534952034676, 0.19651286156678927, 0.21311314579212504, 0.21464856467661952, 0.19670386755366775, 0.19154927668966826, 0.18466749707320018, 0.21806501461348982, 0.2156860290031528, 0.2134025857423375, 0.18061344906500276, 0.18209923115360493, 0.17765128997412483, 0.19621761080539513, 0.1958646641488252, 0.17167959453510173, 0.19252979719724994, 0.18377771549320476, 0.18201413480153505, 0.17340191038239094, 0.17761709100042922, 0.1809189666211235, 0.18408240149896415, 0.17676917709905338, 0.17824488513975134, 0.17937417599975602, 0.18068807737787518, 0.17799633801087622, 0.658639745397686, 0.6352213451257502, 0.16091757789044148, 0.17711927622234092, 0.41408108866060256, 0.5340318811172404, 0.43506966105512634, 0.5978714735746031, 0.17410972973294936, 0.1937713270352217, 0.19736444105906126, 0.16202212979980957, 0.4043141488301878, 0.19170458825185177, 0.40680155230674, 0.6622301834398993, 0.20576237318324198, 0.1999041747124184, 0.1799595930475052, 0.1789020344708543, 0.1841197162165389, 0.1780540035392174, 0.18699380251213438, 0.1756605795455607, 0.1797117885195001, 0.1870531701305873, 0.18691839178199776, 0.07289762427488844, 0.06771197680702512, 0.0711101717041811, 0.07006422553150349, 0.06872191894141833, 0.0751053678317839, 0.06833661131414015, 0.07255332455440566, 0.06597714394580745]}, "mutation_prompt": null}
