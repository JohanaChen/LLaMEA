{"id": "3ebd6728-e34a-48eb-bb85-31dd8db4ada8", "solution": "import numpy as np\n\nclass HybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(4, int(self.budget / (10 * dim)))  # Dynamically adjust population size\n        self.population = np.random.uniform(-5, 5, (self.pop_size, dim))\n        self.sigma = 0.3\n        self.weights = np.log(self.pop_size / 2 + 0.5) - np.log(np.arange(1, self.pop_size + 1))\n        self.weights /= self.weights.sum()\n        self.mu_eff = 1 / np.sum(self.weights**2)\n        self.cov_matrix = np.eye(dim)\n        self.pc = np.zeros(dim)\n        self.ps = np.zeros(dim)\n        self.cs = (self.mu_eff + 2) / (dim + self.mu_eff + 3)\n        self.convergence_criterion = 10 - min(1e-6, 1 / dim)\n    \n    def __call__(self, func):\n        count_evals = 0\n        population_values = np.array([func(ind) for ind in self.population])\n        count_evals += self.pop_size\n        \n        while count_evals < self.budget:\n            # Differential Evolution mutation and crossover\n            indices = np.random.permutation(self.pop_size)\n            for i in range(self.pop_size):\n                if count_evals >= self.budget:\n                    break\n                x1, x2, x3 = self.population[indices[i]], self.population[indices[(i+1) % self.pop_size]], self.population[indices[(i+2) % self.pop_size]]\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, -5, 5)\n                cross_points = np.random.rand(self.dim) < 0.9\n                trial = np.where(cross_points, mutant, self.population[i])\n                trial_value = func(trial)\n                count_evals += 1\n                if trial_value < population_values[i]:\n                    self.population[i] = trial\n                    population_values[i] = trial_value\n            \n            # CMA-ES strategy for adaptation\n            best_indices = np.argsort(population_values)\n            self.population = self.population[best_indices]\n            population_values = population_values[best_indices]\n            mean = np.dot(self.weights, self.population[:self.mu_eff])\n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mu_eff) * np.dot(np.linalg.inv(self.cov_matrix), mean - self.population[0])\n            self.pc = (1 - self.cs) * self.pc + np.sqrt(self.cs * (2 - self.cs) * self.mu_eff) * (mean - self.population[0])\n            self.cov_matrix = (1 - self.cs) * self.cov_matrix + self.cs * np.outer(self.pc, self.pc)\n            \n            if np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * count_evals / self.pop_size)) < self.convergence_criterion:\n                self.sigma *= np.exp(0.2 + self.cs * (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * count_evals / self.pop_size)) - 1))\n            \n            # Sample new population\n            for i in range(self.pop_size):\n                if count_evals >= self.budget:\n                    break\n                self.population[i] = np.random.multivariate_normal(mean, self.sigma**2 * self.cov_matrix)\n                np.clip(self.population[i], -5, 5, out=self.population[i])\n                population_values[i] = func(self.population[i])\n                count_evals += 1\n        return self.population[np.argmin(population_values)]", "name": "HybridDE_CMA", "description": "A hybrid Differential Evolution and Covariance Matrix Adaptation strategy to exploit global and local search capabilities for efficient optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 45, in __call__\nTypeError: slice indices must be integers or None or have an __index__ method\n.", "error": "TypeError('slice indices must be integers or None or have an __index__ method')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 45, in __call__\nTypeError: slice indices must be integers or None or have an __index__ method\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "1a2c1417-6636-4bfc-a520-e878b5510e8e", "solution": "import numpy as np\n\nclass EnhancedHybridDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(4, int(self.budget / (10 * dim)))\n        self.population = np.random.uniform(-5, 5, (self.pop_size, dim))\n        self.sigma = 0.3\n        self.weights = np.log(self.pop_size / 2 + 0.5) - np.log(np.arange(1, self.pop_size + 1))\n        self.weights /= self.weights.sum()\n        self.mu_eff = 1 / np.sum(self.weights**2)\n        self.cov_matrix = np.eye(dim)\n        self.pc = np.zeros(dim)\n        self.ps = np.zeros(dim)\n        self.cs = (self.mu_eff + 2) / (dim + self.mu_eff + 3)\n        self.convergence_criterion = 10 - min(1e-6, 1 / dim)\n    \n    def __call__(self, func):\n        count_evals = 0\n        population_values = np.array([func(ind) for ind in self.population])\n        count_evals += self.pop_size\n        \n        while count_evals < self.budget:\n            indices = np.random.permutation(self.pop_size)\n            for i in range(self.pop_size):\n                if count_evals >= self.budget:\n                    break\n                x1, x2, x3 = self.population[indices[i]], self.population[indices[(i+1) % self.pop_size]], self.population[indices[(i+2) % self.pop_size]]\n                scale_factor = np.random.uniform(0.5, 1.0)  # Adaptive mutation scaling\n                mutant = x1 + scale_factor * (x2 - x3)\n                mutant = np.clip(mutant, -5, 5)\n                cross_points = np.random.rand(self.dim) < 0.9\n                trial = np.where(cross_points, mutant, self.population[i])\n                trial_value = func(trial)\n                count_evals += 1\n                if trial_value < population_values[i]:\n                    self.population[i] = trial\n                    population_values[i] = trial_value\n            \n            best_indices = np.argsort(population_values)\n            self.population = self.population[best_indices[:self.mu_eff]]  # Select top mu_eff individuals\n            population_values = population_values[best_indices[:self.mu_eff]]\n            mean = np.dot(self.weights, self.population)\n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mu_eff) * np.dot(np.linalg.inv(self.cov_matrix), mean - self.population[0])\n            self.pc = (1 - self.cs) * self.pc + np.sqrt(self.cs * (2 - self.cs) * self.mu_eff) * (mean - self.population[0])\n            self.cov_matrix = (1 - self.cs) * self.cov_matrix + self.cs * np.outer(self.pc, self.pc)\n            \n            if np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * count_evals / self.pop_size)) < self.convergence_criterion:\n                self.sigma *= np.exp(0.2 + self.cs * (np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * count_evals / self.pop_size)) - 1))\n            \n            for i in range(self.pop_size):\n                if count_evals >= self.budget:\n                    break\n                self.population[i] = np.random.multivariate_normal(mean, self.sigma**2 * self.cov_matrix)\n                np.clip(self.population[i], -5, 5, out=self.population[i])\n                population_values[i] = func(self.population[i])\n                count_evals += 1\n        return self.population[np.argmin(population_values)]", "name": "EnhancedHybridDE_CMA", "description": "Enhanced HybridDE_CMA with adaptive mutation scaling and enhanced selection strategy for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('slice indices must be integers or None or have an __index__ method').", "error": "TypeError('slice indices must be integers or None or have an __index__ method')", "parent_id": "3ebd6728-e34a-48eb-bb85-31dd8db4ada8", "metadata": {}, "mutation_prompt": null}
