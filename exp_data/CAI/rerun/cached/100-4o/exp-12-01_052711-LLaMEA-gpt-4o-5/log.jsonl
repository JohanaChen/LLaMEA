{"id": "57ccd938-aa18-4dea-b741-b2cfa30c7b2f", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.current_evaluations < self.budget:\n            # Evaluate population\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                self.current_evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.population[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.population[i]\n\n            # Adaptive strategy between DE and PSO\n            if self.current_evaluations < self.budget / 2:\n                self.differential_evolution_step(func)\n            else:\n                self.particle_swarm_optimization_step(func)\n\n        return self.global_best_position\n\n    def differential_evolution_step(self, func):\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n            mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n            trial_vector = np.where(np.random.rand(self.dim) < CR, mutant_vector, self.population[i])\n\n            # Evaluate trial vector\n            trial_score = func(trial_vector)\n            self.current_evaluations += 1\n\n            if trial_score < self.personal_best_scores[i]:\n                self.population[i] = trial_vector\n                self.personal_best_scores[i] = trial_score\n                self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n    def particle_swarm_optimization_step(self, func):\n        w = 0.5  # Inertia weight\n        c1 = 1.5  # Cognitive (personal) coefficient\n        c2 = 1.5  # Social (global) coefficient\n\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n\n            self.velocities[i] = (\n                w * self.velocities[i]\n                + c1 * r1 * (self.personal_best_positions[i] - self.population[i])\n                + c2 * r2 * (self.global_best_position - self.population[i])\n            )\n\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate updated particle\n            score = func(self.population[i])\n            self.current_evaluations += 1\n\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.population[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.population[i]", "name": "HybridDEPSO", "description": "A dynamically adaptive hybrid algorithm combining Differential Evolution and Particle Swarm Optimization to balance exploration and exploitation for diverse optimization landscapes.", "configspace": "", "generation": 0, "fitness": 0.31036233216072057, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.7007521170935103, 0.7274720008969761, 0.7141202834049712, 0.774755842476123, 0.7251818689460559, 0.7421305045121542, 0.7148196097627675, 0.7324870261408936, 0.7461261056581238, 0.5844463143703862, 0.5990325774176061, 0.5696902198061751, 0.5596515297184423, 0.5616112772187614, 0.5770177967975099, 0.6008248996394061, 0.5797396743349137, 0.5617933220140277, 0.13049033796427012, 0.13947974418648068, 0.10672304135288746, 0.13838333699606442, 0.13157306124247115, 0.11872081208867058, 0.11525055100222303, 0.10963251777893424, 0.15661292003322558, 0.11190342470648351, 0.11857670358870454, 0.10003666053682359, 0.12481594469535773, 0.10973452300085196, 0.09433149080917391, 0.10804564931509664, 0.09939976873165579, 0.098315079929296, 0.9474718118363341, 0.9019315617836983, 0.9473457532383525, 0.9572860265067608, 0.95790493533196, 0.9446664335120907, 0.963778538988618, 0.8748524765678645, 0.9791162719625912, 0.4821925154053802, 0.4624377746921299, 0.4933534224257844, 0.46959990970619236, 0.3743370504423017, 0.5059633251480182, 0.45431040607568096, 0.48044548265343023, 0.4811215952007911, 0.682218698610326, 0.6900474640557369, 0.631649512673411, 0.6557988291100527, 0.6494731013697006, 0.6316729993589508, 0.6992710460462281, 0.5973781090458077, 0.6205268394969126, 0.3245338232477053, 0.19216450728623713, 0.1713966472840075, 0.20689179306036054, 0.14830594791459795, 0.1859218001381372, 0.22052714113739647, 0.2402875364909144, 0.1939284404260596, 0.18292586210674322, 0.11807877037121473, 0.19403484196481968, 0.212399782955199, 0.18063834050780203, 0.2095840395570987, 0.21020328926795395, 0.1799016546727149, 0.1898174722008481, 0.12859958503778213, 0.1485064891390543, 0.16341734304091693, 0.18792224335583507, 0.1451027850899791, 0.07767300147095701, 0.10482210405569803, 0.10248667759895724, 0.17522116513851016, 0.2674351147693119, 0.2599698251774507, 0.32236013135759156, 0.3260620820033965, 0.2461765074009853, 0.29773550227159784, 0.28145080566766967, 0.30635027164209394, 0.26685092183239123, 0.06888686462435456, 0.0812568220681269, 0.10952787954541532, 0.1792172559614963, 0.08183402277782847, 0.1245530060200365, 0.1046393509682193, 0.04596503815144637, 0.037650880490950445, 0.18386159986338402, 0.20211675814820462, 0.21836771758596496, 0.1945678074120598, 0.19901222315138367, 0.20441313881378487, 0.21566095763967907, 0.21177266616719126, 0.19166943568307948, 0.5071814376598568, 0.49094402284178373, 0.5267204234952365, 0.5230389838422531, 0.533763037922959, 0.4964816952751535, 0.506526001069186, 0.4895082176891139, 0.5393872820561223, 0.1079480184666105, 0.09914003659649573, 0.07141935841710534, 0.08602468351466008, 0.12051555294779814, 0.12547844527334184, 0.1071952234905752, 0.10102188585326966, 0.10007527581238485, 0.15966928661154234, 0.1350807133351387, 0.16111795519947136, 0.1181486497648997, 0.1437155384849289, 0.1300639684301288, 0.17629659373023565, 0.1382435099859044, 0.19797330961685966, 0.3344465422643905, 0.29941620997108487, 0.29831572634985404, 0.33037033586967945, 0.29523585914119044, 0.2666778628908959, 0.373182168404425, 0.398739650766071, 0.3119568897031261, 0.19161609849810635, 0.23409924249583736, 0.24685966951065885, 0.21822225711457455, 0.23312592960311873, 0.21707551034213668, 0.2772536113853258, 0.2761182224941745, 0.31888068114992174, 0.18677113279967894, 0.18051701297941514, 0.1967277272094331, 0.1829920075648147, 0.2165470762996965, 0.19399822324418736, 0.17397335808636494, 0.18210520904128347, 0.20065379355472224, 0.1969078850137409, 0.3689444991148726, 0.5347587450688871, 0.19222894390145961, 0.19641884777694918, 0.2084862428938884, 0.44668254219376313, 0.19332891231005822, 0.36412346325867295, 0.1530620452680962, 0.16594106133567443, 0.8241601020677284, 0.6056821624803139, 0.17701967975842925, 0.17047443242797256, 0.7334963375128696, 0.7011634427815974, 0.17649589289139567, 0.16496663433452263, 0.17418491424267546, 0.16331682642988055, 0.6698759145367148, 0.15691714243374522, 0.19223853989583883, 0.2080422602120795, 0.20606899086519703, 0.20957948475540178, 0.16552675228846236, 0.17669156716983092, 0.18102380206727453, 0.18746259549047095, 0.19450579630199494, 0.20052869665443118, 0.18344214273670612, 0.17578052931882882, 0.1713407594374281, 0.07262063511791461, 0.0697427914581864, 0.07756390144445335, 0.07961680436071761, 0.06799746196793732, 0.07889496002883445, 0.07910064396902905, 0.07737456745653304, 0.07143817644182127]}, "mutation_prompt": null}
{"id": "c60b34cb-018d-463a-b986-ca96f5fed3c1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = self.initialize_population()\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        while self.current_evaluations < self.budget:\n            # Evaluate population\n            for i in range(self.population_size):\n                score = func(self.population[i])\n                self.current_evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.population[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.population[i]\n\n            # Adaptive strategy between DE and PSO\n            if self.current_evaluations < self.budget / 2:\n                self.differential_evolution_step(func)\n            else:\n                self.particle_swarm_optimization_step(func)\n\n        return self.global_best_position\n\n    def differential_evolution_step(self, func):\n        F = 0.8  # Differential weight\n        CR = 0.9 - (0.4 * (self.current_evaluations / self.budget))  # Dynamically adjust CR\n\n        for i in range(self.population_size):\n            indices = list(range(self.population_size))\n            indices.remove(i)\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n\n            mutant_vector = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n            trial_vector = np.where(np.random.rand(self.dim) < CR, mutant_vector, self.population[i])\n\n            # Evaluate trial vector\n            trial_score = func(trial_vector)\n            self.current_evaluations += 1\n\n            if trial_score < self.personal_best_scores[i]:\n                self.population[i] = trial_vector\n                self.personal_best_scores[i] = trial_score\n                self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n    def particle_swarm_optimization_step(self, func):\n        w = 0.5 + (0.2 * (self.current_evaluations / self.budget))  # Dynamically adjust inertia weight\n        c1 = 1.5  # Cognitive (personal) coefficient\n        c2 = 1.5  # Social (global) coefficient\n\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n\n            self.velocities[i] = (\n                w * self.velocities[i]\n                + c1 * r1 * (self.personal_best_positions[i] - self.population[i])\n                + c2 * r2 * (self.global_best_position - self.population[i])\n            )\n\n            self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            # Evaluate updated particle\n            score = func(self.population[i])\n            self.current_evaluations += 1\n\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.population[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.population[i]", "name": "HybridDEPSO", "description": "A slightly enhanced HybridDEPSO that dynamically adjusts PSO inertia weight and DE crossover probability for improved performance.", "configspace": "", "generation": 1, "fitness": 0.27420751831503964, "feedback": "", "error": "", "parent_id": "57ccd938-aa18-4dea-b741-b2cfa30c7b2f", "metadata": {"aucs": [0.7435383435677058, 0.72843370715663, 0.7234051750240846, 0.7321271529066131, 0.7508501135903023, 0.7667066294452198, 0.7576314869759906, 0.18024049653463203, 0.7437529117874597, 0.561372390271491, 0.5418136128951649, 0.5706163452670563, 0.5444806100826848, 0.5749610305897724, 0.5646766824359282, 0.5608920247669695, 0.5462825006611924, 0.5813835742872502, 0.13577070549499526, 0.12299280914164523, 0.11984224681875644, 0.1183162025076907, 0.1309463120776938, 0.12441345450088848, 0.15498435500677243, 0.1270429566366793, 0.11199356334152111, 0.1089802425427221, 0.11016807419279562, 0.10792963813382139, 0.32273488379345117, 0.10881596828691087, 0.10057686365621199, 0.10500459326189426, 0.10961405141108804, 0.1314914927839178, 0.9341117142290014, 0.9610404635326304, 0.9640328654424937, 0.9729544362962319, 0.9300612812724847, 0.9359534995791686, 0.9701713141389461, 0.9444523218777232, 0.9492641055559742, 0.4100311665647721, 0.3607275465294637, 0.4227125616460343, 0.3952439696422063, 0.3970319795653734, 0.4443931082197874, 0.35697457421728274, 0.40913822941421096, 0.4045126299973515, 0.5775668473080748, 0.5768320220415964, 0.2966307275161181, 0.6269734579851596, 0.5836740186482274, 0.5517942855881834, 0.34119240635082104, 0.30770155750578465, 0.6017001156236279, 0.1815947522011877, 0.16835671825527676, 0.18065173950868751, 0.16681805042755227, 0.1449091932758333, 0.17014212925406225, 0.16466370823970444, 0.17530362211121342, 0.18071795170912286, 0.17824979848465627, 0.1889944841400446, 0.17182439928978233, 0.15188021328443957, 0.15814888757093581, 0.16164251361299808, 0.15437532821089717, 0.15096282925272864, 0.17802838387497655, 0.06672621964677239, 0.006450062771826026, 0.006066309814413029, 0.07849784610525112, 0.04019320401690207, 0.005546599997232615, 0.039208527522682335, 0.042671177529978066, 0.019637161377043078, 0.2136395291532308, 0.13113749367688032, 0.14167005668946508, 0.17107300086337962, 0.15963539182025943, 0.16536510291158846, 0.17038938253167002, 0.22069934219999598, 0.1683519012982615, 0.04272327311785207, 0.04101783803647863, 0.08101800522008507, 0.09191693723211425, 0.10895641931751265, 0.07275835429848576, 0.08315445232001784, 0.05448172585729372, 0.18341331464343213, 0.1582679676159443, 0.15596756301014125, 0.17758082791349006, 0.18710661702321607, 0.13813690643302412, 0.16384874404846128, 0.1329755022035708, 0.16115676989491423, 0.15386211315241016, 0.49522330975196116, 0.44464411417846794, 0.5126619970684922, 0.4737209755786883, 0.5462918653944546, 0.47731741395554816, 0.4874925376135988, 0.49901348548622404, 0.4762274858087573, 0.13458064147041082, 0.10784328896447148, 0.08845356578695951, 0.10519257123996284, 0.10862198438327741, 0.10253655381614424, 0.11946700827875067, 0.08572043557632747, 0.1056254454445158, 0.15959741110031933, 0.13458190673558168, 0.13243682692863645, 0.13190419043028234, 0.1314772134498815, 0.13455012792872312, 0.15372710834308978, 0.174792087629134, 0.18470802256335805, 0.3523196731900211, 0.30768788428150506, 0.3261254764792949, 0.27887964421069766, 0.28294907098580946, 0.27843853770670657, 0.3688010798265048, 0.3411264807372758, 0.3699797952000876, 0.23630632796816764, 0.22721768999689562, 0.22615540633704345, 0.23322732507015065, 0.23857086515685366, 0.20635266615826908, 0.24674166566681843, 0.23932423190367091, 0.2229584075465164, 0.18833645642756713, 0.1704048233518044, 0.18960619733362694, 0.20512110846952103, 0.19668031858389823, 0.17836324624916344, 0.21273865266354974, 0.18594985610744663, 0.18107777447223738, 0.2413474882271729, 0.1760263092670561, 0.35064402133162553, 0.1933203780641306, 0.19788006483689746, 0.19235083089013705, 0.1980783653249525, 0.18096103434391175, 0.20006602751614555, 0.16255722487997792, 0.1613606616186285, 0.6156121524374114, 0.18604713499868597, 0.19061742220204692, 0.1599667309831473, 0.5949812306933153, 0.4607623111811715, 0.16013428794999274, 0.1657129335661599, 0.18971914788133926, 0.19941076103707533, 0.16937473042136153, 0.18548980498370005, 0.19803670609828627, 0.20773880618191087, 0.2061517660148896, 0.1956775052155676, 0.1746935363897939, 0.17619906092073834, 0.18169361706222442, 0.1900325024528816, 0.18390986663618092, 0.18682959432155133, 0.20406921894929975, 0.18363762316086396, 0.1712165918897961, 0.06684797856764602, 0.07305939674659911, 0.06942626986579503, 0.06514653511043123, 0.07066592186426701, 0.07044655501367802, 0.0673881794569905, 0.07413105501958384, 0.06533162539271176]}, "mutation_prompt": null}
