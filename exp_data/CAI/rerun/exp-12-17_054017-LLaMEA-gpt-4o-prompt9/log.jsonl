{"id": "0e236b1c-7556-49a9-8b55-2455b81ed991", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * 0.1\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Hybrid Differential Evolution with Adaptive Memetic Search (Hybrid-DEAMS) which combines differential evolution with local search strategies to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.23474500702380444, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.24.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8452916446464264, 0.8452916446464264, 0.8452916446464264, 0.8763872633610481, 0.8763872633610481, 0.8763872633610481, 0.8544860184498919, 0.8544860184498919, 0.8544860184498919, 0.7947106965844575, 0.7947106965844575, 0.7947106965844575, 0.07065231285590268, 0.07065231285590268, 0.07065231285590268, 0.7632586159765264, 0.7632586159765264, 0.7632586159765264, 0.12486966169857805, 0.12486966169857805, 0.12486966169857805, 0.13892720793277202, 0.13892720793277202, 0.13892720793277202, 0.12855418299551602, 0.12855418299551602, 0.12855418299551602, 0.13255726933969558, 0.13255726933969558, 0.13255726933969558, 0.12722728550721352, 0.12722728550721352, 0.12722728550721352, 0.11679037850952989, 0.11679037850952989, 0.11679037850952989, 0.9770636722672824, 0.9770636722672824, 0.9770636722672824, 0.9868591851641746, 0.9868591851641746, 0.9868591851641746, 0.1314605229500736, 0.1314605229500736, 0.1314605229500736, 0.17128496065752352, 0.17128496065752352, 0.17128496065752352, 0.4047402176421382, 0.4047402176421382, 0.4047402176421382, 0.12094978483875751, 0.12094978483875751, 0.12094978483875751, 0.256524114107048, 0.256524114107048, 0.256524114107048, 0.19121949287836804, 0.19121949287836804, 0.19121949287836804, 0.20515125202439777, 0.20515125202439777, 0.20515125202439777, 0.13623275274163804, 0.13623275274163804, 0.13623275274163804, 0.16635535710028804, 0.16635535710028804, 0.16635535710028804, 0.13104523908670507, 0.13104523908670507, 0.13104523908670507, 0.13677412892162788, 0.13677412892162788, 0.13677412892162788, 0.12945827642045826, 0.12945827642045826, 0.12945827642045826, 0.039352782224185257, 0.039352782224185257, 0.039352782224185257, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16744335242089126, 0.16744335242089126, 0.16744335242089126, 0.04211309688782516, 0.04211309688782516, 0.04211309688782516, 0.13389566546302345, 0.13389566546302345, 0.13389566546302345, 0.2115416822054974, 0.2115416822054974, 0.2115416822054974, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14730782633398343, 0.14730782633398343, 0.14730782633398343, 0.13388717470478406, 0.13388717470478406, 0.13388717470478406, 0.13970062950898976, 0.13970062950898976, 0.13970062950898976, 0.05259278094408315, 0.05259278094408315, 0.05259278094408315, 0.5274011018870413, 0.5274011018870413, 0.5274011018870413, 0.5323957223316143, 0.5323957223316143, 0.5323957223316143, 0.5036075286647927, 0.5036075286647927, 0.5036075286647927, 0.14801612455362878, 0.14801612455362878, 0.14801612455362878, 0.11342719318016592, 0.11342719318016592, 0.11342719318016592, 0.11100072226075686, 0.11100072226075686, 0.11100072226075686, 0.1615255269260375, 0.1615255269260375, 0.1615255269260375, 0.13042722465945678, 0.13042722465945678, 0.13042722465945678, 0.10489154168348447, 0.10489154168348447, 0.10489154168348447, 0.21364176342235774, 0.21364176342235774, 0.21364176342235774, 0.19709332615363806, 0.19709332615363806, 0.19709332615363806, 0.13577528342454115, 0.13577528342454115, 0.13577528342454115, 0.2173921786245775, 0.2173921786245775, 0.2173921786245775, 0.169751553829124, 0.169751553829124, 0.169751553829124, 0.18870462465997284, 0.18870462465997284, 0.18870462465997284, 0.1525370588270334, 0.1525370588270334, 0.1525370588270334, 0.1952619776485618, 0.1952619776485618, 0.1952619776485618, 0.20585782352142978, 0.20585782352142978, 0.20585782352142978, 0.2169793124520295, 0.2169793124520295, 0.2169793124520295, 0.21034922484463925, 0.21034922484463925, 0.21034922484463925, 0.18843448858583167, 0.18843448858583167, 0.18843448858583167, 0.16871171703869037, 0.16871171703869037, 0.16871171703869037, 0.16676412029208498, 0.16676412029208498, 0.16676412029208498, 0.18892242943536575, 0.18892242943536575, 0.18892242943536575, 0.16996332404566072, 0.16996332404566072, 0.16996332404566072, 0.20939729617569525, 0.20939729617569525, 0.20939729617569525, 0.5112928490645787, 0.5112928490645787, 0.5112928490645787, 0.16107124883324797, 0.16107124883324797, 0.16107124883324797, 0.15592736020309128, 0.15592736020309128, 0.15592736020309128, 0.1289870694962183, 0.1289870694962183, 0.1289870694962183, 0.06387498392196211, 0.06387498392196211, 0.06387498392196211, 0.07490484247714935, 0.07490484247714935, 0.07490484247714935, 0.09028547723815794, 0.09028547723815794, 0.09028547723815794]}, "mutation_prompt": null}
{"id": "f4e88ecf-1332-43b0-a22d-e053c28efe9e", "solution": "import numpy as np\n\nclass ModifiedHybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2 * np.log(self.dim)))  # Changed population size calculation\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.dynamic_adjustment_factor = 0.1  # New parameter for dynamic adjustments\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                # Introduce adaptive mutation factor\n                adaptive_mutation = self.mutation_factor * (1 - (i / self.population_size))\n                mutant = np.clip(a + adaptive_mutation * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(int(self.max_local_search_iter * (1 + self.dynamic_adjustment_factor))):  # Adjust local search iterations\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * 0.1 * (1 - self.dynamic_adjustment_factor)  # Adjust step size dynamically\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "ModifiedHybridDEAMS", "description": "Modified Hybrid-DEAMS with Dynamic Subpopulation Size and Adaptive Mutation for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 1, "fitness": 0.11515128702693742, "feedback": "The algorithm ModifiedHybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.09.", "error": "", "parent_id": "0e236b1c-7556-49a9-8b55-2455b81ed991", "metadata": {"aucs": [0.19866442093593872, 0.19866442093593872, 0.19866442093593872, 0.34248052867986156, 0.34248052867986156, 0.34248052867986156, 0.2096897050880755, 0.2096897050880755, 0.2096897050880755, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029311145832816465, 0.029311145832816465, 0.029311145832816465, 0.0959553240213008, 0.0959553240213008, 0.0959553240213008, 0.11343727177097751, 0.11343727177097751, 0.11343727177097751, 0.0641366389298933, 0.0641366389298933, 0.0641366389298933, 0.07298427000509622, 0.07298427000509622, 0.07298427000509622, 0.03328741212267028, 0.03328741212267028, 0.03328741212267028, 0.030668641935149066, 0.030668641935149066, 0.030668641935149066, 0.06242634140433345, 0.06242634140433345, 0.06242634140433345, 0.14516131049304637, 0.14516131049304637, 0.14516131049304637, 0.08337776740878144, 0.08337776740878144, 0.08337776740878144, 0.1169505523840737, 0.1169505523840737, 0.1169505523840737, 0.08124711741659718, 0.08124711741659718, 0.08124711741659718, 0.08849419025125604, 0.08849419025125604, 0.08849419025125604, 0.06263003720361926, 0.06263003720361926, 0.06263003720361926, 0.21136242610669798, 0.21136242610669798, 0.21136242610669798, 0.1410605923475452, 0.1410605923475452, 0.1410605923475452, 0.03885933404394015, 0.03885933404394015, 0.03885933404394015, 0.015213215958286841, 0.015213215958286841, 0.015213215958286841, 0.09032690210539407, 0.09032690210539407, 0.09032690210539407, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06453525886880707, 0.06453525886880707, 0.06453525886880707, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10112929820821304, 0.10112929820821304, 0.10112929820821304, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0474302433226641, 0.0474302433226641, 0.0474302433226641, 0.07344624198826055, 0.07344624198826055, 0.07344624198826055, 0.029190290707458377, 0.029190290707458377, 0.029190290707458377, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06567975945593685, 0.06567975945593685, 0.06567975945593685, 0.004349274131300485, 0.004349274131300485, 0.004349274131300485, 0.048646245991165626, 0.048646245991165626, 0.048646245991165626, 0.33927395159995544, 0.33927395159995544, 0.33927395159995544, 0.22394313504126562, 0.22394313504126562, 0.22394313504126562, 0.36027430670873906, 0.36027430670873906, 0.36027430670873906, 0.06646785923434217, 0.06646785923434217, 0.06646785923434217, 0.1107371630158912, 0.1107371630158912, 0.1107371630158912, 0.07263266584072403, 0.07263266584072403, 0.07263266584072403, 0.18631751768360993, 0.18631751768360993, 0.18631751768360993, 0.15432714303533723, 0.15432714303533723, 0.15432714303533723, 0.1840546770415542, 0.1840546770415542, 0.1840546770415542, 0.15371304747545478, 0.15371304747545478, 0.15371304747545478, 0.16628706367771573, 0.16628706367771573, 0.16628706367771573, 0.23286909769448638, 0.23286909769448638, 0.23286909769448638, 0.13421012337915073, 0.13421012337915073, 0.13421012337915073, 0.10483162910899135, 0.10483162910899135, 0.10483162910899135, 0.13074694554299782, 0.13074694554299782, 0.13074694554299782, 0.14775076935172382, 0.14775076935172382, 0.14775076935172382, 0.24108738238237248, 0.24108738238237248, 0.24108738238237248, 0.1996530654518931, 0.1996530654518931, 0.1996530654518931, 0.18419390453472773, 0.18419390453472773, 0.18419390453472773, 0.18543167305368446, 0.18543167305368446, 0.18543167305368446, 0.17825620539731568, 0.17825620539731568, 0.17825620539731568, 0.18063693354942412, 0.18063693354942412, 0.18063693354942412, 0.16557794094377876, 0.16557794094377876, 0.16557794094377876, 0.1643280395363358, 0.1643280395363358, 0.1643280395363358, 0.16837634820160874, 0.16837634820160874, 0.16837634820160874, 0.11361623965260204, 0.11361623965260204, 0.11361623965260204, 0.11330121761706469, 0.11330121761706469, 0.11330121761706469, 0.19754419386874433, 0.19754419386874433, 0.19754419386874433, 0.2201289084190997, 0.2201289084190997, 0.2201289084190997, 0.1989542632093393, 0.1989542632093393, 0.1989542632093393, 0.06054031959653383, 0.06054031959653383, 0.06054031959653383, 0.06551213971705816, 0.06551213971705816, 0.06551213971705816, 0.12228503625681386, 0.12228503625681386, 0.12228503625681386]}, "mutation_prompt": null}
{"id": "514f89e5-b284-491c-ad46-28741ee58fa0", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Improved seeding strategy\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        population[0] = np.zeros(self.dim)  # Seed one individual at the center\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * 0.1\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced Hybrid Differential Evolution with reduced mutation factor and improved initial solution seeding for faster convergence.", "configspace": "", "generation": 2, "fitness": 0.14699611075647295, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.14.", "error": "", "parent_id": "0e236b1c-7556-49a9-8b55-2455b81ed991", "metadata": {"aucs": [0.22432797647194835, 0.22432797647194835, 0.22432797647194835, 0.2981078629815569, 0.2981078629815569, 0.2981078629815569, 0.30063348408651336, 0.30063348408651336, 0.30063348408651336, 0.03666192241965105, 0.03666192241965105, 0.03666192241965105, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06923319251869231, 0.06923319251869231, 0.06923319251869231, 0.11188326519090674, 0.11188326519090674, 0.11188326519090674, 0.11722697811233007, 0.11722697811233007, 0.11722697811233007, 0.08488739617316865, 0.08488739617316865, 0.08488739617316865, 0.030162770052909016, 0.030162770052909016, 0.030162770052909016, 0.08212803346278885, 0.08212803346278885, 0.08212803346278885, 0.09706766620849472, 0.09706766620849472, 0.09706766620849472, 0.10132953142888512, 0.10132953142888512, 0.10132953142888512, 0.14856585963298496, 0.14856585963298496, 0.14856585963298496, 0.951815700924151, 0.951815700924151, 0.951815700924151, 0.038798292649675936, 0.038798292649675936, 0.038798292649675936, 0.05611625653524699, 0.05611625653524699, 0.05611625653524699, 0.09409848082386763, 0.09409848082386763, 0.09409848082386763, 0.24379866071250578, 0.24379866071250578, 0.24379866071250578, 0.282068956244524, 0.282068956244524, 0.282068956244524, 0.12642233618739207, 0.12642233618739207, 0.12642233618739207, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034280202478755184, 0.034280202478755184, 0.034280202478755184, 0.17743142083381114, 0.17743142083381114, 0.17743142083381114, 0.16385774672224196, 0.16385774672224196, 0.16385774672224196, 0.2226159363343735, 0.2226159363343735, 0.2226159363343735, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07854029790932748, 0.07854029790932748, 0.07854029790932748, 0.023990478841766527, 0.023990478841766527, 0.023990478841766527, 0.038003508756032534, 0.038003508756032534, 0.038003508756032534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10786238772614543, 0.10786238772614543, 0.10786238772614543, 0.14006561488413316, 0.14006561488413316, 0.14006561488413316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06480260411706384, 0.06480260411706384, 0.06480260411706384, 0.3849688776932564, 0.3849688776932564, 0.3849688776932564, 0.22802941817476086, 0.22802941817476086, 0.22802941817476086, 0.2809425125657684, 0.2809425125657684, 0.2809425125657684, 0.0688173143871571, 0.0688173143871571, 0.0688173143871571, 0.11971888238572959, 0.11971888238572959, 0.11971888238572959, 0.10740112303182436, 0.10740112303182436, 0.10740112303182436, 0.12868215115758652, 0.12868215115758652, 0.12868215115758652, 0.07389842052513285, 0.07389842052513285, 0.07389842052513285, 0.14169549233983547, 0.14169549233983547, 0.14169549233983547, 0.3075838889085749, 0.3075838889085749, 0.3075838889085749, 0.19447591447818002, 0.19447591447818002, 0.19447591447818002, 0.205946418582444, 0.205946418582444, 0.205946418582444, 0.17020052463458213, 0.17020052463458213, 0.17020052463458213, 0.2671992072592002, 0.2671992072592002, 0.2671992072592002, 0.1316658112203155, 0.1316658112203155, 0.1316658112203155, 0.2602151077428243, 0.2602151077428243, 0.2602151077428243, 0.2602151077428243, 0.2602151077428243, 0.2602151077428243, 0.2602151077428243, 0.2602151077428243, 0.2602151077428243, 0.032208814913763484, 0.032208814913763484, 0.032208814913763484, 0.20296077648869681, 0.20296077648869681, 0.20296077648869681, 0.17820900798744244, 0.17820900798744244, 0.17820900798744244, 0.1864891088873829, 0.1864891088873829, 0.1864891088873829, 0.16418198103865156, 0.16418198103865156, 0.16418198103865156, 0.3824458577362768, 0.3824458577362768, 0.3824458577362768, 0.1789055925914963, 0.1789055925914963, 0.1789055925914963, 0.21267309557507308, 0.21267309557507308, 0.21267309557507308, 0.15738386327606257, 0.15738386327606257, 0.15738386327606257, 0.19576547304988134, 0.19576547304988134, 0.19576547304988134, 0.18305180752745243, 0.18305180752745243, 0.18305180752745243, 0.1569300235047123, 0.1569300235047123, 0.1569300235047123, 0.07472278901833984, 0.07472278901833984, 0.07472278901833984, 0.0656257131495428, 0.0656257131495428, 0.0656257131495428, 0.07260996772661255, 0.07260996772661255, 0.07260996772661255]}, "mutation_prompt": null}
{"id": "ca27f5fb-bb3b-4601-9466-e240c8de95f3", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.9  # Adjusted mutation factor for enhanced exploration\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate  # Introduce dynamic adjustment\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            # Dynamically adjust crossover rate based on current convergence\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * 0.1\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced-DEAMS with a refined mutation factor adjustment and dynamic crossover rate for improved search adaptability.", "configspace": "", "generation": 3, "fitness": 0.2608758080641264, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "0e236b1c-7556-49a9-8b55-2455b81ed991", "metadata": {"aucs": [0.8769234312344756, 0.8769234312344756, 0.8769234312344756, 0.23535796317843105, 0.23535796317843105, 0.23535796317843105, 0.8461491129116572, 0.8461491129116572, 0.8461491129116572, 0.2853301059110215, 0.2853301059110215, 0.2853301059110215, 0.7790790490188996, 0.7790790490188996, 0.7790790490188996, 0.786945277800913, 0.786945277800913, 0.786945277800913, 0.06991051873979726, 0.06991051873979726, 0.06991051873979726, 0.12906707302088694, 0.12906707302088694, 0.12906707302088694, 0.18354219024665575, 0.18354219024665575, 0.18354219024665575, 0.06473577912443385, 0.06473577912443385, 0.06473577912443385, 0.21279473988295083, 0.21279473988295083, 0.21279473988295083, 0.15493729711392534, 0.15493729711392534, 0.15493729711392534, 0.9860968056470186, 0.9860968056470186, 0.9860968056470186, 0.9774302184886375, 0.9774302184886375, 0.9774302184886375, 0.9764706061034951, 0.9764706061034951, 0.9764706061034951, 0.545157551324225, 0.545157551324225, 0.545157551324225, 0.4522332710495168, 0.4522332710495168, 0.4522332710495168, 0.11062847897805239, 0.11062847897805239, 0.11062847897805239, 0.9063926900804644, 0.9063926900804644, 0.9063926900804644, 0.21270505956990104, 0.21270505956990104, 0.21270505956990104, 0.22333535464930154, 0.22333535464930154, 0.22333535464930154, 0.16999641213653793, 0.16999641213653793, 0.16999641213653793, 0.1348740692493371, 0.1348740692493371, 0.1348740692493371, 0.13040784468993172, 0.13040784468993172, 0.13040784468993172, 0.20299374557493222, 0.20299374557493222, 0.20299374557493222, 0.1249489706126391, 0.1249489706126391, 0.1249489706126391, 0.17994339937010007, 0.17994339937010007, 0.17994339937010007, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09616373891477503, 0.09616373891477503, 0.09616373891477503, 0.036642099208214485, 0.036642099208214485, 0.036642099208214485, 0.08252847751994563, 0.08252847751994563, 0.08252847751994563, 0.13355189743872486, 0.13355189743872486, 0.13355189743872486, 0.06219731510345006, 0.06219731510345006, 0.06219731510345006, 0.001443368984128779, 0.001443368984128779, 0.001443368984128779, 0.15699122077818684, 0.15699122077818684, 0.15699122077818684, 0.16268225062501007, 0.16268225062501007, 0.16268225062501007, 0.21843147505803595, 0.21843147505803595, 0.21843147505803595, 0.5192047062258326, 0.5192047062258326, 0.5192047062258326, 0.5005374705788038, 0.5005374705788038, 0.5005374705788038, 0.5435674021027173, 0.5435674021027173, 0.5435674021027173, 0.1307757545916184, 0.1307757545916184, 0.1307757545916184, 0.06409274018430244, 0.06409274018430244, 0.06409274018430244, 0.12667477758992085, 0.12667477758992085, 0.12667477758992085, 0.23660042925787717, 0.23660042925787717, 0.23660042925787717, 0.12560072608020378, 0.12560072608020378, 0.12560072608020378, 0.4117254691067713, 0.4117254691067713, 0.4117254691067713, 0.1412880477009656, 0.1412880477009656, 0.1412880477009656, 0.27167038197452553, 0.27167038197452553, 0.27167038197452553, 0.18115599313498987, 0.18115599313498987, 0.18115599313498987, 0.1502886501658972, 0.1502886501658972, 0.1502886501658972, 0.32739345397859865, 0.32739345397859865, 0.32739345397859865, 0.24844199620331497, 0.24844199620331497, 0.24844199620331497, 0.16596459685935827, 0.16596459685935827, 0.16596459685935827, 0.13100290184586938, 0.13100290184586938, 0.13100290184586938, 0.16930109551010974, 0.16930109551010974, 0.16930109551010974, 0.2202649177100392, 0.2202649177100392, 0.2202649177100392, 0.21253454075471412, 0.21253454075471412, 0.21253454075471412, 0.20969256425866423, 0.20969256425866423, 0.20969256425866423, 0.16416000295402666, 0.16416000295402666, 0.16416000295402666, 0.1643945260550037, 0.1643945260550037, 0.1643945260550037, 0.15976028274083842, 0.15976028274083842, 0.15976028274083842, 0.21232328183968718, 0.21232328183968718, 0.21232328183968718, 0.11344952049023338, 0.11344952049023338, 0.11344952049023338, 0.15660067349913953, 0.15660067349913953, 0.15660067349913953, 0.16431364732756082, 0.16431364732756082, 0.16431364732756082, 0.1824277079642439, 0.1824277079642439, 0.1824277079642439, 0.20587182701317353, 0.20587182701317353, 0.20587182701317353, 0.10434610443114656, 0.10434610443114656, 0.10434610443114656, 0.07728515883254006, 0.07728515883254006, 0.07728515883254006, 0.08102797231580539, 0.08102797231580539, 0.08102797231580539]}, "mutation_prompt": null}
{"id": "3e630b96-dbbb-4108-8347-82c6fc6c57b0", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.9  # Adjusted mutation factor for enhanced exploration\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate  # Introduce dynamic adjustment\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            # Dynamically adjust crossover rate and mutation factor based on current convergence\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n            self.mutation_factor = 0.8 + 0.2 * np.exp(-np.mean(fitness) / self.best_fitness)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            if self.budget <= 0:\n                break\n            for d in range(self.dim):\n                step_size = (self.upper_bound - self.lower_bound) * 0.05  # Adaptive step size\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Improved local search strategy with adaptive step size and mutation factor dynamic tuning for accelerated convergence.", "configspace": "", "generation": 4, "fitness": 0.22936942008994987, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.24.", "error": "", "parent_id": "ca27f5fb-bb3b-4601-9466-e240c8de95f3", "metadata": {"aucs": [0.8911790592602552, 0.8911790592602552, 0.8911790592602552, 0.8629841073630465, 0.8629841073630465, 0.8629841073630465, 0.8800693859754377, 0.8800693859754377, 0.8800693859754377, 0.006431215074817032, 0.006431215074817032, 0.006431215074817032, 0.03490056170950595, 0.03490056170950595, 0.03490056170950595, 0.09131405559952832, 0.09131405559952832, 0.09131405559952832, 0.06835056136968665, 0.06835056136968665, 0.06835056136968665, 0.19039252299951825, 0.19039252299951825, 0.19039252299951825, 0.16878141290881288, 0.16878141290881288, 0.16878141290881288, 0.028515012522740135, 0.028515012522740135, 0.028515012522740135, 0.10450942250155038, 0.10450942250155038, 0.10450942250155038, 0.150128639725991, 0.150128639725991, 0.150128639725991, 0.9721673544518131, 0.9721673544518131, 0.9721673544518131, 0.9717663835199545, 0.9717663835199545, 0.9717663835199545, 0.10098805007943135, 0.10098805007943135, 0.10098805007943135, 0.5375457500069147, 0.5375457500069147, 0.5375457500069147, 0.6950449476861348, 0.6950449476861348, 0.6950449476861348, 0.059561645465555424, 0.059561645465555424, 0.059561645465555424, 0.3556359073782086, 0.3556359073782086, 0.3556359073782086, 0.16165226760149676, 0.16165226760149676, 0.16165226760149676, 0.22769256381754144, 0.22769256381754144, 0.22769256381754144, 0.21688705677874343, 0.21688705677874343, 0.21688705677874343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.6587792115300545, 0.6587792115300545, 0.6587792115300545, 0.18282828253638672, 0.18282828253638672, 0.18282828253638672, 0.1734875694054444, 0.1734875694054444, 0.1734875694054444, 0.2047878956974254, 0.2047878956974254, 0.2047878956974254, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13676402871884474, 0.13676402871884474, 0.13676402871884474, 0.027593522101181045, 0.027593522101181045, 0.027593522101181045, 0.15770259525539154, 0.15770259525539154, 0.15770259525539154, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0789112578150678, 0.0789112578150678, 0.0789112578150678, 0.06426977638439024, 0.06426977638439024, 0.06426977638439024, 0.33427746249043655, 0.33427746249043655, 0.33427746249043655, 0.1325853980113727, 0.1325853980113727, 0.1325853980113727, 0.08508701024527565, 0.08508701024527565, 0.08508701024527565, 0.5596203809953916, 0.5596203809953916, 0.5596203809953916, 0.5199766685647838, 0.5199766685647838, 0.5199766685647838, 0.5169319071744292, 0.5169319071744292, 0.5169319071744292, 0.18661893416855424, 0.18661893416855424, 0.18661893416855424, 0.0831538784220116, 0.0831538784220116, 0.0831538784220116, 0.03508620272766294, 0.03508620272766294, 0.03508620272766294, 0.2608325606132772, 0.2608325606132772, 0.2608325606132772, 0.26209145246227905, 0.26209145246227905, 0.26209145246227905, 0.11181188149952592, 0.11181188149952592, 0.11181188149952592, 0.1547985031826865, 0.1547985031826865, 0.1547985031826865, 0.32489014009155914, 0.32489014009155914, 0.32489014009155914, 0.17336318285061258, 0.17336318285061258, 0.17336318285061258, 0.14861323056770104, 0.14861323056770104, 0.14861323056770104, 0.19390847424753088, 0.19390847424753088, 0.19390847424753088, 0.09885885888317625, 0.09885885888317625, 0.09885885888317625, 0.2068949046513323, 0.2068949046513323, 0.2068949046513323, 0.2617808230464095, 0.2617808230464095, 0.2617808230464095, 0.2038069185563377, 0.2038069185563377, 0.2038069185563377, 0.09706090448728633, 0.09706090448728633, 0.09706090448728633, 0.19927558743055063, 0.19927558743055063, 0.19927558743055063, 0.18091643339367525, 0.18091643339367525, 0.18091643339367525, 0.15423994767289262, 0.15423994767289262, 0.15423994767289262, 0.1651572279900323, 0.1651572279900323, 0.1651572279900323, 0.16762534682472707, 0.16762534682472707, 0.16762534682472707, 0.21312782004950825, 0.21312782004950825, 0.21312782004950825, 0.11203503866633835, 0.11203503866633835, 0.11203503866633835, 0.10530926792406858, 0.10530926792406858, 0.10530926792406858, 0.17142595110686454, 0.17142595110686454, 0.17142595110686454, 0.19077523351870473, 0.19077523351870473, 0.19077523351870473, 0.18422334498310755, 0.18422334498310755, 0.18422334498310755, 0.08495371492022952, 0.08495371492022952, 0.08495371492022952, 0.08146300947692509, 0.08146300947692509, 0.08146300947692509, 0.08989862133826554, 0.08989862133826554, 0.08989862133826554]}, "mutation_prompt": null}
{"id": "efb38fd2-155b-438e-8ce8-e51b0906131b", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                \n                # Adaptive mutation factor based on fitness variance\n                adaptive_mutation_factor = self.mutation_factor * (1 + np.std(fitness) / np.mean(fitness))\n                mutant = np.clip(a + adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                # Adaptive step size for local search based on fitness improvement\n                step_size = (self.upper_bound - self.lower_bound) * 0.05 * (1 + (self.best_fitness - current_fitness) / abs(self.best_fitness))\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "A hybrid optimization algorithm incorporating adaptive mutation factor scaling and adaptive step size in local search for enhanced convergence. ", "configspace": "", "generation": 5, "fitness": 0.23393977919054365, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.24.", "error": "", "parent_id": "ca27f5fb-bb3b-4601-9466-e240c8de95f3", "metadata": {"aucs": [0.8825345040486343, 0.8825345040486343, 0.8825345040486343, 0.7820683181668701, 0.7820683181668701, 0.7820683181668701, 0.8891847367784372, 0.8891847367784372, 0.8891847367784372, 0.6663357069803602, 0.6663357069803602, 0.6663357069803602, 0.5584392307576573, 0.5584392307576573, 0.5584392307576573, 0.7750270299500033, 0.7750270299500033, 0.7750270299500033, 0.13021460198933088, 0.13021460198933088, 0.13021460198933088, 0.04783110871256435, 0.04783110871256435, 0.04783110871256435, 0.18655109131489123, 0.18655109131489123, 0.18655109131489123, 0.024166239581268956, 0.024166239581268956, 0.024166239581268956, 0.14723657444266014, 0.14723657444266014, 0.14723657444266014, 0.14284090440107133, 0.14284090440107133, 0.14284090440107133, 0.9743084833332284, 0.9743084833332284, 0.9743084833332284, 0.9705269432645022, 0.9705269432645022, 0.9705269432645022, 0.10255564260333028, 0.10255564260333028, 0.10255564260333028, 0.4985246330680949, 0.4985246330680949, 0.4985246330680949, 0.03437426373942165, 0.03437426373942165, 0.03437426373942165, 0.08783820791071395, 0.08783820791071395, 0.08783820791071395, 0.11845453819520912, 0.11845453819520912, 0.11845453819520912, 0.18879032416864527, 0.18879032416864527, 0.18879032416864527, 0.21596847504159544, 0.21596847504159544, 0.21596847504159544, 0.3868742567336857, 0.3868742567336857, 0.3868742567336857, 0.036231521712374315, 0.036231521712374315, 0.036231521712374315, 0.1862780630454789, 0.1862780630454789, 0.1862780630454789, 0.1977578845719452, 0.1977578845719452, 0.1977578845719452, 0.13538887813874667, 0.13538887813874667, 0.13538887813874667, 0.13730769966330936, 0.13730769966330936, 0.13730769966330936, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07029350359304432, 0.07029350359304432, 0.07029350359304432, 0.029974485069677592, 0.029974485069677592, 0.029974485069677592, 0.04062376489088659, 0.04062376489088659, 0.04062376489088659, 0.00362322049746, 0.00362322049746, 0.00362322049746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0037657452739454644, 0.0037657452739454644, 0.0037657452739454644, 0.1437741587027238, 0.1437741587027238, 0.1437741587027238, 0.11678676752412942, 0.11678676752412942, 0.11678676752412942, 0.047232719413317525, 0.047232719413317525, 0.047232719413317525, 0.5045119255400788, 0.5045119255400788, 0.5045119255400788, 0.5337139638191666, 0.5337139638191666, 0.5337139638191666, 0.45458399464687516, 0.45458399464687516, 0.45458399464687516, 0.09837484412115771, 0.09837484412115771, 0.09837484412115771, 0.08431396762628429, 0.08431396762628429, 0.08431396762628429, 0.059017158127721125, 0.059017158127721125, 0.059017158127721125, 0.18682624704304052, 0.18682624704304052, 0.18682624704304052, 0.11653275707108257, 0.11653275707108257, 0.11653275707108257, 0.15985303127406036, 0.15985303127406036, 0.15985303127406036, 0.15145039508030345, 0.15145039508030345, 0.15145039508030345, 0.3523768916823812, 0.3523768916823812, 0.3523768916823812, 0.3175747829393457, 0.3175747829393457, 0.3175747829393457, 0.1522283442447977, 0.1522283442447977, 0.1522283442447977, 0.30588056543257736, 0.30588056543257736, 0.30588056543257736, 0.09541881840903332, 0.09541881840903332, 0.09541881840903332, 0.200497664383398, 0.200497664383398, 0.200497664383398, 0.2412498282611173, 0.2412498282611173, 0.2412498282611173, 0.2436628880230718, 0.2436628880230718, 0.2436628880230718, 0.2107852249341584, 0.2107852249341584, 0.2107852249341584, 0.17021789058539272, 0.17021789058539272, 0.17021789058539272, 0.19386374600460243, 0.19386374600460243, 0.19386374600460243, 0.13920760024007373, 0.13920760024007373, 0.13920760024007373, 0.19662649089292783, 0.19662649089292783, 0.19662649089292783, 0.1764072895751322, 0.1764072895751322, 0.1764072895751322, 0.21315595020741263, 0.21315595020741263, 0.21315595020741263, 0.21198029004525698, 0.21198029004525698, 0.21198029004525698, 0.1903901648190286, 0.1903901648190286, 0.1903901648190286, 0.19380576366815616, 0.19380576366815616, 0.19380576366815616, 0.1800363604952605, 0.1800363604952605, 0.1800363604952605, 0.2813253260808588, 0.2813253260808588, 0.2813253260808588, 0.08123337687106591, 0.08123337687106591, 0.08123337687106591, 0.09962453398820892, 0.09962453398820892, 0.09962453398820892, 0.08685179830689815, 0.08685179830689815, 0.08685179830689815]}, "mutation_prompt": null}
{"id": "5e27bbfd-21c7-40a0-8866-69f31384b8fc", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()  # Introduce adaptive mutation factor\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())  # Stochastic step size\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Adaptive mutation factor with stochastic step size for enhanced global and local search balance.", "configspace": "", "generation": 6, "fitness": 0.29109524748906523, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "ca27f5fb-bb3b-4601-9466-e240c8de95f3", "metadata": {"aucs": [0.8980591561937326, 0.9151847318659707, 0.8786250953403888, 0.8894667803313289, 0.9221476171708735, 0.8402251402443992, 0.8986705110102235, 0.8631836885246718, 0.7439594742789399, 0.7804759734496659, 0.8147594551280962, 0.8061687156721222, 0.7442851685305141, 0.8108361464931773, 0.8182571232110647, 0.7830045865317077, 0.8129359803708325, 0.754259266767549, 0.0950650641327846, 0.1539779575678213, 0.11149503463357269, 0.09227803712076388, 0.10588010387861557, 0.17957907037308596, 0.16638297452857154, 0.2355034219589469, 0.12156946576279481, 0.016761683013156836, 0.018019009665046326, 0.017049951381529538, 0.16617274308238617, 0.18690939922699257, 0.1410554886613956, 0.19337357667330501, 0.1550138896449429, 0.13784735835739614, 0.9842720412764493, 0.9816341011312797, 0.9816356565570401, 0.9883774257942107, 0.9872231174337035, 0.9872752777662694, 0.9618783486481048, 0.9483308497166083, 0.9582307323470334, 0.5016600556085049, 0.4830013430545568, 0.3933787977701456, 0.5812233009593775, 0.37687897689488403, 0.49425138714880346, 0.1115839371085734, 0.4159041949678869, 0.4130198657473638, 0.18645708003023176, 0.3872962504865528, 0.27824100014923847, 0.16075986990979563, 0.19328545780360895, 0.2076400565541101, 0.7645590834261331, 0.06527154000605007, 0.32151250665055475, 0.2016003619192922, 0.2054404032495214, 0.24174255544406975, 0.18139538052056292, 0.1110723347740954, 0.1340997208993273, 0.21938995655744864, 0.1251401902453545, 0.14506346029505146, 0.1973165035582849, 0.1870409422904633, 0.12897467316379774, 0.16463236289005545, 0.16496895445353366, 0.15583129219912317, 0.17006075791494601, 0.12179454199527795, 0.13529254284395442, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.228027586690712, 0.1851409673519545, 0.15765042160557463, 0.04531328827757297, 0.04206740896267436, 0.04696030027431353, 0.13313643089255378, 0.19358621246367136, 0.06850569655712502, 0.01685480046972676, 0.046270780865310224, 0.027664612706125857, 0.05604920991916973, 0.05163751531802385, 0.0751226935407705, 0.09499656162804238, 0.008279411074633258, 0.04390904855117406, 0.3564417281658513, 0.21123005182351506, 0.16116127644297706, 0.26720449818269054, 0.2132880282074061, 0.2233442288235007, 0.04866470063713568, 0.05683765471663682, 0.09372099360957231, 0.5086711745489005, 0.47226055257642496, 0.48454801148950366, 0.48795208554322167, 0.5834454111660412, 0.6140007879689096, 0.5243112613277114, 0.5361826685967261, 0.5317431174539509, 0.11806410779908871, 0.16206293885119138, 0.14409266369226337, 0.0882111586533798, 0.0883911084535004, 0.08307570161155253, 0.07574351524481882, 0.11908973255116084, 0.06348780806158649, 0.14648342521311075, 0.21074975547166797, 0.16358721138344845, 0.2228099304142498, 0.20267469728036824, 0.1524482130347662, 0.11477825147987764, 0.1471343980735912, 0.17461737702608193, 0.18882364755669612, 0.15948185227507694, 0.23654116546208903, 0.3827444659953212, 0.23751329813826838, 0.3122074231093962, 0.3020034999999198, 0.1942979815571355, 0.5175216090331844, 0.1352438845360352, 0.18580318622498315, 0.12429511556582618, 0.26409700712697126, 0.23697052197440227, 0.17689530412488674, 0.32350785995319065, 0.27623021924985924, 0.31528107251209203, 0.2020428987514321, 0.18252065720826427, 0.17996404724374315, 0.1695097673381164, 0.19322429251306317, 0.18922647985041874, 0.1785370461199134, 0.157696596155401, 0.19078287395495974, 0.2038199886290729, 0.23085517677134226, 0.1847387912623043, 0.18302122612035832, 0.1897444136923475, 0.22369457388985703, 0.1635029990728799, 0.8117021065512237, 0.24836429557468986, 0.15291108107505047, 0.15294076119914102, 0.15361192172487248, 0.16435360784114927, 0.25847531291079273, 0.3136607265859126, 0.7979671862377609, 0.8438948558561477, 0.863987434434289, 0.16306709863791513, 0.16931548026265097, 0.16941937096353832, 0.5959543799845113, 0.21655728416997277, 0.21475769011398693, 0.6307382872442542, 0.1270082397838509, 0.1263207691723086, 0.22304232994104, 0.16626320026158514, 0.1992343365472934, 0.1735078201153396, 0.1911789715560137, 0.19982011443338954, 0.16361946996917998, 0.17434775117330714, 0.15251448834636905, 0.08381361718955527, 0.08464876378616848, 0.0628526677807364, 0.07903074160032408, 0.07952265600767983, 0.09897916085815484, 0.08318077077808506, 0.05684856893109458, 0.08815799140484726]}, "mutation_prompt": null}
{"id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)  # Calculate fitness variance\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))  # Dynamic adjustment\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced dynamic mutation factor adjustment based on fitness variance to enhance convergence speed.", "configspace": "", "generation": 7, "fitness": 0.29284905349876694, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "5e27bbfd-21c7-40a0-8866-69f31384b8fc", "metadata": {"aucs": [0.8669800593895391, 0.891439832637445, 0.9023803795823102, 0.8409570722649901, 0.9079054941594695, 0.8975114424984847, 0.20195320548389117, 0.9060480847964879, 0.8889466660811918, 0.7965234888345937, 0.8364800445928038, 0.7421103553480972, 0.7947693344733524, 0.8382189830409751, 0.7732802541646913, 0.7718334376142487, 0.8169454055021443, 0.779470264660772, 0.11670360382194689, 0.1186883620556457, 0.1127089149947118, 0.20324639737068018, 0.15433513337356142, 0.07697002531877006, 0.17397770172595484, 0.6183687574243281, 0.18605292781484684, 0.0708891715139367, 0.13421636012864824, 0.09053877645259467, 0.13147806440868193, 0.21036487991911768, 0.12132970357179251, 0.14422037281096034, 0.23419328286542707, 0.18092594970784037, 0.9769767430935276, 0.9805031700807656, 0.9805046024958844, 0.9894795840544073, 0.9884893596158714, 0.9894586333252717, 0.9682483085926379, 0.9636486331840209, 0.9673943703778013, 0.6232039091483541, 0.5854565315862386, 0.6359117628152056, 0.15664210803866918, 0.6096322787766177, 0.3079873516547922, 0.322278078827531, 0.3618683292192245, 0.4982071840772483, 0.1468167844259045, 0.24473606942042925, 0.21589486031488003, 0.21360454126863848, 0.21254333184513585, 0.19242874281670452, 0.7736956926316463, 0.7194438633725757, 0.28771087743777446, 0.2247691512452994, 0.1559097335370767, 0.16340850909276794, 0.12882583211950316, 0.13425957239554132, 0.1335964063668229, 0.24193474136508353, 0.16928836147371218, 0.1567117322462811, 0.20687575347343357, 0.2066855016186998, 0.19276869688484666, 0.18013362369255992, 0.1954183284441705, 0.15806703472522454, 0.18097634644290217, 0.13144304482454117, 0.14011313779362133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2239275805835209, 0.08908704517278643, 0.10762584754162652, 0.05736834876538155, 0.08148011269532707, 0.09072171450752098, 0.09018945709162329, 0.08419037711347899, 0.040125143691046694, 0.21114970907028008, 0.10187875828978155, 0.2020298966082522, 0.06391846505205889, 9.999999999998899e-05, 9.999999999998899e-05, 0.019445449769672107, 0.002784412194969943, 0.0615089406018291, 0.2770840200356909, 0.27654902601189746, 0.24038820463743527, 0.12163176907883821, 0.2103630031763185, 0.0928723652779363, 0.06039878740535154, 0.05734781115178378, 0.17050891871674245, 0.7136660344720269, 0.539480778423019, 0.501455258235985, 0.5045475263280585, 0.5388327387474467, 0.5133483101824373, 0.5700432081722431, 0.6162617007654445, 0.5141281290852833, 0.16481167613778958, 0.0930185368537142, 0.1115552468713027, 0.15340242456793818, 0.08682134721004864, 0.08503608310564992, 0.10542465028804382, 0.08294307895735986, 0.09170498655290937, 0.22542228030554268, 0.13367134648792567, 0.12632264793946302, 0.17511137013310984, 0.08604018169266092, 0.1452835085350005, 0.11077071274751671, 0.15750196807939243, 0.18139720052273278, 0.2372597146747707, 0.46557063076601335, 0.18404006005379459, 0.4886099736995436, 0.45236192626568905, 0.22161078031878934, 0.5207948635976757, 0.3772479466427935, 0.40009025219963446, 0.34713245492746747, 0.09906082371501923, 0.1303704211284199, 0.3505728058812295, 0.19744483174441707, 0.24992550993333884, 0.4156462620355317, 0.08138707216427954, 0.08751386911332049, 0.1664778698291579, 0.19285915556725042, 0.20437589101815845, 0.24880637200651012, 0.20111153762843026, 0.16050442204648974, 0.19492226584486216, 0.1736457382173836, 0.20313975850692845, 0.252415178984541, 0.17031563697125818, 0.1701287309235151, 0.2156616092028416, 0.2256549638988803, 0.18294470133504914, 0.21405816610714934, 0.19826972524420083, 0.21559471475685021, 0.16184436620126907, 0.7170132503011195, 0.9261984508023673, 0.2615933001956866, 0.1644431925399482, 0.3644040002669279, 0.1666132347903091, 0.13664679562927107, 0.1364470544505222, 0.31868814435830095, 0.32825770547507027, 0.38188801995141197, 0.20874027270566797, 0.21230610713037612, 0.21203982884067085, 0.12813149759681275, 0.12800894162240273, 0.12743885599263993, 0.17607836660909493, 0.18328329673523636, 0.17517565540820046, 0.19898517186044318, 0.18190794864149118, 0.18571644497357265, 0.1724951298594355, 0.2132683295135902, 0.15996170250167874, 0.07875778437832892, 0.07767833109710776, 0.055179782497062124, 0.0869594927046754, 0.0670006579576824, 0.08711319989062483, 0.0777281476831242, 0.11026218696548806, 0.07902277436888872]}, "mutation_prompt": null}
{"id": "e9f8ac47-d01d-4428-ac52-f25d8113feb7", "solution": "import numpy as np\n\nclass EnhancedHybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 6  # Increased local search iterations for deeper exploration\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.2 * np.tanh(fitness_variance))  # Changed scaling factor\n            \n            # Segment-based mutation factor for diverse exploration\n            segment_mutation_factor = adjusted_mutation_factor * np.random.rand(self.dim)\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + segment_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.85 * (self.best_fitness / np.mean(fitness))  # Adjusted rate scaling\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.04 + 0.06 * np.random.rand())  # Modified step size range\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedHybridDEAMS", "description": "Enhanced population diversity and adaptive learning with segment-based mutation rates and neighborhood exploration.", "configspace": "", "generation": 8, "fitness": 0.18375037524902962, "feedback": "The algorithm EnhancedHybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.33028062907541966, 0.26336553124167583, 0.3023142582682703, 0.2885754192415918, 0.26977152774873225, 0.26600579290230675, 0.23402098649947733, 0.2570461069317648, 0.25674294091352834, 0.4460238457856778, 0.22728465246579888, 0.2593544367044892, 9.999999999998899e-05, 0.24593839581641053, 0.31885791276027053, 0.4672224814884476, 0.29799537509395757, 0.6860771410051505, 0.05331588772670692, 0.025612436352592027, 0.17152742319977643, 0.12863930991218553, 0.25801158855738426, 0.20086826072184627, 0.23608263817440167, 0.1353041034832282, 0.36273535650127964, 0.0034675925355465154, 0.018846583990375976, 0.03552075907660002, 0.11106826538886927, 0.05606649218809745, 0.09399950218067932, 0.13486126204336268, 0.16281357135974683, 0.15029234218090493, 0.9787385048976055, 0.971594108258562, 0.9715954311487915, 0.10912184331707664, 0.9723545950833593, 0.9716312235011166, 0.9695395928700972, 0.22265573034254138, 0.23498541015559127, 0.17071638676740497, 0.1577829397981313, 0.18187395262235284, 0.032901365571483265, 0.11454148188433444, 0.17716432442347163, 0.11641698839566927, 0.16036246993338732, 0.1371076567318138, 0.15757498392994918, 0.14723192434112098, 0.11631490125428567, 0.160802517762913, 0.1614638237842111, 0.20886201552075645, 0.1885128877872455, 0.158634740421288, 0.10707312157938409, 0.2252408698489794, 0.13740352603682826, 0.13609553172269517, 0.13404005610132408, 0.1293594981596785, 0.12971184372896094, 0.16377338530851449, 0.16924895616006908, 0.14813348183068575, 0.13097611171941193, 0.1463883824965193, 0.13839240955711063, 0.1321878772771945, 0.15437676221830732, 0.12892114415023803, 0.12995808836742473, 0.12978450358794946, 0.12536015680354795, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03980269419988458, 9.999999999998899e-05, 0.1073917338929663, 0.11275582621618196, 0.15831594938027538, 0.07907903645511738, 0.04489245839832123, 0.03429821422560564, 0.09986452260109813, 0.0855585972237064, 0.09765259599822418, 0.027422663236138733, 0.020544993946060686, 0.033253267161265865, 0.10690428273965591, 0.06685339938733836, 0.04203270984936858, 0.06479502745189769, 0.05289577205318907, 0.051817625712378135, 0.14113332179916782, 0.13055299765129513, 0.12864115123193365, 9.999999999998899e-05, 0.07236570432285994, 0.07019524805439936, 0.09580588354911779, 0.08405198858254859, 0.1681340120574627, 0.35247734141938025, 0.31324199874009573, 0.3823212060597807, 0.22958183493131978, 0.2021032071176655, 0.20168801508901524, 0.37122718596660875, 0.36395708253272385, 0.38940648974388015, 0.07365659266844682, 0.09156661674639766, 0.08020473970352959, 0.066377500690038, 0.11845640631780863, 0.13334882070297205, 0.08252658521691814, 0.18903398221928414, 0.06982838914349909, 0.21485570203709836, 0.13657206418925216, 0.1514119013108517, 0.1377851608695564, 0.15993150818586876, 0.20657668938465445, 0.1525649672916688, 0.16191407090892174, 0.1743091375739403, 0.1826683465330382, 0.15600644392044816, 0.15472629722516373, 0.29140333898747617, 0.2748039162257365, 0.23123315248805132, 0.10798669128776273, 0.20520074755106776, 0.11937742294623477, 0.3078039489277111, 0.2011661149398155, 0.15202081499531528, 0.19272862740346275, 0.13161403047882447, 0.1649883316495374, 0.07351650667057041, 0.06363164330437976, 0.07497578499857027, 0.20495006573091634, 0.20138767939996816, 0.249371206799477, 0.247309525613999, 0.20484211362984672, 0.20976732965532652, 0.23142451400608421, 0.23676825149262581, 0.18786636416928626, 0.19759511872565205, 0.2044095153876928, 0.20878060277707666, 0.21099741968293528, 0.25412061546467, 0.20004590205471462, 0.2330105250562301, 0.22027574457600085, 0.2236070201299334, 0.15214999837451038, 0.14630857842396472, 0.13252760723818624, 0.4519753361774368, 0.361169906506715, 0.19662929000356966, 0.15053585940866854, 0.11415013566709908, 0.14930591388768677, 0.16907664993855365, 0.16941437739186227, 0.16859157411769954, 0.2139731038610453, 0.18810610111912363, 0.1705836171225057, 0.10060694288216288, 0.10397671279220955, 0.10397359681349261, 0.18490660174574036, 0.21052245062375696, 0.1847827026538713, 0.1881768763711804, 0.18793080579041888, 0.1856452726111334, 0.21473333121663274, 0.18718775701535995, 0.18621527660928816, 0.08807561503692063, 0.08077667745327599, 0.08408799639213704, 0.08743948518709999, 0.1555591163691452, 0.11765936110454223, 0.07818632213720611, 0.09793427668472199, 0.08706896136130271]}, "mutation_prompt": null}
{"id": "10fd05cc-e620-43b8-998d-6f49197dc56c", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.adaptive_population = True\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            if self.adaptive_population:\n                self.adjust_population_size(fitness)\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance + np.random.rand() * 0.1))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def adjust_population_size(self, fitness):\n        avg_fitness = np.mean(fitness)\n        if avg_fitness < self.best_fitness * 1.1:\n            self.population_size = max(5, self.population_size - 1)\n        else:\n            self.population_size += 1\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced DE variant with adaptive population size and stochastic adjustment of mutation factor for robust optimization.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 8 is out of bounds for axis 0 with size 8').", "error": "IndexError('index 8 is out of bounds for axis 0 with size 8')", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {}, "mutation_prompt": null}
{"id": "090002b1-b864-4b9b-9639-a2444d675193", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                if np.random.rand() < 0.1:  # Introduce a small probability for larger perturbation\n                    step_size *= 2\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced local search by introducing a small probability of larger perturbations to escape local optima, improving convergence speed.", "configspace": "", "generation": 10, "fitness": 0.28119198044171223, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.9246810602149944, 0.6852168919463559, 0.901933555801899, 0.8618300514323323, 0.8538546772489656, 0.8721164326575114, 0.8774148543430162, 0.6033773068470946, 0.782146880949576, 0.23199768476883942, 0.7449787930307885, 0.10090963295334732, 0.8231417894983993, 0.6897193305741722, 0.8482664496344536, 0.8050616991585284, 0.8125127866565289, 0.8183051082982327, 0.1469925771343138, 0.052542527980010134, 0.14599547682311365, 0.16100321179729438, 0.09739762422589571, 0.19050584757567712, 0.13319348756022864, 0.18842538033831302, 0.19704483563800845, 0.0739374354033524, 0.03584707590166514, 0.04337545810952759, 0.17568982402859656, 0.17307267201705911, 0.16441947482561625, 0.12650627485612442, 0.19895785608026983, 0.1411236409911708, 0.976410892834176, 0.9784357190591236, 0.9784355754283461, 0.9813547391487, 0.9809684480266402, 0.9809824753881975, 0.970359429276296, 0.9815275081053326, 0.9815282014875478, 0.3910536241409738, 0.484518707829137, 0.5349431219742544, 0.40340860715986504, 0.502239989971636, 0.15717803148708753, 0.08995288426733516, 0.11536105417388098, 0.115122860698614, 0.24356352862676367, 0.3867445164979484, 0.16336918505996711, 0.3789547564922777, 0.18938530916371388, 0.910729583742026, 0.3544100945300226, 0.298110863562423, 0.21734669394497652, 0.16236720365822765, 0.19805190809283024, 0.18126732369212528, 0.13199323824928, 0.11733087966010369, 0.12091049685338895, 0.16710103887141614, 0.240845897487314, 0.17228812629952428, 0.1434819370278554, 0.12438865362286688, 0.15077180864158402, 0.22568911487396615, 0.1991228712428511, 0.22879939724714815, 0.20941962802585035, 0.13428770633592135, 0.20020090016990466, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1634394684002184, 0.0951513348174895, 0.13542947367304536, 0.0675961432910126, 0.05178339794234166, 0.06922456446033431, 0.10945922681144471, 0.09149434603961781, 0.17217319701444644, 0.09503560528770849, 9.999999999998899e-05, 0.011636429057084952, 0.06004553264548029, 0.013472649313182594, 0.1150768519522497, 0.10895421548344586, 0.00015646093316512566, 0.019277424789543307, 0.33800911539511547, 0.1448099013867793, 0.23348282108081175, 0.2150028421668887, 0.2662556960396715, 0.300477702657999, 0.05050613340385657, 0.10002703821357062, 0.18684198705962263, 0.4964785383083633, 0.5371823864084722, 0.5462663270758163, 0.4960278083981149, 0.2688289590385866, 0.25828105412918934, 0.4958969956680902, 0.5036641497717105, 0.48194982900596584, 0.11116976804404421, 0.0949861669793709, 0.08747209054503868, 0.10340553660443219, 0.16244946564534712, 0.17223413111318064, 0.09322534041986075, 0.08165236308614676, 0.06460616454383539, 0.14117177265588288, 0.14875898754145223, 0.1752369631518319, 0.12301923423333105, 0.09922641966092183, 0.08578016781379993, 0.1577638848696874, 0.22061721521362287, 0.1401050390025823, 0.18801746711005252, 0.17408177098202526, 0.16246201734885557, 0.2353407005519924, 0.3526011883451291, 0.3273866348847173, 0.14963832311781755, 0.16331003909234965, 0.17677470695988629, 0.2402170660482048, 0.1571375195430672, 0.19229171115852384, 0.2775552109724978, 0.2814158543383807, 0.31311098368665924, 0.2351607003533378, 0.35778749856373404, 0.2449185799001944, 0.18358745581586577, 0.14610954389910857, 0.18062882064679275, 0.2025175069856081, 0.20921683053266005, 0.21863731581070167, 0.20318707674937464, 0.19576438331308055, 0.18619114176751184, 0.19044200610399953, 0.2056816014506524, 0.20619154743219015, 0.20353193051292295, 0.24115763104854704, 0.20200302076293752, 0.17999524021346192, 0.2286815989642983, 0.24467119987363717, 0.889308649417225, 0.7218225768816284, 0.9068011594376686, 0.16872040477704542, 0.3754990919053883, 0.6430511735280154, 0.15291965731133028, 0.8654017017652877, 0.8676166705697119, 0.16832063616548, 0.16933984465181695, 0.16918360830612966, 0.21323761176527378, 0.21273138956175053, 0.21245908349194864, 0.07356162488040863, 0.28364361327321785, 0.12236752688619035, 0.18301860302292405, 0.2003983330372534, 0.1853875284455072, 0.17447352232947688, 0.1813819453865959, 0.1883482057219238, 0.22179278057664986, 0.25790601068124286, 0.17679557384820987, 0.08531983458179238, 0.09776505515049472, 0.08260884372199107, 0.0686107257049029, 0.06104413322072233, 0.11041663316443429, 0.08884567903008833, 0.09706904479551726, 0.10140895589831966]}, "mutation_prompt": null}
{"id": "1b0ba49d-616c-4b4e-87b2-d5245228547e", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)  # Calculate fitness variance\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))  # Dynamic adjustment\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                # Adaptive step size\n                step_size = (self.upper_bound - self.lower_bound) * (0.03 + 0.07 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced diversity through adaptive step size in local search for improved convergence.", "configspace": "", "generation": 11, "fitness": 0.276538974220788, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8831552496315498, 0.8962414615020803, 0.9144809348901989, 0.9083162585446143, 0.8229446633817166, 0.8970323572764971, 0.8928299071185257, 0.8879280093942458, 0.8294411067549933, 0.7408749114752924, 0.2316844892187212, 0.15326866107351056, 0.8465448652808123, 0.8576178139047518, 0.8183512371819093, 0.8308026655151398, 0.8332265840166779, 0.7797410260858169, 0.09569544576794742, 0.09529749891500161, 0.13621442937038208, 0.09324556728595434, 0.07836830632920833, 0.08659563165495232, 0.2895650123556397, 0.1662966323527566, 0.1836141036361002, 0.12230007939142107, 0.10861248656353784, 0.11082666854176804, 0.16656452614374517, 0.16227733364412855, 0.15862366804457306, 0.14426093727834122, 0.14740259177605897, 0.14805272577495943, 0.9729417155004589, 0.9728319569517265, 0.972846098311189, 0.9894740310218552, 0.9884845211727818, 0.9894537039539771, 0.965160606306154, 0.9357080275310261, 0.9257947788366214, 0.2915427014682438, 0.5784433519810609, 0.45986591634837815, 0.47375552635445617, 0.5559344155830837, 0.538807845948716, 0.10157759154872636, 0.11188354581657334, 0.10235797660961266, 0.1688761591321254, 0.22584136356087547, 0.2504972109645215, 0.27581576786168993, 0.2116546944664931, 0.21191447794173013, 0.35301375229219933, 0.28840001540132687, 0.3735684191790266, 0.1813415453027616, 0.13060199012194185, 0.2043547385206883, 0.13101669429649632, 0.43353776828946833, 0.2529174567549368, 0.6648573460347096, 0.1572591869031834, 0.18465680705701848, 0.1491346834092172, 0.1308141518923932, 0.18592838680872614, 0.16851190230987634, 0.2814190375536939, 0.19913274104065304, 0.16725069861111608, 0.13037771325724734, 0.17819066958504115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007023882900273892, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12001567682590941, 0.0851822813766615, 0.15635505175047948, 0.030845430969140164, 0.020869870101069665, 0.07075547742229771, 0.08944649588821507, 0.07072601409517754, 0.05652434044236687, 0.09912217230623332, 0.09708481752284992, 0.29012071911310544, 0.06565747743374928, 0.03165807611379745, 0.15385575252392392, 0.05217934735953045, 0.04414736052051682, 0.011453515578007445, 0.26945851943284094, 0.007771955164740052, 9.999999999998899e-05, 0.16216890119041472, 0.19313172317099248, 0.19619424942487562, 0.17701801833773811, 0.10821734863287114, 0.10942992128750251, 0.4749063881723775, 0.5834925496724717, 0.6103175743582463, 0.47903177291319, 0.5389673310063392, 0.4860929194463348, 0.5724239387162939, 0.4285193873859614, 0.4682580384594992, 0.06518941911142917, 0.09298662176973427, 0.11176019351342037, 0.09223325209579203, 0.10997749789376687, 0.13780296874461095, 0.08914135713275084, 0.07961521745735589, 0.07463765432749847, 0.335075751448367, 0.276692792856977, 0.1861939591618691, 0.17620432521123153, 0.08507231681124339, 0.13797017738366435, 0.135986167809662, 0.19659040626156643, 0.12773676703553138, 0.1597126360113903, 0.16667573013532966, 0.1746043930011163, 0.3136904281924193, 0.42687596485926527, 0.22163882656653455, 0.339894976996033, 0.4393710548908233, 0.22215341482170103, 0.1879231523822673, 0.1612583274674314, 0.1668700342139955, 0.32803720861713215, 0.21450083681532428, 0.19828917814300917, 0.20741964245671896, 0.0816054976046171, 0.08543790295465914, 0.1386956302438077, 0.14385756404235994, 0.23456475786351483, 0.20367820630119748, 0.24845568218303438, 0.2524030280773438, 0.21914677296931984, 0.17361123508510823, 0.25644809236758614, 0.19378551046461157, 0.19399732765534405, 0.21176791497148628, 0.20805520104355768, 0.1772196600111431, 0.18958555302748947, 0.21007779209793298, 0.21032536720708517, 0.22307745882512287, 0.9050750182801792, 0.15353407573928657, 0.16689610517994735, 0.16873265404154825, 0.3159522192011345, 0.38266062094904163, 0.1663775949581059, 0.13671187698791565, 0.13645300740599764, 0.4353455132808065, 0.3544554224379085, 0.5288633219657918, 0.20997206781911926, 0.21160717075098823, 0.21089143673577004, 0.12760109938666286, 0.12819912863505412, 0.09825918920200516, 0.19794655661132188, 0.19295479701103646, 0.1818182764453109, 0.1737822163943067, 0.18303492201191007, 0.18165693411860417, 0.17257076433228413, 0.21403764350990473, 0.190651050392318, 0.10312578112723181, 0.08979050622175233, 0.08827523258644687, 0.08761666761268605, 0.07070224505254896, 0.06960091295808613, 0.09062401110117113, 0.07513409369470614, 0.08055965707471091]}, "mutation_prompt": null}
{"id": "b32d0144-6aac-4592-b8b1-7309855ab54a", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.reinit_period = np.ceil(np.log2(self.population_size))  # New: Re-initialization period\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        iterations = 0  # New: Track iterations for re-initialization\n        \n        while self.budget > 0:\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                if self.budget <= 0:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n            iterations += 1\n            \n            # New: Re-initialize a random subset of the population periodically\n            if iterations % self.reinit_period == 0:\n                num_reinit = max(1, self.population_size // 10)\n                reinit_idxs = np.random.choice(self.population_size, num_reinit, replace=False)\n                population[reinit_idxs] = np.random.uniform(self.lower_bound, self.upper_bound, (num_reinit, self.dim))\n                fitness[reinit_idxs] = np.apply_along_axis(func, 1, population[reinit_idxs])\n                self.budget -= num_reinit\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced a periodic re-initialization strategy for part of the population to escape local optima and improve exploration.", "configspace": "", "generation": 12, "fitness": 0.22745217631266232, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.25.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8616225500038426, 0.8517432662298401, 0.8815156749486143, 0.8306820181267685, 0.8570200933132699, 0.8433035320411155, 0.8715270374014077, 0.8297356608471056, 0.8515938021454095, 0.07731208056603844, 0.0988233629173445, 0.07777560619885848, 0.05780504122575292, 0.030082343297643255, 0.0810460077805647, 0.05039950525456316, 0.035798625042442245, 0.04633939353156036, 0.2073718819117647, 0.15252376283859925, 0.17134459882114372, 0.15578434041618916, 0.14632834093749225, 0.14877285485489955, 0.1877638117144007, 0.15299072566213867, 0.14560366586415563, 0.13142150531039842, 0.06097899606525281, 0.04781114179050272, 0.14332857814337074, 0.12398386013754625, 0.1681351660989603, 0.1543632757425032, 0.20149693474652508, 0.11717738140933742, 0.9673275507358254, 0.9672680587940257, 0.9672760461841025, 0.9819887538042623, 0.9811076153226547, 0.9811066008323288, 0.975289641489605, 0.970657821634621, 0.9706740445202319, 0.1249567605581191, 0.15565838934518672, 0.13193234178848412, 0.11393849109928911, 0.13331960254712594, 0.10622419896000157, 0.13121325117223692, 0.11474040231043892, 0.14678675110896766, 0.22224038313916594, 0.1777222064687205, 0.20340192992099637, 0.2052397811464567, 0.2853148703370866, 0.2461130749736149, 0.14210874476189184, 0.1602241957772751, 0.2021518968533932, 0.16106662065708077, 0.13775876434813183, 0.12047990043325119, 0.11919470682943611, 0.1107170744068533, 0.13784210051465162, 0.10798248581838998, 0.10593389509682272, 0.127179219979076, 0.06946764919144022, 0.11068062622760522, 0.11443707874097309, 0.11665328194142077, 0.10332589370989753, 0.10839955700429205, 0.12310910056860414, 0.15777552669030015, 0.11335859606097254, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05414479763713498, 0.08590346073872024, 0.07834319451629834, 0.05686181110773325, 0.05015815505188004, 0.07329330173927029, 0.1095465115284463, 0.05831446800319806, 0.060564669241770175, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01901136881147336, 0.031212412396529388, 0.03815647856236659, 0.06876432978191338, 0.04647726347007897, 0.05699810917760462, 0.22038202375105953, 0.07182649773405314, 0.0879910110831632, 0.5073143106607363, 0.5557374094301016, 0.530468770670995, 0.5423811271779921, 0.5058915107042341, 0.5345750233733626, 0.4645416199882617, 0.5278134061556963, 0.6223306961952165, 0.07947691759493425, 0.116827622075512, 0.158468711542892, 0.07571316994627264, 0.12693853140891564, 0.08147526444746522, 0.091321803900409, 0.08338720543891054, 0.08812461630540092, 0.1591877197818954, 0.1408353614825424, 0.15941256424465977, 0.19118191734695877, 0.12720453433560108, 0.1651671006716744, 0.1627739758084361, 0.13851323073856092, 0.1567953997390017, 0.22797597573472095, 0.24264300840808628, 0.2168040835297853, 0.33871432495648524, 0.44307585477082034, 0.5151610589057958, 0.34206377114414277, 0.45622796975254554, 0.2806267799805501, 0.20910307746283974, 0.14469650630949704, 0.13086571955978432, 0.1454042139144489, 0.13873495340119957, 0.15498010520414862, 0.2410587412492825, 0.25155339910010244, 0.15876578730874658, 0.31989760686764357, 0.16827057517381383, 0.2185116785795903, 0.18811591996148957, 0.18228303401811186, 0.16641193098093632, 0.1865083842574824, 0.1932131585553265, 0.1891009947770772, 0.19106566371699196, 0.18746598956408744, 0.2069780881107579, 0.18234908187733867, 0.19578252325032786, 0.3391011026578108, 0.19480592230192473, 0.2049256957384783, 0.20294542334396803, 0.1698461289498906, 0.2858305267813944, 0.16832948522627988, 0.2871254968222977, 0.16982015180582022, 0.2905161845189853, 0.21239530092539205, 0.84636801304337, 0.885773785627773, 0.1751757993652936, 0.34846259087233955, 0.402514605007143, 0.20806277494986758, 0.11436165244751739, 0.11767267706524531, 0.40975054652164955, 0.10409986195747367, 0.10466308942160596, 0.17665727222872285, 0.18682064087218775, 0.17832285171166817, 0.20242510975800254, 0.22003262021230663, 0.17426820874706395, 0.18154870509854804, 0.17128434999071085, 0.200178458333084, 0.07090057673863415, 0.06862497469467266, 0.07284036681557426, 0.07899550439818104, 0.07772450408808307, 0.0735979528884414, 0.07302027753058615, 0.07162872793116892, 0.06758091311998926]}, "mutation_prompt": null}
{"id": "cab213c3-4247-422b-a549-0ef470d5fb29", "solution": "import numpy as np\n\nclass EnhancedHybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 10  # Increased local search iterations\n        self.learning_rate = 0.1  # New adaptive learning rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.2 * np.tanh(fitness_variance))  # Altered adjustment\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.95 * (self.best_fitness / np.mean(fitness))  # Adjusted dynamic crossover rate\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = self.learning_rate * (self.upper_bound - self.lower_bound)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedHybridDEAMS", "description": "Enhanced convergence through adaptive learning rate and elitist local search strategies.", "configspace": "", "generation": 13, "fitness": 0.22973424402650253, "feedback": "The algorithm EnhancedHybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.7078643463490224, 0.46724031635008445, 0.8497879312944153, 0.22072891254478577, 0.3478740394337788, 0.7239849033255585, 0.6738853802133453, 0.835721864999994, 0.6460698084564303, 0.5687794891843121, 0.5461449089218415, 0.16546188803375295, 0.6749219824590735, 0.6851016054864699, 0.6171462202618789, 0.672360112025739, 0.544124833059797, 0.6784427555514733, 0.050890763294025754, 0.045466810301308946, 0.04781321760804835, 0.09875652354562536, 0.09109993159832253, 0.1401392872074686, 0.14822626333745936, 0.16203284206819868, 0.15375769435261954, 0.04507912051295737, 0.07029762616417268, 0.08417559924199136, 0.12099485648471087, 0.1581732231643559, 0.13023217352706018, 0.25168534285393374, 0.1174235751992172, 0.10320202549930713, 0.9786093025328799, 0.9786059771033311, 0.978606325591172, 0.9779614317063003, 0.9780242519928563, 0.9780009577760052, 0.9633050408559137, 0.9708411379223031, 0.9708406274883521, 0.2694055525209481, 0.340148496278633, 0.27130756417107005, 0.27436317278380884, 0.14998546542896496, 0.382696423007573, 0.21811677279639896, 0.08897479001902064, 0.12962778310480283, 0.1686379322290319, 0.16350371993678015, 0.13889100493931217, 0.3807602358443184, 0.14427692370875123, 0.15885142781090122, 0.16398453849688777, 0.12356452162878417, 0.1543867783474081, 0.12481503358434742, 0.33549884829178134, 0.27184201437901245, 0.15027646037835252, 0.15865616958254336, 0.16158913264048624, 0.14936448520367362, 0.1805877468205861, 0.12816360672611682, 0.18963134178761487, 0.19861835420108187, 0.12607901897645313, 0.15912227385457334, 0.12433922396034736, 0.13709572776745704, 0.1548704682791715, 0.23262372180138768, 0.12878133120702118, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05846935627165695, 0.07285031044066748, 0.05091821403086538, 0.07355135041299077, 0.06822452138515822, 0.067490638579074, 0.08534632444851109, 0.10627106061502123, 0.047221997774827495, 9.999999999998899e-05, 0.05808633927247775, 0.11356431585159321, 0.06973052459762852, 0.07088751430944262, 0.06187813571040712, 0.06729118996608563, 0.02465166179557221, 0.07204077712626877, 0.07591200169291568, 0.12387626097359294, 0.1252841341950347, 0.18133596399189322, 0.015715231791884277, 0.0577516500428501, 0.037221557221703505, 0.03358583380892666, 0.06688642558424618, 0.3725422120146491, 0.37923278909446345, 0.4865993616672677, 0.43611244910249536, 0.44623797540621446, 0.4428133724545589, 0.484485536198603, 0.49404334845661646, 0.46454383332885496, 0.09156237806631784, 0.42360619126376864, 0.32377581431204483, 0.13527050300250398, 0.0965048635265936, 0.046751858112644595, 0.0716344669273351, 0.06997776058734817, 0.06836623273299558, 0.2157437476264732, 0.14955577020179955, 0.1409784961686873, 0.19398105717789527, 0.13440112987238884, 0.10149064408492992, 0.16114642318939387, 0.17411616364472415, 0.14199901352791622, 0.1370124438191166, 0.14449711772176, 0.1526226863872513, 0.19468070550484085, 0.15216219477792525, 0.26465819337376806, 0.2915414349050368, 0.20860028045044265, 0.3202938614910239, 0.16050291355235546, 0.19743229672238272, 0.17566790101161622, 0.1467323403432823, 0.15179476350106846, 0.2575572264493159, 0.13561810892808557, 0.1823751910833885, 0.24446263816050606, 0.18626055758917226, 0.13966928267051792, 0.162694604475507, 0.2750313223512528, 0.16877546074822147, 0.23109491934778803, 0.2076717299060853, 0.21486592588747855, 0.19623321069032373, 0.18274689899632235, 0.20188281339129166, 0.1847181654338489, 0.22286082025529297, 0.21040696325642272, 0.18730377230092687, 0.17323043381647152, 0.1801498404162829, 0.21191903404199885, 0.15403749621673724, 0.1688634764158582, 0.1689443299988621, 0.1654004744207732, 0.16541266862806647, 0.1654640635561926, 0.1665967856450381, 0.1456933766598577, 0.15383798483785271, 0.155153066728975, 0.1573842197922415, 0.15711251696482942, 0.38079093087535, 0.3021803329603997, 0.4267981160908155, 0.15582499985259235, 0.139188133037897, 0.13931640409803836, 0.18996474180309697, 0.17398168186301932, 0.17853863324913832, 0.1863295240248014, 0.17296385775600098, 0.18688277680075516, 0.1321598806708567, 0.1791771885974517, 0.16519335107977606, 0.06972876590103583, 0.0824260415182958, 0.059764588276903896, 0.06601606155179673, 0.0712637101614002, 0.05299268625700293, 0.09027864111691453, 0.08229667523717288, 0.07107250030255086]}, "mutation_prompt": null}
{"id": "f47bfad4-7618-4066-b9bf-0712d14c5d0a", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            avg_fitness = np.mean(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance / avg_fitness))\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / avg_fitness)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced mutation factor variability by adapting it with fitness variance and average fitness to improve convergence.", "configspace": "", "generation": 14, "fitness": 0.28656473558556694, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8731347175308027, 0.8726986452487333, 0.8329933044185034, 0.21995553209023078, 0.8386899547306167, 0.8628998030213193, 0.9033530371565285, 0.8674321874794981, 0.47026753861437665, 0.7405044192240278, 0.8214986511230467, 0.8263594514943052, 0.817426784593849, 0.8225545713113969, 0.8300975654575734, 0.7768085318197753, 0.8078235048073124, 0.6677129703266648, 0.08741070308793697, 0.09132307124499162, 0.15129504039468245, 0.17698505344405835, 0.18397280723449327, 0.16086684911805782, 0.1550263662254947, 0.7638418731805696, 0.13530452964478668, 0.061611369599114396, 0.11501108683541206, 0.13298842125842525, 0.13521832243613008, 0.17241979227948978, 0.14957592856717017, 0.14349998257271723, 0.1460742041137142, 0.15211987807447624, 0.9771506001033669, 0.977124229195319, 0.9771278116411916, 0.9783721877468903, 0.9837747528481161, 0.9837876172655626, 0.9707116236986683, 0.9758151355488269, 0.9758142264944624, 0.7249543841885018, 0.49992944034008513, 0.6078394890581507, 0.5260375235329826, 0.5075139793507503, 0.3727075094375678, 0.42288220814198096, 0.11134174382846596, 0.4915995575556492, 0.21636061807186036, 0.22312926618164552, 0.23670107783667538, 0.2122730890731651, 0.37492062207501586, 0.25173265030638614, 0.22813084740025102, 0.23569105314687244, 0.7757243520458089, 0.2314504422433461, 0.19214938320301922, 0.19365795484309622, 0.17362046865073988, 0.16011912594402145, 0.18574485846466016, 0.19084364703631962, 0.12875757154422807, 0.13022871059956564, 0.12665775985323613, 0.14676376359935206, 0.16744560389554686, 0.15263435284788796, 0.14471242940831686, 0.1581385017150495, 0.15906967126247584, 0.16679924949224056, 0.17996241005466362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032064528383561886, 9.999999999998899e-05, 0.1318189700212561, 0.12431429027866492, 0.18221251908808622, 0.06065795985187905, 0.06986145160421098, 0.09072171450752098, 0.12378065521276527, 0.0825542892356238, 0.03712628926769235, 0.01937049004689273, 9.999999999998899e-05, 0.000373449905460399, 0.035579003851953006, 0.06350205551161803, 0.0036043632723440355, 0.07107053765154303, 0.04734652677477713, 0.03133428060100829, 0.009145152822472302, 0.1906076661620717, 9.999999999998899e-05, 0.1888996810093645, 0.20140147809336262, 0.15370471625826232, 0.26874159958090604, 0.19647064054904395, 0.22715443972538163, 0.538667135663006, 0.5833581678736668, 0.5232533744727763, 0.5224108713308333, 0.5259682532557504, 0.48075482833744276, 0.5630030578300802, 0.5455172798667651, 0.534957827976393, 0.13477812993725624, 0.15113567709916764, 0.10863115426168646, 0.12332591234972878, 0.14376599114657962, 0.105045998787198, 0.10114171827923313, 0.10820163560924789, 0.1633620930021814, 0.15751752681188647, 0.17243764368379488, 0.15731544193131175, 0.1975943257294669, 0.20931297452424613, 0.2372355343621032, 0.13837476891392375, 0.1354942776939937, 0.21473014829879933, 0.3222969018625834, 0.5312670864213369, 0.2978022020989155, 0.44024030443449624, 0.4611459471603271, 0.29433916240309266, 0.18104507786859358, 0.2500890153873967, 0.3320967393300116, 0.18299399291718899, 0.16041130773891676, 0.17286463709153377, 0.23899996158984138, 0.19592355730956523, 0.3153556766988165, 0.2058990245397906, 0.20196480925864102, 0.1938137872838488, 0.19942672240116321, 0.18224295733709905, 0.24076864191913971, 0.24143158291009215, 0.23414745748169052, 0.23196763548808752, 0.2234503659321858, 0.17685781012450075, 0.19899584593252406, 0.18669032656074214, 0.24950167720745253, 0.222006374495215, 0.21176836175417324, 0.19435543855738824, 0.18732768099311548, 0.17431386981433794, 0.204749674247253, 0.2099500145126303, 0.9172788062292687, 0.17040734184291928, 0.1675314400827489, 0.173661186829152, 0.2753012594356148, 0.29114932883362576, 0.9216895372123077, 0.13643243567106578, 0.1362248046904566, 0.16986819363528938, 0.16990914841023352, 0.1698963922959087, 0.21152374378748218, 0.21291246636985606, 0.2122333836876995, 0.11321236553939285, 0.12705834483524925, 0.11712327899796615, 0.19748989487649948, 0.19200401618703922, 0.1525709995237856, 0.19332090040873395, 0.19126720101747186, 0.17899765856995287, 0.15697259651390794, 0.1813571395538246, 0.2067090229511941, 0.1128805063685282, 0.07998539538766036, 0.08693028402100245, 0.09716841463145032, 0.11254700136786289, 0.10356992555198519, 0.07763524751748196, 0.09023733800348022, 0.07691188329736398]}, "mutation_prompt": null}
{"id": "feda160b-8437-476c-89a8-02fbfb1cd75b", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            self.mutation_factor = max(0.5, self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance)))  # Self-adaptive mutation adjustment\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced the mutation mechanism by incorporating a self-adaptive mutation factor to improve convergence speed.", "configspace": "", "generation": 15, "fitness": 0.10723542701425677, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.17.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.15211450579079444, 0.15214570163835384, 0.15214121268028646, 0.21996204417317067, 0.21603476368417862, 0.21691061618565155, 0.09199059805373377, 0.0937109983865978, 0.09346234018904631, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004840161352840933, 0.006379010562671317, 0.03465878505960207, 0.05551495067893608, 0.06844985940435622, 0.10374460070948588, 0.07581234923428604, 0.07943784801967535, 0.05238966592017147, 0.04766962766588878, 0.039550551974341985, 0.04116072363151868, 0.07621067189966979, 0.041992793401522066, 0.042877366668881534, 0.07266937441591381, 0.03704035994451427, 0.06384312660756442, 0.979906466594111, 0.979916526359706, 0.9799151569758042, 0.9848682122028104, 0.9850024542885236, 0.9849780980153938, 0.9825303439602834, 0.10278740130745845, 0.10278874638099911, 0.11957929882995322, 0.08954097343294631, 0.08964029681155794, 0.018304966191682426, 0.030625767704945628, 0.06375338222289884, 0.17620733801254407, 0.09172312888263456, 0.07864277979856615, 0.06613751634394649, 0.04320900976760855, 0.04320861574617518, 0.11325261201143944, 0.1455368000461894, 0.1455368000461894, 0.046011795367077, 0.0831728976135897, 0.08029064139469178, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010089371083334964, 0.019960190203820116, 9.999999999998899e-05, 0.039735232872377346, 0.03973552277366055, 0.019797021496212763, 0.015088213612318269, 0.015438306241606914, 9.999999999998899e-05, 0.0788735021445296, 0.07528653244526418, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05341593870498962, 0.06606731879283201, 0.03523165692962116, 9.999999999998899e-05, 0.03143917509609595, 0.06341534905897739, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005688999589561372, 0.022066221213744353, 0.021928557461276088, 0.0265246354298182, 0.028635683513049126, 0.02863144291732822, 0.02991071495883657, 0.0401038340464247, 0.039465594584153774, 0.1450579498285357, 0.14520055540254595, 0.14518610787300257, 0.18241771865090473, 0.18348977835343694, 0.1833414890829086, 0.15620003825566475, 0.1565246734094835, 0.15648126115577432, 0.04605509363547211, 0.06891256829100367, 0.06949816669017927, 0.06391888013702884, 0.0496340032641569, 0.029729993126245247, 0.043421241800675636, 0.040161909506804094, 0.06683283216783853, 0.14822753327322002, 0.135700872116573, 0.12632264793946302, 0.0863184104635828, 0.09508575217617254, 0.07995334688191102, 0.11077071274751671, 0.10493106277814257, 0.07964864054505327, 0.13635168759082972, 0.13635841729938036, 0.13599187557724945, 0.12792530998724838, 0.12415878226389121, 0.12365371672260861, 0.12483761337839028, 0.15937491183388808, 0.15518313006828743, 0.12249735127154415, 0.10197404288138856, 0.0976301566395974, 0.06288527060211802, 0.10996631967240411, 0.10435980925473265, 0.11020943205213096, 0.06522934799125579, 0.036900769315585835, 0.12550001718636505, 0.11829545817389775, 0.12753903829987134, 0.137296902893562, 0.14994057062775423, 0.12014112939189814, 0.12292152721369987, 0.14814527671823707, 0.12148047696419761, 0.14849424908935926, 0.1640345794108602, 0.1637923945618801, 0.15332943344733463, 0.14897160766497186, 0.14658366998975836, 0.17363605959089579, 0.15860142330271154, 0.16455723203480377, 0.14660987485137977, 0.1063049683592231, 0.10624385198368469, 0.16553780433335774, 0.10783499234492278, 0.13346477805777546, 0.08372101804201504, 0.09248743303795404, 0.09242998126428448, 0.16099585120975968, 0.08983512367414936, 0.17257500836503537, 0.10185517345788209, 0.1022499295276772, 0.1022022910784195, 0.08293415373139357, 0.10910331950293384, 0.10908387055795321, 0.15255565738532428, 0.17619082761289773, 0.173390867604429, 0.1500477988242117, 0.1497183512672573, 0.18037515354352052, 0.1579743774232133, 0.15604005895663053, 0.14156058636437574, 0.036323695020495816, 0.04239380983596963, 0.03378268751489666, 0.05380250631251726, 0.04799075631931482, 0.053306330209943575, 0.044724406560804564, 0.03720269816328714, 0.04099879682447427]}, "mutation_prompt": null}
{"id": "ce31b13d-72ab-4f76-b083-313fe7c09e8a", "solution": "import numpy as np\n\nclass HybridDEAPRS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.resize_threshold = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        improvements = 0\n        while self.budget > 0:\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    improvements += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n            if improvements / self.population_size < self.resize_threshold and self.population_size > 4:\n                self.population_size = max(4, int(self.population_size * 0.9))\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAPRS", "description": "Introduced dynamic population resizing based on fitness improvements to enhance convergence speed.", "configspace": "", "generation": 16, "fitness": 0.29284905349876694, "feedback": "The algorithm HybridDEAPRS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8669800593895391, 0.891439832637445, 0.9023803795823102, 0.8409570722649901, 0.9079054941594695, 0.8975114424984847, 0.20195320548389117, 0.9060480847964879, 0.8889466660811918, 0.7965234888345937, 0.8364800445928038, 0.7421103553480972, 0.7947693344733524, 0.8382189830409751, 0.7732802541646913, 0.7718334376142487, 0.8169454055021443, 0.779470264660772, 0.11670360382194689, 0.1186883620556457, 0.1127089149947118, 0.20324639737068018, 0.15433513337356142, 0.07697002531877006, 0.17397770172595484, 0.6183687574243281, 0.18605292781484684, 0.0708891715139367, 0.13421636012864824, 0.09053877645259467, 0.13147806440868193, 0.21036487991911768, 0.12132970357179251, 0.14422037281096034, 0.23419328286542707, 0.18092594970784037, 0.9769767430935276, 0.9805031700807656, 0.9805046024958844, 0.9894795840544073, 0.9884893596158714, 0.9894586333252717, 0.9682483085926379, 0.9636486331840209, 0.9673943703778013, 0.6232039091483541, 0.5854565315862386, 0.6359117628152056, 0.15664210803866918, 0.6096322787766177, 0.3079873516547922, 0.322278078827531, 0.3618683292192245, 0.4982071840772483, 0.1468167844259045, 0.24473606942042925, 0.21589486031488003, 0.21360454126863848, 0.21254333184513585, 0.19242874281670452, 0.7736956926316463, 0.7194438633725757, 0.28771087743777446, 0.2247691512452994, 0.1559097335370767, 0.16340850909276794, 0.12882583211950316, 0.13425957239554132, 0.1335964063668229, 0.24193474136508353, 0.16928836147371218, 0.1567117322462811, 0.20687575347343357, 0.2066855016186998, 0.19276869688484666, 0.18013362369255992, 0.1954183284441705, 0.15806703472522454, 0.18097634644290217, 0.13144304482454117, 0.14011313779362133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2239275805835209, 0.08908704517278643, 0.10762584754162652, 0.05736834876538155, 0.08148011269532707, 0.09072171450752098, 0.09018945709162329, 0.08419037711347899, 0.040125143691046694, 0.21114970907028008, 0.10187875828978155, 0.2020298966082522, 0.06391846505205889, 9.999999999998899e-05, 9.999999999998899e-05, 0.019445449769672107, 0.002784412194969943, 0.0615089406018291, 0.2770840200356909, 0.27654902601189746, 0.24038820463743527, 0.12163176907883821, 0.2103630031763185, 0.0928723652779363, 0.06039878740535154, 0.05734781115178378, 0.17050891871674245, 0.7136660344720269, 0.539480778423019, 0.501455258235985, 0.5045475263280585, 0.5388327387474467, 0.5133483101824373, 0.5700432081722431, 0.6162617007654445, 0.5141281290852833, 0.16481167613778958, 0.0930185368537142, 0.1115552468713027, 0.15340242456793818, 0.08682134721004864, 0.08503608310564992, 0.10542465028804382, 0.08294307895735986, 0.09170498655290937, 0.22542228030554268, 0.13367134648792567, 0.12632264793946302, 0.17511137013310984, 0.08604018169266092, 0.1452835085350005, 0.11077071274751671, 0.15750196807939243, 0.18139720052273278, 0.2372597146747707, 0.46557063076601335, 0.18404006005379459, 0.4886099736995436, 0.45236192626568905, 0.22161078031878934, 0.5207948635976757, 0.3772479466427935, 0.40009025219963446, 0.34713245492746747, 0.09906082371501923, 0.1303704211284199, 0.3505728058812295, 0.19744483174441707, 0.24992550993333884, 0.4156462620355317, 0.08138707216427954, 0.08751386911332049, 0.1664778698291579, 0.19285915556725042, 0.20437589101815845, 0.24880637200651012, 0.20111153762843026, 0.16050442204648974, 0.19492226584486216, 0.1736457382173836, 0.20313975850692845, 0.252415178984541, 0.17031563697125818, 0.1701287309235151, 0.2156616092028416, 0.2256549638988803, 0.18294470133504914, 0.21405816610714934, 0.19826972524420083, 0.21559471475685021, 0.16184436620126907, 0.7170132503011195, 0.9261984508023673, 0.2615933001956866, 0.1644431925399482, 0.3644040002669279, 0.1666132347903091, 0.13664679562927107, 0.1364470544505222, 0.31868814435830095, 0.32825770547507027, 0.38188801995141197, 0.20874027270566797, 0.21230610713037612, 0.21203982884067085, 0.12813149759681275, 0.12800894162240273, 0.12743885599263993, 0.17607836660909493, 0.18328329673523636, 0.17517565540820046, 0.19898517186044318, 0.18190794864149118, 0.18571644497357265, 0.1724951298594355, 0.2132683295135902, 0.15996170250167874, 0.07875778437832892, 0.07767833109710776, 0.055179782497062124, 0.0869594927046754, 0.0670006579576824, 0.08711319989062483, 0.0777281476831242, 0.11026218696548806, 0.07902277436888872]}, "mutation_prompt": null}
{"id": "3f08556b-a185-4989-9418-e1b6bd65cdd2", "solution": "import numpy as np\n\nclass AdaptiveHybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.learning_rate_m = 0.02\n        self.learning_rate_c = 0.02\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            self.mutation_factor += self.learning_rate_m * (self.best_fitness / np.mean(fitness) - self.mutation_factor)\n            dynamic_crossover_rate = self.crossover_rate + self.learning_rate_c * (self.best_fitness / np.mean(fitness) - self.crossover_rate)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "AdaptiveHybridDEAMS", "description": "Introduced adaptive learning rates for mutation and crossover to dynamically balance exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.056615595643621265, "feedback": "The algorithm AdaptiveHybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.12.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.11256721918351487, 0.11492474468484215, 0.11459507683721981, 0.09546531638980194, 0.09523567270754973, 0.09527217543964472, 0.07947211060281678, 0.07947211060281678, 0.07947211060281678, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0050680811728541775, 0.0050680811728541775, 0.0050680811728541775, 0.014197694609706213, 0.007486271204382833, 0.008658986890072828, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.9908588575316772, 0.9908594571488207, 0.9908593358674996, 0.030505277410686538, 0.030505277410686538, 0.030505277410686538, 0.03619617077380499, 0.03619617077380499, 0.03619617077380499, 0.02134648432885211, 0.02134648432885211, 0.02134648432885211, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.075893114210277, 0.075893114210277, 0.075893114210277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.038884517798751794, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.12265509189606105, 0.12270341952781949, 0.12269900422598135, 0.16622276083654375, 0.16642087883809709, 0.16639304611468253, 0.1150871746835106, 0.1150871746835106, 0.1150871746835106, 0.05036965452306996, 0.04838869932544787, 0.049121619944962, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.08514577413922564, 0.07166644638110142, 0.07388768881929941, 0.07144742789364189, 0.07144742789364189, 0.07144742789364189, 0.10341627463871261, 0.10235600007505419, 0.10366962679158154, 0.10343741855107003, 0.10343741855107003, 0.10343741855107003, 0.11607669768801698, 0.11654737235339363, 0.11728415818947502, 0.1414538070162733, 0.14877410863617402, 0.1493418022910611, 0.09200263984120705, 0.08899185207288007, 0.09049721903284158, 0.05577925829827912, 0.043141305107222805, 0.05069658081841977, 0.13015560962660766, 0.11316973531560592, 0.11950776466447244, 0.07908365540335904, 0.08535772931927399, 0.09131277888923084, 0.09489738248601476, 0.09489738248601476, 0.09489738248601476, 0.1358908366803644, 0.11982516564983581, 0.17136340057723898, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.11232938452809504, 0.11232938452809504, 0.11232938452809504, 0.05355591304673013, 0.05355591304673013, 0.05355591304673013, 0.08528468162711655, 0.08507459796611816, 0.0851119162802162, 0.04948647952938079, 0.04808605574168401, 0.04829491581045908, 0.07645973960558927, 0.07645973960558927, 0.07645973960558927, 0.11274898523910448, 0.10220449693397438, 0.10139655900179201, 0.13140031586874024, 0.12689689149041428, 0.11140253867201699, 0.1246391444595707, 0.13243258910719558, 0.1461728602938318, 0.14621333386427793, 0.1468978359906119, 0.14360738769571557, 0.012744445914923519, 0.029210106549556247, 0.017512556113762234, 0.021465247319235603, 0.023465123596664306, 0.01782264616567575, 0.01295021042156308, 0.02630703686530833, 0.03181787277909587]}, "mutation_prompt": null}
{"id": "deeb7340-c5eb-4c3f-a23e-486893319db0", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.initial_population_size = self.population_size\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            # Adaptive population resizing based on variance\n            if fitness_variance < 1e-4:\n                self.population_size = max(4, self.population_size - 1)\n            elif self.population_size < self.initial_population_size and fitness_variance > 1e-2:\n                self.population_size += 1\n                population = np.vstack([population, np.random.uniform(self.lower_bound, self.upper_bound, (1, self.dim))])\n                fitness = np.append(fitness, func(population[-1]))\n                self.budget -= 1\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced adaptive population resizing based on fitness diversity to improve exploration and convergence speed.", "configspace": "", "generation": 18, "fitness": 0.24779839924896635, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.46019182989538243, 0.5780681783265089, 0.5154438267582024, 0.4208121147660865, 0.5941527515232643, 0.6427254918749606, 0.20195320548389117, 0.6264197630236725, 0.5507081416328814, 0.37019660730248194, 0.5373007725851691, 0.5178152172645696, 0.49652449449977754, 0.5144562811617668, 0.38791538578188367, 0.4487746833405014, 0.40773545585222903, 0.37012127735790945, 0.11670360382194689, 0.11426840222260648, 0.1127089149947118, 0.20324639737068018, 0.15433513337356142, 0.07697002531877006, 0.17552431763186183, 0.3856858396566052, 0.18605292781484684, 0.09995633541295779, 0.13421636012864824, 0.09053877645259467, 0.13147806440868193, 0.21036487991911768, 0.12132970357179251, 0.14422037281096034, 0.23419328286542707, 0.1726425158475311, 0.9769767430935276, 0.9805031700807656, 0.9805046024958844, 0.9894795840544073, 0.9884893596158714, 0.9894586333252717, 0.9682483085926379, 0.9636486331840209, 0.9673943703778013, 0.26562589073207377, 0.33896476250923147, 0.3362454395301061, 0.15664210803866918, 0.35467361889902127, 0.2717872584357732, 0.19002442800564057, 0.20256280625380363, 0.4025412393443786, 0.1468167844259045, 0.24473606942042925, 0.20493736675985197, 0.21360454126863848, 0.21142584132516218, 0.19202724988937925, 0.36452214423999973, 0.7278901523642323, 0.6201467494086572, 0.22136670815250825, 0.15521227710149688, 0.14959235253768344, 0.1264913170634887, 0.13348635907967432, 0.13321769445669085, 0.22222354393558041, 0.16140359967699747, 0.1553328703848107, 0.2036565660872156, 0.15334042592423125, 0.17384680933522434, 0.1699822209630838, 0.19137114045799775, 0.1515782495657344, 0.18003267990269067, 0.136955086313716, 0.14314268755248571, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.224142505552263, 0.08907060727963634, 0.10818123867385387, 0.05736834876538155, 0.08148011269532707, 0.09072171450752098, 0.09018945709162329, 0.0808402861238472, 0.040125143691046694, 0.21110690794682774, 0.10187875828978155, 0.20195709560541864, 0.061152977351535576, 9.999999999998899e-05, 9.999999999998899e-05, 0.019445449769672107, 0.002784412194969943, 0.0615089406018291, 0.24597745665936122, 0.28425063387511973, 0.2406545250374219, 0.11862465601591754, 0.2113421711086121, 0.0928723652779363, 0.060397079829592304, 0.05581331357815, 0.1657147141550751, 0.4883580902839608, 0.34097158594825483, 0.4546914959015096, 0.365986915581458, 0.349965550882115, 0.5821634229437698, 0.47832095842182865, 0.4109257783757285, 0.40224855077046695, 0.16480620722218609, 0.09289070356652751, 0.09092298112375086, 0.1491967002251462, 0.08682134721004864, 0.08503608310564992, 0.11379969366201126, 0.08264844247411307, 0.09159887461431859, 0.22621417374552466, 0.13367134648792567, 0.12632264793946302, 0.17295751803649706, 0.08604018169266092, 0.1452835085350005, 0.11077071274751671, 0.16859562389896787, 0.18139720052273278, 0.2281560727687565, 0.4356688452248544, 0.18404006005379459, 0.4439946252707069, 0.505134641963106, 0.22120835090113555, 0.3705227812947407, 0.3609669009739932, 0.42121584632232667, 0.28606229336043065, 0.09906082371501923, 0.1303704211284199, 0.35216235740544755, 0.19669172686471215, 0.2414187947493357, 0.40431332466672376, 0.08171310664665465, 0.08751386911332049, 0.1664778698291579, 0.19137899066287212, 0.2043762440033895, 0.24852202820854497, 0.20111153762843026, 0.16169873771353382, 0.19514040086333495, 0.17375071588836422, 0.20313975850692845, 0.25233014840400936, 0.1702964845976932, 0.1699077473264582, 0.2156618961433998, 0.22502337603933809, 0.18294302891039782, 0.21033777110958773, 0.1982705449513995, 0.2155277036387232, 0.16815642503308426, 0.4648464581361107, 0.7743756660277799, 0.2615933001956866, 0.1644431925399482, 0.3644040002669279, 0.1663315276615165, 0.13600264728866007, 0.13635500044877313, 0.5384099808365229, 0.21729666060999864, 0.29771001814181597, 0.17100956095734765, 0.2123707922514898, 0.20481125616866913, 0.12803790479336874, 0.12799459114410505, 0.1221798091349845, 0.17607836660909493, 0.18328329673523636, 0.17517565540820046, 0.19898517186044318, 0.18190794864149118, 0.18571644497357265, 0.1724951298594355, 0.18426368529693915, 0.15996170250167874, 0.07875778437832892, 0.07709512156851983, 0.055179782497062124, 0.0869594927046754, 0.0670006579576824, 0.08297332546729452, 0.0777281476831242, 0.11026218696548806, 0.07902277436888872]}, "mutation_prompt": null}
{"id": "b655f26a-d695-4491-8398-27100baf4407", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        for iteration in range(self.budget):\n            fitness_variance = np.var(fitness)  \n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            oscillating_crossover_rate = 0.7 + 0.2 * np.sin(2 * np.pi * iteration / 50)  # Oscillating rate\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < oscillating_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            if iteration % 25 == 0 and self.population_size > self.initial_population_size//2:\n                self.population_size -= 1  # Adaptive population size reduction\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced adaptive population size and oscillating crossover rate to enhance convergence speed and solution diversity.", "configspace": "", "generation": 19, "fitness": 0.21181862648042607, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.7445040561869503, 0.489662507728721, 0.6834390975424045, 0.91281431613405, 0.6492164805664621, 0.542419073935013, 0.7412767596915223, 0.9226024721209907, 0.39625715188790755, 0.7663595429929065, 9.999999999998899e-05, 0.21986428575268724, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.8137232357675466, 0.06443487940178416, 0.03226821851003281, 0.05474458759227341, 0.21709798803778868, 0.11981231452476981, 0.08550903893621398, 0.13838730543874733, 0.05419516186533746, 0.10876208937110388, 0.15413899385605911, 0.08411171167555154, 0.11051384994046398, 0.13049483881894752, 0.10833338148325655, 0.1145336299356624, 0.11381853344338522, 0.16572058643931764, 0.15271904751884413, 0.15231921686302885, 0.1792562176562622, 0.9458329056546279, 0.9649948602354286, 0.962160644056651, 0.9687681108152916, 0.9698220724831129, 0.9698673632801612, 0.9694786374522548, 0.9716093909624015, 0.9760541015973137, 0.25325620535160254, 0.08668535642550601, 0.08658492216933267, 0.31067013575294955, 0.1055005139346562, 0.1391319921692935, 0.22584906886853684, 0.114933093134449, 0.14087740253198822, 0.17054232347714038, 0.1400487184928294, 0.13109478894176263, 0.19343268545444858, 0.18625933679042883, 0.19115436108940453, 0.11586103588215846, 0.137857178352236, 0.11605211972502527, 0.13938684858907457, 0.1706006467084732, 0.27705696240281485, 0.13672609191337104, 0.14728361594810635, 0.1853143780088634, 0.19574870876951445, 0.1445396468885971, 0.05061216833178839, 0.05514106967299193, 0.051816669951924466, 0.03206602841684725, 0.13907208927318282, 0.13255869589817015, 0.13125919806161856, 0.12937004487399517, 0.129160690353175, 0.13742955605488827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002626359078965468, 9.999999999998899e-05, 9.999999999998899e-05, 0.03264794010839156, 0.062458429685146255, 0.09653030112895578, 0.14554993083051215, 0.09189405396721162, 0.07407901845912279, 0.06818831224523292, 0.03887025943463884, 0.06341534905897739, 0.05654992014528637, 0.06661155965333088, 0.03776177279095716, 0.05847655466463508, 0.10870745730074816, 0.050669818998253735, 0.0853190261549942, 0.07923627884222262, 0.08154630312999656, 0.12968464298208515, 0.07624847658292222, 0.23581894348793453, 0.15176818112527202, 0.07971884391696782, 0.09583944801698285, 0.16479792467993104, 9.999999999998899e-05, 9.999999999998899e-05, 0.0056309928784363805, 0.2522199897388625, 0.05784488266560062, 0.43152002768634334, 0.4820962763966753, 0.4290269968227117, 0.513770953915403, 0.24456361339999566, 0.37447199601906955, 0.33419455098865636, 0.47557495685332196, 0.4454512724435824, 0.09026072993623202, 0.09100754902244912, 0.09048696240719911, 0.06857559803716029, 0.09754618084773015, 0.07457383205618184, 0.08346011228920103, 0.09593602761535336, 0.08154247895609168, 0.1598645921674946, 0.14949952386699983, 0.14174227839925058, 0.169838718840557, 0.13950324651222656, 0.11407962702106511, 0.35180815629436024, 0.14293671784491324, 0.13552204941641743, 0.19468427064443528, 0.17359666683714436, 0.1974861051256287, 0.27193316178112326, 0.21277838872522548, 0.22090994575105538, 0.19260621292390046, 0.29323729532014664, 0.279711058936566, 0.16816078125604017, 0.21306500375992832, 0.09049458549353984, 0.14695208030386053, 0.19375248254513433, 0.18660777982044807, 0.3206071467988798, 0.093129867246315, 0.09197084604145944, 0.17143759094641586, 0.1703383720672733, 0.2288645386746483, 0.19991592846909623, 0.21651799393179194, 0.19337638146735348, 0.21798070438383932, 0.1624404611088759, 0.19444516357862052, 0.22295944703476311, 0.24168292531985902, 0.17838912844700605, 0.22336117964946312, 0.19721540244917046, 0.1881840820520605, 0.20284255843911347, 0.19510983960415007, 0.2096483581505174, 0.677421117025071, 0.16622566381483572, 0.16624934753611176, 0.16647563022016654, 0.16435117445382608, 0.16464351098883012, 0.1625572676678223, 0.17787386322508336, 0.17756480175355904, 0.16718874071545942, 0.15934947017626655, 0.16927327419390936, 0.20310931909387608, 0.22444935135913158, 0.22270790368052973, 0.13337514314816656, 0.15785166263992778, 0.14810046349473327, 0.19867539372882204, 0.1840190679727569, 0.18148827103502274, 0.17462480457922902, 0.164143817835689, 0.1886037159757067, 0.14290536031594403, 0.19746396456581317, 0.17586254679669022, 0.09376411206668922, 0.06064536222228267, 0.07338835557268752, 0.08113264234081707, 0.07922373083144596, 0.06200077505012325, 0.06704592680449062, 0.07798032424471657, 0.07355842610842478]}, "mutation_prompt": null}
{"id": "5ce96838-4c38-44b5-af2e-5b93f5eafa25", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (0.9 ** _)\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced local search by introducing adaptive step sizes, improving exploitation capabilities without exceeding the 1.4% code modification constraint.", "configspace": "", "generation": 20, "fitness": 0.28763915677331725, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8744339648665462, 0.8920944994460646, 0.8073280724434998, 0.8873012127679684, 0.8750168594457228, 0.8390770415455413, 0.9022223794777611, 0.8939930241804367, 0.8229903740645728, 0.7896803964875658, 0.3983968212502832, 0.8521970977376874, 0.7607407998071227, 0.8141712902696066, 0.8154745424059642, 0.810198928923552, 0.7238281431071804, 0.8168433772000055, 0.0795251209127702, 0.09203526372521809, 0.10998663514604756, 0.1824632338067389, 0.22554151528940936, 0.21752727454561982, 0.1815482500738379, 0.06151216124205472, 0.7786802122554761, 0.05031706505702005, 0.13112084169625382, 0.03465742826075524, 0.19412554248105995, 0.14124286068856673, 0.15660281791825126, 0.15530072716505605, 0.15942308725425425, 0.715956534163493, 0.9822170533427518, 0.9583552727718042, 0.16370906533930096, 0.9716957198263967, 0.968845521559562, 0.9688558216193343, 0.9766885919508375, 0.9764656760931313, 0.9764804789550369, 0.557509272901159, 0.6339718181947043, 0.6955220554793236, 0.37724520924647875, 0.27405933792858816, 0.3754297365168433, 0.2861661532758637, 0.21415994344289224, 0.5463986157337067, 0.30417953854824187, 0.16413977701739402, 0.11276437414440865, 0.2114785720820478, 0.3685273080548781, 0.16200684850178115, 0.37205997328723306, 0.36310062212425576, 0.17470426717648901, 0.21249707463432388, 0.17196913827759797, 0.19093553371466743, 0.167254355981576, 0.1527639396229581, 0.1519528376561362, 0.24070215802858042, 0.24665356885378797, 0.2954947990596265, 0.12280849741917521, 0.13948831499297343, 0.1594619177422919, 0.17408253343808733, 0.19950578990390144, 0.1624271988278717, 0.2137870499062331, 0.16584343285291447, 0.18864846543886116, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0024685089957907635, 0.0875504057451193, 0.14753836035208245, 0.12904705054877408, 0.053638164485306894, 0.060608770986500304, 0.06138891235678745, 0.06646385251662323, 0.15343155866994407, 0.1271963691599609, 9.999999999998899e-05, 0.07172603742669048, 0.07416382566708157, 0.06762467854897658, 0.06690246252345644, 0.1635614220098296, 0.008165593937295879, 0.010821278868876294, 0.014991136191599641, 0.012129364548473354, 0.25331362967739857, 0.24698606909769782, 0.07660413298740254, 0.17838348558056516, 0.17964931034065468, 0.16977223135244146, 0.11892074700072319, 0.057186350271486996, 0.4676472821457156, 0.4849524236839776, 0.5612087290640855, 0.19107010525017143, 0.6183192482852644, 0.4942579728279569, 0.534219772138177, 0.5725498564934648, 0.61734353620573, 0.08238562427101792, 0.11694402744666454, 0.10765853848860674, 0.14100859758764384, 0.06953949280451854, 0.12606235272302035, 0.07350989661207874, 0.1316743728554577, 0.09512640061149646, 0.150559400151825, 0.15160699107039677, 0.19190956599078257, 0.14128364038122887, 0.10219597317328322, 0.2137848914539222, 0.13271036595131191, 0.2757383891053091, 0.18497485612417142, 0.13394345221526383, 0.14295501940478206, 0.1252014476285498, 0.3881620722552933, 0.274913981633115, 0.28820150985265014, 0.18182109819279824, 0.4001899576319613, 0.23673768690484354, 0.17037724713568891, 0.15819690397060548, 0.1556995095897742, 0.33021764629505734, 0.22775701166016693, 0.3213850845619227, 0.2302171874600737, 0.14025693531529648, 0.18392374235636366, 0.20116013284484924, 0.29510667885847786, 0.21419734157950665, 0.2391988665504109, 0.205745955373973, 0.20178368195578655, 0.2054288638062869, 0.189777405545421, 0.20441104829462597, 0.22243514344261517, 0.18799185920580164, 0.2081486877134896, 0.19978444367200932, 0.1718628757477385, 0.21294619353936906, 0.21503662076962415, 0.2204651567691922, 0.22076509658605403, 0.8744372521205538, 0.1537518754228946, 0.15379174174242727, 0.37092053176626794, 0.3603530061867758, 0.38461045910359126, 0.8848302868164636, 0.48458144477733844, 0.7263188223102446, 0.16710649151662926, 0.15642618655279872, 0.15655232730593138, 0.21027582308937365, 0.2091027832862591, 0.20824296732315595, 0.525471116608591, 0.14930808432578557, 0.14904435471642918, 0.19593099242086331, 0.19450162388703085, 0.1794025651178155, 0.18812095864059986, 0.18323569202386603, 0.17121820534243615, 0.17063887284277168, 0.1950365972127277, 0.20942954022521976, 0.10590210893891927, 0.08232868134965465, 0.0840869196702757, 0.0928095531189167, 0.0797074683365212, 0.07961412409746349, 0.10129096001930504, 0.06775423117901247, 0.08957502600239076]}, "mutation_prompt": null}
{"id": "d213f968-d615-4fc0-878d-2f22064d52ee", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                adaptive_factor = (self.best_fitness - current_fitness) / self.best_fitness\n                step_size *= adaptive_factor\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced adaptive step-size mechanism in local search for improved convergence during exploitation.", "configspace": "", "generation": 21, "fitness": 0.25274236743646017, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.6074909998484739, 0.8246863864355337, 0.8590953374627416, 0.8343854223213352, 0.8886665238588735, 0.6716854060454633, 0.7871808181806239, 0.7887989699693584, 0.6226177186204274, 0.7716992313887163, 0.7765827039293302, 0.7721963018112719, 0.6467113661646793, 0.7169650198440036, 0.7606404850580983, 0.7637762378912455, 0.5885287061269224, 0.7355002655137926, 0.11450642064251237, 0.14210929550079487, 0.11006387011068075, 0.13113203932502293, 0.18086505123744379, 0.176987242694984, 0.14161313739886372, 0.181670389841614, 0.10897717979586374, 0.09063262091563629, 0.09301934636738018, 0.04489031618916939, 0.17815986816639617, 0.15525977519932643, 0.17016075722505375, 0.14140556111921865, 0.11334717878917822, 0.10997320003666666, 0.9730311999123277, 0.9730349101204692, 0.973034373985459, 0.9794656155075323, 0.97241312386483, 0.9724130087255776, 0.9608502415998446, 0.9608002983940358, 0.9608077396320626, 0.5127348047616815, 0.4503112320634536, 0.36538589210208716, 0.3397903976175223, 0.13476064593549364, 0.37096078765400553, 0.47361106525219265, 0.2470459006079111, 0.2062809361803566, 0.2302630832478989, 0.21564052402823175, 0.10691888940013505, 0.2676947747873478, 0.34528848937651513, 0.27287687331915256, 0.28555102190366155, 0.22356745144998147, 0.17287648466259709, 0.20281588725629307, 0.17589658560476185, 0.15917987005986745, 0.18971725868867573, 0.13869711776372573, 0.13541059400412359, 0.2749940660964748, 0.21741827626332033, 0.1238594906868038, 0.13431941730349517, 0.16251959924372572, 0.15598247769574558, 0.08661707350549219, 0.26528278881542466, 0.500253209800674, 0.1413351407516369, 0.1395777095755506, 0.1260425786417242, 0.02356754115784565, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11728493700952347, 0.06766103886870112, 0.07067018899564992, 0.03440275496486733, 0.040720000974398096, 0.032226363919719225, 0.073581481605423, 0.06921605469274905, 0.09578155068908523, 0.036086896709198846, 0.00042283403664222785, 0.06118745036545148, 0.1057766360325848, 0.015525517112409237, 0.10231966239855306, 0.0236524513171531, 0.031238818253003786, 0.08725663636186787, 0.27201594727169853, 0.2556482527440255, 0.20139207901891298, 0.2170722193633996, 0.2055610030842463, 0.11415268088640784, 0.08642983774354851, 0.11385851147017334, 0.1885145112541705, 0.24286355256586412, 0.23715320122321182, 0.23885210540073354, 0.6719339806515608, 0.20544264486231578, 0.20537803489097417, 0.4876884028721262, 0.3931721546243858, 0.6059798294115258, 0.06964424987258822, 0.16414261477586678, 0.09623785150169728, 0.08848484503802079, 0.11206498297769318, 0.08402420131246913, 0.10260227467794758, 0.10652976503688205, 0.05694058720742157, 0.15509693542445824, 0.13289275334506312, 0.09634479944177743, 0.13691818319875693, 0.0818399806072091, 0.1367559777232864, 0.15472980498580602, 0.10714499670468991, 0.08990322876160517, 0.16608598462574897, 0.1499441625766278, 0.14207272555773653, 0.34509754473418586, 0.19878247437474805, 0.22390854872756427, 0.18512470391254832, 0.3627446725571126, 0.2706476528525914, 0.16197130317218378, 0.20183766748988297, 0.2522911869215676, 0.26686325995023497, 0.25429475925512357, 0.19777551272259908, 0.14342369072594174, 0.10022160415777193, 0.19845913805371806, 0.2053095499179064, 0.17419176789503943, 0.24455452268165556, 0.2361977351412159, 0.25592831324212884, 0.14605142368694546, 0.22774436784061036, 0.17361123508510823, 0.17534176273955526, 0.18123249862711233, 0.19061049303319244, 0.19327693386916434, 0.18537877031056083, 0.20925544872499946, 0.1828227611849611, 0.22247104282438845, 0.22163837758871607, 0.20392810599642042, 0.16346069445322442, 0.11108590555975428, 0.8502275895033418, 0.1802134134351583, 0.2648980728267085, 0.19065122058522355, 0.15859464565947823, 0.1326008976037618, 0.13306392258224664, 0.1521652052865622, 0.20729923872841705, 0.200267782374841, 0.18966886230619384, 0.20972893850414764, 0.20543692154780602, 0.1030775053799271, 0.10766502410500489, 0.10822146644492892, 0.2024179619489972, 0.1698908828023712, 0.19028457899017615, 0.17686218500376782, 0.18410222243321173, 0.22770516845514588, 0.1549032193551082, 0.20372498847773468, 0.1733891022022701, 0.07376446717594931, 0.0979194709097061, 0.07345766542316656, 0.07605054277384804, 0.09341006460987555, 0.0738643794255609, 0.05330667508101128, 0.0740342176483284, 0.08974870764094833]}, "mutation_prompt": null}
{"id": "e1cfb8c7-3d5a-489e-82ed-0a5079583204", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial, trial_fitness)\n\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution, initial_fitness):\n        current_solution = solution.copy()\n        current_fitness = initial_fitness\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                step_size *= (1 - current_fitness / self.best_fitness)  # Adaptive step size\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhancing exploitation by introducing adaptive step size in local search based on fitness improvement for faster convergence.", "configspace": "", "generation": 22, "fitness": 0.2537676329331411, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.610309020392285, 0.8289829772148489, 0.8623280464343988, 0.8381927131563806, 0.8911507769425493, 0.6803954331838721, 0.7924868130216496, 0.794035792932081, 0.6252974831967378, 0.7763830467077435, 0.7818413775017659, 0.7770289905813159, 0.6554396091003911, 0.7235028462592477, 0.7659318247590524, 0.769186845537236, 0.5954732037360538, 0.7414887501075658, 0.11461631285298735, 0.14230651391574467, 0.11026350621627479, 0.13126695942188926, 0.18119962958552382, 0.17739423232282514, 0.1418127039265461, 0.18199796600420381, 0.10915759515430579, 0.09072691948024858, 0.09316123007006338, 0.044931438789901024, 0.17845044120917297, 0.15543732419459044, 0.17061275749311866, 0.14162945627678514, 0.11352767380166406, 0.1100847805459747, 0.9736917212446333, 0.9736953288909815, 0.9736948076159497, 0.9800359954582891, 0.9732230645758309, 0.9732229840109585, 0.9619728577458293, 0.961924238520302, 0.9619314779826892, 0.5237129413436301, 0.45389165623699346, 0.36977563554967363, 0.3445265132680273, 0.1352050719675002, 0.3860358394705149, 0.4837801808845985, 0.24992612226001498, 0.20938705828587023, 0.2305696645946007, 0.21593257165938862, 0.10702171846756647, 0.2680422228134054, 0.34554823170054516, 0.27312000037131934, 0.28598080785396374, 0.22379228722966304, 0.173005210650522, 0.2038197892712963, 0.17668738869941425, 0.1597804545153766, 0.19024488333513467, 0.1391447007267319, 0.13597263828012252, 0.2758340591563533, 0.21769518972640878, 0.12415131664426904, 0.13483837881333716, 0.16283953244290095, 0.1564555091030505, 0.08678461637467061, 0.26835941124170926, 0.5036452420783497, 0.14250273280452852, 0.14031431470709455, 0.12633338452492937, 0.02364437195828928, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11741827019966589, 0.06782377209753199, 0.07086378460320664, 0.03443367858080515, 0.040778845992949564, 0.032249440835823595, 0.07372617511750346, 0.06936270467628092, 0.09605781450650497, 0.03631229619853327, 0.0004354941949419322, 0.06210716173903841, 0.10690775447377932, 0.015615579984800343, 0.10347908382639837, 0.02386618395710083, 0.03140639327923256, 0.08772191666170126, 0.2733238907461444, 0.25733418786887163, 0.20250921422508783, 0.218498383134335, 0.20735692483929613, 0.11466074575695351, 0.08720174682531201, 0.11424932707070479, 0.18952010485302384, 0.24295211512938653, 0.23733204285422949, 0.23899021207569826, 0.6744004357939781, 0.20557441247304165, 0.20551179064335434, 0.49050628162283116, 0.394609262234045, 0.6094493028956437, 0.06969441756897343, 0.164215563906139, 0.09626509945276396, 0.08859731678196281, 0.11218341168946333, 0.08419147928910298, 0.10282060521391123, 0.10676061408132487, 0.05709377980591035, 0.15519855783150183, 0.13293111949540526, 0.09636409622091013, 0.13700896916196814, 0.08184547744150261, 0.13679566835982737, 0.15478188887651234, 0.10716365147298035, 0.08991269944096691, 0.16624593203240734, 0.14998738605727935, 0.14210072344406144, 0.3454745397723973, 0.1988569435498564, 0.22407314150448676, 0.18520970956717708, 0.3631693541143929, 0.27084517242800255, 0.16216906086778105, 0.20212462893312755, 0.2526912617183098, 0.2674757484105881, 0.25473792247655525, 0.1980017785280449, 0.14347827560161508, 0.10028616473562557, 0.1987296623764382, 0.20551589197318143, 0.1745082644947119, 0.24475128729029383, 0.2367998761889195, 0.2561432667216499, 0.1460803156219601, 0.2279525168111327, 0.17363559916196847, 0.1754331687536329, 0.1814265290359266, 0.1908122259637569, 0.1934473667657537, 0.18550467208448407, 0.20957065703066502, 0.18306961274469014, 0.2226620191109221, 0.22184988715244303, 0.20409260338344837, 0.16352506558884528, 0.11115373862383826, 0.8538002908615439, 0.18029304682551828, 0.26536328201691717, 0.19079068145273237, 0.1586475217735006, 0.13274102102648355, 0.13318419908214096, 0.15224549864333947, 0.20750216408203714, 0.20059075134910775, 0.19041024425640685, 0.2098884245196425, 0.2057317108077894, 0.10314097649219311, 0.1077365439941923, 0.10827712932450939, 0.2024680928916156, 0.16992832483994558, 0.19035510249446652, 0.17687938034884976, 0.18414288211656216, 0.22792440145153237, 0.15492106827234964, 0.20442952284412041, 0.17342326954269116, 0.07393765940536667, 0.09804516515833217, 0.07362034280225449, 0.0762082084523128, 0.09356200341468301, 0.07392015379578354, 0.05333175056553752, 0.07406998551696087, 0.0898076773736095]}, "mutation_prompt": null}
{"id": "f2047365-7d5f-4d61-8260-fbd7c8d36f10", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            best_fitness = np.min(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                beta = np.random.uniform(0.5, 1.0)\n                mutant = np.clip(a + beta * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced mutation strategy by utilizing fitness-based scaling to improve exploration and convergence balance.", "configspace": "", "generation": 23, "fitness": 0.25545722181027886, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8235580513012621, 0.8235580513012621, 0.8235580513012621, 0.5074671637590364, 0.5074671637590364, 0.5074671637590364, 0.40061060272001203, 0.40061060272001203, 0.40061060272001203, 0.5784136018898774, 0.5784136018898774, 0.5784136018898774, 0.49200862665067147, 0.49200862665067147, 0.49200862665067147, 0.2775104195282687, 0.2775104195282687, 0.2775104195282687, 0.161481175830553, 0.161481175830553, 0.161481175830553, 0.17612611917102472, 0.17612611917102472, 0.17612611917102472, 0.12982360793846415, 0.12982360793846415, 0.12982360793846415, 0.06284576059939828, 0.06284576059939828, 0.06284576059939828, 0.15077896762356446, 0.15077896762356446, 0.15077896762356446, 0.16920636626179753, 0.16920636626179753, 0.16920636626179753, 0.9792316540808504, 0.9792316540808504, 0.9792316540808504, 0.9778696327386794, 0.9778696327386794, 0.9778696327386794, 0.9670148280108788, 0.9670148280108788, 0.9670148280108788, 0.22751943501041527, 0.22751943501041527, 0.22751943501041527, 0.27666672175616835, 0.27666672175616835, 0.27666672175616835, 0.11511274091485935, 0.11511274091485935, 0.11511274091485935, 0.17045606765814214, 0.17045606765814214, 0.17045606765814214, 0.16150000473480253, 0.16150000473480253, 0.16150000473480253, 0.8640027323318539, 0.8640027323318539, 0.8640027323318539, 0.15812624389111518, 0.15812624389111518, 0.15812624389111518, 0.13228369876259116, 0.13228369876259116, 0.13228369876259116, 0.1320172649178858, 0.1320172649178858, 0.1320172649178858, 0.14787852193041995, 0.14787852193041995, 0.14787852193041995, 0.2509241633646777, 0.2509241633646777, 0.2509241633646777, 0.1328194507397764, 0.1328194507397764, 0.1328194507397764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1355858345150811, 0.1355858345150811, 0.1355858345150811, 0.06690861547301885, 0.06690861547301885, 0.06690861547301885, 0.10094428534758138, 0.10094428534758138, 0.10094428534758138, 0.07274568901800416, 0.07274568901800416, 0.07274568901800416, 0.0754339730536181, 0.0754339730536181, 0.0754339730536181, 0.0468380457691121, 0.0468380457691121, 0.0468380457691121, 0.1247315773198221, 0.1247315773198221, 0.1247315773198221, 0.11132101678987616, 0.11132101678987616, 0.11132101678987616, 0.0713627725796856, 0.0713627725796856, 0.0713627725796856, 0.4755914026200687, 0.4755914026200687, 0.4755914026200687, 0.4181251029179812, 0.4181251029179812, 0.4181251029179812, 0.4139408769537398, 0.4139408769537398, 0.4139408769537398, 0.14125626983488515, 0.14125626983488515, 0.14125626983488515, 0.13870255622927596, 0.13870255622927596, 0.13870255622927596, 0.07827516466591333, 0.07827516466591333, 0.07827516466591333, 0.17292146801308883, 0.17292146801308883, 0.17292146801308883, 0.1611112683129149, 0.1611112683129149, 0.1611112683129149, 0.10493645730412537, 0.10493645730412537, 0.10493645730412537, 0.2876742651450509, 0.2876742651450509, 0.2876742651450509, 0.43924970016790577, 0.43924970016790577, 0.43924970016790577, 0.14107886699026118, 0.14107886699026118, 0.14107886699026118, 0.21742903177452, 0.21742903177452, 0.21742903177452, 0.2392500000385086, 0.2392500000385086, 0.2392500000385086, 0.24643473078473288, 0.24643473078473288, 0.24643473078473288, 0.19562986272332838, 0.19562986272332838, 0.19562986272332838, 0.2591156857443486, 0.2591156857443486, 0.2591156857443486, 0.21469968484276902, 0.21469968484276902, 0.21469968484276902, 0.21001743391828576, 0.21001743391828576, 0.21001743391828576, 0.2537872868774391, 0.2537872868774391, 0.2537872868774391, 0.2350288131965924, 0.2350288131965924, 0.2350288131965924, 0.9339172848852633, 0.9339172848852633, 0.9339172848852633, 0.46892783854397324, 0.46892783854397324, 0.46892783854397324, 0.11262422735560251, 0.11262422735560251, 0.11262422735560251, 0.21320350984023495, 0.21320350984023495, 0.21320350984023495, 0.21324939347977612, 0.21324939347977612, 0.21324939347977612, 0.15525089071813525, 0.15525089071813525, 0.15525089071813525, 0.18039742575411366, 0.18039742575411366, 0.18039742575411366, 0.1870122298738679, 0.1870122298738679, 0.1870122298738679, 0.17847939880249009, 0.17847939880249009, 0.17847939880249009, 0.06721902383615874, 0.06721902383615874, 0.06721902383615874, 0.11501517535893468, 0.11501517535893468, 0.11501517535893468, 0.0939422088529478, 0.0939422088529478, 0.0939422088529478]}, "mutation_prompt": null}
{"id": "eab5eb83-eb82-496e-90e1-8fc5fc8bdc40", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)  # Calculate fitness variance\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))  # Dynamic adjustment\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            if self.budget <= 0:\n                break\n            adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.01 + 0.09 * (1 - current_fitness / self.best_fitness))\n            selected_dims = np.random.choice(self.dim, min(self.dim, 3), replace=False)  # Select a subset of dimensions\n            for d in selected_dims:\n                if self.budget <= 0:\n                    break\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced local search by incorporating adaptive step sizes and selective dimension updates to accelerate convergence.", "configspace": "", "generation": 24, "fitness": 0.27443486419746776, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8939639642105739, 0.9309197099736044, 0.9017798500334342, 0.9162174228194563, 0.8839034989701425, 0.9075121301544478, 0.8505286631410631, 0.19182812353585776, 0.752250776358194, 0.8446791360809012, 0.7772445271954889, 0.10468345557633851, 0.8609384519346809, 0.8455514829644601, 0.8192700893549131, 0.7894770565620071, 0.8248923474995369, 0.8490284398334591, 0.11168746817999786, 0.12612133834269768, 0.13522048880081472, 0.14760388918676925, 0.15869357586494715, 0.15877099313008836, 0.13435919111051442, 0.10552848520445313, 0.16560015777698534, 0.15392895339882995, 0.06884646645164372, 0.03098834489893365, 0.11931579772361078, 0.1874621695463905, 0.15980363626538274, 0.18264756512461267, 0.10312914415791585, 0.1545164236823401, 0.9806666831425778, 0.9809470556979332, 0.9809466630486924, 0.9721138630628352, 0.9707172901121702, 0.9720668550264964, 0.9731273344407401, 0.9815597624916929, 0.9712928705083305, 0.7050637586556798, 0.5400391319324996, 0.6629844183304133, 0.5073986076378498, 0.6208815233708954, 0.7103386263786573, 0.417628335171763, 0.7153755791231748, 0.5262363671678274, 0.22069902776245232, 0.31684275619428803, 0.1676488625664624, 0.21958429553616465, 0.2192247245236031, 0.17422150421207427, 0.3434656652631568, 0.3002622661113652, 0.318044394311103, 0.21500795839926234, 0.12542526706533008, 0.15936155166769272, 0.1957616867060118, 0.15608257394150626, 0.16270044097793124, 0.32485024831375964, 0.15181078989369745, 0.12847016964932167, 0.17952740049602012, 0.17864482021312555, 0.14601126994428537, 0.1728567234662436, 0.19757761582584277, 0.14902509289759713, 0.2398201658786, 0.205164547441276, 0.2070250394355122, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.129373220123295, 0.18169385296551877, 0.07847364989378625, 0.06558408382539216, 0.08036662662940941, 0.06293880597030843, 0.12189068390024949, 0.13205780420245739, 0.07095164199892245, 0.12828125762966702, 0.2687513684882853, 0.1900770291924383, 0.06706507860012212, 0.07715116912363351, 0.07778156058522367, 0.03484626391704426, 0.09640148802942672, 0.06951196882710808, 0.043391354648697034, 9.999999999998899e-05, 9.999999999998899e-05, 0.1795531547146726, 0.027924548673218252, 0.1371099829313378, 0.09056921053306999, 0.3525867195814454, 0.24513515182372803, 0.5080727447340625, 0.5275415960538088, 0.5139234300601787, 0.4299544802283223, 0.11389575539350139, 0.11377191667772002, 0.4979699393663003, 0.49293554067804846, 0.5503696836315402, 0.19468109383115217, 0.1272607479913811, 0.16072501600093614, 0.16876664993956114, 0.10856838799960244, 0.09059438560722466, 0.1043820069917718, 0.12675201562464733, 0.08208670051985723, 0.21101049771397007, 0.17473363671176534, 0.16677169023286076, 0.15964646690240092, 0.17229863076892338, 0.09101952947438752, 0.17693973893817205, 0.11812216643332485, 0.1084671372304189, 0.13712349887311137, 0.12800240675498276, 0.2971414399577782, 0.28768473573054576, 0.49614482886950095, 0.3050466765359967, 0.1803669620718643, 0.13460827676482645, 0.3685055319233518, 0.15267651812281036, 0.21480937581695436, 0.16410390235664363, 0.19084477969210467, 0.25687263340196653, 0.17534284812219125, 0.16722131042902333, 0.3106274790407201, 0.27557284938643534, 0.22692862806087588, 0.17954369117835012, 0.18425039196027726, 0.23126204131004147, 0.23709141331179173, 0.20033216249002805, 0.20685320859237177, 0.22351621251461606, 0.1676633079221279, 0.18932260736733897, 0.22359715084833864, 0.2523626586495632, 0.21013316947735972, 0.22405794806608703, 0.8448818639688632, 0.22661656194437174, 0.18949219111293958, 0.22378179850018987, 0.1995831781392663, 0.14214066877833498, 0.14213928908982032, 0.16813245069694005, 0.16899976169416275, 0.1693160647738292, 0.1360721991884326, 0.10890217355510445, 0.10924589413423169, 0.1680210741249295, 0.1680233454470994, 0.11696681787812324, 0.1983699193608076, 0.16802258447178497, 0.16713787375034939, 0.20723718184623707, 0.1045031928929182, 0.15384526678555854, 0.1777540631454847, 0.1841633470033195, 0.20478665042581334, 0.2037489812541331, 0.19139526200852597, 0.2210063197066997, 0.19449041503977837, 0.15743232647924832, 0.19567118504950787, 0.077113904237468, 0.06816432433622688, 0.08365259190501328, 0.052265900398774656, 0.056523562982415565, 0.048617965971566646, 0.09017592527866658, 0.09043621740345986, 0.08426566470895869]}, "mutation_prompt": null}
{"id": "8607ba57-8d93-4a6b-90c1-a6f7e155cc2b", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = np.random.choice(self.population_size, 5, replace=False)  # Tournament selection\n                a, b, c = population[np.argmin(fitness[idxs[:3]])], population[np.argmin(fitness[idxs[1:4]])], population[np.argmin(fitness[idxs[2:5]])]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced selection strategy by introducing tournament selection to improve convergence speed.", "configspace": "", "generation": 25, "fitness": 0.07118170924726941, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.06.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.17055917718699765, 0.20713982406099196, 0.16812642958577817, 0.13200421769044646, 0.12598629541794848, 0.1268244444818234, 0.19391731373863175, 0.1216294114259504, 0.12162610104606664, 9.999999999998899e-05, 0.04317128939576864, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042163492278369685, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04721745363196206, 0.041975144763773065, 0.03630659881798115, 0.056722875264724415, 0.03140817086049663, 0.03147225267461018, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02380831368419689, 0.01570985128200786, 0.015039837632250586, 0.03824672568817222, 0.04261066194031338, 0.043254008820702294, 0.17001401178693942, 0.1700086861645035, 0.17000949112577224, 0.0800383265055239, 0.07976948746574486, 0.07980854088913714, 0.07969529050677704, 0.10924179682554003, 0.10904336178614882, 0.08207391236762884, 0.08203144629389714, 0.082037571786025, 0.06175353364245162, 0.03903453331293438, 0.03394782454661638, 0.074938034501286, 0.08680743706536365, 0.08797550689297828, 0.05030695561571319, 0.04610703633468893, 0.04610868559838166, 0.12362242903094067, 0.1329171991357031, 0.1329171991357031, 0.03693428244972097, 0.07130481978778624, 0.06814972980663991, 0.04460627370693915, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0056612049441315815, 0.03945465584777341, 0.03529560943175036, 0.08200149070164187, 9.999999999998899e-05, 9.999999999998899e-05, 0.0053969441862921075, 0.11941858275865247, 0.007438101751191417, 9.999999999998899e-05, 0.0945899178702937, 0.06136616541252482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05952518945751761, 0.05952518945751761, 0.05952518945751761, 0.03637706565193943, 0.035798136624648924, 0.03627197042557895, 0.06384431713901373, 0.1115471775989052, 0.08120877761025602, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022014010452050536, 9.999999999998899e-05, 0.12511143207135245, 0.1260767037033147, 0.1259399761635943, 0.10974418219179027, 0.12702190454067463, 0.11103367474018833, 0.1351023529687051, 0.11517566326669182, 0.11517566326669182, 0.048481653338139585, 0.04773796093356408, 0.040383058941768635, 0.029252136214845126, 0.0491191835151743, 0.02892838757490912, 0.03137362196292037, 0.05885437829489182, 0.07300741663736665, 0.11136775032225144, 0.10726530981922933, 0.11610957419577372, 0.06596994129664435, 0.11610068340749535, 0.10978868957180221, 0.14264922626779641, 0.12043330096922578, 0.13553955758777936, 0.1410478134238945, 0.13010457033654643, 0.11554515190658954, 0.14253264510021835, 0.20216892714625023, 0.10991143101482537, 0.13249985975662426, 0.13237448763589732, 0.12860911792171337, 0.08785635817152393, 0.11687102950372297, 0.10669409659934592, 0.056699408068004775, 0.05069247541022448, 0.052819354970545795, 0.03269457245119922, 0.05642291754035955, 0.11466323359079322, 0.09214388479045865, 0.11302702432506573, 0.08597530971778466, 0.12117654285260704, 0.09934971857841501, 0.16287423153616087, 0.1296969495068817, 0.15192013334144194, 0.12281053073289472, 0.15559141667629794, 9.999999999998899e-05, 0.16683998665760646, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16799882897953522, 0.1642142809649384, 0.16344117734630803, 0.09122933893876484, 0.09104866313656768, 0.09108944459352064, 0.1435029650414561, 0.11262530092490197, 0.11240113049506506, 0.10761879350755577, 0.1087461265226588, 0.10859250876949778, 0.09638961508009747, 0.09638961508009747, 0.09638961508009747, 0.07655209194228174, 0.07655209194228174, 0.07655209194228174, 0.11633118139082321, 0.13488620524469985, 0.13561755981344636, 0.15111356368729012, 0.14940674877369298, 0.1466734783465452, 0.17538767921139364, 0.2328956541494106, 0.15129472470747185, 0.16666259937344108, 0.1539800179172618, 0.13572946825761267, 0.037129350966540686, 0.040639811589132435, 0.03717655097343375, 0.029305321458568456, 0.01968693681024747, 0.018501733760739603, 0.07390898457721018, 0.03688866334583818, 0.0868597275223627]}, "mutation_prompt": null}
{"id": "6238c984-1cf4-4f6d-b7f3-1a2537acd5f8", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            if _ % 10 == 0:  # Adapt population size every 10 iterations\n                self.population_size = max(5, int(self.population_size * (0.9 + 0.1 * np.random.rand())))\n                population = np.pad(population, ((0, self.population_size - len(population)), (0, 0)), 'wrap')\n                fitness = np.pad(fitness, (0, self.population_size - len(fitness)), 'wrap')\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced adaptive population size adjustment based on convergence progress to enhance exploration-exploitation balance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"index can't contain negative values\").", "error": "ValueError(\"index can't contain negative values\")", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {}, "mutation_prompt": null}
{"id": "0a28d204-587f-42ec-8e0e-60cc7fe6a194", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial, fitness_variance)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution, fitness_variance):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            step_factor = 0.05 + 0.05 * np.tanh(fitness_variance)\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * step_factor\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Improved exploration by incorporating adaptive step size in local search to balance exploration and exploitation.", "configspace": "", "generation": 27, "fitness": 0.2672856301783045, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8769464316150225, 0.8952653110512836, 0.8902042569017051, 0.1617909534175771, 0.2663680111265029, 0.2835304686038924, 0.7548393349096184, 0.8135617705133862, 0.8518613690783138, 0.7158710317424195, 0.8117269695709006, 0.7780587247541516, 0.7536573483185635, 0.7038998544901037, 0.4870531889756877, 0.6136030244348478, 0.6964429647032038, 0.8221361157922755, 0.1002043576383379, 0.0738678659514368, 0.05886420379766766, 0.1287884865448854, 0.1405811360913105, 0.08993830711652628, 0.15087583580268438, 0.19573957409737686, 0.14532261041290406, 0.05645337058249955, 0.03476187267541864, 0.08014856713246465, 0.16734787221533953, 0.13982711776112078, 0.16132486397834167, 0.14659732492740496, 0.13188614343703542, 0.136657234691397, 0.9786641050536363, 0.9850581068553175, 0.9850638466244188, 0.9716875865910237, 0.9824699094384957, 0.9824862223753086, 0.9774648353131932, 0.9768676539888074, 0.9785970631043226, 0.3867349294514847, 0.5058141841421293, 0.5813740528796019, 0.5521068936939147, 0.5336825865316843, 0.5367530980633066, 0.10856178750484125, 0.4645999917741346, 0.5287961448072549, 0.22013314237032122, 0.20795916259826563, 0.18326793832186217, 0.15576005988099695, 0.19864698320136487, 0.26884033801728835, 0.22991038158595511, 0.7774302522453678, 0.2080089660346679, 0.1800357203577081, 0.16879832065114775, 0.24490368400032358, 0.18708020393175395, 0.2020004604940866, 0.31368467899797414, 0.3026176184985879, 0.17730181438995218, 0.1523117516141781, 0.20087833970506164, 0.21677953154665897, 0.1959890755398066, 0.15838191523960032, 0.1605438797337292, 0.14777101854937047, 0.25629295278798314, 0.16928930910351014, 0.18439358734109645, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16769448129912978, 0.19685320823124297, 0.15854862522269908, 0.0851263246851246, 0.01833279439753077, 0.03751554553883052, 0.13769387524661447, 0.1374407987190096, 0.09093399048877271, 0.05802634867782963, 0.11052492228196276, 0.08317311269910355, 0.06034913701450828, 0.017048109878458617, 0.06588485538179556, 0.058332239188087276, 0.016247678847413183, 0.007381406472659391, 0.1633914315915146, 0.21476324504747668, 0.21598160998293336, 0.13927513493248644, 0.17115448394392097, 0.1630419309561768, 0.049923161262888094, 0.18074981628011733, 0.2731916724328286, 0.5576873271034066, 0.45792611709761377, 0.6108539244341064, 0.5012867972040981, 0.5308126327266254, 0.512830227739201, 0.4772110730331255, 0.6312019426675182, 0.4283363866599621, 0.14669163121171058, 0.11354245920780048, 0.08318129251229256, 0.18752863368468076, 0.08882091819639792, 0.09522131896850383, 0.09164823122447485, 0.10237629320977415, 0.09488911729540928, 0.17728035710685275, 0.13948179750158196, 0.22992079626946704, 0.21473023529227253, 0.12707729921559563, 0.14526208551488484, 0.2522802556020277, 0.10470977099146717, 0.10860015959968183, 0.17627461988005966, 0.16401668434644745, 0.28062705415667033, 0.2767535858736565, 0.2676856799688768, 0.4109071015334368, 0.13983784415519696, 0.14341086839750028, 0.14377622623852004, 0.18966941641024126, 0.2382773911083491, 0.15730784065950743, 0.37901440921256313, 0.21909446848726533, 0.1602624254056162, 0.15020754387996837, 0.13033729068655342, 0.1986873699869428, 0.1459642301188605, 0.19833714484387932, 0.1937031827953819, 0.19843843418340956, 0.20276686740379013, 0.2280960474511221, 0.21527041325078888, 0.17137200506233152, 0.21660660247049734, 0.19081930119939228, 0.22818109800265052, 0.19537310133094554, 0.25204263954214534, 0.2088868227533881, 0.21745765480515467, 0.2483268162053096, 0.20781912898917232, 0.19097651019380146, 0.7771183365888241, 0.15368187817531964, 0.15371061577527811, 0.1651906971542545, 0.194255611388502, 0.1658782386591705, 0.15774032574583818, 0.1597417302553642, 0.15974514145178087, 0.16962980040852949, 0.21319139685790367, 0.2136570191221343, 0.20761010670371594, 0.21267482791984016, 0.11290578922761174, 0.21433961732044116, 0.4556431456835839, 0.2280609558792639, 0.17086554026364753, 0.17035435194451087, 0.17109418828337386, 0.1984583521826776, 0.151465895662113, 0.17307536673751167, 0.22197185281213394, 0.2035114746983978, 0.1947023395230153, 0.08013168228525647, 0.09331806383107943, 0.06941998656616033, 0.08882545182438717, 0.0684783730929106, 0.07577647299588353, 0.08336139121815123, 0.08427779700270366, 0.09057950052635388]}, "mutation_prompt": null}
{"id": "a971b728-7f12-486b-8c25-d2a505d6f3db", "solution": "import numpy as np\n\nclass AdaptiveHybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        iteration = 0\n        while self.budget > 0:\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n            \n            # Adaptive population resize based on fitness improvements\n            if iteration % 5 == 0 and iteration > 0:\n                improvement_rate = np.mean(fitness) / np.mean(fitness[:self.population_size])\n                self.population_size = min(self.initial_population_size, max(4, int(self.initial_population_size * improvement_rate)))\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n            iteration += 1\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "AdaptiveHybridDEAMS", "description": "Introduced adaptive population resizing based on fitness improvements to enhance exploration and exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.29284905349876694, "feedback": "The algorithm AdaptiveHybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8669800593895391, 0.891439832637445, 0.9023803795823102, 0.8409570722649901, 0.9079054941594695, 0.8975114424984847, 0.20195320548389117, 0.9060480847964879, 0.8889466660811918, 0.7965234888345937, 0.8364800445928038, 0.7421103553480972, 0.7947693344733524, 0.8382189830409751, 0.7732802541646913, 0.7718334376142487, 0.8169454055021443, 0.779470264660772, 0.11670360382194689, 0.1186883620556457, 0.1127089149947118, 0.20324639737068018, 0.15433513337356142, 0.07697002531877006, 0.17397770172595484, 0.6183687574243281, 0.18605292781484684, 0.0708891715139367, 0.13421636012864824, 0.09053877645259467, 0.13147806440868193, 0.21036487991911768, 0.12132970357179251, 0.14422037281096034, 0.23419328286542707, 0.18092594970784037, 0.9769767430935276, 0.9805031700807656, 0.9805046024958844, 0.9894795840544073, 0.9884893596158714, 0.9894586333252717, 0.9682483085926379, 0.9636486331840209, 0.9673943703778013, 0.6232039091483541, 0.5854565315862386, 0.6359117628152056, 0.15664210803866918, 0.6096322787766177, 0.3079873516547922, 0.322278078827531, 0.3618683292192245, 0.4982071840772483, 0.1468167844259045, 0.24473606942042925, 0.21589486031488003, 0.21360454126863848, 0.21254333184513585, 0.19242874281670452, 0.7736956926316463, 0.7194438633725757, 0.28771087743777446, 0.2247691512452994, 0.1559097335370767, 0.16340850909276794, 0.12882583211950316, 0.13425957239554132, 0.1335964063668229, 0.24193474136508353, 0.16928836147371218, 0.1567117322462811, 0.20687575347343357, 0.2066855016186998, 0.19276869688484666, 0.18013362369255992, 0.1954183284441705, 0.15806703472522454, 0.18097634644290217, 0.13144304482454117, 0.14011313779362133, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2239275805835209, 0.08908704517278643, 0.10762584754162652, 0.05736834876538155, 0.08148011269532707, 0.09072171450752098, 0.09018945709162329, 0.08419037711347899, 0.040125143691046694, 0.21114970907028008, 0.10187875828978155, 0.2020298966082522, 0.06391846505205889, 9.999999999998899e-05, 9.999999999998899e-05, 0.019445449769672107, 0.002784412194969943, 0.0615089406018291, 0.2770840200356909, 0.27654902601189746, 0.24038820463743527, 0.12163176907883821, 0.2103630031763185, 0.0928723652779363, 0.06039878740535154, 0.05734781115178378, 0.17050891871674245, 0.7136660344720269, 0.539480778423019, 0.501455258235985, 0.5045475263280585, 0.5388327387474467, 0.5133483101824373, 0.5700432081722431, 0.6162617007654445, 0.5141281290852833, 0.16481167613778958, 0.0930185368537142, 0.1115552468713027, 0.15340242456793818, 0.08682134721004864, 0.08503608310564992, 0.10542465028804382, 0.08294307895735986, 0.09170498655290937, 0.22542228030554268, 0.13367134648792567, 0.12632264793946302, 0.17511137013310984, 0.08604018169266092, 0.1452835085350005, 0.11077071274751671, 0.15750196807939243, 0.18139720052273278, 0.2372597146747707, 0.46557063076601335, 0.18404006005379459, 0.4886099736995436, 0.45236192626568905, 0.22161078031878934, 0.5207948635976757, 0.3772479466427935, 0.40009025219963446, 0.34713245492746747, 0.09906082371501923, 0.1303704211284199, 0.3505728058812295, 0.19744483174441707, 0.24992550993333884, 0.4156462620355317, 0.08138707216427954, 0.08751386911332049, 0.1664778698291579, 0.19285915556725042, 0.20437589101815845, 0.24880637200651012, 0.20111153762843026, 0.16050442204648974, 0.19492226584486216, 0.1736457382173836, 0.20313975850692845, 0.252415178984541, 0.17031563697125818, 0.1701287309235151, 0.2156616092028416, 0.2256549638988803, 0.18294470133504914, 0.21405816610714934, 0.19826972524420083, 0.21559471475685021, 0.16184436620126907, 0.7170132503011195, 0.9261984508023673, 0.2615933001956866, 0.1644431925399482, 0.3644040002669279, 0.1666132347903091, 0.13664679562927107, 0.1364470544505222, 0.31868814435830095, 0.32825770547507027, 0.38188801995141197, 0.20874027270566797, 0.21230610713037612, 0.21203982884067085, 0.12813149759681275, 0.12800894162240273, 0.12743885599263993, 0.17607836660909493, 0.18328329673523636, 0.17517565540820046, 0.19898517186044318, 0.18190794864149118, 0.18571644497357265, 0.1724951298594355, 0.2132683295135902, 0.15996170250167874, 0.07875778437832892, 0.07767833109710776, 0.055179782497062124, 0.0869594927046754, 0.0670006579576824, 0.08711319989062483, 0.0777281476831242, 0.11026218696548806, 0.07902277436888872]}, "mutation_prompt": null}
{"id": "99c70e3b-70de-442b-9b27-b0361fa08930", "solution": "import numpy as np\n\nclass EnhancedHybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.population_adapt_factor = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            convergence_rate = np.mean(fitness) / (np.std(fitness) + 1e-8)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance)) * (1 + 0.05 * np.tanh(convergence_rate))\n            \n            for i in range(population_size):\n                idxs = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n            # Adapt population size based on convergence rate\n            population_size = max(4, int(self.initial_population_size * (1 - self.population_adapt_factor * np.tanh(convergence_rate))))\n            population = np.resize(population, (population_size, self.dim))\n            fitness = np.resize(fitness, population_size)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedHybridDEAMS", "description": "Enhanced HybridDEAMS with adaptive population size and adaptive mutation strategy based on convergence rate to improve optimization performance.", "configspace": "", "generation": 29, "fitness": 0.26715145967599685, "feedback": "The algorithm EnhancedHybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8704686945398851, 0.897879316391575, 0.8828407830352626, 0.7400833124655339, 0.22731907011811003, 0.7735921025382227, 0.858079412843608, 0.31474461075540716, 0.28759562684754714, 0.626194222673089, 0.6824307076274408, 0.8262518006820523, 0.7455879843824491, 0.6972887490223224, 0.7880986735033736, 0.7998577606092729, 0.8595175159620093, 0.7286728254773944, 0.06512713129993952, 0.106635875244531, 0.2036258646738054, 0.18199861395742845, 0.1854631929357904, 0.1530721123979072, 0.15554913157425676, 0.18290793075081901, 0.129309529078113, 0.08111065059712252, 0.052870018637563354, 0.052437552053955505, 0.10887943068396433, 0.13689040392647855, 0.21282635280939588, 0.09477999386963898, 0.1796648874886021, 0.6802634380827886, 0.9780772230248932, 0.9780542811168894, 0.978056991855325, 0.9798024743184773, 0.9798150684363979, 0.9798129102357295, 0.10533309850026329, 0.9782360473233341, 0.9782305306464091, 0.42338343369237286, 0.5233838016411112, 0.5821544998625685, 0.5381239160160463, 0.4037691715953713, 0.33608933822394194, 0.42473737428116465, 0.05833983391225395, 0.059661723824457114, 0.12344792287492123, 0.22416155345497546, 0.1258421116600026, 0.28032436344471157, 0.16066408706615054, 0.1706488711095222, 0.17537936762199957, 0.2172788930160443, 0.2270979040188521, 0.17877402573160184, 0.18895065555947554, 0.1281311685384231, 0.13371736946543966, 0.1587665570029665, 0.19843323424167014, 0.1676614550175295, 0.33469175469729096, 0.17524885642977206, 0.12455023543880617, 0.17727458588257106, 0.14558560709718515, 0.1724811470116021, 0.2850886314790658, 0.1886535282007743, 0.15057908838861644, 0.17861169723829862, 0.12391941839259513, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13061307538481048, 0.06275430782297498, 0.06996811558144567, 0.07505010271285606, 0.06239237272002607, 0.08576431846153953, 0.08026246113596602, 0.08016731516413655, 0.09161804889382874, 0.04190253764227747, 0.04687493780747887, 0.03961131058983425, 0.044268155405571274, 0.07155910698118861, 0.06954681426923759, 0.07853615083816945, 0.09505945906765301, 0.036162008684218705, 0.1039109012687488, 0.1715754760850885, 0.2001308555151019, 0.006378456376334052, 0.20446374592315653, 0.29006037477251234, 0.14380355178791393, 0.19900034799585276, 0.09816665121132295, 0.5052625801978239, 0.39236156899966446, 0.47961943426794285, 0.5512619913488417, 0.5200112485095361, 0.5843651062525442, 0.5245830323439953, 0.47337327293066267, 0.5843203832946346, 0.08496642671884891, 0.09986117393524907, 0.06986707865090958, 0.09079746422262669, 0.05463295552053804, 0.09534358434869628, 0.10239854906134604, 0.05740957787553003, 0.048170581798562484, 0.14554887100428537, 0.17920140755198755, 0.18293972335204423, 0.18875663435876022, 0.20265711554766175, 0.09030818518465844, 0.14297111817665742, 0.19217444503529924, 0.1346682637099097, 0.16453081097833788, 0.19874544283690831, 0.24090924130605595, 0.21975100569703343, 0.19654764559363025, 0.1803224960797415, 0.16292235966045265, 0.1962253285268043, 0.2261604354240806, 0.10767786945092339, 0.12445632116198446, 0.11652353595791687, 0.14062512608603428, 0.1804120974913822, 0.21235164810838691, 0.07518189998954417, 0.1776627301164515, 0.1654982697943198, 0.24912715406176178, 0.20067916821492848, 0.19634819368783607, 0.17820068063160177, 0.2226878978353255, 0.19595249112973734, 0.21754989862026408, 0.1851826320606782, 0.22891892534833336, 0.19347504367128243, 0.1928724373914259, 0.20141498718197148, 0.22316953726983324, 0.20123405053234, 0.19743078813778847, 0.19053177342634586, 0.19919378419628275, 0.2110954371566367, 0.5759843623616614, 0.7666752445155026, 0.6645245363909544, 0.371986302216595, 0.29982469829504943, 0.35688855564111654, 0.8953050377237088, 0.9361344055861637, 0.7875630211099056, 0.16947357940875318, 0.16930993298569574, 0.16919075737331746, 0.19930742894103215, 0.21097675986762165, 0.20839521121235094, 0.09822973821844772, 0.15708306699625285, 0.1571073388030202, 0.206321077922186, 0.17742592269783652, 0.1899436386779828, 0.19486555229223457, 0.1696734948216514, 0.19616733882519977, 0.1843675039514462, 0.19722205942017046, 0.19010820736144163, 0.08922636801270878, 0.06814850060444533, 0.10419605457381043, 0.10628494133002409, 0.07668116708348005, 0.08722547522698332, 0.10695364669689167, 0.0749280936732033, 0.09017330195911433]}, "mutation_prompt": null}
{"id": "28f8fff6-cb57-451b-85fe-e92658b89632", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n            # Adaptive population size reduction\n            if np.mean(fitness) < np.median(fitness):\n                self.population_size = max(4, int(self.population_size * 0.95))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced adaptive population size reduction based on fitness improvement to enhance exploration and convergence.", "configspace": "", "generation": 30, "fitness": 0.23532169681965265, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.24.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8278135809901034, 0.3149632001664152, 0.9119130320164016, 0.21996204417317067, 0.21603476368417862, 0.21691061618565155, 0.18472086381816466, 0.15458156589406047, 0.21674279498036497, 0.8001732864792036, 0.7959608156165715, 0.5801078869731626, 0.4392976321173443, 0.8330390247317419, 0.4710656145331852, 0.8167921569929694, 0.3044583586587548, 0.782760309276133, 0.004840161352840933, 0.06840641607112408, 0.0769205065303804, 0.1289917165969744, 0.08940886712177432, 0.09020234625107715, 0.07649315489592323, 0.105405877219646, 0.1589193571803036, 0.06938729203266869, 0.04792828902885449, 0.047504549707090726, 0.14613142691367353, 0.11977470748544838, 0.16674320904144713, 0.15894490611969192, 0.1407217114429784, 0.1526328117107174, 0.974219341856234, 0.9717618519007798, 0.9717639620847182, 0.9763932840317608, 0.9648801046045378, 0.9717542638789005, 0.9780073958045827, 0.9779795220562458, 0.97798323531812, 0.6549494476951815, 0.7021871845009884, 0.7068641596081935, 0.15096881934979411, 0.7045978100936767, 0.546146451765101, 0.2321326903632147, 0.09006132385989762, 0.20270070864174594, 0.16980336762377357, 0.2227281322232706, 0.2982792592796978, 0.8099107897836499, 0.16188111217798906, 0.16187176631793299, 0.21954617521913156, 0.5862335990933016, 0.22018003197748726, 0.26137445908201895, 0.208204265033479, 0.1298765155101761, 0.12721710942023823, 0.11242931986136062, 0.12463031439833427, 0.27027573193662435, 0.13078020932986223, 0.2089197994472708, 0.14113029301342916, 0.16743821404576298, 0.1492769549060473, 0.17638996985042255, 0.14568760349617538, 0.14392517293125862, 0.2405773437896057, 0.1484674017663341, 0.11675501142095013, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08273572884536895, 0.0749005876790696, 0.039238831213623926, 0.030579210770112497, 0.03143917509609595, 0.09072171450752098, 0.09018945709162329, 0.03852715702498466, 0.047778885077326194, 0.07324998928844872, 0.04148532058590737, 0.0483344790378375, 0.018258774148236068, 0.0677883187675028, 0.0769656932499333, 0.10319485560912967, 0.05942459240320874, 0.05977225261884744, 0.04228929956823213, 0.043687791092529515, 0.12501606287377087, 0.006075871229474394, 0.19891700422165148, 0.2304753721756222, 0.03060303927398922, 0.03950962719903672, 0.038738243948175155, 0.4910407202205771, 0.41081764996500925, 0.3870135516102293, 0.4574968289491027, 0.40949245968459225, 0.4357207449454652, 0.5553416705403967, 0.36590456694922013, 0.3080186999894181, 0.0823982750684985, 0.06891256829100367, 0.10319202431161068, 0.1350025568354586, 0.03846148000276117, 0.08392579508064824, 0.08676570455502675, 0.07645006617735073, 0.07972850652379604, 0.337811580938324, 0.14639951845296506, 0.13622806599256088, 0.18446522211500505, 0.08604018169266092, 0.134900083220715, 0.16507450871216822, 0.13052337864157637, 0.1551387356038909, 0.1329374056295506, 0.14790347050090202, 0.19041882568065793, 0.2811484443328841, 0.1837815322169689, 0.18118794573585528, 0.20029967135862303, 0.26787211264893906, 0.2573714910818665, 0.08221794681678407, 0.13941924414604479, 0.10981457197112121, 0.1623967509646278, 0.15537435031762103, 0.14561838720095033, 0.2773918390726928, 0.08036041279596029, 0.07433503592426294, 0.18795980459923678, 0.18189794705423923, 0.12287326649299413, 0.18619784808657736, 0.1757940787284895, 0.17972429593888462, 0.16144427750968715, 0.18947773943511326, 0.16114547862661588, 0.21852817095591048, 0.244184544781349, 0.24369450840727946, 0.19641050562193219, 0.18386106708568184, 0.184269554279213, 0.1801076782672808, 0.1874304224297334, 0.1979595775128813, 0.9046421126266542, 0.2840895293897171, 0.7114621835007665, 0.4165493553926686, 0.33610464305033527, 0.16625539718232607, 0.17033929715399554, 0.13024313340856697, 0.12241765344927258, 0.16832404456172223, 0.16971525997477088, 0.16935732501724465, 0.2034995207172533, 0.1848635716431114, 0.20516740499458108, 0.11094754855866817, 0.13333650485393078, 0.10851806647722029, 0.19384829012648164, 0.1859733134811007, 0.1877389517912803, 0.1911857334433814, 0.16336087824528245, 0.19681824072764642, 0.18768073650569528, 0.16011598754478473, 0.13530077841372912, 0.06088740882335186, 0.06341538153086435, 0.08096027644171722, 0.08968786660413752, 0.0717851671630062, 0.08461622903025767, 0.057476230089745006, 0.079665033117719, 0.06146843979582195]}, "mutation_prompt": null}
{"id": "b981845a-c93c-4d28-bb06-920aeb23b1a2", "solution": "import numpy as np\nfrom scipy.stats.qmc import Sobol\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Initialize population using Sobol sequences for better space coverage\n        sobol_engine = Sobol(d=self.dim, scramble=True)\n        population = sobol_engine.random_base2(m=int(np.log2(self.population_size)))\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * population\n\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced population initialization using Sobol sequences to improve exploration diversity and convergence speed.", "configspace": "", "generation": 31, "fitness": 0.28336855355677965, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8026085087548697, 0.8396354612644175, 0.8892590425457787, 0.9141650108952257, 0.9254521227373705, 0.8599081387877191, 0.912931627391672, 0.7774320374027274, 0.9137137525562506, 0.626623903002119, 0.8062573189706527, 0.7905831454464289, 0.6965073240459283, 0.7506314924489998, 0.7625644213431073, 0.7868327577083846, 0.6718624553357657, 0.7844644306600754, 0.0484815332187154, 0.1336138058386659, 0.0775827135992806, 0.17485546956880194, 0.13375860976483522, 0.16990828329838892, 0.1525310769190995, 0.0769036632837371, 0.13682501643163247, 0.1570662067498264, 0.07824817961030983, 0.05029295897840369, 0.21807927282474504, 0.10381198428281091, 0.13070605386793754, 0.1597983170234133, 0.16325175223646438, 0.125996159611113, 0.9859620146288317, 0.9763148736832951, 0.9735030419688391, 0.9792982183595279, 0.9647081711451249, 0.9865544193253608, 0.9786597270871158, 0.9893842483241964, 0.10228400083241707, 0.6075457266184533, 0.34185758352477846, 0.6474906830648954, 0.686327449829297, 0.41936239535369846, 0.4822416912745562, 0.42856557241715265, 0.4363190987401889, 0.380746040605461, 0.1365899080248757, 0.35198412610783303, 0.22322639358648644, 0.8920769460234946, 0.8603039606422727, 0.8661511384768494, 0.7530448469145483, 0.21233593091904224, 0.22385235653882274, 0.2441004145803619, 0.16984036428243432, 0.23771948258424258, 0.11539991667130434, 0.1921606558802781, 0.1199557277316915, 0.2762714913841219, 0.1792394729479484, 0.18470383648716415, 0.15070580566194147, 0.12988938893269664, 0.11999748680084998, 0.36167924361391735, 0.15250241429319178, 0.1418777589289142, 0.44411797694215915, 0.15824267034384631, 0.19528247744414973, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09618203918423474, 0.0738701857757047, 0.14632474853741773, 0.06554188179063336, 0.07989442009275516, 0.04117188444033071, 0.10951410700487463, 0.0975698975328545, 0.04773688200881132, 9.999999999998899e-05, 9.999999999998899e-05, 0.047625949603599116, 0.08157495026872252, 0.003411457384878802, 0.0372172118877625, 0.04786077858889115, 9.999999999998899e-05, 0.09128833358260746, 0.1943352468931333, 0.33734503503579083, 0.24067769904529301, 0.1737547787578203, 9.999999999998899e-05, 0.04241256051786335, 0.031635711394466304, 0.03571451793251712, 0.24233986383429684, 0.49547031481606396, 0.39877865853128003, 0.5157117319573349, 0.4470934268662069, 0.534575545936827, 0.1873357441311141, 0.5393243379461787, 0.6570767866713287, 0.5012235738813573, 0.11921861787238563, 0.03826851971644607, 0.13550931085900375, 0.15484925285244244, 0.10107840343529917, 0.14386944244002975, 0.051502468094758114, 0.12077301268408847, 0.09446968462588778, 0.13016728190824667, 0.11955441668392286, 0.24090786780707862, 0.11485360989267279, 0.4435537000089691, 0.09726992978272953, 0.17905331060106888, 0.23391559355296554, 0.20257310968990572, 0.1487120935474635, 0.3228391838161663, 0.12971749259731913, 0.3174402681474435, 0.23218504751392954, 0.2913190816332534, 0.14150969306153727, 0.3362133431256107, 0.18328636836372703, 0.21281610391549444, 0.36872104377728177, 0.2052465568899121, 0.3347434305181387, 0.3847961666535309, 0.3548876424695394, 0.19459181554164007, 0.3182331277438665, 0.20670581376153707, 0.2698306744734439, 0.22295288447022799, 0.18292441883249644, 0.22592838052945297, 0.18699463088819546, 0.1857424861304271, 0.2630597099586933, 0.26561491517884783, 0.18999862874229645, 0.2518513455046719, 0.21034242652862678, 0.22570170353700214, 0.17800777370281118, 0.17890445012168166, 0.1992215725565767, 0.18496917303997995, 0.20156674995242907, 0.2241044434872148, 0.18780126689343557, 0.18708326060939184, 0.1729218956513554, 0.16730500536643433, 0.17166826380717903, 0.4178620426693975, 0.1211477942372503, 0.1728681050194435, 0.1590060302804608, 0.15485301740209378, 0.4211730733296707, 0.3216587468365314, 0.07435532955084168, 0.22849585181175658, 0.1687342968130866, 0.1681218560443687, 0.15194570824350706, 0.21245527576277645, 0.18961831930026152, 0.1958618009617622, 0.16807141631979028, 0.1947347132442211, 0.1813056768459762, 0.2154541135289234, 0.16964217990470765, 0.15874846463444414, 0.18276720984852712, 0.06017708421202428, 0.08058464572796997, 0.07495890056993959, 0.0664071485986335, 0.07548061146880136, 0.0894711653790049, 0.09839000027374445, 0.09716233303836574, 0.08983537109071171]}, "mutation_prompt": null}
{"id": "43acc588-96c9-480c-9459-c343492522da", "solution": "import numpy as np\n\nclass HybridDEAMS_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        prev_mean_fitness = np.mean(fitness)\n        \n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            mean_fitness = np.mean(fitness)\n            if mean_fitness < prev_mean_fitness:\n                self.population_size = int(min(self.initial_population_size * 1.1, self.initial_population_size * (1 + np.tanh(fitness_variance))))\n                population = np.vstack((population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(population), self.dim))))\n                fitness = np.hstack((fitness, np.apply_along_axis(func, 1, population[len(fitness):])))\n                self.budget -= (self.population_size - len(fitness))\n            prev_mean_fitness = mean_fitness\n\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / mean_fitness)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS_Adaptive", "description": "Introduced adaptive population size adjustment based on convergence rate to improve exploration-exploitation balance.", "configspace": "", "generation": 32, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('Cannot apply_along_axis when any iteration dimensions are 0').", "error": "ValueError('Cannot apply_along_axis when any iteration dimensions are 0')", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {}, "mutation_prompt": null}
{"id": "c1a73717-7eb7-4dc1-8223-abb42a2cacb8", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            terrain_factor = 1.0 + 0.2 * (fitness_variance / (1.0 + np.mean(fitness)))  # New terrain-sensitive factor\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + terrain_factor * adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)  # Applied terrain factor\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial, fitness_variance)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution, fitness_variance):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n        adaptive_step_size = 0.05 + 0.1 * np.tanh(fitness_variance)  # Adapt step size based on fitness variance\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * adaptive_step_size\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced exploration by incorporating terrain-sensitive mutation and adaptive local search range based on fitness trends.", "configspace": "", "generation": 33, "fitness": 0.17738185111525795, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.26.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.9009792938011966, 0.9080641636044599, 0.8800457439742172, 0.8903804550448442, 0.8878424039073549, 0.905873456502159, 0.9045222065753477, 0.8590414915520688, 0.8961171552521746, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0044895968050364665, 0.0044895968050364665, 0.0044895968050364665, 0.07660080365971389, 0.09204423639942394, 0.09378732617573537, 0.09529777442558318, 0.03541715789267019, 0.09132290261796316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07998742093180422, 0.08993278492050705, 0.07013464858779439, 0.07142096556985011, 0.04989971759572931, 0.04639746230824582, 0.9804785945092647, 0.9805433852706309, 0.9805335800848247, 0.9866012486738941, 0.9841906202060322, 0.9841903439587905, 0.9815189560369801, 0.9815098286385091, 0.9815108587747051, 0.4496030161570974, 0.10723984477402648, 0.10717345627853792, 0.08107102734158544, 0.08107102734158544, 0.08107102734158544, 0.07597371531414432, 0.07597371531414432, 0.07597371531414432, 0.1394716246939275, 0.05591433423419334, 0.17480373494454104, 0.10994229606912176, 0.13175314343352307, 0.12475747159537842, 0.0734009108032535, 0.056312927902018584, 0.030300381410494626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05571037362030529, 0.05571037362030529, 0.05571037362030529, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014737070164817845, 0.014737070164817845, 0.014737070164817845, 0.0027575554283808534, 0.0027575554283808534, 0.0027575554283808534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010182474053402113, 0.010182474053402113, 0.010182474053402113, 0.4780550615664163, 0.5792315458775144, 0.5267228854903199, 0.4873377065799206, 0.5543747170233362, 0.5594753058265929, 0.582355518011326, 0.5192313627471596, 0.5565662281588311, 0.07633189280521036, 0.09568423858067365, 0.05546545365275046, 0.13363214647919996, 0.13191481641049163, 0.1458151276188282, 0.04949418206903722, 0.05370131569515657, 0.05269454305876864, 0.11768289491100348, 0.1109715039173087, 0.15651399768924767, 0.2054712277629458, 0.14830126943822108, 0.19112794563047852, 0.09180548201025573, 0.10074043194982019, 0.1283688062130266, 0.18386183012976554, 0.17268868477892052, 0.16849134637562002, 0.19756927072421127, 0.328898332525966, 0.27494717143842773, 0.19686636466410024, 0.12657110588462905, 0.17672034473636544, 0.10976613630443532, 0.1434621064704017, 0.11747667596893208, 0.13694261277496445, 0.08210731290056505, 0.18714684056171016, 0.17459716810447512, 0.2462123044204131, 0.2688544616874389, 0.2056361512588375, 0.20584002689720604, 0.1867587742103075, 0.17419769986545708, 0.20417915980282697, 0.18526983934858088, 0.18007590979080634, 0.17226292237775087, 0.2043230233579597, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1410431068802911, 0.1410431068802911, 0.1410431068802911, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1874205602404897, 0.2738041890266203, 0.2730414694435407, 0.19818903261720278, 0.16359825785218907, 0.3391947990890337, 0.15999079927777438, 0.15981044266932187, 0.15988832391780616, 0.2123972335156541, 0.16962919897826267, 0.17571970781269464, 0.2087987333264132, 0.2094186902795495, 0.2100487086431584, 0.1943533059126814, 0.2069259675634536, 0.1283446988152105, 0.17034392748191807, 0.1886728625786812, 0.13720942259143154, 0.17664903115481134, 0.18927275124549892, 0.18024114847562356, 0.1594259753088576, 0.1700368203965822, 0.16358029196360913, 0.06635118799262196, 0.10599066469359364, 0.08490631244786473, 0.04239785297473586, 0.09361801727835006, 0.09705603992589695, 0.10196839631634191, 0.07569044551802706, 0.08894850046282332]}, "mutation_prompt": null}
{"id": "b53bd3b2-9e04-4f80-bb5d-2a5496b22f81", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                distance_scaling = np.linalg.norm(a - b) / (self.upper_bound - self.lower_bound)\n                mutant = np.clip(a + adjusted_mutation_factor * distance_scaling * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced mutation strategy by incorporating distance-based scaling, improving exploration and exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.1374536960521139, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.16.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.45103872907304243, 0.3618858137587593, 0.37235175433273493, 0.2195760851860339, 0.21096973143265219, 0.21664709780952318, 0.11372058676473096, 0.11517161776594276, 0.11496325503879157, 0.041881102002576, 0.020348252342848205, 0.01720584410285897, 0.02477080971196499, 9.999999999998899e-05, 9.999999999998899e-05, 0.027894834308953564, 9.999999999998899e-05, 0.031194900074949183, 0.0670101095911485, 0.04268951600663895, 0.055011780799417265, 0.06828080227442512, 0.09430380860197196, 0.11287739056892354, 0.07057537192834806, 0.0834002672429206, 0.08296283642145941, 0.07699919547221512, 0.09350172271787194, 0.09135537150541517, 0.07388420477955748, 0.054913076220904244, 0.10978089466440977, 0.04461741103562711, 0.10447102229272964, 0.0780235554801193, 0.9785639665231232, 0.9785890704683047, 0.9785854077711882, 0.9825369187950589, 0.9825771147268755, 0.9825689158827731, 0.04980451907183925, 0.05041016750397098, 0.05032381504668737, 0.05349027498690262, 0.06417945916182433, 0.07231367013916057, 0.06398337696507084, 0.06550758819837521, 0.06574040753080213, 0.13747568622014894, 0.11514442324257357, 0.11054855296597454, 0.07825609814175749, 0.16512206926061734, 0.20858982721793395, 0.16233308282746406, 0.1625923655643008, 0.16194992151246024, 0.1389144399342882, 0.10762024194529352, 0.10293124179434576, 0.1531372876801328, 0.10844305366406037, 0.11101306722032644, 0.11208410600881635, 0.12428836412101829, 0.11611899735692255, 0.08912328131036196, 0.05274084724821004, 0.05276885273686982, 0.11929387049324158, 0.09377113362492473, 0.1258557958415637, 0.10965066363421505, 0.14668111818801444, 0.11983939941349764, 0.13042458125951162, 0.13029879393009347, 0.048062357821990864, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09943254954313563, 0.0960278779864231, 0.09533635682128783, 0.05068419849839634, 0.03133085848987138, 0.024065477184219697, 0.09015228997103109, 0.07861339747013896, 0.08417551646449539, 9.999999999998899e-05, 0.03757039543339358, 0.01389028877113374, 0.04676923367850505, 0.010821120000406914, 0.023419079038672352, 0.1320254987636701, 0.12669256186256772, 9.999999999998899e-05, 0.03852458278103754, 0.025909343105248395, 0.043920911240692084, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0389374466060004, 0.05475979579891588, 0.05963058582561831, 0.17277498495346533, 0.17417230342584167, 0.17396335219136383, 0.17352181294649927, 0.20330387766892943, 0.2043361580558769, 0.24733851206911162, 0.24947287502369986, 0.24787218612742, 0.11559468853856392, 0.08011590689592762, 0.060699409097975665, 0.07140393716024196, 0.0940256576788383, 0.04948752561800396, 0.046871471958890965, 0.10476476291794767, 0.0841098774267357, 0.14725568454125237, 0.13295083164761856, 0.11476630257521014, 0.14218676280675246, 0.09683096597750807, 0.10401557946347673, 0.16574582221965173, 0.1389590148999903, 0.10150412654936392, 0.11799539386681879, 0.22814441691226417, 0.2307587486880165, 0.1373040841139096, 0.20271677633183083, 0.18615821722695647, 0.14303651658220062, 0.17223393939581033, 0.17136542562933754, 0.1327015401070477, 0.17205750445660073, 0.14751099308749038, 0.10353952655497722, 0.0705849796554876, 0.1013949106974722, 0.11132959552043087, 0.0745075706106676, 0.06912678769755054, 0.21604332253717662, 0.16278213828561316, 0.17697287706096343, 0.15282142106461072, 0.1724186286888646, 0.13494875234693482, 0.19335675552751386, 0.1807058348597771, 0.17283634539521242, 0.20794304901804928, 0.16470352277727307, 0.16364833349425756, 0.19409020630700402, 0.1800559269761719, 0.17934460499370275, 0.20323065036295163, 0.19559784486182574, 0.196020456541264, 0.11281337725329033, 0.1301208624729836, 0.13018942093288877, 0.34264794815264266, 0.1682959337754888, 0.16896959408990841, 0.16393821050409074, 0.16643730816462754, 0.13179884903189654, 0.13982518366838825, 0.06291814137591323, 0.06287004493026471, 0.1405687916071201, 0.16491528110606501, 0.16495443458256542, 0.22010952388163763, 0.2167469337788055, 0.21443198907772765, 0.19230382466320783, 0.18544198300802262, 0.17477873003194933, 0.16778954533282997, 0.19208935612368894, 0.16404607012886574, 0.17712194565300465, 0.16943917134705044, 0.14874568075935857, 0.06999290999847618, 0.06003902319343979, 0.04229977113400707, 0.09268033373321649, 0.049549172681287224, 0.05541180188914785, 0.08246537153607347, 0.0875456286469729, 0.09475789874129292]}, "mutation_prompt": null}
{"id": "d6c45b71-45db-48f5-a5a9-127c8add735b", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.adjust_population_threshold = 0.1 * self.population_size  # New parameter\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        fitness_improvement_counter = 0  # New counter\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)  # Calculate fitness variance\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))  # Dynamic adjustment\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n                    fitness_improvement_counter += 1  # Increment counter on improvement\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n            \n            # Adjust population size if improvements are frequent\n            if fitness_improvement_counter > self.adjust_population_threshold:\n                self.population_size = max(4, int(self.population_size * 0.9))  # Reduce population size by 10%\n                fitness_improvement_counter = 0  # Reset counter\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced adaptive population resizing based on fitness improvements to enhance convergence speed.", "configspace": "", "generation": 35, "fitness": 0.1978444567764368, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.22.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.8646826238838415, 0.8821538238231935, 0.881003343036413, 0.21996204417317067, 0.21603476368417862, 0.21691061618565155, 0.12345940798431543, 0.12534878098597024, 0.12510255066674725, 0.5859630019013792, 0.6016999777297247, 0.6518463134212559, 0.6360852228463694, 0.7462167537673706, 0.7561792149388575, 0.7293217327254128, 0.7781510970767014, 0.6879923825908014, 0.004840161352840933, 0.03201717408664828, 0.005702053606637447, 0.06584970263247447, 0.10409137890131692, 0.08464173620521853, 0.1569144038780207, 0.11637374196306427, 0.15258508846331986, 0.11701631045122973, 0.13467670000421517, 0.1628423332353921, 0.13011804526465753, 0.1814432996797074, 0.07576764363250987, 0.1324375087267381, 0.16871648937461903, 0.15464146312796934, 0.9770903256256857, 0.9763114602101284, 0.9770783633409463, 0.9680521758799199, 0.9773656040109995, 0.977373029184339, 0.94648367486411, 0.10212249811048846, 0.10212552424080112, 0.2777308657202704, 0.3775639157907774, 0.3126236177919576, 0.08196023641470851, 0.16298144357124544, 0.15347255879125843, 0.21683618646947056, 0.23362105200959538, 0.24959856127121305, 0.2687548683606954, 0.08684622895878025, 0.21986708543266853, 0.1420187547999865, 0.14826636715208585, 0.1527912702699541, 0.184057885834627, 0.16345010874102406, 0.22541174891040128, 0.09861838467309847, 0.13137829624796393, 0.1361872022145273, 0.18233540685040317, 0.27342409618877117, 0.23298554132732174, 0.17745035632406803, 9.999999999998899e-05, 0.16030012771894941, 0.1377690182948178, 0.12960380511453695, 0.12894481069526975, 0.16876108477551666, 0.14803247955481347, 0.15977335484058608, 0.12818949583084982, 0.12522091427006032, 0.15117901405860867, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10718594196266062, 0.022966968300617063, 0.0282523652626282, 0.03247768635032211, 0.03143917509609595, 0.06341534905897739, 0.0814481420166383, 0.08049630276878472, 0.08554428859795715, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030538301627118014, 9.999999999998899e-05, 9.999999999998899e-05, 0.04228929956823213, 0.043687791092529515, 0.08196895200357357, 0.0869169413855343, 0.031160175174959837, 0.011955557921806803, 0.08112759870327868, 0.09779905891855856, 0.1315034163004286, 0.1450579498285357, 0.14520055540254595, 0.14518610787300257, 0.44444490166243744, 0.4001901806092035, 0.2545860348224308, 0.4548215821436049, 0.5821857400781072, 0.5323159391970527, 0.11534920304925778, 0.07582777684202524, 0.15367974088965897, 0.08479495042338148, 0.03846148000276117, 0.10519403457066367, 0.061924580508630256, 0.04492755864897224, 0.07716126955268432, 0.13621846770564405, 0.13814648041913336, 0.16596205928339036, 0.18281144279166384, 0.08604018169266092, 0.10608161930679127, 0.24328430853424288, 0.12358951322354184, 0.12424811366546651, 0.11049204267650403, 0.11020974510066917, 0.11025119284838292, 0.22155461051469905, 0.1837815322169689, 0.17491452803811025, 0.19109083187877718, 0.29703860446854846, 0.137401479883003, 0.08596663540050631, 0.08282416735904385, 0.0891269331325506, 0.1358901106898125, 0.15711902714937953, 0.16266102403168858, 0.18573291837737582, 0.19539171913051545, 0.17497704104626666, 0.13115701460031182, 0.12381745864828286, 0.12287326649299413, 0.19227082302260778, 0.20190368407383497, 0.2253151044604731, 0.16555241280845712, 0.19120778652899684, 0.18663471844653168, 0.19786751329677954, 0.1888072122805151, 0.18249919415370097, 0.18813484919107004, 0.20481350387034414, 0.20684549139764652, 0.19225067033904897, 0.18005511388748596, 0.208618662088903, 0.43000248852739265, 0.15165838958919953, 0.15025117377794972, 0.1372512442793351, 0.16620809691217842, 0.16616854404574022, 0.12133460673716001, 0.13024313340856697, 0.12241765344927258, 0.16910983772397503, 0.16967337545585037, 0.16963822558904373, 0.2034995207172533, 0.1848635716431114, 0.20516740499458108, 0.11094754855866817, 0.13333650485393078, 0.10851806647722029, 0.1905242055244316, 0.18088962587965718, 0.1628925810812505, 0.185015651442467, 0.14644292574507634, 0.16645763500762, 0.1648694723618277, 0.15927988686651728, 0.13530077841372912, 0.08564702893746712, 0.07499645000561739, 0.06908863241025887, 0.08694643352433673, 0.0717851671630062, 0.037700500263541326, 0.07101504589693519, 0.06404125415413142, 0.07170860717683503]}, "mutation_prompt": null}
{"id": "25c9a04a-efc9-4751-a97b-56820f3812e4", "solution": "import numpy as np\n\nclass AdaptiveDESLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2 * np.log(self.dim)))\n        self.mutation_factor = 0.7 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.85\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_stochastic_iter = 10\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_mutation_factor = self.mutation_factor\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_mean = np.mean(fitness)\n            dynamic_mutation_factor = self.mutation_factor * (0.5 + 0.5 * np.exp(-np.var(fitness) / fitness_mean))\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._stochastic_search(func, trial)\n\n            dynamic_crossover_rate = 0.8 * (self.best_fitness / fitness_mean)\n\n        return self.best_solution\n\n    def _stochastic_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_stochastic_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = np.random.uniform(0.01, 0.1) * (self.upper_bound - self.lower_bound)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.normal(0, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "AdaptiveDESLS", "description": "Adaptive Differential Evolution with Stochastic Local Search integrates stochastic neighborhood exploration and adaptive learning rates to enhance global and local search balance.", "configspace": "", "generation": 36, "fitness": 0.23518250922437295, "feedback": "The algorithm AdaptiveDESLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.9138314397678349, 0.8718109799945291, 0.858035479082389, 0.8004602959853397, 0.8931309333073241, 0.31449464496850166, 0.1574112159129738, 0.1574112159129738, 0.1574112159129738, 0.13675345477280776, 0.6997344333997775, 0.1552113452490621, 0.24674907044196803, 0.1960909278405617, 0.06372730313062691, 0.41125537400224743, 0.196925148230641, 0.29504681214558204, 0.02514079471706787, 0.02514079471706787, 0.02514079471706787, 0.18221886362319284, 0.10473151810846626, 0.10582708273247898, 0.17889911670137404, 0.17969980760473003, 0.14811383447432436, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16027280553545675, 0.1659849967521474, 0.13139819856701884, 0.14974694681630485, 0.3131320511651129, 0.12098650623179696, 0.9314951844881656, 0.9638599935724981, 0.9638854657766495, 0.9534938660601693, 0.9817565029355488, 0.9817605205957871, 0.9810413828615631, 0.973275207062048, 0.9810411044557708, 0.26127746689886566, 0.335831664322086, 0.5310711458759285, 0.32383773794570436, 0.6868686218132809, 0.4993521755783177, 0.08867065156046539, 0.36672326629622654, 0.306788923009799, 0.262313484695038, 0.16523792043684493, 0.18523764986794344, 0.3917265462290198, 0.21371511878238758, 0.19371703549746078, 0.8656940503992467, 0.17551293196222906, 0.2337817323874014, 0.21011049786306113, 0.19514374991646521, 0.2588838230960103, 0.07678149795509404, 0.11990579350235298, 0.05993028695310754, 0.33445783491121284, 0.20372035303559943, 0.16924248392220143, 0.1502498602259391, 0.17411636509712425, 0.17143530064119672, 0.13533820058325963, 0.1352352289397828, 0.13406330771445374, 0.1413169878759627, 0.13394113879938307, 0.1529496188993158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12746407193063114, 0.16724315381022514, 0.1920324692658112, 0.05791921318801674, 0.05627672700901254, 0.048366973498619514, 0.22294547359671557, 0.17908492510832852, 0.16773602644461227, 0.018328868825493005, 0.0714608302072125, 0.06788486103268931, 0.03559122992015451, 0.0559281741760802, 0.007290774351356721, 0.04746743603968129, 0.06857498448079968, 0.07146022754624937, 0.05788318703716233, 0.1761846822696993, 0.1412311930371528, 0.09511769125769565, 0.13841465335405012, 0.10947486773049098, 0.025586283808439858, 0.029854338859439666, 0.032164951912570516, 0.47559310966666457, 0.3146592999242628, 0.38614188543233874, 0.23090757484724544, 0.23479226305305434, 0.23422520320648677, 0.5819320624044992, 0.5433889483351239, 0.6418948133330105, 0.07150753444219593, 0.03310979756509602, 0.04257109047073848, 0.11585480546025606, 0.10859788505299872, 0.12138388900162567, 0.056814690441972404, 0.08409549754252965, 0.06622345364118487, 0.2712306649008168, 0.23058341300635532, 0.46509893903585553, 0.10238406832533797, 0.10238406832533797, 0.10238406832533797, 0.26609749847946673, 0.28191360692546164, 0.2034683353509017, 0.17501597584034423, 0.11252946152689969, 0.14308130622694448, 0.4576409668068191, 0.43833475219319795, 0.36703472597638387, 0.6627516418938537, 0.4554935213462976, 0.22456108962033794, 0.13627385975941575, 0.09569661505021054, 0.12876061113851578, 0.22263988933664702, 0.20620380289759588, 0.18959328915695062, 0.3574639113123729, 0.30216644851946683, 0.4067800494187057, 0.10285435198686499, 0.10285435198686499, 0.10285435198686499, 0.24156194012992538, 0.23759215037933556, 0.2065514810884972, 0.21273984425538905, 0.19710037080355813, 0.2351959178196098, 0.1692800987243085, 0.17641082786770002, 0.1769468564837443, 0.2260574841166424, 0.23124016868397335, 0.22729503912653137, 0.23088744267215577, 0.22129491606084029, 0.2526834523080268, 0.1872515290059651, 0.18792052037616147, 0.1879347743696761, 0.43469127320089196, 0.1948148084418132, 0.195808847577993, 0.12353637327561806, 0.16740589367217595, 0.1715093264903973, 0.16954210644888768, 0.277000628975935, 0.23073815968611566, 0.21039450615141075, 0.20722437420825845, 0.21151238671399197, 0.10476251916928847, 0.10479154418507552, 0.10478878482349285, 0.18808678689408098, 0.18849771828881068, 0.19473098137408873, 0.19245783598827926, 0.19769999900710822, 0.18918178788355666, 0.18238375227972348, 0.19555039994904733, 0.21219001693216666, 0.10478606285880632, 0.10295339158268346, 0.09630121510840906, 0.08196519982113604, 0.0890562619962375, 0.07841625544445308, 0.08552264003654886, 0.08760363047148312, 0.08986491525875862]}, "mutation_prompt": null}
{"id": "bd779667-b6eb-4844-b6ae-90179fee3f8d", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness_improvement_rate = (fitness[i] - trial_fitness) / (fitness[i] + 1e-8)\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.05 * fitness_improvement_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced crossover strategy dynamically adjusts based on fitness improvement rates to boost convergence.", "configspace": "", "generation": 37, "fitness": 0.29279376543579005, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.9090528279518346, 0.8864610560815188, 0.9023803795823102, 0.8409570722649901, 0.9079054941594695, 0.8975114424984847, 0.8955034008246284, 0.9060480847964879, 0.8889466660811918, 0.686691369267991, 0.8364800445928038, 0.7421103553480972, 0.8152703614670479, 0.8382189830409751, 0.7535660332931118, 0.7718334376142487, 0.7809248572050925, 0.779470264660772, 0.11670360382194689, 0.1186883620556457, 0.1127089149947118, 0.18399808737956558, 0.17477689370096883, 0.12997135520151404, 0.16014070213391496, 0.19117721385857345, 0.1470623560746388, 0.0708891715139367, 0.13421636012864824, 0.09053877645259467, 0.14896024470921987, 0.13301831009995801, 0.12019274000086921, 0.11597449790370573, 0.16474548683674783, 0.14882305248002936, 0.9769767430935276, 0.9805031700807656, 0.9805046024958844, 0.9894795840544073, 0.9884893596158714, 0.9894586333252717, 0.9635471413132766, 0.9641190806483393, 0.9660792368295726, 0.633761534488806, 0.44425394342557933, 0.6141724589700462, 0.14470054120063447, 0.5193013660849499, 0.5603427306998879, 0.322278078827531, 0.3618683292192245, 0.36557157575028854, 0.16123306179772734, 0.24473606942042925, 0.3188884273062146, 0.34661627892525526, 0.21165237391173786, 0.35604721759436875, 0.21626278142096145, 0.7929820954627311, 0.31681759062846815, 0.13567255294367497, 0.2899086163623458, 0.1730960999030844, 0.12882583211950316, 0.13425957239554132, 0.13585345413208927, 0.2052618032624849, 0.28739275957194355, 0.16555158703779993, 0.15629140132104657, 0.21182499515998465, 0.1481283737133019, 0.19829142653062204, 0.15172696675959252, 0.13213410583747665, 0.1833132250512619, 0.14717964654903481, 0.22430370587251225, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09433545133027599, 0.09101912960836911, 0.0725809135963722, 0.050896896073669984, 0.0495789972984354, 0.09072171450752098, 0.08883629371616186, 0.0841903498836919, 0.05220180251922446, 0.23446379334395473, 0.09862613810617349, 0.432722571110305, 0.06137024156142801, 0.02952379671151395, 0.01014992290600747, 0.07837141833064742, 0.015766985331824634, 0.06629655259039757, 0.2178554776648296, 0.1998724348737454, 0.14311782242172644, 0.006547757346509364, 0.25342982890192456, 0.23492557149079274, 0.06039878740535154, 0.08023065862023326, 0.07734311845598674, 0.7136660344720269, 0.539480778423019, 0.501455258235985, 0.5045475263280585, 0.5388327387474467, 0.5133483101824373, 0.5909943711740318, 0.4915548686772859, 0.46545832705168955, 0.16481167613778958, 0.12066901796327201, 0.08172235603724642, 0.15246083195898386, 0.12333269809414216, 0.08503608310564992, 0.06325831417371597, 0.08396741329556223, 0.09174642617274908, 0.22514430338994063, 0.14372319658173105, 0.13914118184303803, 0.17369306237214532, 0.08604018169266092, 0.1452835085350005, 0.11077071274751671, 0.1602899600772696, 0.16846572605429955, 0.2372597146747707, 0.30477316338380334, 0.18404006005379459, 0.2940756442388903, 0.34496666265507125, 0.35923823397699406, 0.5207948635976757, 0.3772479466427935, 0.40009025219963446, 0.34713245492746747, 0.10735771727374799, 0.16076813378154986, 0.27157816612667907, 0.20807987703476205, 0.26590322979716197, 0.4156462620355317, 0.08138707216427954, 0.08751386911332049, 0.22012614330672764, 0.17796999837978777, 0.20379954647050458, 0.2307484249043441, 0.19230155573315166, 0.17351777237066035, 0.1950720919931931, 0.1736457382173836, 0.21494353536087496, 0.252415178984541, 0.18297305038743072, 0.1877174999588701, 0.2156616092028416, 0.7382425354163913, 0.19053132278521778, 0.2270016691316431, 0.20178759060208018, 0.21559471475685021, 0.1685826825374106, 0.8669963991132316, 0.9186876666246477, 0.2690178016534005, 0.16444512744056283, 0.19118724331749393, 0.1666132347903091, 0.13664679562927107, 0.13660567581826566, 0.31868814435830095, 0.32825770547507027, 0.38188801995141197, 0.20874027270566797, 0.21230610713037612, 0.21203982884067085, 0.12349399816692552, 0.12800890446059532, 0.12743885599263993, 0.1874633555528118, 0.19017802388395633, 0.21243463315069266, 0.1901267159432548, 0.17995358506175851, 0.21536337664712546, 0.16985895861823797, 0.19057011838487248, 0.15541112936548618, 0.09139852703925366, 0.07767833109710776, 0.08407352425883186, 0.0869594927046754, 0.0670006579576824, 0.0864859137770978, 0.0777281476831242, 0.08708476124362785, 0.0753886356893132]}, "mutation_prompt": null}
{"id": "adffc225-b448-4bc4-924a-6838d13d8265", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c, d = population[np.random.choice(idxs, 4, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * ((b - c) + 0.5 * (c - d)), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced mutation strategy by incorporating a weighted sum of random vectors for better exploration.", "configspace": "", "generation": 38, "fitness": 0.2717699109511851, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.9126362090193119, 0.7878496329346718, 0.8495405566602393, 0.2663320206792028, 0.8570705314995032, 0.902709849449022, 0.538027623170663, 0.44726712263542945, 0.29064686731365363, 0.4871523091964447, 0.48287054477807156, 0.5213067260488786, 0.6226530673224238, 0.7162877296148193, 0.7798670107697556, 0.748399740164924, 0.6218466528842532, 0.4506019719263685, 0.11093220197492615, 0.034632959279985887, 0.10657534622630427, 0.18668207385282842, 0.17748960029991723, 0.17712841766383536, 0.19161177794331985, 0.19239893687356824, 0.27736330690048583, 0.10663959050228766, 0.17505357562457702, 0.12871201563245072, 0.23170443283938325, 0.12865539280268223, 0.1101334104028785, 0.11995639868103503, 0.12463838474889599, 0.1309105186433439, 0.9737180712908786, 0.9737171619631606, 0.9737173140694985, 0.9679097878533528, 0.9637734689713062, 0.9585601050129314, 0.9645976547632816, 0.9657247486279009, 0.9657589084355207, 0.20020597694538178, 0.2218297440604099, 0.14101510108092752, 0.2918456265273389, 0.21041622311383645, 0.22051871160272762, 0.27508427428548043, 0.2833165624823749, 0.2658117130701336, 0.8975267060304151, 0.20818686364682892, 0.28406131970453186, 0.1931064684657775, 0.9139803167736059, 0.19393962254599806, 0.8492550694074842, 0.3104097708193302, 0.21752298320182817, 0.2168213152731655, 0.2468669939761282, 0.20180391305349543, 0.16537119018367608, 0.2139371425091119, 0.11948096007538223, 0.15949027560275952, 0.18498895254797365, 0.1300267632920863, 0.12661208436199178, 0.1436915437239803, 0.15779592654840813, 0.15426734762384753, 0.14948878456980186, 0.1457508945337378, 0.26313176097536006, 0.1583563719751182, 0.13662839282761596, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056072837811655285, 0.06894643075594831, 0.05392324182350383, 0.028179572694875032, 0.04065130676604334, 0.041334417509073185, 0.06355616178796575, 0.14440637946652712, 0.1270681579730859, 0.0739200950271719, 0.007957888683745473, 0.01812735200312887, 0.06648433453070268, 0.038438844117216986, 0.021991039059626738, 0.038889902887227934, 0.07297172950870989, 0.0525070178110012, 0.20355269621535976, 0.25325791322235014, 0.1985547445057959, 0.09946734040853078, 0.1422054928620632, 0.2536205893092356, 0.05510374816833408, 0.1781756836390911, 0.0422717505093122, 0.5817585261728165, 0.4292926402783923, 0.42671320019283443, 0.38811404392725357, 0.1878628481838982, 0.4355841980756826, 0.6640088252978993, 0.42200233841258517, 0.35824619577183503, 0.13734302219753614, 0.1560245844629753, 0.11866425587794605, 0.11197700605211425, 0.11861151735458153, 0.11596601755322733, 0.14663517891778644, 0.08343836628511603, 0.08157801711177559, 0.16944042326923914, 0.1246940686781749, 0.23231616564637503, 0.2630236729804687, 0.35691761325485827, 0.2091860993256197, 0.23899586127758454, 0.09268874467453136, 0.1469523285401214, 0.23142211529862244, 0.16907940890662898, 0.22616743882630652, 0.35772926777761815, 0.36029638188014146, 0.3702465356800215, 0.29184123924278615, 0.2235528441006599, 0.24419511093850765, 0.3102354656982438, 0.22519739608734113, 0.24771734740297757, 0.34340090702956294, 0.4300795940278873, 0.2607623294455317, 0.40240966996392635, 0.17062470227892312, 0.36324471595915186, 0.206689667240046, 0.238775913044046, 0.18844503606181828, 0.19600314514800998, 0.2036828828907712, 0.22846125011219742, 0.20736683731199923, 0.2093126614044062, 0.20710032108662813, 0.19546496441215766, 0.22170112749413318, 0.2219821838666982, 0.2539340599913117, 0.21141350761488897, 0.24582768249993137, 0.33592680255910357, 0.21626241700741844, 0.3392213122288693, 0.2603901410567837, 0.20594730094157887, 0.8920202100846996, 0.16571360817027447, 0.22503094157120684, 0.22213666405130195, 0.16429940194748383, 0.5524376318913475, 0.8295589202131353, 0.1691392097254023, 0.12082095822442929, 0.22066766268370108, 0.31085023608464557, 0.516626830666943, 0.41928557671261146, 0.1285837468779777, 0.12903825428711424, 0.1289630933501259, 0.182317162445909, 0.19397681851043203, 0.20831894978244458, 0.19190593126065025, 0.17804394665917955, 0.18035760762137798, 0.1902011909050585, 0.1904344065891741, 0.18932911665063712, 0.08567490341944062, 0.08196409517181924, 0.07680788512146264, 0.07525209178128012, 0.09258830019733832, 0.08734397086471235, 0.12210303972357983, 0.07404326973460351, 0.08947562376010443]}, "mutation_prompt": null}
{"id": "4fd81b1b-a401-47d8-9caa-918992f67264", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            # Adaptive population size reduction\n            adaptive_pop_size = max(4, int(self.population_size * (1 - 0.05 * fitness_variance / (fitness_variance + 1e-9))))\n            population = population[:adaptive_pop_size]\n            fitness = fitness[:adaptive_pop_size]\n            \n            for i in range(adaptive_pop_size):\n                idxs = [idx for idx in range(adaptive_pop_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced adaptive population size reduction based on fitness variance to enhance convergence speed and efficiency.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 7 is out of bounds for axis 0 with size 7').", "error": "IndexError('index 7 is out of bounds for axis 0 with size 7')", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {}, "mutation_prompt": null}
{"id": "f04735ae-6cea-4bce-9b75-a0ea1ba83d84", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.history_success = []\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.history_success.append(1)\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n                else:\n                    self.history_success.append(0)\n\n            success_rate = np.mean(self.history_success[-20:]) if len(self.history_success) >= 20 else 0.5\n            dynamic_crossover_rate = 0.9 * success_rate\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.03 + 0.07 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced local search with adaptive step size and dynamic crossover rates based on historical success to improve convergence.", "configspace": "", "generation": 40, "fitness": 0.27733465067534296, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.906343912632341, 0.9189647105286336, 0.9133904142752913, 0.9239393747632989, 0.9214172498871301, 0.9059614952815647, 0.9133371920339232, 0.9116220618091975, 0.9037553671494272, 0.8185361469791603, 0.8042904670810754, 0.8104177129854895, 0.7867493222189866, 0.8494526395502411, 0.8137688824045777, 0.8703968004369786, 0.8195433186767851, 0.8205351312929201, 0.8223339677011594, 0.19036739676645698, 0.19240241550906068, 0.8482195947843879, 0.1370368368137984, 0.1846880633544108, 0.19911516816079589, 0.18431351407000907, 0.17100085796395437, 0.317353321311203, 0.8167399195171978, 0.2793495137425853, 0.23235926062338563, 0.15889683642983143, 0.20963455336862624, 0.20334753698904962, 0.18918473587571738, 0.16796751167061752, 0.9845356898063475, 0.9845384638781615, 0.9845380603035083, 0.9743935794506975, 0.9743590277528337, 0.9743638730902756, 0.9776149455950739, 0.977612882693327, 0.9776131749496741, 0.2710760128226605, 0.27536987846827266, 0.2426593696383037, 0.21140738177144336, 0.25012756360378585, 0.180576501782448, 0.16917010812584454, 0.20172629200924708, 0.18530354067349775, 0.16026378942333452, 0.20246785377397625, 0.16385978959217462, 0.21665342718298164, 0.26618607461366084, 0.250698319999649, 0.22562924447129273, 0.21533484143996529, 0.26241583127141954, 0.18932233110847485, 0.25614848515422217, 0.26773045411610585, 0.10514391943914692, 0.17929327626852176, 0.2258159801224464, 0.2622193554662432, 0.23027487553034698, 0.12714750871306146, 0.1278896551841162, 0.1885216743236643, 0.16554173291418084, 0.158225624260238, 0.17296190785613796, 0.1892865086958303, 0.1242999819462226, 0.1587622392957555, 0.1295976946011842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09652318642077518, 0.06295443484883634, 0.06287494341510214, 0.045431912584240175, 0.06492389963757683, 0.06729635564390446, 0.0394592345162057, 0.06309224368294386, 0.06659044229668909, 0.0015736389978130427, 0.01467278273571715, 9.999999999998899e-05, 0.08080226455451867, 0.030431521517370497, 0.013321664278220124, 0.017262098374502766, 0.002345758135621323, 0.04166321785136751, 0.12593718185976066, 0.12145859226687239, 0.09316983907126508, 0.09900107689527904, 0.08358248832379322, 0.07526948356775953, 0.12789532957461847, 0.09445988210853884, 0.1442791475044949, 0.4712276520785641, 0.4866341599604779, 0.4577905288751387, 0.4308443867998879, 0.40747777209317115, 0.420832361228057, 0.4304820190148374, 0.42587946546658595, 0.43063789880095904, 0.14762722212050716, 0.11997716635497813, 0.11218802707690123, 0.10913828385195068, 0.11772364496735077, 0.08683923277923644, 0.07308176754036433, 0.08691908961707795, 0.08255787887278088, 0.17376231689111787, 0.15103463183313393, 0.22987685908032718, 0.18042370358023418, 0.1654846365454401, 0.1870040322692631, 0.1685999022011485, 0.15185854078771188, 0.18439106369350533, 0.2355765056941307, 0.22836310893606537, 0.2011737933505393, 0.25344935969996196, 0.20495098701800285, 0.24436015792112242, 0.2794589616038028, 0.24327861482912727, 0.2351647350783036, 0.16475218930869762, 0.17128267126070174, 0.12625852874445076, 0.1941665495693078, 0.16776692165376839, 0.18316094581129627, 0.19666797575973793, 0.07091554166266778, 0.06700402253849513, 0.18426280979742105, 0.21863357467547107, 0.19130074025428834, 0.19754636186675756, 0.20697871567269976, 0.20155451506757915, 0.18497586169802782, 0.17127233005227294, 0.21183507650856614, 0.313572191039165, 0.2279732126345103, 0.2202956802657301, 0.2289234920406411, 0.21076938405009016, 0.20949345724056545, 0.24901967168179828, 0.32985628632804287, 0.3521192463347572, 0.2247913914419163, 0.3666870643428136, 0.3926447124518332, 0.46168134485435053, 0.3037388399989496, 0.46301039304761493, 0.16678161548430326, 0.18488193596036884, 0.18254335167409286, 0.16886852408453612, 0.16896705425792147, 0.16882472176786012, 0.21570321237942658, 0.21622088767165937, 0.21618666910281847, 0.20681297548654332, 0.18410234132939762, 0.2490614647617786, 0.17301231762523128, 0.18110530802570834, 0.18251528764611258, 0.21349300260962534, 0.17821755299763586, 0.1852565323379618, 0.19613333011595702, 0.1890167252567987, 0.16761965578637483, 0.07480449987463211, 0.08081650302938992, 0.07872004114943376, 0.08434103397541914, 0.0936145137853982, 0.07705429757742988, 0.09388020378790807, 0.08799626556317686, 0.08406600411962661]}, "mutation_prompt": null}
{"id": "aecbccef-7ada-4364-8513-5953e288bf38", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)  # Calculate fitness variance\n            avg_fitness = np.mean(fitness)\n            adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))  # Dynamic adjustment\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / avg_fitness)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduced a fitness-based adaptive strategy for mutation factor scaling to improve convergence speed.", "configspace": "", "generation": 41, "fitness": 0.28485656540574383, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.7872974936051631, 0.8874366339007923, 0.7960571389690839, 0.8409570722649901, 0.9005712842468134, 0.7953138572894611, 0.8847389994139871, 0.6566655648374952, 0.7578698756000036, 0.8137068647045523, 0.8320086261180039, 0.8483105796496468, 0.7416576367660219, 0.7876936247590253, 0.7639617104828393, 0.742297769675087, 0.7926808730121188, 0.7505276186463348, 0.12842444443317436, 0.09940565341501317, 0.08748322152868881, 0.18926380423518308, 0.2618123365542242, 0.24084626781917595, 0.17609278084338498, 0.15337304202503543, 0.15705215708137765, 0.05761307409470373, 0.04792828902885449, 0.09485745541939483, 0.14241538388629393, 0.1705993288646983, 0.14556798589319153, 0.17421279230915676, 0.16748544203361804, 0.14193051670784285, 0.9771505973378658, 0.9771242272024693, 0.9771278095561297, 0.9894795840544073, 0.9884893596158714, 0.9894586333252717, 0.9744373888098637, 0.9758062981283547, 0.9758056876458877, 0.5126573226850868, 0.40789968536480625, 0.46005209433740524, 0.35774637260747166, 0.31755707375126074, 0.14646722972487936, 0.4699499071341916, 0.2873932106117476, 0.4992978070180979, 0.34150044896007925, 0.2238623593443264, 0.22587872556820077, 0.3075301579790446, 0.21229063572836726, 0.21068500877417629, 0.7955546835133548, 0.33485835499618, 0.7396577137321478, 0.30518831938688473, 0.20104536815646445, 0.2446673060910728, 0.1918136537453493, 0.1921692688295359, 0.1819445461180973, 0.1485595285012381, 0.12857398858020874, 0.12986817313512855, 0.12785976931077492, 0.15767913988080595, 0.16644526385170433, 0.14455101079547517, 0.18476793315804507, 0.16088694851413088, 0.1298414723882808, 0.1691540815628283, 0.16915133627118417, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032064528383561886, 9.999999999998899e-05, 0.11626663156826111, 0.13502093088394052, 0.17046434537007626, 0.06065795985187905, 0.06986145160421098, 0.09072171450752098, 0.11774749558972941, 0.08255428926456321, 0.03712628926769235, 0.01937049004689273, 9.999999999998899e-05, 0.000373449905460399, 0.017419548273989283, 0.05757546524363155, 0.0036043632723440355, 0.05788113695022146, 0.04734652677477713, 0.03133428060100829, 0.009145152822472302, 0.2887790671780823, 9.999999999998899e-05, 0.1967367442219935, 0.2007056794794927, 0.15091608242669208, 0.09579920163368938, 0.06294445283200112, 0.17162894391553507, 0.5287601949003549, 0.5310040154202688, 0.47990393473946746, 0.48202443293025676, 0.4626102477600087, 0.5147289153846395, 0.5434244695635426, 0.5473646315308663, 0.5660138580032978, 0.10145041433435564, 0.09821298723754013, 0.07684708642677429, 0.08268985987743194, 0.14210132200904624, 0.1055465559637212, 0.06660634374204455, 0.10940155484149217, 0.08173602784477485, 0.1648092815305937, 0.18207978289593862, 0.14221347426418451, 0.17511137013310984, 0.08604018169266092, 0.1452835085350005, 0.11077071274751671, 0.25269632994820157, 0.14341318772248235, 0.2224002858060229, 0.2207160917264377, 0.15604778048086265, 0.2993242768721941, 0.42877420042052483, 0.34356899836568167, 0.2003401126254286, 0.22675432885753588, 0.3519380872788054, 0.22967367467428035, 0.2315220303037535, 0.1544254962999685, 0.2720492698406769, 0.23888135034925684, 0.24473364982729118, 0.22208721311060275, 0.1409881294665376, 0.21024608984375226, 0.21188319382038645, 0.24203630051815495, 0.20437589101815845, 0.19734124209225823, 0.24302160965014008, 0.1969658834255541, 0.19492226584486216, 0.17377393811180297, 0.20313975850692845, 0.20887486690054435, 0.20689783117843108, 0.25021752777113393, 0.20622817413471584, 0.25195309764639473, 0.20043795020556088, 0.19335646795050765, 0.25379186725278713, 0.19036948589950575, 0.930574879242928, 0.8981762168389192, 0.873564368777847, 0.1736744667880875, 0.32604440830367953, 0.3411928390061718, 0.13594752249273767, 0.13664679562927107, 0.13680186979941933, 0.1507123687261559, 0.15131971580475345, 0.15124644599837123, 0.20874027270566797, 0.21230610713037612, 0.21203982884067085, 0.1274981869242593, 0.11659422964325783, 0.4877901522632345, 0.1964830013772877, 0.1831707694282615, 0.20197177335061178, 0.2158783778742469, 0.19121695578917164, 0.1921784418309952, 0.1581788518200905, 0.2428283421699, 0.1468306532378656, 0.08914847475295151, 0.07938506618688712, 0.09001860799079553, 0.08014053541487487, 0.07934260912687785, 0.10281926966462285, 0.08554723848301127, 0.07855254843028192, 0.07536200351601496]}, "mutation_prompt": null}
{"id": "03b64c3c-3691-4832-8b34-553f25283325", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhanced mutation adaptivity through learning from past successful mutations to potentially improve convergence speed.", "configspace": "", "generation": 42, "fitness": 0.29747198017086174, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "bc54c46e-a7a3-430b-8cfc-75de4d239c34", "metadata": {"aucs": [0.9046258351240177, 0.8984777591748351, 0.8770665119257438, 0.8937714209802634, 0.8867754298949905, 0.8792151472244716, 0.8898363021792903, 0.8811303004356615, 0.9078616476125951, 0.7482258500969758, 0.6155265556812586, 0.7851240686824432, 0.7939477689977887, 0.8459148965851435, 0.8131917638696826, 0.7772913645580055, 0.7899247221665737, 0.8017289496540908, 0.16472263740933724, 0.1524834265706746, 0.17149226500450876, 0.07363241001169174, 0.186045521634843, 0.17215732123043104, 0.18975670494878816, 0.16244811913345036, 0.1847687214589654, 0.08502585856578171, 0.0638262986095659, 0.08315618856074858, 0.147502804386052, 0.14652721224881593, 0.24473083666088613, 0.1584206992563466, 0.2503819724105295, 0.17854521886783736, 0.9770167653086292, 0.9805017430079909, 0.980503190760959, 0.9894761759804626, 0.9804396168414702, 0.9873661508589303, 0.9740573490031026, 0.9737761352195701, 0.9742901353023934, 0.7375323891677392, 0.5956189531226901, 0.5956512753504535, 0.5565089184227721, 0.5980348353759267, 0.565757623253753, 0.46561840045625036, 0.3929667844400717, 0.08927601417666997, 0.1675602976541648, 0.16778256498986288, 0.38075415751508024, 0.21165937336263696, 0.21424919531475206, 0.1614379783156613, 0.28282276067955314, 0.22146862845580173, 0.7969977180910164, 0.676926180191364, 0.189724196590505, 0.24140988161448862, 0.17193272864669906, 0.12299330529852792, 0.15768148709178187, 0.16006374638843446, 0.2707284347386426, 0.1324956182583351, 0.18471413353652588, 0.23310743656274224, 0.15346920330939395, 0.24096693004518777, 0.19292819755455515, 0.2419576145640988, 0.18971199366148195, 0.15530290715174377, 0.18957526132952118, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13384589921721213, 0.17279822395415245, 0.10478602818829674, 0.05325889062993561, 0.0804763643214681, 0.06424826755588242, 0.11558542657046766, 0.19967833676681612, 0.11877843863893944, 0.09337014152878531, 0.04739502250417704, 0.10747295053874117, 0.09043267480379746, 0.02356572263095591, 9.999999999998899e-05, 0.026571134946882347, 0.005127670821206243, 0.02979474076788613, 0.27074691481177693, 0.26097384365586695, 0.22707499156082867, 0.09255036828617325, 0.1292256283103136, 0.17692294154807586, 0.08686243313580577, 0.13198822499157048, 0.12446878941725392, 0.5083194464951415, 0.6573095941863565, 0.5257136144550474, 0.5723082016369292, 0.4681183893768509, 0.5131356735922135, 0.5291840489643631, 0.5507025609748775, 0.6194370109306901, 0.08373276348421677, 0.14347792763179945, 0.11092528513069688, 0.09490290165593707, 0.11513759448761374, 0.10342891997077863, 0.0702774051509869, 0.1006736679733482, 0.07145303417822957, 0.12589429045299294, 0.1001904776864021, 0.161323686534944, 0.14901338676021458, 0.12233845567365953, 0.15810015176014658, 0.18008656930220746, 0.24964005522375188, 0.2789195800329627, 0.19081975966443265, 0.182015828721527, 0.17793678784266942, 0.29067483224630364, 0.38538027161116806, 0.3369926960066867, 0.2675316760323675, 0.2504660135820226, 0.2858672016867885, 0.17281361230366987, 0.20126408362613013, 0.2604112164093142, 0.21621532097604323, 0.37431758300087514, 0.17783334808912843, 0.3036422450207573, 0.08090288158681036, 0.08052234841238715, 0.2094290743493571, 0.17094886768026696, 0.2342110107061116, 0.17699902852079963, 0.24638263399364657, 0.21881459489660637, 0.20586493383877325, 0.198192802386011, 0.2645408112523091, 0.17639761226423667, 0.2268619792100739, 0.21767154057968097, 0.1891940322296619, 0.19913966591066778, 0.834452944358137, 0.21123469457979038, 0.2094701838539863, 0.18483501574745098, 0.28064364540037257, 0.1537202972164181, 0.15372381142015834, 0.3234423513686905, 0.2328113520088837, 0.24528255234388463, 0.9126256644460982, 0.13685875066958997, 0.13669589152599015, 0.8098399968211278, 0.1693147579630826, 0.7045936210940458, 0.21174961518946245, 0.21173918226397448, 0.21201058353654867, 0.1281844809663758, 0.12797206989915832, 0.10853446542781786, 0.16883614200929353, 0.161482830460422, 0.19972924791385915, 0.1750768440015934, 0.1922032525456705, 0.1933158988871645, 0.18377393743847914, 0.19072603566005908, 0.13530077841372912, 0.09740997403253437, 0.07691881141753198, 0.07835826191879824, 0.07462027854680653, 0.08754051396897777, 0.08017205165846586, 0.07234012593082917, 0.0800529826668459, 0.07327786411464954]}, "mutation_prompt": null}
{"id": "74f17394-6e16-4e4b-8b1d-064a4e1c8407", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.initial_population_size = self.population_size\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        while self.budget > 0:\n            fitness_variance = np.var(fitness)\n            self.population_size = min(self.initial_population_size, max(4, int(self.initial_population_size * (1 + 0.1 * np.tanh(fitness_variance)))))\n            population = np.resize(population, (self.population_size, self.dim))\n            fitness = np.resize(fitness, self.population_size)\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introducing adaptive population size scaling based on fitness variance to enhance convergence speed and efficiency.", "configspace": "", "generation": 43, "fitness": 0.29747198017086174, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "03b64c3c-3691-4832-8b34-553f25283325", "metadata": {"aucs": [0.9046258351240177, 0.8984777591748351, 0.8770665119257438, 0.8937714209802634, 0.8867754298949905, 0.8792151472244716, 0.8898363021792903, 0.8811303004356615, 0.9078616476125951, 0.7482258500969758, 0.6155265556812586, 0.7851240686824432, 0.7939477689977887, 0.8459148965851435, 0.8131917638696826, 0.7772913645580055, 0.7899247221665737, 0.8017289496540908, 0.16472263740933724, 0.1524834265706746, 0.17149226500450876, 0.07363241001169174, 0.186045521634843, 0.17215732123043104, 0.18975670494878816, 0.16244811913345036, 0.1847687214589654, 0.08502585856578171, 0.0638262986095659, 0.08315618856074858, 0.147502804386052, 0.14652721224881593, 0.24473083666088613, 0.1584206992563466, 0.2503819724105295, 0.17854521886783736, 0.9770167653086292, 0.9805017430079909, 0.980503190760959, 0.9894761759804626, 0.9804396168414702, 0.9873661508589303, 0.9740573490031026, 0.9737761352195701, 0.9742901353023934, 0.7375323891677392, 0.5956189531226901, 0.5956512753504535, 0.5565089184227721, 0.5980348353759267, 0.565757623253753, 0.46561840045625036, 0.3929667844400717, 0.08927601417666997, 0.1675602976541648, 0.16778256498986288, 0.38075415751508024, 0.21165937336263696, 0.21424919531475206, 0.1614379783156613, 0.28282276067955314, 0.22146862845580173, 0.7969977180910164, 0.676926180191364, 0.189724196590505, 0.24140988161448862, 0.17193272864669906, 0.12299330529852792, 0.15768148709178187, 0.16006374638843446, 0.2707284347386426, 0.1324956182583351, 0.18471413353652588, 0.23310743656274224, 0.15346920330939395, 0.24096693004518777, 0.19292819755455515, 0.2419576145640988, 0.18971199366148195, 0.15530290715174377, 0.18957526132952118, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13384589921721213, 0.17279822395415245, 0.10478602818829674, 0.05325889062993561, 0.0804763643214681, 0.06424826755588242, 0.11558542657046766, 0.19967833676681612, 0.11877843863893944, 0.09337014152878531, 0.04739502250417704, 0.10747295053874117, 0.09043267480379746, 0.02356572263095591, 9.999999999998899e-05, 0.026571134946882347, 0.005127670821206243, 0.02979474076788613, 0.27074691481177693, 0.26097384365586695, 0.22707499156082867, 0.09255036828617325, 0.1292256283103136, 0.17692294154807586, 0.08686243313580577, 0.13198822499157048, 0.12446878941725392, 0.5083194464951415, 0.6573095941863565, 0.5257136144550474, 0.5723082016369292, 0.4681183893768509, 0.5131356735922135, 0.5291840489643631, 0.5507025609748775, 0.6194370109306901, 0.08373276348421677, 0.14347792763179945, 0.11092528513069688, 0.09490290165593707, 0.11513759448761374, 0.10342891997077863, 0.0702774051509869, 0.1006736679733482, 0.07145303417822957, 0.12589429045299294, 0.1001904776864021, 0.161323686534944, 0.14901338676021458, 0.12233845567365953, 0.15810015176014658, 0.18008656930220746, 0.24964005522375188, 0.2789195800329627, 0.19081975966443265, 0.182015828721527, 0.17793678784266942, 0.29067483224630364, 0.38538027161116806, 0.3369926960066867, 0.2675316760323675, 0.2504660135820226, 0.2858672016867885, 0.17281361230366987, 0.20126408362613013, 0.2604112164093142, 0.21621532097604323, 0.37431758300087514, 0.17783334808912843, 0.3036422450207573, 0.08090288158681036, 0.08052234841238715, 0.2094290743493571, 0.17094886768026696, 0.2342110107061116, 0.17699902852079963, 0.24638263399364657, 0.21881459489660637, 0.20586493383877325, 0.198192802386011, 0.2645408112523091, 0.17639761226423667, 0.2268619792100739, 0.21767154057968097, 0.1891940322296619, 0.19913966591066778, 0.834452944358137, 0.21123469457979038, 0.2094701838539863, 0.18483501574745098, 0.28064364540037257, 0.1537202972164181, 0.15372381142015834, 0.3234423513686905, 0.2328113520088837, 0.24528255234388463, 0.9126256644460982, 0.13685875066958997, 0.13669589152599015, 0.8098399968211278, 0.1693147579630826, 0.7045936210940458, 0.21174961518946245, 0.21173918226397448, 0.21201058353654867, 0.1281844809663758, 0.12797206989915832, 0.10853446542781786, 0.16883614200929353, 0.161482830460422, 0.19972924791385915, 0.1750768440015934, 0.1922032525456705, 0.1933158988871645, 0.18377393743847914, 0.19072603566005908, 0.13530077841372912, 0.09740997403253437, 0.07691881141753198, 0.07835826191879824, 0.07462027854680653, 0.08754051396897777, 0.08017205165846586, 0.07234012593082917, 0.0800529826668459, 0.07327786411464954]}, "mutation_prompt": null}
{"id": "fff18d65-cdcb-4c2f-91b7-6af7583ff67b", "solution": "import numpy as np\n\nclass HybridDEAMSv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.initial_population_size = self.population_size\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.adaptive_mutation_factor = self.mutation_factor\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        \n        dynamic_crossover_rate = self.crossover_rate\n        for iteration in range(self.budget):\n            fitness_variance = np.var(fitness)\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                self.adaptive_mutation_factor = self.mutation_factor * (1 + 0.1 * avg_successful_mutation)\n            else:\n                self.adaptive_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(self.adaptive_mutation_factor)\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n            \n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness))\n            if iteration % 10 == 0 and iteration > 0:\n                self._dynamic_population_resizing(fitness)\n                \n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1\n\n    def _dynamic_population_resizing(self, fitness):\n        mean_fitness = np.mean(fitness)\n        if mean_fitness < 1.5 * self.best_fitness:\n            self.population_size = min(self.initial_population_size, self.population_size + 1)\n        elif mean_fitness > 2.5 * self.best_fitness:\n            self.population_size = max(5, self.population_size - 1)", "name": "HybridDEAMSv2", "description": "Introducing adaptive mutation rate and dynamic population resizing to enhance exploration capabilities and convergence speed.", "configspace": "", "generation": 44, "fitness": 0.2458164504405051, "feedback": "The algorithm HybridDEAMSv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "03b64c3c-3691-4832-8b34-553f25283325", "metadata": {"aucs": [0.9046258351240177, 0.8984777591748351, 0.8770665119257438, 0.8937714209802634, 0.8867754298949905, 0.8792151472244716, 0.3475422194062978, 0.2885067810927123, 0.2935855420231922, 0.7207091106362373, 0.7772161442934922, 0.8299307606371916, 0.6602468137843613, 0.8224726591750696, 0.6902930878695852, 0.8085544625096761, 0.6490974418689119, 0.48513817506348367, 0.06926019944172346, 0.11751244197455202, 0.07184124123761682, 0.07363241001169174, 0.186045521634843, 0.17215732123043104, 0.18975670494878816, 0.16244811913345036, 0.1847687214589654, 0.04123729212986671, 0.10194174252658073, 0.0693361483696523, 0.147502804386052, 0.14652721224881593, 0.24473083666088613, 0.1584206992563466, 0.2503819724105295, 0.17854521886783736, 0.9783723966336714, 0.9805017430079909, 0.980503190760959, 0.9894761759804626, 0.9804396168414702, 0.9873661508589303, 0.9740573490031026, 0.9737761352195701, 0.9742901353023934, 0.2763125638575772, 0.33983347216115045, 0.30637584911212024, 0.17512893906478288, 0.2256572255393714, 0.1192781117151771, 0.13187025795704832, 0.1854458011779152, 0.17912696387443172, 0.1675602976541648, 0.16778256498986288, 0.38075415751508024, 0.884515593279484, 0.21424919531475206, 0.1614379783156613, 0.18016030399414262, 0.1501371729367038, 0.19517967154025162, 0.13473654060354345, 0.18919159634406346, 0.13104323227374337, 0.09432819439259843, 0.08944972309770127, 0.10251441175374498, 0.28053303850122324, 0.12928149147366474, 0.23743309944112123, 0.14652097583554824, 0.13953151695598864, 0.19223727051568507, 0.1585826066670052, 0.15458693172409, 0.15005431284396742, 0.1359354913169274, 0.11980779904291872, 0.1281558780591706, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05492963158584241, 0.07859519875681675, 0.05305532686290426, 0.04323469556065862, 0.07379601061657048, 0.06341534905897739, 0.1164735045116444, 0.06646187153689476, 0.08645835352081122, 0.031201002652893606, 0.05601638706348222, 0.05399237830240766, 9.999999999998899e-05, 0.053973010972635294, 0.10423767505921311, 0.013101426951903528, 0.05153076379173305, 0.028630807000598946, 0.11675694637953404, 0.17442927354938476, 0.1980611818658241, 0.1337130416263994, 0.11482652364605817, 0.12855369098818514, 0.03278302186061555, 0.044805200790310695, 0.040038127358923536, 0.28718134701574216, 0.3651126603477892, 0.3737274825450796, 0.32409494643982584, 0.41438240115028324, 0.35779130327926445, 0.5291840489643631, 0.5507025609748775, 0.6194370109306901, 0.08373276348421677, 0.14347792763179945, 0.11092528513069688, 0.09490290165593707, 0.11513759448761374, 0.10342891997077863, 0.07188183686883276, 0.0981632530173252, 0.11465989044380076, 0.12589429045299294, 0.1001904776864021, 0.161323686534944, 0.13011358297305597, 0.11534151754032373, 0.11526862310449981, 0.18008656930220746, 0.24964005522375188, 0.2789195800329627, 0.19799157771706488, 0.16880585795876868, 0.17772152577446998, 0.29067483224630364, 0.38538027161116806, 0.3369926960066867, 0.2675316760323675, 0.2504660135820226, 0.2858672016867885, 0.11883714254968103, 0.11526234500422183, 0.11620588263633691, 0.21621532097604323, 0.37431758300087514, 0.17783334808912843, 0.3036422450207573, 0.08090288158681036, 0.08052234841238715, 0.16417003085244974, 0.19529825957173075, 0.19130733653763177, 0.17699902852079963, 0.24638263399364657, 0.21881459489660637, 0.20586493383877325, 0.198192802386011, 0.2645408112523091, 0.2290801746255713, 0.3164895972745152, 0.22685411875278882, 0.19135306567794175, 0.198614990527458, 0.24840182898148322, 0.20840685794578384, 0.1995888717498394, 0.4475409642480792, 0.28064364540037257, 0.1537202972164181, 0.15372381142015834, 0.22398673266223934, 0.16529009373227233, 0.16450413608861814, 0.1612095035309965, 0.11871965430797105, 0.11780490812458466, 0.24422877181392244, 0.16950582978591278, 0.2812905770210926, 0.21174961518946245, 0.21173918226397448, 0.21201058353654867, 0.11347041763991095, 0.12334537533083678, 0.1633826700131329, 0.16883614200929353, 0.161482830460422, 0.19972924791385915, 0.1750768440015934, 0.19064480893418345, 0.1933158988871645, 0.15920914441542267, 0.16711132512889093, 0.13530077841372912, 0.09740997403253437, 0.07691881141753198, 0.07835826191879824, 0.07462027854680653, 0.08754051396897777, 0.08017205165846586, 0.07234012593082917, 0.0800529826668459, 0.07327786411464954]}, "mutation_prompt": null}
{"id": "18ac7e59-7857-4314-90e0-81b77ecf10ff", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Integrating adaptive crossover rate adjustments based on success probabilities to enhance convergence efficiency.", "configspace": "", "generation": 45, "fitness": 0.29756290025924936, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "03b64c3c-3691-4832-8b34-553f25283325", "metadata": {"aucs": [0.9046258351240177, 0.8957795775998122, 0.8770665119257438, 0.8935905942013963, 0.8867754298949905, 0.8792151472244716, 0.8898363021792903, 0.8811303004356615, 0.9078616476125951, 0.7918143806415125, 0.5335378484312795, 0.7851240686824432, 0.79544272097438, 0.8414329220248287, 0.8131917638696826, 0.7694523313565069, 0.7899247221665737, 0.7789751677406531, 0.16472263740933724, 0.15082136845556326, 0.17149226500450876, 0.07363241001169174, 0.186045521634843, 0.17215732123043104, 0.18975670494878816, 0.16244811913345036, 0.19143144985268024, 0.08502585856578171, 0.0638262986095659, 0.08315618856074858, 0.18181216668993982, 0.14652721224881593, 0.24473083666088613, 0.1584206992563466, 0.2503819724105295, 0.17854521886783736, 0.9770167653086292, 0.9805017430079909, 0.980503190760959, 0.9894761759804626, 0.9804396168414702, 0.9873661508589303, 0.9740573490031026, 0.9737761352195701, 0.9742901353023934, 0.6853451525070683, 0.7109905404558476, 0.7060813317780577, 0.5144134397290662, 0.5805677834297315, 0.6357699946900404, 0.4767659160541635, 0.43142613732676194, 0.08927601417666997, 0.1675602976541648, 0.16778256498986288, 0.38075415751508024, 0.21165937336263696, 0.21424919531475206, 0.1614379783156613, 0.28282276067955314, 0.22146862845580173, 0.7969977180910164, 0.5695967823886974, 0.19239901706940077, 0.24227880759027864, 0.16014762344584155, 0.12153722368757713, 0.18208070756511996, 0.1578738335314701, 0.27372627067876454, 0.1324973666104553, 0.17287188771803408, 0.2342470693398997, 0.1536117542391776, 0.200604683890947, 0.2086755445614994, 0.2421151511912648, 0.21199199570285165, 0.15557793020913957, 0.18965025725743268, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13389888770232827, 0.17149735600076343, 0.10478757981667697, 0.05325889062993561, 0.0804763643214681, 0.06424826755588242, 0.11558542657046766, 0.20369705802786042, 0.11877843863893944, 0.09337014152878531, 0.04739502250417704, 0.10747295053874117, 0.09043267480379746, 0.02356572263095591, 9.999999999998899e-05, 0.026571134946882347, 0.005127670821206243, 0.02979474076788613, 0.27073181792530054, 0.26123243156886966, 0.26801634974049504, 0.09255036828617325, 0.1289890362374565, 0.17057072965167097, 0.06753524219166573, 0.1269059258729841, 0.1621608064375325, 0.47786841043579054, 0.6574004847097812, 0.5236976939448802, 0.5130571947884223, 0.4784312308868406, 0.5235246990384559, 0.5301338000628611, 0.5337974366106462, 0.5854605390007501, 0.08373276350018277, 0.14347792765071476, 0.11092528513064004, 0.09490290165084225, 0.11513759449251171, 0.10342909045413051, 0.0702774051509869, 0.1006736679733482, 0.07145793100993392, 0.12589429045299294, 0.1001904776864021, 0.16143919471249046, 0.14901338676021458, 0.12233845567365953, 0.15810015176014658, 0.18008656930220746, 0.24963198689021937, 0.2789195800329627, 0.19081975966443265, 0.1820337768038025, 0.17793678784266942, 0.29065946863627046, 0.38538027161116806, 0.33805048901651436, 0.2675005538243006, 0.24866242435214303, 0.2859258022523814, 0.17281361230366987, 0.20126408362613013, 0.26041123797683874, 0.21588615814313028, 0.37431770299248146, 0.1778333737476422, 0.3028989054942197, 0.08090288158681036, 0.08052234840116834, 0.2092616656431936, 0.17045900417837634, 0.2341542298277295, 0.17699902852079963, 0.2463826211982667, 0.22101711310617833, 0.20612020150407218, 0.19871062683171237, 0.2645402024380683, 0.1763974622828588, 0.22686197924533036, 0.21767154057968097, 0.18919417730495225, 0.19914090908895887, 0.834452944358137, 0.21123469457963462, 0.20947018370540826, 0.18483501574745098, 0.28064364540037257, 0.1537202949768236, 0.15372381140815627, 0.3234423513686905, 0.2328113520088837, 0.24528255234388463, 0.9126256644460982, 0.1368587639859501, 0.1366960182366903, 0.8130688122372121, 0.16931485698160353, 0.6919481985470703, 0.21174961549854487, 0.2117391822362209, 0.21201110967916026, 0.12818448096696466, 0.12797191927918372, 0.10853446542781786, 0.16817888966850258, 0.161482830460422, 0.19972924791318925, 0.1750768440015934, 0.1922032525456705, 0.1933158988871645, 0.18377381847906138, 0.19482336642468878, 0.13530077841372912, 0.09739389459624748, 0.0769558823810732, 0.07964392467768844, 0.07462027883814826, 0.08753978387550942, 0.08018359807013165, 0.07234012593082917, 0.0800529826668459, 0.07327786411464954]}, "mutation_prompt": null}
{"id": "636095ae-d8ca-4380-ae5c-78cc22a71474", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.dynamic_population_adjustment = 0.5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n            # Dynamic population resizing based on success rate\n            if self.success_rate > self.dynamic_population_adjustment and self.budget > self.population_size:\n                extra_individuals = int(self.population_size * 0.1)\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (extra_individuals, self.dim))\n                population = np.vstack((population, new_individuals))\n                new_fitness = np.apply_along_axis(func, 1, new_individuals)\n                fitness = np.concatenate((fitness, new_fitness))\n                self.budget -= extra_individuals\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Enhance exploration using adaptive dynamic population resizing to improve convergence speed.", "configspace": "", "generation": 46, "fitness": 0.29756290025924936, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "18ac7e59-7857-4314-90e0-81b77ecf10ff", "metadata": {"aucs": [0.9046258351240177, 0.8957795775998122, 0.8770665119257438, 0.8935905942013963, 0.8867754298949905, 0.8792151472244716, 0.8898363021792903, 0.8811303004356615, 0.9078616476125951, 0.7918143806415125, 0.5335378484312795, 0.7851240686824432, 0.79544272097438, 0.8414329220248287, 0.8131917638696826, 0.7694523313565069, 0.7899247221665737, 0.7789751677406531, 0.16472263740933724, 0.15082136845556326, 0.17149226500450876, 0.07363241001169174, 0.186045521634843, 0.17215732123043104, 0.18975670494878816, 0.16244811913345036, 0.19143144985268024, 0.08502585856578171, 0.0638262986095659, 0.08315618856074858, 0.18181216668993982, 0.14652721224881593, 0.24473083666088613, 0.1584206992563466, 0.2503819724105295, 0.17854521886783736, 0.9770167653086292, 0.9805017430079909, 0.980503190760959, 0.9894761759804626, 0.9804396168414702, 0.9873661508589303, 0.9740573490031026, 0.9737761352195701, 0.9742901353023934, 0.6853451525070683, 0.7109905404558476, 0.7060813317780577, 0.5144134397290662, 0.5805677834297315, 0.6357699946900404, 0.4767659160541635, 0.43142613732676194, 0.08927601417666997, 0.1675602976541648, 0.16778256498986288, 0.38075415751508024, 0.21165937336263696, 0.21424919531475206, 0.1614379783156613, 0.28282276067955314, 0.22146862845580173, 0.7969977180910164, 0.5695967823886974, 0.19239901706940077, 0.24227880759027864, 0.16014762344584155, 0.12153722368757713, 0.18208070756511996, 0.1578738335314701, 0.27372627067876454, 0.1324973666104553, 0.17287188771803408, 0.2342470693398997, 0.1536117542391776, 0.200604683890947, 0.2086755445614994, 0.2421151511912648, 0.21199199570285165, 0.15557793020913957, 0.18965025725743268, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13389888770232827, 0.17149735600076343, 0.10478757981667697, 0.05325889062993561, 0.0804763643214681, 0.06424826755588242, 0.11558542657046766, 0.20369705802786042, 0.11877843863893944, 0.09337014152878531, 0.04739502250417704, 0.10747295053874117, 0.09043267480379746, 0.02356572263095591, 9.999999999998899e-05, 0.026571134946882347, 0.005127670821206243, 0.02979474076788613, 0.27073181792530054, 0.26123243156886966, 0.26801634974049504, 0.09255036828617325, 0.1289890362374565, 0.17057072965167097, 0.06753524219166573, 0.1269059258729841, 0.1621608064375325, 0.47786841043579054, 0.6574004847097812, 0.5236976939448802, 0.5130571947884223, 0.4784312308868406, 0.5235246990384559, 0.5301338000628611, 0.5337974366106462, 0.5854605390007501, 0.08373276350018277, 0.14347792765071476, 0.11092528513064004, 0.09490290165084225, 0.11513759449251171, 0.10342909045413051, 0.0702774051509869, 0.1006736679733482, 0.07145793100993392, 0.12589429045299294, 0.1001904776864021, 0.16143919471249046, 0.14901338676021458, 0.12233845567365953, 0.15810015176014658, 0.18008656930220746, 0.24963198689021937, 0.2789195800329627, 0.19081975966443265, 0.1820337768038025, 0.17793678784266942, 0.29065946863627046, 0.38538027161116806, 0.33805048901651436, 0.2675005538243006, 0.24866242435214303, 0.2859258022523814, 0.17281361230366987, 0.20126408362613013, 0.26041123797683874, 0.21588615814313028, 0.37431770299248146, 0.1778333737476422, 0.3028989054942197, 0.08090288158681036, 0.08052234840116834, 0.2092616656431936, 0.17045900417837634, 0.2341542298277295, 0.17699902852079963, 0.2463826211982667, 0.22101711310617833, 0.20612020150407218, 0.19871062683171237, 0.2645402024380683, 0.1763974622828588, 0.22686197924533036, 0.21767154057968097, 0.18919417730495225, 0.19914090908895887, 0.834452944358137, 0.21123469457963462, 0.20947018370540826, 0.18483501574745098, 0.28064364540037257, 0.1537202949768236, 0.15372381140815627, 0.3234423513686905, 0.2328113520088837, 0.24528255234388463, 0.9126256644460982, 0.1368587639859501, 0.1366960182366903, 0.8130688122372121, 0.16931485698160353, 0.6919481985470703, 0.21174961549854487, 0.2117391822362209, 0.21201110967916026, 0.12818448096696466, 0.12797191927918372, 0.10853446542781786, 0.16817888966850258, 0.161482830460422, 0.19972924791318925, 0.1750768440015934, 0.1922032525456705, 0.1933158988871645, 0.18377381847906138, 0.19482336642468878, 0.13530077841372912, 0.09739389459624748, 0.0769558823810732, 0.07964392467768844, 0.07462027883814826, 0.08753978387550942, 0.08018359807013165, 0.07234012593082917, 0.0800529826668459, 0.07327786411464954]}, "mutation_prompt": null}
{"id": "6c621726-e5ad-4cf6-bcc7-4c021d5272c3", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n\n            if fitness_variance < 1e-5:\n                self.population_size = max(4, self.population_size - 1)\n            elif fitness_variance > 0.1:\n                self.population_size = min(self.initial_population_size + 5, self.population_size + 1)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            if self.budget <= 0:\n                break\n            step_size_scale = 0.05 + 0.05 * self.success_rate\n            for d in range(self.dim):\n                step_size = (self.upper_bound - self.lower_bound) * step_size_scale\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introduce adaptive step-size scaling for local search and dynamic population size adjustment based on fitness diversity for enhanced convergence.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 8 is out of bounds for axis 0 with size 8').", "error": "IndexError('index 8 is out of bounds for axis 0 with size 8')", "parent_id": "18ac7e59-7857-4314-90e0-81b77ecf10ff", "metadata": {}, "mutation_prompt": null}
{"id": "526129a3-9c68-497d-a094-066817212b5f", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n\n            adjusted_mutation_factor *= (1 + 0.1 * self.success_rate)  # Slight change here\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introducing adaptive mutation factor based on success rate to enhance convergence speed.", "configspace": "", "generation": 48, "fitness": 0.2937334286594455, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "18ac7e59-7857-4314-90e0-81b77ecf10ff", "metadata": {"aucs": [0.9013195554993982, 0.9012114177896299, 0.8372329732358577, 0.8916172822947008, 0.8574568561543088, 0.8631870637603563, 0.9037019463447316, 0.8830599131443552, 0.8962605828692003, 0.8425787854775062, 0.7642983745393056, 0.8285393126532503, 0.8057200408967017, 0.8122337679538882, 0.8170284739355126, 0.75766282757456, 0.8249459834737143, 0.7869352288158937, 0.16439585574231041, 0.15083027262307225, 0.14310970487732033, 0.07402865538793668, 0.13218502335749616, 0.17241452322782003, 0.23991344652374413, 0.16266299347103508, 0.18667872594917878, 0.10567700461737928, 0.0637451400363831, 0.08316370426952746, 0.2602930057115075, 0.14457901978039167, 0.17398754175194042, 0.15165312839552514, 0.15541334070423363, 0.164207217908785, 0.9770166589204488, 0.9805017490742524, 0.9805031969046257, 0.9894761790962494, 0.9804406467517155, 0.9873667951130503, 0.974057512221448, 0.973776393079084, 0.9742901833852862, 0.3973491697931293, 0.5392195962348698, 0.4665014684080039, 0.5333223481321363, 0.5719203568936144, 0.5763181785713707, 0.5285667150310935, 0.4874840405525981, 0.0892730206513157, 0.1675602976541648, 0.22138003259258132, 0.22271404672031492, 0.21165937336263696, 0.21428615832905384, 0.1614379783156613, 0.7743102047517898, 0.28264920551180284, 0.3676288251748421, 0.3174280708670044, 0.18417607878155917, 0.15573643110252067, 0.18776569728576475, 0.12074480317462655, 0.17674216717376656, 0.16830821698549658, 0.22149679872693873, 0.1861617864595796, 0.17385372798989795, 0.1883988122308412, 0.13871000260973654, 0.21175317267551097, 0.19508476513423667, 0.20006645428846037, 0.19775809169677383, 0.18821628470851992, 0.12384021623376595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13418857755595615, 0.1720965665754589, 0.15877242401435776, 0.053649166489129985, 0.08038660234070416, 0.06430822461598384, 0.11495388034724019, 0.10774884034413335, 0.12602420804075987, 0.11066557541944055, 0.10674958221629127, 0.07121505665583538, 0.05183090789562994, 0.028561680823664948, 9.999999999998899e-05, 0.01896248246392407, 0.017782486534047348, 9.999999999998899e-05, 0.19620684196763516, 0.26427127029866404, 0.27010416550215166, 0.34566654330583046, 0.27930570847049585, 0.1450507498698005, 0.13057805697254576, 0.12286435503088777, 0.10381279288563527, 0.6014810011272511, 0.6634541871705388, 0.4471787060483958, 0.5384918737937988, 0.4857698360651589, 0.6387899899995828, 0.5208707739424137, 0.5378651176938366, 0.5184621912637193, 0.08373338492803373, 0.14355015396971427, 0.11084149300821788, 0.09492538622114444, 0.11490198870990131, 0.10353560619751678, 0.05571737010254396, 0.10715817625609403, 0.07148225070561542, 0.12780834912015981, 0.1001904776864021, 0.15799089093989094, 0.11453512164091462, 0.12980331180986193, 0.11961966091263587, 0.1819520001040793, 0.2444046240355493, 0.295774483078184, 0.18608192699281467, 0.18212468917125801, 0.17808833271001823, 0.312126085914214, 0.2827499492274972, 0.2715635351152883, 0.34906466953132076, 0.24442088676609042, 0.4066997705293576, 0.1728862707308092, 0.18298328410977882, 0.29638991645276525, 0.2767434504262901, 0.2625012107600737, 0.17108675678224172, 0.2396095570261817, 0.08074445800602903, 0.06913529461403645, 0.16398341747879475, 0.2361016895546979, 0.22755815098069254, 0.22356180786666346, 0.21521976431945278, 0.2171069778688005, 0.22279612480814226, 0.25183816437629625, 0.22475596134077847, 0.17639404012550475, 0.22674510784869395, 0.2217673447556079, 0.2098781029469996, 0.19929473823475952, 0.8413992324444293, 0.2107639755677181, 0.20836914217005953, 0.18118281898398003, 0.6934646574654462, 0.15372026427993257, 0.15371690443021802, 0.3106197653079732, 0.23252742119880843, 0.24513190380880023, 0.9139780481873367, 0.13674324916705083, 0.13669061126909765, 0.30975751368996196, 0.16825211969231457, 0.50395586021613, 0.21173152291408848, 0.21172516886883974, 0.21212144505892205, 0.1281846726130983, 0.1279636300960736, 0.10853643866509155, 0.23427315690071016, 0.15476994298099667, 0.18567022062431626, 0.18033173716472317, 0.16774786418815235, 0.17558311139290295, 0.18347697907670169, 0.2025172621800322, 0.13530077841372912, 0.08902648708220151, 0.08146471356655915, 0.11095344677515184, 0.07467236219544648, 0.10223322509270005, 0.09090629956429563, 0.0886686280629041, 0.06753919569416234, 0.08042162274925946]}, "mutation_prompt": null}
{"id": "5c98aaf9-0f76-499f-bd2f-20acf924ba84", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(4 + np.floor(3 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.dynamic_population_factor = 0.05  # New parameter for dynamic population adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + 0.1 * np.tanh(fitness_variance))\n\n            # Dynamic population size adjustment\n            adjusted_population_size = int(self.population_size * (1 + self.dynamic_population_factor * (1 - self.success_rate)))\n            adjusted_population_size = min(max(4, adjusted_population_size), self.dim * 10)  # Ensure reasonable bounds\n\n            for i in range(adjusted_population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introducing dynamic population size adjustment to improve convergence by adapting to the problem's complexity.", "configspace": "", "generation": 49, "fitness": 0.29756290025924936, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "18ac7e59-7857-4314-90e0-81b77ecf10ff", "metadata": {"aucs": [0.9046258351240177, 0.8957795775998122, 0.8770665119257438, 0.8935905942013963, 0.8867754298949905, 0.8792151472244716, 0.8898363021792903, 0.8811303004356615, 0.9078616476125951, 0.7918143806415125, 0.5335378484312795, 0.7851240686824432, 0.79544272097438, 0.8414329220248287, 0.8131917638696826, 0.7694523313565069, 0.7899247221665737, 0.7789751677406531, 0.16472263740933724, 0.15082136845556326, 0.17149226500450876, 0.07363241001169174, 0.186045521634843, 0.17215732123043104, 0.18975670494878816, 0.16244811913345036, 0.19143144985268024, 0.08502585856578171, 0.0638262986095659, 0.08315618856074858, 0.18181216668993982, 0.14652721224881593, 0.24473083666088613, 0.1584206992563466, 0.2503819724105295, 0.17854521886783736, 0.9770167653086292, 0.9805017430079909, 0.980503190760959, 0.9894761759804626, 0.9804396168414702, 0.9873661508589303, 0.9740573490031026, 0.9737761352195701, 0.9742901353023934, 0.6853451525070683, 0.7109905404558476, 0.7060813317780577, 0.5144134397290662, 0.5805677834297315, 0.6357699946900404, 0.4767659160541635, 0.43142613732676194, 0.08927601417666997, 0.1675602976541648, 0.16778256498986288, 0.38075415751508024, 0.21165937336263696, 0.21424919531475206, 0.1614379783156613, 0.28282276067955314, 0.22146862845580173, 0.7969977180910164, 0.5695967823886974, 0.19239901706940077, 0.24227880759027864, 0.16014762344584155, 0.12153722368757713, 0.18208070756511996, 0.1578738335314701, 0.27372627067876454, 0.1324973666104553, 0.17287188771803408, 0.2342470693398997, 0.1536117542391776, 0.200604683890947, 0.2086755445614994, 0.2421151511912648, 0.21199199570285165, 0.15557793020913957, 0.18965025725743268, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13389888770232827, 0.17149735600076343, 0.10478757981667697, 0.05325889062993561, 0.0804763643214681, 0.06424826755588242, 0.11558542657046766, 0.20369705802786042, 0.11877843863893944, 0.09337014152878531, 0.04739502250417704, 0.10747295053874117, 0.09043267480379746, 0.02356572263095591, 9.999999999998899e-05, 0.026571134946882347, 0.005127670821206243, 0.02979474076788613, 0.27073181792530054, 0.26123243156886966, 0.26801634974049504, 0.09255036828617325, 0.1289890362374565, 0.17057072965167097, 0.06753524219166573, 0.1269059258729841, 0.1621608064375325, 0.47786841043579054, 0.6574004847097812, 0.5236976939448802, 0.5130571947884223, 0.4784312308868406, 0.5235246990384559, 0.5301338000628611, 0.5337974366106462, 0.5854605390007501, 0.08373276350018277, 0.14347792765071476, 0.11092528513064004, 0.09490290165084225, 0.11513759449251171, 0.10342909045413051, 0.0702774051509869, 0.1006736679733482, 0.07145793100993392, 0.12589429045299294, 0.1001904776864021, 0.16143919471249046, 0.14901338676021458, 0.12233845567365953, 0.15810015176014658, 0.18008656930220746, 0.24963198689021937, 0.2789195800329627, 0.19081975966443265, 0.1820337768038025, 0.17793678784266942, 0.29065946863627046, 0.38538027161116806, 0.33805048901651436, 0.2675005538243006, 0.24866242435214303, 0.2859258022523814, 0.17281361230366987, 0.20126408362613013, 0.26041123797683874, 0.21588615814313028, 0.37431770299248146, 0.1778333737476422, 0.3028989054942197, 0.08090288158681036, 0.08052234840116834, 0.2092616656431936, 0.17045900417837634, 0.2341542298277295, 0.17699902852079963, 0.2463826211982667, 0.22101711310617833, 0.20612020150407218, 0.19871062683171237, 0.2645402024380683, 0.1763974622828588, 0.22686197924533036, 0.21767154057968097, 0.18919417730495225, 0.19914090908895887, 0.834452944358137, 0.21123469457963462, 0.20947018370540826, 0.18483501574745098, 0.28064364540037257, 0.1537202949768236, 0.15372381140815627, 0.3234423513686905, 0.2328113520088837, 0.24528255234388463, 0.9126256644460982, 0.1368587639859501, 0.1366960182366903, 0.8130688122372121, 0.16931485698160353, 0.6919481985470703, 0.21174961549854487, 0.2117391822362209, 0.21201110967916026, 0.12818448096696466, 0.12797191927918372, 0.10853446542781786, 0.16817888966850258, 0.161482830460422, 0.19972924791318925, 0.1750768440015934, 0.1922032525456705, 0.1933158988871645, 0.18377381847906138, 0.19482336642468878, 0.13530077841372912, 0.09739389459624748, 0.0769558823810732, 0.07964392467768844, 0.07462027883814826, 0.08753978387550942, 0.08018359807013165, 0.07234012593082917, 0.0800529826668459, 0.07327786411464954]}, "mutation_prompt": null}
{"id": "afc6d153-015d-457d-8a96-0d61b16df41b", "solution": "import numpy as np\n\nclass HybridDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "HybridDEAMS", "description": "Introducing an adaptive learning rate strategy for mutation adjustments based on current fitness trends to enhance convergence speed.", "configspace": "", "generation": 50, "fitness": 0.30829705000394436, "feedback": "The algorithm HybridDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "18ac7e59-7857-4314-90e0-81b77ecf10ff", "metadata": {"aucs": [0.8896101265515608, 0.8730656120956114, 0.8915523027109501, 0.8660825115646668, 0.8914535493242373, 0.8500615925611443, 0.8682265549474791, 0.8955334300785421, 0.8887018352775587, 0.7846505608727308, 0.8091992435454549, 0.7943711006349443, 0.8036254071642831, 0.8100798095840226, 0.7925231848157536, 0.7632568222859283, 0.7999445131508928, 0.8220536000204669, 0.12586181620886494, 0.12490857048842785, 0.11411058744273872, 0.7269690487642341, 0.14083848783292774, 0.15559134607635838, 0.15227119892069063, 0.2280047113747724, 0.17870769392468722, 0.05305554743493557, 0.13846113725924258, 0.09295022469848924, 0.15987713788461733, 0.19254296049293385, 0.1222037583862422, 0.22289581551281135, 0.19727541534977167, 0.183482449945092, 0.9763745971494179, 0.9755944972605839, 0.9756052074427901, 0.9346015864491148, 0.9372297929150462, 0.9396960884099043, 0.9865821195899972, 0.9865831500574134, 0.9865830016401742, 0.6245538226587866, 0.4943970290734411, 0.6052989250445604, 0.5965603171014673, 0.6456381249106748, 0.5834050740050669, 0.6638195801273665, 0.5357959100228319, 0.6209196050959345, 0.3786572144843673, 0.1696185004805546, 0.22258071410326374, 0.16172950265809982, 0.26218298074123547, 0.21246570672181375, 0.7702932151256311, 0.221849316996656, 0.29121496487289755, 0.19458906019554068, 0.28533286883392805, 0.25483379888283153, 0.2516728124498647, 0.1337639660316532, 0.16862823725131515, 0.1322580481528508, 0.3834042536396578, 0.39270311670238034, 0.21399391374050558, 0.1976561512475351, 0.18221450347331458, 0.36822925928665085, 0.2560747738787984, 0.2958636825602834, 0.23410337820730054, 0.22589795647818378, 0.1893604357398685, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1661701748525698, 0.16655852839009455, 0.1068821855394475, 0.025989775332059817, 0.05079369866941119, 0.021960865449445532, 0.051824146036630325, 0.08975425622608058, 0.07901082903421552, 0.0730825908679541, 0.08591472185879245, 0.07310952521462644, 0.012348911935463724, 0.011708173737848826, 0.09141599846451576, 0.009977391545176073, 0.003956726459984794, 0.01385671991219295, 0.3014294013335168, 0.22559825625901153, 0.2154974139286442, 0.16677795365598835, 0.2376245934934632, 0.22464199145859998, 0.05732648205995161, 0.2990017316578464, 0.3723673637639495, 0.5593568341403596, 0.5497212120510755, 0.5957395197589685, 0.5513481401613753, 0.5876258588237047, 0.4637867147888928, 0.6585214613572187, 0.6244627951693789, 0.5552210715591941, 0.14247298413290932, 0.14518128666835983, 0.12810033887027117, 0.11424062306276173, 0.1646436252517497, 0.13199290109669803, 0.13133924231804361, 0.1178930805287397, 0.1050810724714003, 0.1334060451862923, 0.19166808660296297, 0.12676228029857362, 0.26046642535207243, 0.17254799149502176, 0.2064138217523095, 0.2006541327878527, 0.11400381410230187, 0.11553293040051615, 0.2888450297901868, 0.17396264284481278, 0.14535973276764214, 0.25451024459986704, 0.38478525181441825, 0.2755268249120173, 0.24531582219373127, 0.4669413452722396, 0.4524964994316045, 0.20053612355101513, 0.18465892732325384, 0.2767223313240862, 0.23837876993209384, 0.36403890704608777, 0.21958197694898862, 0.16735574821325994, 0.16820571036130771, 0.172832225964616, 0.20300308568040382, 0.21570796098238487, 0.23393149946206748, 0.26284061326187624, 0.23965399258519593, 0.18787551371903388, 0.26437290842783545, 0.20656324760443256, 0.2069057534093558, 0.19064048968444192, 0.18734440526720586, 0.19579567339376003, 0.2160176137556412, 0.22286759158303282, 0.8168196773373008, 0.19868850213341416, 0.1789729437300719, 0.7205432030269618, 0.21126011395429833, 0.8189850707498693, 0.15354768563539423, 0.19840573101504078, 0.2524194121251947, 0.253557422701313, 0.113086696201811, 0.1132841710667073, 0.11328079505453847, 0.16936007613274473, 0.12686535677432909, 0.20646278410654606, 0.21296688880195225, 0.2117785241137985, 0.21239828561975704, 0.21076775331628483, 0.15442251718341227, 0.1511629425834522, 0.19710150322413178, 0.18316855696977896, 0.16199298368853032, 0.14669992609185667, 0.20033590540497348, 0.19033182814230298, 0.2219215666717228, 0.19656649755644162, 0.17926425988872086, 0.07473794729630867, 0.09412990041328373, 0.10776633616666109, 0.07764314551566931, 0.07699937363571485, 0.11343615951465236, 0.07902080733083838, 0.09189545269688515, 0.07846450976932484]}, "mutation_prompt": null}
{"id": "798fc427-af7f-4cbe-adca-fe8b29101f49", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1  # New parameter for diversity\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))  # Measure of diversity\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2  # Increase exploration if diversity is low\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introducing a fitness diversity strategy by incorporating population dispersion metrics to adaptively refine exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 51, "fitness": 0.32569095873623843, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "afc6d153-015d-457d-8a96-0d61b16df41b", "metadata": {"aucs": [0.8592883076417128, 0.8521170252330084, 0.8603986770717641, 0.8606821844428848, 0.8839652435659876, 0.8638312760165769, 0.8441249174716247, 0.8486487116939752, 0.8814378292229231, 0.7960562631258186, 0.7598354300044221, 0.7460257642158923, 0.7342681238551717, 0.7923927702138444, 0.790305417404643, 0.7484550632330825, 0.75513937503746, 0.798280694022017, 0.12586181620886494, 0.12127237315264816, 0.15829839404287538, 0.7211712454281163, 0.1394801403439624, 0.1454777377445864, 0.14807329410969594, 0.21921260472245896, 0.2174145411920787, 0.05305554743493557, 0.1362747902074548, 0.1032765638932831, 0.16312830756419694, 0.2414695381759585, 0.1222037583862422, 0.22272541087583297, 0.19582848327354718, 0.3483358440054366, 0.9763745971494179, 0.9755944972605839, 0.9756052074427901, 0.9465141214848051, 0.9591424573425752, 0.9607071826474737, 0.9865821195899972, 0.9865831500574134, 0.9865830016401742, 0.6187786966304996, 0.5725605234855817, 0.6738768683117973, 0.5981648145682319, 0.606968412867062, 0.6253022281392218, 0.7096479592280278, 0.6101568327422441, 0.686494651622874, 0.8592212515704414, 0.1696185004805546, 0.22370359265375028, 0.16172950265809982, 0.2719152617674535, 0.2124681198382613, 0.7493340204561084, 0.22184813281503324, 0.6654036364885934, 0.3960681678383693, 0.5266504695035605, 0.3484481514419303, 0.5523742427465145, 0.1346783294145535, 0.41107621089181945, 0.13231991730239, 0.46685357538784933, 0.6353113031446707, 0.3424880165421883, 0.197524122114476, 0.2234993407606084, 0.5097035090656659, 0.31215646350717097, 0.37027093177196835, 0.2540557477003359, 0.3687376226310696, 0.282788803902688, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1615505152108231, 0.17438953593398743, 0.1075887337066389, 0.025989775332059817, 0.05079369866941119, 0.021960865449445532, 0.051969752513902456, 0.08975425622608058, 0.07901082903421552, 0.07585455681897424, 0.08965394486055611, 0.06341200266115266, 0.012348911935463724, 0.011708173737848826, 0.11635217406537246, 0.009977391545176073, 0.003956726459984794, 0.01385671991219295, 0.25050096598181537, 0.33021255851079867, 0.2928496102961894, 0.3495811787576564, 0.22913964863135938, 0.23338177304958985, 0.057739931696105695, 0.21957842489958035, 0.327993783786774, 0.5960835481589042, 0.6642427456379671, 0.6072879541647314, 0.6226051529545806, 0.5699443267602811, 0.5737750242014306, 0.6574884254928688, 0.5615664026231856, 0.6190370647284721, 0.14198604351802258, 0.14504196137378678, 0.13350453726849643, 0.11520860139857791, 0.1675798415269545, 0.13292703332089462, 0.13134986729195808, 0.11782248443889598, 0.10586626724004877, 0.1351973429826132, 0.19173919914894721, 0.12676228029857362, 0.2542059492371842, 0.18435102714044616, 0.2284273183461456, 0.18997691938853245, 0.11400381410230187, 0.11553293040051615, 0.28952580175709886, 0.17395814517584496, 0.14332813604332695, 0.26651106401914704, 0.3832698413001926, 0.36525320892411994, 0.24796238710009744, 0.3354731128585603, 0.4327167893487236, 0.2119411159309521, 0.24873534784995, 0.24656007050519313, 0.25610960841183994, 0.2740429906990124, 0.22131101528716812, 0.17397656891543267, 0.18268297505587872, 0.17715762496175935, 0.20167244601314316, 0.21639490398318628, 0.23710608053998183, 0.26430242013882543, 0.2443400406001428, 0.189341775088525, 0.26672225243981407, 0.21019684990237852, 0.21086577347115776, 0.19058099069674495, 0.18731892208967227, 0.1958136879999064, 0.2160176137556412, 0.22318519379665847, 0.8088421650663007, 0.1986590100732798, 0.1789729437300719, 0.7118857331194903, 0.21126291022300014, 0.8105062496708507, 0.15353640149671732, 0.19840573101504078, 0.2524194121251947, 0.253557422701313, 0.1133289198575973, 0.11328434415183186, 0.11330425091836438, 0.16937977971230556, 0.12690481341866267, 0.20646278410654606, 0.2131003630855134, 0.21163589057430499, 0.21239204995052996, 0.21074107884824844, 0.15446393254088253, 0.19771081143469738, 0.19710150322413178, 0.18316855696977896, 0.16199298368853032, 0.14669992609185667, 0.20033590540497348, 0.19033182814230298, 0.22226698733088324, 0.19642381195083125, 0.17926425988872086, 0.0746823509948128, 0.09492841889495451, 0.10850225222610388, 0.07707225188319611, 0.07740479728857985, 0.11330566313127588, 0.07983056420800694, 0.09139465134152891, 0.08019038821586255]}, "mutation_prompt": null}
{"id": "3e118b74-d8d9-48a9-92c3-67deb2b6e306", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.15  # Increased learning rate for adaptation\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (1 - self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Slightly increased the learning rate and adjusted dynamic crossover rate calculation for improved convergence.", "configspace": "", "generation": 52, "fitness": 0.28868762772834927, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "798fc427-af7f-4cbe-adca-fe8b29101f49", "metadata": {"aucs": [0.9094179114940587, 0.8981840200648745, 0.9024902921756559, 0.8951145679466368, 0.8966539816124335, 0.9025532732988591, 0.910041147270938, 0.9014997899546294, 0.9054649652525187, 0.8033622733471348, 0.8179126310700244, 0.8031487805339758, 9.999999999998899e-05, 0.06963415932280381, 0.8334542194232843, 0.8261680933846958, 0.8052021121917354, 0.831535307692165, 0.2560500484969459, 0.7985953284250157, 0.2320604836776109, 0.8130127636990371, 0.8317294651605083, 0.225647828641223, 0.8224715768216332, 0.8173643617565103, 0.8238313040276953, 0.12748231281480094, 0.8019709112414836, 0.7923625982217287, 0.2774623811171547, 0.22616750944296826, 0.22762226653173157, 0.18234942770440088, 0.168688042545467, 0.7459500813243548, 0.9786188547553106, 0.9776171110842423, 0.9776367328288178, 0.9771913611221082, 0.9771672001132145, 0.9771703395603779, 0.9798497834075248, 0.9801144269903512, 0.9801168553899527, 0.36621243601112996, 0.311025037329568, 0.31102745860353054, 0.34872054296958854, 0.27615769077239916, 0.2683660367419406, 0.22410981136486618, 0.19155738785958187, 0.19261780984391774, 0.2005860168284851, 0.19894178170664845, 0.21262751370550592, 0.19054881358740416, 0.19172828878714776, 0.19164606443819643, 0.11427861141601703, 0.3206710717356809, 0.1860771587974388, 0.17591133865659636, 0.21774683154931695, 0.17949129665460573, 0.24135212703966213, 0.21540976945014856, 0.24423478645235608, 0.184107084584875, 0.18886216686897228, 0.1937307703401483, 0.2082995112884818, 0.1736039743156178, 0.18221583933024288, 0.255043541384246, 0.19317527872168405, 0.16498922821912076, 0.17123993052244257, 0.13788877178677172, 0.21734554961595054, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022623878280933374, 0.050229904466525976, 0.08541047358517462, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09156529510623079, 0.08323151160635756, 0.08385350726092633, 0.009397587604368485, 0.03161620679428356, 0.00047798689194100685, 0.1091721733008435, 0.0373207340654057, 0.007992179060209326, 0.08569928775311042, 0.03635005258923152, 0.034362148353222044, 0.08696065552627785, 0.15775284214597973, 0.06668130359219615, 0.19375569356141253, 0.08324081825529761, 0.07179101455969117, 0.09390984478893094, 0.08604420507456667, 0.1576438488753622, 0.07920564943718622, 0.04793496974185951, 0.18913529148779895, 0.0256225199511404, 0.13403007986767845, 0.13658220012674227, 0.4904802344563348, 0.42400849674783914, 0.45475619954710844, 0.4510082863933035, 0.4007169036280638, 0.39581325607745543, 0.3919045474380858, 0.41645190846920044, 0.44632470430726245, 0.09028138140246411, 0.09822342365206893, 0.08134362459415356, 0.10487132935585286, 0.10743302669317978, 0.10317107740970388, 0.1164987517669126, 0.10688489051788241, 0.10917804655344576, 0.1921960432202494, 0.14973534993356985, 0.13576927452685228, 0.1609635929614771, 0.16632400845672224, 0.14512735058789716, 0.17136506846807587, 0.19959632443622688, 0.17167888151345523, 0.2127421381941299, 0.1896410659041451, 0.2215650008891097, 0.1991757410060211, 0.22895963623908444, 0.24642964350109242, 0.2102258033665909, 0.26392472292342317, 0.22506765256447048, 0.15945624338864384, 0.11811977793911377, 0.19743418542818048, 0.1679236033790159, 0.17745082714004345, 0.20064162634127514, 0.15611884666025744, 0.16377480450136628, 0.17864631479852067, 0.20762782690985837, 0.2220067567977546, 0.20239320594252652, 0.184754000485284, 0.18338068135083274, 0.19496244083795955, 0.19488342495441147, 0.18578495881356016, 0.23485665814055012, 0.1856918980790685, 0.28521053622800796, 0.2132961549815363, 0.2002810787963829, 0.24056181639317797, 0.4157705185320941, 0.20779059193310556, 0.2381852898407828, 0.23468856400596372, 0.29263906229218317, 0.346154000830063, 0.3100542221914697, 0.16384153805286572, 0.1616698029133311, 0.16098910690552315, 0.16770863803005398, 0.14956307421503756, 0.16816270967552505, 0.3689438265365823, 0.3087003596440282, 0.2877278037283637, 0.18054494996099857, 0.17689237087207532, 0.17939624845966085, 0.21356721188896288, 0.174990251310697, 0.17723250957503078, 0.20745614347999597, 0.1907294308719376, 0.17443922422598424, 0.17158897686548513, 0.17440170688271284, 0.18119708031089377, 0.2142133250630852, 0.17256271688447944, 0.18286520480792778, 0.09313905560666558, 0.082055118902856, 0.08920126456841515, 0.08042888506958934, 0.08062764849343274, 0.07529339336076724, 0.07297874821720685, 0.09127769055352797, 0.09178419184408482]}, "mutation_prompt": null}
{"id": "69144a43-5a6d-4f3d-8d4a-47ad40f7fe38", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n            else:\n                avg_successful_mutation = np.tanh(fitness_variance - fitness_trend)\n\n            adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation * (1 + self.success_rate))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introducing adaptive exploration-exploitation balance using success rate to dynamically adjust mutation factor for improved convergence.", "configspace": "", "generation": 53, "fitness": 0.31959767222376984, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "798fc427-af7f-4cbe-adca-fe8b29101f49", "metadata": {"aucs": [0.8702545073781214, 0.8731285530136386, 0.8518527967820387, 0.8603980729234255, 0.8886534720632183, 0.846876652759162, 0.8620543612395932, 0.8615789936841223, 0.8864908929595545, 0.7393189570017122, 0.7673292790382409, 0.7672063726624564, 0.8147044277017516, 0.8315402508836105, 0.7750803871873728, 0.3224562003017679, 0.7501954667401015, 0.7850785241952115, 0.12599652002581718, 0.119212502042362, 0.1582520414246279, 0.658463701646244, 0.14017526668501146, 0.14560575994363156, 0.15325302759583082, 0.2403403106409302, 0.21852206421024645, 0.05310923581190363, 0.11775240189932701, 0.10130566101172067, 0.15010953714746578, 0.16425544096831413, 0.12238562142666409, 0.18246624216005136, 0.6526373574076845, 0.6142663675287892, 0.9763746058765939, 0.9755945227826389, 0.9756052375687034, 0.9465190301006803, 0.9591383651735501, 0.9607072577775347, 0.9865821194126934, 0.9865831498849246, 0.9865830014669953, 0.5539887059425102, 0.5970261801084451, 0.6287406017513459, 0.6732004231256699, 0.5444024901552724, 0.6769899967782846, 0.5932785982956008, 0.6829682181310044, 0.7144580605744891, 0.3446917011690456, 0.1696185004805546, 0.2130511203516413, 0.16172950265809982, 0.2713185068574322, 0.2124681198382613, 0.3306608174195419, 0.3209796658321209, 0.3171966968925388, 0.5019645530406605, 0.3867198645219031, 0.47514724627291716, 0.3650209974802493, 0.1348209363616183, 0.3552988494500626, 0.13243215286609722, 0.51336921803942, 0.6907131896810632, 0.3028199020049517, 0.240826424160551, 0.25540205907220703, 0.39527152311758706, 0.5568230310450744, 0.3363369577132733, 0.343535302829847, 0.39552993284923, 0.3463891493986494, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18691648350856316, 0.2010179753890423, 0.17756733133392988, 0.024753359308627876, 0.059006982917633066, 0.018192745311955694, 0.04039012257959662, 0.08945026862890315, 0.07675377024405239, 0.06338212694646461, 0.10195402641322249, 0.03502641216870783, 0.013701803984530136, 0.02272287725160982, 0.07343363619817633, 0.003927756259978765, 0.01785526156927697, 0.0068476087581038625, 0.24492027254811033, 0.253360669446691, 0.35121686305101163, 0.2971528724180569, 0.21541622793780624, 0.23490136761401903, 0.057650967907509454, 0.3353212952075827, 0.243934690656486, 0.5214918227703109, 0.5844890767381483, 0.5587450052618619, 0.6212196284544158, 0.6429143912197981, 0.6463049115182131, 0.5576765918649249, 0.5494329987856252, 0.5470622017924153, 0.1423254774885201, 0.14591837636874339, 0.14051312328610188, 0.11559113516624187, 0.1675422602660923, 0.13267645127714478, 0.1313395481612104, 0.11770787770785351, 0.10584525048145166, 0.13117328121280147, 0.1299800860642636, 0.12686242069556397, 0.26091178820791083, 0.19035881033345237, 0.11167310797271257, 0.14874704367121172, 0.11394606709451838, 0.11547603498513348, 0.28216114236745016, 0.1739481747677597, 0.14205215398242, 0.29003136934775386, 0.46373087882276043, 0.33930805021175736, 0.24893024972120492, 0.4173182310798913, 0.38834149692079367, 0.22950830517629228, 0.2522486019825836, 0.15516531145310675, 0.27963673113153154, 0.24199559615733568, 0.31200071938387086, 0.17404233199779084, 0.16748050275000226, 0.17783899830248207, 0.24314356024279649, 0.2090207098642467, 0.16624028084914866, 0.20515633137924805, 0.18198402356055876, 0.19661194807849736, 0.20166674273738927, 0.20487722434816347, 0.2140614290249604, 0.1905832570158298, 0.18720008648523878, 0.1957798997929331, 0.21569960370788843, 0.210631245807948, 0.8009379682656742, 0.19868603472777735, 0.17894666624313793, 0.7307602021679982, 0.2112562887674898, 0.7817654488841738, 0.15354512854808766, 0.1984112979508783, 0.25251835183924054, 0.2536213678685547, 0.11332904883531114, 0.11328423838117962, 0.11330345309366419, 0.16935821558188768, 0.12689418013273046, 0.2064719081076598, 0.21311606243718428, 0.21219064030173196, 0.212334961060909, 0.21074088071591124, 0.15446412266795373, 0.20106449118882996, 0.18992399102550173, 0.20832985955529693, 0.21782845170680132, 0.14665998327133944, 0.19047054451002388, 0.19100004543976234, 0.2222597997842265, 0.19590451994105418, 0.18638240508215276, 0.093595243927167, 0.08586558675289724, 0.08377127954910679, 0.07042177725903764, 0.08732599425838672, 0.08248366890395287, 0.08105008629958954, 0.08153141023239674, 0.0861121478064375]}, "mutation_prompt": null}
{"id": "3cc7618c-3727-49f1-8a32-b7ab71123acb", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance))\n\n            adjusted_mutation_factor *= (1 + 0.5 * self.success_rate)  # Modify based on success rate\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.1  # Slightly increase exploration if diversity is low\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "EnhancedDEAMS with adaptive mutation scaling based on diversity and success rate to accelerate convergence.", "configspace": "", "generation": 54, "fitness": 0.30244770789522235, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "798fc427-af7f-4cbe-adca-fe8b29101f49", "metadata": {"aucs": [0.8766381292911392, 0.8816405705438597, 0.8702559920792742, 0.8440689890058645, 0.8659003866362618, 0.8673540884651281, 0.8792169605723621, 0.8715396702568611, 0.8969220794034577, 0.70886634886237, 0.7719861594675466, 0.7528202628933054, 0.7811666493690704, 0.7837610278173764, 0.826215771294876, 0.7735139051881031, 0.7249856387022087, 0.7585669536484468, 0.11533673388823773, 0.1216938084634196, 0.12289462222199732, 0.19053338660049413, 0.13990657151553554, 0.1483960795922873, 0.1478910278235389, 0.23028969466427607, 0.16315336376145317, 0.053346546804589834, 0.06503669697569026, 0.11155404407960523, 0.255614038998353, 0.28992151880866623, 0.168694757210328, 0.16961729038950124, 0.1679145877338909, 0.6858987443323185, 0.9763746481703666, 0.9755946488309349, 0.975605385997927, 0.9384531063495662, 0.9480961216088718, 0.9544966562815104, 0.9865821185586119, 0.9865831490396773, 0.9865830006204693, 0.6547746893243989, 0.6156765187731084, 0.652979924303136, 0.6712956994651625, 0.5084023613778924, 0.6110017027529386, 0.6201564233580052, 0.5296125554369451, 0.6401020149671419, 0.20958579312981596, 0.1696185004805546, 0.2132324988302039, 0.16166042022844107, 0.3301597068687553, 0.21243087602015798, 0.22553510254485432, 0.22356584672352564, 0.3269768762966503, 0.31758193593921535, 0.3026663415228632, 0.2036348260655313, 0.23975498808348772, 0.3126106114856959, 0.13376437248028628, 0.13297736447764197, 0.21995124826771006, 0.5617688356399528, 0.20028782366351894, 0.1989013748753825, 0.1297264043891957, 0.36057839184393603, 0.39033508476547096, 0.29210553533146266, 0.22300253939288206, 0.22976174425595475, 0.23764371573241339, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16999651047774855, 0.12097936779949692, 0.13744705794240164, 0.028060459216751932, 0.04384798809264334, 0.035396440848801336, 0.08671333255073366, 0.08824691690592223, 0.11122193414090631, 0.009652416511333417, 0.08244280403436333, 0.11287100124241656, 0.027441717545780175, 0.0069046972755928415, 0.012832509629841615, 0.0022246995238971445, 0.0013526337640611397, 9.999999999998899e-05, 0.21189018281918126, 0.2659513826760127, 0.2235635629635242, 0.16866300054124772, 0.2291944013428736, 0.23299454914643747, 0.05753882210526007, 0.32319934001320105, 0.21151440363718377, 0.7578960921835286, 0.5341415458114422, 0.5715223740609268, 0.517141331048979, 0.5560318632268452, 0.4953234881082318, 0.5334811845478556, 0.6282169132780753, 0.6584594795068457, 0.1420163889897449, 0.16066321430953245, 0.09227093887673132, 0.10804078964363928, 0.12989045585259196, 0.1503948117764905, 0.13114995501082283, 0.11778319362970469, 0.10605526598544535, 0.16128803088801502, 0.16862581207658822, 0.1346969350294266, 0.2552620741663083, 0.1615653123283255, 0.1448031835796061, 0.16619064133521244, 0.1136806823565315, 0.11573801300680475, 0.26446036725450606, 0.2571583780601133, 0.12929455204953466, 0.18291138725083567, 0.29735476309497233, 0.2737243634874694, 0.26577435672497873, 0.25346513973177487, 0.31130003670239725, 0.19287876324528785, 0.14276595244731927, 0.18881271889650353, 0.22606202284329224, 0.26322670133035986, 0.26841172168953176, 0.1693165554901772, 0.16820354984858676, 0.180848032158329, 0.26848824547594563, 0.2516168604232041, 0.14336135329476096, 0.1800641545736087, 0.22673588948728063, 0.2684058862057431, 0.2808085575776569, 0.18968615165613256, 0.21383732156149504, 0.20659609452983219, 0.19168172072101974, 0.1956318361217838, 0.22039703196636984, 0.2107034643626715, 0.8029986129441747, 0.21592362475138294, 0.21084722617219798, 0.7693892134614668, 0.21120789785898963, 0.8118549873517964, 0.15356160465229718, 0.19248955187163896, 0.28024972209017696, 0.25512574624973805, 0.1132921757478893, 0.11328437041182116, 0.11338160686914667, 0.1693703901693061, 0.12659046408461672, 0.20651640869929755, 0.21312689564964948, 0.21229838158204584, 0.21233412877917368, 0.21072920576004261, 0.15448643842179122, 0.1511365575375052, 0.1731006987850735, 0.2033822386279437, 0.21493378993970724, 0.1944084753430022, 0.16330436749351085, 0.1765020356397552, 0.22890416358221566, 0.19505007424051923, 0.1444475814923467, 0.07347726054493975, 0.07028124740919084, 0.07520715535705336, 0.10404306266497265, 0.10124844804755262, 0.09189885487239902, 0.07533408047344059, 0.08273952072932078, 0.08548802346968098]}, "mutation_prompt": null}
{"id": "7e9745b9-81e6-4ca0-928f-b239ce36a862", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend * 0.95))  # Adjusted factor\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand())\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-step_size, step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Incorporating adaptive mutation scaling based on current fitness variance trends to enhance convergence speed.", "configspace": "", "generation": 55, "fitness": 0.32569095873623843, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "798fc427-af7f-4cbe-adca-fe8b29101f49", "metadata": {"aucs": [0.8592883076417128, 0.8521170252330084, 0.8603986770717641, 0.8606821844428848, 0.8839652435659876, 0.8638312760165769, 0.8441249174716247, 0.8486487116939752, 0.8814378292229231, 0.7960562631258186, 0.7598354300044221, 0.7460257642158923, 0.7342681238551717, 0.7923927702138444, 0.790305417404643, 0.7484550632330825, 0.75513937503746, 0.798280694022017, 0.12586181620886494, 0.12127237315264816, 0.15829839404287538, 0.7211712454281163, 0.1394801403439624, 0.1454777377445864, 0.14807329410969594, 0.21921260472245896, 0.2174145411920787, 0.05305554743493557, 0.1362747902074548, 0.1032765638932831, 0.16312830756419694, 0.2414695381759585, 0.1222037583862422, 0.22272541087583297, 0.19582848327354718, 0.3483358440054366, 0.9763745971494179, 0.9755944972605839, 0.9756052074427901, 0.9465141214848051, 0.9591424573425752, 0.9607071826474737, 0.9865821195899972, 0.9865831500574134, 0.9865830016401742, 0.6187786966304996, 0.5725605234855817, 0.6738768683117973, 0.5981648145682319, 0.606968412867062, 0.6253022281392218, 0.7096479592280278, 0.6101568327422441, 0.686494651622874, 0.8592212515704414, 0.1696185004805546, 0.22370359265375028, 0.16172950265809982, 0.2719152617674535, 0.2124681198382613, 0.7493340204561084, 0.22184813281503324, 0.6654036364885934, 0.3960681678383693, 0.5266504695035605, 0.3484481514419303, 0.5523742427465145, 0.1346783294145535, 0.41107621089181945, 0.13231991730239, 0.46685357538784933, 0.6353113031446707, 0.3424880165421883, 0.197524122114476, 0.2234993407606084, 0.5097035090656659, 0.31215646350717097, 0.37027093177196835, 0.2540557477003359, 0.3687376226310696, 0.282788803902688, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1615505152108231, 0.17438953593398743, 0.1075887337066389, 0.025989775332059817, 0.05079369866941119, 0.021960865449445532, 0.051969752513902456, 0.08975425622608058, 0.07901082903421552, 0.07585455681897424, 0.08965394486055611, 0.06341200266115266, 0.012348911935463724, 0.011708173737848826, 0.11635217406537246, 0.009977391545176073, 0.003956726459984794, 0.01385671991219295, 0.25050096598181537, 0.33021255851079867, 0.2928496102961894, 0.3495811787576564, 0.22913964863135938, 0.23338177304958985, 0.057739931696105695, 0.21957842489958035, 0.327993783786774, 0.5960835481589042, 0.6642427456379671, 0.6072879541647314, 0.6226051529545806, 0.5699443267602811, 0.5737750242014306, 0.6574884254928688, 0.5615664026231856, 0.6190370647284721, 0.14198604351802258, 0.14504196137378678, 0.13350453726849643, 0.11520860139857791, 0.1675798415269545, 0.13292703332089462, 0.13134986729195808, 0.11782248443889598, 0.10586626724004877, 0.1351973429826132, 0.19173919914894721, 0.12676228029857362, 0.2542059492371842, 0.18435102714044616, 0.2284273183461456, 0.18997691938853245, 0.11400381410230187, 0.11553293040051615, 0.28952580175709886, 0.17395814517584496, 0.14332813604332695, 0.26651106401914704, 0.3832698413001926, 0.36525320892411994, 0.24796238710009744, 0.3354731128585603, 0.4327167893487236, 0.2119411159309521, 0.24873534784995, 0.24656007050519313, 0.25610960841183994, 0.2740429906990124, 0.22131101528716812, 0.17397656891543267, 0.18268297505587872, 0.17715762496175935, 0.20167244601314316, 0.21639490398318628, 0.23710608053998183, 0.26430242013882543, 0.2443400406001428, 0.189341775088525, 0.26672225243981407, 0.21019684990237852, 0.21086577347115776, 0.19058099069674495, 0.18731892208967227, 0.1958136879999064, 0.2160176137556412, 0.22318519379665847, 0.8088421650663007, 0.1986590100732798, 0.1789729437300719, 0.7118857331194903, 0.21126291022300014, 0.8105062496708507, 0.15353640149671732, 0.19840573101504078, 0.2524194121251947, 0.253557422701313, 0.1133289198575973, 0.11328434415183186, 0.11330425091836438, 0.16937977971230556, 0.12690481341866267, 0.20646278410654606, 0.2131003630855134, 0.21163589057430499, 0.21239204995052996, 0.21074107884824844, 0.15446393254088253, 0.19771081143469738, 0.19710150322413178, 0.18316855696977896, 0.16199298368853032, 0.14669992609185667, 0.20033590540497348, 0.19033182814230298, 0.22226698733088324, 0.19642381195083125, 0.17926425988872086, 0.0746823509948128, 0.09492841889495451, 0.10850225222610388, 0.07707225188319611, 0.07740479728857985, 0.11330566313127588, 0.07983056420800694, 0.09139465134152891, 0.08019038821586255]}, "mutation_prompt": null}
{"id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1  # New parameter for diversity\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))  # Measure of diversity\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2  # Increase exploration if diversity is low\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce an adaptive step size scaling based on success rate to refine local search effectiveness for faster convergence.", "configspace": "", "generation": 56, "fitness": 0.3264254990728041, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "798fc427-af7f-4cbe-adca-fe8b29101f49", "metadata": {"aucs": [0.8592867541896644, 0.8521136240191396, 0.8604041111050538, 0.8606750456263702, 0.8839663390849283, 0.8638200355395397, 0.8441280718746558, 0.848647900532628, 0.8814411182782456, 0.7960561220350244, 0.7598445948474117, 0.7460225853176865, 0.7342387342352444, 0.7923918823635517, 0.7903032399745437, 0.7484468010499836, 0.7551360487008694, 0.7982625077052583, 0.12586803303925753, 0.1208467505666847, 0.15803999839407112, 0.7211653899453195, 0.14530835696358502, 0.15524785459972024, 0.14876599798344703, 0.21774885781753506, 0.21709566563498084, 0.053069877519869246, 0.13647788108751613, 0.10324258213084869, 0.16320681687461092, 0.2398303324619051, 0.1225887492498734, 0.19656853265098762, 0.19844167474788266, 0.2577858910371891, 0.9763746083761489, 0.975594550099331, 0.975605268125381, 0.9465164151916905, 0.9591425331330113, 0.96070726905951, 0.9865821224947126, 0.9865831529723937, 0.9865830045536736, 0.6187899426118189, 0.537857612981341, 0.6738789183152698, 0.6261704309734836, 0.6069742519606471, 0.6253072035271126, 0.6463505543293073, 0.6101744595561982, 0.6864970310834999, 0.8592212515704414, 0.1696185004805546, 0.16840772917571945, 0.16172950265809982, 0.2719152617674535, 0.2124647427359111, 0.7493340204561084, 0.22184813281503324, 0.6654036364885934, 0.3960683908177389, 0.2786019006188336, 0.34844735830966833, 0.5523735846633838, 0.13467626058997484, 0.4110769665355237, 0.13232075545989752, 0.46684387057199916, 0.6353209432855891, 0.3424798550991561, 0.19760104634875464, 0.2235033168646855, 0.5097046188970515, 0.3121563949041949, 0.5757728209043077, 0.46506371543965663, 0.3687349435312324, 0.31821925556599895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16154983621953178, 0.17438530717624467, 0.1075895055533238, 0.02598626424807171, 0.05078048275216751, 0.021960816553924678, 0.05196977984010265, 0.08975400047875304, 0.07901260872735805, 0.07585457154269548, 0.08967104055973829, 0.06341200266115266, 0.012347193263453127, 0.011708173737848826, 0.11635070284177673, 0.012179415556531792, 9.999999999998899e-05, 0.05513888053085303, 0.2504945202599089, 0.3302110369323402, 0.2524875717136792, 0.3495796837470131, 0.2291311859692814, 0.23337391438594846, 0.05774121783583108, 0.2195714007954963, 0.32799274636627984, 0.5960826655376283, 0.6642226992865994, 0.6072869848710137, 0.6226029558875579, 0.5699454010282925, 0.6232553145745983, 0.6574875039261912, 0.5615662217382232, 0.6190400666139971, 0.1419855429984095, 0.14504134935013335, 0.13351361363411762, 0.11520813103575511, 0.1676670819196583, 0.13292041580981617, 0.13134970522103162, 0.11782089981479094, 0.10586633050495198, 0.13266455850502412, 0.19173684102552946, 0.12689367876001578, 0.25423942379978126, 0.1843388451645479, 0.2210778616918596, 0.18996915869607955, 0.11396945974387984, 0.11559626674798618, 0.28929995274178544, 0.17395805636672412, 0.1444636048231296, 0.26650514173668194, 0.3832666369872558, 0.36514525294153133, 0.24808365109269048, 0.33546743803247037, 0.43271583036233174, 0.21195775744447942, 0.248720342206889, 0.3442239247553197, 0.2560818770553911, 0.3427791811283746, 0.22130598286806402, 0.1739492597693023, 0.17245301194347307, 0.17715692691860352, 0.1967295820602485, 0.21631354170350914, 0.23490675083897783, 0.26023281646328966, 0.21043582997405041, 0.2224441740572759, 0.26669694917763287, 0.21043228512627388, 0.2090183819520539, 0.19058176826456452, 0.18731937182931946, 0.19581435809211567, 0.21610093360652405, 0.22318526133548722, 0.8088439939978083, 0.19864815845292616, 0.17898821191873904, 0.7118782611674256, 0.21126398115413636, 0.8105010503987936, 0.15353637502206097, 0.19842617563443488, 0.2524253619966823, 0.2535602018335218, 0.113328916012023, 0.11328431376552761, 0.11330426289157935, 0.1693796232790601, 0.1269050924851043, 0.20646071989237502, 0.21310015720834297, 0.2116361841750073, 0.21239210326502145, 0.2107413569532055, 0.15446417577721783, 0.19771684244960397, 0.19710150322413178, 0.1831662498130633, 0.16199298368853032, 0.14669992609185667, 0.200334818659213, 0.1903279482499578, 0.2222655599317379, 0.19642359559948785, 0.17920722396274336, 0.07468223355480463, 0.09511516874913595, 0.10850649664117007, 0.07703011451881814, 0.0775203020021954, 0.11165399285973965, 0.08005855640247095, 0.09139452414307048, 0.08022954502519353]}, "mutation_prompt": null}
{"id": "5e062276-0321-4925-90de-730a49527b1b", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1  # Initial parameter for diversity\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        diversity_history = []  # Track recent diversity\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))  # Measure of diversity\n\n            # Update diversity threshold based on history\n            diversity_history.append(population_dispersion)\n            if len(diversity_history) > 10:  # Keep a short history\n                diversity_history.pop(0)\n            avg_recent_diversity = np.mean(diversity_history)\n            adaptive_diversity_threshold = self.diversity_threshold * (1 + 0.1 * (avg_recent_diversity - self.diversity_threshold))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < adaptive_diversity_threshold:\n                adjusted_mutation_factor *= 1.2  # Increase exploration if diversity is low\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Implement a dynamic adjustment of the diversity threshold based on recent diversity trends to enhance convergence.", "configspace": "", "generation": 57, "fitness": 0.3261609469976671, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8592867541896644, 0.8521136240191396, 0.8604041111050538, 0.8606750456263702, 0.8839663390849283, 0.8638200355395397, 0.8441280718746558, 0.848647900532628, 0.8814411182782456, 0.7960561220350244, 0.7598445948474117, 0.7460225853176865, 0.7342387342352444, 0.7923918823635517, 0.7903032399745437, 0.7484468010499836, 0.7551360487008694, 0.7982625077052583, 0.12586803303925753, 0.1208467505666847, 0.15803999839407112, 0.7211653899453195, 0.14530835696358502, 0.15524785459972024, 0.14876599798344703, 0.21774885781753506, 0.21709566563498084, 0.053069877519869246, 0.13647788108751613, 0.10324258213084869, 0.14763783825365517, 0.2398303324619051, 0.1225887492498734, 0.19656853265098762, 0.19844167474788266, 0.2577858910371891, 0.9763746083761489, 0.975594550099331, 0.975605268125381, 0.9465164151916905, 0.9591425331330113, 0.96070726905951, 0.9865821224947126, 0.9865831529723937, 0.9865830045536736, 0.6187899426118189, 0.5503725782846867, 0.6738789183152698, 0.6261704309734836, 0.6069742519606471, 0.6253072035271126, 0.6463505543293073, 0.6101744595561982, 0.6864970310834999, 0.8592212515704414, 0.1696185004805546, 0.16840772917571945, 0.16172950265809982, 0.2719152617674535, 0.2124647427359111, 0.7493340204561084, 0.22184813281503324, 0.6654036364885934, 0.3960683908177389, 0.2786019006188336, 0.34844735830966833, 0.5523735846633838, 0.13467626058997484, 0.4110769665355237, 0.13232075545989752, 0.46684387057199916, 0.7249617374152009, 0.3424798550991561, 0.19760104634875464, 0.2235033168646855, 0.5097046188970515, 0.3121563949041949, 0.5757728209043077, 0.46506371543965663, 0.3687349435312324, 0.31821925556599895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16154983621953178, 0.17438530717624467, 0.1075895055533238, 0.02598626424807171, 0.05078048275216751, 0.021960816553924678, 0.05196977984010265, 0.08975400047875304, 0.07901260872735805, 0.07585457154269548, 0.08967104055973829, 0.06341200266115266, 0.012347193263453127, 0.011708173737848826, 0.11635070284177673, 0.012179415556531792, 9.999999999998899e-05, 0.05513888053085303, 0.2504945202599089, 0.3302110369323402, 0.2524875717136792, 0.3495796837470131, 0.23278196670329376, 0.23337391438594846, 0.05774121783583108, 0.2195714007954963, 0.304150710690571, 0.5960826655376283, 0.6642226992865994, 0.6072869848710137, 0.6226029558875579, 0.5699454010282925, 0.6232553145745983, 0.5430647082941318, 0.5615662217382232, 0.6190400666139971, 0.1419855429984095, 0.14504134935013335, 0.13351361363411762, 0.11520813103575511, 0.1676670819196583, 0.13292041580981617, 0.13134970522103162, 0.11782089981479094, 0.10586633050495198, 0.13266455850502412, 0.19173684102552946, 0.12689367876001578, 0.25423942379978126, 0.1843388451645479, 0.2210778616918596, 0.1713858546280388, 0.11396945974387984, 0.11559626674798618, 0.28929995274178544, 0.17395805636672412, 0.1444636048231296, 0.26650514173668194, 0.3832666369872558, 0.36514525294153133, 0.24808365109269048, 0.33546743803247037, 0.43271583036233174, 0.21195775744447942, 0.248720342206889, 0.3442239247553197, 0.2560818770553911, 0.3427791811283746, 0.22130598286806402, 0.1739492597693023, 0.17245301194347307, 0.17715692691860352, 0.1967295820602485, 0.21631354170350914, 0.23490675083897783, 0.26023281646328966, 0.21043582997405041, 0.2224441740572759, 0.26669694917763287, 0.21043228512627388, 0.2090183819520539, 0.19058176826456452, 0.18731937182931946, 0.19581435809211567, 0.21610093360652405, 0.22320503287626248, 0.8088439939978083, 0.19864815845292616, 0.17898821191873904, 0.7118782611674256, 0.21126398115413636, 0.8105010503987936, 0.15353637502206097, 0.19842617563443488, 0.2524253619966823, 0.2535602018335218, 0.11332898183241691, 0.11328431376552761, 0.11330426289157935, 0.1693796232790601, 0.1269050924851043, 0.20646071989237502, 0.21310015720834297, 0.2116361841750073, 0.21239210326502145, 0.21069371839759887, 0.1544885838358201, 0.20718756118564474, 0.19710150322413178, 0.1831662498130633, 0.16199298368853032, 0.14669992609185667, 0.200334818659213, 0.1903279482499578, 0.2222655599317379, 0.19642359559948785, 0.17920722396274336, 0.07468223355480463, 0.09511516874913595, 0.10850649664117007, 0.07703011451881814, 0.0775203020021954, 0.11165399285973965, 0.08005855640247095, 0.09139452414307048, 0.08022954502519353]}, "mutation_prompt": null}
{"id": "f5d8e8be-d835-473a-8431-21dcbe8a193d", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.initial_population_size = self.population_size  # Store initial size for adaptive resizing\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n            # Dynamic population resizing based on success rate\n            if self.success_rate > 0.5 and self.population_size < 2 * self.initial_population_size:\n                self.population_size += 1\n            elif self.success_rate < 0.1 and self.population_size > self.initial_population_size / 2:\n                self.population_size -= 1\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce dynamic population resizing based on convergence speed to adaptively balance exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.22013108212837643, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.25.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.886674035936124, 0.8925559032971822, 0.8994399876385727, 0.8687904984158813, 0.9107106951632989, 0.7923005819810737, 0.11590919670346067, 0.11125432595332296, 0.11125047967204171, 0.7260551497182098, 0.8015650648339594, 0.6810967964211839, 0.6441566617182755, 0.7513598942528462, 0.6658620681450933, 0.7880767169495312, 0.8190545650897347, 0.6656080268538532, 0.0880360823606059, 0.08602717557919681, 0.10905711376399374, 0.09089118921073602, 0.16653437783342362, 0.12324993090135217, 0.1758137066377049, 0.14387059852482886, 0.11031778130284797, 9.999999999998899e-05, 0.01531589049312565, 0.015790718214535815, 0.14289036267784905, 0.026908863415757378, 0.15494503634257706, 0.15022327495301502, 0.2569520562444991, 0.15501979634592422, 0.9808356704850646, 0.9790017806455004, 0.9802102279042277, 0.974151124507443, 0.9661695101821344, 0.9576826513888074, 0.9734844158358867, 0.9666119309133351, 0.9666146464888438, 0.12375037728493066, 0.16550416911553367, 0.21558472511972537, 0.12759108585875334, 0.36768716474483276, 0.30760824341558113, 0.16564413435323444, 0.2163345589369663, 0.14863655418204758, 0.2053345232016659, 0.17512802264271343, 0.19887465822551564, 0.156578450367991, 0.17337592516010103, 0.16975755998078967, 0.13044875024681735, 0.15019011754109945, 0.12581704418466177, 0.1312354609398375, 0.1281467633468899, 0.11497941891040098, 0.1855440059721415, 0.156456161841786, 0.18439242968375524, 0.157867655281416, 0.10649720321979006, 0.10660544232479297, 0.10844755274447071, 0.12797471360746526, 0.1272013887938248, 0.1709360005789633, 0.1561654434328995, 0.15472704442237706, 0.14979332751479013, 0.14634293615389649, 0.13958704193004812, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11827353254788664, 0.050695014096112545, 0.04607864075753876, 0.013770390769238472, 0.05669886477495789, 0.05562678043530611, 0.04401316036554326, 0.03663259762905913, 0.04605271040670067, 0.025249851867853113, 0.011802581980849602, 0.0715754803992239, 0.03875188459160217, 0.012387382391324198, 0.056940257090323576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12862424586191024, 0.1735873082693633, 0.13069584356288555, 0.20171231640132314, 0.13613778877645366, 0.12780264987719148, 0.18474663018967052, 0.1866748054614129, 0.18838231661350824, 0.1657686223307383, 0.31050986474888365, 0.2331909208657197, 0.5539667029711908, 0.6394592518580309, 0.5172830679467284, 0.07061865308853721, 0.08384722411095624, 0.08307611985125518, 0.05437281536529426, 0.05788811533493665, 0.06189463345141888, 0.06033253611332112, 0.07525107773124418, 0.09706720100300792, 0.13927467256642156, 0.1619942508170079, 0.15301675952125826, 0.14412926973319595, 0.06786789290206485, 0.06867587446922352, 0.14918617708597193, 0.15592098528594067, 0.13836758035763064, 0.11282665685429638, 0.12345930020313423, 0.11905093185431093, 0.11800794774273327, 0.24295085976502617, 0.2384140511385674, 0.22190068116528106, 0.231849389981317, 0.2980468165199044, 0.1178401389704844, 0.11021618663937116, 0.14513101062866174, 0.2091327385681785, 0.16466941996403384, 0.14658109753274728, 0.15952594846788792, 0.24235031898879356, 0.15463507191754744, 0.1517864410743437, 0.12145793945858008, 0.11951771480274487, 0.16078591796322694, 0.16492320214575795, 0.19616757471519908, 0.18567927160276998, 0.18254879049778705, 0.15883675253450258, 0.1941540195691377, 0.2098408283321892, 0.19799603238983077, 0.20327057858414532, 0.18899964305907702, 0.18907486869426293, 0.19310197265125217, 0.27815715075052605, 0.20478466276455698, 0.3941145467519229, 0.586690514681022, 0.5409077388922467, 0.16483690657734784, 0.16456082624382196, 0.17889484158368119, 0.15247734006539126, 0.1543574160030945, 0.15285693816808466, 0.16848159415622754, 0.12119618407931643, 0.12163458096372248, 0.20675306515768355, 0.143547671556139, 0.14633235742815964, 0.1539017282854087, 0.08657479146806579, 0.08652035834732708, 0.15897045532595033, 0.1692266038090422, 0.17657533290837923, 0.18281593928213968, 0.2189632221752993, 0.16300688053757073, 0.16375050646876554, 0.1614949296767445, 0.15730819239864668, 0.08560662356234638, 0.08252862633893965, 0.08118587294719692, 0.058558139001888776, 0.07893111241445572, 0.08956754141519063, 0.07466898137308797, 0.03980111430285471, 0.07049641510339166]}, "mutation_prompt": null}
{"id": "4288940e-a76f-40b8-8ce4-34af4dc4f5d2", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate * 1.1)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Adjust local search step size scaling based on success rate to dynamically enhance convergence speed and adaptability.", "configspace": "", "generation": 59, "fitness": 0.32641234984133843, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8592865978859949, 0.859271584296997, 0.8604046389480069, 0.8606743266961175, 0.8839664485074153, 0.8638189113033035, 0.8441283864332634, 0.8486478182136107, 0.8814414470666934, 0.7960561056267857, 0.7598455103199798, 0.7460222417705566, 0.7342357921510435, 0.7923917931832842, 0.7903030233668636, 0.7484459841748314, 0.7551357161848646, 0.7982606043793816, 0.12586857794381412, 0.12081985605818157, 0.15801044577966916, 0.7211647649405689, 0.14532654268393597, 0.15522528341400466, 0.14883344504101936, 0.21760653645619477, 0.21702808763066372, 0.053071283947694226, 0.13650024370248026, 0.1032364992975181, 0.16321033702025067, 0.23975590133668245, 0.12262710573114821, 0.19614379396833748, 0.19871435516085134, 0.2532643291085732, 0.9763746094988376, 0.9755945553854162, 0.9756052741967509, 0.9465166463200099, 0.9591425407124936, 0.9607072777012445, 0.9865821227851865, 0.9865831532638942, 0.9865830048450261, 0.6187910613436414, 0.5378581956178279, 0.6738791231976287, 0.6261705085823817, 0.6069748157652521, 0.6253078309370493, 0.6463506338369611, 0.6101762228493622, 0.6864972681127821, 0.8592212515704414, 0.1696185004805546, 0.16840772917571945, 0.16172950265809982, 0.2719152617674535, 0.2124647427359111, 0.7493340204561084, 0.22184813281503324, 0.6654036364885934, 0.3960684082353715, 0.2786017227278722, 0.3484472772147398, 0.5523735171725255, 0.13467605185919806, 0.41107703786096506, 0.13232083905489145, 0.46684289819668956, 0.6353219082270851, 0.3424790375852407, 0.19760071392133838, 0.22350371151279858, 0.5097047277220448, 0.31215638541509383, 0.5757728766997326, 0.4650632254189788, 0.3687346691809251, 0.3182192550448194, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1615497681508543, 0.17438488303640132, 0.10758958277145048, 0.02598591249787119, 0.05077916082836931, 0.02196081165760877, 0.051969782508101026, 0.08975397453053102, 0.07901278669695899, 0.07585457297017328, 0.08967273727013692, 0.06341200266115266, 0.012347020617678561, 0.011708173737848826, 0.11635055499831526, 0.012179415556531792, 9.999999999998899e-05, 0.05514048238830804, 0.2504938729242806, 0.33021088478771676, 0.2524865234740521, 0.34957952922393964, 0.2291303367384342, 0.23337312843253122, 0.057741345798958954, 0.2195706971187109, 0.3279926422808015, 0.5960825769689634, 0.6642206982070594, 0.6072869336710491, 0.6226027352422956, 0.5699455007974203, 0.6232563910417901, 0.6574874113263631, 0.5615662029720517, 0.6190403663576542, 0.1419854928793156, 0.14504128805613659, 0.1335145101462687, 0.11520808253244652, 0.16766692118312898, 0.13291975722945704, 0.13134968891892584, 0.11782074107621499, 0.10586633675551382, 0.13266473987347438, 0.19173667024513197, 0.12691454946700198, 0.2542440169506066, 0.18434072036272864, 0.2225199827055051, 0.18997006876299782, 0.11396641660199258, 0.11560406836870951, 0.28926762126937455, 0.17395804694753847, 0.14446445219930137, 0.2605956820032902, 0.38326630245731663, 0.3651338794639487, 0.24809550574203465, 0.33546688915067335, 0.43271573631528126, 0.21195936288487194, 0.24871880083050246, 0.3442191946255799, 0.2560789712069482, 0.3427876764733062, 0.22130529961195267, 0.17394655128291414, 0.17245297466623055, 0.1771568568178422, 0.19696196723998705, 0.21631827775717094, 0.23343789954592808, 0.2602580638372073, 0.21043228310770068, 0.222384636958322, 0.26669375270059714, 0.21107688603102825, 0.20901804394673917, 0.19058184573336745, 0.1873194166824893, 0.19581442495475732, 0.21610922310634162, 0.22318526757901802, 0.8088441762887554, 0.19864732550435904, 0.17898973227724824, 0.7118774982067697, 0.21126408823598408, 0.8105005274415038, 0.15353299934681586, 0.1984282121891462, 0.2524259479319185, 0.253560471224756, 0.11332891562557001, 0.11328431072381895, 0.11330426408630379, 0.16937960760355397, 0.12690512036168167, 0.2064605100277247, 0.21310013654373072, 0.2116362134342289, 0.2123921085048731, 0.21074138461893188, 0.1544641999056836, 0.19771743940277975, 0.19710150322413178, 0.18316575661809165, 0.16199298368853032, 0.14669992609185667, 0.20033456678332995, 0.19032764545758385, 0.22226546354925347, 0.19642359789081565, 0.17920293696014, 0.07468222179685746, 0.09511573323006473, 0.10850692101903692, 0.07702576783197124, 0.07752082410596195, 0.11164950491336889, 0.08005775044918606, 0.09139451139264132, 0.08023330987211597]}, "mutation_prompt": null}
{"id": "8049b847-9d33-48dd-bf2c-6e201cbdf137", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        last_mean_fitness = np.mean(fitness)\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            current_mean_fitness = np.mean(fitness)\n            fitness_change_ratio = max(0.9, min(1.1, last_mean_fitness / current_mean_fitness))\n            dynamic_crossover_rate = 0.9 * fitness_change_ratio * (1 + 0.1 * self.success_rate)\n            last_mean_fitness = current_mean_fitness\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Leverage a dynamic adjustment of crossover rate based on average population fitness improvement to enhance adaptability and speed up convergence.", "configspace": "", "generation": 60, "fitness": 0.2973700106512714, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.858642657783717, 0.8889868874594358, 0.8536757917240305, 0.8745072400722966, 0.8771191733476782, 0.8556069698647374, 0.8918794366786872, 0.8888189787776632, 0.887469461903191, 0.04868973697258261, 0.7460985474667605, 0.05851954988670427, 0.7487946479040033, 0.7830279813078007, 0.7707630392806113, 0.7246575916870428, 0.06848510700255739, 0.05823115792436673, 0.1613265663815271, 0.07930250101917824, 0.18963669868208577, 0.15167747560269296, 0.17665811606451243, 0.7182088664735722, 0.056505063134719924, 0.09157910297815164, 0.13255637096415818, 0.09569488502774526, 0.1779478765938416, 0.12925871776883724, 0.05117416961251697, 0.049272006895783704, 0.05643605214924796, 0.13736877183896812, 0.15724144131353968, 0.16829114288081326, 0.9576105987121636, 0.9645302063360587, 0.9609286278123074, 0.9702086589861089, 0.963856372441635, 0.9638821439235685, 0.9654477466113467, 0.9714988685244248, 0.9660419585892532, 0.6261991720327308, 0.5533966346388142, 0.5751483952112879, 0.5789229022999705, 0.6688957801003013, 0.5101106408805856, 0.6200244320369623, 0.5947027227671315, 0.5926929244745607, 0.8838836145582069, 0.19142266319927648, 0.2068519110306749, 0.20875479399863028, 0.21903058555204036, 0.11868926365357091, 0.16788592825714244, 0.23123438073443425, 0.23173309936163822, 0.13151340590506866, 0.7374592723730464, 0.27968008320253546, 0.1311169001203516, 0.13286282519934411, 0.25482704022304536, 0.16267983196718672, 0.5152213480678984, 0.11546729890615881, 0.4817726317137492, 0.28986153080554855, 0.41847139588555526, 0.1497753014526303, 0.5153279449225459, 0.5715894167226234, 0.13421231261222688, 0.4742703687511878, 0.3000485423197582, 0.1824099023417095, 0.09446278124716068, 0.08865009884713415, 0.07697618355251001, 0.0561810100456831, 0.040981576280375576, 0.057603267267146485, 9.999999999998899e-05, 0.003182268950936984, 0.18397122601798332, 0.1573424525320153, 0.14050948814773856, 0.06122328197224047, 0.13687485797554477, 0.09297592370405094, 0.10688084282037458, 0.04302708794998089, 0.059180864264171906, 0.14226756750297043, 0.07005518596788263, 0.1975617293990839, 0.13229531312973974, 0.12982535914817694, 0.17961766595592654, 0.1898673665232139, 0.10194747997027753, 0.1270623291624, 0.22672858276119223, 0.4179887905426508, 0.17158596511805257, 0.006408980926185914, 0.013079099657431148, 0.2656664437349877, 0.2510724852759434, 0.1884114374326593, 0.2594999204359617, 0.5439948129780652, 0.6879807180733162, 0.6438267944596405, 0.6369186194400156, 0.5834888501546902, 0.4823893084212989, 0.629362782317737, 0.6412001162562073, 0.6046529873418245, 0.14506572989357158, 0.18859513708458087, 0.15906647390864348, 0.08265081715609301, 0.10944314667407284, 0.09247300966455918, 0.11818427814888943, 0.13040430005518522, 0.11325634245330474, 0.19548112439900478, 0.17587474849235096, 0.18765358874045623, 0.09413405441313238, 0.081893930134742, 0.07653091410766788, 0.15911584966157533, 0.14772958602554986, 0.15169126435310387, 0.24114713792177644, 0.3442364923728496, 0.2831243363666883, 0.19321073676494604, 0.2907324387738378, 0.3755183354520524, 0.2481144510093699, 0.3137886982223359, 0.2894569760872199, 0.11154495089160132, 0.24561416108228018, 0.15940104876387196, 0.3358422635480237, 0.1430993275525907, 0.2251304756127699, 0.2510257735298079, 0.30515434317793255, 0.20295768117064783, 0.19771375158766202, 0.20462340447935579, 0.1908764181041639, 0.2192410204031422, 0.25997768344355987, 0.12545183356827894, 0.2259846551789758, 0.18069611569168587, 0.2550425820395591, 0.2026070962459532, 0.2092485663566278, 0.21875679098226364, 0.2087208879005794, 0.22718197476875546, 0.2010323654548728, 0.18379341906079427, 0.19828044260560285, 0.22401656880945298, 0.1734581151592598, 0.16779522940500302, 0.17270400065208524, 0.16613959931346856, 0.16646140338747906, 0.1661941105281407, 0.15320541656737274, 0.15776466032163938, 0.15817502507615067, 0.17044865418314037, 0.21043765705074713, 0.2103752120079283, 0.16975750408461643, 0.553903958761687, 0.8034935552515786, 0.213075098001288, 0.21287539250076137, 0.14545437673690453, 0.15007928621004207, 0.16940497268559906, 0.1585621473257528, 0.17319905155628235, 0.15008039568437104, 0.15009157355015468, 0.17859396404660544, 0.1914447678539033, 0.1862838700133692, 0.08723369832367478, 0.07139174358446632, 0.09796186954343755, 0.0804051527298898, 0.0920941871434443, 0.09170403898174351, 0.09223331486447628, 0.09254850695676597, 0.11415922397768008]}, "mutation_prompt": null}
{"id": "f8e3899d-2c02-48b6-97a1-60cdab3eebea", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1  # New parameter for diversity\n        self.avg_fitness_improvement = 0.0  # Track average fitness improvement\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n        prev_avg_fitness = np.mean(fitness)\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))  # Measure of diversity\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2  # Increase exploration if diversity is low\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            current_avg_fitness = np.mean(fitness)\n            fitness_improvement = abs(prev_avg_fitness - current_avg_fitness)\n            self.avg_fitness_improvement = (self.avg_fitness_improvement * 0.9 + fitness_improvement * 0.1)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (1 + 0.1 * self.success_rate) * (1 + 0.1 * self.avg_fitness_improvement)\n            prev_avg_fitness = current_avg_fitness\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce self-adaptive dynamic crossover rate adjustment based on average previous fitness improvements to enhance exploration-exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.20718636753862588, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8431925260813978, 0.8511325523504986, 0.8689953665677086, 0.8689609907421112, 0.8581724597046819, 0.8240624513746115, 0.8460905911488198, 0.25857583657363603, 0.2567250125593148, 0.551921300203477, 0.5865015689832502, 0.034055831703471595, 0.048928515311290166, 0.49683773345953175, 0.05850384050536883, 0.657477358603154, 0.037312936696888066, 0.06889612806026801, 0.14320195379238065, 0.13893240205478263, 0.12361021224667734, 0.07513774502892034, 0.1357784156260765, 0.11418115086940384, 0.09125624549503608, 0.06907567484603738, 0.06874900634814729, 0.05145866015474654, 0.010886789636911587, 0.01238059079973286, 0.040168634586353225, 0.026177933687348554, 0.06461674509125337, 0.08690457262125206, 0.053924095599757305, 0.0621077511630137, 0.07802387952965817, 0.05167285411929201, 0.9417653616617985, 0.07689990357338139, 0.9432359214681494, 0.9464024543915996, 0.07691102911337078, 0.0792189007589168, 0.0779695116437561, 0.5880486792968602, 0.4947145265488748, 0.5767093039131264, 0.5285396173064967, 0.42215771465050433, 0.5191366170371614, 0.497484908907013, 0.5820901368207418, 0.5472292901228032, 0.09656909891239596, 0.12070013104394439, 0.1391468938025351, 0.1542709627278005, 0.14746609437029712, 0.1145881494106572, 0.10785322214574478, 0.0660071436519244, 0.0719964261085756, 0.11798725569978175, 0.44332883787844835, 0.21905889011064184, 0.29620308757729297, 0.20322206467859727, 0.2118243582305921, 9.999999999998899e-05, 0.13941056553948705, 9.999999999998899e-05, 0.2251301395414751, 0.23891983412138929, 0.11307209607872426, 0.3388656624071249, 0.21387282610407532, 0.2774538157193649, 0.1163663841854563, 0.21392576274940966, 0.16089235379079525, 0.09218192665665503, 0.07275310922992195, 0.08289934692501189, 9.999999999998899e-05, 0.008646361611226339, 0.0455022380664728, 0.04218432305413933, 9.999999999998899e-05, 0.016011181460041768, 0.07464955745554358, 0.09543670629355927, 0.11869384023134755, 0.11205609310707365, 0.1208693526910285, 0.13169825948706582, 0.13380595298675346, 0.05479494291348874, 0.05922452924841659, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04312672043569599, 0.041444291243299625, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007004067924822888, 0.009873567586235033, 0.26829832491592864, 0.15552187324901245, 0.0053802084771170655, 0.006041317737167651, 0.005791404270217626, 0.07496558080922588, 0.18865475214703664, 0.06507383221473595, 0.6864477495277489, 0.6353097771023901, 0.5379320205775796, 0.5716594885075166, 0.5553885876243272, 0.5006576311251827, 0.635631635614031, 0.5731621686051965, 0.5791347530173707, 0.12406379778900556, 0.10585091201964802, 0.11412453356754015, 0.06837637970535437, 0.10110108498915416, 0.0825235223873727, 0.08109239689198788, 0.09260904982597584, 0.025583104124706546, 0.14788553395107706, 0.15541057767415567, 0.1554355249664262, 0.25570506674065074, 0.14882805498081964, 0.11886601546481912, 0.1677260392050819, 0.16428556812936346, 0.1402172520655165, 0.14488663474695362, 0.17331889817439838, 0.19460575637207922, 0.20809513312863503, 0.3243261254442361, 0.19788737168748016, 0.23895256657959707, 0.1758237819857732, 0.18704644208872956, 0.1185134622943338, 0.11047547474680919, 0.28891307287535495, 0.12602212025007808, 0.1184769862923658, 0.1336128942223852, 0.1745302141900662, 0.12464676642273753, 0.16089721066099538, 0.23153630969901629, 0.18527744406400948, 0.16517312489952096, 0.24184950687970153, 0.23688692151953628, 0.1837211491085643, 0.21865822153693215, 0.2638783012437461, 0.22094737464896552, 0.18874517642189104, 0.18304554105997228, 0.1913123461075601, 0.17128842717656412, 0.19941842121378173, 0.1985645620684181, 0.17474712508539192, 0.1842767752511728, 0.1883089705601687, 0.16940619570297677, 0.17296049412836545, 0.17303604919779025, 0.16621084286091714, 0.16624825820611044, 0.16624436723320157, 0.20060174878995574, 0.2004158846598253, 0.200539387911276, 0.16836776094114614, 0.169391384051523, 0.16900346930287946, 0.1685852724849326, 0.16791552999947656, 0.1679266773281266, 0.21108097023214567, 0.1550882903089782, 0.15544683913674617, 0.18482751256289498, 0.20673831892000838, 0.16158099380223556, 0.15875336360614123, 0.14994787132790988, 0.15009157355015468, 0.16254416790471515, 0.1976244064224194, 0.17920722396274336, 0.06830916373139184, 0.08199906708190141, 0.06755370401052951, 0.06384302249016416, 0.05513222402285267, 0.08627353161053031, 0.07323316657947287, 0.05698775466393802, 0.05694981370563623]}, "mutation_prompt": null}
{"id": "769e7d4f-3dcd-4af2-89d6-5d7e534d8459", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.last_improvement = 0  # Track the time since last improvement\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for current_eval in range(1, self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    self.last_improvement = current_eval  # Update last improvement\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n            # Adjust mutation factor based on time since last improvement\n            if current_eval - self.last_improvement > 0.1 * self.budget:\n                self.mutation_factor *= 1.1  # Increase exploration if no recent improvement\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Integrate dynamic mutation factor adjustment based on convergence speed to enhance adaptive exploration and exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.3264254990728041, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8592867541896644, 0.8521136240191396, 0.8604041111050538, 0.8606750456263702, 0.8839663390849283, 0.8638200355395397, 0.8441280718746558, 0.848647900532628, 0.8814411182782456, 0.7960561220350244, 0.7598445948474117, 0.7460225853176865, 0.7342387342352444, 0.7923918823635517, 0.7903032399745437, 0.7484468010499836, 0.7551360487008694, 0.7982625077052583, 0.12586803303925753, 0.1208467505666847, 0.15803999839407112, 0.7211653899453195, 0.14530835696358502, 0.15524785459972024, 0.14876599798344703, 0.21774885781753506, 0.21709566563498084, 0.053069877519869246, 0.13647788108751613, 0.10324258213084869, 0.16320681687461092, 0.2398303324619051, 0.1225887492498734, 0.19656853265098762, 0.19844167474788266, 0.2577858910371891, 0.9763746083761489, 0.975594550099331, 0.975605268125381, 0.9465164151916905, 0.9591425331330113, 0.96070726905951, 0.9865821224947126, 0.9865831529723937, 0.9865830045536736, 0.6187899426118189, 0.537857612981341, 0.6738789183152698, 0.6261704309734836, 0.6069742519606471, 0.6253072035271126, 0.6463505543293073, 0.6101744595561982, 0.6864970310834999, 0.8592212515704414, 0.1696185004805546, 0.16840772917571945, 0.16172950265809982, 0.2719152617674535, 0.2124647427359111, 0.7493340204561084, 0.22184813281503324, 0.6654036364885934, 0.3960683908177389, 0.2786019006188336, 0.34844735830966833, 0.5523735846633838, 0.13467626058997484, 0.4110769665355237, 0.13232075545989752, 0.46684387057199916, 0.6353209432855891, 0.3424798550991561, 0.19760104634875464, 0.2235033168646855, 0.5097046188970515, 0.3121563949041949, 0.5757728209043077, 0.46506371543965663, 0.3687349435312324, 0.31821925556599895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16154983621953178, 0.17438530717624467, 0.1075895055533238, 0.02598626424807171, 0.05078048275216751, 0.021960816553924678, 0.05196977984010265, 0.08975400047875304, 0.07901260872735805, 0.07585457154269548, 0.08967104055973829, 0.06341200266115266, 0.012347193263453127, 0.011708173737848826, 0.11635070284177673, 0.012179415556531792, 9.999999999998899e-05, 0.05513888053085303, 0.2504945202599089, 0.3302110369323402, 0.2524875717136792, 0.3495796837470131, 0.2291311859692814, 0.23337391438594846, 0.05774121783583108, 0.2195714007954963, 0.32799274636627984, 0.5960826655376283, 0.6642226992865994, 0.6072869848710137, 0.6226029558875579, 0.5699454010282925, 0.6232553145745983, 0.6574875039261912, 0.5615662217382232, 0.6190400666139971, 0.1419855429984095, 0.14504134935013335, 0.13351361363411762, 0.11520813103575511, 0.1676670819196583, 0.13292041580981617, 0.13134970522103162, 0.11782089981479094, 0.10586633050495198, 0.13266455850502412, 0.19173684102552946, 0.12689367876001578, 0.25423942379978126, 0.1843388451645479, 0.2210778616918596, 0.18996915869607955, 0.11396945974387984, 0.11559626674798618, 0.28929995274178544, 0.17395805636672412, 0.1444636048231296, 0.26650514173668194, 0.3832666369872558, 0.36514525294153133, 0.24808365109269048, 0.33546743803247037, 0.43271583036233174, 0.21195775744447942, 0.248720342206889, 0.3442239247553197, 0.2560818770553911, 0.3427791811283746, 0.22130598286806402, 0.1739492597693023, 0.17245301194347307, 0.17715692691860352, 0.1967295820602485, 0.21631354170350914, 0.23490675083897783, 0.26023281646328966, 0.21043582997405041, 0.2224441740572759, 0.26669694917763287, 0.21043228512627388, 0.2090183819520539, 0.19058176826456452, 0.18731937182931946, 0.19581435809211567, 0.21610093360652405, 0.22318526133548722, 0.8088439939978083, 0.19864815845292616, 0.17898821191873904, 0.7118782611674256, 0.21126398115413636, 0.8105010503987936, 0.15353637502206097, 0.19842617563443488, 0.2524253619966823, 0.2535602018335218, 0.113328916012023, 0.11328431376552761, 0.11330426289157935, 0.1693796232790601, 0.1269050924851043, 0.20646071989237502, 0.21310015720834297, 0.2116361841750073, 0.21239210326502145, 0.2107413569532055, 0.15446417577721783, 0.19771684244960397, 0.19710150322413178, 0.1831662498130633, 0.16199298368853032, 0.14669992609185667, 0.200334818659213, 0.1903279482499578, 0.2222655599317379, 0.19642359559948785, 0.17920722396274336, 0.07468223355480463, 0.09511516874913595, 0.10850649664117007, 0.07703011451881814, 0.0775203020021954, 0.11165399285973965, 0.08005855640247095, 0.09139452414307048, 0.08022954502519353]}, "mutation_prompt": null}
{"id": "23643aed-307b-4f97-983d-48231458365b", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.initial_mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.mutation_decay_rate = 0.98  # New parameter for mutation decay\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        mutation_factor = self.initial_mutation_factor\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n            mutation_factor *= self.mutation_decay_rate  # Apply decay to mutation factor\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce a mutation factor decay to balance exploration and exploitation dynamically over iterations for improved convergence.", "configspace": "", "generation": 63, "fitness": 0.18419798840099502, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.3760515617553678, 0.4021903133299961, 0.44961943520111425, 0.47729693740343804, 0.3929844931109344, 0.32207413340713453, 0.36279447484977334, 0.3596547279661245, 0.3103027490491257, 0.38063759959397736, 0.28688820547582505, 0.3720409276470359, 0.1992727187206439, 0.5182761730568912, 0.1707946806809454, 0.18797047705217562, 0.41015961883776464, 0.3285382209445672, 0.1683155099541115, 0.1509454418472298, 0.10742833375876948, 0.1919582094554898, 0.1392402137533092, 0.14110501378837126, 0.15329845728972635, 0.14134397330409576, 0.15016787389079544, 0.1782683061082294, 0.11013935644538508, 0.1418300542451696, 0.14292168138013495, 0.11611382404773829, 0.11572817914897493, 0.13215710306505457, 0.06409136104477364, 0.10041326471972956, 0.975550412188643, 0.9763703681574046, 0.9674811686424882, 0.05660183627484672, 0.056600071934778895, 0.0566003191195541, 0.9862530307623344, 0.9865843696042422, 0.9865842235438629, 0.062237882785748155, 0.12680830260066522, 0.1268069732260395, 0.11387302426325474, 0.12908766760978108, 0.17571778345821898, 0.11214638032941371, 0.11723862142418862, 0.11311625392513303, 0.22652892951995274, 0.20490363818951762, 0.19015320661252377, 0.15542559647171983, 0.19176355821822422, 0.2084475151994144, 0.1741788658715523, 0.17134596510612243, 0.22354602806102886, 0.1728613650620675, 0.30227954447805383, 0.13308272078250338, 0.11862724732965324, 0.08548555794460533, 0.10310868501462322, 0.25288381064693755, 0.21725733308978756, 0.16423484349640094, 0.1190897768010889, 0.13118776104239172, 0.13996446867133128, 0.1443294787934799, 0.1628707810110145, 0.14089994602336142, 0.13230958816707006, 0.15669349122747223, 0.13531140710041678, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06478787550182386, 0.08490702682626161, 0.10547273031206461, 0.029393407699662366, 0.017920560864314927, 0.012750469549177246, 0.12693858115343626, 0.036722818856613215, 0.08826332003528436, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06594776444985839, 0.12774117716840028, 0.1325485123735709, 9.999999999998899e-05, 9.999999999998899e-05, 0.09302580023772311, 0.10132648078192574, 0.21913978649846566, 0.10561414811362613, 0.10255205999017558, 0.10251671422897812, 0.13196694487270766, 0.01354815615941729, 0.09442376857926649, 0.0771362722710428, 0.168374192428298, 0.33037801652132825, 0.4521604943872961, 0.2726652206839414, 0.2864489080369559, 0.26263339695679866, 0.3865398221030786, 0.2501697509315147, 0.2532329219195171, 0.08133058935139181, 0.11341060826994454, 0.09817929634908684, 0.11858109549120821, 0.11901827848439939, 0.08035188947747485, 0.09007723729714978, 0.08725889041441715, 0.07158302371173908, 0.15121124228536043, 0.16481189610651148, 0.13735870839141684, 0.13645244661865796, 0.1578327615776357, 0.20383353040817798, 0.16921063684153792, 0.15469393411115928, 0.13446468697675884, 0.19172504713196703, 0.22015664183580497, 0.15067507084713783, 0.2727949441537989, 0.2313527125497441, 0.24060003513415684, 0.25744833051989224, 0.25346091219654776, 0.2577405407348303, 0.18866626058557823, 0.16059512895482453, 0.1506544990128874, 0.17924092882364784, 0.19136196418835372, 0.17190359105649478, 0.19126642837538188, 0.2589071049352878, 0.23335969883445007, 0.2111816291112668, 0.19820022481156452, 0.21300172360857073, 0.19755722957500943, 0.2047602193764133, 0.1889466522300075, 0.25132704548711504, 0.20368713199228372, 0.17309465042360517, 0.20025956325830618, 0.1837379050557214, 0.17277696340799886, 0.19894269417107513, 0.16614288828693446, 0.17789782347419802, 0.19057193264127859, 0.1889324534749307, 0.19797891032622417, 0.18788459854072492, 0.1837988419344625, 0.1811764018926585, 0.17420148244271916, 0.17786908452185546, 0.17489713323484535, 0.10834364245246364, 0.10226348268879559, 0.10745910039967965, 0.1436758241329873, 0.16660232773737083, 0.10132771376822769, 0.14974603900212746, 0.16901950279808375, 0.16872370086922295, 0.13293601523043985, 0.15396083382275605, 0.13243049272749197, 0.18593635711782186, 0.1707286297135373, 0.18007923192734854, 0.19262149340879509, 0.1604897434245779, 0.21701899886243603, 0.18885456989923965, 0.15704729027757858, 0.17677733145690977, 0.08196795178219507, 0.09545725911738934, 0.09888804373387028, 0.09841975342845144, 0.0629621039044359, 0.09394281345134292, 0.09320412885489737, 0.0853838234777562, 0.1040110142267493]}, "mutation_prompt": null}
{"id": "3af73275-253a-4d49-8f69-26d912e2b72e", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1  # New parameter for diversity\n        self.initial_population_size = self.population_size  # Store initial population size\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))  # Measure of diversity\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2  # Increase exploration if diversity is low\n\n            # Dynamically adjust population size based on success rate\n            if self.success_rate > 0.1:\n                self.population_size = min(self.initial_population_size * 2, self.population_size + 1)\n            else:\n                self.population_size = max(self.initial_population_size // 2, self.population_size - 1)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce a dynamic population size adjustment based on convergence rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 64, "fitness": 0.2119701622356713, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.24.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8743256773301271, 0.9124308920929507, 0.8971044245021602, 0.6227155135042626, 0.4203687326809845, 0.8073145967434827, 0.1403075353762031, 0.14493117129041944, 0.144285329103776, 0.7188069679599053, 0.7882613650841863, 0.7226015880763588, 0.7452112189739962, 0.8232371617445057, 0.7360554643301035, 0.7533717423901035, 0.6367239699009934, 0.6572808968068553, 0.034428632614089794, 0.03976278892004226, 0.05333256002365783, 0.18826412148997718, 0.1449422622692801, 0.14625368502831004, 0.1961686050679885, 0.23759576321454212, 0.11272935781832383, 0.018533901427946198, 0.00589584344698324, 0.005950291240906291, 0.26437620305002385, 0.058855227045634284, 0.1427611892257059, 0.25408386817571904, 0.1726670211297493, 0.09905371073114733, 0.9681471113184279, 0.9679629704465492, 0.9679827043315586, 0.9754359894642911, 0.9747431865598998, 0.9747572683011677, 0.8688625688157683, 0.9247540789841941, 0.9567989225928806, 0.22290943518765627, 0.2124760089495652, 0.2321183982125642, 0.3309181079116126, 0.049862139821660434, 0.04647760352109287, 0.16997770213516183, 0.054827970503258605, 0.05132814896217519, 0.16791334169660166, 0.18989427529730052, 0.12899178387387222, 0.13319557556017392, 0.23279476827501733, 0.22573359172506102, 0.15399966842624357, 0.10953565564772161, 0.0952189057769216, 0.17862266788510184, 0.14790930247453304, 0.14787491418394583, 0.17621636556336362, 0.28242183603381343, 0.2877037425503842, 0.08871397580406082, 0.19146996885946255, 0.12176647572325416, 0.14797147751259687, 0.13039348174067578, 0.1413004280331579, 0.13693902016781545, 0.17652542397048454, 0.17994058796539736, 0.12645837605972776, 0.1617762824846406, 0.14580721922904172, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037049478670936664, 0.054772096020939354, 0.051616869776754726, 9.999999999998899e-05, 0.012943650751491953, 9.999999999998899e-05, 0.048942968940714815, 0.04543389169057188, 0.08106565330765136, 9.999999999998899e-05, 0.04333030077386213, 0.00977073458529043, 0.08457473489526168, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17333510206187852, 0.006559253650681551, 0.006452524245960767, 0.04562047070132247, 0.11156543712013134, 0.08777245005114964, 0.2750712533724815, 0.174199661586251, 0.17399566926955634, 0.21801969814490396, 0.2280276233645121, 0.18412669551009941, 0.5891473081122944, 0.14113989769372015, 0.14118036783123622, 0.05091397497795391, 0.07666090533030823, 0.06591571291387444, 0.08595954377836312, 0.09391003946359466, 0.09061111847965786, 0.05247418547507554, 0.07088075857726472, 0.05287313781853886, 0.13072144674722608, 0.14468869114505944, 0.14949752829688623, 0.12489273436493675, 0.07655875986277028, 0.08263597953147384, 0.140299131912625, 0.12274860110114749, 0.0901977999436745, 0.13790935663746495, 0.14062427244836218, 0.13293193682970283, 0.23164684822590265, 0.17903005790133086, 0.17358641559479204, 0.2593044497985816, 0.19130197729158593, 0.24612664738090573, 0.13572815791050274, 0.10016671336093841, 0.08530570229546863, 0.06005859670438696, 0.14181329414596278, 0.1405545498159223, 0.21194389208513753, 0.23511569739723615, 0.20239323387651398, 0.13148158380717434, 0.12145793945858008, 0.12241646926650596, 0.17561536299247604, 0.16778723445441024, 0.18397292724452508, 0.15413506665564036, 0.17416590014308453, 0.20206689337915107, 0.19006861204423897, 0.19542768949025957, 0.20579897143819126, 0.207925176647756, 0.3113912746946801, 0.3742084756031291, 0.18447174107065334, 0.181935625108525, 0.21387096727731159, 0.3150408889642391, 0.16573937128160565, 0.16628554014428232, 0.4317980837523111, 0.3781611874964641, 0.40085655302463563, 0.12153599033475548, 0.17750280528601559, 0.17047176283859133, 0.20794978120661745, 0.17057884942113433, 0.20541835458250224, 0.21160797806292053, 0.2124637933259783, 0.39682644787411736, 0.20215318716151565, 0.193610944244608, 0.19535838286170326, 0.1819293691559396, 0.12453899671076962, 0.17782155462410587, 0.15709278335669918, 0.16778186679855278, 0.17264775414764078, 0.15945153429174064, 0.1568047385530985, 0.16088408753728178, 0.06515591026634904, 0.07318251749002447, 0.09417050725079457, 0.04996688069758626, 0.0668458596495084, 0.07944998464526054, 0.09543239476014043, 0.07394056090764867, 0.09278557951952737]}, "mutation_prompt": null}
{"id": "6d360adc-327a-448f-bcc6-7ad7bf9c5d10", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.dynamic_population_adjustment = 0.9  # New parameter for dynamic adjustment\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n            # Adjust population size dynamically\n            if np.mean(fitness) > 0.8 * self.best_fitness:\n                self.population_size = int(self.population_size * self.dynamic_population_adjustment)\n                self.population_size = max(4, self.population_size)  # Ensure a minimum size\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Integrate dynamic population size adaptation based on convergence speed to enhance exploration and exploitation balance.", "configspace": "", "generation": 65, "fitness": 0.23578226985901327, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.26.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.886674035936124, 0.8925559032971822, 0.8994399876385727, 0.8687904984158813, 0.9107106951632989, 0.7923005819810737, 0.8441280718746558, 0.848647900532628, 0.8814411182782456, 0.7260551497182098, 0.8015650648339594, 0.6810967964211839, 0.6441566617182755, 0.7513598942528462, 0.6658620681450933, 0.7880767169495312, 0.8190545650897347, 0.6656080268538532, 0.09922189404997384, 0.08303167880213858, 0.10905711376399374, 0.09089118921073602, 0.16653437783342362, 0.12324993090135217, 0.1758137066377049, 0.14387059852482886, 0.11031778130284797, 9.999999999998899e-05, 0.01531589049312565, 0.015790718214535815, 0.14289036267784905, 0.026908863415757378, 0.15494503634257706, 0.15022327495301502, 0.2569520562444991, 0.15501979634592422, 0.9808356704850646, 0.9790017806455004, 0.9802102279042277, 0.974151124507443, 0.9661695101821344, 0.9576826513888074, 0.9734844158358867, 0.9666119309133351, 0.9666146464888438, 0.12375037728493066, 0.16550416911553367, 0.21558472511972537, 0.12759108585875334, 0.36768716474483276, 0.30760824341558113, 0.16564413435323444, 0.2163345589369663, 0.14863655418204758, 0.2053345232016659, 0.17512802264271343, 0.19887465822551564, 0.156578450367991, 0.17337592516010103, 0.16975755998078967, 0.13044875024681735, 0.15019011754109945, 0.12581704418466177, 0.1312354609398375, 0.1281467633468899, 0.11497941891040098, 0.1855440059721415, 0.156456161841786, 0.18439242968375524, 0.157867655281416, 0.10649720321979006, 0.10660544232479297, 0.10844755274447071, 0.12797471360746526, 0.1272013887938248, 0.1709360005789633, 0.1561654434328995, 0.15472704442237706, 0.14979332751479013, 0.14634293615389649, 0.13958704193004812, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11827353254788664, 0.050695014096112545, 0.04607864075753876, 0.013770390769238472, 0.05669886477495789, 0.05562678043530611, 0.04401316036554326, 0.03663259762905913, 0.04605271040670067, 0.025249851867853113, 0.011802581980849602, 0.0715754803992239, 0.03875188459160217, 0.012387382391324198, 0.056940257090323576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12862424586191024, 0.1735873082693633, 0.13069584356288555, 0.20171231640132314, 0.13613778877645366, 0.12780264987719148, 0.18474663018967052, 0.1866748054614129, 0.18838231661350824, 0.4089297351787998, 0.40665151502176766, 0.46038552566402213, 0.5539667029711908, 0.6394592518580309, 0.5172830679467284, 0.07061865308853721, 0.08384722411095624, 0.08307611985125518, 0.05437281536529426, 0.05788811533493665, 0.06189463345141888, 0.06033253611332112, 0.07525107773124418, 0.09706720100300792, 0.13927467256642156, 0.1619942508170079, 0.15301675952125826, 0.25423942379978126, 0.1843388451645479, 0.2210778616918596, 0.14918617708597193, 0.15592098528594067, 0.13836758035763064, 0.11282665685429638, 0.12345930020313423, 0.11905093185431093, 0.11800794774273327, 0.24295085976502617, 0.2384140511385674, 0.22190068116528106, 0.231849389981317, 0.2980468165199044, 0.1178401389704844, 0.11021618663937116, 0.14513101062866174, 0.2091327385681785, 0.16466941996403384, 0.14658109753274728, 0.15952594846788792, 0.24235031898879356, 0.15463507191754744, 0.14513444591238256, 0.17442461649753438, 0.17738409216369877, 0.16078591796322694, 0.16492320214575795, 0.19616757471519908, 0.18567927160276998, 0.18254879049778705, 0.15883675253450258, 0.1941540195691377, 0.2098408283321892, 0.19799603238983077, 0.20327057858414532, 0.18899964305907702, 0.18907486869426293, 0.19310197265125217, 0.27815715075052605, 0.20478466276455698, 0.3941145467519229, 0.586690514681022, 0.5409077388922467, 0.16483690657734784, 0.16456082624382196, 0.17889484158368119, 0.113328916012023, 0.11328431376552761, 0.11330426289157935, 0.1693796232790601, 0.1269050924851043, 0.20646071989237502, 0.20675306515768355, 0.143547671556139, 0.14633235742815964, 0.1539017282854087, 0.08657479146806579, 0.08652035834732708, 0.15897045532595033, 0.1692266038090422, 0.17657533290837923, 0.18281593928213968, 0.2189632221752993, 0.16300688053757073, 0.2222655599317379, 0.19642359559948785, 0.17920722396274336, 0.08560662356234638, 0.08252862633893965, 0.08118587294719692, 0.058558139001888776, 0.07893111241445572, 0.08956754141519063, 0.07466898137308797, 0.03980111430285471, 0.07049641510339166]}, "mutation_prompt": null}
{"id": "14c79817-9f47-45f0-8dc5-638009556e9a", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1  # New parameter for diversity\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))  # Measure of diversity\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            self.diversity_threshold = max(0.05, 0.1 * (1 - self.success_rate))  # Dynamically adjust diversity threshold\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2  # Increase exploration if diversity is low\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce a dynamic adjustment to the diversity threshold based on the success rate to enhance adaptability and faster convergence.", "configspace": "", "generation": 66, "fitness": 0.325772544189794, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8592867541896644, 0.8521136240191396, 0.8604041111050538, 0.8606750456263702, 0.8839663390849283, 0.8638200355395397, 0.8647855451066427, 0.848647900532628, 0.8814411182782456, 0.7960561220350244, 0.7598445948474117, 0.7460225853176865, 0.7342387342352444, 0.7923918823635517, 0.7903032399745437, 0.7484468010499836, 0.7551360487008694, 0.7982625077052583, 0.12586803303925753, 0.1208467505666847, 0.15803999839407112, 0.7211653899453195, 0.14530835696358502, 0.15524785459972024, 0.14876599798344703, 0.21774885781753506, 0.21709566563498084, 0.053069877519869246, 0.13647788108751613, 0.10324258213084869, 0.16320681687461092, 0.2398303324619051, 0.1225887492498734, 0.19656853265098762, 0.19844167474788266, 0.2577858910371891, 0.9763746083761489, 0.975594550099331, 0.975605268125381, 0.9465164151916905, 0.9591425331330113, 0.96070726905951, 0.9865821224947126, 0.9865831529723937, 0.9865830045536736, 0.6187899426118189, 0.537857612981341, 0.6738789183152698, 0.6184950912501677, 0.6069742519606471, 0.6253072035271126, 0.6463505543293073, 0.6101744595561982, 0.6864970310834999, 0.8592212515704414, 0.1696185004805546, 0.16840772917571945, 0.16172950265809982, 0.2719152617674535, 0.2124647427359111, 0.7493340204561084, 0.22184813281503324, 0.6654036364885934, 0.3960683908177389, 0.2786019006188336, 0.34844735830966833, 0.5523735846633838, 0.13467626058997484, 0.4110769665355237, 0.13232075545989752, 0.46684387057199916, 0.6353209432855891, 0.3424798550991561, 0.19760104634875464, 0.2235033168646855, 0.5097046188970515, 0.3121563949041949, 0.5757728209043077, 0.46506371543965663, 0.3687349435312324, 0.31821925556599895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16154983621953178, 0.17438530717624467, 0.1308317486229258, 0.02598626424807171, 0.05078048275216751, 0.021960816553924678, 0.05196977984010265, 0.08975400047875304, 0.07901260872735805, 0.07585457154269548, 0.08967104055973829, 0.06341200266115266, 0.012347193263453127, 0.011708173737848826, 0.11635070284177673, 0.012179415556531792, 9.999999999998899e-05, 0.05513888053085303, 0.2504945202599089, 0.3302110369323402, 0.2524875717136792, 0.3495796837470131, 0.2291311859692814, 0.23337391438594846, 0.05774121783583108, 0.2195714007954963, 0.19129065599867912, 0.5960826655376283, 0.6642226992865994, 0.6072869848710137, 0.6226029558875579, 0.5699454010282925, 0.5826947736337496, 0.6574875039261912, 0.5615662217382232, 0.6190400666139971, 0.1419855429984095, 0.14504134935013335, 0.13351361363411762, 0.11520813103575511, 0.1676670819196583, 0.13292041580981617, 0.13134970522103162, 0.11782089981479094, 0.10586633050495198, 0.13266455850502412, 0.19173684102552946, 0.12689367876001578, 0.25423942379978126, 0.1843388451645479, 0.2210778616918596, 0.18996915869607955, 0.11396945974387984, 0.11559626674798618, 0.28929995274178544, 0.17395805636672412, 0.1444636048231296, 0.26650514173668194, 0.3832666369872558, 0.36514525294153133, 0.24808365109269048, 0.33546743803247037, 0.43271583036233174, 0.21195775744447942, 0.248720342206889, 0.3442239247553197, 0.2560818770553911, 0.3427791811283746, 0.22130598286806402, 0.1739492597693023, 0.17245301194347307, 0.17715692691860352, 0.1967295820602485, 0.21631354170350914, 0.23490675083897783, 0.26023281646328966, 0.21043582997405041, 0.2224441740572759, 0.26669694917763287, 0.21043228512627388, 0.2090183819520539, 0.19058176826456452, 0.18731937182931946, 0.19581435809211567, 0.21610093360652405, 0.22318526133548722, 0.8088439939978083, 0.19864815845292616, 0.17898821191873904, 0.7118782611674256, 0.21126398115413636, 0.8105010503987936, 0.15353637502206097, 0.19842617563443488, 0.2524253619966823, 0.2535602018335218, 0.113328916012023, 0.11328431376552761, 0.11330426289157935, 0.1693796232790601, 0.1269050924851043, 0.20646071989237502, 0.21310015720834297, 0.2116361841750073, 0.21239210326502145, 0.2107413569532055, 0.15446417577721783, 0.19771684244960397, 0.19710150322413178, 0.1831662498130633, 0.16199298368853032, 0.14669992609185667, 0.200334818659213, 0.1903279482499578, 0.2222655599317379, 0.19642359559948785, 0.17920722396274336, 0.07468223355480463, 0.09511516874913595, 0.10850649664117007, 0.07703011451881814, 0.0775203020021954, 0.11165399285973965, 0.08005855640247095, 0.09139452414307048, 0.08022954502519353]}, "mutation_prompt": null}
{"id": "0cbfccd4-1d1d-430c-aad1-65e775aa25c2", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            average_improvement = self.best_fitness - np.mean(fitness)\n            modulated_learning_rate = self.learning_rate * (1 + 0.1 * np.tanh(average_improvement))\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Modulate the learning rate based on the average improvement in fitness to dynamically balance exploration and exploitation.", "configspace": "", "generation": 67, "fitness": 0.3264254990728041, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8592867541896644, 0.8521136240191396, 0.8604041111050538, 0.8606750456263702, 0.8839663390849283, 0.8638200355395397, 0.8441280718746558, 0.848647900532628, 0.8814411182782456, 0.7960561220350244, 0.7598445948474117, 0.7460225853176865, 0.7342387342352444, 0.7923918823635517, 0.7903032399745437, 0.7484468010499836, 0.7551360487008694, 0.7982625077052583, 0.12586803303925753, 0.1208467505666847, 0.15803999839407112, 0.7211653899453195, 0.14530835696358502, 0.15524785459972024, 0.14876599798344703, 0.21774885781753506, 0.21709566563498084, 0.053069877519869246, 0.13647788108751613, 0.10324258213084869, 0.16320681687461092, 0.2398303324619051, 0.1225887492498734, 0.19656853265098762, 0.19844167474788266, 0.2577858910371891, 0.9763746083761489, 0.975594550099331, 0.975605268125381, 0.9465164151916905, 0.9591425331330113, 0.96070726905951, 0.9865821224947126, 0.9865831529723937, 0.9865830045536736, 0.6187899426118189, 0.537857612981341, 0.6738789183152698, 0.6261704309734836, 0.6069742519606471, 0.6253072035271126, 0.6463505543293073, 0.6101744595561982, 0.6864970310834999, 0.8592212515704414, 0.1696185004805546, 0.16840772917571945, 0.16172950265809982, 0.2719152617674535, 0.2124647427359111, 0.7493340204561084, 0.22184813281503324, 0.6654036364885934, 0.3960683908177389, 0.2786019006188336, 0.34844735830966833, 0.5523735846633838, 0.13467626058997484, 0.4110769665355237, 0.13232075545989752, 0.46684387057199916, 0.6353209432855891, 0.3424798550991561, 0.19760104634875464, 0.2235033168646855, 0.5097046188970515, 0.3121563949041949, 0.5757728209043077, 0.46506371543965663, 0.3687349435312324, 0.31821925556599895, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16154983621953178, 0.17438530717624467, 0.1075895055533238, 0.02598626424807171, 0.05078048275216751, 0.021960816553924678, 0.05196977984010265, 0.08975400047875304, 0.07901260872735805, 0.07585457154269548, 0.08967104055973829, 0.06341200266115266, 0.012347193263453127, 0.011708173737848826, 0.11635070284177673, 0.012179415556531792, 9.999999999998899e-05, 0.05513888053085303, 0.2504945202599089, 0.3302110369323402, 0.2524875717136792, 0.3495796837470131, 0.2291311859692814, 0.23337391438594846, 0.05774121783583108, 0.2195714007954963, 0.32799274636627984, 0.5960826655376283, 0.6642226992865994, 0.6072869848710137, 0.6226029558875579, 0.5699454010282925, 0.6232553145745983, 0.6574875039261912, 0.5615662217382232, 0.6190400666139971, 0.1419855429984095, 0.14504134935013335, 0.13351361363411762, 0.11520813103575511, 0.1676670819196583, 0.13292041580981617, 0.13134970522103162, 0.11782089981479094, 0.10586633050495198, 0.13266455850502412, 0.19173684102552946, 0.12689367876001578, 0.25423942379978126, 0.1843388451645479, 0.2210778616918596, 0.18996915869607955, 0.11396945974387984, 0.11559626674798618, 0.28929995274178544, 0.17395805636672412, 0.1444636048231296, 0.26650514173668194, 0.3832666369872558, 0.36514525294153133, 0.24808365109269048, 0.33546743803247037, 0.43271583036233174, 0.21195775744447942, 0.248720342206889, 0.3442239247553197, 0.2560818770553911, 0.3427791811283746, 0.22130598286806402, 0.1739492597693023, 0.17245301194347307, 0.17715692691860352, 0.1967295820602485, 0.21631354170350914, 0.23490675083897783, 0.26023281646328966, 0.21043582997405041, 0.2224441740572759, 0.26669694917763287, 0.21043228512627388, 0.2090183819520539, 0.19058176826456452, 0.18731937182931946, 0.19581435809211567, 0.21610093360652405, 0.22318526133548722, 0.8088439939978083, 0.19864815845292616, 0.17898821191873904, 0.7118782611674256, 0.21126398115413636, 0.8105010503987936, 0.15353637502206097, 0.19842617563443488, 0.2524253619966823, 0.2535602018335218, 0.113328916012023, 0.11328431376552761, 0.11330426289157935, 0.1693796232790601, 0.1269050924851043, 0.20646071989237502, 0.21310015720834297, 0.2116361841750073, 0.21239210326502145, 0.2107413569532055, 0.15446417577721783, 0.19771684244960397, 0.19710150322413178, 0.1831662498130633, 0.16199298368853032, 0.14669992609185667, 0.200334818659213, 0.1903279482499578, 0.2222655599317379, 0.19642359559948785, 0.17920722396274336, 0.07468223355480463, 0.09511516874913595, 0.10850649664117007, 0.07703011451881814, 0.0775203020021954, 0.11165399285973965, 0.08005855640247095, 0.09139452414307048, 0.08022954502519353]}, "mutation_prompt": null}
{"id": "36502bd0-4f86-4ec9-be7d-432a02d92935", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1  # New parameter for diversity\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        previous_best_fitness = self.best_fitness\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))  # Measure of diversity\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2  # Increase exploration if diversity is low\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            if self.best_fitness < previous_best_fitness:\n                dynamic_crossover_rate *= 1.05  # Slight increase if improvement is observed\n            else:\n                dynamic_crossover_rate *= 0.95  # Slight decrease if there's no improvement\n            dynamic_crossover_rate = np.clip(dynamic_crossover_rate, 0.1, 0.9)\n            previous_best_fitness = self.best_fitness\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce a self-tuning mechanism for crossover rate based on ongoing improvement rates to enhance convergence.", "configspace": "", "generation": 68, "fitness": 0.2842181104849033, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.28.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8873788760227127, 0.91146302229632, 0.8971473851757314, 0.9048812819294204, 0.9105899852375581, 0.9115868353826853, 0.9070545645310663, 0.8955202152493021, 0.9010627849351626, 0.7983963599468149, 0.814985487883447, 0.8188975925284203, 0.7938514128818013, 0.8330590929671768, 0.8185423051694999, 0.8301148671006184, 0.832694163488374, 0.8367935060929838, 0.22604385196956867, 0.8155145908259509, 0.8402073081593179, 0.13136395879055085, 0.20974723762176983, 0.17760496719047647, 0.16600504989766973, 0.19788132042154805, 0.8004352313875865, 0.8104231321045592, 0.7971551844933931, 0.2630794881005124, 0.11606295732315774, 0.1114758205059394, 0.2102051319413979, 0.8007135536976806, 0.7875320294271554, 0.22862911993195845, 0.9855262216297288, 0.9851649216199067, 0.9851800254148886, 0.9676850459427295, 0.9676610434081232, 0.9676641232416942, 0.980486748440674, 0.9805581385124257, 0.980541159717101, 0.3899076071272546, 0.29386797092126216, 0.32901454362081706, 0.23245328125029796, 0.431371596830064, 0.3411762501603707, 0.227465431211622, 0.1899858725963045, 0.18651772854683657, 0.1450734589439966, 0.16630345301509186, 0.12649110449589174, 0.16235657392853264, 0.17145518179628472, 0.19979709059476658, 0.17144723786863747, 0.2654427838734379, 0.19976382952817806, 0.18469328224284076, 0.1866969955700022, 0.20544025173794012, 0.19484484688144443, 0.23153045555450613, 0.24575787727535847, 0.25901159225225834, 0.12968966796601566, 0.17754040221334455, 0.11545544115137507, 0.11823397048973516, 0.13554771144602795, 0.19078396238784112, 0.13434125887591308, 0.2848831824541067, 0.13615024714385182, 0.14525492441273014, 0.1514694212867489, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07292499952562392, 0.05643449106120446, 0.0754599514508536, 9.999999999998899e-05, 0.04090909883934368, 0.05938839291590303, 0.0764671230793239, 0.06218363409867067, 0.05168230367824489, 0.027501327387806307, 0.007680884436897628, 0.003526651876041953, 0.07779950780877165, 0.07853097093088146, 0.07649778291043507, 0.01542776742972296, 0.00939003778131886, 0.032657707035733785, 0.05719908523075812, 0.05050238791053163, 0.05399173332313967, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13578709677839995, 0.11210028935202632, 0.12738536580895854, 0.4601771466016574, 0.4259334703205906, 0.5354289339663862, 0.44971193010726607, 0.4662730785203061, 0.4608903772406495, 0.47111005149608587, 0.4011724251475475, 0.43607442767305915, 0.0936020695322366, 0.10153403245402437, 0.10287601528245505, 0.08603811372262793, 0.13067442877571045, 0.09114224061088738, 0.09880114243498195, 0.10357009151765162, 0.1033073441227581, 0.2018579972770571, 0.18002556161840855, 0.16124390275213918, 0.19525523573374903, 0.1893218390025071, 0.1711109693812337, 0.15037825271679262, 0.15792051854779243, 0.143016122084907, 0.18122349986632058, 0.23386784580321252, 0.3024335944181624, 0.24100435210661753, 0.21437874414439906, 0.3025653102490734, 0.28164089108274737, 0.2929026484800683, 0.32121595186921226, 0.16873378897485813, 0.1543350269750916, 0.1679781332487431, 0.17002243870625755, 0.17039753663980461, 0.186771325885708, 0.1979092030677151, 0.20126089832470961, 0.22388988381367403, 0.20889142991960874, 0.19220695618081407, 0.19653562562623172, 0.208142427493214, 0.1914992401824115, 0.19719610061403314, 0.1876791608789653, 0.2052264992591658, 0.20437596445942396, 0.25667798960001564, 0.353059798398772, 0.2232124771520776, 0.2979260617658911, 0.24190180694013186, 0.2195152055491414, 0.3314540159236331, 0.24568053674191592, 0.24361472204625167, 0.16651093292956887, 0.16672450016221096, 0.20347531295692955, 0.16616743772550235, 0.18405857347366195, 0.19192851766586583, 0.18334560022420232, 0.1921560264997454, 0.19327340170332086, 0.20609803301638774, 0.1914675616518725, 0.19911598561030275, 0.1683073458824852, 0.1875044418233558, 0.19303055058798912, 0.13041600499703032, 0.21184710182126631, 0.20713015048101358, 0.20344163097469503, 0.18197247883062873, 0.18849565658501777, 0.18086508783084643, 0.1824152242050836, 0.16466144213039824, 0.21097133065745766, 0.1828900527838715, 0.183314350929902, 0.08670541235460483, 0.08493229511469269, 0.07447525271103639, 0.09188739943574731, 0.08354697870643535, 0.08992560908723501, 0.0833001543195554, 0.07981384519513413, 0.09465319380568293]}, "mutation_prompt": null}
{"id": "dd4f68a3-9219-4260-9816-12e7cac2f6c6", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            adjusted_mutation_factor *= (0.9 + 0.2 * self.success_rate)  # Added adjustment\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Enhance search efficiency by dynamically adjusting the mutation factor based on both success rate and convergence trends to improve exploration-exploitation balance.", "configspace": "", "generation": 69, "fitness": 0.3124757854566025, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8723661606203008, 0.892633954632711, 0.8630839983215173, 0.8785486149952859, 0.898893817657362, 0.8907155969506675, 0.8640089486818134, 0.8643307948993755, 0.8576818369616601, 0.7532638772627017, 0.7935594684133519, 0.8147531411771962, 0.7260322121735243, 0.7859588941518298, 0.7525006472880478, 0.7652403519913318, 0.6843829145442663, 0.7260727504465092, 0.1197114547144984, 0.1472269824447232, 0.14171827266564507, 0.16588153402696848, 0.14530604519784196, 0.25560008060002926, 0.5860081311224102, 0.15316880028161073, 0.6659973718749223, 0.05935344021128053, 0.06163643083614534, 0.13562359542489488, 0.14419966253194472, 0.21154673771113097, 0.15084820997219717, 0.14736303100850923, 0.1511644204279573, 0.1539435016996462, 0.9733288773428712, 0.9742794548231204, 0.9742847541630181, 0.9824420468494535, 0.9824411821706784, 0.9824412633889105, 0.9741606946759656, 0.9754371960331425, 0.97383787043512, 0.5756611978328825, 0.5281453440940747, 0.6245924736921875, 0.5853840881197439, 0.3136695731989718, 0.5488372860878252, 0.5665700379952932, 0.6229530341335043, 0.5771347816424537, 0.1341659752930009, 0.22951544726134365, 0.36783032826412865, 0.19898883315592997, 0.3747322394752495, 0.21323504772739188, 0.3439436540354981, 0.7385360442126543, 0.739144482148621, 0.32834427833017676, 0.1817049220992384, 0.2250907068676209, 0.2531523726046525, 0.18763794341291595, 0.13468551397374995, 0.20807986866902883, 0.28408180429934016, 0.22703315290956672, 0.22164722028296635, 0.22679258688049286, 0.20793002270550465, 0.28637103695599475, 0.2280349097058817, 0.21903584318371372, 0.28624905101431863, 0.2440508739698437, 0.2610493491969381, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12433583795862091, 0.16763990474889656, 0.11882716906413004, 0.032368887206505326, 0.02845788230431845, 0.04086597309122075, 0.11229685620347973, 0.12815755172791543, 0.07912427354430418, 0.01884503768020973, 0.03992211634716458, 0.03659072588326895, 0.07047077132510804, 0.1145994155785316, 0.10818541342154042, 0.046416474701437394, 0.037278374059682706, 0.04394896523335268, 0.20538029883283315, 0.2553932781214169, 0.2586818306141928, 0.23779993710868597, 0.24270058100662106, 0.133779919430426, 0.1915924111052284, 0.15478744325147542, 0.2064948891040438, 0.583552064321273, 0.5934298878918951, 0.5378540367029505, 0.6243564180774896, 0.5505719371153982, 0.45389133689484074, 0.5505720505804954, 0.604947305331883, 0.5431901219433825, 0.17663543198454867, 0.12251141439158786, 0.1402722314829753, 0.11744805138226388, 0.12148143718563531, 0.11729710883966382, 0.10020197388965846, 0.09925628159596966, 0.07372461321327806, 0.18857746520929497, 0.1549970111240203, 0.27718595121430456, 0.15761719786048434, 0.17571989972537339, 0.14805147958612652, 0.17702497126482175, 0.119543991817459, 0.15607982252614583, 0.20026388839987008, 0.2846518422472917, 0.21826643064092766, 0.3160591785475272, 0.2721434394021316, 0.3660342060120937, 0.30250868632572736, 0.2652596679002359, 0.47655180453434653, 0.14035861277515138, 0.17356714131809947, 0.15082327696191078, 0.24711878116955732, 0.31727802532483373, 0.34581792132622413, 0.2600781723975095, 0.2840664233895488, 0.2520644745033416, 0.18839532179553375, 0.2880388557615008, 0.185119613169913, 0.18071602426135847, 0.22807895104385367, 0.22026719390118144, 0.20271590994477096, 0.18424036841044222, 0.22666072509630186, 0.22593279701477964, 0.18283230009385953, 0.24364978720030084, 0.22504256961021996, 0.22342178136593172, 0.22272488615587305, 0.22480071753977016, 0.21145060327262044, 0.1966820631238012, 0.19329906734709945, 0.1526699248956347, 0.167888389881498, 0.3124704065936056, 0.1841857732236828, 0.19030853228280153, 0.19980578885991696, 0.16787928773219263, 0.16788869792842087, 0.2128882931907593, 0.16982099683959206, 0.13966273909737736, 0.7625862141495947, 0.16883311008770652, 0.16886803175919718, 0.7873816205739367, 0.7853219663058244, 0.7832777633765048, 0.2214040983699208, 0.19241359602438457, 0.1694138797055511, 0.1702514037337296, 0.19665534328068934, 0.18220844159723215, 0.19357449537362093, 0.2682295565451418, 0.23447394083429585, 0.0922265097583913, 0.08087963617955685, 0.08986981736084831, 0.06305797698431947, 0.10527347715497726, 0.0837582857642718, 0.0792898920712769, 0.07687693109376836, 0.07736926968585467]}, "mutation_prompt": null}
{"id": "e028ca74-dc9c-4982-b991-ae2d9ae6bf01", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.inertia_weight = 0.9  # Added for adaptive mutation\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        initial_budget = self.budget\n        for _ in range(self.budget):\n            self.inertia_weight *= 0.99  # Decay over time to improve convergence\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            adjusted_mutation_factor *= self.inertia_weight  # Apply inertia weight to mutation factor\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * initial_budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive mutation factor adjustment using a decaying inertia weight to enhance convergence speed and maintain exploration.", "configspace": "", "generation": 70, "fitness": 0.20948076410400432, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.29635704709312227, 0.3900397866402555, 0.46560249089209527, 0.2896916849090352, 0.6784997894061648, 0.5458942570042955, 0.26743529568752333, 0.27383937827238947, 0.2733257041256395, 0.4400191413153106, 0.3825938725217547, 0.4800646717015036, 0.4732166078655424, 0.3681675548120432, 0.44514762537525676, 0.39117137189904216, 0.4155695774563686, 0.22826384755353712, 0.14828207687565753, 0.12172559134416461, 0.0914065148093055, 0.1649965894096711, 0.14218230738205273, 0.15884003179208506, 0.1599949466884436, 0.15030468059087487, 0.18194263218818463, 0.06326289212817426, 0.06641836635782661, 0.06217412852157633, 0.13281636072140102, 0.11769964846677017, 0.13957997002179923, 0.13497006107882825, 0.18532256939810843, 0.11872066238074763, 0.9727052594323127, 0.9767625866919009, 0.9767655062892395, 0.9818607044159551, 0.9783634432375958, 0.9784040807597859, 0.9739892207810331, 0.9725210391431417, 0.9725276295299655, 0.13900560680437868, 0.11392383124562999, 0.12246126782292865, 0.1530162348547719, 0.17444150691032023, 0.14528397793839853, 0.10788537558401745, 0.10065571892838487, 0.1334762400095726, 0.16788815190182482, 0.31524232783125583, 0.08752228645386406, 0.15761746998801918, 0.27892291531632496, 0.20802782217391536, 0.1693148308792417, 0.2870817079392788, 0.23283309465078061, 0.18456838649953666, 0.1886601233423233, 0.12270545353727613, 0.06559142709638877, 0.24969482413462474, 0.10766768603827737, 0.1356766662060016, 0.4387762288998366, 0.170907811840327, 0.26495278888066665, 0.14446333691523705, 0.13164166770000285, 0.16745985120671336, 0.1270356700696964, 0.12918104508428352, 0.12828575713342616, 0.12963263217964538, 0.12663747114680046, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09390300259006568, 0.15770668410990707, 0.09226503198295011, 0.03518731404572284, 0.02503879716299029, 0.0399381111031194, 0.08924831341832251, 0.05391528697373449, 0.07124774258943178, 9.999999999998899e-05, 0.01630479999599388, 9.999999999998899e-05, 0.05236833169245925, 0.11307250384087764, 0.07818135954993377, 0.05565304916242364, 0.055860405507046185, 0.05423160052130804, 0.1362412411624382, 0.12058663725793473, 0.1504469046094269, 0.14216485078587904, 0.1753314436839679, 0.12183925278973806, 0.06291258757728158, 0.01781447048184548, 0.018010745745426937, 0.3734838442741729, 0.28706175745552287, 0.43937797454616145, 0.3431607499606947, 0.36074934754103993, 0.3668353172702242, 0.3402154293701999, 0.2473567093460688, 0.24596857282712403, 0.1049708940239108, 0.07147212769342492, 0.0629791392430219, 0.119411730011582, 0.14164054407944549, 0.18148140687586578, 0.08761176859734254, 0.09846498466265208, 0.11042824546490082, 0.1531247933614952, 0.2752077973436886, 0.1581636470003519, 0.1652860235240351, 0.08313199787058789, 0.19182649334163848, 0.1335338473807819, 0.13404861851348526, 0.15311882684448497, 0.25574731732992073, 0.15033499673549378, 0.24899937194192512, 0.19759983945810278, 0.3141449722191473, 0.26265977928717044, 0.30146633135056156, 0.2791243719503077, 0.29366995547483554, 0.16828109013858772, 0.15545200159248507, 0.15682820319107926, 0.1892139850702591, 0.2810980664652418, 0.24308139982997556, 0.32220903369915654, 0.2319394522674163, 0.3292759230156903, 0.22615147831495053, 0.24956365299401895, 0.22906541054181684, 0.20439952322811406, 0.2260433024179963, 0.21006971118291573, 0.21864986114548102, 0.23077986511732484, 0.20045242570041633, 0.21275250038534, 0.17412776707525512, 0.19503973577114364, 0.19074887455756295, 0.2018424359523039, 0.18089306656424464, 0.17974817581123703, 0.19665147019929108, 0.18632692366231896, 0.14699436459516657, 0.13985218910668407, 0.18787334178995263, 0.19588139074235233, 0.18273250464854296, 0.1843874360070793, 0.10534802143059208, 0.1775956022147993, 0.16627216814482726, 0.14176295700289976, 0.13237992351869776, 0.16786786696293798, 0.16748752095146135, 0.1516347121153272, 0.16509274806736152, 0.15337748752252467, 0.13108879420171593, 0.11484816468237713, 0.20647057363360566, 0.18315604727797785, 0.21408015401783764, 0.19387531600460128, 0.20012171090464193, 0.21343280293876254, 0.20379212335053332, 0.1578106471815538, 0.18011215418371518, 0.07727520451230574, 0.08671281670965059, 0.08825142211360504, 0.0791535910557799, 0.07633842254598444, 0.10708204648637731, 0.09172806939434652, 0.10165245267892464, 0.08162856925476314]}, "mutation_prompt": null}
{"id": "a3214f8c-e7f4-4b31-9222-38738760a05c", "solution": "import numpy as np\n\nclass EnhancedDEAMSPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.inertia_weight = 0.9  # New parameter for inertia weight\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            rank_prob = np.argsort(np.argsort(-fitness)) / self.population_size  # Rank-based probability\n            adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance))\n            \n            for i in range(self.population_size):\n                if np.random.rand() < rank_prob[i]:  # Stochastic rank-based selection\n                    idxs = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                    mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                    cross_points = np.random.rand(self.dim) < self.crossover_rate\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n                    trial = np.where(cross_points, mutant, population[i])\n                    trial_fitness = func(trial)\n\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n                        self.successful_mutations.append(adjusted_mutation_factor)\n                        self.successful_trials += 1\n                        if trial_fitness < self.best_fitness:\n                            self.best_fitness = trial_fitness\n                            self.best_solution = trial\n                            if self.budget > 0:\n                                self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            self.inertia_weight = 0.9 - 0.7 * (self.budget / (self.population_size * self.dim))  # Adaptive inertia\n            self.mutation_factor *= self.inertia_weight  # Apply inertia\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMSPlus", "description": "Integrate stochastic rank-based selection and adaptive inertia weight to improve exploration-exploitation balance and accelerate convergence.", "configspace": "", "generation": 71, "fitness": 0.09157334503561011, "feedback": "The algorithm EnhancedDEAMSPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.20.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.08143913318320906, 0.08143913318320906, 0.08143913318320906, 0.14112528373500421, 0.14113539328563673, 0.1411339131174587, 0.12199350618930038, 0.12221471755581914, 0.12218541259980653, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026606077759682045, 0.041805453962620254, 0.041805453962620254, 0.01741109531145324, 0.020119365411008783, 0.01741109531145324, 0.04067841147696505, 0.04744276298981642, 0.03538076641983823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0, 0.0, 0.0, 0.9891201861657286, 0.989120641150315, 0.9891205754765471, 0.9927980269001844, 0.9927980269001844, 0.9927980269001844, 0.983865373817057, 0.983865373817057, 0.983865373817057, 0.04662728321041887, 0.04662728321041887, 0.04662728321041887, 0.008973073780067398, 0.008476969616469487, 0.00854938854691445, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06947226236094628, 0.06947226236094628, 0.06947226236094628, 0.12942782171201483, 0.12942782171201483, 0.12942782171201483, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02347864200927874, 0.02347864200927874, 0.02347864200927874, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03740661505560916, 0.04579333090163051, 0.038105577706926796, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023806462762509528, 0.0160142302192664, 9.999999999998899e-05, 0.0, 0.0, 0.0, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0, 0.0, 0.0, 0.16042654277477597, 0.1604259528336588, 0.15880487622948547, 0.15184487292816995, 0.15184487292816995, 0.15184487292816995, 0.12172649982174444, 0.12172649982174444, 0.12172649982174444, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03224538493495199, 0.03224538493495199, 0.03224538493495199, 0.12247824525453432, 0.12372608860799172, 0.13640445030532355, 0.07654624883477301, 0.07660508023708212, 0.07660881388264329, 0.09919542470662657, 0.12407666316149113, 0.08218497899096688, 0.11309052727257729, 0.11309052727257729, 0.11309052727257729, 0.10696208197741797, 0.11209857773076692, 0.11091825631172814, 0.09205764822443596, 0.09204797767262718, 0.0920494402157066, 0.07089568628061316, 0.07089568628061316, 0.07089568628061316, 0.04400942431736099, 0.04400942431736099, 0.04400942431736099, 0.06503084887101174, 0.06503084887101174, 0.06503084887101174, 0.11468335079600966, 0.11468335079600966, 0.11468335079600966, 0.12871386527526008, 0.11297433484154429, 0.11297433484154429, 0.10197249352498039, 0.10197249352498039, 0.10197249352498039, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1193843384682195, 0.11938708952853994, 0.11938677048408375, 0.16959596283343958, 0.16829805978248136, 0.16894561598939217, 0.10834364245246364, 0.10226348268879559, 0.10745910039967965, 0.11030083676828961, 0.10781881001470506, 0.10790250060746398, 0.1167339417971478, 0.11574801520626965, 0.11574801520626965, 0.14371659537372816, 0.14371659537372816, 0.14371659537372816, 0.17749181080030974, 0.13348930074897214, 0.17749181080030974, 0.1501068761860893, 0.15005583321034444, 0.15005583321034444, 0.1530511485563526, 0.1321672018854262, 0.13677954640839418, 0.013576840397440337, 0.013576840397440337, 0.013576840397440337, 0.00346381488078773, 0.00346381488078773, 0.00346381488078773, 0.012614551035896704, 0.020375879234500793, 0.019936262229298007]}, "mutation_prompt": null}
{"id": "14f3e5c0-2561-4232-bcc0-a47e9a3869b4", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2  # Increase exploration if diversity is low\n\n            # New adaptive population size scaling\n            adaptive_population_size = int(self.population_size * (1 + 0.1 * (fitness_trend - 1.0)))\n            adaptive_population_size = np.clip(adaptive_population_size, 4, self.population_size)\n            population = population[:adaptive_population_size]\n            fitness = fitness[:adaptive_population_size]\n\n            for i in range(adaptive_population_size):\n                idxs = [idx for idx in range(adaptive_population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (adaptive_population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive population size scaling based on the fitness trend to enhance exploration and exploitation balance for faster convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: OverflowError('cannot convert float infinity to integer').", "error": "OverflowError('cannot convert float infinity to integer')", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {}, "mutation_prompt": null}
{"id": "f4137bb7-08bc-420a-bab9-d230a4e9aef9", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1  # New parameter for diversity\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))  # Measure of diversity\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2  # Increase exploration if diversity is low\n\n            # Dynamic adjustment of crossover rate based on diversity\n            dynamic_crossover_rate = self.crossover_rate * (1 + 0.5 * (self.diversity_threshold - population_dispersion) / self.diversity_threshold)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce a dynamic adaptation of the crossover rate based on diversity to balance exploration and exploitation for enhanced convergence.", "configspace": "", "generation": 73, "fitness": 0.2258471115298658, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.4748594760547762, 0.4944325979849199, 0.4094445961134511, 0.42137239207569377, 0.3860933650874291, 0.4178728403728308, 0.5158311817183756, 0.4355165657535045, 0.4162318431556271, 0.3272439478172121, 0.2823636657210049, 0.34459330105844843, 0.28042574033399614, 0.256374742023013, 0.21113924273982232, 0.20205815336601807, 0.26101923912695635, 0.25081231942594095, 0.19169367357727574, 0.18663326215387477, 0.15329952768583222, 0.15506592558974208, 0.3254124550233015, 0.2792291752796804, 0.25832378177394866, 0.1877503138220562, 0.2582215692782417, 0.275907189570349, 0.1803321152345645, 0.2500255174644618, 0.23445803949427713, 0.17152352951095073, 0.16475555485034854, 0.3395856009310714, 0.2451021287878976, 0.2658965993132105, 0.9713894264258185, 0.9713997221105284, 0.971398105242212, 0.9838725130673857, 0.9829280389425146, 0.9829440236514725, 0.9910381148394165, 0.9910395468286322, 0.9910393416163193, 0.13826953657734742, 0.13876253666906302, 0.16125379757742486, 0.16541919743605993, 0.20303476726490777, 0.17265915474869342, 0.20825071430990938, 0.11249070609830136, 0.09395192703003319, 0.1504335146690743, 0.19215471736899525, 0.15996266092230704, 0.18938900196631336, 0.2659638207027599, 0.24791850164247498, 0.18880644588912399, 0.21280375794585749, 0.21745335329584858, 0.23603203277823437, 0.2182783349169104, 0.1986512071912524, 0.2490883349899572, 0.1961767211610288, 0.221824354452974, 0.28232242574974553, 0.3039699202633527, 0.28629828596710105, 0.13666045442865848, 0.14010789181767414, 0.1540991173666897, 0.21181682675888824, 0.14636484028205976, 0.13970195756676163, 0.1324605381109868, 0.17634847081133576, 0.20529712187370774, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05685507420136038, 0.054548197457792935, 0.046424219826804114, 0.03163831631923475, 0.031608550618241305, 0.024396646310572367, 0.07867618503820062, 0.0586658773916553, 0.068759813525197, 0.005296022678897838, 0.031243699590909224, 0.059927999375717134, 0.06357211822163933, 0.009830327586247245, 0.0067336293845498, 0.019179229399236775, 0.03679208813038748, 0.02128802070793223, 0.09524052790965543, 0.08719436271592718, 0.11688114614422429, 0.12534333367222938, 0.12969607803253602, 0.1219794314257222, 0.11459129637964438, 0.12450121775171241, 0.10442300771521418, 0.40421692736748693, 0.5152850251935182, 0.4570584100955788, 0.4866137020314114, 0.4431081994916236, 0.4551415359499291, 0.4152003405914997, 0.45684430554838096, 0.49754538425276273, 0.12265220434753754, 0.09512513266926015, 0.13345204208648642, 0.10926544886950673, 0.0691782391141551, 0.0806326021180499, 0.08005211005335511, 0.11576467070596064, 0.10962318802153936, 0.15349407911975255, 0.20636750890409483, 0.17403830613659943, 0.16904834549657421, 0.16328409457048565, 0.15346138103736973, 0.17799600338977906, 0.21491484793661242, 0.14738983930733507, 0.20924274381094687, 0.2307016512098652, 0.2455836774583826, 0.21556919852001954, 0.22399298814252544, 0.2267773389041965, 0.2693308290662949, 0.2605293690787537, 0.22940036763661087, 0.18336468364840008, 0.1308591119179775, 0.14890356687118478, 0.15699196443825092, 0.22985637044399632, 0.1568258259830101, 0.15167337159537708, 0.20970211120443827, 0.16900924973424392, 0.1923992897122554, 0.22185582587832664, 0.18685614968220876, 0.22659878969653136, 0.21688504930755248, 0.19642506161817597, 0.1776956078048768, 0.19262195413698147, 0.21409923157626398, 0.22752654931180982, 0.31609405728241635, 0.328027686374291, 0.30101375820718135, 0.29212097586027497, 0.24896326230633326, 0.2351815785783109, 0.23784485190831584, 0.24548336913416835, 0.3711607294775615, 0.3495327883251923, 0.3393970405217498, 0.33107782978504796, 0.1966261380789368, 0.1922707552611057, 0.2037001005135517, 0.20313900932794893, 0.1954631783927634, 0.209790934518569, 0.19131497592564506, 0.17868391347322654, 0.1861473363229741, 0.1834896052945869, 0.1587081845398507, 0.15460708605670714, 0.15648882862032298, 0.1550434263392999, 0.17761369219178635, 0.1835568717136633, 0.19755556191234758, 0.19437205509250355, 0.18807728526258505, 0.19512536178748174, 0.1795098838221686, 0.18534111008117982, 0.1820850385920204, 0.08374781374487761, 0.06995395944743554, 0.08423615445751453, 0.07861926316461398, 0.07608388431152235, 0.08217531895720587, 0.06864215539443907, 0.07857925774918528, 0.07968485143838844]}, "mutation_prompt": null}
{"id": "207cba6f-5efc-425c-96c0-946716e6211b", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if self.successful_trials > 5:  # Start dynamic learning rate adjustment after some successful trials\n                self.learning_rate *= 1.05  # Slightly increase learning rate if success persists\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce a success-driven adaptive learning rate to dynamically adjust the mutation factor based on recent improvements.", "configspace": "", "generation": 74, "fitness": 0.1583658821955457, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.33760422950893554, 0.28213077331325076, 0.3566633452827157, 0.27874993541495297, 0.2675822916195997, 0.48486440637246075, 0.2925937290665831, 0.27279358407999543, 0.403794532821525, 0.19525447600321577, 9.999999999998899e-05, 0.028510246586216037, 0.04935772565712837, 0.07095139668681061, 0.11230731495642354, 0.017803271354650874, 0.059919663935027345, 9.999999999998899e-05, 0.1037826679982341, 0.14013883654181847, 0.0529408692469584, 0.11235460226454486, 0.07721706674535722, 0.09305058862234672, 0.06833621526835776, 0.07823672681253813, 0.09301890892353881, 0.07044810098730014, 0.0349231831148068, 0.11693157285171474, 0.07414845385621194, 0.06434023854691873, 0.08639568499252492, 0.06393344799705536, 0.06883985107595403, 0.08123480605008704, 0.9763806389052151, 0.9756125165512439, 0.9756273399001999, 0.9559709012171114, 0.9567178862633782, 0.956731131168593, 0.9865821224947126, 0.9865831529723937, 0.9865830045536736, 0.07421002339047877, 0.10508182467698679, 0.12328687908540359, 0.1510497725053388, 0.07302096730383545, 0.10691094424194325, 0.1136744566102239, 0.15386144149119407, 0.15407606636735982, 0.1656482876593356, 0.15701197715400395, 0.13082521715731454, 0.13003079896601777, 0.16903249144505517, 0.13713185728049315, 0.10220183846352793, 0.12109244839834721, 0.12401799949494474, 0.07095765369270157, 0.0926621609324666, 0.016848913546324562, 0.10111222599548797, 0.14096358157493283, 0.14218329350044545, 0.10268573611958487, 0.16500188282476647, 0.1087835389147862, 0.08828534005175204, 0.0925748831904104, 0.0954266289586645, 0.13845869076630335, 0.11147653727144191, 0.11064525549099435, 0.09115873401019614, 0.1086062857881599, 0.10967759187359005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10003410681278146, 0.06924585426090235, 0.0668700178461088, 0.012792069619668278, 0.02773871767761571, 0.02520432481381718, 0.039020449180065975, 0.09153785195661568, 0.04562530092328454, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030424462259042273, 0.02803732762527289, 0.0742382571092256, 0.05229900050121561, 0.03273537653748004, 0.009198361005919087, 0.031832716394356586, 0.048357133769164284, 0.26187163846759665, 0.30334577942094065, 0.27927051688013715, 0.29813562634977675, 0.3008454662510074, 0.28012077217890496, 0.23437857363162184, 0.3947011270464903, 0.31063575805634813, 0.05606579369190601, 0.054822902911961124, 0.04713300790708019, 0.047824422508734865, 0.04717024526943536, 0.07203182934075325, 0.06015218942980882, 0.07695864442217881, 0.06410978390139122, 0.28548388729827423, 0.12014903465262283, 0.11258827829390305, 0.14427641198587282, 0.1256663188755378, 0.135524132067405, 0.14761153226434942, 0.12147290768854835, 0.12062106601666578, 0.15317085870037594, 0.14758288354614635, 0.16778669025331006, 0.16916291888446067, 0.22614064843101045, 0.13497009871493226, 0.21534223710915057, 0.18629606967686407, 0.22381399753007925, 0.12840262988646223, 0.13300969661626183, 0.17859478416869645, 0.08639499922531302, 0.14573916026537392, 0.10573566275283552, 0.15606738511869533, 0.15569323177669847, 0.16657086537977173, 0.16860160912492606, 0.1581600393921797, 0.17461480911439142, 0.1496893188490085, 0.13099440623284386, 0.14851357163890355, 0.1773155738241463, 0.1444614518594235, 0.1581449397501521, 0.1655994071015945, 0.21807372078091714, 0.2129942431327122, 0.16484036813994063, 0.17203301223211853, 0.1426736470552914, 0.18994676588095494, 0.1699211773606315, 0.1694323619365694, 0.2736425521632797, 0.19782511072457487, 0.20557890286158265, 0.16396790529928917, 0.18145281908012179, 0.18165306499434264, 0.12193578776740577, 0.11143273724039604, 0.11255146500025726, 0.16731659080211936, 0.163690182885462, 0.17117773311235196, 0.16914033979555276, 0.2073317946724368, 0.20600864196904412, 0.15279697604142128, 0.11769128157372977, 0.15279863665318538, 0.20480542847343675, 0.171731141082758, 0.1585621473257528, 0.17527220188756165, 0.16468509317957036, 0.16467988305876846, 0.17034043041480784, 0.16255726915534052, 0.1757028847127734, 0.06656438658532549, 0.056811347762117825, 0.06683927136765144, 0.0570626217977479, 0.05529238243590773, 0.029435653427471564, 0.060196096118092624, 0.05174745559143035, 0.04239245590277174]}, "mutation_prompt": null}
{"id": "5dfe7cfb-f56f-43d1-a68b-924ce9e2c137", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            new_population = np.copy(population)\n            new_fitness = np.copy(fitness)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            elitism_index = np.argmin(fitness)\n            new_population[np.argmax(new_fitness)] = population[elitism_index]\n            new_fitness[np.argmax(new_fitness)] = fitness[elitism_index]\n\n            population = new_population\n            fitness = new_fitness\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduced elitism by retaining the best solution in each generation to enhance convergence speed.", "configspace": "", "generation": 75, "fitness": 0.1248554084634617, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.21345416206643308, 0.1359355854200055, 0.18857361386962368, 0.3393962664522514, 0.22062548184253372, 0.22392170188749883, 0.12261777637973281, 0.12234567427101051, 0.12240250932177565, 0.06164798143304473, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07869539578798557, 0.05514426556763463, 0.10514945191734171, 0.06518993679031249, 0.1320224813313976, 0.03144386867916804, 0.07374573593963762, 0.07692029051063398, 0.0804805912416563, 0.004600434953172972, 0.005329212892168145, 0.007757295864283309, 0.09777144195018572, 0.1238406743996362, 0.05379674749630847, 0.09057856343674497, 0.04189115326279258, 0.10452792945353306, 0.9783100481673195, 0.9779087952398616, 0.977931354787129, 0.9709655242238336, 0.9705073851169317, 0.9703084624756815, 0.9787717807959826, 0.9723322800252336, 0.9723375234526596, 0.03606720183834655, 0.03608059693742416, 0.03608083701159526, 0.10676151550918689, 0.11865785273821383, 0.062038794527205066, 0.08527602872336337, 0.06203597977598818, 0.08065176186429768, 0.031252925517691654, 0.05195355517969924, 0.18451064764995995, 0.12315618687587537, 0.1561754841738402, 0.1561754841738402, 0.05424048505966639, 0.14893226325017517, 0.12991627809327588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03881761462273259, 0.009419382750149419, 0.0071596194521598155, 0.034110882118462915, 0.10856886629045126, 0.11765760417452731, 0.07293271663560286, 0.07852594439103922, 0.109797131629644, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1259455396280571, 9.999999999998899e-05, 0.04320589458330337, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009480169592699927, 0.011171182822232173, 0.01669757880895817, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027773909303537403, 9.999999999998899e-05, 9.999999999998899e-05, 0.04941576453968122, 0.009905706717623475, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.27394718566323806, 0.32014586884913443, 0.33636835581441915, 0.1832939740541225, 0.1483927951104933, 0.1483775649568717, 0.28496417766522975, 0.3055030572675945, 0.27008469192669204, 0.025325710082569786, 0.058689963678706936, 0.09799654755763898, 0.05424616149985195, 0.06324374508248942, 0.08760814047120369, 0.04468064900370172, 0.04869508441883208, 0.04841856065772243, 0.1571994009747938, 0.11116426941139523, 0.12168232263316203, 0.1188052727998975, 0.10701543153112159, 0.10497577562511995, 0.09192290300784733, 0.07521392839475416, 0.07521392839475416, 0.12042204571342752, 0.132565156010512, 0.132565156010512, 0.1759977410108624, 0.12701702686565675, 0.13326873503262282, 0.15883068569102265, 0.22188659305344638, 0.22419067808470206, 0.11273418329792562, 0.07082187982104349, 0.06442557328943388, 0.14402473814977002, 0.0884079366732693, 0.1002885122549777, 0.10668282446525323, 0.1181776766112127, 0.11849810231778302, 0.16282765434000923, 0.1273578491101376, 0.13935404057900092, 0.12933352082177352, 0.09874809212123525, 0.17558085477026886, 0.17419059518525026, 0.1619569551051645, 0.14509592207146738, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1879067707263522, 0.18391953126748117, 0.16008290655210822, 9.999999999998899e-05, 0.18345192107425023, 0.18236436004201817, 0.1448596627869574, 0.21652072829814972, 0.1682687984115786, 0.15669020113758236, 0.15299999975341472, 0.15372670025787516, 0.10834364245246364, 0.11822711457124646, 0.10745910039967965, 0.1694195847759956, 0.16795518641429386, 0.16761120326725376, 0.09455280587317705, 0.11792935130063165, 0.11792935130063165, 0.16603647404590305, 0.10808516664164358, 0.10811894569598657, 0.13868943679785484, 0.13147032148329385, 0.1650020423948132, 0.14048760128846716, 0.1944595768322206, 0.14747204139180525, 0.15713327541766908, 0.1543692326463051, 0.1315279483042041, 0.08715250142604636, 0.03944689766087173, 0.03556731329157414, 0.06015988903774705, 0.0692701462128773, 0.03707691587103268, 0.01888834985253396, 0.0720310319797014, 0.03304923851729158]}, "mutation_prompt": null}
{"id": "d94a575c-3390-45d9-b255-61396aa645ea", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)  # Dynamic adjustment\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce a dynamic adjustment to mutation factor based on cumulative success rate to improve solution quality.", "configspace": "", "generation": 76, "fitness": 0.3280343869300537, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "ebcb119c-7c9a-43ee-9034-26560c568ca0", "metadata": {"aucs": [0.8658167619417423, 0.867968541952731, 0.8701137941837738, 0.8688120022155796, 0.87145687604336, 0.8534644674620718, 0.8414297904670729, 0.8886501147280358, 0.8669536123347121, 0.7802304217417049, 0.7334901605717844, 0.7551170030949074, 0.7529064530805211, 0.7824617135189391, 0.7854495484197552, 0.7501760545806038, 0.7408235665456131, 0.7635050664219807, 0.12594671855564032, 0.12234913842542738, 0.1580039159342348, 0.70685506274667, 0.13604303493102865, 0.1453120545067803, 0.15299949928036582, 0.26802926455749254, 0.21779267154392923, 0.053100935359556733, 0.09952099121979263, 0.09292277857029052, 0.15305606916569525, 0.1657860832891802, 0.12245707991066723, 0.18201225115242614, 0.6321062297557039, 0.15014375067599162, 0.9763746134748085, 0.9755945652504145, 0.9756052859727075, 0.9465189542444267, 0.9591400410181143, 0.9607073075923113, 0.9865821223915728, 0.9865831528706189, 0.986583004451702, 0.6076210793564727, 0.5863663329832267, 0.5904669659099104, 0.7023303978449649, 0.6069525669414779, 0.630802689788288, 0.633625605552198, 0.5999228688059586, 0.6615434545397558, 0.3630402240372216, 0.1696185004805546, 0.2130511203516413, 0.16172950265809982, 0.22829124446120064, 0.2124647427359111, 0.8017810092925293, 0.344546766688932, 0.6808792016102987, 0.43553634341489245, 0.4098460937874425, 0.4013650136935719, 0.36726915057474807, 0.13466654441596726, 0.39244615697438057, 0.13244153776505863, 0.29201754878005026, 0.6679995787635138, 0.3770866576163864, 0.3349437017830146, 0.4423574856421628, 0.5275524290761973, 0.4583999633633571, 0.4655422092524867, 0.4093429432550555, 0.5637840845901688, 0.4130474294851464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1758340012064311, 0.1766253461610895, 0.20174881969667735, 0.024073926175364968, 0.05522579657853621, 0.02318465033129835, 0.07460929804413641, 0.08953724741639235, 0.07829306451588491, 0.06602800503390549, 0.08298035838894124, 0.028279144226737496, 0.037481901565315834, 0.021492619756440345, 0.07050696650345456, 0.008513439423214586, 0.059453351854060754, 0.02609453965771058, 0.2796307770379294, 0.21499236398853427, 0.216549574306919, 0.3116733076790549, 0.22512593002189396, 0.2154655614035459, 0.05749771428830608, 0.29313801812180573, 0.3291144262144742, 0.627838655695782, 0.5935742358502504, 0.6517659221747092, 0.6075356701776825, 0.6079023032032946, 0.6175352548380244, 0.5568671573804909, 0.7675654089834433, 0.5771016709333034, 0.14232711787163244, 0.1459202946063628, 0.1323248427313769, 0.11645887429053603, 0.16735021746740553, 0.13552534707167285, 0.131533750442013, 0.11773085516711324, 0.10583403916495848, 0.13049370421924378, 0.1299884604391155, 0.1268796195465216, 0.28111251972662643, 0.1741438715248922, 0.20373810827958883, 0.21542347610959256, 0.11398122988625514, 0.11538830772578457, 0.27579465685135074, 0.1739647004724738, 0.14476467966471207, 0.2770067965997872, 0.38699487997507354, 0.29793001841448974, 0.24887430707079639, 0.3434541950568709, 0.3862673258472141, 0.2516813849936128, 0.24733108839763107, 0.18096319708993847, 0.2956671345506173, 0.26890227448602677, 0.24612846698555557, 0.167524309347292, 0.2938092382507608, 0.1710279574779121, 0.23133726112530784, 0.22670363972302776, 0.24989435304508678, 0.2174533016709368, 0.2743272495003556, 0.21491667617898436, 0.19982073172970205, 0.23222777609086465, 0.20089074563204123, 0.19058318001991426, 0.18719961570067611, 0.19577012712111397, 0.21591480962179277, 0.22334328108333834, 0.7954591480957566, 0.1986448373133911, 0.17897287209015356, 0.727251723207991, 0.21126410856889144, 0.7933947304250162, 0.15353821169714443, 0.1984295262050424, 0.25248434473758374, 0.25359830712823017, 0.11332931992156425, 0.113284313223046, 0.11330416442103974, 0.1693722516733609, 0.12689600161795078, 0.2064661200756316, 0.21311392035370025, 0.21166923271811122, 0.212335631006081, 0.21073997707292946, 0.15446474764673535, 0.19823908263440293, 0.18623870131082654, 0.19527137946826711, 0.20928054991421574, 0.1466856697036919, 0.18937417386199384, 0.18976888048229634, 0.22216717717179846, 0.19611396456820207, 0.15007813394767278, 0.08663379469916677, 0.10682464022986582, 0.10727449248627796, 0.08225075263826098, 0.08126992494382468, 0.09905264249798984, 0.0818123352705652, 0.0837082748503919, 0.08137741970686241]}, "mutation_prompt": null}
{"id": "18813739-58a5-4b7e-bb1d-f3019e70d0c4", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)  # Dynamic adjustment\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            recent_improvement = np.mean(fitness) - np.median(fitness)\n            dynamic_crossover_rate = self.crossover_rate * (1 + 0.1 * np.sign(recent_improvement))\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Implement a feedback mechanism to dynamically adjust the crossover rate based on recent improvement trends for enhanced convergence.", "configspace": "", "generation": 77, "fitness": 0.27198866241549213, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8879507514485234, 0.8122895437938673, 0.8588623064342134, 0.8781071564731702, 0.8063829483546601, 0.86364132394804, 0.23107808439621313, 0.23050949554624478, 0.23063333006900266, 0.7278202459353784, 0.7279123077244675, 0.7403942326513544, 0.71083676091469, 0.7580367798646934, 0.719552036225779, 0.794029212276481, 0.6958580755753745, 0.7502792956141544, 0.16896799310928523, 0.08601085447783696, 0.13733642065270635, 0.1583112399342046, 0.12217287942464905, 0.09456695315781394, 0.17475946229353845, 0.7449549872816299, 0.18015952461823492, 0.17775127265747703, 0.08933667917813104, 0.10914569346915015, 0.1584748049647584, 0.1212989953490411, 0.17428412056060605, 0.04173558951651102, 0.0267989023165488, 0.03196040088873231, 0.9466728473048828, 0.9564874280591538, 0.10159182320862492, 0.9730696114872661, 0.9816479198614538, 0.9816486374275568, 0.10552849702955047, 0.10365580358794191, 0.9549437076445104, 0.45026277561327244, 0.5149745860932269, 0.6365315426813577, 0.5197503814895383, 0.5752634862834451, 0.582243432883512, 0.08552904906940328, 9.999999999998899e-05, 9.999999999998899e-05, 0.22722731719173417, 0.25166262674629447, 0.13900250559955551, 0.18023966987231088, 0.20720317641968222, 0.21047717296865254, 0.2300926265979084, 0.22497757003884766, 0.026221750830517365, 0.13306442032404942, 0.30787706510638313, 0.6811219423212413, 0.5607540895361433, 0.11849688990664853, 0.13107024416046353, 0.4445601426944874, 0.1291321945379612, 0.408226025548037, 0.051170563696376514, 0.43073308507726416, 0.13029922990706944, 0.13234796415551686, 0.23013014605236726, 0.34717449964655356, 0.5765992081908629, 0.1346200733706011, 0.13332148775208919, 0.15189578533558556, 0.04404304878817489, 0.12309858054269518, 0.012236224139445584, 0.08629005308988469, 0.03304756503618422, 9.999999999998899e-05, 0.14655563249822334, 0.06748298320898471, 0.09796792782440755, 0.19039067438445545, 0.28478169865211544, 0.2950174962506471, 0.1387962361133428, 0.1640466198502687, 0.260590242178408, 0.18058187613774968, 0.16888025903397685, 9.999999999998899e-05, 0.1359303060539263, 0.11840622621281405, 0.1237006041124128, 0.1114259945579279, 0.10515077849968746, 0.15232866426720415, 0.10087160188537236, 0.1254903150778418, 0.1403630041943501, 0.2546751150217196, 9.999999999998899e-05, 0.2929992835837919, 0.0385336402239973, 0.28445409135908406, 0.3296616360867487, 0.25554123176951804, 0.20926422126140276, 0.5531444147262985, 0.6200943633498074, 0.6474185030152089, 0.5984224631162798, 0.6166982332943256, 0.6000705966146529, 0.5905576605673383, 0.6450725777713198, 0.630581426757536, 0.07703325726066246, 0.11690996137808685, 0.07395393280257812, 0.0923444489424099, 0.14073609673843623, 0.0952188454172328, 0.07935833598279529, 0.11383876972229989, 0.11181583156169694, 0.1340784688363854, 0.18495981180249987, 0.15221676982321042, 0.17896615974718022, 0.1452486878013588, 0.10345181368031553, 0.16353115023112297, 0.20386508351119403, 0.3095430374669986, 0.13694787893527338, 0.29246175630400495, 0.1559070579519315, 0.3915889933827229, 0.147705161554048, 0.1617655202042766, 0.2876335725460012, 0.3282746832769139, 0.2370252312777924, 0.07214808221634028, 0.19949985094470635, 0.1784624516723914, 0.10007089188154095, 0.14122747594196494, 0.2824321718658017, 0.21624258324478507, 0.16077037868660538, 0.2054823577676118, 0.2432321417500739, 0.26575159626572975, 0.1908122595609575, 0.18459880724619115, 0.18941182814185342, 0.1826571895806387, 0.19096526273140813, 0.2580964207516645, 0.21016961545803547, 0.20295742632153402, 0.19990123809108062, 0.20788531176641645, 0.24845705722938505, 0.19203896279756372, 0.22713670650886464, 0.2097434458214802, 0.22804108957290525, 0.2509762745257408, 0.9327495738046944, 0.21049685247655403, 0.2864064232398694, 0.17587096561923643, 0.17679082349505948, 0.17797986847093783, 0.17281462035440875, 0.12220138122676505, 0.15008597208614538, 0.16904002609646884, 0.16608997600670805, 0.16766588750323297, 0.20919547052290222, 0.12753585716376037, 0.12797799502992036, 0.14434968358079536, 0.15725868264225318, 0.1560316115923408, 0.16732919141837288, 0.2214667767363776, 0.26491259637893705, 0.1500970465010243, 0.1758875767828546, 0.16879519048056713, 0.25456297257050875, 0.20827051137855124, 0.2199386507113511, 0.10031705702200111, 0.10804121502951602, 0.10677747550156402, 0.09564362234133572, 0.10568376641413868, 0.08630577337870493, 0.09236245579144264, 0.06512007487931859, 0.07508252551838046]}, "mutation_prompt": null}
{"id": "e09beb17-c492-44dc-9264-0e05a2550e7e", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)  # Dynamic adjustment\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.15  # Slightly reduced boost to avoid overshooting\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1.05 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-0.9 * adaptive_step_size, adaptive_step_size)  # Adjusted range for more exploration\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive scaling factor adjustment and dynamic local search intensification to enhance convergence speed.", "configspace": "", "generation": 78, "fitness": 0.27956972008908537, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8516951334808714, 0.8221113325944203, 0.8779444281613116, 0.8632848156882543, 0.8876919037016283, 0.8548568665850617, 0.21150294505168832, 0.23618770828645996, 0.2378314133602999, 0.7182383327548583, 0.7742334511896709, 0.8089227833800212, 0.7844747276396786, 0.774495183122409, 0.767595375130172, 0.7722802637365005, 0.7820294617293864, 0.7991794541193464, 0.13046230726574304, 0.14774002751135618, 0.1581487893609025, 0.16785822200578293, 0.7291584097585173, 0.15564370722873677, 0.21079985587914019, 0.15795385566922482, 0.2429134163458191, 0.04253433315098443, 0.03064300864807723, 0.0943102501532509, 0.15456885095814799, 0.1559638880971439, 0.17736280464871035, 0.17700638509370614, 0.22526193139757267, 0.23855333965444425, 0.975991317250314, 0.9759962850864196, 0.9759955612869011, 0.9710391800688118, 0.9772029542794615, 0.9656998420749403, 0.9749808848093222, 0.9775689236204426, 0.9775693607803542, 0.5826770962207396, 0.45355632338661056, 0.5141452167335581, 0.16018600985740572, 0.5137834463613011, 0.5989553250236554, 0.42840258352203653, 0.5159346238632566, 0.4714234723474269, 0.22318385636787585, 0.1712256691718359, 0.17473622855636606, 0.37092820740124866, 0.19070298704280875, 0.26782497468180166, 0.35314792111813587, 0.2223364287064673, 0.222975797203938, 0.24673700028974277, 0.23094548210866161, 0.20396384219894326, 0.2832065711844026, 0.13361502970867967, 0.2036830801153069, 0.635838681719683, 0.6798085856370264, 0.48456534292423226, 0.21335012338497417, 0.25343069900289306, 0.22835670381485818, 0.27282582001858113, 0.2155484035305859, 0.24975506069256048, 0.24358811491053833, 0.22914254486376107, 0.1316123664066967, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14315602543126227, 0.08818476988135049, 0.2428109956296668, 0.026365314702513576, 0.05952763369566616, 0.01772929359038866, 0.05178505740442596, 0.07851747232530781, 0.11814251173897394, 0.04875716077790626, 0.024170026647885035, 0.0053820339975809706, 0.0071092787803325175, 9.999999999998899e-05, 0.03088671060192627, 0.12072490716489226, 0.026918344479516243, 0.013481774669173552, 0.23023790336841765, 0.2956621327031612, 0.2735563797155559, 0.21164023119241415, 0.1546044779552449, 0.11828317084686857, 0.0307694035755951, 0.25539229509980177, 0.11390015604522763, 0.5219266570370773, 0.5857088092943304, 0.5498362305788775, 0.5031959765551828, 0.21262402604581454, 0.19341174210821066, 0.5630413138268863, 0.5634939875775136, 0.5427581989195962, 0.11110696364880457, 0.1253620898697163, 0.11726047075305246, 0.1318773686568815, 0.11929282307816669, 0.12673687928120525, 0.15215747264001767, 0.1418618522498606, 0.07986502742063617, 0.09825737902529874, 0.16749184876225842, 0.1493349813156699, 0.21148656376474173, 0.15448905062542728, 0.15455529762136266, 0.12844262664758133, 0.11005159509871987, 0.21024334692038327, 0.25320058455603234, 0.17272773523929608, 0.1464970881861013, 0.24579194360289558, 0.27147523729429335, 0.32518836369448123, 0.22968422835238267, 0.25642713774340586, 0.24390259802573833, 0.1453136652216359, 0.10739434894392397, 0.19022440458141066, 0.24187740636307342, 0.23085550019951828, 0.2404815108617102, 0.20639151626701246, 0.2764534296336868, 0.14892257384002316, 0.18775900428783376, 0.21159923288181415, 0.16766034984389733, 0.2297058315165008, 0.15175097230468926, 0.22181233435610437, 0.20740200504868, 0.19561256971053997, 0.19995071380479945, 0.20693044039773445, 0.17733989492756008, 0.19838553112319235, 0.17899117045708257, 0.18701076046490128, 0.23212213242837787, 0.22656840036866166, 0.20561773814763107, 0.19802646389388678, 0.16585184617820214, 0.1892208121989012, 0.18921957799980316, 0.26604621429424213, 0.23980873606574438, 0.24757156803874236, 0.11333087117251905, 0.11316895559025997, 0.113286697188685, 0.16865384357167135, 0.16944661559700458, 0.16993984274749785, 0.16983216867598694, 0.7419845824033096, 0.6743696702706568, 0.21061020479820658, 0.15427307142459157, 0.19589637582614128, 0.15950564227907382, 0.20753095720413528, 0.1777783938788049, 0.18575337499314049, 0.18377219413202917, 0.18901518498454073, 0.17621343316456384, 0.1854437627069203, 0.20636894663085603, 0.09365325504044975, 0.10206084447222752, 0.0925671435046328, 0.09974756947776409, 0.08697485253479642, 0.08965097357567575, 0.08280822801310328, 0.08902006748897551, 0.08547930932888981]}, "mutation_prompt": null}
{"id": "621daf6f-deec-41d1-92f1-63cdd42af281", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.15  # Modified from 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Enhanced mutation strategy by dynamically adjusting the mutation factor based on a modified learning rate considering population dispersion.", "configspace": "", "generation": 79, "fitness": 0.317777175367409, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8671957739408809, 0.8714322880470224, 0.8670568001503517, 0.8577930468989877, 0.8789084173539697, 0.8609289896774819, 0.8600492737176277, 0.8859176472688272, 0.8770342417438586, 0.7510480619089921, 0.7694552067238284, 0.7883155249173732, 0.7923186746885313, 0.8313919099744613, 0.8061985943045353, 0.737430199006307, 0.7751328413730147, 0.7711096409601401, 0.12594671855564032, 0.125900786127788, 0.15100142901368796, 0.686222598958588, 0.14486741663581992, 0.1457033266445067, 0.15035199482994688, 0.22319038312828354, 0.18014953224629426, 0.053100935359556733, 0.09902958823326224, 0.1025598274714794, 0.15326276315839205, 0.17126589875120057, 0.12245707991066723, 0.29777057435154497, 0.6376279793431976, 0.15002851471982104, 0.9763746134748085, 0.9755945652504145, 0.9756052859727075, 0.9454880633984019, 0.9469543297036768, 0.9539895845274107, 0.9865821223915728, 0.9865831528706189, 0.986583004451702, 0.6356775697814598, 0.6369510462221843, 0.6031636663299954, 0.5493636056813342, 0.5843955188022609, 0.658396764223802, 0.7073042491906314, 0.5656970659557566, 0.6537187679810978, 0.3182704765172829, 0.1696185004805546, 0.2130511203516413, 0.16172950265809982, 0.24718193555909485, 0.21246225718772271, 0.3667744705525523, 0.3053933868452724, 0.30904475529663744, 0.2791804647732816, 0.5525537836585863, 0.5500849804457464, 0.3519787235187424, 0.28006206250224774, 0.28452876161527674, 0.13226682377748145, 0.3193590135354957, 0.7669026132081705, 0.2255843858366271, 0.23977753740215269, 0.200871952068149, 0.4312154962480437, 0.4637911668735254, 0.2295934076615579, 0.3279424558167823, 0.3040452707639332, 0.3357520756148309, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16992288587615256, 0.16586833056427608, 0.19771453805538686, 0.024073926175364968, 0.05522579657853621, 0.02318465033129835, 0.07435656155101167, 0.08953724741639235, 0.07829306451588491, 0.0684993696532068, 0.08437514139424551, 0.02839644449977874, 0.03725723579527307, 0.021492619756440345, 0.060791662448204664, 0.008513439423214586, 0.059453351854060754, 0.02609453965771058, 0.22668513367213705, 0.21729124288321022, 0.2729057605440597, 0.2221080638793992, 0.2889540271331271, 0.29785842263842977, 0.05778082257202988, 0.23974456828839752, 0.22938614301251103, 0.6341444182823686, 0.5504425039988723, 0.6738131366294876, 0.6969012596160715, 0.6414240012586312, 0.5461028524307994, 0.5526428973172357, 0.6553791555552204, 0.5535977278514153, 0.1422544807570464, 0.145689351715396, 0.13169155597131976, 0.11574146130483498, 0.1675329592419017, 0.13552551903599974, 0.1314425642448106, 0.1175924607781863, 0.10609826711997539, 0.13049370421924378, 0.1299884604391155, 0.1268796195465216, 0.2588675691650707, 0.14889317162493354, 0.1587951818702541, 0.19609052205819288, 0.11398122988625514, 0.11538830772578457, 0.30113782636409325, 0.1739517704613177, 0.1424664788802522, 0.24623547503359866, 0.31061150368212, 0.3277609444754057, 0.25256284107531435, 0.321673912445991, 0.3848878276124511, 0.2383229876009344, 0.1922894561318097, 0.16552032417936624, 0.30588896997074777, 0.3103115109412694, 0.24727120893608567, 0.16815983837542758, 0.1706561577634912, 0.1710060621230337, 0.24833022811016503, 0.2254555851378338, 0.2506686131095497, 0.21779114359609775, 0.2729277838810845, 0.2146659760728008, 0.20011624441395603, 0.2319649463135518, 0.20088313247470313, 0.20009049928910738, 0.18713431138460845, 0.19574519054211237, 0.21591480962179277, 0.22340187237717546, 0.7742437908798729, 0.19874247530634348, 0.17897287209015356, 0.6995836724646999, 0.21124603630420302, 0.7803570323785883, 0.1535414700878488, 0.1984295262050424, 0.25248434473758374, 0.25359830712823017, 0.11333350053615232, 0.11328335834990377, 0.11329428299422395, 0.16935707848856396, 0.12692048887358431, 0.2064661200756316, 0.21309859891161342, 0.21172830793881725, 0.21232185226997224, 0.21073089256329203, 0.1544476386423166, 0.19669345764604107, 0.18623870131082654, 0.19527121894621846, 0.20946883729963894, 0.1466856697036919, 0.18937417386199384, 0.19433070245029238, 0.22209600213200187, 0.19813651953279676, 0.15007813394767278, 0.08660492838896572, 0.10628434329545822, 0.10726225432715908, 0.08175244426821426, 0.08133332483627942, 0.0986101091496534, 0.0818123352705652, 0.0837082748503919, 0.08148720164871992]}, "mutation_prompt": null}
{"id": "c0a01afb-284d-4628-a2c6-147da2f687a3", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)  # Dynamic adjustment\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                fitness_gradient = abs(func(current_solution) - current_fitness)\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate) / (1 + fitness_gradient)  # Adjust based on fitness gradient\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive local search step size tuned by fitness gradient to enhance convergence speed.", "configspace": "", "generation": 80, "fitness": 0.30491795500100344, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8284789105198125, 0.8319180882638032, 0.8367546223566688, 0.8325146521565505, 0.8274494734679285, 0.8032800547845012, 0.796348044244338, 0.863131474079541, 0.8252304471465519, 0.7099142746245408, 0.6647877597212727, 0.6724166537621277, 0.6713825623556138, 0.7171630873737164, 0.7177265716104052, 0.6612938999712218, 0.6520919748460563, 0.6919255292133923, 0.12513899762815017, 0.12160055941017689, 0.15670324564884408, 0.6344618796136379, 0.13475813909034573, 0.14365086399670746, 0.15152170862585757, 0.2610130865941481, 0.2149064786824858, 0.05252147812543373, 0.09856733911476423, 0.09215459011689187, 0.15074054957678562, 0.1632051256653516, 0.12115405112504063, 0.17892205211777923, 0.551145943932611, 0.14754264711515463, 0.9616623208006697, 0.9601056588066587, 0.9601266539719995, 0.9208209279887415, 0.9369697099427919, 0.9417398939707421, 0.9771316283003981, 0.9771333432777557, 0.9771330962752913, 0.49818214068360844, 0.4688208791595163, 0.48212839053773304, 0.6308346642460845, 0.5032697438362912, 0.5145735319962434, 0.5266304458461228, 0.5126962058534693, 0.5403488984364975, 0.356590675245937, 0.16803271883680249, 0.21077642622961656, 0.16111586581035642, 0.2263018690593822, 0.2108808049822205, 0.7772438003554614, 0.33811637421897245, 0.6534935116934274, 0.32389104894451237, 0.3371768259094703, 0.28261653826081223, 0.2669041818937843, 0.1334129589924492, 0.30703054283802367, 0.13139758590578898, 0.22951464063924487, 0.5776516730698469, 0.28961171047673084, 0.25018139463777267, 0.30880765946970623, 0.3937567289708228, 0.32551281147886013, 0.32389798656935787, 0.28592853348271574, 0.4290287240591034, 0.28404578801807157, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17222416151381725, 0.16242590024036785, 0.19531605032810884, 0.023579333245045575, 0.054710738701677974, 0.022721792456675938, 0.06619566827230539, 0.08927590324661328, 0.07780432783203195, 0.060679830791890654, 0.07405559812153528, 0.022324918022913476, 0.0293497157683833, 0.01871607388628449, 0.05757121595792747, 0.0076773227720848825, 0.05523580276763662, 0.023517684157348784, 0.23232780272061992, 0.1939208988146135, 0.1986707485792727, 0.2754142276856314, 0.21366011701514886, 0.19890179516794793, 0.05654202836779132, 0.25671117641771357, 0.3126038104636204, 0.6090455591627885, 0.5801493943591399, 0.6090149077160554, 0.5782388404618137, 0.5841139507410344, 0.5879153426274474, 0.5214018040843827, 0.7210947810984778, 0.5477925836404822, 0.1408560708319455, 0.14456591635029326, 0.13119780731265096, 0.11406426980221729, 0.16260230910918017, 0.1333497840873792, 0.12916943690730243, 0.11505341372531297, 0.1033297047255215, 0.13009255490139526, 0.1297773009376788, 0.12667953632311346, 0.2779255103975389, 0.17311024739820424, 0.20278262364485, 0.21215005172982493, 0.11372468542186909, 0.11511014983664314, 0.27321471095654526, 0.17335303975138827, 0.14426571628479146, 0.27261654173068606, 0.3795048567432351, 0.2951310519930226, 0.24744608485185404, 0.3407006221357095, 0.3786518129284211, 0.24455414466735514, 0.24073626829106398, 0.17901125837358745, 0.28859127501545234, 0.2613618709306429, 0.2423066166091623, 0.1668054856574448, 0.28406794211535613, 0.169738595549339, 0.22889740127655656, 0.2248499449694512, 0.24660707078113386, 0.21495568573767532, 0.27063510039145156, 0.21216861247748697, 0.19696360150896586, 0.2294335094618638, 0.19864712435739174, 0.18926171142316572, 0.185845627442075, 0.1943479383189356, 0.21460282468289105, 0.22139760274888598, 0.7384035817496927, 0.19747444457312946, 0.17821754323063255, 0.6776131356107946, 0.2106047499061422, 0.7618013709469855, 0.1529101856807592, 0.19690337608118735, 0.250870863736919, 0.25197594095883347, 0.11322094915717373, 0.11316026573152171, 0.1131910076331556, 0.1689860071128867, 0.12634804768665053, 0.20585976992249033, 0.2124741601183726, 0.21097336006363343, 0.21148596921782414, 0.2094651706595232, 0.15382508053609867, 0.19699175809822034, 0.18580916733797803, 0.19464587572034686, 0.20768713081592438, 0.1466675296179858, 0.18868202940564438, 0.1891265268379504, 0.22147651613238284, 0.1954265191881126, 0.14986086522101194, 0.08540780524433844, 0.10393689233744885, 0.10613560067407124, 0.080267369493349, 0.07988706597893491, 0.09733388343110494, 0.08073861015831207, 0.08216248727616804, 0.07951050546243332]}, "mutation_prompt": null}
{"id": "0020c80f-b419-46b4-a0f5-6b68f8ac6a9d", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.adaptive_learning_rate = self.learning_rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        avg_initial_fitness = np.mean(fitness)\n        \n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.adaptive_learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.adaptive_learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n            avg_current_fitness = np.mean(fitness)\n            self.adaptive_learning_rate = self.learning_rate * (1 + np.sign(avg_initial_fitness - avg_current_fitness))\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive learning rate based on fitness improvement to enhance convergence speed.", "configspace": "", "generation": 81, "fitness": 0.28159878261453036, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8088781547572921, 0.8935458058816269, 0.8172152008323329, 0.8332558602942954, 0.8358658011723654, 0.8631795552731099, 0.20544459322786224, 0.8163917116701738, 0.1995349828495483, 0.6502547944747429, 0.6989262095973928, 0.7377587182797939, 0.717695755833985, 0.6929819535264423, 0.728903149080127, 0.7194503399703617, 0.735915302308261, 0.7347669728358066, 0.17981515876590326, 0.10456824016799104, 0.07317575901843232, 0.2465095744815612, 0.17467265790567854, 0.12304970323515974, 0.19353205906196047, 0.15904470053597997, 0.15344848515525922, 0.12044394984905371, 0.03847531356648759, 0.041573936334609596, 0.22228600574269453, 0.1665242145893695, 0.1552107203861175, 0.10047743658632657, 0.14990592904783373, 0.136234881183656, 0.9713025174703318, 0.9770793160414551, 0.9770797029789272, 0.9518696365760154, 0.05116876597450504, 0.05115752506998328, 0.9756617023169782, 0.975671836189694, 0.9756684907241592, 0.5079710410446658, 0.49952682046830943, 0.5398653970897858, 0.5506814826975615, 0.6403069054653885, 0.5136446243069495, 0.5930531508465833, 0.09695541453346523, 0.5416055068329056, 0.16533649553015206, 0.37879983311887866, 0.38035166500490336, 0.16232037499072083, 0.21733832066230907, 0.2741904973596888, 0.21140047783145977, 0.33099843000565066, 0.6838381836439127, 0.12936361445917433, 0.5667717108001794, 0.48155362907614174, 0.13287560932858633, 0.5850424420505576, 0.3858006077225752, 0.27139429373145463, 0.5268800095387942, 0.3937702765350476, 0.2769818927410702, 0.26125829976298054, 0.36475983294934555, 0.4140518065762565, 0.5922237908155119, 0.642108810853599, 0.33800483329161923, 0.5642554459121288, 0.33931316758511265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12173137535291567, 0.1305056348176824, 0.12384623138640471, 0.0262296102217644, 0.026550247279094052, 0.017489828436625388, 0.11810583460370505, 0.06761512855109808, 0.0433319780766982, 9.999999999998899e-05, 0.011160401938955733, 9.999999999998899e-05, 0.1455441770017989, 0.054953195761100915, 0.07967588639140144, 0.04143168705447242, 0.0025822358929253886, 0.0816966433048929, 0.21588958659097202, 0.3197584120187025, 0.004850074501910107, 0.2922835565150189, 0.3201102295266187, 0.30377048488811564, 0.05781020425038719, 0.2022208887362683, 0.25162517779260984, 0.705778646382931, 0.5923476327465886, 0.6371107114936915, 0.5207380254541496, 0.5943430634761889, 0.6021322358267367, 0.6016345461803034, 0.6052919575104825, 0.6926508792561566, 0.044874054404092756, 0.0930107101097225, 0.11057052349885066, 0.13573011279226144, 0.1347405209336383, 0.11620063145729165, 0.093971482009365, 0.11072797032277071, 0.08527163560098505, 0.1818947095787652, 0.1403261808093419, 0.12782810481204088, 0.17222305644597002, 0.09567697167256006, 0.10961968990986948, 0.14558872599981498, 0.3527298195174251, 0.21913910710363893, 0.17300921065484143, 0.19785373701454023, 0.14678185552409118, 0.20330245546954084, 0.15870362446745367, 0.23216850708925463, 0.34571307536015494, 0.21201383793531892, 0.36156930406729615, 0.1679819996077826, 0.11169845768189657, 0.28851484193374, 0.21096785307592658, 0.25119446955391544, 0.30881869238863124, 0.18577449141103475, 0.1643119898636083, 0.15794466333544244, 0.20812690369557785, 0.19345605416193867, 0.18203579035559025, 0.20074464128619507, 0.24565311034187798, 0.16504897871747048, 0.20664223308023388, 0.1916474750259235, 0.21109417405929698, 0.18931877418887721, 0.20793090603010933, 0.20093218927368428, 0.20760457479623506, 0.21796487966243017, 0.20746447071937502, 0.19582662105937465, 0.20464885572856062, 0.19967303455384444, 0.17624163476136379, 0.14220292652327027, 0.13939130779959907, 0.27418697303513784, 0.1951138413320581, 0.1908176929133346, 0.11333815969302397, 0.17735601304679605, 0.17727965686066527, 0.15579240689360363, 0.15467567922572656, 0.1677456005540815, 0.15346713998638806, 0.1681678866786488, 0.17013552453433478, 0.20852778968798236, 0.1561936127366773, 0.15611261614100025, 0.18586700022200908, 0.1960255552465645, 0.17703148714527217, 0.1822221908979874, 0.2085598120002935, 0.15001566426214719, 0.18997076319619666, 0.1858051207851067, 0.17180600630328768, 0.0776833336843501, 0.08820348912232001, 0.09266696871421098, 0.08631889057937236, 0.09959055374151526, 0.0948116397881158, 0.07613460311186226, 0.09780091859285645, 0.0997516595874911]}, "mutation_prompt": null}
{"id": "da899b77-81ee-4baa-83b6-532791256344", "solution": "import numpy as np\n\nclass AdaptiveEnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.mutation_scale_factor = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + self.mutation_scale_factor * self.success_rate)  # Updated dynamic adjustment\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "AdaptiveEnhancedDEAMS", "description": "Introduce adaptive scaling of mutation factor and enhanced crossover mechanism to accelerate convergence.", "configspace": "", "generation": 82, "fitness": 0.3255345447234915, "feedback": "The algorithm AdaptiveEnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8585013599887887, 0.8517667519528265, 0.8577109917676684, 0.8556788273881921, 0.8722203899781285, 0.8391339071508861, 0.8239522571543973, 0.8414027920284184, 0.8552568557149919, 0.7520092560044628, 0.7452654458470378, 0.783943538084735, 0.7671473728312463, 0.7354275908581858, 0.7354588661114541, 0.7759024726626377, 0.7494778238278642, 0.7823911834497339, 0.10908849354396966, 0.12192540363834614, 0.14088091785074053, 0.7165198520563597, 0.1541273853412577, 0.16286113599291296, 0.15025055003976817, 0.20711526404309322, 0.2197695387686711, 0.0531908362119109, 0.0680910070217251, 0.12311760806466154, 0.1705193368487138, 0.17552199995823015, 0.11845129770142415, 0.21568217876939144, 0.1693125727939503, 0.14723121389247462, 0.9763746287755711, 0.9755946107270916, 0.9756053395477664, 0.9465201369148695, 0.9591330676601183, 0.9607072891501539, 0.9865821220821539, 0.9865831525652948, 0.9865830041457873, 0.6384626408987014, 0.6383322216154703, 0.6186821286330462, 0.6073599667540033, 0.5980839157342903, 0.5650723842374596, 0.699340877685892, 0.5725482028407025, 0.6065156015298284, 0.3773792037196241, 0.1696185004805546, 0.2130511203516413, 0.15669844970890112, 0.8261394139327654, 0.21245494439277113, 0.22551976710885124, 0.320350669569185, 0.6983767678675856, 0.29629689856021346, 0.45044794774949637, 0.5294045263515024, 0.5431053969848411, 0.2820476835901655, 0.2883099069712046, 0.13227552573097268, 0.4409937563747717, 0.721470825787851, 0.36916414498885963, 0.35745060101492243, 0.27271993716971166, 0.5343052022292577, 0.500067917587546, 0.3652685250061414, 0.27058212191482367, 0.2584052990325688, 0.28640299762366717, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20820721442419, 0.14449476449883136, 0.14993788144688713, 0.03217315171956492, 0.057582353731783, 0.02364840580509986, 0.071350923985951, 0.08872595965914554, 0.07698734532595375, 0.0939203991517581, 0.09691226862024904, 0.004027993680112196, 9.999999999998899e-05, 0.018863229517377622, 0.06687315116781589, 0.07786893797940975, 0.016825672755891752, 0.01704938742231965, 0.2502236615734803, 0.26468391547290493, 0.2326511553263242, 0.33072802080464003, 0.2508315566596464, 0.2637161240229353, 0.05768693413498782, 0.21926201024673952, 0.24911817453040552, 0.618389113407727, 0.6165677699333896, 0.7578763888233913, 0.5699832283775086, 0.6637051611770723, 0.5605647900964168, 0.619310478101212, 0.7395463905407629, 0.5660865882873716, 0.14230750823019023, 0.14601184125186306, 0.1416436745106162, 0.1324117339317672, 0.1533903081448681, 0.12463622781052441, 0.13160121806535408, 0.11775788832373235, 0.1062689277464488, 0.1684041190029586, 0.1300681307517949, 0.12670221407734805, 0.2615916255165709, 0.17584156376492488, 0.11084918582897785, 0.2151923674197339, 0.11387182373710403, 0.11553880578253595, 0.2853078771299561, 0.2777703480577277, 0.1434485693967319, 0.28041164401458984, 0.37564213584233885, 0.3900496293557594, 0.2503447004091883, 0.37818551528626154, 0.4161220599164205, 0.19629326944012893, 0.3276102250375872, 0.1540948360846558, 0.2695687280823733, 0.20573612905493488, 0.28501567024691, 0.27927410919713436, 0.1673669196758466, 0.18033349242426155, 0.2614966402759633, 0.24009949290170063, 0.18310445182551605, 0.2189679330269415, 0.24366322828618125, 0.23077746922530973, 0.1922751602095425, 0.18522954017610227, 0.20245182551097485, 0.19058164991347204, 0.19676052403284294, 0.1957875974616592, 0.6139548354477794, 0.21070742317537738, 0.7861259328280213, 0.19865660178566868, 0.17892385946557188, 0.6798764519846683, 0.21124505113608916, 0.8060672960259883, 0.15354605208610195, 0.2095869679104594, 0.2526455203124406, 0.25540087058908834, 0.11332919100720007, 0.11328421509933195, 0.11330348675446911, 0.16937781453195622, 0.12694378589116417, 0.20648227259417695, 0.21311346938210096, 0.21219564409909042, 0.21233394576964926, 0.21077539917967913, 0.1544482337589428, 0.1511594550312566, 0.20927916430508087, 0.184219540526267, 0.22450774909197724, 0.1924103696445767, 0.18414261917383046, 0.1867821304162186, 0.22804399070169679, 0.19448536997937893, 0.16790416603834457, 0.09388417932807736, 0.09731706966587717, 0.08317275716956862, 0.07498522487963, 0.07722836292105006, 0.09349208042334722, 0.08305298129378258, 0.09643277670885764, 0.09270269571689493]}, "mutation_prompt": null}
{"id": "ad36e8c2-bfdf-4c89-a10a-2f757c8913bd", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        no_improvement_counter = 0  # Counter for tracking stagnation\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n                    no_improvement_counter = 0  # Reset counter on improvement\n                else:\n                    no_improvement_counter += 1\n\n            if no_improvement_counter > 10:  # Reset crossover rate if stagnant\n                dynamic_crossover_rate = self.crossover_rate\n                no_improvement_counter = 0\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive crossover rate reset based on convergence speed to enhance exploration-exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.3280343869300537, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8658167619417423, 0.867968541952731, 0.8701137941837738, 0.8688120022155796, 0.87145687604336, 0.8534644674620718, 0.8414297904670729, 0.8886501147280358, 0.8669536123347121, 0.7802304217417049, 0.7334901605717844, 0.7551170030949074, 0.7529064530805211, 0.7824617135189391, 0.7854495484197552, 0.7501760545806038, 0.7408235665456131, 0.7635050664219807, 0.12594671855564032, 0.12234913842542738, 0.1580039159342348, 0.70685506274667, 0.13604303493102865, 0.1453120545067803, 0.15299949928036582, 0.26802926455749254, 0.21779267154392923, 0.053100935359556733, 0.09952099121979263, 0.09292277857029052, 0.15305606916569525, 0.1657860832891802, 0.12245707991066723, 0.18201225115242614, 0.6321062297557039, 0.15014375067599162, 0.9763746134748085, 0.9755945652504145, 0.9756052859727075, 0.9465189542444267, 0.9591400410181143, 0.9607073075923113, 0.9865821223915728, 0.9865831528706189, 0.986583004451702, 0.6076210793564727, 0.5863663329832267, 0.5904669659099104, 0.7023303978449649, 0.6069525669414779, 0.630802689788288, 0.633625605552198, 0.5999228688059586, 0.6615434545397558, 0.3630402240372216, 0.1696185004805546, 0.2130511203516413, 0.16172950265809982, 0.22829124446120064, 0.2124647427359111, 0.8017810092925293, 0.344546766688932, 0.6808792016102987, 0.43553634341489245, 0.4098460937874425, 0.4013650136935719, 0.36726915057474807, 0.13466654441596726, 0.39244615697438057, 0.13244153776505863, 0.29201754878005026, 0.6679995787635138, 0.3770866576163864, 0.3349437017830146, 0.4423574856421628, 0.5275524290761973, 0.4583999633633571, 0.4655422092524867, 0.4093429432550555, 0.5637840845901688, 0.4130474294851464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1758340012064311, 0.1766253461610895, 0.20174881969667735, 0.024073926175364968, 0.05522579657853621, 0.02318465033129835, 0.07460929804413641, 0.08953724741639235, 0.07829306451588491, 0.06602800503390549, 0.08298035838894124, 0.028279144226737496, 0.037481901565315834, 0.021492619756440345, 0.07050696650345456, 0.008513439423214586, 0.059453351854060754, 0.02609453965771058, 0.2796307770379294, 0.21499236398853427, 0.216549574306919, 0.3116733076790549, 0.22512593002189396, 0.2154655614035459, 0.05749771428830608, 0.29313801812180573, 0.3291144262144742, 0.627838655695782, 0.5935742358502504, 0.6517659221747092, 0.6075356701776825, 0.6079023032032946, 0.6175352548380244, 0.5568671573804909, 0.7675654089834433, 0.5771016709333034, 0.14232711787163244, 0.1459202946063628, 0.1323248427313769, 0.11645887429053603, 0.16735021746740553, 0.13552534707167285, 0.131533750442013, 0.11773085516711324, 0.10583403916495848, 0.13049370421924378, 0.1299884604391155, 0.1268796195465216, 0.28111251972662643, 0.1741438715248922, 0.20373810827958883, 0.21542347610959256, 0.11398122988625514, 0.11538830772578457, 0.27579465685135074, 0.1739647004724738, 0.14476467966471207, 0.2770067965997872, 0.38699487997507354, 0.29793001841448974, 0.24887430707079639, 0.3434541950568709, 0.3862673258472141, 0.2516813849936128, 0.24733108839763107, 0.18096319708993847, 0.2956671345506173, 0.26890227448602677, 0.24612846698555557, 0.167524309347292, 0.2938092382507608, 0.1710279574779121, 0.23133726112530784, 0.22670363972302776, 0.24989435304508678, 0.2174533016709368, 0.2743272495003556, 0.21491667617898436, 0.19982073172970205, 0.23222777609086465, 0.20089074563204123, 0.19058318001991426, 0.18719961570067611, 0.19577012712111397, 0.21591480962179277, 0.22334328108333834, 0.7954591480957566, 0.1986448373133911, 0.17897287209015356, 0.727251723207991, 0.21126410856889144, 0.7933947304250162, 0.15353821169714443, 0.1984295262050424, 0.25248434473758374, 0.25359830712823017, 0.11332931992156425, 0.113284313223046, 0.11330416442103974, 0.1693722516733609, 0.12689600161795078, 0.2064661200756316, 0.21311392035370025, 0.21166923271811122, 0.212335631006081, 0.21073997707292946, 0.15446474764673535, 0.19823908263440293, 0.18623870131082654, 0.19527137946826711, 0.20928054991421574, 0.1466856697036919, 0.18937417386199384, 0.18976888048229634, 0.22216717717179846, 0.19611396456820207, 0.15007813394767278, 0.08663379469916677, 0.10682464022986582, 0.10727449248627796, 0.08225075263826098, 0.08126992494382468, 0.09905264249798984, 0.0818123352705652, 0.0837082748503919, 0.08137741970686241]}, "mutation_prompt": null}
{"id": "8c63e81f-14e1-4ec2-b4e4-a3c8954b781e", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        inertia_weight = 0.9  # New addition\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)  # Dynamic adjustment\n            adjusted_mutation_factor *= inertia_weight  # Apply inertia weight\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce an adaptive inertia weight to the mutation factor based on population diversity to enhance exploration and convergence.", "configspace": "", "generation": 84, "fitness": 0.317251809315324, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8965222403285302, 0.8825582179574761, 0.8559402511791162, 0.8840308440325498, 0.8849346555693159, 0.8974963494880177, 0.8680210065640491, 0.8630350175001175, 0.8490266595564164, 0.8283578802399328, 0.7858002430322015, 0.7950574368808527, 0.7085362019915136, 0.740256556293122, 0.7379604736414519, 0.7391503085656339, 0.7839956985253043, 0.6891869047621951, 0.12010158874547305, 0.14297192689434723, 0.14179744416536777, 0.163981513149005, 0.14506573275845314, 0.175189821131558, 0.7075020174168882, 0.15299275728549566, 0.7177853641127334, 0.05933875206664274, 0.08505183137630334, 0.1246594926725646, 0.159901800444344, 0.6396434658266438, 0.5140214691068887, 0.17540207665911856, 0.15491078791998703, 0.1391419373296794, 0.973328857576685, 0.974279421602157, 0.9742847212176816, 0.982442036266067, 0.982441172769522, 0.9824412538257933, 0.9741605684807835, 0.9754371707020233, 0.973836943836656, 0.6813598271092631, 0.49705847104078416, 0.5308236990780801, 0.5479692336486816, 0.5594959080768925, 0.5347478113335788, 0.4956873610474464, 0.5782759425683736, 0.5302729141451232, 0.129820839507361, 0.22150507494175686, 0.3533611568726238, 0.21214946596155138, 0.3729174908034144, 0.267951673779497, 0.37888522608683783, 0.7391942982531643, 0.3278793841157479, 0.459160477448449, 0.18547123521373998, 0.205137407373026, 0.19768922558453095, 0.2350171324853132, 0.13448532246653844, 0.20725147995859794, 0.2702470840618204, 0.22877737892007266, 0.3481422545312003, 0.2166381249645517, 0.18774634434612636, 0.2631724651932046, 0.22188512465541987, 0.25827088840406187, 0.2544801272914641, 0.21650245165644344, 0.2578473646238967, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17519856101107456, 0.15389599859986902, 0.1271891983415846, 0.032327301525533425, 0.05801560357951607, 0.05700838777396133, 0.07802295116701585, 0.0903830822768017, 0.09651670229044207, 0.10219306772991876, 0.0012941128678487512, 0.055363165576459705, 0.07607483891771949, 0.06830053718050733, 0.08738347906515542, 0.006288022636005586, 0.028704581755082836, 0.06991484271718706, 0.2628702796857587, 0.35385635061080023, 0.24377996926007894, 0.22184520945361408, 0.3756792106693715, 0.1091754136947849, 0.23605015698450638, 0.18324313094960365, 0.16942340270427336, 0.532586328459189, 0.6380754358856033, 0.5574481564384031, 0.5954951039375089, 0.5197668136964728, 0.4754069062607965, 0.5281599875060975, 0.6017310405793681, 0.5542102445199282, 0.1779265562356992, 0.13270911760595683, 0.14007425404192164, 0.11032918902044675, 0.12211104356302149, 0.12947233054311968, 0.09711975995151556, 0.09971341238628406, 0.07368317812878833, 0.14947639264829993, 0.15405808134624588, 0.16658297025316038, 0.19653568659128273, 0.19130522283041207, 0.1480941033207075, 0.17700724713158578, 0.11981027674574019, 0.20625594461477348, 0.20362445908163118, 0.2581998731699203, 0.19463276488031955, 0.22621455673365942, 0.3193029996795519, 0.3093603311780486, 0.3199537677941061, 0.2676688829234892, 0.342888733709214, 0.1584060845253723, 0.2212327871058437, 0.20420534410620006, 0.19184992492134767, 0.22069096897063023, 0.2435452173372431, 0.27194248102434226, 0.26898317397324445, 0.3077124648591497, 0.23220624048950433, 0.19483218904397026, 0.25268782381103505, 0.21603965914102763, 0.23986890322830423, 0.19118724443056645, 0.2623134526464228, 0.19720002682593196, 0.23613727191032696, 0.19213207138015842, 0.1818317545337963, 0.21693335553136572, 0.22217727108882923, 0.22347513003119845, 0.19584970677421087, 0.7275660922754139, 0.1841770778893358, 0.2464214171950253, 0.19325795823233494, 0.15266268548284045, 0.16788942272669716, 0.31258192136587626, 0.18418445479445578, 0.190380695265723, 0.19968030593248154, 0.16787810526153313, 0.16788644208654147, 0.2128312186107617, 0.16982011494708926, 0.13966031503302478, 0.7630473689088413, 0.16883374900185844, 0.16886900195339383, 0.7267746804645607, 0.7729579363310968, 0.754938352135148, 0.19962696624688536, 0.18013760538721635, 0.1790857925717222, 0.18402808609306798, 0.19319395000006312, 0.20150800644505873, 0.18564351569781035, 0.217140530035846, 0.19056244899214447, 0.10734341283664217, 0.09614389642861787, 0.09847785294425992, 0.08657704806053479, 0.07781418539978224, 0.08555234766815778, 0.08276202988550008, 0.09016897302189542, 0.08773904939868249]}, "mutation_prompt": null}
{"id": "840ec8d6-f69c-47ef-b9ae-0d7ac24d92af", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)  # Dynamic adjustment\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (1 + 0.1 * self.success_rate) * (self.best_fitness / np.mean(fitness))  # Adjusted for fitness improvement\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive crossover rate tuning based on fitness improvement to enhance solution exploration and exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.3280343869300537, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8658167619417423, 0.867968541952731, 0.8701137941837738, 0.8688120022155796, 0.87145687604336, 0.8534644674620718, 0.8414297904670729, 0.8886501147280358, 0.8669536123347121, 0.7802304217417049, 0.7334901605717844, 0.7551170030949074, 0.7529064530805211, 0.7824617135189391, 0.7854495484197552, 0.7501760545806038, 0.7408235665456131, 0.7635050664219807, 0.12594671855564032, 0.12234913842542738, 0.1580039159342348, 0.70685506274667, 0.13604303493102865, 0.1453120545067803, 0.15299949928036582, 0.26802926455749254, 0.21779267154392923, 0.053100935359556733, 0.09952099121979263, 0.09292277857029052, 0.15305606916569525, 0.1657860832891802, 0.12245707991066723, 0.18201225115242614, 0.6321062297557039, 0.15014375067599162, 0.9763746134748085, 0.9755945652504145, 0.9756052859727075, 0.9465189542444267, 0.9591400410181143, 0.9607073075923113, 0.9865821223915728, 0.9865831528706189, 0.986583004451702, 0.6076210793564727, 0.5863663329832267, 0.5904669659099104, 0.7023303978449649, 0.6069525669414779, 0.630802689788288, 0.633625605552198, 0.5999228688059586, 0.6615434545397558, 0.3630402240372216, 0.1696185004805546, 0.2130511203516413, 0.16172950265809982, 0.22829124446120064, 0.2124647427359111, 0.8017810092925293, 0.344546766688932, 0.6808792016102987, 0.43553634341489245, 0.4098460937874425, 0.4013650136935719, 0.36726915057474807, 0.13466654441596726, 0.39244615697438057, 0.13244153776505863, 0.29201754878005026, 0.6679995787635138, 0.3770866576163864, 0.3349437017830146, 0.4423574856421628, 0.5275524290761973, 0.4583999633633571, 0.4655422092524867, 0.4093429432550555, 0.5637840845901688, 0.4130474294851464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1758340012064311, 0.1766253461610895, 0.20174881969667735, 0.024073926175364968, 0.05522579657853621, 0.02318465033129835, 0.07460929804413641, 0.08953724741639235, 0.07829306451588491, 0.06602800503390549, 0.08298035838894124, 0.028279144226737496, 0.037481901565315834, 0.021492619756440345, 0.07050696650345456, 0.008513439423214586, 0.059453351854060754, 0.02609453965771058, 0.2796307770379294, 0.21499236398853427, 0.216549574306919, 0.3116733076790549, 0.22512593002189396, 0.2154655614035459, 0.05749771428830608, 0.29313801812180573, 0.3291144262144742, 0.627838655695782, 0.5935742358502504, 0.6517659221747092, 0.6075356701776825, 0.6079023032032946, 0.6175352548380244, 0.5568671573804909, 0.7675654089834433, 0.5771016709333034, 0.14232711787163244, 0.1459202946063628, 0.1323248427313769, 0.11645887429053603, 0.16735021746740553, 0.13552534707167285, 0.131533750442013, 0.11773085516711324, 0.10583403916495848, 0.13049370421924378, 0.1299884604391155, 0.1268796195465216, 0.28111251972662643, 0.1741438715248922, 0.20373810827958883, 0.21542347610959256, 0.11398122988625514, 0.11538830772578457, 0.27579465685135074, 0.1739647004724738, 0.14476467966471207, 0.2770067965997872, 0.38699487997507354, 0.29793001841448974, 0.24887430707079639, 0.3434541950568709, 0.3862673258472141, 0.2516813849936128, 0.24733108839763107, 0.18096319708993847, 0.2956671345506173, 0.26890227448602677, 0.24612846698555557, 0.167524309347292, 0.2938092382507608, 0.1710279574779121, 0.23133726112530784, 0.22670363972302776, 0.24989435304508678, 0.2174533016709368, 0.2743272495003556, 0.21491667617898436, 0.19982073172970205, 0.23222777609086465, 0.20089074563204123, 0.19058318001991426, 0.18719961570067611, 0.19577012712111397, 0.21591480962179277, 0.22334328108333834, 0.7954591480957566, 0.1986448373133911, 0.17897287209015356, 0.727251723207991, 0.21126410856889144, 0.7933947304250162, 0.15353821169714443, 0.1984295262050424, 0.25248434473758374, 0.25359830712823017, 0.11332931992156425, 0.113284313223046, 0.11330416442103974, 0.1693722516733609, 0.12689600161795078, 0.2064661200756316, 0.21311392035370025, 0.21166923271811122, 0.212335631006081, 0.21073997707292946, 0.15446474764673535, 0.19823908263440293, 0.18623870131082654, 0.19527137946826711, 0.20928054991421574, 0.1466856697036919, 0.18937417386199384, 0.18976888048229634, 0.22216717717179846, 0.19611396456820207, 0.15007813394767278, 0.08663379469916677, 0.10682464022986582, 0.10727449248627796, 0.08225075263826098, 0.08126992494382468, 0.09905264249798984, 0.0818123352705652, 0.0837082748503919, 0.08137741970686241]}, "mutation_prompt": null}
{"id": "a96727ec-e074-4af3-8366-63cf765e9f06", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.1 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                # Adaptive step size control based on variance\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate) * np.sqrt(np.var(current_solution))\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive step size control through variance scaling in local search for enhanced convergence.", "configspace": "", "generation": 86, "fitness": 0.3014045777585727, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8410718898297028, 0.8503890530492677, 0.8541869977835078, 0.8615051658893921, 0.8637131962018986, 0.874558392293987, 0.8652851826091085, 0.8817885706141723, 0.8694052444380522, 0.7758098074379586, 0.7932027136937039, 0.7809170297153805, 0.7412224637409681, 0.7833351455663065, 0.7651719412839318, 0.7337404407039425, 0.7529948338426915, 0.7344591135780526, 0.16325615094562707, 0.0942952414237701, 0.11231520882532664, 0.14088500586131958, 0.17819699152030644, 0.7089604056198974, 0.1520020417885638, 0.18757328059595968, 0.17124675862648164, 0.05839693269112445, 9.999999999998899e-05, 9.999999999998899e-05, 0.1706196676033953, 0.21886679708627255, 0.20078985516321368, 0.1640272161191233, 0.1688743807125771, 0.22788500142915535, 0.9823262749548926, 0.9844157194779564, 0.984416567564326, 0.08090532864068622, 0.08702292599550676, 0.08224223598431157, 0.9855980203947999, 0.9855942509358496, 0.985593963009729, 0.5620453514364772, 0.6305690010122769, 0.605386780621505, 0.6252478242001811, 0.6101751523353424, 0.15453963300247664, 0.626738295051527, 0.6509426108134241, 0.5957759939204177, 0.23067632845921238, 0.8397867951644455, 0.22442426006102656, 0.36527311859992273, 0.1918871342739008, 0.160327795846391, 0.31363900245585963, 0.34842757801687707, 0.3436241371532315, 0.29429875021487195, 0.6781790828789427, 0.13710459632182226, 0.23741035686750112, 0.16480810958135916, 0.5052953188000744, 0.192816057375647, 0.4829808897239303, 0.429679815983362, 0.39764060998696293, 0.5284144388162372, 0.29250492934483274, 0.13533475666900918, 0.40942952009323286, 0.3624663052436212, 0.22478528461471148, 0.3035272377649708, 0.3264654077382094, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12729772040052956, 0.1271548861080024, 0.17253717025868986, 0.02897274368775493, 0.028620950637914255, 0.02967984406035995, 0.0633541797239584, 0.10715023213156305, 0.08058917943719335, 0.0062353735899359775, 0.01906225855915622, 0.06112685257876005, 0.0029594830426220575, 0.032634408849053775, 0.018662314871043084, 0.023543099844751336, 0.0655885334424332, 0.042950382445160695, 0.2451295481356054, 0.30180513690461275, 0.2454926988638727, 0.17428426656856044, 0.24835757403933378, 0.22451360545230226, 0.40638032550532555, 0.024626509292268728, 0.22206859641404275, 0.549045727206549, 0.632747953545582, 0.6627787612749322, 0.6914630321696318, 0.5587275072471167, 0.6609319508226446, 0.5499376550571264, 0.6679716766360116, 0.6224571125023335, 0.1031466741394872, 0.07475968543005407, 0.09229560367288647, 0.10864461498854816, 0.15064858683875648, 0.15749018817312932, 0.11771790983820518, 0.12391616312545972, 0.10623249652403988, 0.1178343136687432, 0.13605558267219298, 0.17432161442316485, 0.16612502046185962, 0.16280320498716117, 0.15523527304229412, 0.150790147979728, 0.10573146025317093, 0.1122752894867648, 0.44758273464227893, 0.16976406160057467, 0.29947992089306785, 0.3343229025887049, 0.22891722209481657, 0.2765235686566576, 0.4460908916599966, 0.5397960169147796, 0.3073098372573905, 0.23892870372084674, 0.29344184159193387, 0.2295739891411256, 0.350390596779798, 0.3077700668589175, 0.281520552905845, 0.20901523530048294, 0.19074571111549132, 0.21394444867729268, 0.16191294236920473, 0.18428295493838354, 0.25048388254714005, 0.23241270146243365, 0.21420254524232607, 0.18566750456618797, 0.2537632595963476, 0.18041892597275988, 0.22579961527399095, 0.17681898940992247, 0.22688270420157897, 0.24950459994298002, 0.24491802183274836, 0.19570845346845178, 0.2229077564577555, 0.1989678914614249, 0.22230830954078074, 0.2022335093145412, 0.15158924719292444, 0.9001166909323922, 0.9052327486072974, 0.1770570017151738, 0.1859881685346494, 0.19051374943938904, 0.11679107038333492, 0.11338389962096918, 0.1134581089499308, 0.20891912613712105, 0.07311134490892379, 0.1321985541422297, 0.21228205860349658, 0.21061680658497173, 0.21210781554850222, 0.1175161524059064, 0.15528280200869882, 0.12829453609259167, 0.1914263475807877, 0.19815880557655552, 0.19914272218987927, 0.17469541082582185, 0.18527769647326575, 0.1747666736630803, 0.16524788526448375, 0.19812637258840504, 0.19787684322832744, 0.09045211042913093, 0.08519755009995855, 0.08541781642894564, 0.08415295008459545, 0.09387913885239141, 0.09009257125909464, 0.08648125074804025, 0.09614048000629172, 0.08242867204681592]}, "mutation_prompt": null}
{"id": "1c0f7959-e486-4950-8099-3dbdcbbe91ab", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)  # Change made here\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce a more responsive dynamic crossover rate adjustment to enhance convergence speed.", "configspace": "", "generation": 87, "fitness": 0.3292271740981192, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "d94a575c-3390-45d9-b255-61396aa645ea", "metadata": {"aucs": [0.8749264988790573, 0.867968541952731, 0.8792163412799672, 0.8674438834937077, 0.87145687604336, 0.8534644674620718, 0.8414297904670729, 0.8885979049568675, 0.8669536123347121, 0.7802304217417049, 0.7334901605717844, 0.7560890326044254, 0.7529064530805211, 0.7816886568161436, 0.7854495484197552, 0.7672620852242228, 0.7408235665456131, 0.7627578629819847, 0.12594671855564032, 0.12234913842542738, 0.1580039159342348, 0.70685506274667, 0.13604303493102865, 0.1453120545067803, 0.15299949928036582, 0.26802926455749254, 0.21779267154392923, 0.053100935359556733, 0.09952099121979263, 0.09292277857029052, 0.15305606916569525, 0.1657860832891802, 0.12245707991066723, 0.18201225115242614, 0.6277057730918068, 0.15262812248708957, 0.9763746134748085, 0.9755945652504145, 0.9756052859727075, 0.9465189542444267, 0.9591400410181143, 0.9607073075923113, 0.9865821223915728, 0.9865831528706189, 0.986583004451702, 0.6101939067195542, 0.6224234215342561, 0.7024423097393475, 0.7023303978449649, 0.6516080867137871, 0.6202153411413918, 0.6512388753318185, 0.6148923000844151, 0.679327792504755, 0.3630402240372216, 0.1696185004805546, 0.2130511203516413, 0.16172950265809982, 0.22829124446120064, 0.2124647427359111, 0.8017810092925293, 0.344546766688932, 0.6808792016102987, 0.43554135237705194, 0.5205196752085226, 0.4525677253791035, 0.3899119205203698, 0.13466654441596726, 0.48150767609064005, 0.13244153776743262, 0.30333609350640567, 0.6506695738751925, 0.3770866576163864, 0.2940683441978271, 0.42834904581337185, 0.5275524290761973, 0.4571313911210647, 0.46608800803965333, 0.2545971753428704, 0.5637840845901688, 0.34396567786652044, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1758340012064311, 0.1766253461610895, 0.2017511631330261, 0.024073926175364968, 0.05522579657853621, 0.02318465033129835, 0.07460929804413641, 0.08953724741639235, 0.07829306451588491, 0.06602800503390549, 0.08298035838894124, 0.028265325146854092, 0.036504203698203175, 0.021492619756440345, 0.06930337527848573, 0.008513439423214586, 0.059453351854060754, 0.026489530798023075, 0.27855046550740803, 0.2061469817950251, 0.2533674461374209, 0.3116733076790549, 0.22478787883506146, 0.2154655614035459, 0.05749771428039896, 0.31785252815339937, 0.32174084027995176, 0.628004629219979, 0.5992491744766353, 0.6517659221747092, 0.6031525657931012, 0.6091659473029664, 0.6242845762462257, 0.5327820066660569, 0.7675561348507951, 0.6024487475290558, 0.14232711787170138, 0.1460017271492423, 0.13388031134717948, 0.11645887429053603, 0.16710806997258731, 0.135525347068008, 0.131533673035363, 0.11773085516711324, 0.10583403916495848, 0.13049370421924378, 0.1299884604391155, 0.1268796195465216, 0.28111252066941383, 0.17414387148017363, 0.20373810827958883, 0.215423476109595, 0.11398122988625514, 0.11538830772578457, 0.27579465685135074, 0.1739647004724738, 0.14476467966471207, 0.2774075856621916, 0.38699487997507354, 0.29793001841448974, 0.24887430707079639, 0.3434541821606839, 0.3862480107442876, 0.2516813849936128, 0.24733108839763107, 0.18093688187751567, 0.29566713639525855, 0.26890227448602677, 0.24612863186909995, 0.167524309347292, 0.29450148509629837, 0.1710279574779121, 0.2313372611429334, 0.2266952697734258, 0.24989559342906587, 0.2174533016709368, 0.2743272495005994, 0.21491667618247412, 0.19982073172970205, 0.23222777609086465, 0.20089071688655236, 0.19058317999319963, 0.18719961570067611, 0.19577012716524278, 0.21591480962179277, 0.22334328117939473, 0.7962259663357528, 0.1986448373133911, 0.17897287209015356, 0.7333016857878849, 0.21126410856549882, 0.7343680459419026, 0.15353821169714443, 0.1984295262050424, 0.25248434473758374, 0.25359830712823017, 0.11332931992156425, 0.113284313223046, 0.11330416442103974, 0.1693722516733327, 0.12689638446948392, 0.2064661200756316, 0.21311392035370025, 0.21166952389436533, 0.212335631006081, 0.21073997707389813, 0.1544647478474792, 0.19823908263440293, 0.18623870131082654, 0.19527406989695284, 0.20928054991421574, 0.1466856697036919, 0.18937417386199384, 0.18976888048229634, 0.22216717717179846, 0.19611396456820207, 0.15007813394767278, 0.0866337946951855, 0.10681296198768175, 0.10728485122689013, 0.08225075305674068, 0.08126984843447627, 0.09905264340778286, 0.0818123352705652, 0.0837082748503919, 0.08137741970686241]}, "mutation_prompt": null}
{"id": "fce1ee77-18e8-4280-9b33-34436e883460", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.previous_improvement = 0\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            adjusted_mutation_factor *= 1 + 0.2 * np.tanh(self.previous_improvement)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    self.previous_improvement = fitness[i] - trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce a self-adaptive control for mutation factor based on fitness improvement history to enhance convergence speed.", "configspace": "", "generation": 88, "fitness": 0.3292271740981192, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "1c0f7959-e486-4950-8099-3dbdcbbe91ab", "metadata": {"aucs": [0.8749264988790573, 0.867968541952731, 0.8792163412799672, 0.8674438834937077, 0.87145687604336, 0.8534644674620718, 0.8414297904670729, 0.8885979049568675, 0.8669536123347121, 0.7802304217417049, 0.7334901605717844, 0.7560890326044254, 0.7529064530805211, 0.7816886568161436, 0.7854495484197552, 0.7672620852242228, 0.7408235665456131, 0.7627578629819847, 0.12594671855564032, 0.12234913842542738, 0.1580039159342348, 0.70685506274667, 0.13604303493102865, 0.1453120545067803, 0.15299949928036582, 0.26802926455749254, 0.21779267154392923, 0.053100935359556733, 0.09952099121979263, 0.09292277857029052, 0.15305606916569525, 0.1657860832891802, 0.12245707991066723, 0.18201225115242614, 0.6277057730918068, 0.15262812248708957, 0.9763746134748085, 0.9755945652504145, 0.9756052859727075, 0.9465189542444267, 0.9591400410181143, 0.9607073075923113, 0.9865821223915728, 0.9865831528706189, 0.986583004451702, 0.6101939067195542, 0.6224234215342561, 0.7024423097393475, 0.7023303978449649, 0.6516080867137871, 0.6202153411413918, 0.6512388753318185, 0.6148923000844151, 0.679327792504755, 0.3630402240372216, 0.1696185004805546, 0.2130511203516413, 0.16172950265809982, 0.22829124446120064, 0.2124647427359111, 0.8017810092925293, 0.344546766688932, 0.6808792016102987, 0.43554135237705194, 0.5205196752085226, 0.4525677253791035, 0.3899119205203698, 0.13466654441596726, 0.48150767609064005, 0.13244153776743262, 0.30333609350640567, 0.6506695738751925, 0.3770866576163864, 0.2940683441978271, 0.42834904581337185, 0.5275524290761973, 0.4571313911210647, 0.46608800803965333, 0.2545971753428704, 0.5637840845901688, 0.34396567786652044, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1758340012064311, 0.1766253461610895, 0.2017511631330261, 0.024073926175364968, 0.05522579657853621, 0.02318465033129835, 0.07460929804413641, 0.08953724741639235, 0.07829306451588491, 0.06602800503390549, 0.08298035838894124, 0.028265325146854092, 0.036504203698203175, 0.021492619756440345, 0.06930337527848573, 0.008513439423214586, 0.059453351854060754, 0.026489530798023075, 0.27855046550740803, 0.2061469817950251, 0.2533674461374209, 0.3116733076790549, 0.22478787883506146, 0.2154655614035459, 0.05749771428039896, 0.31785252815339937, 0.32174084027995176, 0.628004629219979, 0.5992491744766353, 0.6517659221747092, 0.6031525657931012, 0.6091659473029664, 0.6242845762462257, 0.5327820066660569, 0.7675561348507951, 0.6024487475290558, 0.14232711787170138, 0.1460017271492423, 0.13388031134717948, 0.11645887429053603, 0.16710806997258731, 0.135525347068008, 0.131533673035363, 0.11773085516711324, 0.10583403916495848, 0.13049370421924378, 0.1299884604391155, 0.1268796195465216, 0.28111252066941383, 0.17414387148017363, 0.20373810827958883, 0.215423476109595, 0.11398122988625514, 0.11538830772578457, 0.27579465685135074, 0.1739647004724738, 0.14476467966471207, 0.2774075856621916, 0.38699487997507354, 0.29793001841448974, 0.24887430707079639, 0.3434541821606839, 0.3862480107442876, 0.2516813849936128, 0.24733108839763107, 0.18093688187751567, 0.29566713639525855, 0.26890227448602677, 0.24612863186909995, 0.167524309347292, 0.29450148509629837, 0.1710279574779121, 0.2313372611429334, 0.2266952697734258, 0.24989559342906587, 0.2174533016709368, 0.2743272495005994, 0.21491667618247412, 0.19982073172970205, 0.23222777609086465, 0.20089071688655236, 0.19058317999319963, 0.18719961570067611, 0.19577012716524278, 0.21591480962179277, 0.22334328117939473, 0.7962259663357528, 0.1986448373133911, 0.17897287209015356, 0.7333016857878849, 0.21126410856549882, 0.7343680459419026, 0.15353821169714443, 0.1984295262050424, 0.25248434473758374, 0.25359830712823017, 0.11332931992156425, 0.113284313223046, 0.11330416442103974, 0.1693722516733327, 0.12689638446948392, 0.2064661200756316, 0.21311392035370025, 0.21166952389436533, 0.212335631006081, 0.21073997707389813, 0.1544647478474792, 0.19823908263440293, 0.18623870131082654, 0.19527406989695284, 0.20928054991421574, 0.1466856697036919, 0.18937417386199384, 0.18976888048229634, 0.22216717717179846, 0.19611396456820207, 0.15007813394767278, 0.0866337946951855, 0.10681296198768175, 0.10728485122689013, 0.08225075305674068, 0.08126984843447627, 0.09905264340778286, 0.0818123352705652, 0.0837082748503919, 0.08137741970686241]}, "mutation_prompt": null}
{"id": "5dbb3275-9213-4b8d-9b6b-4698e517ee80", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.mutation_history = []\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n            self.mutation_history.append(adjusted_mutation_factor)  # Log the mutation factor\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            # Dynamically scale mutation factor based on its history for improved adaptation\n            if len(self.mutation_history) > 5:\n                past_avg_mutation_factor = np.mean(self.mutation_history[-5:])\n                adjusted_mutation_factor *= 1 + 0.1 * (past_avg_mutation_factor - adjusted_mutation_factor)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive mutation factor scaling based on historical success rates to improve convergence speed.", "configspace": "", "generation": 89, "fitness": 0.3165841036725681, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "1c0f7959-e486-4950-8099-3dbdcbbe91ab", "metadata": {"aucs": [0.8636874412491417, 0.866263092365045, 0.8691337308493401, 0.8442004218686745, 0.8384374889457842, 0.8437142041335308, 0.8756241809032044, 0.8919673776018032, 0.8961748370825683, 0.804874547546377, 0.7633000759355034, 0.7443045920896953, 0.7482983195897451, 0.7572815923638415, 0.7914264823301504, 0.717332858106018, 0.7347818134680436, 0.760296399755459, 0.1259672060896121, 0.1248839609970257, 0.15238531722209903, 0.7051219300532872, 0.1365270519616537, 0.14559775818606302, 0.16066377187135694, 0.2025562348086396, 0.16548570945190788, 0.05310192547872139, 0.11773524351723441, 0.10863017892469995, 0.14910273060905532, 0.16870310187626614, 0.11744542545316328, 0.18498532739808715, 0.6684272049055084, 0.6241517972690602, 0.9763746136662124, 0.975594565967034, 0.9756052867928257, 0.9461069233014512, 0.9469343866511398, 0.9579498912883544, 0.9865821223915728, 0.9865831528706189, 0.986583004451702, 0.5681651468268852, 0.5653165848599719, 0.5430334027007725, 0.6193686843008546, 0.5537692793425746, 0.6423268734479743, 0.6624316187894632, 0.6586511148421677, 0.6703793376759838, 0.34525337278369117, 0.1696185004805546, 0.2130511203516413, 0.16172950265809982, 0.2717947085619814, 0.273188203494236, 0.36476725653776243, 0.29941358330455337, 0.6972493938888085, 0.42570673334071774, 0.32436028895001323, 0.4432986211230254, 0.332240561254477, 0.13471906682839785, 0.21889192732614182, 0.1325001114638088, 0.2954372029818233, 0.6493392118487997, 0.324870219004219, 0.19187746275878248, 0.25249847803323433, 0.5500855556456155, 0.3436202584587442, 0.29387056581543913, 0.2569131033509896, 0.31215347746522104, 0.2896624546212524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17586195398144988, 0.1657081539459574, 0.1806920791556953, 0.02407495007841498, 0.058773448039907805, 0.01819699148426701, 0.07385359205778441, 0.08981449039575617, 0.07836595660320878, 0.06836586075277007, 0.0826363018614722, 0.019284745044191753, 0.02191381300603501, 0.023349722705308107, 0.05901195293580097, 0.002481981961444779, 9.999999999998899e-05, 0.026566455677790368, 0.2630229742615544, 0.3472062567529306, 0.30872767180150273, 0.2863165377617869, 0.33493850876325537, 0.215858296218971, 0.05761018769522508, 0.24451730076055334, 0.2478891139796583, 0.608762855458383, 0.6610981463442984, 0.6156240893842064, 0.5636705444724533, 0.5626580680270907, 0.5467199487570815, 0.5289054060742138, 0.5750694663659721, 0.5467065322575759, 0.14237084524602905, 0.14564564246988887, 0.13482527765742414, 0.11594217844056531, 0.1668390745072773, 0.13559083431367092, 0.13152449408653288, 0.11764752906675746, 0.10547344013117743, 0.1300026150009992, 0.12997196621988083, 0.12688361946754123, 0.2550794799792151, 0.1885385006987388, 0.11198027818679823, 0.14844839044852487, 0.11398122988625514, 0.11538830772578457, 0.26470662291145886, 0.17665317312196116, 0.1417127176595233, 0.2592986457870097, 0.4197681000936535, 0.4128471030320082, 0.2531314073362054, 0.33272695486622883, 0.3383175482120965, 0.23737964830219194, 0.22655593188433654, 0.17553384847607156, 0.22112572042108358, 0.3060808800698951, 0.24352547514332945, 0.17774180138810303, 0.172985900368556, 0.17878702701517324, 0.18994446485404093, 0.2623841352424139, 0.1454710780186027, 0.1739762195018426, 0.2192809440577811, 0.19847830230859176, 0.16828028101598025, 0.20194470459001423, 0.21462922146222763, 0.20007221959119725, 0.18717374283807664, 0.19578164691949584, 0.2159138532525886, 0.2234046177576714, 0.7662886462506767, 0.1986756401360399, 0.17897055623267732, 0.7470807550498247, 0.211253031696374, 0.7964466490028745, 0.1535438034719656, 0.19843154091961535, 0.2524827676254402, 0.25359705687995304, 0.1133660717073739, 0.1132840867660232, 0.11328936029062897, 0.16933356640311992, 0.12692426844046223, 0.20646664075785015, 0.21309184136921233, 0.21155230235326195, 0.21232956631866207, 0.21074152367262944, 0.15445744315115806, 0.1982320783836411, 0.1991237037047373, 0.19530170188785945, 0.2094495156180236, 0.1466856697036919, 0.18939343670032038, 0.1968649116496488, 0.22226547301978283, 0.1960416438174859, 0.15009505932184242, 0.08656991319945795, 0.10667033252636016, 0.1071669363067771, 0.08220040360151992, 0.08132862885626113, 0.11192586012520567, 0.08182105204844992, 0.0836853117216968, 0.08629738197274384]}, "mutation_prompt": null}
{"id": "ec260d80-72c2-4b35-85c5-63113ba01d11", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate  # Added line for adaptive scaling\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Integrate adaptive learning rate scaling to enhance local exploration and convergence efficiency.", "configspace": "", "generation": 90, "fitness": 0.3297247077278683, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "1c0f7959-e486-4950-8099-3dbdcbbe91ab", "metadata": {"aucs": [0.8749262250521244, 0.8679686308834282, 0.8792157455321457, 0.8674437831875557, 0.8714569943904291, 0.853464008513888, 0.8414303568971716, 0.8885973931996473, 0.8669539275282339, 0.7802306057748212, 0.7334904894613505, 0.7560887003320921, 0.7529058989222783, 0.7816885259386801, 0.7854495497931849, 0.7672615377205003, 0.7408235879045084, 0.7627553096344346, 0.12594725289845554, 0.12235899893439106, 0.15797372518079722, 0.7068549871968445, 0.13608410985050867, 0.14528536757775457, 0.15299091920926688, 0.2679525669013112, 0.21772728846737432, 0.05310229139299483, 0.09959538639678844, 0.09294321965555097, 0.15309662117284661, 0.16589902340877283, 0.12249547110721393, 0.1822981068166799, 0.6277055994808921, 0.15255744421352524, 0.9763746145977298, 0.9755945705394251, 0.9756052920477959, 0.9465191891061658, 0.9591400486010792, 0.9607073162399797, 0.9865821226820636, 0.9865831531621363, 0.9865830047430714, 0.6101946980063488, 0.6224241999416835, 0.7024425838369079, 0.7023310463556396, 0.6516092036244239, 0.6202154764685286, 0.6512389533508236, 0.6148926442530114, 0.6793279900707181, 0.3630402240372216, 0.1696185004805546, 0.22377669431100278, 0.16172950265809982, 0.22829124446120064, 0.2124647427359111, 0.8017810092925293, 0.344546766688932, 0.6808792016102987, 0.43554139850701346, 0.5205198381962047, 0.5163139405961115, 0.38991140309812466, 0.13466636159624834, 0.48150767869283784, 0.1324416612243403, 0.3033347420469399, 0.6506704826489413, 0.3770868346839339, 0.29406776310591487, 0.42834950192760934, 0.5275523120332856, 0.4571314198925466, 0.46608820152740305, 0.25459708563657946, 0.5637844196640249, 0.4412140290488701, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17583422996628872, 0.17662488929190256, 0.20175123960938146, 0.024073605876059223, 0.055224694214675796, 0.02318460926320909, 0.0746093250107458, 0.08953718896073803, 0.07829327025082, 0.06602800521064078, 0.08297505776928771, 0.02826523793949076, 0.036504203698203175, 0.02149519922758647, 0.06930271858336856, 0.008513439423214586, 0.0594595857414717, 0.02609453965771058, 0.278549945300523, 0.20614651149490104, 0.2533667233568754, 0.3116728192227062, 0.224787010834263, 0.21546340064342018, 0.05749784679686687, 0.31785181520078154, 0.3217407346784138, 0.6280045280209702, 0.5992482372071322, 0.6517658539797189, 0.6031529065201947, 0.6091659587771825, 0.6242855385039809, 0.5327818406656828, 0.7675560970264523, 0.6024486107574034, 0.14232705275908597, 0.14600159805660184, 0.13388012396972593, 0.11645893261281981, 0.16710801026169297, 0.13552501092232505, 0.13153365695495978, 0.11773070404259978, 0.10583404794826423, 0.13050883376049183, 0.1299432231892126, 0.12683746171132537, 0.28112026262879075, 0.17414706955974235, 0.17468304083373054, 0.215427091746203, 0.11398252973288725, 0.11540176168049654, 0.2757948292276948, 0.1739646892573512, 0.14476647235779327, 0.2774037861389408, 0.3869948523707959, 0.29792984663073707, 0.24888088727530033, 0.3434542753108353, 0.3862480916079831, 0.2516828569012931, 0.2473320744981553, 0.18093794161298793, 0.29566197841410236, 0.2689021502262846, 0.24612951842217612, 0.16750384871351676, 0.29450171291475014, 0.17102759647628263, 0.23088403012530312, 0.2265551487268428, 0.24989570068354083, 0.21745312599556643, 0.27437641222772136, 0.1803679118150887, 0.19981575839790455, 0.23222783089428145, 0.20089102394202452, 0.19058325821921784, 0.1871996250901431, 0.19577018924370215, 0.21592301070938746, 0.22334327517483166, 0.7962249535605189, 0.19864401403976373, 0.1789744021174805, 0.7333022909587893, 0.21126421544627083, 0.7343669210289043, 0.15353820757440806, 0.19843154216138315, 0.25248494641349895, 0.25359858810319447, 0.11332931953462844, 0.11328431017985219, 0.11330416560221601, 0.16937223188275352, 0.12689641158487686, 0.20646591034195683, 0.21311390126943297, 0.21166950584393973, 0.21233561801064504, 0.2107400142002256, 0.15446477204890163, 0.19824007129491295, 0.18623874281938813, 0.19527407009713105, 0.20928057809681244, 0.1466856697036919, 0.18937417386199384, 0.18976884053432597, 0.22216669046490878, 0.19611391691172175, 0.15007855493825262, 0.08663374006095748, 0.10681476282157731, 0.10728521031794658, 0.08225104012886297, 0.08126982228820157, 0.09905274384306306, 0.08181241504975989, 0.08370792221463652, 0.0813774026533558]}, "mutation_prompt": null}
{"id": "3b58d2fc-bf80-4ce8-8980-a4d8187b177f", "solution": "import numpy as np\n\nclass EnhancedDEAMS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.population_size = self.initial_population_size\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        while self.budget > 0:\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            # Dynamically adjust population size\n            if self.success_rate < 0.2:\n                self.population_size = max(int(self.initial_population_size * 0.8), 5)\n            else:\n                self.population_size = min(int(self.initial_population_size * 1.2), self.budget)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS_V2", "description": "Introducing adaptive population size and dynamic mutation factor to enhance exploration and convergence.", "configspace": "", "generation": 91, "fitness": 0.259835598819008, "feedback": "The algorithm EnhancedDEAMS_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "ec260d80-72c2-4b35-85c5-63113ba01d11", "metadata": {"aucs": [0.8974064318331834, 0.8680101600908394, 0.8795483104783935, 0.21906570415550208, 0.8683319179302045, 0.9134726689499436, 0.38263831097679324, 0.1478757884098415, 0.3486980793845338, 0.8530225184177038, 0.78200859763856, 0.855575116928692, 0.8053070271388889, 0.8385930162871174, 0.6593357563206603, 0.800912753031184, 0.8133944679671712, 0.7267088543286138, 0.021084834245087003, 0.07573103590089647, 0.12003762718543842, 0.14145176770300882, 0.16986430227211224, 0.7422142474503495, 0.20267839944826382, 0.8409244465368901, 0.19232831387175842, 0.06108521372898035, 0.06446325673220488, 0.08169643048336328, 0.2317499276414916, 0.763280569083288, 0.10066049058365845, 0.3757256398742981, 0.18298507669433595, 0.1591638864200522, 0.986906864340934, 0.9869091393125885, 0.986908805519321, 0.981219561295387, 0.9792492140924923, 0.9792509593238269, 0.9713023874210157, 0.9728890410437064, 0.9723503133183964, 0.24464368240389478, 0.2527378463790405, 0.1714478966101517, 0.2636046782910918, 0.1732556905682321, 0.16487733661894066, 0.10943054564692833, 0.08798954940672488, 0.11364746968570694, 0.22033561981204042, 0.24373897784403975, 0.20802809402768874, 0.2129857691064354, 0.18531563705638165, 0.21206141843626103, 0.1406288310550322, 0.11142621994228341, 0.1916692043178152, 0.19140312220030298, 0.1459308729998624, 0.24987830409472445, 0.3014661893986641, 0.31347425380714045, 0.29595158789403675, 0.2393687059141255, 0.2475532606677543, 0.29509102978026047, 0.1306865975984285, 0.14109990592633714, 0.1499346871335998, 0.18954509787068874, 0.27170186775648175, 0.1682614504904526, 0.15784050176911946, 0.17619224013177004, 0.13561977741928344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0753052126178243, 0.0843961614607801, 0.07790941060347523, 0.03886026156751998, 0.04948183714476018, 0.04415666216511438, 0.04540241294101399, 0.08872991017411513, 0.040357648077399944, 0.07464040007515649, 9.999999999998899e-05, 0.05104762198888735, 0.05834797785874102, 0.05208192729324268, 0.05678238436517824, 0.04566108262738511, 0.028125862113210665, 0.05598592368265054, 0.06956033391234229, 0.040502092198259065, 0.042825856289056774, 0.1487889156098492, 9.999999999998899e-05, 0.01158397243665199, 0.15185771332638176, 0.11651178555707664, 0.11429699881417998, 0.38433345422958254, 0.43246446799415694, 0.38810131685473426, 0.42373836279449384, 0.44304871014003155, 0.4182647000716633, 0.5310125784252899, 0.5702296225915935, 0.5868500067960387, 0.10478037532403561, 0.16194970933964725, 0.09014637196586806, 0.1423086301169465, 0.1283829161829828, 0.13435970329393843, 0.1064786593712792, 0.10767283991628118, 0.09340037831769166, 0.28581168023426706, 0.16736397118908686, 0.24363559226844977, 0.12393452411544681, 0.10642421452730921, 0.17282983251562822, 0.216901647097673, 0.16005766508463315, 0.16202011581025766, 0.1865040619378281, 0.21668795787494932, 0.21754188067306712, 0.33330582054237423, 0.4565680957378173, 0.2200100097623826, 0.18265468286432773, 0.21416862435519468, 0.2759303494985017, 0.16671573790394645, 0.12611102987718692, 0.14793040140298053, 0.27644023067587664, 0.28090159763188405, 0.23946677401125638, 0.08248505453539023, 0.2316959042905442, 0.10553777912271922, 0.17844966656002959, 0.16824408559926518, 0.14856478732053424, 0.2258589738305683, 0.17791603844428372, 0.1931933756547093, 0.1845271911460743, 0.1515907535104405, 0.20191688945165198, 0.3722267388266248, 0.3524801965332678, 0.30562962139235217, 0.3041696963191979, 0.2454833198027273, 0.24710569196638088, 0.2448015286804438, 0.22047420712016041, 0.1958209711254083, 0.16719385830391953, 0.17111243179582214, 0.1716959304368626, 0.5125083056493063, 0.3212493185224785, 0.43262127559676145, 0.1757165698967056, 0.1682018727090181, 0.1538500275749941, 0.16933029782952813, 0.16821622299568628, 0.16822765133803785, 0.26617707111910627, 0.47172305874502685, 0.12663133084792444, 0.12297846072721874, 0.11303291840589735, 0.11603559661219565, 0.18414092524245163, 0.17048999529312636, 0.17790647001251214, 0.1928340951052503, 0.17515670261081673, 0.19112100258957765, 0.16433657902434518, 0.1757871123767376, 0.15228605177357168, 0.0717600987467828, 0.09039084797196117, 0.12199094199865745, 0.09106940077411907, 0.07503631984034764, 0.09685315451972387, 0.08760719781557547, 0.07804141528890796, 0.08842554551045834]}, "mutation_prompt": null}
{"id": "92da8e37-e874-4230-a1e8-df48f00d6a3a", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.last_improvement = 0  # New state to track iterations since last best fitness improvement\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n            \n            if self.best_fitness < np.mean(fitness):  # Modify mutation factor based on recent improvement\n                self.last_improvement = 0\n            else:\n                self.last_improvement += 1\n            adjusted_mutation_factor /= (1 + 0.01 * self.last_improvement)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Incorporate adaptive mutation scaling based on fitness improvement rate to enhance convergence speed.", "configspace": "", "generation": 92, "fitness": 0.3131553062011366, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "ec260d80-72c2-4b35-85c5-63113ba01d11", "metadata": {"aucs": [0.8555445202318782, 0.8791549343280607, 0.8470281171692221, 0.8451649966832433, 0.8660054176825608, 0.876371897927901, 0.22714573179044695, 0.871739752615643, 0.8631225205714779, 0.7685408587084377, 0.7493552982212421, 0.7432866294788122, 0.7800645048894077, 0.7943228319045242, 0.7796656305041578, 0.7260778487820777, 0.7547270651291138, 0.77341247891134, 0.08184515962760774, 0.13652753825783426, 0.12375994222292297, 0.223107432706376, 0.17075543918973968, 0.17981348319198276, 0.12645907951393287, 0.1691102700871574, 0.22765068405350308, 0.10045556085631668, 0.12487636807907898, 0.04543538558191851, 0.15723799502785096, 0.1763523153574742, 0.14557331799114603, 0.30343480585854155, 0.17176483157499445, 0.15122762777982968, 0.9756783109254396, 0.9759742321185336, 0.9759865589313838, 0.9487992046957191, 0.9601723770851343, 0.9475702623545792, 0.9865821750412137, 0.986583204099241, 0.9865830558840013, 0.6458444048577325, 0.6275442325546493, 0.5817476154787609, 0.6015076080800408, 0.6207046888149647, 0.6287432896292855, 0.7033663934745777, 0.6445016630027032, 0.6569834033915614, 0.3442208924190534, 0.22182837775459774, 0.2410380295557053, 0.1656902227622037, 0.21768791844853197, 0.36861567365899317, 0.6716466283397627, 0.22047576510663425, 0.6484606765034322, 0.5645272296787937, 0.49197295655909545, 0.32975210656440723, 0.13419739339736025, 0.5873943521976993, 0.13557665741690073, 0.40202290053001943, 0.2522688297613521, 0.5697327015235392, 0.31466200870158045, 0.2625956366908824, 0.27173619863373233, 0.3934720690079886, 0.5631353446738503, 0.5068888037340913, 0.3397167522344029, 0.13397543688063562, 0.47576709195691946, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16410646930770667, 0.12134191748975376, 0.18558996457736954, 0.024931130826036152, 0.04281634605599649, 0.029089779906364854, 0.06375827769907705, 0.059258446495902395, 0.056397001321485396, 0.032911586485752875, 0.1356711210586975, 0.0862762054265348, 0.09793726310864181, 0.14715536607232516, 0.05409407900500518, 0.02136677078471272, 9.999999999998899e-05, 0.00903438694452785, 0.20737232663768446, 0.2707963149914172, 0.24476699360211018, 0.2559155894259758, 0.26785901557715563, 0.18003644227174131, 0.24839660717906975, 0.3486899473199083, 0.2803968172536927, 0.5999502197402894, 0.6340551076715046, 0.6513510000659111, 0.5941045679950184, 0.5471259081266613, 0.6523808857051767, 0.6018193658268611, 0.6852329093812876, 0.5934137921609038, 0.10290837111627338, 0.10648746324095082, 0.11444507942897941, 0.12881469841452486, 0.12940679337600436, 0.11238273755992845, 0.09342425908373386, 0.09258351184786828, 0.08247884501901936, 0.20995103962187955, 0.13057026721710685, 0.1587136972821156, 0.2313646731610628, 0.1938498344430475, 0.18078109567466838, 0.176047146915283, 0.10359216773768365, 0.132504693764665, 0.15595173528276463, 0.2036790678733521, 0.276709524193655, 0.3573308929592608, 0.3100560363884406, 0.25653476216407956, 0.3880961867966114, 0.30077501999596745, 0.5067974891196014, 0.1863075802694939, 0.14121678170356333, 0.19469905193027148, 0.3101296008717581, 0.24748742772710164, 0.2621727415394398, 0.29382496007099923, 0.2937047834162535, 0.2337396671978491, 0.24872979739096024, 0.23314734374709822, 0.16950311798092932, 0.23407654511515197, 0.18282361301177275, 0.19017687123979787, 0.21978206766043806, 0.182968850701278, 0.24334464606370854, 0.2237651563950589, 0.20858562172898043, 0.2077270079805693, 0.20800039504707235, 0.2276809889625201, 0.24997322446816017, 0.23093014468310746, 0.7737282001431826, 0.20958440175060333, 0.14737097552799205, 0.1531637643489534, 0.1529815552688073, 0.2984740808753442, 0.18478267983693408, 0.18813532394955224, 0.16239739337416537, 0.11125469809326893, 0.11335993729686611, 0.17060682284418838, 0.2114335745814162, 0.2112382290296767, 0.21293517885639734, 0.211823122791594, 0.2123879100646201, 0.11825025356170804, 0.15581687009701184, 0.15580723480692793, 0.15430854394339222, 0.19584385679051763, 0.18541905758246746, 0.1630186061240343, 0.16655139977690847, 0.18533936733031853, 0.1477501128957519, 0.18350319765437673, 0.1747552614932818, 0.08273924682232625, 0.08646802472062487, 0.09851924244718269, 0.09061046767696135, 0.10280185199097136, 0.08172727927846168, 0.07697228081479368, 0.0755392138789277, 0.07696231344542726]}, "mutation_prompt": null}
{"id": "4bff3814-94ab-4386-b134-28537d969b14", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.improvement_rate = 0.0  # New attribute for improvement rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        initial_best_fitness = np.min(fitness)  # Capture initial best fitness\n\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            # Calculate improvement rate\n            current_best_fitness = np.min(fitness)\n            self.improvement_rate = (initial_best_fitness - current_best_fitness) / initial_best_fitness if initial_best_fitness != 0 else 0\n            adjusted_mutation_factor *= (1 + 0.1 * self.improvement_rate)  # Adjust mutation factor based on improvement rate\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Enhance efficiency by introducing mutation factor adaptation based on fitness improvement rate.", "configspace": "", "generation": 93, "fitness": 0.31315441038956493, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "ec260d80-72c2-4b35-85c5-63113ba01d11", "metadata": {"aucs": [0.888160071923878, 0.8758250345221091, 0.8966131762815106, 0.8704866350190732, 0.9081155605136078, 0.8569545495131238, 0.8651952282267394, 0.8574434966076211, 0.8784363357342653, 0.7879272903201326, 0.697444338422412, 0.7280048575677138, 0.7475384123232236, 0.7387602258935485, 0.6913727694315591, 0.7268889554182135, 0.7437380811318446, 0.7334051347505057, 0.1277919125739947, 0.11452992788027172, 0.09783996379653548, 0.11188154932581273, 0.16488151275611695, 0.31634727345817837, 0.13584601972674426, 0.18487799255539938, 0.15692337216468255, 0.09034598767126822, 0.18389007587108686, 0.17744884166472363, 0.19590970679772657, 0.1635028117974, 0.7276369534093137, 0.1663367021527884, 0.1682015393870121, 0.1762829497016648, 0.9764511774950362, 0.9763760001497889, 0.9763820551230168, 0.9464977185545949, 0.9501905000168296, 0.9575197083968188, 0.9865821226820636, 0.9865831531621363, 0.9865830047430714, 0.520068406421351, 0.5301236611489519, 0.5457686469698083, 0.6023870333843366, 0.6085647642479253, 0.5143137131533686, 0.5900799649281879, 0.47520058286885036, 0.5515337946538821, 0.22394959336971132, 0.22126687101709808, 0.1684956802514771, 0.1618333178264485, 0.20574571007592724, 0.19194762830480527, 0.6721590902394131, 0.6107898094386569, 0.7112990805088217, 0.42463903344088016, 0.46446559469582216, 0.4736534647727021, 0.13216047132756648, 0.47442401710119375, 0.37287868775564037, 0.4460487304614781, 0.649102009496046, 0.6705364816055488, 0.23889259349711423, 0.3332067210312907, 0.24606251860164585, 0.3167012903741323, 0.3497303084253096, 0.34268504980522796, 0.37321748832118173, 0.43759987470408246, 0.43264539565185467, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16992060288951416, 0.20129627913726045, 0.14191553025000414, 0.03332671822829403, 0.03285806413654768, 0.029000099214978925, 0.042935915625256005, 0.05376149738099778, 0.0688852180213626, 0.0374812501533448, 0.05608894439834944, 0.025075965757353713, 0.022096928499790947, 0.026448693231795217, 0.03875349468054101, 0.020288202432815705, 0.02057900850033567, 0.0011339120234673539, 0.2806440891981181, 0.23161935504440223, 0.2253141702551732, 0.31920282099156616, 0.27914589813822455, 0.2115790009686369, 0.07815483105539855, 0.07058277235785426, 0.037620657624749976, 0.6206139795341005, 0.5540696530665168, 0.5645145136187231, 0.5780844905274682, 0.7090809058783363, 0.5813979754466535, 0.6392273397880592, 0.5887738205205709, 0.5379717663524366, 0.08622562906483, 0.10104275439274224, 0.14401077770942794, 0.09453248694082372, 0.10666985326968847, 0.12076627806985474, 0.0846615815172087, 0.10187753566328539, 0.12186741169352588, 0.1949896947594153, 0.12813957870617254, 0.0970212675081924, 0.10803470557888217, 0.210932326528804, 0.20594561013150392, 0.1614062381427882, 0.11520688649447819, 0.11465677588582512, 0.2068032419787461, 0.2250849052498407, 0.1522347494221178, 0.22889151655840356, 0.2729172762022952, 0.23399909388315587, 0.37839056615895095, 0.3806003205456361, 0.3894543611890787, 0.13085948159352012, 0.15337134751435255, 0.16609575080827965, 0.23684992438107688, 0.19405784611277765, 0.18799439170166132, 0.2704986778552736, 0.3470167464535946, 0.2615694004454324, 0.1932315927430608, 0.24995679036597018, 0.20258727286369205, 0.23368576890609827, 0.23373604468595677, 0.19650845158448382, 0.23705405068535224, 0.17243204931461897, 0.18614282655169967, 0.22415557278705822, 0.21962582320943624, 0.20412201775676464, 0.20630865820083055, 0.20069868249911482, 0.19193872971301096, 0.1888490398449998, 0.2023512802385078, 0.22992487427827057, 0.8672495590171306, 0.8328343114507664, 0.153196725137981, 0.33541467147914805, 0.22679285795714854, 0.19547242210566862, 0.11331699410235396, 0.1131656827512888, 0.11340031259628902, 0.17091340411016176, 0.12693102965069702, 0.21234445976090133, 0.21310374846283398, 0.21234054864223662, 0.21246210769778495, 0.10624132427618038, 0.1177043220208398, 0.11172377512932052, 0.18249449419322428, 0.20673027017930912, 0.18777335322794408, 0.19803924992775457, 0.20404148630454577, 0.19884205312634384, 0.21555226437709385, 0.16314551403061395, 0.18048545799906734, 0.10110540277348612, 0.09576724601228848, 0.1123724157660334, 0.11317080701946358, 0.07667254168234972, 0.09462886525632497, 0.10413451057269307, 0.09486114225918607, 0.07846866532710972]}, "mutation_prompt": null}
{"id": "8d60bde0-115e-48a4-936b-6b0640e60583", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.fitness_memory = []  # Added attribute\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n            \n            # Adaptive mutation based on fitness variance\n            adaptive_mutation_adjustment = np.tanh(fitness_variance - 0.5 * fitness_trend)\n            adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * adaptive_mutation_adjustment)\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate  # Adaptive scaling\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Integrate adaptive mutation and crossover adjustments based on fitness variance for improved convergence.", "configspace": "", "generation": 94, "fitness": 0.3078874238915373, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "ec260d80-72c2-4b35-85c5-63113ba01d11", "metadata": {"aucs": [0.9030492183905555, 0.8808646671975912, 0.906444486746947, 0.9102650353220287, 0.9131286904112376, 0.9006225369302274, 0.8621679704502718, 0.8679411314221888, 0.8708112007100413, 0.7183698432365659, 0.7904371531942274, 0.761581497961831, 0.7797504023790292, 0.7632220506016608, 0.7925488066643296, 0.7499055102309133, 0.7348471009580892, 0.7438446178171662, 0.09673194773878802, 0.12224281392019853, 0.18958909979917382, 0.14510728664158046, 0.1824314414171918, 0.15018100593202, 0.13713197772222774, 0.3017132928547197, 0.340971625653265, 0.06377565793304729, 0.16592391989187216, 0.050363491065431476, 0.1196474330171593, 0.12723106373520054, 0.10126701569151353, 0.1741930104845032, 0.1355388954558997, 0.1403758426403403, 0.9763788929791275, 0.9756113451400843, 0.9756248628735958, 0.9258462114051125, 0.9487135042066953, 0.9316020822013513, 0.986581787566208, 0.9865827415964212, 0.9865826040600298, 0.5467971190409624, 0.6173317274921832, 0.7103275230414869, 0.5934108681866281, 0.6331722395582763, 0.6488739016987509, 0.6053066530449083, 0.6472418389143291, 0.6286188814440131, 0.1946521612270261, 0.22612225112736628, 0.10880478485274947, 0.16187833820761444, 0.34984155942515727, 0.2631781001469684, 0.3582791334288744, 0.34017691782245363, 0.779119872948301, 0.4397765672536591, 0.30134427298045996, 0.2770363745069855, 0.46954277608902684, 0.39223755691356543, 0.3812029784671166, 0.26783075268539724, 0.23755008705710956, 0.13559369566557167, 0.20907847552829273, 0.23428980913944286, 0.1306248980567618, 0.27600109406816287, 0.3303507153501729, 0.2637273152247228, 0.2643219442903635, 0.17692069503154895, 0.1901472012421357, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.101690733867563, 0.13009179306192598, 0.11900441888785884, 0.03458523737510533, 0.026538019691034198, 0.024721091166571063, 0.04820740979858107, 0.05508739914909311, 0.10343312706124597, 0.05289631666771, 0.035221920592102274, 0.05495933485385318, 0.07912132620817647, 0.10042016033387502, 0.021315139974800168, 0.0056424453988571655, 9.999999999998899e-05, 0.002358592116637137, 0.2864590565387334, 0.20211804499807362, 0.32337049367352255, 0.27726117630899205, 0.19721338380737297, 0.20247505328417192, 0.19135018889913757, 0.22866477336002622, 0.315899020483412, 0.7574860420547254, 0.6029795659350752, 0.6223123027916919, 0.5564353874005514, 0.6160752984941134, 0.604750705384384, 0.6021580578144875, 0.49001353829878513, 0.581961592129243, 0.12512083027550325, 0.08785532690759412, 0.0866095125981603, 0.1075262964719963, 0.10417668983263062, 0.12735394711695713, 0.09145409620890987, 0.0849329711323622, 0.11030220277111491, 0.17037707274017944, 0.16644973753269765, 0.1651818438095476, 0.11424030773809368, 0.2936327072135283, 0.20337942064148773, 0.12732440971759806, 0.10091067716392266, 0.2465295751476877, 0.18344794092980365, 0.24964103379278524, 0.20047476612339854, 0.3458516622918737, 0.25547992518385076, 0.3516492793755531, 0.31224085381140454, 0.40546394393637264, 0.34902041468508127, 0.164614150330466, 0.16782097332361012, 0.1655895948013133, 0.35521820235029544, 0.1847028701850173, 0.1808513728585046, 0.442251310162199, 0.295513178449184, 0.24680710066701994, 0.2176836056727478, 0.31538327773594166, 0.18712692015424848, 0.15561169918547968, 0.20122764447792707, 0.18285447886803818, 0.22105311252087934, 0.19713726024620593, 0.1783378584063714, 0.20074106478432918, 0.19549298664433523, 0.22316391358986654, 0.2228945574345763, 0.1979478409252834, 0.17843048700079667, 0.7635957865489928, 0.20761058673000976, 0.2507231014282705, 0.20317083703030958, 0.18581808229252705, 0.1532221487825569, 0.25859810296416064, 0.26671427896240296, 0.2831109759985331, 0.11335800479531732, 0.11327758977695501, 0.11337559315714407, 0.16866509231024807, 0.16920175951701844, 0.1689858958307474, 0.21235765386351502, 0.20928362593607075, 0.21206743671074457, 0.21062869796515493, 0.7829189354823134, 0.15547015552326449, 0.1728246590151271, 0.17347047945090577, 0.16642318105887532, 0.17899490493456194, 0.18788981627558543, 0.17645218689728193, 0.22980873703744154, 0.2360796076716838, 0.23076480867697013, 0.08058944990662442, 0.08296673898682405, 0.09386735454205497, 0.09368569121650194, 0.09583861997320653, 0.08742510673577686, 0.0817456150219541, 0.08423626228748637, 0.06965109008452441]}, "mutation_prompt": null}
{"id": "4146ce1e-3e39-4d8f-93b1-34a7d8b123ac", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n            \n            # Immediate reward adjustment based on fitness improvement\n            immediate_reward = 0.1 * (self.best_fitness / np.mean(fitness))\n            adjusted_mutation_factor *= 1 + immediate_reward\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate  # Added line for adaptive scaling\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Incorporate an immediate reward mechanism to adjust the mutation factor dynamically based on improvement within each iteration.", "configspace": "", "generation": 95, "fitness": 0.08773480214865993, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.20.", "error": "", "parent_id": "ec260d80-72c2-4b35-85c5-63113ba01d11", "metadata": {"aucs": [0.08143913318320906, 0.08143913318320906, 0.08143913318320906, 0.13159081564043495, 0.13159081564043495, 0.13159081564043495, 0.09170558433610787, 0.09170558433610787, 0.09170558433610787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03914005819120758, 0.03914005819120758, 0.03914005819120758, 0.03302562040494372, 0.03302562040494372, 0.03302562040494372, 0.04645312376290334, 0.04645312376290334, 0.04645312376290334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.9892213676004427, 0.9892213676004427, 0.9892213676004427, 0.9855850650578012, 0.9855850650578012, 0.9855850650578012, 0.9851138714642615, 0.9851138714642615, 0.9851138714642615, 0.02144434968053688, 0.02144434968053688, 0.02144434968053688, 0.0203890925081176, 0.0203890925081176, 0.0203890925081176, 0.08669909383502805, 0.08669909383502805, 0.08669909383502805, 0.02004102848654077, 0.02004102848654077, 0.02004102848654077, 0.11245356098428616, 0.11245356098428616, 0.11245356098428616, 0.029318875281848844, 0.029318875281848844, 0.029318875281848844, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011080381568064679, 0.011080381568064679, 0.011080381568064679, 0.03127531617645696, 0.03127531617645696, 0.03127531617645696, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0, 0.0, 0.0, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11688446184255896, 0.11688446184255896, 0.11688446184255896, 0.09622392263345192, 0.09622392263345192, 0.09622392263345192, 0.11517566326669182, 0.11517566326669182, 0.11517566326669182, 0.0207578667925582, 0.0207578667925582, 0.0207578667925582, 0.02310919071154005, 0.02310919071154005, 0.02310919071154005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15758141940742043, 0.15758141940742043, 0.15758141940742043, 0.07683228595023706, 0.07683228595023706, 0.07683228595023706, 0.13244798636982102, 0.13244798636982102, 0.13244798636982102, 0.11453542693410068, 0.11453542693410068, 0.11453542693410068, 0.12985569223139792, 0.12985569223139792, 0.12985569223139792, 0.08547589678363143, 0.08547589678363143, 0.08547589678363143, 0.03210351472335993, 0.03210351472335993, 0.03210351472335993, 0.04475820100751571, 0.04475820100751571, 0.04475820100751571, 0.0370822440335038, 0.0370822440335038, 0.0370822440335038, 0.06652944125908256, 0.06652944125908256, 0.06652944125908256, 0.11183501183362099, 0.11183501183362099, 0.11183501183362099, 0.10283366598084509, 0.10283366598084509, 0.10283366598084509, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12815557347807138, 0.12815557347807138, 0.12815557347807138, 0.14474050849599573, 0.14474050849599573, 0.14474050849599573, 0.07391429025805851, 0.07391429025805851, 0.07391429025805851, 0.03788433045839734, 0.03788433045839734, 0.03788433045839734, 0.07655209194228174, 0.07655209194228174, 0.07655209194228174, 0.11153464353622655, 0.11153464353622655, 0.11153464353622655, 0.20655549751738267, 0.20655549751738267, 0.20655549751738267, 0.16760738218778426, 0.16760738218778426, 0.16760738218778426, 0.15280029058847044, 0.15280029058847044, 0.15280029058847044, 0.02156157306438633, 0.02156157306438633, 0.02156157306438633, 0.004759007341992416, 0.004759007341992416, 0.004759007341992416, 0.008342335910938026, 0.008342335910938026, 0.008342335910938026]}, "mutation_prompt": null}
{"id": "f44a2167-a83b-4486-adf6-f634a49b9e5a", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n            stochastic_scaling = 1.0 + 0.05 * np.random.randn()  # Added line for stochastic scaling\n            adjusted_mutation_factor *= stochastic_scaling\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Incorporate stochastic scaling in mutation to enhance exploration while maintaining controlled convergence.", "configspace": "", "generation": 96, "fitness": 0.33146845829074084, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "ec260d80-72c2-4b35-85c5-63113ba01d11", "metadata": {"aucs": [0.8679012123733749, 0.858075673848654, 0.8558485867146448, 0.8662441661764766, 0.8963260087608695, 0.868788115116538, 0.8588330043647303, 0.8618537866261824, 0.26616956587500584, 0.7640834628134596, 0.7604063654563444, 0.767433518819537, 0.8142220171217125, 0.7621145031337107, 0.7674450631175168, 0.7735894617928246, 0.7201970054569122, 0.787220748635748, 0.1491796267955724, 0.13961319128989202, 0.17760196763821334, 0.1990146642601499, 0.7036871434107459, 0.21985898918822233, 0.165988994472677, 0.6483560077666812, 0.1834493946636807, 0.014923947618881384, 0.08688733795774328, 0.028619185491523758, 0.1611249640225988, 0.17358899965471608, 0.6960244448851101, 0.19676977092781966, 0.14344784258256027, 0.6009019521979015, 0.9790841098348847, 0.97909353670004, 0.9790935972156785, 0.9828121957616179, 0.9832158875916067, 0.9832109257602641, 0.9417661085853286, 0.958201978074987, 0.9260856082453403, 0.5557228270314301, 0.6492072366419656, 0.623537967990877, 0.6157397999196494, 0.6890455734666815, 0.6043346564580374, 0.08857096139611675, 0.1097112615723912, 0.10433333535893052, 0.38214144868416466, 0.2266608962005947, 0.7865616845778571, 0.856519803450314, 0.3170237033942691, 0.16123018166704572, 0.7534052943127587, 0.3458929614265239, 0.269632628762393, 0.43966088958119987, 0.3500031880014892, 0.5831744184740217, 0.1336336668912037, 0.409421327899544, 0.5065970505824737, 0.6377952730617416, 0.3880408484466935, 0.5207613944894656, 0.3496296716353744, 0.3209843915072975, 0.13067446168996044, 0.3657242194945981, 0.3301216954582711, 0.39565262147438385, 0.39983910743710716, 0.3242492277235677, 0.13278675857479827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1139249380975611, 0.21595259780165266, 0.17279835306166735, 0.04621724274402095, 0.0336509985765695, 0.029868387344844316, 0.07760808175840161, 0.08488140697177149, 0.09556403552983561, 9.999999999998899e-05, 0.0024797139872362317, 9.999999999998899e-05, 0.07190835056583333, 0.0669278228633371, 0.07969743243425087, 0.0029143833009528386, 0.012326742779358746, 0.002508035508255624, 0.3329189069848332, 0.27988347433052785, 0.31606271060105295, 0.25588154470377444, 0.24102626691100948, 0.21467073478935672, 0.08078018227714534, 0.23703612703397536, 0.21744322145586115, 0.5672292153884155, 0.6618850321346086, 0.6107288423948822, 0.6878929132308722, 0.64784624265241, 0.5420480420999922, 0.6670768511154492, 0.6341769961853545, 0.7346708825172157, 0.0915007800318468, 0.11144892819802876, 0.1161464661240017, 0.14337749713966097, 0.12354965372672577, 0.11965578488358275, 0.1393122293193808, 0.0641690112066935, 0.10441192574343072, 0.27545114746738175, 0.16278070822542268, 0.14053863493653207, 0.7837117584939579, 0.7232485445718655, 0.2875945523702037, 0.23840391077237533, 0.1412762488599264, 0.18998832617366535, 0.44336353260100825, 0.26011409250486994, 0.3760779095604133, 0.3451745326715244, 0.36628092960085556, 0.30419873369087114, 0.27473022177477957, 0.5343696043752847, 0.24614051251954516, 0.15910360900852116, 0.1782727055881873, 0.13929631935291142, 0.2092880517911262, 0.2779621761548017, 0.2909022777737409, 0.17306690152105042, 0.2981248395446966, 0.22782547403819342, 0.17215460034892927, 0.2032807547403659, 0.23274885878120022, 0.18916411108104403, 0.20111720970039926, 0.20155193676428484, 0.19899946387775524, 0.18698308084120818, 0.1969924247938859, 0.1972112822504618, 0.20796003799616813, 0.7682402334785129, 0.18970663431397394, 0.208192797335779, 0.2070192530645949, 0.18781711266742795, 0.7375501848344619, 0.18638203395143627, 0.9018982218135478, 0.12605809986338024, 0.1259360912906925, 0.3300551217718847, 0.23562668958016852, 0.18265546794330545, 0.13662799416037574, 0.13663840914551728, 0.12329488580913583, 0.20889365751951727, 0.21137483005762492, 0.2126096413955635, 0.12824440077861177, 0.2096565883682905, 0.12801531982334347, 0.11168745367994348, 0.20133687710939063, 0.19861326429213932, 0.19697579868046888, 0.1947038981879553, 0.21017314440441415, 0.1731824562016827, 0.18878778096731152, 0.19619931527048862, 0.2001873362464286, 0.16579467765900335, 0.1899470217278073, 0.07738939776887144, 0.10134496242131086, 0.09266088169738762, 0.10628434487066696, 0.08963561010145149, 0.09881379416428826, 0.09157582829690114, 0.08841133791197375, 0.07600206301408252]}, "mutation_prompt": null}
{"id": "31b0f567-25d1-4e18-9030-38079f985b4c", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n        self.elite_rate = 0.1  # New line for elite selection\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adjusted_mutation_factor *= (1 + 0.05 * self.success_rate)\n            stochastic_scaling = 1.0 + 0.05 * np.random.randn()\n            adjusted_mutation_factor *= stochastic_scaling\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n            \n            elite_count = int(self.elite_rate * self.population_size)  # Calculate elite count\n            elite_indices = np.argsort(fitness)[:elite_count]  # Get indices of elite solutions\n\n            for i in range(self.population_size):\n                if i in elite_indices:  # Skip mutation for elite solutions\n                    continue\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Add elite selection strategy to retain top-performing individuals across generations for better convergence.", "configspace": "", "generation": 97, "fitness": 0.33146845829074084, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "f44a2167-a83b-4486-adf6-f634a49b9e5a", "metadata": {"aucs": [0.8679012123733749, 0.858075673848654, 0.8558485867146448, 0.8662441661764766, 0.8963260087608695, 0.868788115116538, 0.8588330043647303, 0.8618537866261824, 0.26616956587500584, 0.7640834628134596, 0.7604063654563444, 0.767433518819537, 0.8142220171217125, 0.7621145031337107, 0.7674450631175168, 0.7735894617928246, 0.7201970054569122, 0.787220748635748, 0.1491796267955724, 0.13961319128989202, 0.17760196763821334, 0.1990146642601499, 0.7036871434107459, 0.21985898918822233, 0.165988994472677, 0.6483560077666812, 0.1834493946636807, 0.014923947618881384, 0.08688733795774328, 0.028619185491523758, 0.1611249640225988, 0.17358899965471608, 0.6960244448851101, 0.19676977092781966, 0.14344784258256027, 0.6009019521979015, 0.9790841098348847, 0.97909353670004, 0.9790935972156785, 0.9828121957616179, 0.9832158875916067, 0.9832109257602641, 0.9417661085853286, 0.958201978074987, 0.9260856082453403, 0.5557228270314301, 0.6492072366419656, 0.623537967990877, 0.6157397999196494, 0.6890455734666815, 0.6043346564580374, 0.08857096139611675, 0.1097112615723912, 0.10433333535893052, 0.38214144868416466, 0.2266608962005947, 0.7865616845778571, 0.856519803450314, 0.3170237033942691, 0.16123018166704572, 0.7534052943127587, 0.3458929614265239, 0.269632628762393, 0.43966088958119987, 0.3500031880014892, 0.5831744184740217, 0.1336336668912037, 0.409421327899544, 0.5065970505824737, 0.6377952730617416, 0.3880408484466935, 0.5207613944894656, 0.3496296716353744, 0.3209843915072975, 0.13067446168996044, 0.3657242194945981, 0.3301216954582711, 0.39565262147438385, 0.39983910743710716, 0.3242492277235677, 0.13278675857479827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1139249380975611, 0.21595259780165266, 0.17279835306166735, 0.04621724274402095, 0.0336509985765695, 0.029868387344844316, 0.07760808175840161, 0.08488140697177149, 0.09556403552983561, 9.999999999998899e-05, 0.0024797139872362317, 9.999999999998899e-05, 0.07190835056583333, 0.0669278228633371, 0.07969743243425087, 0.0029143833009528386, 0.012326742779358746, 0.002508035508255624, 0.3329189069848332, 0.27988347433052785, 0.31606271060105295, 0.25588154470377444, 0.24102626691100948, 0.21467073478935672, 0.08078018227714534, 0.23703612703397536, 0.21744322145586115, 0.5672292153884155, 0.6618850321346086, 0.6107288423948822, 0.6878929132308722, 0.64784624265241, 0.5420480420999922, 0.6670768511154492, 0.6341769961853545, 0.7346708825172157, 0.0915007800318468, 0.11144892819802876, 0.1161464661240017, 0.14337749713966097, 0.12354965372672577, 0.11965578488358275, 0.1393122293193808, 0.0641690112066935, 0.10441192574343072, 0.27545114746738175, 0.16278070822542268, 0.14053863493653207, 0.7837117584939579, 0.7232485445718655, 0.2875945523702037, 0.23840391077237533, 0.1412762488599264, 0.18998832617366535, 0.44336353260100825, 0.26011409250486994, 0.3760779095604133, 0.3451745326715244, 0.36628092960085556, 0.30419873369087114, 0.27473022177477957, 0.5343696043752847, 0.24614051251954516, 0.15910360900852116, 0.1782727055881873, 0.13929631935291142, 0.2092880517911262, 0.2779621761548017, 0.2909022777737409, 0.17306690152105042, 0.2981248395446966, 0.22782547403819342, 0.17215460034892927, 0.2032807547403659, 0.23274885878120022, 0.18916411108104403, 0.20111720970039926, 0.20155193676428484, 0.19899946387775524, 0.18698308084120818, 0.1969924247938859, 0.1972112822504618, 0.20796003799616813, 0.7682402334785129, 0.18970663431397394, 0.208192797335779, 0.2070192530645949, 0.18781711266742795, 0.7375501848344619, 0.18638203395143627, 0.9018982218135478, 0.12605809986338024, 0.1259360912906925, 0.3300551217718847, 0.23562668958016852, 0.18265546794330545, 0.13662799416037574, 0.13663840914551728, 0.12329488580913583, 0.20889365751951727, 0.21137483005762492, 0.2126096413955635, 0.12824440077861177, 0.2096565883682905, 0.12801531982334347, 0.11168745367994348, 0.20133687710939063, 0.19861326429213932, 0.19697579868046888, 0.1947038981879553, 0.21017314440441415, 0.1731824562016827, 0.18878778096731152, 0.19619931527048862, 0.2001873362464286, 0.16579467765900335, 0.1899470217278073, 0.07738939776887144, 0.10134496242131086, 0.09266088169738762, 0.10628434487066696, 0.08963561010145149, 0.09881379416428826, 0.09157582829690114, 0.08841133791197375, 0.07600206301408252]}, "mutation_prompt": null}
{"id": "7e0f3d46-4cb5-4d8f-8bc6-7558384c04b2", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n            \n            adaptive_scaling = 1 + 0.05 * np.tanh(self.success_rate)  # Modified line for adaptive scaling based on success rate\n            adjusted_mutation_factor *= adaptive_scaling\n            stochastic_scaling = 1.0 + 0.05 * np.random.randn()\n            adjusted_mutation_factor *= stochastic_scaling\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduce adaptive learning rate scaling based on success rate to refine mutation factor adjustments.", "configspace": "", "generation": 98, "fitness": 0.33117556067912635, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "f44a2167-a83b-4486-adf6-f634a49b9e5a", "metadata": {"aucs": [0.8679012757906326, 0.858293926241372, 0.8562799585511829, 0.8662440875095325, 0.8963260367819708, 0.8714470680576556, 0.8588334723569913, 0.8618540615250909, 0.2661695658758374, 0.7628204536181095, 0.7600188352726754, 0.7734196960621967, 0.8153676021337577, 0.7787896224288136, 0.7674447186593185, 0.7735989015879035, 0.7136108886650592, 0.7888651200086456, 0.14917962692752784, 0.1396131912805234, 0.17760196768237746, 0.1990146642938081, 0.7036886164127982, 0.21985898902977752, 0.16598899441020043, 0.6483550366075629, 0.18344939512339153, 0.014923947619266964, 0.0868873379721945, 0.02861918549342335, 0.16112496386609765, 0.1735889996570309, 0.6960221390125778, 0.18181238765321606, 0.14344784257794507, 0.6009015684742047, 0.9790841098348849, 0.9790935367000401, 0.9790935972156787, 0.982812195761618, 0.9832158875916067, 0.9832109257602641, 0.9417661085842174, 0.9582019780749588, 0.9260856082320311, 0.5576213310644951, 0.6501091353260879, 0.6299611318985336, 0.6052389002751564, 0.6839688070120481, 0.5906403684833419, 0.08857096139612475, 0.10971126157242639, 0.10433333535875422, 0.38214144868416466, 0.2266608962005947, 0.7865616845778571, 0.856519803450314, 0.3170237033942691, 0.16123018166704572, 0.7534052943127587, 0.3458929614265239, 0.269632628762393, 0.4360118095198331, 0.35000316877038395, 0.5831738347050535, 0.13363370115439388, 0.40942127458842625, 0.5163469807320323, 0.6377948616735769, 0.41409742266751803, 0.5207605991415888, 0.3459329077581109, 0.32096910883626073, 0.13067446169001995, 0.34945455810458637, 0.33113772719632384, 0.3957878521138506, 0.400663278979528, 0.30567541293129774, 0.13278663837099924, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11392493815099136, 0.21561791798445729, 0.17279835221418127, 0.046217242742869535, 0.03365099858489706, 0.02986838735304087, 0.07760808192828894, 0.0848814066143887, 0.09556403497696231, 9.999999999998899e-05, 0.0024797161659789735, 9.999999999998899e-05, 0.07190835038799581, 0.06692781116941826, 0.07969743264727513, 0.002914383045398816, 0.01232674094836439, 0.0025080357625821836, 0.3348833942993358, 0.27988378055960705, 0.316063664750048, 0.2017222148000828, 0.2410244372153033, 0.21650962412245867, 0.08079242187865643, 0.24255177058393895, 0.21746892526218342, 0.5672292064534085, 0.6746973244762451, 0.6107806918024443, 0.6884425912712075, 0.6452051417889606, 0.5490875692897896, 0.6109365913979546, 0.6341727981084764, 0.7615982100165548, 0.09150078014444374, 0.11144892819442997, 0.11614646612387447, 0.1433774971615721, 0.12354965372495863, 0.11965578487886164, 0.13931223119632918, 0.06416901120686702, 0.10441192589947423, 0.2754483737700538, 0.1627807092091107, 0.14053863494231877, 0.783711732540405, 0.7232486001013281, 0.2875945456735187, 0.23840391182336396, 0.14127624746430534, 0.18998833011927252, 0.44333475265581945, 0.2601140923764187, 0.3760782243044025, 0.3451745325875999, 0.3662522062118173, 0.3042043864363727, 0.27472967075155175, 0.5344033029572561, 0.24614051236670997, 0.15910360902271337, 0.17827270559722241, 0.13929631935896325, 0.20928896124556662, 0.2779621416562531, 0.29090229045611116, 0.1857282732874852, 0.2981275388513627, 0.22782410748158388, 0.1721546008584024, 0.20328075442157123, 0.23274885877017526, 0.1891641108721246, 0.20111720984417647, 0.20155193985615782, 0.1989994649071487, 0.1869830809214671, 0.19699242742801282, 0.19721128225262397, 0.20796003799555574, 0.7651085364875738, 0.189706634314314, 0.20819279733081053, 0.20701925306490543, 0.187817112947688, 0.737547281332578, 0.1863820337320149, 0.9018982218433919, 0.12605809986338024, 0.1259360912906925, 0.3300551217862443, 0.23562668961511357, 0.1826554679453254, 0.13662799417233162, 0.13663840914621617, 0.12329488580913295, 0.20889365752007338, 0.21137483005766966, 0.21260964139559013, 0.12824440077860344, 0.20965658836840617, 0.12801531982336034, 0.11168745367999233, 0.2013368771094457, 0.19861326429164494, 0.1969757985910755, 0.19470389818795086, 0.21017314396591646, 0.17318245620207295, 0.18878778105296445, 0.19619931526963008, 0.2001873360738713, 0.16579467767659262, 0.1926153409571042, 0.07738939776933873, 0.10134496242145397, 0.09266088169054054, 0.106284344772268, 0.08963561002359588, 0.09881379367102927, 0.09157582829943, 0.08841133791009925, 0.0760020630163557]}, "mutation_prompt": null}
{"id": "f1449d1c-4f17-4e6f-93e5-2f2453846277", "solution": "import numpy as np\n\nclass EnhancedDEAMS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = int(5 + np.floor(2.8 * np.log(self.dim)))\n        self.mutation_factor = 0.8 + 0.1 * np.random.rand()\n        self.crossover_rate = 0.9\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.max_local_search_iter = 5\n        self.successful_mutations = []\n        self.success_rate = 0.0\n        self.successful_trials = 0\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.budget -= self.population_size\n\n        dynamic_crossover_rate = self.crossover_rate\n        for _ in range(self.budget):\n            fitness_variance = np.var(fitness)\n            fitness_trend = np.mean(fitness) / np.std(fitness)\n            population_dispersion = np.mean(np.std(population, axis=0))\n\n            if self.successful_mutations:\n                avg_successful_mutation = np.mean(self.successful_mutations)\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * avg_successful_mutation)\n            else:\n                adjusted_mutation_factor = self.mutation_factor * (1 + self.learning_rate * np.tanh(fitness_variance - fitness_trend))\n\n            # Introduced adaptive adjustment to the learning rate based on success rate\n            adaptive_learning_rate = self.learning_rate * (1 + 0.1 * np.random.rand())\n            adjusted_mutation_factor *= (1 + adaptive_learning_rate * self.success_rate)\n\n            stochastic_scaling = 1.0 + 0.05 * np.random.randn()\n            adjusted_mutation_factor *= stochastic_scaling\n\n            if population_dispersion < self.diversity_threshold:\n                adjusted_mutation_factor *= 1.2\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + adjusted_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(adjusted_mutation_factor)\n                    self.successful_trials += 1\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        if self.budget > 0:\n                            self._local_search(func, trial)\n\n            self.success_rate = self.successful_trials / (self.population_size * self.budget)\n            dynamic_crossover_rate = 0.9 * (self.best_fitness / np.mean(fitness)) * (1 + 0.15 * self.success_rate)\n\n        return self.best_solution\n\n    def _local_search(self, func, solution):\n        current_solution = solution.copy()\n        current_fitness = func(current_solution)\n\n        for _ in range(self.max_local_search_iter):\n            for d in range(self.dim):\n                if self.budget <= 0:\n                    break\n                adaptive_step_size = (self.upper_bound - self.lower_bound) * (0.05 + 0.05 * np.random.rand()) * (1 + self.success_rate)\n                adaptive_step_size *= 1 + 0.1 * self.success_rate\n                neighbor = current_solution.copy()\n                neighbor[d] += np.random.uniform(-adaptive_step_size, adaptive_step_size)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n\n                if neighbor_fitness < current_fitness:\n                    current_solution = neighbor\n                    current_fitness = neighbor_fitness\n                    if neighbor_fitness < self.best_fitness:\n                        self.best_fitness = neighbor_fitness\n                        self.best_solution = neighbor\n\n                self.budget -= 1", "name": "EnhancedDEAMS", "description": "Introduced adaptive learning rate to improve the balance between exploration and exploitation.", "configspace": "", "generation": 99, "fitness": 0.3382177111438129, "feedback": "The algorithm EnhancedDEAMS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "f44a2167-a83b-4486-adf6-f634a49b9e5a", "metadata": {"aucs": [0.8596641311242801, 0.846080697675309, 0.8508615978372343, 0.8775839590130814, 0.8886966618273449, 0.8592558265019306, 0.8543707552227446, 0.8793243411494037, 0.8606479337019881, 0.7761150130181207, 0.7496418769936629, 0.7278003986108819, 0.7569919770028954, 0.7110443699148192, 0.7994076221689712, 0.7766320373493412, 0.7887813170012388, 0.7752940498908569, 0.14223762926313033, 0.07642807083130121, 0.053462367460519244, 0.15310677646182247, 0.18210632431807006, 0.18701011206409612, 0.20811253954827857, 0.19218181726146744, 0.21083838060590165, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.20048019571967512, 0.16366105607938586, 0.656692968619262, 0.16492145334523645, 0.2191202207280437, 0.18141027379827046, 0.9707391992883415, 0.9706941807179268, 0.970700457520577, 0.9848366883938683, 0.9389671857755401, 0.9413503452569116, 0.9756855344721245, 0.975259763644751, 0.9752644936455758, 0.6421156081697493, 0.6305519404457443, 0.6188875452578477, 0.6676203078301834, 0.6475360271814459, 0.6709631382405603, 0.616309843510332, 0.6196596174161674, 0.5986150808482912, 0.2078784985544213, 0.2121250978411816, 0.8351280494669197, 0.8536752923373656, 0.82648102809608, 0.3712441002182766, 0.3157344564084046, 0.7432090451419557, 0.6951526983868915, 0.12819261287054273, 0.31519804395639517, 0.5179085904655717, 0.48511649008580626, 0.6265646843373369, 0.5656758085818119, 0.4434180004596422, 0.41988056861418976, 0.34838676717646533, 0.35491765803386266, 0.25833184098241846, 0.18557100815922178, 0.5326079344551382, 0.41293190844481975, 0.3279638260071921, 0.36444433069709825, 0.3895292127396497, 0.4878808267899555, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14522031011442993, 0.14020353502178373, 0.10579245766114831, 0.08531277278524063, 0.07641457554662534, 0.0717078971656474, 0.10138290567981001, 0.0831032708970455, 0.09467708333687064, 0.037915759082718825, 0.027270666584729986, 0.018629811497691273, 0.06860489886364829, 0.08058832876930155, 0.03040521016806852, 0.05851217200437664, 0.01978432445186007, 0.07578593267034817, 0.22040653375791297, 0.3054488992972293, 0.26193139868200355, 0.22393347807385733, 0.16371228040349084, 0.07935339598062185, 0.36752440863290536, 0.2841753056907903, 0.22037705368270322, 0.6242594887925613, 0.6351594751407174, 0.6600634438798278, 0.5718066365458703, 0.6667505273111594, 0.618044483900919, 0.6457549364796242, 0.625367199661916, 0.595507073096244, 0.09871318322259537, 0.0869280443926882, 0.0958928318073351, 0.12276200165393403, 0.11920993510484201, 0.1294797869186104, 0.1265377030073498, 0.07293876305234148, 0.13188372553334815, 0.11266589362879242, 0.13926988806996998, 0.2050458846741735, 0.16224331830270544, 0.25159047330689277, 0.17063113697178067, 0.21975317203737477, 0.1776669243411716, 0.25181915643549635, 0.3505983208321566, 0.18050404871279657, 0.20026337886452306, 0.403613991437226, 0.3332828327461733, 0.43716238135689145, 0.3903153269611672, 0.3249019360264467, 0.36876474205141463, 0.21613212404157345, 0.1928541849194464, 0.1768348227205293, 0.2602287954827389, 0.24633665494199208, 0.2780924800144535, 0.35951196955809395, 0.1589146886447932, 0.5478727654568235, 0.17644210941576366, 0.18540971776381687, 0.22090602428705508, 0.20270495205126604, 0.2234129799558131, 0.18989554301365696, 0.21298806084182464, 0.21356178486873167, 0.18779055821506452, 0.20571297127619725, 0.1831079050119918, 0.24675598480655359, 0.7875431510246569, 0.7435843234613562, 0.22443028865178294, 0.2103134549700848, 0.2051309695730451, 0.22508476475017603, 0.8691107889494771, 0.12705663006532453, 0.12731490029502168, 0.23673580524020998, 0.44091690855694365, 0.2878322107644663, 0.16708569418171226, 0.16655049434976132, 0.10843691812693868, 0.16611234332979052, 0.16760839465494792, 0.1681308959595248, 0.21215422283792063, 0.21219021535130445, 0.21309770731545818, 0.1976485723456226, 0.209388488593505, 0.21036126736180416, 0.19182567566995723, 0.20790222872614006, 0.20795619340391536, 0.19027755973977933, 0.17926608500587116, 0.18788164994420442, 0.1688762595384462, 0.18447355659101183, 0.15015832702044318, 0.10773529150199979, 0.0899664217547621, 0.0967240166861657, 0.09540100523183515, 0.0816568465149774, 0.07110508858080533, 0.08377558316089795, 0.08037750661771392, 0.08298302158063886]}, "mutation_prompt": null}
