{"id": "d42070b0-fb8d-4d33-9f7f-96d05ca83ba3", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n    \n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters\n            self.mutation_factor = 0.5 + 0.2 * (1 - evals / self.budget)\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Adaptive Differential Evolution with Covariance Matrix Adaptation for diverse problem landscapes.", "configspace": "", "generation": 0, "fitness": 0.050043655807591216, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": null, "metadata": {"aucs": [0.11285449670450798, 0.11152955973053869, 0.1262988044526161, 0.05869298213644303, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10217487709910711, 0.07633282172969524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02642655464500676, 0.03104030688407944, 9.999999999998899e-05, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.0373291604028998, 0.00023040876205193683, 9.999999999998899e-05, 0.015737846180767345, 9.999999999998899e-05, 0.00036580233928595884, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.03794237872826667, 0.019728681060037112, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.1145609309957697, 0.042141119013906936, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04268856704942303, 9.999999999998899e-05, 0.00990846602666351, 0.026539587325965508, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0879135468155644, 0.02096992833261191, 0.057321363796033475, 9.999999999998899e-05, 0.0642973352878935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17658063443072092, 0.15940641491336394, 0.09819252432275494, 0.12328103151888703, 0.0618049400494165, 0.10447438057432301, 0.1607492388395203, 0.1710041808599937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036581238860921017, 0.028112723025944586, 0.000635863717310392, 0.02403245070248794, 0.0267656688986897, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.11347519164259667, 0.06750174035189471, 0.09284248734104916, 0.08296408380323028, 0.0794396307614097, 0.07726393575557644, 0.13146814346182178, 0.12287304150010592, 0.11704192399813129, 0.12548811730493725, 0.1722153321743254, 0.1259787746545329, 0.1362511076685441, 0.130243312090228, 0.0981403274724495, 0.0676411568483849, 0.05895177285510722, 0.04689957301377967, 0.07783917353644099, 0.1136427810388454, 0.0696337026820083, 0.05648699256316181, 0.07709631609591738, 0.04947704304466516, 0.160151745937534, 0.15442818789327828, 0.14147171266020309, 0.19389811620560826, 0.14352104100061536, 0.20062611813264686, 0.1421298350462905, 0.11281333985909081, 0.15081246810988092, 9.999999999998899e-05, 0.009481557254094719, 0.15380093874430445, 9.999999999998899e-05, 0.167141465347594, 0.15289362082965796, 0.1480901377898688, 0.13687249471035634, 9.999999999998899e-05, 0.09207195749122166, 0.27488860166370244, 0.10608557030683585, 0.16417478359687465, 0.1207914665021157, 0.04032919680404723, 0.03497572734703336, 0.056615725614002965, 0.06952661227523493, 0.04149762253526801, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.022454682062276188, 0.0317201888080455, 0.04143420019681854, 0.12796278388174087, 0.14668078603081502, 0.14763022729669195, 0.14080860959776986, 0.1923561159088819, 0.1524908532652235, 0.12790649620731143, 0.13362217639771712, 0.14849372211569312, 0.04980017573601603, 0.030490558001612378, 0.031393493129599714, 0.03298259355879274, 0.032982124671739776, 0.04407370132394739, 0.034131050068484936, 0.03495822080486921, 0.03408636607980409]}, "mutation_prompt": null}
{"id": "d9ef256e-4482-4db2-b3c3-1cb1d4452da7", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.sigma_initial = 0.3\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n    \n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Enhanced crossover strategy with adaptive crossover rate\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate * (1 - evals / self.budget) else self.population[i, j] \n                                             for j in range(self.dim)])\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters\n            self.mutation_factor = 0.5 + 0.2 * (1 - evals / self.budget)\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Adaptive Differential Evolution with enhanced crossover strategy for improved convergence speed.", "configspace": "", "generation": 1, "fitness": 0.04967723404095627, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "d42070b0-fb8d-4d33-9f7f-96d05ca83ba3", "metadata": {"aucs": [0.11285449670450798, 0.11152955973053869, 0.1262988044526161, 0.05869298213644303, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10217487709910711, 0.07633282172969524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02642655464500676, 0.03104030688407944, 9.999999999998899e-05, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.0373291604028998, 0.00023040876205193683, 9.999999999998899e-05, 0.015737846180767345, 9.999999999998899e-05, 0.00036580233928595884, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.03794237872826667, 0.019728681060037112, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.1145609309957697, 0.042141119013906936, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04268856704942303, 9.999999999998899e-05, 0.00990846602666351, 0.026539587325965508, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0879135468155644, 0.02096992833261191, 0.057321363796033475, 9.999999999998899e-05, 0.08404466666748889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17658063443072092, 0.15940641491336394, 0.09819252432275494, 0.12328103151888703, 0.0618049400494165, 0.10447438057432301, 0.1607492388395203, 0.1710041808599937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036581238860921017, 0.028112723025944586, 0.000635863717310392, 0.02403245070248794, 0.0267656688986897, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.11318555048837531, 0.06750174035189471, 0.09284248734104916, 0.06413738849474426, 0.0794396307614097, 0.07726393575557644, 0.13146814346182178, 0.12287304150010592, 0.11704192399813129, 0.12548811730493725, 0.1722153321743254, 0.1259787746545329, 0.1362511076685441, 0.130243312090228, 0.0981403274724495, 0.0676411568483849, 0.05895177285510722, 0.04689957301377967, 0.07783917353644099, 0.1136427810388454, 0.0696337026820083, 0.05648699256316181, 0.07709631609591738, 0.04947704304466516, 0.1340650933216201, 0.15442818789327828, 0.14147171266020309, 0.14719853202156485, 0.14352104100061536, 0.20062611813264686, 0.1421298350462905, 0.11281333985909081, 0.15081246810988092, 9.999999999998899e-05, 0.009481557254094719, 0.15380093874430445, 9.999999999998899e-05, 0.167141465347594, 0.15289362082965796, 0.1480901377898688, 0.13687249471035634, 9.999999999998899e-05, 0.09207195749122166, 0.27488860166370244, 0.10608557030683585, 0.16417478359687465, 0.1207914665021157, 0.04032919680404723, 0.03497572734703336, 0.056615725614002965, 0.06952661227523493, 0.04149762253526801, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.022454682062276188, 0.0317201888080455, 0.04143420019681854, 0.12796278388174087, 0.14668078603081502, 0.14763022729669195, 0.14080860959776986, 0.1923561159088819, 0.1524908532652235, 0.12790649620731143, 0.13362217639771712, 0.14849372211569312, 0.04980017573601603, 0.030490558001612378, 0.031393493129599714, 0.03298259355879274, 0.032982124671739776, 0.04407370132394739, 0.02713919035840462, 0.03495822080486921, 0.03408636607980409]}, "mutation_prompt": null}
{"id": "2a6a371d-7eb7-43d0-b1d8-2fb2a5a7b8a7", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n    \n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters\n            self.mutation_factor = 0.5 + 0.1 * (1 - evals / self.budget)  # Slight adjustment\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_v2", "description": "AdaptiveDE_CMA_v2: Enhanced parameter adaptation strategy for improved convergence speed in diverse landscapes.", "configspace": "", "generation": 2, "fitness": 0.04974058478332418, "feedback": "The algorithm AdaptiveDE_CMA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "d42070b0-fb8d-4d33-9f7f-96d05ca83ba3", "metadata": {"aucs": [0.11530779993069518, 0.10866372360208698, 0.1262988044526161, 0.054452311051145674, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.1028412492944153, 0.07702731564937171, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020501441383715457, 0.031933141441751856, 0.0013117263916941901, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.03904501421332929, 0.00023040876205193683, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.03746944292696186, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.11455593492791705, 0.042141119013906936, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04118324823970765, 9.999999999998899e-05, 0.00990846602666351, 0.02784460139613698, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04616220909833135, 0.08819331704552702, 0.02595322578186765, 0.061364539959003706, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17471175170960274, 0.15940641491336394, 0.09686276855708165, 0.12062325742844882, 0.0618049400494165, 0.10443214810253043, 0.1607492388395203, 0.17183983811914583, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014594791645391458, 0.028112723025944586, 0.000635863717310392, 0.02362241002201826, 0.0267656688986897, 0.08226160278931605, 0.08439033755601066, 0.07700480203705229, 0.13087110002401992, 0.12940222031388604, 0.09284248734104916, 0.06413738849474426, 0.06955194447088053, 0.07726393575557644, 0.13240365457425762, 0.12135972835152697, 0.11704192399813129, 0.12873969000441088, 0.17925233706475174, 0.12678844157296876, 0.13802996039189652, 0.1346470719707733, 0.10654499527416195, 0.05818524012276971, 0.06599981970159607, 0.041597743805120935, 0.0769713108299811, 0.1136427810388454, 0.0637412338423553, 0.05648699256316181, 0.0711772066945967, 0.03767490129901385, 0.15769277834171558, 0.1251670869630157, 0.15339486561279914, 0.186129777482538, 0.14433595768673368, 0.16079455568138912, 0.1315564654790029, 0.11625285563180354, 0.15101147225601141, 9.999999999998899e-05, 0.009481557254094719, 0.1492306622347518, 9.999999999998899e-05, 0.17329130539970938, 0.14808666889622368, 0.15576027326768727, 0.1384610072636846, 9.999999999998899e-05, 0.0859878111125234, 0.23796058095054018, 0.10112394702555971, 0.16618809929222556, 0.1207914665021157, 0.038139837546615984, 0.03391929261879634, 0.056615725614002965, 0.06517221021591046, 0.040293247503621066, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.02618381728663166, 0.0317201888080455, 0.04143420019681854, 0.16637678668525568, 0.12964960107607948, 0.1560565966723334, 0.14126511510814654, 0.1923561159088819, 0.14334354765765422, 0.14292804824727334, 0.16189521608833324, 0.14689007985489466, 0.04821306707165318, 0.01882345471167468, 0.031393493129599714, 0.04719424117465154, 0.03398682070406134, 0.05480642635205746, 0.02981870702923839, 0.031451705194713964, 0.023159705337614134]}, "mutation_prompt": null}
{"id": "cf83998c-ed01-42c6-9053-287bb3b4d5b2", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.sigma_initial = 0.3\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n    \n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters\n            self.mutation_factor = 0.5 + 0.2 * (1 - evals / self.budget)\n            self.crossover_rate = 0.8 + 0.1 * (np.min(fitness) / self.best_fitness)  # Dynamic adjustment\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced Adaptive Differential Evolution with dynamic crossover rate adjustment to improve convergence speed.", "configspace": "", "generation": 3, "fitness": 0.04996717392149481, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "d42070b0-fb8d-4d33-9f7f-96d05ca83ba3", "metadata": {"aucs": [0.11285449670450798, 0.11152955973053869, 0.1262988044526161, 0.05869298213644303, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10217487709910711, 0.07633282172969524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02642655464500676, 0.03104030688407944, 9.999999999998899e-05, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.0373291604028998, 0.00023040876205193683, 9.999999999998899e-05, 0.015737846180767345, 9.999999999998899e-05, 0.00036580233928595884, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.03794237872826667, 0.019728681060037112, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.1145609309957697, 0.042141119013906936, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04268856704942303, 9.999999999998899e-05, 0.00990846602666351, 0.026539587325965508, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0886276237244219, 0.02096992833261191, 0.044898427885436853, 9.999999999998899e-05, 0.0642973352878935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17658063443072092, 0.15940641491336394, 0.09819252432275494, 0.12328103151888703, 0.0618049400494165, 0.10447438057432301, 0.1607492388395203, 0.1710041808599937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036581238860921017, 0.028112723025944586, 0.000635863717310392, 0.02403245070248794, 0.04049626240144932, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.11347519164259667, 0.06750174035189471, 0.09284248734104916, 0.08296408380323028, 0.0794396307614097, 0.07726393575557644, 0.13146814346182178, 0.12287304150010592, 0.11704192399813129, 0.12548811730493725, 0.1722153321743254, 0.1259787746545329, 0.1362511076685441, 0.130243312090228, 0.0981403274724495, 0.0676411568483849, 0.05895177285510722, 0.04689957301377967, 0.07783917353644099, 0.1136427810388454, 0.0696337026820083, 0.05648699256316181, 0.07709631609591738, 0.04947704304466516, 0.160151745937534, 0.15442818789327828, 0.14147171266020309, 0.19389811620560826, 0.14352104100061536, 0.20062611813264686, 0.1421298350462905, 0.11281333985909081, 0.15081246810988092, 9.999999999998899e-05, 0.009481557254094719, 0.15380093874430445, 9.999999999998899e-05, 0.167141465347594, 0.15289362082965796, 0.1480901377898688, 0.13687249471035634, 9.999999999998899e-05, 0.09207195749122166, 0.27488860166370244, 0.10608557030683585, 0.16417478359687465, 0.1207914665021157, 0.04032919680404723, 0.03497572734703336, 0.056615725614002965, 0.06952661227523493, 0.04149762253526801, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.022454682062276188, 0.0317201888080455, 0.04143420019681854, 0.12796278388174087, 0.14668078603081502, 0.14763022729669195, 0.14080860959776986, 0.1923561159088819, 0.1339490313673799, 0.12790649620731143, 0.13362217639771712, 0.14849372211569312, 0.04980017573601603, 0.030490558001612378, 0.031393493129599714, 0.03298259355879274, 0.032982124671739776, 0.04407370132394739, 0.034131050068484936, 0.03495822080486921, 0.03408636607980409]}, "mutation_prompt": null}
{"id": "86525f7d-979f-424d-a72d-fc266a1e1535", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * evals / (2 * self.budget))\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced AdaptiveDE_CMA with an alternative strategy for mutation factor adaption to improve convergence speed.", "configspace": "", "generation": 4, "fitness": 0.05021356172103248, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "d42070b0-fb8d-4d33-9f7f-96d05ca83ba3", "metadata": {"aucs": [0.11285449670450798, 0.11153803193247225, 0.1262988044526161, 0.05870427807435008, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10217306439296281, 0.07633282172969524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02651835125110269, 0.03104030688407944, 9.999999999998899e-05, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.03732297535089746, 0.00023040876205193683, 9.999999999998899e-05, 0.015543230506489314, 9.999999999998899e-05, 0.000367674197348955, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.03794366997483012, 0.019726589544638906, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.1145609309957697, 0.042141119013906936, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04268856704942303, 9.999999999998899e-05, 0.00990846602666351, 0.02651918990674751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0879221060504789, 0.02096992833261191, 0.057586927601580795, 9.999999999998899e-05, 0.06376566615257218, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17659756506601876, 0.15940641491336394, 0.09819593656710346, 0.12328763895009909, 0.0618049400494165, 0.10447425006984323, 0.1607492388395203, 0.1710041808599937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036540529439387237, 0.028112723025944586, 0.000635863717310392, 0.024058290325300935, 0.0267656688986897, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.11271966176287174, 0.06750174035189471, 0.09284248734104916, 0.0833591381070975, 0.0793334092764737, 0.07726393575557644, 0.1314803838127766, 0.12286328805828284, 0.11704192399813129, 0.12549090100419613, 0.17221823564671357, 0.1259787746545329, 0.13626016158000764, 0.13023248764771833, 0.0981403274724495, 0.06765492421054076, 0.05898654495984934, 0.04689860009815816, 0.07782375785187556, 0.1136427810388454, 0.06962534579297919, 0.05648699256316181, 0.07705988579391854, 0.04949958617867123, 0.18898361643529415, 0.1680716324027931, 0.14143652733553858, 0.16198100162989848, 0.15315090913909735, 0.20235260197144334, 0.14010380586972437, 0.11932374044011507, 0.14552656503999384, 9.999999999998899e-05, 0.009481557254094719, 0.15382014776285957, 9.999999999998899e-05, 0.16714827492952244, 0.15292815249670888, 0.1481392261885981, 0.13685821073187798, 9.999999999998899e-05, 0.09208321927199248, 0.2749809239422083, 0.1061059649904259, 0.16417515418106743, 0.1207914665021157, 0.04033196864729183, 0.03508311663748287, 0.056615725614002965, 0.06953699289874071, 0.04149864215162202, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.02244304209606196, 0.0317201888080455, 0.04143420019681854, 0.1448908917058801, 0.14528488513500637, 0.14763022729669195, 0.14108883913697357, 0.1923561159088819, 0.15179534221009905, 0.12880853117528202, 0.13309131854455414, 0.14931941628838086, 0.04956078457876156, 0.03062606393122347, 0.031393493129599714, 0.033028012466580936, 0.03297345380408001, 0.044028531071856336, 0.03405026073962303, 0.03490980467206173, 0.03407601756922396]}, "mutation_prompt": null}
{"id": "ae46819f-e233-438c-8c0f-413a783bc281", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        # Slightly widen the initial population range for better exploration\n        self.population = np.random.uniform(self.lower_bound - 0.5, self.upper_bound + 0.5, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                # Slight adjustment in mutant vector computation for better diversity\n                mutant_vector = np.clip(a + (self.mutation_factor + 0.05) * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * evals / (2 * self.budget))\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Minor enhancement in mutation strategy and population initialization in AdaptiveDE_CMA for better exploration.", "configspace": "", "generation": 5, "fitness": 0.05006284282553652, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "86525f7d-979f-424d-a72d-fc266a1e1535", "metadata": {"aucs": [0.128767635483784, 0.10567690872088875, 0.0921795234867836, 0.05354865801240338, 0.053444211669837594, 0.029772660975819765, 0.04696040380822375, 0.10339631832188956, 0.08010065440372949, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025953772836858846, 0.0465465034199819, 0.0009280836458818165, 0.0453896601530116, 9.999999999998899e-05, 0.02598546885309949, 0.030455389532249466, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027337144590395823, 9.999999999998899e-05, 9.999999999998899e-05, 0.008626327324188776, 9.999999999998899e-05, 9.999999999998899e-05, 0.006095070549859916, 9.999999999998899e-05, 9.999999999998899e-05, 0.05511377323643751, 0.03778813717167395, 0.05196303021323634, 0.04690005586241697, 0.05435648297755158, 0.03601197108941001, 0.03939880075978486, 0.05713671129107134, 0.030188689699913396, 0.04036648614518579, 0.03648877987573618, 9.999999999998899e-05, 9.999999999998899e-05, 0.00425999130376109, 9.999999999998899e-05, 9.999999999998899e-05, 0.0049531487584283385, 9.999999999998899e-05, 0.10021374875811107, 0.11455408590434157, 0.04095183953349102, 0.036526503597080984, 9.999999999998899e-05, 9.999999999998899e-05, 0.09737308263795963, 0.011696237861337666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005136608821008082, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019865547769993275, 0.05405965614247343, 9.999999999998899e-05, 0.09132031091116755, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09369937921130134, 0.2534193381508242, 0.1596071394437959, 0.08991301915631644, 0.12434655928223581, 0.06899015566156885, 0.09635551755960337, 0.16010705284368887, 0.16908673098709393, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010509127344821123, 0.04335374068772435, 0.0025721421469524497, 0.028477459402683203, 0.013203050765622226, 0.06520883065727634, 0.04756171390412911, 0.056153794144506386, 0.07994124447431805, 0.06323196397577191, 0.08962556932735732, 0.08381478820106825, 0.08068339485011877, 0.0799585228214551, 0.12130998116049163, 0.1259651359047741, 0.10501824961346573, 0.11877096949747867, 0.15659455318267845, 0.12959886077452398, 0.12914300075417717, 0.13425250930259158, 0.10823021791380139, 0.06673585791846814, 0.08069364252145494, 0.045163138201962494, 0.09352982068275673, 0.10665494953574328, 0.056202931508316345, 0.07063313968556595, 0.0778362402790328, 0.044817970187944756, 0.1693449223485275, 0.13461095859207872, 0.167589605676286, 0.15303743339982578, 0.12965663429169094, 0.22053249407481068, 0.14519892682190128, 0.19802726935636106, 0.15583484954073645, 9.999999999998899e-05, 0.041402941838035945, 0.09717865052738672, 9.999999999998899e-05, 0.17048079528741122, 0.159749338649669, 0.15606676127548869, 0.12448672409973682, 9.999999999998899e-05, 0.09252695333234007, 0.10164146012017206, 0.10360242417897592, 0.16752277599720677, 0.12289619739139668, 0.10563933808039205, 0.0352812544637261, 0.06487309557033327, 0.08466385708926105, 0.11635990575195354, 0.019930525694300205, 0.028833281445076908, 0.0574679625629918, 0.06126823891825084, 0.041501224003396064, 0.07248385253153189, 0.027598706876576617, 0.02861083693747657, 0.1398792575632528, 0.12645808787551627, 0.1610935782427101, 0.14141895456594722, 0.18115194610758223, 0.15277831091699567, 0.12450124997729639, 0.1504413721244413, 0.1213312231297119, 0.034929711191153734, 0.016615691841463387, 0.04469395400629861, 0.040809374423724676, 0.03062515934992438, 0.029156800361000546, 0.02889260373244995, 0.01944697739931711, 0.020993551177232228]}, "mutation_prompt": null}
{"id": "18632666-b043-49de-a657-7a77057041a8", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                dynamic_scaling = np.sin(np.pi * evals / (2 * self.budget))  # Dynamic scaling factor\n                mutant_vector = np.clip(a + self.mutation_factor * dynamic_scaling * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * evals / (2 * self.budget))\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Introduced a dynamic scaling factor for DE mutation to increase exploration early and exploitation later, alongside the existing cosine-based strategy.", "configspace": "", "generation": 6, "fitness": 0.045179340921276415, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "86525f7d-979f-424d-a72d-fc266a1e1535", "metadata": {"aucs": [0.11808184817385281, 0.13462455378322524, 0.14561301030291018, 0.032811567004711994, 0.052774370294379924, 0.028027315888911275, 0.05142568804351011, 0.0814779655541561, 0.06711154613058024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0016789001049308805, 0.020873257669072, 9.999999999998899e-05, 0.01983926933063518, 0.0014904270117130913, 0.0036807014336430743, 0.028772333502299463, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019892377539380335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0052659931876601895, 9.999999999998899e-05, 0.045179741609489454, 0.033669640956058955, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.041562812130162996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002915868802875976, 0.02218255636951494, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.11048503249177155, 0.08475871300030269, 0.017841464492953985, 0.0321102514985665, 9.999999999998899e-05, 9.999999999998899e-05, 0.026279303607937843, 9.999999999998899e-05, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034858284800646233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053655078365485886, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1051611211062673, 0.04795291040733696, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0858385047127389, 0.15669098002619752, 0.14838054695461433, 0.09508099197347997, 0.16064829841602846, 0.04457031991552973, 0.1093935884333832, 0.20325922277290154, 0.17556538079169437, 9.999999999998899e-05, 0.042601841261186935, 9.999999999998899e-05, 9.999999999998899e-05, 0.006050404869500925, 0.034609165281540455, 9.999999999998899e-05, 0.01967222264934665, 0.027267694435411438, 0.07037543064596374, 0.07299678039603408, 0.07571393020572237, 0.09855305120349966, 0.12968991009342334, 0.05828550366907348, 0.07211347794339196, 0.07245685584927286, 0.07726393575557644, 0.11661256018237232, 0.10108868130272641, 0.1084359947449347, 0.12450746576212457, 0.15841515628014136, 0.12661599217965136, 0.11563067971895347, 0.12391016770809493, 0.07207167343192833, 0.05273228581202771, 0.05130525857493773, 0.04676627363941621, 0.05029668290649547, 0.11941484894870158, 0.06476424065351583, 0.05648699256316181, 0.05494717678592187, 0.018679556897935434, 0.15460892091211031, 0.07609986541201419, 0.15119633031412738, 0.16284559260305054, 0.17598487247486994, 0.16456088523369183, 0.12245976138762271, 0.12735806601373678, 0.1481070814031562, 9.999999999998899e-05, 0.15403558214923452, 0.1410087634731948, 9.999999999998899e-05, 0.14590593537187757, 0.1311334174050538, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07690752046234628, 0.05636436018387447, 0.06479050595728642, 0.15111664598981656, 0.12307520249991355, 0.027117525622056382, 0.03391929261879634, 0.056615725614002965, 0.08174686360366068, 0.04962573845542251, 0.03967402848431323, 0.029073512190348483, 0.024102061376883976, 0.031941808409673866, 0.045511073114331335, 0.05778510979594664, 0.06000810000075307, 0.041558556675266645, 0.157580639759911, 0.1328863409395732, 0.1476334671170042, 0.11529569423781305, 0.12043117944275095, 0.1258238822169535, 0.14498237854552876, 0.11624505181554501, 0.14985156422339774, 0.0397887322954692, 0.017488363626171344, 0.03525560271525696, 0.032251783114991106, 0.06134216623853095, 0.04949458293035691, 0.015031882136094854, 0.01998289532116526, 0.03335289575123257]}, "mutation_prompt": null}
{"id": "9988cc52-61af-4397-a44b-b46f4d797c67", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using exponential decay strategy\n            self.mutation_factor = 0.5 * (0.9 ** (evals / self.budget))\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "AdaptiveDE_CMA with refined mutation factor adaptation using an exponential decay strategy for improved convergence.", "configspace": "", "generation": 7, "fitness": 0.04973719176728181, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "86525f7d-979f-424d-a72d-fc266a1e1535", "metadata": {"aucs": [0.11588237427041326, 0.10866372360208698, 0.1262988044526161, 0.051261170656000665, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10332473978807544, 0.07761931570858505, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022244076538367352, 0.03357879502442118, 0.0009097849369449351, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.03163356286441943, 0.00023040876205193683, 9.999999999998899e-05, 0.010932456548180536, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.03694790062593989, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.11455836089132121, 0.03921595107461928, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04307436944040133, 9.999999999998899e-05, 0.00990846602666351, 0.03034856552852705, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05806570979358405, 0.05305383340660008, 0.06694869445540175, 0.02096992833261191, 0.05686406032493596, 9.999999999998899e-05, 0.05669780427460158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17409872717541386, 0.15940641491336394, 0.09550318899379895, 0.11816985406815417, 0.0618049400494165, 0.10440825581522173, 0.1607492388395203, 0.17287480874683248, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014594791645391458, 0.028112723025944586, 0.000635863717310392, 0.02362241002201826, 0.0267656688986897, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.1138091057279591, 0.09844407995888416, 0.09284248734104916, 0.06413738849474426, 0.06955194447088053, 0.07726393575557644, 0.13082968777466064, 0.12094992153017736, 0.11704192399813129, 0.12804676654166725, 0.17597757334497766, 0.1259787746545329, 0.14343486490960078, 0.1334351210620156, 0.09993671721259323, 0.04582515853426761, 0.06452329400209345, 0.04234743948281794, 0.07772741130204663, 0.1136427810388454, 0.05634299539972232, 0.05648699256316181, 0.07500792854799188, 0.03735540866863907, 0.14983618562115586, 0.15119858258826135, 0.17032917596746633, 0.14419419989147841, 0.15090733946834012, 0.15967303350356, 0.13615824939470655, 0.1024706307297345, 0.16293269360835094, 9.999999999998899e-05, 0.009481557254094719, 0.15362454558145167, 9.999999999998899e-05, 0.18287587219845158, 0.15376133791698599, 0.1517140944387837, 0.13644152986845692, 9.999999999998899e-05, 0.07951163945928896, 0.22763239077203123, 0.1000742355061377, 0.168440786529774, 0.1207914665021157, 0.037606328717061155, 0.03391929261879634, 0.056615725614002965, 0.060052346277633895, 0.03925425932066606, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.026761068217914907, 0.03374317421620854, 0.04143420019681854, 0.15358786014087167, 0.1472644597329369, 0.14763022729669195, 0.15496668696912808, 0.1923561159088819, 0.13143467335808423, 0.1632605914854467, 0.12008032342526509, 0.15380053065357768, 0.03764598825966514, 0.026359046450407875, 0.03855881095778768, 0.0543757775157645, 0.03610936515732244, 0.03697393653926151, 0.032563437974194365, 0.0364119627356857, 0.031432429376832105]}, "mutation_prompt": null}
{"id": "eb2de350-c243-446f-b339-b035a0d3071b", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Initial crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * evals / (2 * self.budget))\n\n            # Dynamic crossover rate adaptation\n            self.crossover_rate = 0.9 - 0.4 * np.sin(np.pi * evals / self.budget)\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced AdaptiveDE_CMA with a dynamic crossover rate adaptation for improved exploration-exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.050088055201473386, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "86525f7d-979f-424d-a72d-fc266a1e1535", "metadata": {"aucs": [0.11285449670450798, 0.11153803193247225, 0.1262988044526161, 0.05870427807435008, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10217306439296281, 0.07633282172969524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02651835125110269, 0.03104030688407944, 9.999999999998899e-05, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.03732297535089746, 0.00023040876205193683, 9.999999999998899e-05, 0.015543230506489314, 9.999999999998899e-05, 0.000367674197348955, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.03794366997483012, 0.019726589544638906, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.1145609309957697, 0.042141119013906936, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04268856704942303, 9.999999999998899e-05, 0.00990846602666351, 0.02651918990674751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0879221060504789, 0.02096992833261191, 0.057586927601580795, 9.999999999998899e-05, 0.08354946531107799, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17659756506601876, 0.15940641491336394, 0.09819593656710346, 0.12328763895009909, 0.0618049400494165, 0.10447425006984323, 0.1607492388395203, 0.1710041808599937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036540529439387237, 0.028112723025944586, 0.000635863717310392, 0.024058290325300935, 0.0267656688986897, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.11271966176287174, 0.06750174035189471, 0.09284248734104916, 0.06413738849474426, 0.0793334092764737, 0.07726393575557644, 0.1314803838127766, 0.12286328805828284, 0.11704192399813129, 0.12549090100419613, 0.17221823564671357, 0.1259787746545329, 0.13626016158000764, 0.13023248764771833, 0.0981403274724495, 0.06765492421054076, 0.05898654495984934, 0.04689860009815816, 0.07782375785187556, 0.1136427810388454, 0.06962534579297919, 0.05648699256316181, 0.07705988579391854, 0.04949958617867123, 0.18898361643529415, 0.1680716324027931, 0.14143652733553858, 0.15114259370952154, 0.15315090913909735, 0.20235260197144334, 0.13020327244621022, 0.11932374044011507, 0.14552656503999384, 9.999999999998899e-05, 0.009481557254094719, 0.15382014776285957, 9.999999999998899e-05, 0.16714827492952244, 0.15292815249670888, 0.1481392261885981, 0.13685821073187798, 9.999999999998899e-05, 0.09208321927199248, 0.2749809239422083, 0.1061059649904259, 0.16417515418106743, 0.1207914665021157, 0.04033196864729183, 0.03508311663748287, 0.056615725614002965, 0.06953699289874071, 0.04149864215162202, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.02244304209606196, 0.0317201888080455, 0.04143420019681854, 0.1448908917058801, 0.14528488513500637, 0.14763022729669195, 0.14108883913697357, 0.1923561159088819, 0.15179534221009905, 0.12880853117528202, 0.13309131854455414, 0.14931941628838086, 0.04956078457876156, 0.03062606393122347, 0.031393493129599714, 0.033028012466580936, 0.03297345380408001, 0.044028531071856336, 0.027117744312596948, 0.03490980467206173, 0.03407601756922396]}, "mutation_prompt": null}
{"id": "d796f0fd-5130-469e-9b19-b0269754e09f", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Initial crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * evals / (2 * self.budget))\n            # Dynamic crossover rate adaptation\n            self.crossover_rate = 0.9 * (1 - evals / self.budget)\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced AdaptiveDE_CMA with dynamic crossover rate adaptation for improved convergence speed.", "configspace": "", "generation": 9, "fitness": 0.050088055201473386, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "86525f7d-979f-424d-a72d-fc266a1e1535", "metadata": {"aucs": [0.11285449670450798, 0.11153803193247225, 0.1262988044526161, 0.05870427807435008, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10217306439296281, 0.07633282172969524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02651835125110269, 0.03104030688407944, 9.999999999998899e-05, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.03732297535089746, 0.00023040876205193683, 9.999999999998899e-05, 0.015543230506489314, 9.999999999998899e-05, 0.000367674197348955, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.03794366997483012, 0.019726589544638906, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.1145609309957697, 0.042141119013906936, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04268856704942303, 9.999999999998899e-05, 0.00990846602666351, 0.02651918990674751, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0879221060504789, 0.02096992833261191, 0.057586927601580795, 9.999999999998899e-05, 0.08354946531107799, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17659756506601876, 0.15940641491336394, 0.09819593656710346, 0.12328763895009909, 0.0618049400494165, 0.10447425006984323, 0.1607492388395203, 0.1710041808599937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036540529439387237, 0.028112723025944586, 0.000635863717310392, 0.024058290325300935, 0.0267656688986897, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.11271966176287174, 0.06750174035189471, 0.09284248734104916, 0.06413738849474426, 0.0793334092764737, 0.07726393575557644, 0.1314803838127766, 0.12286328805828284, 0.11704192399813129, 0.12549090100419613, 0.17221823564671357, 0.1259787746545329, 0.13626016158000764, 0.13023248764771833, 0.0981403274724495, 0.06765492421054076, 0.05898654495984934, 0.04689860009815816, 0.07782375785187556, 0.1136427810388454, 0.06962534579297919, 0.05648699256316181, 0.07705988579391854, 0.04949958617867123, 0.18898361643529415, 0.1680716324027931, 0.14143652733553858, 0.15114259370952154, 0.15315090913909735, 0.20235260197144334, 0.13020327244621022, 0.11932374044011507, 0.14552656503999384, 9.999999999998899e-05, 0.009481557254094719, 0.15382014776285957, 9.999999999998899e-05, 0.16714827492952244, 0.15292815249670888, 0.1481392261885981, 0.13685821073187798, 9.999999999998899e-05, 0.09208321927199248, 0.2749809239422083, 0.1061059649904259, 0.16417515418106743, 0.1207914665021157, 0.04033196864729183, 0.03508311663748287, 0.056615725614002965, 0.06953699289874071, 0.04149864215162202, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.02244304209606196, 0.0317201888080455, 0.04143420019681854, 0.1448908917058801, 0.14528488513500637, 0.14763022729669195, 0.14108883913697357, 0.1923561159088819, 0.15179534221009905, 0.12880853117528202, 0.13309131854455414, 0.14931941628838086, 0.04956078457876156, 0.03062606393122347, 0.031393493129599714, 0.033028012466580936, 0.03297345380408001, 0.044028531071856336, 0.027117744312596948, 0.03490980467206173, 0.03407601756922396]}, "mutation_prompt": null}
{"id": "a75213b4-49d0-4619-8b63-44b5e686c902", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Initial crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                candidate_fitness = func(crossover_vector)\n                if candidate_fitness < fitness[i]:\n                    self.population[i] = crossover_vector\n                    fitness[i] = candidate_fitness\n                    evals += 1\n                    self.crossover_rate = min(1.0, self.crossover_rate + 0.05)  # Increase on improvement\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * evals / (2 * self.budget))\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced AdaptiveDE_CMA with adaptive crossover rate based on fitness improvement to accelerate convergence.", "configspace": "", "generation": 10, "fitness": 0.04731530377360807, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "86525f7d-979f-424d-a72d-fc266a1e1535", "metadata": {"aucs": [0.09799797657514353, 0.10811722130515578, 0.1262988044526161, 0.041464654605653184, 0.05843786835194864, 0.028128934048788135, 0.06596402570180604, 0.0968200735101109, 0.07165374966941451, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02450465194289131, 0.022150994859073014, 9.999999999998899e-05, 0.018414546797477893, 0.015371214342060235, 0.0040664177995966, 0.01977449865760661, 0.007405194376618018, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.033906873995760756, 0.048986754550083944, 0.02584969810736515, 0.022617279986819283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015796865505633084, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.07538654779863496, 0.06410701975704558, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04118177474020723, 9.999999999998899e-05, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03091714057523509, 0.040786783751050826, 0.026692877125080283, 0.04566437767827869, 9.999999999998899e-05, 0.11604748054185132, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07395604398987776, 0.15986617530222624, 0.15940641491336394, 0.09425923977458062, 0.11402594521322229, 0.0618049400494165, 0.09984151210102687, 0.20002999278916545, 0.1710041808599937, 0.001208515715145908, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018277699490221844, 0.02842949080639423, 0.003359113038068795, 0.03781975126395587, 0.0267656688986897, 0.07135250709766983, 0.06735693451091351, 0.07700480203705229, 0.09855305120349966, 0.09424255412089622, 0.09284248734104916, 0.07316497085362406, 0.0790710554354942, 0.07726393575557644, 0.1110285316012869, 0.12955703888254333, 0.11704192399813129, 0.1296910032444637, 0.16415256367139464, 0.11709933708511999, 0.1397467038587049, 0.13187160259257125, 0.1108563640017255, 0.08327576280493398, 0.09375050384740047, 0.04689860009815816, 0.0709017866729641, 0.10308510937507365, 0.06665910397116426, 0.06445874594655376, 0.07218135401942416, 0.03085937933852545, 0.17779087149450812, 0.10090060376115029, 0.16469284999763567, 0.1562801314480453, 0.1282473173702139, 0.23593757274807126, 0.12654798442911486, 0.1350738014713937, 0.13667691970192575, 9.999999999998899e-05, 9.999999999998899e-05, 0.15303822543647272, 9.999999999998899e-05, 0.1508426853489545, 0.14516788346312037, 0.16702928259875138, 9.999999999998899e-05, 9.999999999998899e-05, 0.06743688892554123, 0.07845627725443138, 0.1000834397662731, 0.16631608575467438, 0.1207914665021157, 0.03928172362186744, 0.03391929261879634, 0.056615725614002965, 0.09501540448438484, 0.03824121102611444, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04338192583470846, 0.045511073114331335, 0.04770355234988133, 0.029443688736963458, 0.04143420019681854, 0.13534463015794373, 0.14086830263905992, 0.14763022729669195, 0.13232226136578573, 0.14257059868765842, 0.129681982918032, 0.12049728613866795, 0.13462056016388757, 0.14689007985489466, 0.04577868346535252, 0.014459550158305134, 0.05628758818088153, 0.024144278539824704, 0.029947521646669695, 0.05125067575851805, 0.017746326317110483, 0.03452003949109328, 0.030585647475132594]}, "mutation_prompt": null}
{"id": "8d9d768c-3f9d-4264-839c-cff5b1069df8", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * (0.5 + evals) / (2 * self.budget))  # Adjusted cosine strategy\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced AdaptiveDE_CMA with balanced mutation factor adaptation using a cosine strategy for improved convergence.", "configspace": "", "generation": 11, "fitness": 0.05021356201127513, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "86525f7d-979f-424d-a72d-fc266a1e1535", "metadata": {"aucs": [0.11285449670450798, 0.1115380308725189, 0.1262988044526161, 0.05870427665409883, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10217306462172715, 0.07633282172969524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026518339805983837, 0.03104030688407944, 9.999999999998899e-05, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.03732297612831348, 0.00023040876205193683, 9.999999999998899e-05, 0.0155432551631286, 9.999999999998899e-05, 0.000367673971500726, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.0379436698126181, 0.019726589807585904, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.1145609309957697, 0.042141119013906936, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04268856704942303, 9.999999999998899e-05, 0.00990846602666351, 0.02651919247906609, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08792210434077674, 0.02096992833261191, 0.05758688575038162, 9.999999999998899e-05, 0.06376575829182696, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17659756294181284, 0.15940641491336394, 0.09819593613727884, 0.12328763811655408, 0.0618049400494165, 0.10447425008597344, 0.1607492388395203, 0.1710041808599937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003654053461401574, 0.028112723025944586, 0.000635863717310392, 0.024058287086382357, 0.0267656688986897, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.1127211185908451, 0.06750174035189471, 0.09284248734104916, 0.08335990332844156, 0.07933342081616923, 0.07726393575557644, 0.1314803822821219, 0.12286328928697599, 0.11704192399813129, 0.12549090065767088, 0.17221823528323166, 0.1259787746545329, 0.13626016043981903, 0.1302324890198452, 0.0981403274724495, 0.06765492248690175, 0.058986540608971016, 0.046898600221781606, 0.07782375979113154, 0.1136427810388454, 0.06962534683619181, 0.05648699256316181, 0.07705989053420859, 0.04949958350806738, 0.1889828031419929, 0.1680713027190721, 0.14143701693048027, 0.16198070950641852, 0.15315108701067492, 0.20235242043873625, 0.14010257373056534, 0.11932384735816182, 0.14552624690797333, 9.999999999998899e-05, 0.009481557254094719, 0.15382014535867983, 9.999999999998899e-05, 0.16714827407132815, 0.1529281481413438, 0.14813921998383917, 0.13685821253411867, 9.999999999998899e-05, 0.09208321784628992, 0.2749809123630442, 0.10610596248835424, 0.16417515413406014, 0.1207914665021157, 0.0403319683261909, 0.035083103106833935, 0.056615725614002965, 0.06953699159180582, 0.041498642020803556, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.02244304356697735, 0.0317201888080455, 0.04143420019681854, 0.1448906831917599, 0.1452852971303924, 0.14763022729669195, 0.14108875740194837, 0.1923561159088819, 0.15179545502534297, 0.1288083883150366, 0.1330913984859582, 0.14931941957739858, 0.049560814612553794, 0.030626047301963832, 0.031393493129599714, 0.0330280068877602, 0.03297345490966108, 0.044028536907908755, 0.03405027161011165, 0.034909810814556796, 0.03407601888186107]}, "mutation_prompt": null}
{"id": "09d37634-2eaa-4f78-9c7d-4a564e07e547", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        prev_best_fitness = np.inf\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * (0.5 + evals) / (2 * self.budget))  # Adjusted cosine strategy\n\n            # Dynamic adjustment of the crossover rate\n            if self.best_fitness < prev_best_fitness:\n                self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n            else:\n                self.crossover_rate = max(0.7, self.crossover_rate - 0.05)\n            prev_best_fitness = self.best_fitness\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced AdaptiveDE_CMA with dynamic crossover rate adjustment based on fitness improvement trends for accelerated convergence.", "configspace": "", "generation": 12, "fitness": 0.048774945328289875, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "8d9d768c-3f9d-4264-839c-cff5b1069df8", "metadata": {"aucs": [0.11650237197461755, 0.10866372360208698, 0.1262988044526161, 0.05799261046722681, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10217306462172715, 0.07633282172969524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0245046234371592, 0.03104030688407944, 9.999999999998899e-05, 0.027953270932632, 0.0012186513362246743, 0.007346650975361246, 0.03383497002195568, 0.00023040876205193683, 9.999999999998899e-05, 0.007065863101842984, 9.999999999998899e-05, 0.000367673971500726, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.039107335310901714, 0.016438444949404607, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.10264816599685289, 0.042141119013906936, 0.030951476252724985, 9.999999999998899e-05, 9.999999999998899e-05, 0.03873453765321211, 9.999999999998899e-05, 0.00990846602666351, 0.012807607210413297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012396689849255238, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039012238048551584, 0.027950650353326778, 0.046386487670021626, 9.999999999998899e-05, 0.03793089643749714, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17355892576628595, 0.15940641491336394, 0.10205900755957442, 0.11449835939784914, 0.0618049400494165, 0.10344556647215764, 0.1607492388395203, 0.1710041808599937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003654053461401574, 0.028429490291275727, 0.000635863717310392, 0.024058287086382357, 0.0267656688986897, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.10229168716725034, 0.06750174035189471, 0.09284248734104916, 0.07564601619956468, 0.0706827075212213, 0.07726393575557644, 0.13051399154366494, 0.12094992153017736, 0.11704192399813129, 0.1340441898973177, 0.1571627790096809, 0.1259787746545329, 0.13626987589650852, 0.1278801293319639, 0.0981403274724495, 0.06672449241970047, 0.05831811890078875, 0.046898600221781606, 0.07375848145866437, 0.1136427810388454, 0.0622340387948882, 0.05648699256316181, 0.07528308949597451, 0.04949958350806738, 0.16226810725792462, 0.13252839393421878, 0.18267594715850477, 0.1179877207806872, 0.14871816055965614, 0.14434597005883676, 0.13861158769956494, 0.1294106697161035, 0.14284702198870125, 9.999999999998899e-05, 0.009481557254094719, 0.15382014535867983, 9.999999999998899e-05, 0.16714827407132815, 0.1529281481413438, 0.16702928460962807, 0.14302492302401637, 9.999999999998899e-05, 0.06743688543461335, 0.2749809123630442, 0.1000834403516101, 0.16631608532428632, 0.1207914665021157, 0.039281723414535175, 0.04274145675724772, 0.056615725614002965, 0.06953699159180582, 0.05968549219508801, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.05055677597986252, 0.045511073114331335, 0.02244304356697735, 0.0317201888080455, 0.04143420019681854, 0.13888478423177897, 0.1400347803175207, 0.14763022729669195, 0.12466909444357477, 0.19764909376015705, 0.15957841563175967, 0.11626068606381845, 0.13886345141026102, 0.1562723884780446, 0.045968323039989434, 0.02252131087905984, 0.031393493129599714, 0.03294845349306508, 0.023732905693896966, 0.05420351120124145, 0.026351914584402225, 0.025653583690120607, 0.03407601888186107]}, "mutation_prompt": null}
{"id": "dc68628b-ace2-4b01-8f40-c020e6bfd3ad", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim))\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.dynamic_pop_factor = 1.05  # Factor for potentially adjusting population size\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * (0.5 + evals) / (2 * self.budget))  # Adjusted cosine strategy\n\n            # Adjust population size based on convergence\n            if evals < self.budget / 2 and np.std(fitness) < 0.1:\n                self.population_size = int(self.population_size * self.dynamic_pop_factor)\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced AdaptiveDE_CMA with dynamic population size adaptation based on convergence rate for faster optimization.", "configspace": "", "generation": 13, "fitness": 0.05021356201127513, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.06.", "error": "", "parent_id": "8d9d768c-3f9d-4264-839c-cff5b1069df8", "metadata": {"aucs": [0.11285449670450798, 0.1115380308725189, 0.1262988044526161, 0.05870427665409883, 0.05843786835194864, 0.030420311313528292, 0.05140423906395497, 0.10217306462172715, 0.07633282172969524, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026518339805983837, 0.03104030688407944, 9.999999999998899e-05, 0.027387287341591904, 0.0012186513362246743, 0.007346650975361246, 0.03732297612831348, 0.00023040876205193683, 9.999999999998899e-05, 0.0155432551631286, 9.999999999998899e-05, 0.000367673971500726, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05036646056244409, 0.033667547960281485, 0.04287777107098589, 0.039088515291900494, 0.04687545855643349, 0.03058144271518759, 0.03327721672346584, 0.048986754550083944, 0.02584969810736515, 0.0379436698126181, 0.019726589807585904, 9.999999999998899e-05, 9.999999999998899e-05, 0.015664361862444243, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.1145609309957697, 0.042141119013906936, 0.02853758606698542, 9.999999999998899e-05, 9.999999999998899e-05, 0.04268856704942303, 9.999999999998899e-05, 0.00990846602666351, 0.02651919247906609, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08792210434077674, 0.02096992833261191, 0.05758688575038162, 9.999999999998899e-05, 0.06376575829182696, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08925915176333643, 0.17659756294181284, 0.15940641491336394, 0.09819593613727884, 0.12328763811655408, 0.0618049400494165, 0.10447425008597344, 0.1607492388395203, 0.1710041808599937, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003654053461401574, 0.028112723025944586, 0.000635863717310392, 0.024058287086382357, 0.0267656688986897, 0.07135250709766983, 0.08439033755601066, 0.07700480203705229, 0.1127211185908451, 0.06750174035189471, 0.09284248734104916, 0.08335990332844156, 0.07933342081616923, 0.07726393575557644, 0.1314803822821219, 0.12286328928697599, 0.11704192399813129, 0.12549090065767088, 0.17221823528323166, 0.1259787746545329, 0.13626016043981903, 0.1302324890198452, 0.0981403274724495, 0.06765492248690175, 0.058986540608971016, 0.046898600221781606, 0.07782375979113154, 0.1136427810388454, 0.06962534683619181, 0.05648699256316181, 0.07705989053420859, 0.04949958350806738, 0.1889828031419929, 0.1680713027190721, 0.14143701693048027, 0.16198070950641852, 0.15315108701067492, 0.20235242043873625, 0.14010257373056534, 0.11932384735816182, 0.14552624690797333, 9.999999999998899e-05, 0.009481557254094719, 0.15382014535867983, 9.999999999998899e-05, 0.16714827407132815, 0.1529281481413438, 0.14813921998383917, 0.13685821253411867, 9.999999999998899e-05, 0.09208321784628992, 0.2749809123630442, 0.10610596248835424, 0.16417515413406014, 0.1207914665021157, 0.0403319683261909, 0.035083103106833935, 0.056615725614002965, 0.06953699159180582, 0.041498642020803556, 0.03967402848431323, 0.024704455354112143, 0.058614968481298324, 0.04753208647970186, 0.045511073114331335, 0.02244304356697735, 0.0317201888080455, 0.04143420019681854, 0.1448906831917599, 0.1452852971303924, 0.14763022729669195, 0.14108875740194837, 0.1923561159088819, 0.15179545502534297, 0.1288083883150366, 0.1330913984859582, 0.14931941957739858, 0.049560814612553794, 0.030626047301963832, 0.031393493129599714, 0.0330280068877602, 0.03297345490966108, 0.044028536907908755, 0.03405027161011165, 0.034909810814556796, 0.03407601888186107]}, "mutation_prompt": null}
{"id": "c196ceb1-7a5e-4c95-b48c-537136fc86cf", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        # Dynamic population size based on budget and dimension influences exploration and exploitation\n        self.population_size = 4 + int(3 * np.log(self.dim)) + int(self.budget * 0.002)\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate else self.population[i, j] \n                                             for j in range(self.dim)])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptation of DE parameters using cosine-based strategy\n            self.mutation_factor = 0.5 + 0.2 * np.cos(np.pi * (0.5 + evals) / (2 * self.budget))  # Adjusted cosine strategy\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Improved AdaptiveDE_CMA with dynamic population size adaptation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.07296428450014157, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.07.", "error": "", "parent_id": "8d9d768c-3f9d-4264-839c-cff5b1069df8", "metadata": {"aucs": [0.18829021870842555, 0.17304434728953844, 0.18456633704619385, 0.1254912111066263, 0.06465182560793858, 0.1059555013230391, 0.14165111413323372, 0.12694870529393976, 0.09451085575105356, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03247712604302144, 0.05028341483306309, 0.009374215932177132, 0.07608865570084944, 0.02811990642593387, 0.023068752140591675, 0.04871376153373075, 0.023984240746335317, 0.010674738340807233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.004302190893209046, 9.999999999998899e-05, 9.999999999998899e-05, 0.0630451748287929, 0.06310240638105191, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.04987989128029169, 0.0638860334912611, 0.048986754550083944, 0.04010198326211978, 0.030125173964407392, 0.03960256351333469, 9.999999999998899e-05, 0.04089420982479064, 0.018463344427090522, 0.07787119417705313, 0.1097753347192223, 0.011293333694524565, 9.999999999998899e-05, 0.1283381716808739, 0.11221460847868714, 0.10009980456393064, 0.0667108215001172, 0.20610531375316954, 9.999999999998899e-05, 0.05269756848535434, 0.06041808654605885, 0.06741106643383632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005635275894783853, 9.999999999998899e-05, 0.031763301891374995, 0.14741392306941636, 0.031085294555404097, 0.017383258841235927, 0.0368841160057809, 0.06503586762102354, 0.059353247587208724, 0.10311995812215724, 0.006391990298179939, 0.0576846484226744, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13898043764820467, 9.999999999998899e-05, 0.06018071392999558, 0.058681526180267785, 0.048777491247850246, 9.999999999998899e-05, 0.01194434665140065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18634206537191123, 0.1788810524173574, 0.2609161141741685, 0.1320029242685118, 0.1209677172693886, 0.1396324077700266, 0.16932971124410012, 0.18207465943039103, 0.1942899351894728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03005819492431072, 0.03807020927842297, 0.03967065987903351, 0.026392210578450204, 0.028371513501201262, 0.05451154217187737, 0.17306320808775455, 0.09589273262791698, 0.10130804717663411, 0.09855305120349966, 0.10852972522114013, 0.11528944645580907, 0.08808199726801991, 0.08849652487352178, 0.08262508964114146, 0.1358044557612118, 0.1311850586854436, 0.14352810184653642, 0.17913068038826419, 0.16309869031138824, 0.13972382200559896, 0.12028165949079228, 0.17377774300845283, 0.11363346445524236, 0.09341913402466129, 0.0600432576779002, 0.0645313632504596, 0.09870814897964741, 0.11941621062741647, 0.09492343658888991, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.18707815449237297, 0.16349289977296777, 0.17054097325457096, 0.1782981891163432, 0.20398173821837007, 0.18850180691293683, 0.20437766809615587, 0.17494869470677388, 0.15557730618887267, 0.14259457705437184, 0.15665304232650146, 0.15795105438885293, 0.16126281884391325, 0.1553502233274081, 0.1609438686157053, 0.16270972238167392, 0.15530469836970262, 0.1328678033986067, 0.11975137003449476, 0.10933184039366373, 0.08167024703901915, 0.1124492856899616, 0.1207914665021157, 0.09848142531149628, 0.10543676803925883, 0.10109822919136002, 0.11568876086994917, 0.16743677373421761, 0.1649004691983308, 0.11214243940902657, 0.12854631390429583, 0.057314351330853386, 0.076814093747406, 0.08251484250894703, 0.10125318320956433, 0.12751670068230359, 0.15805612643544864, 0.1587619663858153, 0.1537688265002245, 0.1709509132098268, 0.16253054781027398, 0.1631063243062053, 0.15569083516148585, 0.1806914402656732, 0.14976711545609123, 0.06509447145080649, 0.051915760265484834, 0.04932312992929744, 0.062057851892500016, 0.035038680151769364, 0.04389127502426016, 0.05773991435508574, 0.049632653677092464, 0.071885868178298]}, "mutation_prompt": null}
{"id": "f8773c1c-2313-4437-98a9-3e5749d6ce48", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        # Dynamic population size based on budget and dimension influences exploration and exploitation\n        self.population_size = 4 + int(3 * np.log(self.dim)) + int(self.budget * 0.002)\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Annealing-inspired adaptation of DE parameters\n            self.mutation_factor = 0.5 + 0.3 * np.exp(-evals / self.budget)  # Annealing-style adaptation\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced AdaptiveDE_CMA using annealing-inspired mutation factor and dynamic crossover for improved convergence.", "configspace": "", "generation": 15, "fitness": 0.07331140990004122, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.07.", "error": "", "parent_id": "c196ceb1-7a5e-4c95-b48c-537136fc86cf", "metadata": {"aucs": [0.20521860461703012, 0.17220765246065928, 0.18456633704619385, 0.1254912111066263, 0.06608213442931743, 0.10926068298629854, 0.14165111413323372, 0.12898551836523042, 0.09355926305649609, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021391438408852492, 0.06284632633499498, 0.011455395308835992, 0.07334617710903346, 0.027734649595779093, 0.03015499586498316, 0.046842016059002844, 0.03206702774364767, 0.013371371126068676, 9.999999999998899e-05, 0.011825374381444487, 9.999999999998899e-05, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.004302190893209046, 9.999999999998899e-05, 9.999999999998899e-05, 0.0630451748287929, 0.06310240638105191, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.04987989128029169, 0.0638860334912611, 0.048986754550083944, 0.04010198326211978, 0.030125173964407392, 0.03960256351333469, 9.999999999998899e-05, 0.04089420982479064, 0.017716048010824714, 0.07787119417705313, 0.1097753347192223, 0.011293333694524565, 9.999999999998899e-05, 0.13290086838291826, 0.10862834459855042, 0.0937385598060908, 0.0667108215001172, 0.20610531375316954, 9.999999999998899e-05, 0.05269756848535434, 0.05931056463008866, 0.06741106643383632, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005635275894783853, 9.999999999998899e-05, 0.013818804988303013, 0.12120933162984349, 0.03221585212961653, 0.017383258841235927, 0.03907416673514086, 0.05015539791142787, 0.06478053638044146, 0.08798232302324482, 0.023137207724263642, 0.14155004960203876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10569700017147277, 9.999999999998899e-05, 0.05981763872166179, 0.058681526180267785, 0.044454532446492334, 9.999999999998899e-05, 0.03620158705736576, 0.05560856321954166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18634206537191123, 0.19653162754111853, 0.2651270396795906, 0.1320029242685118, 0.11965872437730052, 0.1396324077700266, 0.1742737648073498, 0.17710001792898544, 0.19993529154072298, 0.00045286402971267403, 9.999999999998899e-05, 9.999999999998899e-05, 0.03082970275875796, 0.03967891592512918, 0.05489887423402984, 0.02459186571802907, 0.03860108540228446, 0.05156082822662034, 0.17306320808775455, 0.11091826374727076, 0.087865616874236, 0.09855305120349966, 0.10852972522114013, 0.12271439510149118, 0.08808199726801991, 0.095948501665028, 0.08552711672192492, 0.13596007617740635, 0.13437204849271112, 0.14352810184653642, 0.18790434240828857, 0.18841601812629172, 0.13814890492103116, 0.12028165949079228, 0.17377774300845283, 0.11363346445524236, 0.11284015175353612, 0.060076959245245365, 0.06499323542122748, 0.09073149265912306, 0.09592538949605567, 0.10620632861849044, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.19321073188797677, 0.16349289977296777, 0.1850232826016167, 0.1771197169258345, 0.17536723308737523, 0.194728396269907, 0.155929431730213, 0.18098974192279382, 0.16967004527471619, 0.1429056634209539, 0.15435780921799414, 0.1556474029785634, 0.15651725942641892, 0.15651135707097996, 0.15808495838039993, 0.16270972238167392, 0.16026497739125733, 0.026159090251507422, 0.11975137003449476, 0.09770115179841687, 0.08246017068461153, 0.13620621089098417, 0.1207914665021157, 0.09848142531149628, 0.10828624793788366, 0.10109822919136002, 0.11467422000967797, 0.19506391660639189, 0.10051730792859848, 0.11214243940902657, 0.12854631390429583, 0.057314351330853386, 0.076814093747406, 0.08877822891591292, 0.12978061018123166, 0.12751670068230359, 0.1570861398611072, 0.1587619663858153, 0.14763022729669195, 0.1709509132098268, 0.16898217958321748, 0.1631063243062053, 0.15778566621483825, 0.1641360317592706, 0.14976711545609123, 0.06409408850363307, 0.046811379447136425, 0.04932312992929744, 0.06024173974940916, 0.035038680151769364, 0.04821927365215628, 0.06458318102781135, 0.04340680652233164, 0.0715473579153535]}, "mutation_prompt": null}
{"id": "a267758a-e907-44dc-b24b-1f4f12e846e4", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim)) + int(self.budget * 0.002)\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.sigma_initial = 0.3\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.diversity_threshold = 1e-6  # New threshold for diversity control\n\n    def __call__(self, func):\n        evals = 0\n        stagnation_counter = 0  # Counter for stagnation detection\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n                stagnation_counter = 0  # Reset counter on improvement\n            else:\n                stagnation_counter += 1  # Increment counter on stagnation\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            self.mutation_factor = 0.5 + 0.3 * np.exp(-evals / self.budget)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Adaptive population control based on diversity\n            population_std = np.std(self.population, axis=0)\n            if np.all(population_std < self.diversity_threshold) or stagnation_counter > 10:\n                self.population_size = min(int(self.population_size * 1.1), int(self.budget / (evals + 1)))\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                stagnation_counter = 0  # Reset stagnation counter\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Robustified AdaptiveDE_CMA using diversity-preserving techniques and adaptive population control for faster convergence.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "f8773c1c-2313-4437-98a9-3e5749d6ce48", "metadata": {}, "mutation_prompt": null}
{"id": "9048e1e8-87b2-493d-b51d-6989ad893e4c", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        # Adjust population size strategy for better balance\n        self.population_size = 4 + int(3 * np.log(self.dim)) + int(self.budget * 0.002)\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.9  # Crossover probability\n        self.sigma_initial = 0.3  # Initial step size for CMA-ES\n        # Improved population initialization using normal distribution\n        self.population = np.random.normal(0, 1, (self.population_size, self.dim))\n        self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            # Evaluate current population\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            # Update the best solution\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptive mutation factor scaling based on evaluations progress\n            self.mutation_factor = 0.4 + 0.5 * (1.0 - evals / self.budget)\n\n            # Covariance Matrix Adaptation (CMA) inspired update\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Enhanced AdaptiveDE_CMA using adaptive mutation factor scaling and improved population initialization for accelerated convergence.", "configspace": "", "generation": 17, "fitness": 0.06182409152701882, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.07.", "error": "", "parent_id": "f8773c1c-2313-4437-98a9-3e5749d6ce48", "metadata": {"aucs": [0.1335956162507046, 0.16027425744493085, 0.157025244232043, 0.0691601945876752, 0.06311027328077412, 0.06144300167194994, 0.0661207265896836, 0.08343743142405069, 0.08468693137910177, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03412805225915616, 0.014310430250809247, 0.01486502344621099, 9.999999999998899e-05, 0.031616236456537994, 0.030807338479443724, 9.999999999998899e-05, 0.013862300693897822, 0.01041888453796469, 0.03670116419489933, 0.027570126483628332, 0.00842483178325093, 0.01948131026589095, 0.000273909556650187, 9.999999999998899e-05, 0.0016545465890037692, 9.999999999998899e-05, 9.999999999998899e-05, 0.004820492974557999, 0.014686722277850284, 0.011578609766261572, 0.008530000205076105, 0.014244473262100654, 0.019441437994830668, 0.008298072022259517, 0.013537347816124923, 0.019883281936605268, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014692440461487877, 0.0016598489247616754, 0.023075947390889473, 0.05589886400871491, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14747295439957708, 0.14216807984591673, 0.12838702673611113, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011735387599778768, 9.999999999998899e-05, 0.08155046432619206, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08722425624948738, 0.06384961918358278, 0.11071597684789358, 0.12321357064122473, 0.09447283472541423, 0.045074014409761, 0.11484797488940712, 0.07810894436478755, 0.07200724241626555, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040031730675907595, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12113125841394556, 0.13889841169497996, 0.10090472390383731, 0.10485906600470951, 0.10758479744326721, 0.12997785149499141, 0.17777469220531783, 0.1899261424842631, 0.18041385587129444, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01200105175249433, 0.005782253115570901, 0.03053379842989612, 0.008601116427712996, 0.01804614982626429, 0.029507401030463787, 0.11047053203777923, 0.12781552906001037, 0.10337275004596835, 0.08025885604789562, 0.08969083692533009, 0.07215523493169418, 0.12732860547781688, 0.11215329018556275, 0.09059101635941302, 0.1414780969332664, 0.12838134812765134, 0.13695894402421416, 0.16535607625824955, 0.17166462459465182, 0.1631653065477252, 0.12555121596071894, 0.12243317141404808, 0.12779209555529292, 0.06278652377212224, 0.061406416487466364, 0.07291287774337196, 0.10572379510913454, 0.12029987883463378, 0.11767265847071706, 0.053932604821561814, 0.057686078550909015, 0.05749264793062414, 0.21892861311350997, 0.1895204212357472, 0.25928322005504534, 0.19481244191485347, 0.26049330735254883, 0.20622906991561107, 0.19799864221008945, 0.18037362304387083, 0.18492818336184036, 0.1584802517219579, 0.1494251622116588, 0.13750886454278466, 0.18181540986262867, 0.04086513139790726, 0.141375770602706, 0.1549651338062129, 0.13547958741869792, 9.999999999998899e-05, 0.17093040423519945, 0.11793191810387471, 0.11614889100897485, 0.10519165041940193, 0.09380533345862807, 0.08680841013151841, 0.05467385137102376, 0.05102174819876404, 0.06447364916007059, 0.06557308619988012, 0.04936861007729931, 0.09030996976753958, 0.054494749356795213, 0.051172734221179406, 0.046640432606835036, 0.08769756478225044, 0.07693667891156308, 0.1415784007575025, 0.15467869901900433, 0.1724983922062331, 0.15237941325436477, 0.17383493604731104, 0.1673032446476631, 0.15739925215095096, 0.16380109573776813, 0.15493456634371883, 0.16611847929148627, 0.04279329132758469, 0.04197585446070662, 0.04803877387622291, 0.047752562732709114, 0.0650725024984824, 0.051661627940818855, 0.060439020245712904, 0.03493099440875025, 0.05062431300802128]}, "mutation_prompt": null}
{"id": "9bc25bce-944c-4994-a371-68e2ec4d9164", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 4 + int(3 * np.log(self.dim)) + int(self.budget * 0.002)\n        self.mutation_factor = 0.6  # Adjusted initial mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover probability\n        self.sigma_initial = 0.3\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))  # Momentum for exploration\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.005  # Introduce adaptive learning rate\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            self.mutation_factor = 0.4 + 0.4 * np.exp(-evals / self.budget)  # Enhanced annealing adaptation\n            learning_rate = 0.005 + 0.01 * (np.exp(-evals / self.budget))  # Adapt learning rate\n\n            # Momentum-based exploration adjustment\n            for i in range(self.population_size):\n                self.momentum[i] = 0.9 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, self.sigma_initial**2 * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA", "description": "Hybrid AdaptiveDE_CMA with Momentum-Inspired Exploration and Adaptive Learning Rates for Enhanced Convergence.", "configspace": "", "generation": 18, "fitness": 0.07961692907967637, "feedback": "The algorithm AdaptiveDE_CMA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "f8773c1c-2313-4437-98a9-3e5749d6ce48", "metadata": {"aucs": [0.19007864574764222, 0.19950495506464572, 0.2370424493891724, 0.10019600410547991, 0.07840523383778764, 0.12076853199574666, 0.152600147496454, 0.12339952145037036, 0.105682217784685, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020509992449770698, 0.03590223062746267, 0.029186350702699038, 0.06184824793870125, 0.031040997645114254, 0.02879197248566956, 0.08140147075045356, 0.03608408250879769, 0.021701557154338524, 0.01650921383146764, 0.006862013447512805, 9.999999999998899e-05, 0.02089388095697431, 0.003822053673545045, 9.999999999998899e-05, 0.017158154190371144, 9.999999999998899e-05, 9.999999999998899e-05, 0.06488237923467532, 0.06801118449774024, 0.06659813437676854, 0.08447619750113722, 0.05869711792192278, 0.04598035148642232, 0.10631318278150415, 0.06515799869006988, 0.04572106157174061, 0.02585929027583933, 0.04027591480715387, 0.005231506105436545, 0.05700071543677476, 0.044855637349895394, 0.07009986886700847, 9.999999999998899e-05, 0.03483091376702707, 9.999999999998899e-05, 0.15099931339955164, 0.13596638813463346, 0.12779525223003874, 0.0948911449758234, 0.11619142265764582, 0.023160133160085805, 0.058999966638573875, 0.10408034080404704, 0.08234021342085873, 0.036646545647201156, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06884547477830838, 0.00011550049785979954, 0.09793465993980188, 0.08284843032207445, 0.04255878190563578, 0.04138865436682826, 0.08520121590366203, 0.04328182690485605, 0.05317795828706695, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1366411056306559, 0.07639597273609511, 0.09256712408777401, 0.047569267023244044, 0.05478766128140866, 0.010032893405067078, 0.06825474505259865, 0.14473232336462605, 0.032114694671921074, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2061838517833261, 0.24059402247648687, 0.21804133750648735, 0.14902811757326673, 0.10968455320430892, 0.10582917654395696, 0.18778788488458065, 0.22672269854301041, 0.18093829399907602, 0.023517909631606715, 9.999999999998899e-05, 9.999999999998899e-05, 0.04424528017682894, 0.04691678496936835, 0.04509672309516477, 0.04056024879325082, 0.05655507729504383, 0.06797204554888381, 0.13202959934083502, 0.12694430724484695, 0.12975451106286984, 0.15061563809769085, 0.11550191207095284, 0.10754272317801372, 0.1093271855797695, 0.08854984098546104, 0.15565021760627495, 0.12960078072724168, 0.13348095172675367, 0.14866884018730853, 0.14316703773570572, 0.18936388476921406, 0.1459363078050545, 0.12388428469505275, 0.18873893859515412, 0.11704474507127582, 0.06670637931634571, 0.060014158146215246, 0.06538282105224968, 0.1257187879300864, 0.10495460129804612, 0.10355038574608622, 0.10123918150310163, 0.10744864885669902, 0.08190474880783372, 0.20234762107300175, 0.20277918224488356, 0.2089619648213068, 0.20103600120726317, 0.2593172278316813, 0.227063085299824, 0.19366126237125647, 0.20994245681818724, 0.20212708526193524, 0.14343586970304278, 0.15386080669834168, 0.17139994236510414, 0.15231128113459147, 0.1562761344233864, 0.15371023257250271, 0.14941191863849945, 0.13212692336525322, 0.1376654212237035, 0.09594447461272049, 0.13974366084986867, 0.08716936827873756, 0.1565951493873432, 0.12410916852753306, 0.10856382521931296, 0.07909084442577408, 0.1117266194655091, 0.08997483402300566, 0.2204760364927293, 0.11571682046856291, 0.16940629878497726, 0.11190495431759395, 0.0577823707007159, 0.057942994064731246, 0.0732372853180745, 0.09077772717691901, 0.09072875450769802, 0.15492387935052776, 0.15109726198014983, 0.17642813080740383, 0.171916531764448, 0.20253316213123795, 0.20336723561470949, 0.16107480625586812, 0.14955452078817066, 0.1720753066888726, 0.056075502316724535, 0.05111470984107658, 0.049524181023262503, 0.06150891012720261, 0.04458785406875032, 0.04916619845253267, 0.06560057112339979, 0.06292396007763379, 0.0549625388278433]}, "mutation_prompt": null}
{"id": "c6cb8ae5-e67f-4c87-8212-3082432d8df3", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 10)\n        self.mutation_factor = 0.7  # Updated initial mutation factor\n        self.crossover_rate = 0.9  # Updated crossover probability\n        self.sigma_initial = 0.2  # Adjusted initial sigma\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))  # Momentum for exploration\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.01  # Updated adaptive learning rate\n        diversity_threshold = 0.1  # Introduced diversity threshold\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, 0.01, self.dim)  # Noise infusion into mutation\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) + noise, self.lower_bound, self.upper_bound)\n                crossover_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            self.mutation_factor = 0.5 + 0.3 * np.exp(-evals / self.budget)  # Adjusted annealing adaptation\n            learning_rate = 0.007 + 0.01 * (np.exp(-evals / self.budget))  # Refined learning rate\n\n            # Momentum-based exploration adjustment\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.9 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, (self.sigma_initial**2 + evals / self.budget) * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2", "description": "Introduced adaptive population scaling, modified mutation strategy with noise infusion, and added diversity preservation for enhanced exploration and convergence speeds.", "configspace": "", "generation": 19, "fitness": 0.09106776749303856, "feedback": "The algorithm AdaptiveDE_CMA_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "9bc25bce-944c-4994-a371-68e2ec4d9164", "metadata": {"aucs": [0.2645524364999353, 0.2709142491519848, 0.19660126876794448, 0.07568665686441522, 0.0874784076789139, 0.057123112923321395, 0.13473306792725603, 0.11803166916135666, 0.23188600583224628, 0.014844289776583919, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011959950795924268, 0.06277123987568867, 0.01791820307029024, 0.03557339143964289, 0.044488115600706424, 9.999999999998899e-05, 0.04831414570644088, 0.013359001933933135, 0.00983707988085536, 0.005752800658471835, 9.999999999998899e-05, 9.999999999998899e-05, 0.0382702652117185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00882643196775168, 9.999999999998899e-05, 0.0641088812541748, 0.25841628402714545, 0.822591050943905, 0.06267741376767988, 0.072094687535591, 0.05948889148148251, 0.059846993118230274, 0.4761308762902158, 0.06440282484309046, 0.10150752981358324, 0.012905207827051846, 0.04042415199159166, 0.02831083680045432, 0.0522419783330732, 0.03933526619672589, 0.059789929363561756, 0.02469565667285134, 0.004233853060240822, 0.13150591574782322, 0.07747896986162939, 0.03589845755830878, 0.023282553633487302, 9.999999999998899e-05, 9.999999999998899e-05, 0.09767058028118158, 0.04734648577227818, 0.04139028855894489, 0.14137952527439646, 9.999999999998899e-05, 0.01060405245087892, 0.015537720288608448, 0.0005275688697385927, 9.999999999998899e-05, 0.005902069201722093, 0.08403323850456601, 0.058771909938544975, 0.15964987882465465, 0.08259462725377886, 0.14495059910628494, 0.06448917745288596, 0.3205590323320989, 0.07825950757667599, 0.1301959412409135, 0.003934667704157069, 0.03249170574819904, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007798975698183996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09778303794449461, 0.05787091253386156, 0.07240875283242676, 0.0635894742938874, 0.034355395038468295, 9.999999999998899e-05, 0.13646505415942933, 0.05966206574012012, 0.013524024477650554, 9.999999999998899e-05, 0.007492941162259736, 0.00954588124025102, 0.020575686407345306, 9.999999999998899e-05, 0.008039247400127736, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024047120641846442, 0.011690331828869804, 9.999999999998899e-05, 0.0026520509624797795, 0.006317655131704458, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2607530352621056, 0.2808171714414964, 0.1799943239677434, 0.11137433354738258, 0.17095866758294742, 0.1265685201374812, 0.206385558331173, 0.2725643504669977, 0.19482467423872618, 0.018867828298050004, 9.999999999998899e-05, 9.999999999998899e-05, 0.037082815792762625, 0.05947471685118144, 0.07017710703893043, 0.020482324264802232, 0.029413741058060605, 0.03928091565740377, 0.09974771600409438, 0.19166424931816295, 0.13287236737935093, 0.12798148499882223, 0.13205402435579727, 0.13881067362201793, 0.10918202321651604, 0.11892817204702533, 0.09858942843562801, 0.11992667744195917, 0.16336664448660154, 0.14252893573206782, 0.13608898264413383, 0.15233342415802054, 0.13160575507177286, 0.13011885679054502, 0.12366060498520692, 0.10300190111800567, 0.07367324771821293, 0.09215992911177506, 0.06006819646673289, 0.06558451702578472, 0.07318799610418869, 0.07261412768304343, 0.07215697297802248, 0.07360456335769416, 0.04080405566933365, 0.21156207376491643, 0.19683934943804593, 0.24164926278727084, 0.19496459985607684, 0.20763200648859637, 0.19584975491064072, 0.21900739905652522, 0.19254307882366206, 0.18788116311880176, 0.1588025071908079, 0.1501293870622209, 0.17028794236816247, 0.15912988208947898, 0.15411168914664342, 0.1651131108214864, 0.1713964717008868, 0.14767111058399296, 0.13995319638898274, 0.07992548558566448, 0.15245950825323196, 0.14606467890526598, 0.2139169334462464, 0.17733809228597985, 0.10803382808703721, 0.0893194777874915, 0.10142238316063634, 0.10011764856107619, 0.42145359366250146, 0.09982890038263414, 0.09950888435226168, 0.11535990434983145, 0.09097191981125163, 0.08914213156590389, 0.16734035910556555, 0.09926439556601785, 0.11919414161556197, 0.20931287984745806, 0.19815538768704888, 0.20807308622058807, 0.2025535703768495, 0.19208740796533474, 0.20980089779637778, 0.22089820122327164, 0.2078229633608163, 0.21737899047902776, 0.06501996083004957, 0.05254865724624269, 0.05470791685401433, 0.05228470784558448, 0.04090285822850637, 0.0777384301945997, 0.06284582539944517, 0.07226288984808249, 0.05732409843271702]}, "mutation_prompt": null}
{"id": "41f87efd-6d15-418c-bccd-c5a8da7f14ac", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 10)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.9\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.01\n        diversity_threshold = 0.1\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, 0.01, self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) + noise, self.lower_bound, self.upper_bound)\n                crossover_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:  # Introduce small chance of direct mutation vector acceptance\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            self.mutation_factor = 0.5 + 0.3 * np.exp(-evals / self.budget)\n            learning_rate = 0.007 + 0.01 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.9 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, (self.sigma_initial**2 + evals / self.budget) * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced", "description": "Enhanced mutation and crossover strategies for improved diversity and convergence performance.", "configspace": "", "generation": 20, "fitness": 0.09203024722958608, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "c6cb8ae5-e67f-4c87-8212-3082432d8df3", "metadata": {"aucs": [0.23137489956617352, 0.19446773123609973, 0.2110757442208443, 0.07141659792734933, 0.08482585644544438, 0.09391108904006817, 0.08410713629465971, 0.1513486710837828, 0.0940992365072647, 0.00010155744654216647, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023341802585128635, 0.04009078319026482, 0.020023461913423635, 0.03685084461216248, 0.03104963623365653, 0.005548157220413352, 0.03821394109651721, 0.007637757728815808, 0.028750051338687133, 0.004890721469786197, 9.999999999998899e-05, 0.0037704862810573614, 0.03701484492655871, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003831389821825626, 9.999999999998899e-05, 0.08487167487388247, 0.3572505871879552, 0.23973647576064983, 0.07175035177434186, 0.06733469969000871, 0.0588253104670301, 0.059405840346602456, 0.6774477505245156, 0.0592869823973724, 0.09497542538111958, 0.0065956683832111285, 0.0008900909936657708, 0.018437008032303526, 0.03503354808747716, 0.04851094066743389, 0.0924951441549321, 0.0336430690889552, 0.013382819799260481, 0.15035946597193628, 0.11701972729286514, 0.09139556221879142, 0.06040813334814632, 0.030366606262026696, 0.0033955269418775025, 0.0649403219500666, 0.032656657902843333, 0.04096725947574209, 0.13659270390838096, 0.0002979255122059765, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007764047296088261, 9.999999999998899e-05, 0.21754593828947022, 0.016608591896243752, 0.08185571180455409, 0.28437364575252855, 0.06948827275339176, 0.2859996565682885, 0.007483130614748923, 0.21028301595065202, 0.06784057961427448, 0.15436717443016368, 0.06894394905616408, 0.08905836112404486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00938909206345162, 9.999999999998899e-05, 0.08803367204694501, 0.04336571145310286, 0.10389112350400209, 0.06469990855055041, 0.05645088088538108, 0.047123702125930644, 0.1152291272475563, 0.09590624948685877, 0.11291944305158608, 9.999999999998899e-05, 0.035978821978034814, 0.00607265873991869, 0.0039530952429635, 0.00471395578095124, 0.0011682175548048956, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000709633929677711, 0.016185881925975032, 9.999999999998899e-05, 9.999999999998899e-05, 0.00024003095762914484, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.23197799413792886, 0.2975999396769976, 0.22768915962135672, 0.11291097076099377, 0.14037457626770722, 0.14121400044589882, 0.17708404473471395, 0.2971810034355873, 0.2762096171827718, 0.009640497088612587, 9.999999999998899e-05, 9.999999999998899e-05, 0.03329577270631323, 0.008895790990572694, 0.06924910539290663, 0.004691602639686265, 0.03161886469661035, 0.06329890677186978, 0.09901401883872929, 0.1938258628280879, 0.1419927981918312, 0.12735454481156505, 0.11448495013311677, 0.11070665518195622, 0.08526758206416596, 0.09930745448041067, 0.10215698640351933, 0.12460688061669423, 0.1631070963912432, 0.1272446956845339, 0.1366026671632783, 0.15376686621433888, 0.1336137120157237, 0.13463501596962635, 0.14963924805534534, 0.1080211461778936, 0.06176964064954105, 0.12457628817135669, 0.05940972205195483, 0.0830313972722212, 0.10244138433048122, 0.07701818533208493, 0.0644736521467294, 0.07308077421871662, 0.058122184982169034, 0.21459102444215217, 0.20262493531432058, 0.22143336700855631, 0.23059747908618333, 0.18511802043841874, 0.2450666299935942, 0.19634244458560457, 0.2460553949995683, 0.21649376508977447, 0.16724356827443787, 0.13112360866339678, 0.14981156697757347, 0.14785640760532337, 0.16366058890819435, 0.1670967424158365, 0.1191191300868577, 0.16824501949059012, 0.11126599053059705, 0.12257897488454561, 0.1516798893179826, 0.08659821314623639, 0.555783554030084, 0.1702231857557952, 0.11406758944484896, 0.09571899582974797, 0.09186887129965493, 0.11046609990755041, 0.2324832471563657, 0.08912376446214787, 0.05644752059118041, 0.08387426480575755, 0.14631533110244088, 0.08118640187322113, 0.12948707095825374, 0.0777364168428536, 0.12602417823226042, 0.2089520927761015, 0.2348675052199758, 0.21413802898487944, 0.20415451332112466, 0.18790661522901542, 0.18343481260702954, 0.19708048333160366, 0.22979085276873212, 0.21573082720276093, 0.0710634839603086, 0.07734495523682616, 0.057988666585350956, 0.026825140814480064, 0.04643108974245547, 0.04610705611417509, 0.041350161132401086, 0.03915041031536637, 0.05178113091632153]}, "mutation_prompt": null}
{"id": "5fc34cb9-9e51-4072-933f-13a3ba7faacf", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 10)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.9\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.01\n        diversity_threshold = 0.1\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                d = self.population[np.random.choice(idxs)]\n                noise = np.random.normal(0, 0.01, self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c + d - a) + noise, self.lower_bound, self.upper_bound)\n                crossover_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:  # Introduce small chance of direct mutant acceptance\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            self.mutation_factor = 0.5 + 0.4 * np.exp(-evals / self.budget)  # Adjusted factor\n            learning_rate = 0.007 + 0.015 * (np.exp(-evals / self.budget))  # Adjusted learning rate\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.9 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            self.population = np.random.multivariate_normal(mean_vector, (self.sigma_initial**2 + evals / self.budget) * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced", "description": "Integrating adaptive learning rates and a hybrid mutation strategy to enhance convergence speed.", "configspace": "", "generation": 21, "fitness": 0.09162564553321212, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "41f87efd-6d15-418c-bccd-c5a8da7f14ac", "metadata": {"aucs": [0.20430653283106448, 0.2599356653366822, 0.21516205470327554, 0.09067404849713678, 0.07608267617059061, 0.09640182504593109, 0.20394731013555378, 0.10446958632850456, 0.15486494693211406, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027821403288708635, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008623987934917698, 0.06255859968958188, 0.0402482667696451, 0.0434184178012591, 0.014393890381876884, 0.022139107506648048, 0.04334682085852237, 0.02229787079261114, 0.034533869362027736, 0.026922397704456813, 9.999999999998899e-05, 0.00019482374349777398, 0.037205382513420204, 9.999999999998899e-05, 0.04261859605927898, 9.999999999998899e-05, 0.0008607685181762914, 0.003292219254500184, 0.08283085239162957, 0.10524974599492576, 0.8901708827459197, 0.4961764758530183, 0.26562372533170286, 0.056496676381990296, 0.054082255309247595, 0.33402435986018686, 0.06467782725859739, 0.10237869474790007, 0.024390331042233093, 0.01436523918364141, 0.008014980381039427, 0.22000192647811367, 0.04072580365573797, 0.07517414519677823, 0.048781019425075844, 0.00438077757472588, 0.1105811830184088, 0.09995140564636873, 0.1434651935502077, 0.04612323338678037, 0.013045537531755191, 0.00454759217667966, 0.03113750403110349, 9.999999999998899e-05, 0.04113751002776067, 0.13975661247731097, 9.999999999998899e-05, 9.999999999998899e-05, 0.003091394513483059, 0.12025890247691517, 9.999999999998899e-05, 0.3232116072770237, 0.009252233091615047, 0.006480039330251874, 0.0649950601790944, 9.999999999998899e-05, 0.17263343090276395, 0.10578526952495382, 0.0789328478148944, 0.09965398649210588, 0.029289310519155287, 0.0035926532974984715, 0.09014285412533063, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000858225507444299, 0.015936015552368787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11796583880719591, 0.03679208974027948, 0.08466929478684981, 0.06381135067582222, 0.04467391709527524, 9.999999999998899e-05, 0.09849967706448348, 0.0643776062373741, 0.014401643860573299, 9.999999999998899e-05, 0.03864143500295669, 9.999999999998899e-05, 9.999999999998899e-05, 0.0059270101454661495, 0.0076150238908255785, 9.999999999998899e-05, 9.999999999998899e-05, 0.0043430872234179185, 9.999999999998899e-05, 0.02982823003586743, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.23158345696397886, 0.17578804606341292, 0.1843233780164798, 0.11635506399940188, 0.13516870162670747, 0.17991004094812202, 0.18819986677748823, 0.31765015729681256, 0.26200339595646716, 0.018418121453598557, 9.999999999998899e-05, 9.999999999998899e-05, 0.05040385538448533, 0.01033472414367842, 0.06397640164468554, 0.026850585988533182, 0.03486581027447777, 0.07510954221735122, 0.09991867398918108, 0.10414631314800993, 0.08517270996219484, 0.1434658420949565, 0.1351989602771626, 0.10080787268372293, 0.09282755752285043, 0.11223112125953316, 0.1033281084661607, 0.12798896272757954, 0.14601468097448633, 0.12621926427595898, 0.135066431326466, 0.15581940974045283, 0.1324174702403872, 0.13688921164504841, 0.11722507519161462, 0.13249084569069836, 0.061259544376736974, 0.07666503611852493, 0.06006182301473195, 0.0879062858780515, 0.09358076586946695, 0.08142266505663798, 0.06580424732244261, 0.0840126829118133, 0.0634769622687048, 0.22443373592575921, 0.22971803437240035, 0.24566051539790978, 0.1952845665330638, 0.16369208541177793, 0.20261802637701298, 0.22809038817825356, 0.23286334568109224, 0.1806024542346233, 0.10401590995455567, 0.17343912611447865, 0.15625330681468863, 0.15930118430117524, 0.16641019707408233, 0.15241469388360496, 0.1069771761513797, 0.13768295946062914, 0.15953946369607508, 0.11505167406379391, 0.18601281006756576, 0.0806934788853576, 0.14070213236144047, 0.17077583793614937, 0.15491841319444444, 0.10743484285730176, 0.09201280080117524, 0.10404043485281222, 0.10964429108763374, 0.08452767212552537, 0.2388715194068345, 0.121466012038275, 0.03770232960143949, 0.07767418959542005, 0.10778169630600842, 0.06450546546957159, 0.0938725745456217, 0.18075020861107027, 0.18260911223359755, 0.2425488588274276, 0.2046954128432652, 0.2116758270886171, 0.19993037859973783, 0.22664197511200723, 0.210478411645601, 0.23233269235146392, 0.0770383359486645, 0.06452702748211836, 0.04627444845498885, 0.0919049530437469, 0.0502941786820964, 0.07141926759352768, 0.04763299926586584, 0.04383593601793856, 0.0743317998337869]}, "mutation_prompt": null}
{"id": "55e4fac6-6d15-46d1-a0e6-ccf28f52f853", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 10)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.9\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.01\n        diversity_threshold = 0.1\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, 0.01, self.dim)\n                mutation_intensity = 1 + (evals / self.budget)  # Adaptive mutation intensity\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                crossover_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:  # Introduce small chance of direct mutation vector acceptance\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            self.mutation_factor = 0.5 + 0.3 * np.exp(-evals / self.budget)\n            learning_rate = 0.007 + 0.01 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.9 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.01  # Small adaptive adjustment\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified", "description": "Enhanced exploitation and exploration balance using selective mutation intensification and adaptive crossover dynamics.", "configspace": "", "generation": 22, "fitness": 0.10395776226092322, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.10.", "error": "", "parent_id": "41f87efd-6d15-418c-bccd-c5a8da7f14ac", "metadata": {"aucs": [0.32707338078521775, 0.25166931125703773, 0.31810766103615173, 0.13461697583004806, 0.18375694366503603, 0.21634798007209488, 0.2215644749726685, 0.2573795666906825, 0.18805760148213335, 0.014532488954175249, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011508331190996923, 9.999999999998899e-05, 0.022993451443521717, 0.03997383768265117, 0.020005234865481003, 0.04841944758282768, 0.033038747458729034, 0.005083526894133827, 0.038040971826746706, 0.007548280075339808, 0.013920066641233464, 0.013045836367535757, 0.00440160188661598, 0.00227501664153007, 0.03739290520429717, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012309126039777851, 9.999999999998899e-05, 0.13334881383128028, 0.3458522161072417, 0.2850110452202288, 0.07176771322278586, 0.07146475587507362, 0.05957111074272947, 0.059424726798268934, 0.7189730124385876, 0.06073810468405716, 0.13700451817233938, 0.020929914945101324, 0.013812395957763735, 0.04977156360863866, 0.05839773275352089, 0.07251954046909326, 0.19475289738525858, 0.04567810587841559, 0.022277904200300513, 0.14035706029603257, 0.11700113921402644, 0.08603685792245963, 0.06091388845929069, 0.04009223358937963, 9.999999999998899e-05, 0.0619563799147228, 0.016639188724990928, 0.05878154766539534, 0.11304609987802594, 0.01950725867337655, 0.03971715765137651, 9.999999999998899e-05, 0.027768797453592176, 0.010168130993726154, 0.16913001228574498, 0.09437983995921273, 0.08840366886429274, 0.26849997498134237, 0.0611099825646817, 0.04724049860974122, 0.035908287472517064, 0.216055843362441, 0.064630600456829, 0.15546564969914412, 0.06125764652864074, 0.1159724051041705, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005142456904087878, 9.999999999998899e-05, 0.08839860690358292, 0.04399541534457019, 0.10273761152774696, 0.06484875959826442, 0.03880327485544044, 0.0486151970567309, 0.14315562462165, 0.09432770106349764, 0.11836602097277626, 0.003256497141738701, 0.06508317977582723, 0.015255045247924315, 0.024814227340984818, 0.024156610260767986, 0.01929584792077854, 0.004685002603924349, 0.02277657047799453, 0.01504009762108327, 0.016106204364467858, 0.03810305517428547, 0.0047709016380211855, 0.027373677103690874, 0.019550280078243443, 0.020638218571703337, 0.00016184264609286902, 0.025833882849521594, 0.027330468438541144, 0.29115008990508284, 0.29666946628168733, 0.28567926483055484, 0.18757454945788032, 0.20937947437735382, 0.20371819880387798, 0.2634408167115615, 0.3502306010670865, 0.33630764102538224, 0.019842593525020713, 9.999999999998899e-05, 9.999999999998899e-05, 0.03566548382671608, 0.009251962144122605, 0.0540874818330076, 0.023229028765322846, 0.03177100385741183, 0.06867129586506493, 0.10311903733584982, 0.15880609625274678, 0.13078162304543384, 0.14198812842809405, 0.11663024048526827, 0.1336107328115449, 0.09683988055568371, 0.11222481939452134, 0.12379981896914272, 0.11969669459344168, 0.19602422533646968, 0.126221433372392, 0.13614034276515707, 0.16575527629948195, 0.13571624786471692, 0.13912406847446823, 0.1558135538984161, 0.1091297747350638, 0.06599316632558572, 0.11974099456388398, 0.05875297794927592, 0.08065109055037123, 0.12435401613871744, 0.0750560650214891, 0.07382102958541492, 0.06910117842654495, 0.04984721847602536, 0.23954345083877637, 0.21857572933779212, 0.2232131688850837, 0.18872166054273654, 0.16793802514759815, 0.2518744712679446, 0.21948090898044403, 0.20044594339950195, 0.23434728621931722, 0.1691136332709544, 0.1356877352712822, 0.14899415383635406, 0.1487388804619273, 0.16846907897166152, 0.1667188802778533, 0.16368752867991732, 0.1680472785888626, 0.10420168465822643, 0.1327809303309221, 0.15063242298160984, 0.09300815946851904, 0.6637829114449354, 0.1800917129032401, 0.11439970684560807, 0.10638087518411576, 0.09768544785959765, 0.1273775240426619, 0.28044822607680975, 0.09349504695955313, 0.10052183694514583, 0.10749009298061096, 0.14984513614849604, 0.10734486345732075, 0.1293903686823985, 0.05193198766967144, 0.21275823805811112, 0.22395856750798393, 0.20502709665149355, 0.20551324236296853, 0.20102424878891, 0.21430948997924693, 0.18427391154817574, 0.18117548224824387, 0.22254934281820637, 0.2176998058528572, 0.06380466785057415, 0.07115977536560514, 0.060694149454272206, 0.04107978306700388, 0.05607446364702484, 0.046543979732247, 0.04505727189414088, 0.04405138415932164, 0.05042075906450205]}, "mutation_prompt": null}
{"id": "e25563f0-8109-477a-bfcd-22e0e101dfc9", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V3_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 10)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.9\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def adaptive_mutation_factor(self, evals):\n        return 0.7 + 0.2 * np.sin(np.pi * evals / self.budget)\n\n    def adaptive_crossover_rate(self, evals):\n        return 0.9 - 0.4 * (evals / self.budget)\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.01\n        diversity_threshold = 0.1\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, 0.01, self.dim)\n                mutation_factor = self.adaptive_mutation_factor(evals)\n                mutant_vector = np.clip(a + mutation_factor * (b - c) + noise, self.lower_bound, self.upper_bound)\n                crossover_vector = np.where(np.random.rand(self.dim) < self.adaptive_crossover_rate(evals), mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.007 + 0.01 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.9 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.01\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V3_Improved", "description": "Incorporate self-adaptive differential mutation strategy and adaptive crossover rate tuning for enhanced convergence.", "configspace": "", "generation": 23, "fitness": 0.09290162898959478, "feedback": "The algorithm AdaptiveDE_CMA_V3_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.09.", "error": "", "parent_id": "55e4fac6-6d15-46d1-a0e6-ccf28f52f853", "metadata": {"aucs": [0.2526181839228683, 0.2067891452004713, 0.24479400442149313, 0.07352240214827421, 0.09433194763791575, 0.10060645017462555, 0.0927024038627291, 0.1877152588931177, 0.12022497510392527, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022956081839700215, 0.04020827790167314, 0.01993912571372325, 0.04811266277721549, 0.033889929163970045, 0.005122879223308119, 0.037854205931612483, 0.003604534646306834, 0.01461611901154225, 0.010557160664057097, 0.00589031262833728, 0.006939752680891975, 0.036744525143207696, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012422836178394014, 9.999999999998899e-05, 0.08405094951377667, 0.31990854996966356, 0.16244681734551591, 0.0716103287871912, 0.07304137662216559, 0.05877045167381034, 0.05942279237894377, 0.6636938862501767, 0.060323569174567604, 0.086643473337632, 0.008958882539902846, 0.00020264265820657545, 0.012104659738184642, 0.033300105452714, 0.04362272755140961, 0.08876282832040028, 0.038630587396125904, 0.023661759994372922, 0.14116939021783126, 0.11700113921402644, 0.10160302627145235, 0.060118267580286155, 0.04067009885118389, 0.0034046576521820082, 0.06622928416552354, 0.016627727520640345, 0.05911107542970262, 0.09019875912537623, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00029957351355491824, 0.004403371718217253, 0.22017868057522294, 0.072741305515022, 0.056284518385666726, 0.26579680652168836, 0.06054534519619992, 0.20664696499143043, 0.052240561209836556, 0.21494493116355162, 0.07731463574642117, 0.16803553644379576, 0.02690050026339108, 0.0973227569789622, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005679400006185831, 9.999999999998899e-05, 0.07764807915923899, 0.039414703669252815, 0.10445863263403843, 0.06446523357006717, 0.04053575287325151, 0.045444094380065136, 0.13497424746783726, 0.0627699980724068, 0.1036484645891973, 9.999999999998899e-05, 0.04810385243775672, 0.0005673139100931257, 0.008916840537961934, 0.028540657810191217, 0.009352061522009403, 9.999999999998899e-05, 0.0008023009832835992, 9.999999999998899e-05, 0.001392909871714032, 0.02175895209775003, 9.999999999998899e-05, 9.999999999998899e-05, 0.008620009893401726, 9.999999999998899e-05, 0.00023143109366552395, 9.999999999998899e-05, 0.00011347717312004679, 0.2398595470106034, 0.26522997573739193, 0.2345248392620639, 0.11665786270592948, 0.15851454792361985, 0.15866554261565613, 0.1917634193579888, 0.30379211368355563, 0.3078211918475051, 0.01693551431518936, 9.999999999998899e-05, 9.999999999998899e-05, 0.033322790877783115, 0.001905365858855812, 0.04824247779533053, 0.004926006643880321, 0.015871574182138692, 0.06744780472731982, 0.0965473639504979, 0.19360581641926122, 0.13979872681148953, 0.1318558888319623, 0.11469761358701869, 0.11044007263556088, 0.0948601403343291, 0.09701160912420437, 0.1191985233778936, 0.1230278997049239, 0.1735295197704625, 0.12621305808404182, 0.13657885628957922, 0.15374281867262984, 0.13579860036951963, 0.13425939250902252, 0.14936836132615483, 0.10928427530541485, 0.065810703238255, 0.12849777503070692, 0.06004937195142024, 0.09371212149142905, 0.10710001366354305, 0.06842047275928576, 0.07174220016608923, 0.06983963597091458, 0.0525241721470775, 0.2185017070431612, 0.23627963455729994, 0.22939175308948556, 0.23883834913478363, 0.16226936294826477, 0.2097983053146567, 0.19553544612363694, 0.22601724986100058, 0.2209126647748788, 0.16824958742800278, 0.12056701909929601, 0.14880247651201695, 0.1569529603305133, 0.16453234283538953, 0.16183904924160963, 0.14078290155244888, 0.1688725242782022, 0.07879574373991305, 0.12548852984370384, 0.15174867722379626, 0.08897098644293744, 0.5644525222914016, 0.16916026063587775, 0.11422516667502536, 0.09830396541888853, 0.09079852482136908, 0.11991097134659434, 0.25015379620047906, 0.08964745840630928, 0.06905110941691639, 0.10011454991949209, 0.1454672194192571, 0.07995072542631043, 0.11692641577258123, 0.06653786556362429, 0.17719673448239315, 0.17386286585726252, 0.24159731191229694, 0.1829832960245097, 0.21992667753984996, 0.22967806855943673, 0.2117970654426795, 0.21025470291316006, 0.22140655400688702, 0.2143619664690073, 0.07282125263658779, 0.08952193939622866, 0.058044931585778836, 0.045921198077709224, 0.05252455063211381, 0.04672843291172535, 0.039758513387911476, 0.03833637623030339, 0.04963773916884273]}, "mutation_prompt": null}
{"id": "fb977c99-ca5c-4253-9e64-fd6eb51cd44f", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 10)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.9\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.01\n        diversity_threshold = 0.1\n        noise_scale_factor = 0.5  # New parameter for dynamic noise scaling\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)  # Adjusted noise\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover improvement\n                crossover_vector = np.where(np.random.rand(self.dim) < (self.crossover_rate + 0.1 * np.exp(-evals / self.budget)), mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.1:  # Introduce small chance of direct mutation vector acceptance\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            self.mutation_factor = 0.6 + 0.3 * np.exp(-evals / self.budget)  # Fine-tuned mutation factor\n            learning_rate = 0.007 + 0.01 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.9 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.01\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V2", "description": "Enhanced mutation strategy with dynamic noise scaling and adaptive crossover improvement for accelerated convergence.", "configspace": "", "generation": 24, "fitness": 0.1704294367069537, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "55e4fac6-6d15-46d1-a0e6-ccf28f52f853", "metadata": {"aucs": [0.3313818193508289, 0.2869210071628535, 0.3550059782991981, 0.32783454664902534, 0.29146871461415336, 0.3041714268754614, 0.3051137607739438, 0.28332142328191445, 0.3068532109844999, 0.006761186260413665, 9.999999999998899e-05, 0.0020596250214417466, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10008883527857126, 0.11941984358295799, 0.07621020368208464, 0.08959527604715456, 0.10634502949701086, 0.09442652075379832, 0.08757168953756445, 0.1103304335487888, 0.09280463901230573, 0.06894977699919003, 0.07582134757734516, 0.060516775907609954, 0.07751325481644089, 0.05496012420385066, 0.07843730412253425, 0.07949150328000776, 0.07687152717677237, 0.06663522038394676, 0.9545038301492503, 0.9544868656105936, 0.9482372508922738, 0.9208572968360845, 0.8859145121381324, 0.8739484784137648, 0.9325362214034517, 0.8944974192510474, 0.8233448625206593, 0.14974386903642956, 0.20559951607611449, 0.18074704840001288, 0.1601120374681756, 0.17219027201583836, 0.17562199375384657, 0.17771326143489208, 0.173374017785772, 0.17615615718952415, 0.2265683110117882, 0.14564292966009285, 0.15412868885730224, 0.23752754476737759, 0.24173409743737406, 0.2269933390982808, 0.15070985689407645, 0.1763634081822414, 0.1788249481050288, 0.05865355988902976, 0.1061999733776835, 0.1026667352268893, 0.08846104428667878, 0.09239206485825058, 0.09398688318062287, 0.07572174702849332, 0.11224968189605788, 0.0979238522000987, 0.14186632127013832, 0.09260401618234959, 0.10259317122956857, 0.09917734275883683, 0.12124371188103089, 0.08940674937412407, 0.11954892727029343, 0.07456586469005466, 0.08627071292163346, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07703920885231819, 0.08156537529286612, 0.10891731448454833, 0.0769148110425174, 0.05610311224451803, 0.050646557962415684, 0.12419191925093087, 0.1252205353161222, 0.06924018473853633, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03359178769559967, 0.032527629379825895, 0.04556211737708815, 0.035728135808715145, 0.04486716833821047, 0.06414076539799007, 0.06650014078665922, 0.04761783220611393, 0.027396530481489045, 0.32754126041294396, 0.3536523634189651, 0.28528168903151285, 0.28339543586730864, 0.30316675578018903, 0.31718583067355677, 0.40125879122713615, 0.2976909881798592, 0.3038846214639467, 0.10391954843307627, 0.09563655897123824, 0.08873511289956892, 0.11637660175411602, 0.08384375069372074, 0.10542031443099986, 0.09084938086141936, 0.08732341186231096, 0.09203617220318683, 0.20460177305097038, 0.1523821887817961, 0.2079813495492654, 0.2049209507256332, 0.17163287515512182, 0.1625211940061927, 0.1575945889972139, 0.15322796806773498, 0.1466675338511253, 0.2262002469253639, 0.2251717699539607, 0.23906811902387437, 0.21065969979798027, 0.2425600857340534, 0.21759322849111606, 0.21041040634320418, 0.2167648054025677, 0.1953434483314751, 0.17059076875556878, 0.1753263519483308, 0.18761142630665895, 0.1692773719152667, 0.15016179603569713, 0.2008976698608813, 0.1652198129011544, 0.16088416009311846, 0.15550359396917413, 0.21075683142632962, 0.23746534710633926, 0.24385163271494104, 0.2125564149365594, 0.20941611421745632, 0.22271524677042576, 0.20013368923311825, 0.22767010234299678, 0.22031981126013278, 0.17242704745494397, 0.1740445955626979, 0.17665797987775134, 0.16644386675869804, 0.17313328783440773, 0.18213382956332302, 0.17160732884874363, 0.17130636959800372, 0.17060017236952785, 0.17393486284845439, 0.1805928731913109, 0.17682462805802224, 0.340836552917141, 0.18640745415311555, 0.15235538637166723, 0.16179030999128519, 0.19946092273908722, 0.1519519823945149, 0.14891244698901285, 0.19828952650017584, 0.08634438195976635, 0.16158817491104438, 0.1675139436304064, 0.18387251268336147, 0.10839115739820115, 0.1624469368849656, 0.1097587790655713, 0.20621807759020627, 0.17910743577550636, 0.18779516214633019, 0.17525784492057372, 0.1853444733763585, 0.1919655725184528, 0.21588176503390655, 0.18322833114513426, 0.20814834308311225, 0.09677279622665247, 0.10977710120178508, 0.09980162340590326, 0.11890081777894135, 0.09648593687869178, 0.10722206554373315, 0.1046265745176399, 0.08015581575752329, 0.1128187938491012]}, "mutation_prompt": null}
{"id": "a8975917-1efb-4e63-9e35-dc744ff2bcdf", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)  # Slightly larger initial population\n        self.mutation_factor = 0.75  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Slightly lower crossover rate\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015  # Increased learning rate\n        diversity_threshold = 0.12  # Slightly adjusted threshold\n        noise_scale_factor = 0.45  # Modified noise scale factor\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                crossover_vector = np.where(np.random.rand(self.dim) < (self.crossover_rate + 0.1 * np.exp(-evals / self.budget)), mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:  # Increased chance of direct mutation vector acceptance\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            self.mutation_factor = 0.65 + 0.25 * np.exp(-evals / self.budget)  # Fine-tuned mutation factor\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])  # Adjusted momentum weight\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015  # Adjusted adaptive sigma\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V3", "description": "Synergistic integration of adaptive differential mutations with refined stochastic sampling and strategic convergence acceleration.", "configspace": "", "generation": 25, "fitness": 0.17418530450857503, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "fb977c99-ca5c-4253-9e64-fd6eb51cd44f", "metadata": {"aucs": [0.3075095022191351, 0.29223342572163624, 0.3178287580056858, 0.29781604122172234, 0.30776173516973715, 0.311492682575073, 0.3178250803850109, 0.3209165649713177, 0.29210813916429734, 9.999999999998899e-05, 0.015836882536949815, 9.999999999998899e-05, 0.01904995497504658, 0.02902526535149519, 9.999999999998899e-05, 0.00010077320727253092, 0.05531098459868733, 9.999999999998899e-05, 0.13118245655228877, 0.10748976029379498, 0.10092685118381473, 0.11074512711643214, 0.10365459450349357, 0.10819706535551343, 0.09962519573491935, 0.0912955425497135, 0.13158369078322885, 0.07492916737706479, 0.07186836510696903, 0.06546899979333543, 0.08198082276718255, 0.06380833696324828, 0.08060578825478237, 0.07468028867400534, 0.07569056921838513, 0.06955867990105802, 0.8886246585307, 0.9128279228545303, 0.9396747100819459, 0.8728469664946678, 0.876893710073988, 0.8679382025485904, 0.8681755667365357, 0.896199529791617, 0.8939216970701495, 0.20937788057990125, 0.211396744833801, 0.17555008562472885, 0.20341137356493455, 0.21935444060062192, 0.19753855946844, 0.17815998259355825, 0.16729601723800025, 0.15601133424855185, 0.2050711815468288, 0.1342830365496851, 0.17484336459052374, 0.21043798209638032, 0.2047629066780261, 0.2040676820194357, 0.17568327062296607, 0.20362162867270472, 0.21411334318869446, 0.11319458762360624, 0.13682164231698157, 0.10954797414805506, 0.09144735856139485, 0.09313274739424071, 0.0861742559184362, 0.09601959747994193, 0.09635699190153024, 0.10513452108233956, 0.11791790582173778, 0.10406046205157948, 0.09437375348465626, 0.11081053607283575, 0.09602511013367643, 0.12341795041241621, 0.16079271046970767, 0.10632664138524073, 0.1140483595183901, 0.001112686843524724, 0.004909853566399391, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10902175255262192, 0.0731679903041158, 0.10860108301871829, 0.06188663435959885, 0.05346986585503821, 0.05770893645215214, 0.08867435587812411, 0.05684903011742226, 0.07202119737211465, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052385627858985706, 0.025728639205866988, 0.03727377076021221, 0.07368218814291416, 0.05352446397793642, 0.027400781679325914, 0.036853641405212745, 0.04090285550217454, 0.040808044065668736, 0.29952753787655617, 0.31684886344779706, 0.3115716737136174, 0.3527218701925877, 0.30638445528491187, 0.32403824095930434, 0.32895112856608655, 0.32219757379562086, 0.3410411724881758, 0.09172439394849241, 0.10354001816083325, 0.1331244004091413, 0.13161852847947808, 0.1140959894112028, 0.12656887946772766, 0.1079167484961665, 0.15491298228472183, 0.10937240297289375, 0.13940926306656332, 0.12712481670294506, 0.1966751994219278, 0.18261883260584832, 0.15690907410824095, 0.1576208888049485, 0.17482399441031027, 0.1509701456147985, 0.1584433431033262, 0.24901818367029738, 0.23518342105147894, 0.2354124916232091, 0.239531534922227, 0.22350677405016894, 0.23688719581563322, 0.22197304859951617, 0.1976561340130354, 0.2203745943806713, 0.15794914908853463, 0.1817691556845713, 0.15192713081256692, 0.20730768366259034, 0.14938272188375523, 0.1863427798191537, 0.17171088607868756, 0.17476453223453736, 0.14377089423468548, 0.2438631422719847, 0.3065628800189093, 0.19522974558537032, 0.20821356902935162, 0.2523239949029412, 0.23662061320350214, 0.23865514070771776, 0.23639831112408627, 0.21231083117383553, 0.1727845879125176, 0.1794844056153836, 0.16715281124893078, 0.17546131228711748, 0.17748519667895268, 0.16894508944712638, 0.16903108545880363, 0.17586132036059443, 0.17276080162331742, 0.17723025142511384, 0.17800091580493116, 0.15163367810588557, 0.204516941180799, 0.1876803454329543, 0.11889086357578604, 0.1652767741981941, 0.2008027248335318, 0.14951643965483252, 0.39048185134833724, 0.1954824318047872, 0.07720996498272248, 0.18335591965542952, 0.20113235124934847, 0.19842027475932278, 0.10354179396807173, 0.16252132867445002, 0.26788265755243834, 0.17274703385712908, 0.19273206010168475, 0.18891803337229673, 0.18257934018535948, 0.2032449822027239, 0.1932614983268356, 0.18522535330424394, 0.18610515861101085, 0.21921132100001628, 0.09431743474831744, 0.09355518274920471, 0.0958516673078248, 0.11390129987168707, 0.09280162214277354, 0.08674529539420273, 0.09081677715228742, 0.10226256025766944, 0.09802870116231643]}, "mutation_prompt": null}
{"id": "7a350141-e8b2-41d6-87e8-51b6fdc60c83", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        noise_scale_factor = 0.45\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover rate based on population variance\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            self.mutation_factor = 0.65 + 0.25 * np.exp(-evals / self.budget)\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V4", "description": "Introduced adaptive crossover rate scaling based on population variance to enhance exploration-exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.1778959851653967, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "a8975917-1efb-4e63-9e35-dc744ff2bcdf", "metadata": {"aucs": [0.31323226953086136, 0.3192313310646707, 0.31111824106752894, 0.33550450837803447, 0.2870839213380413, 0.30491191205798396, 0.3209294952581935, 0.34005539250699934, 0.33511157755296495, 9.999999999998899e-05, 0.0358333654739752, 0.03866056056641387, 0.02388263685229941, 0.01974073469541071, 0.003183142439566078, 9.999999999998899e-05, 0.053526713422094696, 0.0006158586166491453, 0.11990747135363633, 0.11418053613829471, 0.11967282505198107, 0.10898838873692074, 0.11889792225839124, 0.09065502566479722, 0.10495721609969155, 0.12507522221140077, 0.10780174525474673, 0.07863498565519045, 0.07927024200778887, 0.08076535545651264, 0.09687775691511746, 0.06818441364630068, 0.0745320160018822, 0.08084228013455608, 0.06994547368082127, 0.07227780681658857, 0.9125483991351647, 0.9041484030367362, 0.9295341690010691, 0.8722513883435814, 0.8738412329347933, 0.8999016475259828, 0.8669197224932216, 0.9154631470419762, 0.8918168925231258, 0.20564852213124707, 0.1851110990374698, 0.20547669871319663, 0.20041014411890845, 0.19286898468187397, 0.23281730473296414, 0.2236703143258173, 0.1772949361083085, 0.21985924198828488, 0.21325073002873307, 0.12785122226764356, 0.1824269940598966, 0.19154508003021997, 0.1923547749911222, 0.220020610256493, 0.17184187015933516, 0.2180891454031968, 0.16278470206865636, 0.10400475848386936, 0.10554947442432727, 0.10552897425252616, 0.09293361248903453, 0.070809772014929, 0.06843383736761044, 0.10231512791049713, 0.12762539582804944, 0.10283697641218281, 0.11694705559645169, 0.08651753207857327, 0.105483940513171, 0.11598784028403786, 0.11032163817655016, 0.10087525840607792, 0.10700145452637155, 0.10618811890718938, 0.11110235626571918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004394143950070539, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005647007227519096, 0.12418312920769825, 0.08233270029678263, 0.1751495118059363, 0.07242257986733724, 0.08852117070860988, 0.0500759323379345, 0.08539775582527798, 0.05886304830606637, 0.08433863401900321, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04873793647418512, 0.041959147753542814, 0.06484023909500791, 0.06945829771714229, 0.045531349141399335, 0.046560203498707264, 0.04596097119569409, 0.03986762319055248, 0.046710040906920214, 0.32053205160442977, 0.31592923148461083, 0.3798166205874751, 0.2791048286337088, 0.31761686184594173, 0.3704724768950953, 0.3277598225741938, 0.34502935936133783, 0.30831642267998927, 0.10618730732423332, 0.11606145928737421, 0.09760280385449427, 0.11041530828376622, 0.15209323804436303, 0.11233393258319813, 0.09884580102071883, 0.10410585406492934, 0.11813587321849828, 0.14444947343757997, 0.14260859765343825, 0.12699803712370905, 0.19120633477466265, 0.16509449553790367, 0.14041783935288532, 0.2055571451750018, 0.2043100219123143, 0.16314622582325677, 0.23922927622647283, 0.21813741368798822, 0.24906380951211693, 0.23959318255979545, 0.21735409078177104, 0.2514944051197029, 0.2027685503767105, 0.2081549131229451, 0.20597385084184572, 0.15614227049653617, 0.1930823372043533, 0.18001056348117872, 0.19016864567432545, 0.19292373673132457, 0.2031914572142849, 0.16271381620760217, 0.1561834850065812, 0.16378260313270931, 0.22294639907985403, 0.21658804037039514, 0.2210089613587053, 0.230313770870476, 0.2236813182580849, 0.2517453592263903, 0.1977563923240785, 0.23237346868092978, 0.21377429304309825, 0.17144237826917252, 0.17455973405424374, 0.16809443885499875, 0.17861253234911856, 0.18088860199898416, 0.16689691056084832, 0.17361009724834564, 0.17490196627776766, 0.17245143738982427, 0.1789292452031559, 0.18327210392510673, 0.1495007407199178, 0.22317375806028206, 0.19099398740652707, 0.11728328037028513, 0.15914892896422972, 0.20503052107186248, 0.15433426513636117, 0.40678873628573187, 0.19426711517219386, 0.2778151842637956, 0.18832322988557637, 0.19453766560402608, 0.19777552042958435, 0.11130121697273532, 0.35170387471902564, 0.24095942879555743, 0.18192283889337546, 0.19248698649653984, 0.19044302492754794, 0.2193687041871326, 0.18857148853395123, 0.18386243298856564, 0.1871500066356634, 0.1952075475079077, 0.18064743923617643, 0.09008860594936396, 0.12634305204439822, 0.08681553326892422, 0.10960434751033077, 0.08920600248380472, 0.08157357614232785, 0.09329696896991413, 0.08752982239464213, 0.08741814488367616]}, "mutation_prompt": null}
{"id": "a01010ba-161d-43b8-9df7-56f441dcd86b", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        noise_scale_factor = 0.45\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor = 0.75 * (1 - convergence_progress) + 0.35 * convergence_progress\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V4", "description": "Implemented dynamic mutation factor adaptation based on convergence progress to improve convergence speed.", "configspace": "", "generation": 27, "fitness": 0.17816165920094182, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "7a350141-e8b2-41d6-87e8-51b6fdc60c83", "metadata": {"aucs": [0.3125172699812444, 0.3217790389024381, 0.3608597625121972, 0.2915945109008249, 0.29382751190541956, 0.2955865916285869, 0.31890167696697713, 0.3424056136532396, 0.29925932431293356, 0.017855515369422537, 0.05017315109820286, 9.999999999998899e-05, 0.020853469274824232, 0.0671250053803204, 0.030073859753380394, 0.0004897188155317256, 0.017360255801060154, 0.0009589649789304433, 0.10420388565098071, 0.09281177872280455, 0.0902395287284975, 0.1018034564442234, 0.10407099233250228, 0.11502248787787905, 0.09847652752981217, 0.09649412213351483, 0.11078172578319812, 0.07254627053801466, 0.07668148278588816, 0.06198887175898926, 0.09588820455920466, 0.07989676742532958, 0.08604198837016686, 0.08217768113957646, 0.06840212420958691, 0.08002502860796445, 0.8908907472680696, 0.9168546325941083, 0.9287833285235005, 0.8704138237091247, 0.8403993110805856, 0.8698119298335925, 0.8667771790335168, 0.9148081900521933, 0.8874944635425268, 0.2150190611939078, 0.19735801466257186, 0.19380594514459004, 0.18958746682983663, 0.24513372167711334, 0.17697230026821487, 0.20775621451327342, 0.20677651722810697, 0.1955813485942801, 0.23474787337252834, 0.143515634091538, 0.19573680800054072, 0.20738340306551617, 0.2277542102248985, 0.2204660842815238, 0.1614624326205616, 0.20315840845717292, 0.16475029110598638, 0.11998926796494502, 0.09467981536265946, 0.09793618415759975, 0.13825749345045646, 0.11672997733133539, 0.0726896302278699, 0.11232208964215273, 0.10696550020616591, 0.10306129152490373, 0.14181044423352163, 0.0943239949427701, 0.09659110176750818, 0.10805053711294133, 0.11942863007516857, 0.092549731736146, 0.10213705655345362, 0.10554795941102546, 0.11629883797159601, 0.008017669793035531, 9.999999999998899e-05, 0.006116825066866061, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009234585843193921, 0.11791699309766479, 0.0948418361637432, 0.17277140547887904, 0.06252995407910256, 0.08410101283972926, 0.04648949780603562, 0.10793308396963097, 0.06450202373819192, 0.09675676302772429, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02761905034724388, 0.04724099679429328, 0.051420970019915746, 0.05153681588332548, 0.05203852679516807, 0.03316099425406405, 0.029769897614671526, 0.03657697082808331, 0.03461086732203489, 0.37207417713790814, 0.36336776630234213, 0.30494742710316136, 0.34767604938915053, 0.3206828328411675, 0.32298518327955084, 0.3530860225064134, 0.30991434522843764, 0.3036443264426323, 0.10118562033883283, 0.10656440918273002, 0.09822627774952031, 0.1079895532713141, 0.1019069500576456, 0.10099468460879357, 0.08846301630166686, 0.09715715206826203, 0.09187459060757086, 0.1616617791469085, 0.17281450909717855, 0.142535495432059, 0.18678010971138403, 0.15258935201055923, 0.12899495754571344, 0.1789172691717873, 0.13199027898297933, 0.16651470161046966, 0.23487775490810214, 0.2533800855021182, 0.18261791435702213, 0.27456966016922835, 0.23525253515299716, 0.2160716942704869, 0.2356219267320484, 0.2039979421052418, 0.1992308502631418, 0.17023017573654486, 0.19536136580750085, 0.17842702350509976, 0.18927971780031583, 0.17020681102120894, 0.19842289865055407, 0.17168505944098778, 0.154561341489308, 0.1673606755160696, 0.22617237111184663, 0.2224212244970697, 0.22859186668999287, 0.2259855731358199, 0.22166287423083708, 0.2056561082953774, 0.2464509783951162, 0.2427912224625286, 0.20976548688105512, 0.17000887475593285, 0.17077287964145416, 0.1706404419272476, 0.1681547894863421, 0.17969649741224203, 0.17481906506200118, 0.16375132981830343, 0.17395604637113338, 0.17811763309584094, 0.1791912031146332, 0.183050718289399, 0.15255305007495623, 0.4497744245407914, 0.18475598403113702, 0.4566452374016079, 0.1596037948351794, 0.1987372935776116, 0.1590586524979286, 0.3640085323687333, 0.19039267510144808, 0.3076301701740273, 0.19830410129047205, 0.20030062096051493, 0.1983709741908387, 0.1272301279173409, 0.10708208672003916, 0.2055708792278299, 0.1852139941563351, 0.1834844490895754, 0.1815573758104595, 0.1827569352250754, 0.20132909177465685, 0.18275519665741613, 0.17198957636956058, 0.18693711222628406, 0.18588962362333294, 0.09556360875000391, 0.10435439132553803, 0.09266646004619272, 0.12499483953901125, 0.08800639359698836, 0.09743253997675472, 0.09627304856507746, 0.0848003951493882, 0.08001350514517147]}, "mutation_prompt": null}
{"id": "4cfc1a49-c769-4790-ba6e-b51d9e02e619", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        noise_scale_factor = 0.45\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor = 0.75 * (1 - convergence_progress) + 0.35 * convergence_progress\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                diversity = np.linalg.norm(self.best_solution - self.population[i]) / self.dim\n                mutation_intensity = 1 + (evals / self.budget) * (1 - diversity)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V4", "description": "Improved exploitation-exploration balance by refining mutation intensity scaling based on diversity and convergence progress.", "configspace": "", "generation": 28, "fitness": 0.17738451741269792, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "a01010ba-161d-43b8-9df7-56f441dcd86b", "metadata": {"aucs": [0.31282190726015546, 0.31003195305032816, 0.3147926754560736, 0.2916484563545533, 0.29371139337781493, 0.29631127754827224, 0.3205969039125376, 0.333919179699122, 0.2992856002769053, 0.004423495259177845, 0.032619014609477914, 0.013725995929401713, 0.02660582381633425, 0.017430175018002037, 0.0006531647150899156, 0.0008729051234910301, 0.04633879301126509, 0.000991323699880975, 0.10432418908096897, 0.09244837906724201, 0.09364217519751805, 0.1506275935018342, 0.12376438188486338, 0.12022859884755654, 0.108667463936855, 0.09766834763055543, 0.09579836597250324, 0.09281820662637952, 0.07384760472262475, 0.0733226842994894, 0.09622728857174678, 0.09180468534845443, 0.0860920173409877, 0.09314377181741074, 0.07868757087827893, 0.07421421343698309, 0.8880221055853994, 0.915395127395446, 0.9288188313271005, 0.8704117669030326, 0.8404225777538625, 0.8691045474073938, 0.8667533646200749, 0.9362501081006507, 0.8874882338302236, 0.19968509586967675, 0.25044881048363754, 0.17645298512559526, 0.18107255202144168, 0.240837049704276, 0.17701299418291183, 0.21655862646292856, 0.2065475451983434, 0.20614694116692467, 0.21832840527706143, 0.14324267909005772, 0.1921662221832271, 0.24022329988520918, 0.22803203679831485, 0.20729835266872654, 0.17145217397203327, 0.18931968224986173, 0.15773905365138285, 0.11994881178450201, 0.09646509821931337, 0.10716893163690422, 0.11403172386394145, 0.11542700663137162, 0.07291575233281711, 0.11766626191151863, 0.10514845946095497, 0.10237295640938626, 0.14200451755616594, 0.09618533059197765, 0.0964590517000804, 0.10811814767902816, 0.11405079125231654, 0.09197095189999038, 0.10014059766020256, 0.10383964489569186, 0.11622976299881826, 9.999999999998899e-05, 9.999999999998899e-05, 0.013375999084412116, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009286245283642858, 0.1054721433742386, 0.07317019834337368, 0.17009024965334096, 0.06415878263108865, 0.07555745446722051, 0.05563472403305003, 0.10325715554447634, 0.05950784167253731, 0.05868065615713536, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022799102938896088, 0.044192603228637606, 0.03850268835202608, 0.05132510319494865, 0.05150623586325531, 0.03441650821310849, 0.03286723096672117, 0.03646204127880026, 0.04789499404046016, 0.3730546217253081, 0.36049186874239536, 0.3007503315356933, 0.3032552151163982, 0.32083419345213426, 0.31953038806151945, 0.3556625225511204, 0.3081224514090801, 0.3017697056990746, 0.08436233291733297, 0.09216360375942079, 0.09996143485007492, 0.11666445209474918, 0.11793701310234506, 0.10066887017639126, 0.08938657394486216, 0.10898870422014695, 0.13751475418660286, 0.150419983058664, 0.134366904111604, 0.13406869690879686, 0.21753401869957856, 0.14870122218381132, 0.1476658445358393, 0.13871122244768908, 0.15146281594398148, 0.15210984245709025, 0.2415035574624662, 0.23927423243798762, 0.23017236097307558, 0.24185153454532438, 0.23497960337909496, 0.22414921643686458, 0.21743640671637, 0.18514048777483538, 0.22565782556355796, 0.18550816438986106, 0.18370294091055794, 0.17720139672353363, 0.19225299545653896, 0.1826391861135206, 0.19243837501660432, 0.16268617711255628, 0.15449345992554353, 0.1455232252665135, 0.2388943535026552, 0.24731283441290064, 0.20123149862907996, 0.21368016847310423, 0.26080101459759164, 0.19539508023397234, 0.20412954161593733, 0.23644434065208775, 0.22486382922985637, 0.16697426554103967, 0.18237196009220158, 0.17052890403310372, 0.1699788473874072, 0.19366380713744413, 0.1781056922446823, 0.17775045468988993, 0.17780779461478813, 0.17260849225984698, 0.17895378184344668, 0.18291774649009096, 0.15169127527060955, 0.374556596722737, 0.18556366766060683, 0.41405032996708746, 0.15963468651297374, 0.20208788757024798, 0.1567190581427531, 0.36082796406023687, 0.20008711055005757, 0.30865266158730276, 0.19521374654998347, 0.20036072674550243, 0.19842418720406962, 0.126899081241432, 0.10707955262660418, 0.21478356458139336, 0.2019174507803515, 0.17682129447283712, 0.19878730273770406, 0.1881592049996912, 0.17454873453675723, 0.18275475073296676, 0.18694187270594387, 0.20375348765976264, 0.19115662825054525, 0.09015973050114112, 0.11222894862048327, 0.09947767545570774, 0.10760270833941432, 0.09880057495581918, 0.08927012731729267, 0.08046835118290219, 0.09252032564287416, 0.086628851478047]}, "mutation_prompt": null}
{"id": "1ba2e88f-b1d2-4242-9e24-fd29cb554860", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        noise_scale_factor = 0.45\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor = 0.75 * (1 - convergence_progress) + 0.35 * convergence_progress\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                dynamic_momentum_scaling = 0.85 + 0.1 * (diversity / diversity_threshold)\n                if diversity > diversity_threshold:\n                    self.momentum[i] = dynamic_momentum_scaling * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V4", "description": "Introduced dynamic momentum factor scaling based on solution diversity to enhance convergence speed.", "configspace": "", "generation": 29, "fitness": 0.10525021903287785, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.11.", "error": "", "parent_id": "a01010ba-161d-43b8-9df7-56f441dcd86b", "metadata": {"aucs": [0.20802274902503015, 0.18151149540675737, 0.22040523991355943, 0.174182891219977, 0.15584390707734563, 0.22032668495075336, 0.22049088755419255, 0.17198954976687086, 0.1853437782506997, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060492993894988634, 0.048971562311531436, 0.05915523491500885, 0.05804527706600948, 0.054701744078010206, 0.05653578002421433, 0.053616760790181406, 0.04721041626150857, 0.03386560274132311, 0.018185683643580197, 0.018351149791856147, 0.05050105258320148, 0.02807015152098158, 0.012389828234334876, 0.04667457884938342, 0.03624885024968538, 0.014198599691657598, 0.024247766625636213, 0.10475335730629098, 0.5360510891259334, 0.8904537964934057, 0.37120813863056634, 0.8846798074836552, 0.08093697425149293, 0.11256578071366907, 0.6099344922140355, 0.085664120594927, 0.060069484550062446, 0.06694393873419413, 0.05564456314481159, 0.11011655970959255, 0.07986064667867265, 0.08416004524619913, 0.112221635169378, 0.11305576163999143, 0.062304320482400866, 0.15381445830089246, 0.0962621461233164, 0.14806947347505406, 0.1705743414155737, 0.06572125792267802, 0.10979655930467469, 0.07934078834370484, 0.11832037442393628, 0.08378415442551379, 0.038149578078813695, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031188537932991256, 9.999999999998899e-05, 0.015456971657900387, 0.017086354412731763, 9.999999999998899e-05, 0.025071134526220118, 0.04907276215212242, 0.004480711942341453, 0.01696806335617307, 0.01632369877404327, 0.03362235056631324, 0.06297563166820985, 0.059248911608186794, 9.999999999998899e-05, 0.01595492745967564, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07743048055035173, 0.03131293475236174, 0.14138095179661936, 0.04773121125497637, 0.04407629308454453, 0.02506077106593607, 0.05789462880435914, 0.049544629375620985, 0.031172347438921166, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005458470244886882, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014905527991360135, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013608650421802482, 0.2355570410354092, 0.2292146089750633, 0.2155025959801926, 0.165213548510576, 0.16148379831197202, 0.18221091893716845, 0.21161368830057814, 0.21973254103161266, 0.22945079145726777, 0.03118269510379923, 0.04146667842688434, 0.058257561013055015, 0.05204732986049598, 0.03328523901047398, 0.07978642270620517, 0.05133204543779535, 0.04355199300899826, 0.06109521275893626, 0.1336800014570907, 0.13838692164138078, 0.14643492481820575, 0.12514522914026915, 0.1390508424596859, 0.1389441302518022, 0.1311182092471831, 0.15171617638072332, 0.13170856435264744, 0.14092770578526592, 0.15982843955593762, 0.1694508567146259, 0.17858029929694208, 0.14375315802487998, 0.19679535218015354, 0.15973517851733854, 0.17382170163836652, 0.14190128354981368, 0.11734283899164333, 0.13408270081779305, 0.1278624914800568, 0.13736572738853425, 0.1014003311257442, 0.11078275335262011, 0.11245267199128994, 0.16219722080683097, 0.0970331926353587, 0.18461394564651612, 0.13880360988469675, 0.17746444499605496, 0.16930463551968677, 0.15710120587174847, 0.14384320084666746, 0.19658874927417724, 0.16558216668553216, 0.1867783411524988, 0.1533910133736761, 0.15541180014112066, 0.1590792178835343, 0.17397020622149162, 0.16064516232388737, 0.14648181525677917, 0.16478921088706233, 0.14946777576947767, 0.16498780430252846, 0.16800520165563482, 0.1699524966760042, 0.12964932403814422, 0.1458508315328616, 0.17028097223512773, 0.12034742207149507, 0.1976715862654712, 0.11490778147737546, 0.11927998950631868, 0.13749367260291823, 0.15264127362813418, 0.15933793582059586, 0.11757403280800427, 0.1186723305570313, 0.16284978241956083, 0.15741012320862025, 0.10708208672003916, 0.22428372819950626, 0.1750388319866465, 0.17734084837268727, 0.21206497147804926, 0.18565996431181453, 0.1859622891803998, 0.1787591299522141, 0.20533320345773887, 0.18307544304918855, 0.18970999583548764, 0.07935471323863219, 0.059684701249132055, 0.06262493582324424, 0.05607770619171881, 0.042326524198044946, 0.06668800451952372, 0.055111576601068246, 0.04059901523106946, 0.07657306288067522]}, "mutation_prompt": null}
{"id": "463ddda0-8b2a-40e6-8299-35fb2034e1d9", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        noise_scale_factor = 0.45\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor = 0.75 * (1 - convergence_progress) + 0.40 * convergence_progress  # Adjusted factor\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.12 * variance_factor  # Adjusted rate\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V5", "description": "Enhanced dynamic adaptation of the mutation factor and crossover rate to improve convergence speed and stability.", "configspace": "", "generation": 30, "fitness": 0.17709416781041792, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "a01010ba-161d-43b8-9df7-56f441dcd86b", "metadata": {"aucs": [0.3059938421899623, 0.3217201084126443, 0.3204114769940577, 0.2868535097691999, 0.3236603204168318, 0.2977959016566597, 0.3293967029325868, 0.3693925280293091, 0.3028538148455713, 9.999999999998899e-05, 0.04169269130843223, 0.026543580473375017, 0.020241333864024602, 0.03154332520087266, 0.014253252056440235, 0.008516087994142052, 0.017767016201101105, 9.999999999998899e-05, 0.09734701258869449, 0.1523180837041178, 0.08738972008291257, 0.13281336179364645, 0.11676062666567233, 0.10454557737711401, 0.11106175066184132, 0.10782565381041931, 0.10425212470970369, 0.08408927007047129, 0.06974245686468972, 0.07399622689757945, 0.09783538635560451, 0.06550707892114027, 0.07095499294608798, 0.07877997942748993, 0.06203816091971914, 0.08003644015214628, 0.8919530032334595, 0.9017278550717176, 0.9291689553917175, 0.8714565285944544, 0.8427534742442283, 0.8696325012604749, 0.8653732395922984, 0.8949999951438626, 0.8870540681825039, 0.2138871499153424, 0.16995954999499385, 0.16124073915672998, 0.2007479666596923, 0.21341821486031787, 0.20596267043776673, 0.22267189271066223, 0.21769249446078343, 0.24335860978076984, 0.23474787337252834, 0.17544243765699663, 0.2009826544999962, 0.20849088803827043, 0.20973424614740632, 0.19969228148627094, 0.1592817019020376, 0.18405376789976258, 0.22110302713288488, 0.12221452383149245, 0.094727095033311, 0.0994859143525667, 0.10988302954129125, 0.11085110476105398, 0.08900909061582662, 0.10811376711977105, 0.10615857438824294, 0.10275641027000115, 0.13899704037630978, 0.0964731296201835, 0.09659540022221647, 0.10583433286622534, 0.10963916451465938, 0.0929124255461018, 0.1319929040297788, 0.10555309906005894, 0.1163020513150066, 0.0071827766420419215, 9.999999999998899e-05, 0.0337524599072051, 0.002662858070279661, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0053030117839490964, 0.1005440475098911, 0.0892890994748694, 0.13594175562704536, 0.06257821139049757, 0.05628072027439468, 0.059123052475759996, 0.11587920643040583, 0.0675578587020691, 0.08767677969436993, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02287472439317184, 0.04773079156903237, 0.04205079227574082, 0.048880138095607095, 0.03778118694885779, 0.028782689436504416, 0.035112772555363936, 0.03579763760204191, 0.046249855759479375, 0.326308726099364, 0.3159061692990879, 0.33900313027258866, 0.33113972769102107, 0.3190151917993317, 0.318364293205625, 0.3527406630211444, 0.35570534922535346, 0.2963129901751792, 0.0803464676188369, 0.08999745084010013, 0.08614261398237544, 0.10705950148370325, 0.11959181898517013, 0.10096631148811464, 0.1102772762103208, 0.10197284467736878, 0.10885319137526095, 0.16449812143861653, 0.16778534302863102, 0.14950297973606175, 0.2021465544007085, 0.179476623280308, 0.14313401549948834, 0.16530572291465995, 0.1476721267248451, 0.1708519443632769, 0.22038014059669864, 0.2283261525118898, 0.20781733121893453, 0.2857189794062449, 0.2340679575122222, 0.22885780897895613, 0.20064625917101608, 0.21654174395852444, 0.21932596678888594, 0.16570568924526374, 0.2187807121790315, 0.1587680695026582, 0.18906581900935548, 0.18305937427825258, 0.19586902605887213, 0.16637118999269862, 0.14889303833340128, 0.1638387727655065, 0.23819736192612162, 0.31663067979579373, 0.2129527154225591, 0.22089496460106173, 0.21856573941457524, 0.2298942806672355, 0.25324231703609734, 0.22864437352695655, 0.22509057974421398, 0.16919209187798356, 0.16482921836789577, 0.16854809075301458, 0.16946440269283414, 0.17968444777278858, 0.1748137424005547, 0.1720801134574993, 0.17230437235899476, 0.17348042593552415, 0.1792002980656835, 0.1804932525372136, 0.1507989207586461, 0.3541419410584221, 0.1939409660312783, 0.12176247432867127, 0.1601743433567019, 0.2052383863298325, 0.160828793638653, 0.34257446845019746, 0.19226276532957487, 0.2893728499786373, 0.19956535713395385, 0.19514864507864438, 0.19836929789044566, 0.12716185844844785, 0.16469584185434394, 0.21616639249345893, 0.18238830098260328, 0.19193474096695495, 0.1944649195487197, 0.18040699159085505, 0.18414383345698782, 0.1961828196293387, 0.1835836480147396, 0.17714441103817813, 0.19170240121365145, 0.09451246716873307, 0.10195253859708031, 0.09248570968149272, 0.0941414104088566, 0.09251707011825694, 0.09366000512715111, 0.09291238558007409, 0.08904224143593897, 0.09599773442632809]}, "mutation_prompt": null}
{"id": "80ba1cfe-2da1-4f79-8892-1167fafb5a08", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor = 0.75 * (1 - convergence_progress) + 0.35 * convergence_progress\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V5", "description": "Introduced adaptive noise scaling based on diversity to enhance exploration capabilities in later stages.", "configspace": "", "generation": 31, "fitness": 0.18255408584180113, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "a01010ba-161d-43b8-9df7-56f441dcd86b", "metadata": {"aucs": [0.3295151939616362, 0.35638267462050677, 0.3568709207517041, 0.3245491407774258, 0.30094262077819545, 0.31930790187715596, 0.32335674636994827, 0.3410284303083855, 0.32728210052276696, 0.04788214061570528, 0.017624916066351526, 0.01417367147643711, 0.010923963373927426, 0.04867228915738919, 0.0026675151505205497, 0.027595172658951173, 0.016908206251634472, 0.0005078673097012043, 0.09495322473234902, 0.1094167104061673, 0.11539407200366714, 0.11203430746382148, 0.12877482467210943, 0.09358554379829254, 0.08701730655425743, 0.09713659148663611, 0.10477278353648234, 0.10185198732039791, 0.08739763866261108, 0.06430325845136964, 0.10422900701790183, 0.06568463297394134, 0.07270484153565071, 0.09239065572814342, 0.09560340763028452, 0.0783260005747135, 0.8887577809674158, 0.9175645812081511, 0.9146901422423029, 0.8727534130877584, 0.8394926527825123, 0.9010658665271513, 0.8670202580293253, 0.9164300515571615, 0.8902407682646682, 0.20215591248050324, 0.18667784932892362, 0.19789951065159883, 0.1980251980890788, 0.22253193919739078, 0.2014014846864619, 0.20268529703602733, 0.21936172705688073, 0.20772042827602866, 0.23365043373564376, 0.1400916788399338, 0.19981620563759084, 0.20824733645317506, 0.1960370910211512, 0.19884102094404388, 0.15841720347298982, 0.22132146725004065, 0.17214022434242338, 0.11702924451363383, 0.10536908671890766, 0.10974689235239732, 0.10999033695808502, 0.14124487978499123, 0.12149397753755653, 0.12365942754174741, 0.10711413035939044, 0.121198386249463, 0.15616156362108502, 0.11292947013100296, 0.1198329019210409, 0.12739251079117497, 0.13175157042500973, 0.11158028962229549, 0.12641935177080288, 0.12418047380756903, 0.11522448339628155, 0.00689853168097565, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010822789247612041, 0.16562840933217626, 0.07881111964048881, 0.14984062990238067, 0.060304921875326545, 0.07382620194166156, 0.045581232652278425, 0.12695166095006405, 0.06879174053822845, 0.06552682083972561, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04754905538688747, 0.057165553552991355, 0.05262349101609265, 0.05147187071002679, 0.06912439785495483, 0.0715883093329518, 0.04197079465376341, 0.06529115718842515, 0.051899119638761815, 0.33100839705481533, 0.3209730990198699, 0.3653261550450494, 0.3345532398199308, 0.3127543103457008, 0.313523777587412, 0.38193606213124, 0.37587907050913094, 0.3190405968044724, 0.08821313600327085, 0.11784046558018324, 0.08829862813219447, 0.09655548445152728, 0.10338431483264554, 0.1221174535595908, 0.11839606209053688, 0.11387427340202483, 0.10926721202551837, 0.1473835484087671, 0.2019293724218829, 0.17837499098191145, 0.1546051954677934, 0.15051251855101944, 0.18390266345413087, 0.16440035977026835, 0.1890078945029866, 0.15393953292352103, 0.23971216876062573, 0.26317219295112526, 0.2399650765932856, 0.24431993208115288, 0.24289430760211883, 0.25140698541727957, 0.2053937323242635, 0.19472949458308275, 0.2113564199212975, 0.1771545366060121, 0.21366848326063448, 0.17338520972968985, 0.17256170138431537, 0.18048150853627998, 0.18735661270239345, 0.19109612598516512, 0.16851276040446805, 0.19821274666298372, 0.27124840730822464, 0.23706678251114832, 0.2090591795612391, 0.22655821305699486, 0.29061603516417833, 0.24185582732514488, 0.2417169586060851, 0.21378000527478014, 0.21703453757826707, 0.17971552634148447, 0.1711946139134367, 0.1692367345382616, 0.18664899339671182, 0.17476386052210402, 0.16850182683584103, 0.17179313929924067, 0.1734819258650706, 0.16908304971817234, 0.18413684046604095, 0.18264872508545504, 0.15118397974273612, 0.4378990319112155, 0.1877792519035204, 0.14688285250936461, 0.1633564578870108, 0.1958343556044594, 0.16518420308039927, 0.47135506961214424, 0.1982202175038703, 0.3350847370872789, 0.1924225203267591, 0.140184653534547, 0.19665724627977454, 0.10379126518864745, 0.16212085994172631, 0.2737848034933893, 0.18450789651942145, 0.19418629800809795, 0.1895672856019256, 0.18127286600656078, 0.1780050390953204, 0.18471977304384612, 0.1756523197185781, 0.17763460179839385, 0.18436525041259388, 0.10065209360835758, 0.12341020585151141, 0.10145676285885297, 0.13251776555385353, 0.08025776525183559, 0.09737964558392709, 0.0905910781588416, 0.0876776771510196, 0.09091565438898797]}, "mutation_prompt": null}
{"id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99  # Newly introduced decay rate\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate  # Apply decay to mutation factor\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6", "description": "Introduced a decay mechanism to the mutation factor for improved convergence speed.", "configspace": "", "generation": 32, "fitness": 0.18421141615785305, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "80ba1cfe-2da1-4f79-8892-1167fafb5a08", "metadata": {"aucs": [0.32232324630972575, 0.3810779826780777, 0.3498232598428498, 0.31574893128069714, 0.3442944871107403, 0.31690187962128147, 0.3538855045108782, 0.3759692958185705, 0.35761997404545554, 0.010726864823417448, 0.02095254157981996, 0.014538495648796945, 0.015289118776120048, 0.04160775566593533, 0.00858440780784564, 0.009486346709501103, 0.011797453693059068, 0.00126735623576546, 0.0991895973437188, 0.14060501765478162, 0.09483743574206238, 0.09876356505840522, 0.13526136412903655, 0.1085992506989314, 0.08576660019696358, 0.09843590880922415, 0.12284616265448733, 0.08313576245278187, 0.07608778466914023, 0.07979631557531885, 0.09079786156461944, 0.08518244504329142, 0.06629495713485467, 0.08526279915256185, 0.08155732680178485, 0.08008403499612993, 0.9137920550668734, 0.9022792897809753, 0.9292053852257206, 0.8759504193617215, 0.8744564816590736, 0.8699237139956192, 0.8662173682078337, 0.8742615654962407, 0.8894488571618278, 0.22475791625371, 0.2100131823182162, 0.23443255822830988, 0.20399769413808333, 0.2088587940393306, 0.18983545767079235, 0.23265676453880169, 0.23304684508711837, 0.21860123892852867, 0.2310503554798231, 0.1363512552072742, 0.23411033051636654, 0.20433915743900555, 0.18837007293982433, 0.2018401736274552, 0.14628396072873018, 0.1968069286078813, 0.21219381303762752, 0.12248252988306574, 0.11343791526041036, 0.1129098647995248, 0.12587414041954503, 0.13086643459833958, 0.12220420625149964, 0.12901387497509242, 0.10887063833305255, 0.12969821212755783, 0.15365077915014536, 0.15604249485335053, 0.0997927424632471, 0.12482132043797389, 0.13679645759901282, 0.12187706565534029, 0.1199633542133961, 0.1031278144243506, 0.1164548724442731, 9.999999999998899e-05, 9.999999999998899e-05, 0.023134899242969964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011396620507676203, 0.16401614104056372, 0.082034574905823, 0.18420252473851784, 0.06554754690318987, 0.07851051562440847, 0.04688611510774443, 0.12060432346749239, 0.07503541186241369, 0.07176033174691787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07752132737649808, 0.03960780447200485, 0.052308295444360886, 0.05979119252199594, 0.06741771027680554, 0.06090284225148246, 0.03629900658082075, 0.04025277891696244, 0.043345806696528544, 0.30658285238895355, 0.32788683968871646, 0.34938783922818517, 0.32666467190688386, 0.3307878868774815, 0.3203150434245978, 0.35647642166112703, 0.3697600754706263, 0.32693850512457057, 0.1041054081739119, 0.08939374163850666, 0.10340773472608578, 0.11839720126644093, 0.12304142239836346, 0.12017137698871028, 0.11051057396259001, 0.09277103674402043, 0.10872047974627252, 0.1327485248567205, 0.24186392419348635, 0.17035208615196862, 0.18619794167785608, 0.1500192717909138, 0.16272880095234266, 0.15832823741426472, 0.2005858479046737, 0.15023278957541353, 0.2494986351315066, 0.23149629588641296, 0.2349073025192926, 0.2428898748831836, 0.21690650151772195, 0.2531519212430181, 0.23746637542964055, 0.20811462405051195, 0.21236206849110273, 0.17959948614479926, 0.18496528883411956, 0.19420242684481026, 0.23502115272140023, 0.21257712528106854, 0.20819692873592643, 0.192582915921077, 0.1678328391106445, 0.16627592034292082, 0.24111573322675428, 0.2238591546049259, 0.23575057605664784, 0.23251558074486367, 0.23502885807844542, 0.24072141252594248, 0.24836414267507811, 0.22834081383096194, 0.21228683243089386, 0.17307255107832975, 0.17242146842772965, 0.16621706593155228, 0.1927153958763974, 0.1785729810186253, 0.17303052880073666, 0.1776729309272509, 0.1660364586097809, 0.17131906842922284, 0.18343730028718253, 0.1823896441867381, 0.15069990654176724, 0.43347520282119556, 0.18836540082053266, 0.14712924037672326, 0.14369634388518882, 0.2026783614782912, 0.16465006504193258, 0.48004975296521657, 0.19736496378090707, 0.34070665737557904, 0.1953951240564329, 0.14241420079766975, 0.19516989191464307, 0.1037801564214671, 0.1631147368691247, 0.2639727565787189, 0.18812578089787335, 0.18642902039312303, 0.20473438155459556, 0.18766914799669698, 0.18204086015137044, 0.18131113899533624, 0.17640234567454405, 0.19265297306697937, 0.19425510435408977, 0.09186963753853883, 0.10747052775211874, 0.08766950932911421, 0.12904101500680465, 0.08665857307212921, 0.09970686608353085, 0.09029351696160448, 0.09551778378916864, 0.09632101482860034]}, "mutation_prompt": null}
{"id": "bf8c7228-bba7-4a08-aba1-1bec3502cd9e", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99  # Newly introduced decay rate\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate  # Apply decay to mutation factor\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1.1 - 0.1 * convergence_progress)  # Slightly adjusted scaling\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6", "description": "Enhanced mutation intensity scaling based on convergence progress to improve speed without sacrificing precision.", "configspace": "", "generation": 33, "fitness": 0.18262224446402103, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32233233877105927, 0.38115530037280354, 0.34975451518803113, 0.3150794171240471, 0.34392907682261, 0.3169648743827058, 0.3287904048839947, 0.3759563250276755, 0.3588833520169261, 0.010522950009782317, 0.022806535304134234, 0.013957139210219238, 0.01397836228719973, 0.03275918157613611, 0.003946807018458842, 0.009413266844347512, 0.010122688384316625, 9.999999999998899e-05, 0.08097072141792305, 0.10765581106105271, 0.09312411089694816, 0.11301789691656561, 0.1319426524334012, 0.1086226961645147, 0.07647928033168516, 0.09715356730164948, 0.0985041878299091, 0.08300110730592092, 0.07243554496565918, 0.07796759097252381, 0.08737240112746425, 0.07772885201635604, 0.08270399105071224, 0.09225419109867394, 0.08290510697274445, 0.07238308019935835, 0.9137890849938217, 0.9022919644137919, 0.9292093272033687, 0.875962206624378, 0.8744516128872898, 0.8699298041640382, 0.8663597181558456, 0.8742908244999087, 0.8894551067896794, 0.21590562414139836, 0.18606205400501097, 0.22946108878774396, 0.2039278145395068, 0.22499949081242854, 0.1884402714987029, 0.22810826142116558, 0.23881995801105682, 0.2183756341597083, 0.2310503554798231, 0.1363512552072742, 0.20744248405769572, 0.21087626747849553, 0.19346930934967077, 0.2017886082539745, 0.14505023243189352, 0.1800902074716425, 0.18335834141002694, 0.12251961746326945, 0.11345332486949666, 0.11290447669164805, 0.12055804257121872, 0.1327950480243657, 0.12186424014686414, 0.12901266694563296, 0.10885959686995228, 0.12971792085372147, 0.15252428935555196, 0.15604388988068418, 0.09977501235342956, 0.12484183107982405, 0.13851003482401159, 0.12189735118035128, 0.12000364127927021, 0.10311269916368493, 0.11645101313097161, 9.999999999998899e-05, 9.999999999998899e-05, 0.022543680754824935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012069361503251663, 0.16380392675286093, 0.085545109490207, 0.18416873515853172, 0.06384355685409338, 0.0778516906987825, 0.046820367780304184, 0.11808229920612234, 0.06992910036665001, 0.07462270864298737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.047518385967542986, 0.03961120710427224, 0.052338011685581276, 0.05991864497466992, 0.06749851578539912, 0.060855479598109774, 0.03632733859376569, 0.0407116567277469, 0.04338097024435206, 0.3065706134543772, 0.3280359534564262, 0.3494813739567977, 0.3155833533176662, 0.33085584151606684, 0.3222286046397318, 0.3608486161987261, 0.3698205776867728, 0.3333992841267205, 0.09207775100817384, 0.13045376059307912, 0.0799132481448207, 0.11820576407518346, 0.12109208327368615, 0.11909194126428735, 0.13933972470961142, 0.11983771344461924, 0.10955973313788159, 0.13643364425728144, 0.20683271949140203, 0.14495950418735337, 0.18126988789077292, 0.17986079018538403, 0.1649332641634208, 0.1866984875723885, 0.18255147117946613, 0.19312161861819355, 0.25695671288147526, 0.23055548337654175, 0.21502894897523217, 0.26045228056889924, 0.2150494371841437, 0.2541343390082552, 0.2359287911315484, 0.21068243928253882, 0.19278432089128072, 0.17311355798001782, 0.19792406588545675, 0.1931565735504267, 0.1878690049045577, 0.1905135824940294, 0.1964305635638861, 0.1774158234993498, 0.15993265943254298, 0.1595874050432452, 0.2181203302687562, 0.23338003169665156, 0.219079017253914, 0.21337998190377616, 0.2388698648063705, 0.22507548566049995, 0.24420070161629093, 0.2281099564090986, 0.25370437566893966, 0.1730850813594923, 0.17582011753401006, 0.16811267680865039, 0.1932366825532853, 0.17606434512518787, 0.1686476189257322, 0.17975310034507475, 0.17035516118265226, 0.17444848057586626, 0.1834444997596817, 0.1823928861705011, 0.1506968652555557, 0.4334792371135384, 0.1883675775751863, 0.14712700708773552, 0.14173097816121005, 0.20267632760492105, 0.16464807768494993, 0.47994916781830343, 0.19732644605728988, 0.3406461193951773, 0.19399303448631222, 0.14241510475902797, 0.19517849990105574, 0.10375539750984697, 0.163112217503257, 0.2639799136572164, 0.185377949095751, 0.18290511773166296, 0.1836032921629489, 0.19006134439655298, 0.18616272245860432, 0.17842172934910427, 0.18469164817337247, 0.1879338898609051, 0.18270403456234008, 0.09183105529088098, 0.11501403485239703, 0.0936365198113095, 0.1234417006131272, 0.08933520274420681, 0.08474430175676462, 0.08727641293380528, 0.0931284488690528, 0.08732203905616576]}, "mutation_prompt": null}
{"id": "27b950d2-5876-4e73-8dd0-8027d2d6f9f9", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n                # Adaptive adjustment of diversity threshold\n                if np.var(self.population) < 0.05:\n                    diversity_threshold *= 1.02  \n                else:\n                    diversity_threshold *= 0.98\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved", "description": "Introduced an adaptive diversity mechanism to balance exploration and exploitation for improved convergence.", "configspace": "", "generation": 34, "fitness": 0.1781058741966193, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3102495357110576, 0.3435164524822286, 0.34429602761867306, 0.30795827680162124, 0.33267949510388306, 0.3248259108880729, 0.3273057885487052, 0.3177265338923476, 0.3249949581591286, 0.026140771358085346, 0.024634825746960298, 0.008332594255877068, 0.0049174063304983084, 0.05986498284071817, 9.999999999998899e-05, 9.999999999998899e-05, 0.003858769869030776, 9.999999999998899e-05, 0.09962333230103482, 0.12720945699815367, 0.07029811262997832, 0.10228658480845698, 0.1173467749292384, 0.10444334357076845, 0.08397326480635836, 0.09359959159543485, 0.08700512057632681, 0.08075572651997298, 0.0759269182504897, 0.06777628146071568, 0.09059083528430978, 0.07878165634506917, 0.07677073659523137, 0.08159575498917637, 0.07078103232032884, 0.08705559332260959, 0.9138623634032671, 0.9020243201969399, 0.9138463134379512, 0.8761196615335202, 0.8747111119016476, 0.8700341388878992, 0.8660949406421119, 0.8734667590041368, 0.8894828685767926, 0.1948838430283094, 0.2218859347011387, 0.18778046859207498, 0.18562526215681796, 0.20187020866031358, 0.17226956813160088, 0.18688650442467325, 0.19610497375112268, 0.17082730946390368, 0.21895997371669995, 0.13568735403944188, 0.2353815487520301, 0.2036981533128449, 0.193885473732462, 0.20336051219802287, 0.13006217727154212, 0.20391503411729694, 0.19040531511612135, 0.10967202816528276, 0.09958481015129206, 0.11063410101227533, 0.09091639449491795, 0.1353356987605252, 0.08235707184330077, 0.12213512274976313, 0.11206814126328368, 0.11271140694253934, 0.14437622522209914, 0.1033015445939609, 0.08347660720457184, 0.11994857367457212, 0.13436023020529175, 0.12116189831611723, 0.13248070390580546, 0.1096270613523549, 0.11098583807314011, 0.005951488457330734, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011904571366239902, 0.003888168170820827, 0.1434878544486744, 0.0718059568564835, 0.17937174020643376, 0.0633749239809227, 0.08159165459255913, 0.04782636625041503, 0.12455054916070951, 0.07475454461535136, 0.08032513974110078, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051467185935188176, 0.03894217870268457, 0.05413709641403597, 0.0571535023977191, 0.054409781364464616, 0.054868544733190694, 0.03813368109571913, 0.03803838386260616, 0.05149372621752246, 0.3301376043663228, 0.33699151640939073, 0.31098554485568597, 0.3315593502768618, 0.31633749936829325, 0.3100992933355623, 0.33480449952534796, 0.33646669839161736, 0.3263426326484038, 0.10673117443073699, 0.11833502171874666, 0.09483965409391026, 0.11491617130061693, 0.11914449635470115, 0.11283622405319016, 0.09836894114547357, 0.10303747238015581, 0.10867039813235457, 0.1552475994664102, 0.21500154721662956, 0.12259442359821204, 0.16637154084970385, 0.17232466890952858, 0.1558353325414098, 0.15528961246848882, 0.18371014968966337, 0.14333758313891065, 0.235392547265743, 0.23104783954753327, 0.22579536273283873, 0.2276031258588529, 0.22418258924738432, 0.2392594812279959, 0.2181946429448136, 0.19942629627183428, 0.2070045556493988, 0.15732070598752523, 0.17341671216182042, 0.16978619594621536, 0.19254087612005089, 0.17103870893579065, 0.17644400256685844, 0.16031935843348344, 0.16443346123672908, 0.15162318273832298, 0.26048803244544727, 0.24078981497710117, 0.22567434866665814, 0.21546119420682885, 0.23502885807844542, 0.23284902964397125, 0.21560539332781303, 0.22834081383096194, 0.23531190387968648, 0.1805378949634523, 0.17887457505394655, 0.171185205127374, 0.19531803307833884, 0.17869362273761402, 0.18849768832734093, 0.17148368915934298, 0.16520980152612408, 0.17192547136622038, 0.1813947905921619, 0.18374956567031098, 0.14950203904920523, 0.4269841434938233, 0.18991830564760237, 0.16278616938149715, 0.1395445147172617, 0.20232166970542187, 0.1648757089406827, 0.49152185235672285, 0.20163331108474125, 0.33530170430951045, 0.18826091751972118, 0.14190006744286876, 0.19247131490454028, 0.10382126373980172, 0.16290659732479906, 0.2310531529441071, 0.18812578089787335, 0.18642902039312303, 0.20473438155459556, 0.18766914799669698, 0.18204086015137044, 0.18947156740377114, 0.17640234567454405, 0.19265297306697937, 0.19425510435408977, 0.09186963753853883, 0.10309125241949713, 0.08766950932911421, 0.12904101500680465, 0.09426819024143929, 0.09970686608353085, 0.08830434530370035, 0.09778202330204333, 0.09632101482860034]}, "mutation_prompt": null}
{"id": "a5662584-a30c-4452-ac72-764142aa8fa8", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor * (1 - convergence_progress)\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced a dynamic adaptation mechanism for the crossover rate based on convergence progress to enhance exploration-exploitation balance.", "configspace": "", "generation": 35, "fitness": 0.18404502022818503, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32232324630972575, 0.3810779826780777, 0.3498232598428498, 0.31574889157551933, 0.34489386951379597, 0.3206609536174343, 0.3538855045108782, 0.35721107577473454, 0.35761997404545554, 0.010726864823417448, 0.02095254157981996, 0.014709682096272214, 0.016431129664389865, 0.04160775566593533, 0.00858440780784564, 0.025290811867727858, 0.012967406824741734, 0.0033669239212901214, 0.09311718805001623, 0.1406162458239263, 0.09310754264628796, 0.10616561928458756, 0.12854959517386633, 0.10565810231160144, 0.0801621749878696, 0.09344289638537451, 0.10376379514327361, 0.08313857172705341, 0.07680350550518, 0.07979631557531885, 0.09079786156461944, 0.06855610508121246, 0.06504094180904829, 0.09145122381463988, 0.06892511133163992, 0.08027935876637271, 0.9137920550668734, 0.902243876487958, 0.9137906326528082, 0.8738370581953939, 0.8752857768951535, 0.8699237139956192, 0.8663087549729649, 0.8729935804591855, 0.8894329438623912, 0.2161595389175479, 0.21787365032839512, 0.20734609117823188, 0.2101610506941991, 0.22006319887986048, 0.17917434365551, 0.21629726256668425, 0.1943012377194957, 0.1900550290000218, 0.2310503554798231, 0.1363512552072742, 0.23462370804743327, 0.2035016091854096, 0.2550386868351827, 0.20352265929364588, 0.14242057927563967, 0.18144609319574323, 0.18871592745592858, 0.12248252988306574, 0.11343791526041036, 0.1129098647995248, 0.12587414041954503, 0.13086643459833958, 0.12220420625149964, 0.14117636123161958, 0.10887063833305255, 0.12969821212755783, 0.15365077915014536, 0.15604249485335053, 0.0997927424632471, 0.12482132043797389, 0.13679645759901282, 0.12187706565534029, 0.1199633542133961, 0.1031278144243506, 0.1164548724442731, 9.999999999998899e-05, 0.0038234726328133517, 0.023134899242969964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011396620507676203, 0.16089075496034544, 0.07643977460859841, 0.18420252473851784, 0.06554754690318987, 0.07851051562440847, 0.04688611510774443, 0.12060432346749239, 0.07503541186241369, 0.07176033174691787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04755808695174468, 0.03872058794445288, 0.05253712633196406, 0.05621400964634138, 0.07249708790665632, 0.06087747974446733, 0.04157628839067551, 0.04009546561953925, 0.0519073026123098, 0.30658285238895355, 0.33797874612332746, 0.34938783922818517, 0.3243105978995561, 0.3307878868774815, 0.3091386676522472, 0.35647642166112703, 0.3697600754706263, 0.32693850512457057, 0.10472464954798455, 0.11775493310499041, 0.10590448907187289, 0.1164086330645383, 0.12304142239836346, 0.12017137698871028, 0.11082750577759326, 0.10785386050756973, 0.10157929906013174, 0.1307772352026806, 0.24186392419348635, 0.1754401569992493, 0.1893330200996184, 0.1515902419385209, 0.15641622875965255, 0.2136113942437703, 0.2005858479046737, 0.15665815664575822, 0.24703069847582115, 0.23164216548873273, 0.2349073025192926, 0.23981529685943936, 0.21690650151772195, 0.25035778945214837, 0.23319674380094257, 0.20515234246586755, 0.18181724836014201, 0.17959948614479926, 0.18496528883411956, 0.19420242684481026, 0.23502115272140023, 0.21257712528106854, 0.20819692873592643, 0.192582915921077, 0.15989711577150179, 0.1706030687520126, 0.2338256631865523, 0.22420775538498305, 0.23575057605664784, 0.22946090536791097, 0.23015284508003342, 0.2532769248426283, 0.23960961029354844, 0.24088287591070745, 0.23753206323601017, 0.17307255107832975, 0.1737237613720114, 0.17056572098619016, 0.19524866267887286, 0.18121384785610894, 0.17522015230305243, 0.17265801052935092, 0.16473224272666354, 0.17552902977819962, 0.18343730028718253, 0.1823896441867381, 0.1509102486549334, 0.43347520282119556, 0.18840457349688589, 0.14712924037672326, 0.14369634388518882, 0.20302872217552226, 0.1645138869092836, 0.48004975296521657, 0.19932841602609253, 0.34070665737557904, 0.19658003813517388, 0.14209794918908936, 0.19516989191464307, 0.10389387109007242, 0.1631147368691247, 0.2639727565787189, 0.21680237083330378, 0.18290472026673643, 0.20898977138408859, 0.1931537585336257, 0.18234544918736295, 0.17636683378512008, 0.18374988630807265, 0.19265297306697937, 0.1866648675966861, 0.08958833691721324, 0.10918648575210099, 0.08635718243125268, 0.1314537292125939, 0.10402130650387642, 0.09443117917248078, 0.09174895186101495, 0.0956463454384493, 0.08999418624666178]}, "mutation_prompt": null}
{"id": "dc1cc57e-d769-4ab8-9b9e-9691afa9fe62", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim + 0.05 * (1 - convergence_progress)**2  # Adjusted noise scale\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6", "description": "Implementing a dynamic noise scale factor adjustment based on convergence rate to potentially enhance exploration.", "configspace": "", "generation": 36, "fitness": 0.1804047176276081, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.31053568967448086, 0.33273301517394527, 0.3095099281337277, 0.3053340487850744, 0.31001103952055487, 0.3141903994654359, 0.3631301436097477, 0.33223992202542785, 0.33030136418152156, 0.004748662710863383, 0.011712952988837566, 0.0440980310178084, 0.05300068986524342, 0.02943609253709656, 0.0032556058864462445, 0.03575744591950747, 0.040517805378296745, 9.999999999998899e-05, 0.12490593753706891, 0.11553147314193246, 0.09652302240917887, 0.11140304967332426, 0.120334610178637, 0.08680952752443705, 0.09408835428754703, 0.10125130346889677, 0.0928169505880766, 0.08640399796909737, 0.08050300932450705, 0.08523597331992405, 0.0783449241228622, 0.06948133264472667, 0.0713526717122186, 0.08679107272635045, 0.0698729763503374, 0.0844773185363592, 0.9126806652094744, 0.9345835374457236, 0.9317654511290976, 0.8460287104762659, 0.8842032573789042, 0.9004140782856829, 0.8937876154652401, 0.9364189908558292, 0.8914199753089943, 0.19577360239306152, 0.21511533353775725, 0.1639555280525794, 0.23280545318727142, 0.2285021040485703, 0.1858508022788471, 0.1825454138367858, 0.22807614838990942, 0.20812137984095858, 0.22115758775617367, 0.12916673696558667, 0.19167156560115184, 0.21356864979658552, 0.2114674716953523, 0.20372349512560728, 0.1489890768627392, 0.19445693560864352, 0.16221414504276122, 0.1020181362240562, 0.10273782871472559, 0.10914659410044003, 0.0869629728239244, 0.10377203449010797, 0.10212701012027214, 0.1227681671232278, 0.10244528046574053, 0.12671260834941822, 0.15375600270042544, 0.10563767018240999, 0.10462195531788565, 0.1255170867250719, 0.10848816580399778, 0.11797782739989782, 0.13229177044776919, 0.11652094745253017, 0.10022066387522077, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027928143082863288, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010492958888469461, 0.14201605658583927, 0.0801933520747885, 0.1498174623868268, 0.06644072239752208, 0.08680528159987677, 0.052129705969234275, 0.1212701719579089, 0.0757290508664622, 0.07180302501022362, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011795434517308578, 9.999999999998899e-05, 0.07065125531986782, 0.03961885993807013, 0.04284432606826627, 0.05219117892414471, 0.06679118577649679, 0.047347038302450906, 0.04926498766187182, 0.04271821045338331, 0.04053386102781109, 0.32881073819742423, 0.31129356145239584, 0.32279113616893196, 0.3154910808823127, 0.33169833499947743, 0.3206566827309847, 0.3297799250622687, 0.33072847390018356, 0.3365272749880829, 0.0891930324996758, 0.10461315364241619, 0.11655798766406555, 0.12302503115244567, 0.09507842467742433, 0.13099237703386402, 0.11739523452875222, 0.10867580985868608, 0.11492544995299381, 0.18401121472667825, 0.14226242714489945, 0.15073201059046426, 0.22112955335784534, 0.1675285875786936, 0.17168683312056, 0.19868424466179235, 0.1554504575091361, 0.1943197603466842, 0.2539118639648221, 0.25423464742166524, 0.1751757857783407, 0.2421358863619819, 0.2539766179312697, 0.2496153500134214, 0.23491622781778498, 0.20549128024291807, 0.19533002329548577, 0.1759237278832041, 0.20093654261189264, 0.17775798537681253, 0.19506903668936681, 0.19156641701566757, 0.18190477817291983, 0.1558702109628981, 0.15450127080023557, 0.1782155221115721, 0.21154541091669676, 0.2573883949643384, 0.20579691775824305, 0.21516514967706257, 0.22435640752710584, 0.23850451703758235, 0.23738576619233986, 0.22304367183271778, 0.2277773929494321, 0.16778325877854872, 0.16906146631050067, 0.17291622390203687, 0.18422262069263695, 0.18828868843892765, 0.1687934940063004, 0.16917325911435732, 0.1686762569448651, 0.18641817888664536, 0.18474497280480828, 0.18611692297571658, 0.15052037289373876, 0.3698870431687432, 0.190571527577844, 0.1152842957283392, 0.1000378390008112, 0.1133955361390333, 0.1565660991374449, 0.48201219867627754, 0.19732017960070902, 0.34265258805413024, 0.19321316631164553, 0.138225533598463, 0.19117150960723872, 0.3522632311558689, 0.16142878032968688, 0.2612276526684335, 0.17239338465265486, 0.180526608855747, 0.18478880674223797, 0.1812543943409347, 0.19234722833604834, 0.18041941647748694, 0.18225816662376915, 0.18904254923588015, 0.17419645430446185, 0.08561141190923227, 0.08204917594719097, 0.09283740935346885, 0.10474446423665018, 0.09656011042935875, 0.08852417774188193, 0.09466947575506035, 0.09714348616432111, 0.0951784061240658]}, "mutation_prompt": null}
{"id": "0be0454d-ce1b-44e3-99f0-869e70772ca2", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            decay_rate = 0.98 + 0.01 * np.sin(evals / self.budget * np.pi)  # Dynamically adjust decay rate\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Enhanced mutation strategy by varying decay rate dynamically for improved convergence.", "configspace": "", "generation": 37, "fitness": 0.18252184501988683, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3268856817237519, 0.36371547128786297, 0.3453639032448719, 0.32180161732599666, 0.3069162971085556, 0.32662382445634697, 0.3113964967013819, 0.361241336140777, 0.35206159488498157, 0.012578010982110532, 0.017472591164786944, 0.017345948925979626, 0.026525388635870284, 0.038457977686274014, 0.01513713123015914, 0.0013420248419461211, 9.999999999998899e-05, 0.0008545332040601483, 0.0915910422127505, 0.12616657269096831, 0.11182618850872716, 0.1266970111614577, 0.10958710776174174, 0.11924476451361266, 0.07939144362860806, 0.09297313261748041, 0.09844987010663775, 0.07638504467887619, 0.07337228312669974, 0.06860090495745585, 0.09084571810189446, 0.08519955276225666, 0.0806022468530877, 0.11277886884521593, 0.08356426000592876, 0.0741053895413617, 0.9142767379987101, 0.9001242536322056, 0.9099939726439508, 0.8431736858735166, 0.8768586055330047, 0.8705120995372853, 0.8394405514780516, 0.8753775023811815, 0.8901444954943112, 0.22912464555857925, 0.24125167975498774, 0.17264008903499484, 0.24536093794402414, 0.2550400557294189, 0.18562391736684325, 0.18960771372913054, 0.18164620331048242, 0.21900217810756217, 0.23255827778600846, 0.1496221124730418, 0.21865783519762805, 0.2038781625650824, 0.2181260426389875, 0.2076283150360907, 0.15518258812442332, 0.20648298419148126, 0.18032861353840435, 0.1354236964097052, 0.11317528791263898, 0.11494850430078207, 0.10284367188961874, 0.10581631945516434, 0.10521748639688577, 0.1320787055164112, 0.12904188241642767, 0.12721197872671364, 0.14370994945409, 0.09592497733846717, 0.11876400887394956, 0.12313128853606448, 0.12325110636931225, 0.11886162941239142, 0.14522108195249517, 0.14630361603124842, 0.11810831544240552, 9.999999999998899e-05, 0.0006002840711502033, 9.999999999998899e-05, 0.004481452139283082, 0.010347861448330109, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015796986260089296, 0.013723388699594996, 0.15766181292309778, 0.0693752650694458, 0.18586590936856529, 0.06098819369873543, 0.08097771708424639, 0.044554869682917664, 0.11764341906672982, 0.07318220546274401, 0.0714819660983892, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07739640231041589, 0.04362327659552989, 0.07127142079744586, 0.08512204644626908, 0.058720179141455664, 0.04578803525091846, 0.045622412423959924, 0.052698797985622714, 0.04880342275153615, 0.32471125768501374, 0.3364244703987258, 0.3532642005087059, 0.34868375312395505, 0.315663563672266, 0.38764327727155, 0.323292048638928, 0.36465040452975106, 0.3411625439985997, 0.10178964356278009, 0.11311176946046286, 0.10742655785944422, 0.12098227802151995, 0.11667549952841949, 0.13232356308668536, 0.11340860956114807, 0.09377542072510237, 0.10103397614464593, 0.16245163149585717, 0.16243481203716914, 0.17362241143288248, 0.16923562970094697, 0.1845388759173726, 0.18887367692922918, 0.17167990017881873, 0.15020886393596322, 0.16006653392835757, 0.24015563640576998, 0.24967941804657123, 0.21470446252899378, 0.24925657669050127, 0.2544957729309911, 0.2459789993267476, 0.21366741127842237, 0.24778789286509495, 0.19535741160443976, 0.18667757631939863, 0.20431272549139234, 0.18004349798741082, 0.1829922424893935, 0.173039365787775, 0.18617054573697145, 0.16922445882976989, 0.17558497384825567, 0.16981170419966296, 0.23525782056016897, 0.2243305928240572, 0.1966193457254405, 0.2130439568260043, 0.23598590381092455, 0.2405688912337398, 0.23000135274554045, 0.2470206010981849, 0.21986947281089464, 0.17350084111448538, 0.1803338532942651, 0.17558179008800234, 0.1846310891259323, 0.18149394707508137, 0.175723316580079, 0.16776874270994702, 0.16719741336713156, 0.17060002189526513, 0.18296979988291528, 0.18305346183747406, 0.15026482471243563, 0.42485495807216445, 0.18891787707159347, 0.14744350735654843, 0.14302504840064745, 0.1140667593699356, 0.16287849227674756, 0.4866574498396342, 0.20067954479164918, 0.34007107014149107, 0.19294603489073092, 0.14572516179980632, 0.19954038344619962, 0.14251931340630686, 0.16121281161971068, 0.2585273893147302, 0.18226064679359177, 0.19606579707461758, 0.1724226517279307, 0.1825498540433671, 0.19272380470026318, 0.18918212878659335, 0.18778424200554544, 0.188167365404748, 0.19983855691901142, 0.09460174753518169, 0.11887613269224218, 0.08581876168294877, 0.10393426926816207, 0.08429893114720832, 0.09072438231923297, 0.08934802051243385, 0.09572477203918739, 0.086728740968531]}, "mutation_prompt": null}
{"id": "2bdc564a-11ed-471f-a366-dcfffb6c833c", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            diversity_factor = np.std(fitness) / (np.mean(fitness) + 1e-9)\n            mutation_intensity = 1 + 0.5 * (evals / self.budget) * diversity_factor\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6", "description": "Introduced a strategy to dynamically adjust the mutation intensity based on the diversity of the population for better convergence.", "configspace": "", "generation": 38, "fitness": 0.18287482056091467, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3222287517724589, 0.38250127868889927, 0.3400474345707225, 0.3101877841161449, 0.338837185342063, 0.31318284628212645, 0.35373064247904185, 0.37607843209686287, 0.35959060837689627, 0.01542516452802467, 0.010994494152691159, 0.019969237648154947, 0.018206100391088165, 0.011240899692092854, 0.009079032424299083, 0.00895869528672244, 0.025087548556099848, 0.0008909681844923023, 0.09274355622120178, 0.1079285008958697, 0.10584298646725687, 0.10656793312911073, 0.12514565288030977, 0.10744156335286792, 0.08510978995846141, 0.10060697673819508, 0.10762827931796237, 0.08564618242454014, 0.07288925145709835, 0.07387189607901545, 0.0920436155924308, 0.08172535400312153, 0.06632006849596961, 0.09557297635597284, 0.08448742464408932, 0.08033752054434173, 0.9148132799472343, 0.9017283246986659, 0.929163712493965, 0.8714841879001989, 0.8745028647432921, 0.8701777225143229, 0.8652077900511588, 0.8734171343737182, 0.8893833601281764, 0.2086135028030327, 0.20665807398070712, 0.25537402669680664, 0.20467333368749263, 0.2721242154844843, 0.190348203285713, 0.20630843122992581, 0.22561958833404283, 0.19915766124968615, 0.2310426802718043, 0.14174041314212482, 0.21294032093143223, 0.200043846232264, 0.1787160301468308, 0.20506480109378777, 0.14017363525495097, 0.1939029644298581, 0.20690181720991474, 0.13305041814179475, 0.10906264293727075, 0.10974656194999821, 0.12416685397413008, 0.1337514724164406, 0.09312491144826307, 0.12243921774499444, 0.10869577920255646, 0.12885520684403107, 0.15062470728605315, 0.14568105255310815, 0.09983123294098772, 0.12491454844431371, 0.12178432830488295, 0.1211206876585813, 0.12479271619324739, 0.1032873460805247, 0.11699483122990317, 0.00018333224026356731, 9.999999999998899e-05, 0.026233049920913576, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006053122569675828, 0.002223594287197206, 0.16651446745871523, 0.07420994583818807, 0.18323528876422956, 0.06602115063740044, 0.07794612582698413, 0.049580849730673116, 0.11791643069190527, 0.07585950902750771, 0.0804466064867897, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07394646049721176, 0.03895688078803394, 0.05873822028320663, 0.05210365574739351, 0.05893543810692203, 0.061176844143995934, 0.04469970897223119, 0.04435800328171868, 0.053678767185015075, 0.3067593044734064, 0.3524252684041038, 0.3154768142138662, 0.3327421871645918, 0.3305472181168744, 0.39627676760198316, 0.33701441215488026, 0.36941744209867744, 0.33586857495956823, 0.09970547090358528, 0.11863825176950127, 0.10092862893675847, 0.09935663132223416, 0.10387517133693414, 0.12486759184948293, 0.13196546114950836, 0.09196128616312638, 0.10067756233443836, 0.15261413566703086, 0.2257131875617051, 0.14920471910868038, 0.14322617282519223, 0.15961060303182273, 0.17054207286249168, 0.13857131268303802, 0.21994365733113974, 0.18407014969111968, 0.2567304661367652, 0.22942977345629767, 0.23802717318306532, 0.2534958534222973, 0.22430388083524522, 0.24253607292775692, 0.21641215650937218, 0.2205825369224722, 0.20641651593420374, 0.16643666103198562, 0.2088915721910919, 0.18231118577270478, 0.19747941211042186, 0.20843371381976572, 0.17614028201323995, 0.1623158447944939, 0.18037266178488587, 0.15567060688940948, 0.20891910854282036, 0.21580434715920604, 0.1999755522078659, 0.21710069246933705, 0.2294655301132018, 0.22284073100388546, 0.2334959202139435, 0.24396259557495215, 0.24724534945493304, 0.1770151642086608, 0.175287689695108, 0.16673425733286673, 0.18810540343229554, 0.1780092916309941, 0.16918870498511973, 0.171292161002913, 0.16829080252295148, 0.17002478677033073, 0.18268787372576667, 0.18129896825586878, 0.15116977218017014, 0.4293244655112778, 0.19253211975740592, 0.14714537584649756, 0.14393366917640504, 0.20251253395065594, 0.16469565378846596, 0.4809257287323172, 0.1981887857033976, 0.34132306248273003, 0.19892016022155135, 0.1415745954326778, 0.1996781489317575, 0.10378903260879013, 0.16311832006807703, 0.2639560367620686, 0.19348437668472107, 0.17796821625501524, 0.179799290670819, 0.19820387276444684, 0.19757097811597657, 0.18383587067993212, 0.19088322674426428, 0.17696088336325377, 0.18455352143970372, 0.10453451082089182, 0.10368172884403537, 0.085192471101455, 0.13225828717705057, 0.09393493017604837, 0.08994256531791356, 0.09614250527633028, 0.09667980149744926, 0.08949267433294439]}, "mutation_prompt": null}
{"id": "e3b2ab04-bb1c-490c-adbb-d1162647864d", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            # Apply a linear adjustment to the decay of the mutation factor\n            self.mutation_factor = max(0.4, self.mutation_factor * (1 - convergence_progress * 0.5))\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced a linear adjustment to the mutation factor based on convergence progress for improved adaptation.", "configspace": "", "generation": 39, "fitness": 0.18234048295935198, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.339797152504985, 0.3538546217579437, 0.3319197410550979, 0.32358939959261845, 0.32176899104299495, 0.3204234442104209, 0.3467717532270863, 0.3397192770606845, 0.32994736017404636, 0.04758016666982057, 0.0433487057463291, 0.00017194273320897402, 0.04232515212216148, 0.06508316908855905, 0.005202834787753852, 0.03587488753304735, 0.02087038839187194, 0.002119835831897232, 0.06489356507259891, 0.11118838011836485, 0.13277018176047972, 0.11337963535375928, 0.10948807583377962, 0.09510869829450108, 0.08552107799461772, 0.09719565829860088, 0.11380975530726978, 0.0997153439202626, 0.08520147431415703, 0.08300364960912632, 0.08777325430824234, 0.0682065576645633, 0.07067201564812964, 0.08932932736087662, 0.08870118100011426, 0.07116659614682408, 0.8879052471424461, 0.904194837381706, 0.9287090877076382, 0.8715825446768553, 0.8747431240020032, 0.8741801972470418, 0.8420965393928433, 0.915081959354391, 0.8898903159079581, 0.20750521808246736, 0.22216018535049642, 0.18645033764240815, 0.19361263950784857, 0.20603941499099232, 0.19821391738421568, 0.2340652099663021, 0.23820800734951542, 0.208217923833261, 0.23377245338354347, 0.13064036970701198, 0.20118266674191876, 0.20736897731092452, 0.2053535378884932, 0.1938955899111282, 0.15237638487477667, 0.17739883054884087, 0.1686633388480444, 0.12420803516324086, 0.1060853443805696, 0.11192765762481816, 0.11095115043023673, 0.1256577986719407, 0.07747712269599882, 0.12195232360606001, 0.10634820305808645, 0.11900903781202155, 0.14200150815517132, 0.16051229742097006, 0.12887456604561065, 0.12375147246079121, 0.13139403227169189, 0.11116058405541385, 0.13256553611954236, 0.12745851317383383, 0.11751873387791112, 0.005967201117017984, 0.0005828270617950215, 0.009152469590822832, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006894537566346504, 0.015577298738940759, 0.1664456827861981, 0.07198721577488354, 0.15078525181006752, 0.06676291802624379, 0.07958804734129299, 0.04676643805232017, 0.12502965418188328, 0.0723957366598399, 0.06318616963688328, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042737992784741996, 0.054852092597977964, 0.07675038552348379, 0.06184357124664186, 0.06957994266812384, 0.07651310495323338, 0.05381000903432054, 0.053561366872735716, 0.05618329218914764, 0.3083101318477316, 0.3121108380047337, 0.3261513620493932, 0.3288562888284994, 0.36802446902571806, 0.3240767231337066, 0.33522906462681124, 0.3720474441751116, 0.321971908483904, 0.12188647001902786, 0.1234245492205509, 0.1193499043095193, 0.12504990586833287, 0.1218742103192495, 0.0977435958743823, 0.1196375643121308, 0.0898443339922913, 0.09854696869803248, 0.13859810007054363, 0.15519977313673827, 0.1468442999970796, 0.1423535002015982, 0.1793301148494133, 0.14951721303650067, 0.1524990519177094, 0.179108855405664, 0.14297565573030258, 0.21704990606538987, 0.23870449652610792, 0.2533915319486063, 0.26867028289325856, 0.22425229795030577, 0.2547451059579766, 0.21296394081731973, 0.21891652359719482, 0.2280653127017248, 0.17985550377208204, 0.1917691842435364, 0.18519406777974612, 0.19965628721074868, 0.20922502536940923, 0.17522387239915516, 0.16315955874046373, 0.17899853466943383, 0.1637028051266236, 0.216754243064467, 0.26464533186818584, 0.22230558292837033, 0.21713185822860637, 0.24067460269261087, 0.21041783200998143, 0.2502200743516757, 0.2155513422814782, 0.22729154573368782, 0.18809919614379356, 0.17675705302829958, 0.16309931855315007, 0.18637934376489662, 0.17814759811010894, 0.1684673094447997, 0.17848845990589945, 0.16985647197222264, 0.17578176605112839, 0.18443527768639978, 0.18434134401696722, 0.1512957101888116, 0.4385783691217915, 0.18818542544428274, 0.1468566093919842, 0.1641374917226407, 0.20113251861430326, 0.16511947270009875, 0.4735953352961857, 0.20140009400117365, 0.33610023021483515, 0.1960082008236057, 0.14200685431114723, 0.19716221198236672, 0.10376386844844687, 0.16213602502603064, 0.27338262910209954, 0.1920872663683627, 0.19237008769253572, 0.19865838273586078, 0.17873674772222126, 0.18638401559899687, 0.18023229390929918, 0.1743663832640301, 0.19032552359473076, 0.18264277707973287, 0.09331331301779322, 0.12292492167107061, 0.09994936152561273, 0.12907015685123058, 0.10262152622196241, 0.08630963454847274, 0.08276876398475086, 0.08782377229172256, 0.08924211091035017]}, "mutation_prompt": null}
{"id": "fee9a2bb-85a3-4399-8c5a-7df04476c927", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            # Population size adaptation added\n            self.population_size = max(4 + int(3 * np.log(self.dim)) - int(convergence_progress * 2), 12)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced a population size adaptation mechanism based on convergence progress to enhance convergence speed.", "configspace": "", "generation": 40, "fitness": 0.18421141615785305, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32232324630972575, 0.3810779826780777, 0.3498232598428498, 0.31574893128069714, 0.3442944871107403, 0.31690187962128147, 0.3538855045108782, 0.3759692958185705, 0.35761997404545554, 0.010726864823417448, 0.02095254157981996, 0.014538495648796945, 0.015289118776120048, 0.04160775566593533, 0.00858440780784564, 0.009486346709501103, 0.011797453693059068, 0.00126735623576546, 0.0991895973437188, 0.14060501765478162, 0.09483743574206238, 0.09876356505840522, 0.13526136412903655, 0.1085992506989314, 0.08576660019696358, 0.09843590880922415, 0.12284616265448733, 0.08313576245278187, 0.07608778466914023, 0.07979631557531885, 0.09079786156461944, 0.08518244504329142, 0.06629495713485467, 0.08526279915256185, 0.08155732680178485, 0.08008403499612993, 0.9137920550668734, 0.9022792897809753, 0.9292053852257206, 0.8759504193617215, 0.8744564816590736, 0.8699237139956192, 0.8662173682078337, 0.8742615654962407, 0.8894488571618278, 0.22475791625371, 0.2100131823182162, 0.23443255822830988, 0.20399769413808333, 0.2088587940393306, 0.18983545767079235, 0.23265676453880169, 0.23304684508711837, 0.21860123892852867, 0.2310503554798231, 0.1363512552072742, 0.23411033051636654, 0.20433915743900555, 0.18837007293982433, 0.2018401736274552, 0.14628396072873018, 0.1968069286078813, 0.21219381303762752, 0.12248252988306574, 0.11343791526041036, 0.1129098647995248, 0.12587414041954503, 0.13086643459833958, 0.12220420625149964, 0.12901387497509242, 0.10887063833305255, 0.12969821212755783, 0.15365077915014536, 0.15604249485335053, 0.0997927424632471, 0.12482132043797389, 0.13679645759901282, 0.12187706565534029, 0.1199633542133961, 0.1031278144243506, 0.1164548724442731, 9.999999999998899e-05, 9.999999999998899e-05, 0.023134899242969964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011396620507676203, 0.16401614104056372, 0.082034574905823, 0.18420252473851784, 0.06554754690318987, 0.07851051562440847, 0.04688611510774443, 0.12060432346749239, 0.07503541186241369, 0.07176033174691787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07752132737649808, 0.03960780447200485, 0.052308295444360886, 0.05979119252199594, 0.06741771027680554, 0.06090284225148246, 0.03629900658082075, 0.04025277891696244, 0.043345806696528544, 0.30658285238895355, 0.32788683968871646, 0.34938783922818517, 0.32666467190688386, 0.3307878868774815, 0.3203150434245978, 0.35647642166112703, 0.3697600754706263, 0.32693850512457057, 0.1041054081739119, 0.08939374163850666, 0.10340773472608578, 0.11839720126644093, 0.12304142239836346, 0.12017137698871028, 0.11051057396259001, 0.09277103674402043, 0.10872047974627252, 0.1327485248567205, 0.24186392419348635, 0.17035208615196862, 0.18619794167785608, 0.1500192717909138, 0.16272880095234266, 0.15832823741426472, 0.2005858479046737, 0.15023278957541353, 0.2494986351315066, 0.23149629588641296, 0.2349073025192926, 0.2428898748831836, 0.21690650151772195, 0.2531519212430181, 0.23746637542964055, 0.20811462405051195, 0.21236206849110273, 0.17959948614479926, 0.18496528883411956, 0.19420242684481026, 0.23502115272140023, 0.21257712528106854, 0.20819692873592643, 0.192582915921077, 0.1678328391106445, 0.16627592034292082, 0.24111573322675428, 0.2238591546049259, 0.23575057605664784, 0.23251558074486367, 0.23502885807844542, 0.24072141252594248, 0.24836414267507811, 0.22834081383096194, 0.21228683243089386, 0.17307255107832975, 0.17242146842772965, 0.16621706593155228, 0.1927153958763974, 0.1785729810186253, 0.17303052880073666, 0.1776729309272509, 0.1660364586097809, 0.17131906842922284, 0.18343730028718253, 0.1823896441867381, 0.15069990654176724, 0.43347520282119556, 0.18836540082053266, 0.14712924037672326, 0.14369634388518882, 0.2026783614782912, 0.16465006504193258, 0.48004975296521657, 0.19736496378090707, 0.34070665737557904, 0.1953951240564329, 0.14241420079766975, 0.19516989191464307, 0.1037801564214671, 0.1631147368691247, 0.2639727565787189, 0.18812578089787335, 0.18642902039312303, 0.20473438155459556, 0.18766914799669698, 0.18204086015137044, 0.18131113899533624, 0.17640234567454405, 0.19265297306697937, 0.19425510435408977, 0.09186963753853883, 0.10747052775211874, 0.08766950932911421, 0.12904101500680465, 0.08665857307212921, 0.09970686608353085, 0.09029351696160448, 0.09551778378916864, 0.09632101482860034]}, "mutation_prompt": null}
{"id": "79392d55-d189-4a80-98e7-d242aa72beb8", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            decay_rate = 0.99 - 0.02 * convergence_progress\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved", "description": "Introduced a dynamic adjustment to the decay rate of the mutation factor based on convergence progress for enhanced adaptability.", "configspace": "", "generation": 41, "fitness": 0.18341595080370235, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3223091996133497, 0.38104697357842965, 0.3497451220514203, 0.31707534960463224, 0.34417721138313373, 0.3168940487220907, 0.3234581623214825, 0.37589778348578085, 0.3605757892596637, 0.010662706298442792, 0.018811024100601426, 0.014418442461732961, 0.015312411784098034, 0.03941690921079333, 0.008540215996062028, 0.009506765239181925, 0.019098443273503296, 0.0006557290184442399, 0.0934766674101265, 0.11343820194248133, 0.09321780515640454, 0.12407455626349073, 0.12042321357171548, 0.09600175687449242, 0.08950935282567118, 0.10595592689396438, 0.09755555624338053, 0.08147682776133569, 0.09220135895410164, 0.06347558751731719, 0.08973770435985551, 0.07391682829265467, 0.07806944290732354, 0.11298465055024631, 0.07260467154623818, 0.07266079607476805, 0.9138221569060219, 0.9022452136718009, 0.9291958420843718, 0.8759313755453617, 0.8744724968470435, 0.8702066763893741, 0.8662207387262701, 0.8740391111572607, 0.8894411978543337, 0.25358242909093986, 0.23628114122761168, 0.2104241209561788, 0.2043558427119737, 0.23829409286040004, 0.17789283367677977, 0.22840867468963977, 0.23594109014956144, 0.1915405888432541, 0.2310503554798231, 0.1550407056335853, 0.22286428684138915, 0.19874913146689033, 0.18636911858200034, 0.2018415050234157, 0.15333256467931966, 0.18621306546121008, 0.2000590043291791, 0.12244075969895096, 0.11275392381267102, 0.11284490257701907, 0.12378968312911143, 0.13062801026707016, 0.12015544473555706, 0.12904408655139465, 0.1088776143478759, 0.12995773155904866, 0.15358487616381766, 0.1558384639715007, 0.09980089372259315, 0.12672948883206814, 0.13680119666229495, 0.12188674660412491, 0.12519168577990547, 0.10319383035613428, 0.11645975847596723, 9.999999999998899e-05, 9.999999999998899e-05, 0.0233900709293563, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01204231824596158, 0.1640855221747275, 0.08218301604230871, 0.18428622337552836, 0.06126743529425516, 0.07997454055883446, 0.0469123898421, 0.12259458644691823, 0.07747787272111051, 0.07268272419615074, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07051709575762366, 0.03960979092873074, 0.052308581680667876, 0.05974337090507853, 0.06742642315659486, 0.06094859497645955, 0.04294818073843143, 0.0400907734628545, 0.04946559656892535, 0.3085340340879842, 0.3323454366517501, 0.34705529160508286, 0.330339579261854, 0.3366539290079025, 0.353729626634952, 0.3678515237383152, 0.36974525039512285, 0.3332485359595403, 0.09341921215068083, 0.15111941525143335, 0.10118954032945038, 0.12007838306616758, 0.12236796621805368, 0.11148648085964485, 0.10144007895008345, 0.12299609678996026, 0.10060186461307608, 0.15248213883799833, 0.20950180194163226, 0.15105311226641394, 0.1820553773505088, 0.1540461810001056, 0.16168530926126623, 0.13434322139760002, 0.18200156353460384, 0.1386893278901733, 0.25558488379279876, 0.2225928111150861, 0.22638579118519297, 0.25350300548627414, 0.21615002516374815, 0.25457641081547866, 0.22434878118725687, 0.20704841366975446, 0.21000854212661868, 0.17361709652919344, 0.18680396646800068, 0.2163938814512898, 0.21220515518819116, 0.21084015012629187, 0.18478370699862956, 0.17736889782546317, 0.15607265838704099, 0.16266558022267708, 0.2340407911541651, 0.22994031061875964, 0.21387897774708076, 0.2176769096894423, 0.21469125467125671, 0.20661087616496165, 0.22952732149905908, 0.23340695730781524, 0.22047731718848884, 0.17141723237815387, 0.17242043289784248, 0.16841427126213349, 0.201102198415943, 0.1799342329511725, 0.17142461589268165, 0.17567820836463055, 0.16763305260235462, 0.17600409408295525, 0.18343410323337395, 0.18238843599149457, 0.15070340251137082, 0.43347174546228195, 0.18907576661466496, 0.1471283614868506, 0.14373407223286072, 0.20251359747401698, 0.16465020268395314, 0.4800306516373313, 0.19743268019309612, 0.34077717873863433, 0.1954296592739344, 0.14239834349087888, 0.19513334518712233, 0.10377967492518492, 0.16311761788171575, 0.26397132292988457, 0.17522818266663032, 0.17777035120847062, 0.2079776125272349, 0.2093132980592095, 0.20217988309661528, 0.17248536795031977, 0.18183246711686496, 0.17987961489993798, 0.18233756296819148, 0.0934892378075518, 0.11710056188397133, 0.0826987403866839, 0.1593195895000148, 0.08855148682211145, 0.08966711370428859, 0.08787292742631303, 0.08295073337703729, 0.0949986298872385]}, "mutation_prompt": null}
{"id": "51d9dc54-fc12-44c7-a9b6-02c4b1fc6934", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99  # Newly introduced decay rate\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate  # Apply decay to mutation factor\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n            noise_scale_factor *= 1 + 0.05 * (1 - evals / self.budget)  # Adjust noise dynamically\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6", "description": "Introduced a dynamic adjustment to the noise scale factor based on the remaining budget to enhance convergence speed.", "configspace": "", "generation": 42, "fitness": 0.18250429968285575, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3183506161882722, 0.3871066280584823, 0.3629570068688045, 0.30328238768402005, 0.3123801712392281, 0.3279515231822685, 0.3385370433513505, 0.3037086041552921, 0.3629404878820526, 0.038509917417128836, 0.045980607899548165, 0.06192946336406224, 0.04287994718159849, 0.013093531221562649, 0.00829389073073239, 9.999999999998899e-05, 0.01669346007219452, 0.0008651083110671198, 0.11000165675019469, 0.10161493509144526, 0.0888363297873932, 0.12008989448473406, 0.10190583562059241, 0.09330964548846932, 0.08442002863998854, 0.09406492167776126, 0.12005091955346692, 0.07708494272701372, 0.07952169642292428, 0.06493016685144615, 0.0899336959532917, 0.07466283466415047, 0.07315063532622901, 0.09282419940334963, 0.07983281855700552, 0.07027109112374474, 0.9126288034538055, 0.9347722946936059, 0.9096985576731781, 0.8778914220937856, 0.875118993404082, 0.8695745924010431, 0.8674091664099982, 0.9177739512181835, 0.8907815628031445, 0.2371477717207493, 0.20758005268571422, 0.1872471633756223, 0.21454569196794337, 0.2585456085966189, 0.17353727644701833, 0.2029677294400155, 0.19358928506041106, 0.21248160897340362, 0.21889780015996185, 0.13831633424960432, 0.1938457638041865, 0.2516101975842371, 0.2521979800368105, 0.19921563586408364, 0.1335490030033023, 0.23418387069498314, 0.19805960448232873, 0.12680701225239632, 0.1109670147531997, 0.11594255353041005, 0.13976895267477063, 0.11777633145974031, 0.06276332550684038, 0.11653276186213557, 0.10495880899292098, 0.11558583215418239, 0.1344751765875306, 0.09779189135006672, 0.11042804928487271, 0.12199227225754239, 0.1358463156332631, 0.11086942856035553, 0.14089149537073842, 0.0801586482931127, 0.10076805268948197, 9.999999999998899e-05, 0.0004402306058942651, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005044787871494871, 0.007793100929370134, 0.15016785175342828, 0.08462356193000509, 0.16098807025661865, 0.06731764949893893, 0.08133562817058104, 0.04975974831339647, 0.11949963833593502, 0.07697497349884341, 0.08196492630210417, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0476041244526163, 0.058727634668023554, 0.037852734626655726, 0.07246340272524943, 0.05162720825555189, 0.06363630858460656, 0.04102608201405733, 0.04429303046442512, 0.04894655058923347, 0.30889131692013316, 0.3241456229366557, 0.3087116181030828, 0.32831406124397433, 0.33917862653003583, 0.34536111719955687, 0.33614473178333615, 0.32214490573082977, 0.3661392441227278, 0.07395793915422733, 0.12543856635513562, 0.11303176424672001, 0.11403931464256534, 0.09855037692267121, 0.10100228805997902, 0.10244502990560689, 0.11864039473842714, 0.1105516884668214, 0.17348596411680905, 0.2243600391320304, 0.16456335877554118, 0.1795597027111817, 0.14522612465773732, 0.19677232787954424, 0.19041122108147457, 0.15539895039340623, 0.15041620083514684, 0.24177913473524226, 0.24841537403555136, 0.23826173264394834, 0.23056535746261686, 0.2543614805696548, 0.2597143229687774, 0.2380294229089951, 0.22392307659245425, 0.203541161536269, 0.1685074191118605, 0.19214287821634224, 0.16880576655123403, 0.20293547108694032, 0.18944843206717998, 0.2070904732545059, 0.17480213053559945, 0.15956334539699457, 0.17343842555971822, 0.26491033741023917, 0.25420754326409756, 0.2247629819778344, 0.20960654656406918, 0.2239106926510902, 0.24068480772942458, 0.22464108102978342, 0.24916170620061306, 0.20779756435261576, 0.1741219032173429, 0.17241128916256043, 0.17264816910912362, 0.17288104004599247, 0.1915737555216751, 0.17475171402840484, 0.16883530537046643, 0.16825445856381593, 0.17225213612547863, 0.18360022944850063, 0.18303532669377232, 0.15024948788925263, 0.3755192851143294, 0.1909428809553556, 0.14131712255153084, 0.14423145183915476, 0.11362523723740392, 0.16543654666196694, 0.4631618560446331, 0.19800006559178163, 0.32616134058423296, 0.1950890846065012, 0.14143070255512935, 0.1971548896254588, 0.3256724057303805, 0.16250669474051627, 0.2571686451107513, 0.1708300383500465, 0.18841648767731933, 0.18706991854745814, 0.1895380364513598, 0.2050072299679221, 0.1740397798283082, 0.18442473494300782, 0.18505360943930205, 0.19552058201192934, 0.09835044037118656, 0.10936071026397676, 0.09498809620573612, 0.10426406941311928, 0.08715286232168784, 0.0821820628985781, 0.09234647317982347, 0.08322648367939878, 0.09208739647288311]}, "mutation_prompt": null}
{"id": "f478006e-877c-4353-9994-79e4155b7482", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            decay_rate = 0.99 - 0.02 * convergence_progress  # Dynamic scaling based on progress\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced a dynamic scaling mechanism for mutation factor decay based on convergence progress for faster adaptation.", "configspace": "", "generation": 43, "fitness": 0.18341595080370235, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3223091996133497, 0.38104697357842965, 0.3497451220514203, 0.31707534960463224, 0.34417721138313373, 0.3168940487220907, 0.3234581623214825, 0.37589778348578085, 0.3605757892596637, 0.010662706298442792, 0.018811024100601426, 0.014418442461732961, 0.015312411784098034, 0.03941690921079333, 0.008540215996062028, 0.009506765239181925, 0.019098443273503296, 0.0006557290184442399, 0.0934766674101265, 0.11343820194248133, 0.09321780515640454, 0.12407455626349073, 0.12042321357171548, 0.09600175687449242, 0.08950935282567118, 0.10595592689396438, 0.09755555624338053, 0.08147682776133569, 0.09220135895410164, 0.06347558751731719, 0.08973770435985551, 0.07391682829265467, 0.07806944290732354, 0.11298465055024631, 0.07260467154623818, 0.07266079607476805, 0.9138221569060219, 0.9022452136718009, 0.9291958420843718, 0.8759313755453617, 0.8744724968470435, 0.8702066763893741, 0.8662207387262701, 0.8740391111572607, 0.8894411978543337, 0.25358242909093986, 0.23628114122761168, 0.2104241209561788, 0.2043558427119737, 0.23829409286040004, 0.17789283367677977, 0.22840867468963977, 0.23594109014956144, 0.1915405888432541, 0.2310503554798231, 0.1550407056335853, 0.22286428684138915, 0.19874913146689033, 0.18636911858200034, 0.2018415050234157, 0.15333256467931966, 0.18621306546121008, 0.2000590043291791, 0.12244075969895096, 0.11275392381267102, 0.11284490257701907, 0.12378968312911143, 0.13062801026707016, 0.12015544473555706, 0.12904408655139465, 0.1088776143478759, 0.12995773155904866, 0.15358487616381766, 0.1558384639715007, 0.09980089372259315, 0.12672948883206814, 0.13680119666229495, 0.12188674660412491, 0.12519168577990547, 0.10319383035613428, 0.11645975847596723, 9.999999999998899e-05, 9.999999999998899e-05, 0.0233900709293563, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01204231824596158, 0.1640855221747275, 0.08218301604230871, 0.18428622337552836, 0.06126743529425516, 0.07997454055883446, 0.0469123898421, 0.12259458644691823, 0.07747787272111051, 0.07268272419615074, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07051709575762366, 0.03960979092873074, 0.052308581680667876, 0.05974337090507853, 0.06742642315659486, 0.06094859497645955, 0.04294818073843143, 0.0400907734628545, 0.04946559656892535, 0.3085340340879842, 0.3323454366517501, 0.34705529160508286, 0.330339579261854, 0.3366539290079025, 0.353729626634952, 0.3678515237383152, 0.36974525039512285, 0.3332485359595403, 0.09341921215068083, 0.15111941525143335, 0.10118954032945038, 0.12007838306616758, 0.12236796621805368, 0.11148648085964485, 0.10144007895008345, 0.12299609678996026, 0.10060186461307608, 0.15248213883799833, 0.20950180194163226, 0.15105311226641394, 0.1820553773505088, 0.1540461810001056, 0.16168530926126623, 0.13434322139760002, 0.18200156353460384, 0.1386893278901733, 0.25558488379279876, 0.2225928111150861, 0.22638579118519297, 0.25350300548627414, 0.21615002516374815, 0.25457641081547866, 0.22434878118725687, 0.20704841366975446, 0.21000854212661868, 0.17361709652919344, 0.18680396646800068, 0.2163938814512898, 0.21220515518819116, 0.21084015012629187, 0.18478370699862956, 0.17736889782546317, 0.15607265838704099, 0.16266558022267708, 0.2340407911541651, 0.22994031061875964, 0.21387897774708076, 0.2176769096894423, 0.21469125467125671, 0.20661087616496165, 0.22952732149905908, 0.23340695730781524, 0.22047731718848884, 0.17141723237815387, 0.17242043289784248, 0.16841427126213349, 0.201102198415943, 0.1799342329511725, 0.17142461589268165, 0.17567820836463055, 0.16763305260235462, 0.17600409408295525, 0.18343410323337395, 0.18238843599149457, 0.15070340251137082, 0.43347174546228195, 0.18907576661466496, 0.1471283614868506, 0.14373407223286072, 0.20251359747401698, 0.16465020268395314, 0.4800306516373313, 0.19743268019309612, 0.34077717873863433, 0.1954296592739344, 0.14239834349087888, 0.19513334518712233, 0.10377967492518492, 0.16311761788171575, 0.26397132292988457, 0.17522818266663032, 0.17777035120847062, 0.2079776125272349, 0.2093132980592095, 0.20217988309661528, 0.17248536795031977, 0.18183246711686496, 0.17987961489993798, 0.18233756296819148, 0.0934892378075518, 0.11710056188397133, 0.0826987403866839, 0.1593195895000148, 0.08855148682211145, 0.08966711370428859, 0.08787292742631303, 0.08295073337703729, 0.0949986298872385]}, "mutation_prompt": null}
{"id": "1aba0302-0112-4029-b663-e090b6ace110", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n        momentum_dec_factor = 0.003  # Momentum-based decay adjustment\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= (decay_rate - momentum_dec_factor * convergence_progress)  # Adjust based on momentum\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved", "description": "Enhanced convergence speed by introducing momentum-based mutation factor adjustment for adaptive diversity control.", "configspace": "", "generation": 44, "fitness": 0.18354243985079433, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3223210974794707, 0.38107333564880796, 0.3498250282175531, 0.3151474038644918, 0.34427757059868913, 0.316900692272578, 0.35385357857937516, 0.3759601220247919, 0.3576085777070759, 0.010717630522315114, 0.019742291274612356, 0.014516742065057375, 0.015291630530460676, 0.04161650232718095, 0.00858261063666066, 0.009489370803587582, 0.011767868603962062, 0.0012154627356876224, 0.09398746307547956, 0.11904875021771566, 0.09302261213005736, 0.11846668792511283, 0.1438480748832851, 0.10833323308220044, 0.09282205140763145, 0.09405407300853763, 0.09853247470036475, 0.07865114841714782, 0.08127220548756031, 0.07986836160504351, 0.09084894251173536, 0.07883384044876862, 0.07684918717999667, 0.08790894655672132, 0.08356064390976736, 0.08037824153746131, 0.9137917180229598, 0.9022740878532071, 0.929203942296561, 0.8759475463652882, 0.8744590014143943, 0.8699182806219118, 0.8662179167124964, 0.8742259275816024, 0.8894477143744525, 0.23162075088476797, 0.2099316352823417, 0.20669487595024916, 0.20933766724113745, 0.2317026662086168, 0.1806588002183951, 0.21280976775118166, 0.23218545446897132, 0.21782420963545246, 0.2310503554798231, 0.1363512552072742, 0.2337895429762301, 0.19908397390615817, 0.18837058981006605, 0.2018415050234157, 0.13027564359092791, 0.18271156402947475, 0.19324022046456035, 0.1224762581815757, 0.11339504235368913, 0.11290847631404999, 0.12585553266953953, 0.13639564433133744, 0.12225792259388524, 0.12901917403309127, 0.10887168568435823, 0.12968683380379809, 0.153650350459822, 0.1560116170867506, 0.09979404674563652, 0.12675615036858778, 0.13679718065709934, 0.12187888189037877, 0.11996068858197173, 0.10312776808078439, 0.11645564082217896, 9.999999999998899e-05, 9.999999999998899e-05, 0.023174819698335347, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011750028377402133, 0.1640397184055682, 0.08205153445206781, 0.18421568164748625, 0.0655551559287384, 0.07976474426296776, 0.04555344232957759, 0.11864433544665476, 0.07504568396166145, 0.07178768884409004, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07748359647242165, 0.03960811939664943, 0.05230725006240122, 0.05978424534033455, 0.0674622703657507, 0.06090992322474553, 0.03629976876910057, 0.04023113035073289, 0.04335350352162748, 0.3065903500792496, 0.331243917983566, 0.3493842150119677, 0.3267947527302878, 0.33078906361942784, 0.3203415895211995, 0.3565325130414323, 0.3697578547116449, 0.3269275944804887, 0.09943874995245239, 0.1501344834258016, 0.10008061868560492, 0.10911051954800965, 0.12222513238859434, 0.12018007804076514, 0.11140558984525906, 0.12552851023108103, 0.10284194642965727, 0.1378081285165721, 0.18273052048827143, 0.1289248135036718, 0.18149227530956502, 0.14889656147103958, 0.1824254948755223, 0.14551400361653233, 0.20843540860350496, 0.12808232283029575, 0.24175361974085685, 0.23117937291168578, 0.23351344915629169, 0.26213089164125936, 0.21390004455474076, 0.259276957151655, 0.23672129014631227, 0.20734127930533208, 0.18134387008309427, 0.16378752561423626, 0.18499003823343674, 0.1944713377604922, 0.23558151705100094, 0.21256611414738225, 0.19156623805591277, 0.16250532946182417, 0.16792809602341963, 0.17065090940690986, 0.2494288763785084, 0.2506817918763561, 0.23222439045337795, 0.24157166621239246, 0.2830369301286296, 0.2188002494118898, 0.2315137420660196, 0.22157591519513187, 0.2117682749349915, 0.1700016793398419, 0.1792276706738961, 0.16707807722881374, 0.19445279887715283, 0.17599940190054963, 0.17588887439346124, 0.1713628389054458, 0.17327036248209915, 0.17357558245481308, 0.18343681824844194, 0.18238947705014075, 0.1507004342686742, 0.4334710829196262, 0.18833531866144992, 0.14712910901487597, 0.1437020703997136, 0.20267913452198327, 0.16465009132502328, 0.4800556118448992, 0.19737516555541812, 0.3407179585851644, 0.19539845987755455, 0.14241166000658245, 0.19517038779178242, 0.10378007911253917, 0.16311448386052985, 0.2639725426392753, 0.186102231936632, 0.1784811172612797, 0.20030262336956317, 0.18734454764574648, 0.21058503783640403, 0.17043867349147546, 0.17815976531520306, 0.19069277875676194, 0.188652539346174, 0.09061832481800902, 0.12420234818373754, 0.09026645959627744, 0.10903618360262735, 0.10443395277971301, 0.09460040827855631, 0.09213927184901571, 0.09229993955404647, 0.09095430330029208]}, "mutation_prompt": null}
{"id": "a346d5a2-f261-4532-91a4-3b56af3373a8", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            fitness_variance = np.var(fitness)\n            self.mutation_factor *= decay_rate * (1 + 0.1 * fitness_variance)  # New adaptive scaling\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced adaptive mutation factor scaling based on fitness variance to enhance convergence speed.", "configspace": "", "generation": 45, "fitness": 0.12240887380552687, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.20.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.34439172591383627, 0.3087923970334029, 0.33540797544897927, 0.2439471925801705, 0.2901606138849713, 0.30634751825686624, 0.25585210560606964, 0.29927583258115875, 0.27711669180623344, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033290748177885465, 0.03178561691692139, 0.023567515187527865, 0.04132165182552272, 0.03156176640903463, 0.020199525813573538, 0.037816799072887264, 0.029784878602043263, 0.02453005161091426, 0.0006486370147966714, 9.999999999998899e-05, 9.999999999998899e-05, 0.03441824201390031, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.9106626038310336, 0.9980607638425784, 0.9374579084464336, 0.9964612117770411, 0.9894526471777052, 0.9695082633117366, 0.9786279978292484, 0.9383357563343929, 0.9987280955612895, 0.03469024283021083, 0.016057870148760256, 0.0006094313774285265, 0.025320030915004454, 0.022862900108545414, 0.0319909526284613, 0.06104637360621312, 0.07237711765467192, 0.0002691192430740452, 0.13221793706422302, 0.09056606925773991, 0.06778672246344153, 0.05141234588608401, 0.026754360406865074, 0.05462921893298822, 0.06991597634612412, 0.01543748687444002, 0.0303136073977206, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048885529554775875, 0.0218175491674647, 9.999999999998899e-05, 0.01910833246581367, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0686413374020407, 0.04391107266578709, 0.10079455885577004, 0.05448494082205291, 0.04621155758887474, 0.05024727311357835, 0.035014357051045386, 0.034450148420169024, 0.07973110908460423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05884441579679811, 0.3416069598860899, 0.2134054157709625, 0.2801758799356512, 0.24440195751283267, 0.2370261120010514, 0.2370314951975493, 0.2847972076273608, 0.3359041753605614, 0.30264896803412744, 0.02645870737616518, 0.056025764328996974, 0.043688294080334145, 0.01044412025622865, 0.038163626061071265, 0.039238519012274264, 0.029186803873428313, 0.02076649339896508, 0.03583169568640132, 0.13305185057584823, 0.12987764190559503, 0.12443866264995418, 0.11682604931839591, 0.15154008602803715, 0.13750517151190722, 0.1257468502266882, 0.1312811076117858, 0.12793366363933978, 0.1451349793146579, 0.14286996691761833, 0.13393869267665182, 0.16460079611531597, 0.22000850139620665, 0.20341144992275062, 0.20006493173391793, 0.19282019105115966, 0.1899533369914178, 0.05667457080432936, 0.05834447254149944, 0.06771229666875211, 0.08088081442201733, 0.10550562081921055, 0.09398496426572533, 0.09790872687695917, 0.08817125535454562, 0.08071634086361357, 0.18206713942493102, 0.1662226913362198, 0.18921525870871825, 0.20346549433318706, 0.2197938827204966, 0.20065782822458533, 0.21267151332419387, 0.16467012536698744, 0.20574095899869804, 0.020637008479719277, 0.1367116733267454, 0.08999890326996995, 0.09857021187034931, 0.021312760671588715, 9.999999999998899e-05, 0.14366416665704618, 9.999999999998899e-05, 9.999999999998899e-05, 0.10734711279643472, 0.088270301193625, 0.13446254049006856, 0.3118095776495239, 0.16987083083668664, 0.11026040914145119, 0.11252604609241024, 0.12091667619495294, 0.11608310539585198, 0.11627811187175152, 0.10205129059156393, 0.36094510635977406, 0.1411901057857372, 0.12220369808157083, 0.15939604800953688, 0.14515904654764722, 0.15842614751830808, 0.18034866545383954, 0.16421111393077936, 0.16077956320690978, 0.18965764271973917, 0.17975306474772956, 0.19098737159730061, 0.19191079685735435, 0.1825176918371768, 0.17697975213336026, 0.17132885810897824, 0.0585270093685214, 0.047871693011412364, 0.044131246839117066, 0.045033914485965165, 0.05271888610779274, 0.0309925856042782, 0.0395731167824791, 0.04596777712713296, 0.04677402756082416]}, "mutation_prompt": null}
{"id": "d04d9454-14a4-4f06-9ad8-cd3f088f1cc1", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                \n                dynamic_mutation_intensity = 1 + (avg_diversity / (self.upper_bound - self.lower_bound))\n\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * dynamic_mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced a dynamic mutation intensity adjustment based on population diversity to improve convergence efficiency.", "configspace": "", "generation": 46, "fitness": 0.18239122781964714, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.30981893640578295, 0.3533362438152611, 0.36548196221988627, 0.34062890247833, 0.2997353007284209, 0.34668683689095503, 0.33231909276550897, 0.33918716600889476, 0.362892036887283, 0.024281210303551237, 0.02763221199895849, 0.07376672401431628, 0.008445402651193201, 0.024233516957524848, 0.02300020722134344, 0.011762072533372359, 0.009588790155695248, 9.999999999998899e-05, 0.09894896267001463, 0.12023619419304155, 0.130916816175486, 0.10702167377815275, 0.13629564531609994, 0.07880393157748877, 0.1249091021027583, 0.10203859325404085, 0.09931518032456843, 0.07773587940442572, 0.09099783903376502, 0.07883635198328554, 0.0829863779377027, 0.08872497575412397, 0.08428341402056849, 0.07843357811745078, 0.07146800139594034, 0.08755970843115157, 0.8858704510572067, 0.9347191433761788, 0.9405972645882444, 0.8703927786724504, 0.8750584807602848, 0.9017243059862279, 0.8681810690279096, 0.874129483203868, 0.9985043691080369, 0.19991156927913512, 0.20804659987686258, 0.22191245362020884, 0.20819840220082653, 0.22632246754909557, 0.2422522658701729, 0.21809419913822825, 0.22340862621081992, 0.2189271854080429, 0.23130687412228212, 0.16080145296609005, 0.2001880631166899, 0.20895623828018284, 0.19462130546972356, 0.24780997001824134, 0.1477525905033623, 0.18239051460112565, 0.21856374579133375, 0.13532644752047052, 0.12577344429379445, 0.11820239229401208, 0.1003595044814738, 0.13041792878998237, 0.07929821011142735, 0.11861989476547474, 0.11389212442957686, 0.12368807104799073, 0.1352906162576466, 0.1051128907841492, 0.12906275422163616, 0.11050932027100135, 0.15094089702041258, 0.1090396464873955, 0.11490341706608398, 0.10828422845262053, 0.11942254701102051, 0.026894619290040667, 0.004689280949677799, 9.999999999998899e-05, 0.00987406726669271, 0.002325050798580919, 9.999999999998899e-05, 9.999999999998899e-05, 0.007189260182417834, 0.013314850525125488, 0.0787255260938049, 0.09513767198985279, 0.18425790919578644, 0.06732311560893955, 0.07027455118464188, 0.04473913526629203, 0.08880650714302862, 0.07544341219549355, 0.0627041541501343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058605951095498154, 0.053029115233695356, 0.05714604995420636, 0.05972403899444667, 0.0711357514324713, 0.05752055400880651, 0.0601676677384374, 0.06048939278984433, 0.048098946373433815, 0.3300492837368544, 0.3351215138520426, 0.3512237795064279, 0.326019589562056, 0.33521309191357984, 0.331291760899189, 0.34682637077120926, 0.3206111573428587, 0.40358967278160485, 0.08552122400100615, 0.12739864909467957, 0.10385147159786245, 0.1438158297170583, 0.10928786639072985, 0.12993297656017644, 0.1262311425861279, 0.09851841340327405, 0.09110028207601661, 0.16390136371410258, 0.18019117096982806, 0.18990398327203084, 0.16833666774009304, 0.1973666167775816, 0.17753263498900174, 0.23231858781962755, 0.15246496440344603, 0.1486248053521274, 0.21118512995539218, 0.24786813919836792, 0.23622489258714086, 0.23789337970060076, 0.24420166490720108, 0.244013448702476, 0.20928676603154184, 0.19743638792751927, 0.20770622945275996, 0.19201589727528368, 0.18707943898396595, 0.1633956175232012, 0.16354746763766415, 0.1706793941306345, 0.2180274112604167, 0.16647165327797553, 0.15274728809231075, 0.1499448580619943, 0.24213270767486939, 0.2268824133357944, 0.2012689802998986, 0.2282997127637223, 0.22157936183638272, 0.2445771895608192, 0.2084271807542103, 0.23740379387496402, 0.22751134626998537, 0.1823159135188276, 0.17685767634651295, 0.17195178468279848, 0.17549958975812718, 0.180305467030364, 0.16518382781241558, 0.1796221587197666, 0.17529280169520767, 0.16679770962951967, 0.18477056890288224, 0.1849728851124609, 0.15042072426444664, 0.11416332326049883, 0.19567192528378197, 0.16836929694825553, 0.16482047125337107, 0.12319515492517785, 0.15677195022966006, 0.4257397984390161, 0.19676737450931436, 0.33152711184110517, 0.19528443688279673, 0.13893135752562025, 0.19884370930289774, 0.10375884081164999, 0.1639647608499486, 0.2812575902539738, 0.19506834977026832, 0.18941870404679362, 0.1916798865173216, 0.19452460177697417, 0.19941076244535694, 0.18186334607334786, 0.17951354907265338, 0.18575232697985344, 0.18411755597132384, 0.10588506269752451, 0.11597359132637264, 0.08873137526203789, 0.10739315412962769, 0.09789219251704184, 0.12188406836506294, 0.08995695884846733, 0.08451795734230694, 0.09779931012667042]}, "mutation_prompt": null}
{"id": "9315f631-37bf-4ad6-8429-d087cc0e911c", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                fitness_improvement = self.best_fitness - np.min(fitness)\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n            else:\n                fitness_improvement = 0\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            # Introduce dynamic scaling for mutation factor\n            scaling_factor = 1 + 0.5 * fitness_improvement / (1 + evals / self.budget)\n            self.mutation_factor *= scaling_factor\n            \n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced a dynamic scaling factor for the mutation factor based on the fitness improvement rate for faster convergence.", "configspace": "", "generation": 47, "fitness": 0.10142333034278249, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.14407705264646486, 0.12504016096656834, 0.13881092702227982, 0.14017341900274582, 0.15849965340044891, 0.22445644998044423, 0.14741245213654652, 0.12582137945206906, 0.16366549473335323, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033290748177885465, 0.03178561691692139, 0.023567515187527865, 0.04132165182552272, 0.03156176640903463, 0.020199525813573538, 0.037816799072887264, 0.029784878602043263, 0.02453005161091426, 0.0006486370147966714, 9.999999999998899e-05, 9.999999999998899e-05, 0.03451600317975756, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.9448161373908046, 0.9980607638425784, 0.9708171093208722, 0.9964612117770411, 0.8589007635842574, 0.9907227786430076, 0.8558275587980633, 0.0967283979458331, 0.9987280955612895, 0.03469024283021083, 0.01605949991674882, 0.0006094313774285265, 9.999999999998899e-05, 0.022862900108545414, 0.0319909526284613, 0.061052492500733524, 0.07089416757010092, 0.0008516528803452772, 0.1300260190099043, 0.08461339944860213, 0.05777250431227399, 0.05141234588608401, 0.019494108993674986, 0.05462921893298822, 0.06991597634612412, 0.011155007995085953, 0.0303136073977206, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048885529554775875, 0.0218175491674647, 9.999999999998899e-05, 0.01910833246581367, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06723474677883623, 0.04391107266578709, 0.10080535478955355, 0.09655586202532451, 0.03675884519546613, 0.01876950093505325, 0.09893881709968899, 0.034450148420169024, 0.047160091359998435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05884441579679811, 0.17880041269887137, 0.14084835236118598, 0.17914388510080648, 0.14064668268062364, 0.11688553321678263, 0.13569789572617097, 0.1997167352562147, 0.23081819448970486, 0.1493274661578322, 0.02646139661353697, 0.056025764328996974, 0.043688294080334145, 0.009860437884926632, 0.038163626061071265, 0.037874394505343245, 0.029186803873428313, 0.02076649339896508, 0.033447533240186234, 0.12032637688509662, 0.1389485728312273, 0.12668112697211542, 0.1467635104991667, 0.13227754083888343, 0.12685025695720376, 0.15784017754544732, 0.13405972405258815, 0.12328812984055171, 0.1275407241308325, 0.13905684096070892, 0.11806673487304464, 0.1204118973721846, 0.14139687408243062, 0.14284127887962494, 0.12413494015266902, 0.15895074431635148, 0.1295869105634896, 0.05667457080432936, 0.06095809448871026, 0.06771229666875211, 0.08088081442201733, 0.098806876003395, 0.09399401599183255, 0.09791378653805682, 0.08817125535454562, 0.08071634086361357, 0.19231386384307914, 0.1662226913362198, 0.18752723448436925, 0.20346549433318706, 0.2197938827204966, 0.20065823718188291, 0.21267151332419387, 0.16467012536698744, 0.20569088999571505, 0.020637008479719277, 0.1367116733267454, 0.08999890326996995, 0.09857021187034931, 0.021312760671588715, 9.999999999998899e-05, 0.14367891329981863, 9.999999999998899e-05, 9.999999999998899e-05, 0.08362317128226282, 0.0789663286865292, 0.10627249602086286, 0.11702265036657977, 0.16634110709575978, 0.10866068011171082, 0.11805335810529793, 0.08734546749499927, 0.11391297643397169, 0.16769839157916522, 0.08828661311921338, 0.10766541963227716, 0.05867795751463223, 0.04969792043218735, 0.04739919606872922, 0.11721714171754394, 0.11367589926203636, 0.1214910586122302, 0.19340399707402778, 0.16482808553309458, 0.21611744792152932, 0.192843755149523, 0.19853942930528157, 0.1685114472083793, 0.1708775612087513, 0.19071555429925313, 0.1761051468042948, 0.0585270093685214, 0.047871693011412364, 0.044131246839117066, 0.045033914485965165, 0.05271888610779274, 0.0309925856042782, 0.0395731167824791, 0.04596777712713296, 0.04677402756082416]}, "mutation_prompt": null}
{"id": "efe71c97-8462-4c49-aa22-acf0f43e359b", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.985  # Adjusted decay rate\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # Dynamic population resizing to enhance exploration\n            if evals < self.budget * 0.5:\n                self.population_size = min(self.population_size + 1, 50)\n            else:\n                self.population_size = max(self.population_size - 1, 12)\n            self.population = np.vstack((self.population, np.random.uniform(self.lower_bound, self.upper_bound, (1, self.dim))))\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Enhanced exploration through dynamic population resizing and improved mutation strategy for faster convergence.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 12')", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {}, "mutation_prompt": null}
{"id": "9c4fbad4-6d95-4ff5-8cdb-844c96d1c48a", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor = 0.75 * (1 - convergence_progress) + 0.25  # Adjust mutation factor based on progress\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Enhanced exploration through adaptive mutation factor scaling based on convergence progress.", "configspace": "", "generation": 49, "fitness": 0.18080544319394234, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.33284736005388127, 0.33669652437945163, 0.3433747923153284, 0.2889295289327193, 0.2938129510140175, 0.3346539000529609, 0.3443971911760628, 0.35140459130170343, 0.3377548918950152, 0.047214601028198744, 0.01747340751877713, 0.01839879182396631, 0.04858634999851674, 0.07216163163819511, 0.02108963529146768, 0.008158345006842538, 0.039247105002108595, 9.999999999998899e-05, 0.11697523885163041, 0.11984488049224051, 0.1387680415481335, 0.12345321322568548, 0.12660588747083734, 0.10517582511631951, 0.10344533463386418, 0.11089732352585502, 0.09756413723457857, 0.08153463585275289, 0.0697121038706946, 0.07419078484660147, 0.09144137119899065, 0.08419814283386462, 0.08291354436472287, 0.09093408879192233, 0.08922047564723634, 0.094807242066139, 0.8891994229864679, 0.9192214210063577, 0.9324564830261438, 0.8451974353512584, 0.836465168030087, 0.8707680609640033, 0.8732434062552601, 0.9148241674957492, 0.8925576051474912, 0.27156565381149667, 0.1924054109820973, 0.22482483145571008, 0.20973664439398831, 0.23422544288155278, 0.1960535243057938, 0.17896320776225327, 0.22493005180184922, 0.21131351658952957, 0.24434581622300933, 0.11093717502472555, 0.20256931783995835, 0.2397947356282536, 0.2368690636515729, 0.24871651986803978, 0.17097558126938606, 0.1921163809594636, 0.17552014958218276, 0.10100220067421883, 0.12378056199000953, 0.11621076453200363, 0.10714372490345814, 0.1267372972321842, 0.10177983520798839, 0.1074347457899879, 0.11784670583915013, 0.11765412377112805, 0.1257329571648108, 0.10978152618136539, 0.1085562065560598, 0.13922151722336962, 0.12932087137882642, 0.11187304276628507, 0.12886610585474556, 0.09284590149447158, 0.11648303174591568, 0.0010128521501403531, 0.008483876465065654, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005024995658650555, 0.005317257793131636, 0.12869212605518277, 0.06984786199946924, 0.19457606833059493, 0.06987368799073679, 0.08849426839629226, 0.04465078009980461, 0.08085560457036767, 0.06539684369952536, 0.1145902757142141, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049557039735338315, 0.044475154271506834, 0.08085543760473524, 0.07468423467293683, 0.03906707656345565, 0.061314152466477534, 0.04393548283199289, 0.05202682643490497, 0.04933245424824417, 0.3306621009474109, 0.3416777675121785, 0.37680300937825206, 0.3295253952193382, 0.315334907364341, 0.3190384649410075, 0.33778605390002137, 0.34064178281674007, 0.3315162660883577, 0.17130370593706723, 0.12021425714308664, 0.09665821751603232, 0.11858862160215122, 0.09454812129175971, 0.12774645415333596, 0.08471560529752187, 0.11394912838828153, 0.09459031032065945, 0.1856472216282128, 0.14716816587818848, 0.16138792853583706, 0.2348975864753433, 0.1472337250492508, 0.17792100719549164, 0.1651696162103723, 0.13049747480643925, 0.19977795402695608, 0.24952772272146306, 0.24094245974244088, 0.21023885353349547, 0.260669470856965, 0.28520759212643165, 0.25977484527389594, 0.20200789555719945, 0.23724535505853706, 0.19491173943584228, 0.19455225360869377, 0.21177534236429008, 0.19682886637267505, 0.18053380053627988, 0.16112241710887898, 0.18212446955203376, 0.1733059820670545, 0.16240381639975243, 0.17554980461557057, 0.23251841028807052, 0.21405712194187054, 0.21992972776539677, 0.2249953717587685, 0.22028290510720994, 0.21417483291811779, 0.22729681919757272, 0.22508209450268002, 0.22518849985570055, 0.16679797559392007, 0.1748663458335331, 0.17593920180540734, 0.1844999951867713, 0.18008881158628542, 0.1695056351285832, 0.17737151059747613, 0.1638220870100715, 0.17281750162871046, 0.18221585763670423, 0.18313844889855613, 0.15052332685938685, 0.11386173223425688, 0.18876044045559226, 0.11399331527518641, 0.1459373891809761, 0.11887769785901603, 0.16253701922373953, 0.45547994958269333, 0.19670584374619726, 0.34372083786557917, 0.19681384163722082, 0.13948983655464509, 0.14176165545324093, 0.10402672125274293, 0.1645721878567059, 0.2662963700576604, 0.19221404631838646, 0.1819167615375722, 0.19110410568941383, 0.1928359438284848, 0.1855371811070028, 0.19693353825117588, 0.1776968946270726, 0.1761680110287065, 0.1707394494439326, 0.09248862956200721, 0.11653950415132708, 0.08829814507776501, 0.10750675196578197, 0.09371186376016705, 0.08818963050757334, 0.0864099293473215, 0.08558926327202576, 0.08490968217073824]}, "mutation_prompt": null}
{"id": "f6ebd670-50bd-4898-a37c-1ddd73f5be7d", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        previous_best_fitness = np.inf  # Track previous best fitness\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            # Adaptive decay based on fitness improvement rate\n            if self.best_fitness < previous_best_fitness:\n                improvement_rate = (previous_best_fitness - self.best_fitness) / previous_best_fitness\n                self.mutation_factor *= (decay_rate + 0.01 * improvement_rate)\n                previous_best_fitness = self.best_fitness\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - evals / self.budget) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Enhanced mutation factor adjustment by introducing adaptive decay based on fitness improvement rate.", "configspace": "", "generation": 50, "fitness": 0.06049760233906546, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.07.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.14443838378677032, 0.12560541679357118, 0.13950317528916079, 0.036427314659949306, 0.0623729012668347, 0.11663498100844938, 0.07858092897412394, 0.08726051533751122, 0.06723797386792851, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0016497228567809996, 0.024000915764636588, 0.0, 0.023720282933590853, 0.024912567374734684, 0.02689368760593225, 0.03076747860709894, 0.01827807190350561, 0.025581339725423424, 0.0, 0.0, 0.0, 0.03479715230214164, 0.0, 0.0, 0.0, 0.0, 0.0, 0.06843668582686491, 0.06676155135499906, 0.5933944005493479, 0.06578014074943361, 0.10886479605955068, 0.06142635595254764, 0.05322793189675035, 0.10357644338642691, 0.050168457524465526, 0.029288098924471484, 0.0, 0.0, 0.006769547292404754, 0.023998777207104416, 0.00249257549739923, 0.0, 0.015449156873421965, 0.0, 0.1303301588451502, 0.1194876674717108, 0.08216757795290508, 0.013973919385818934, 0.0, 0.0, 0.04294691250625693, 0.0, 0.024929766548100862, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.04900470049012895, 0.02179064477860615, 0.0, 0.021021601246218213, 0.0, 0.04984782607078919, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.055192103436776385, 0.02201595279892099, 0.1062895605225398, 0.04771852593080894, 0.0, 0.00031169301925781934, 0.13246584170459375, 0.021448087691604223, 0.01669811636960772, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.16167518410163007, 0.11000896919100467, 0.15296885735609778, 0.09430497333201548, 0.11528744722277373, 0.102274010388414, 0.15319525235931375, 0.21275564961208016, 0.1605507785007425, 0.003915347326097662, 0.0, 0.0, 0.016761483561601787, 0.0, 0.036740225954272177, 0.01100917535486301, 0.0230803648204434, 0.03363602054905024, 0.12373820619826092, 0.0890610255523352, 0.10426578322763869, 0.11052050566105664, 0.11750763452425195, 0.07524851774127217, 0.1754831771818337, 0.10627317025868566, 0.08902983080071991, 0.09610343080086936, 0.10797897452178917, 0.11663050119376017, 0.1306042951467311, 0.15440492858849697, 0.13721584824384003, 0.1228025413265823, 0.11012742391895614, 0.10216269028189673, 0.04386220228305082, 0.04959068368968278, 0.04742291424085232, 0.0684310482979863, 0.11116281065740674, 0.11451726200348944, 0.07425436937085583, 0.051823255329151885, 0.04103195150408612, 0.19720821850168335, 0.15974322842128896, 0.1909138124501495, 0.19401684546649645, 0.19672546888057985, 0.2163407534807027, 0.20362915868818476, 0.1864578497603524, 0.26405028300663, 0.0, 0.13567183042164976, 0.09163639240345889, 0.05026469935817646, 0.021959969680739544, 0.14879126024374456, 0.0, 0.05011524171580073, 0.0, 0.059340727120917425, 0.10768318459679738, 0.09757508037826501, 0.12165668734548962, 0.12450043009189937, 0.09249972152225472, 0.06676232856884001, 0.057201191894047265, 0.06226403223193322, 0.23075726388292683, 0.06543962613715648, 0.04673124602731149, 0.043126351372621, 0.031019306519728507, 0.045642898946331445, 0.06128485257822336, 0.09142513397200769, 0.07114837527167761, 0.19742811275879335, 0.1850564475686508, 0.17215091759747936, 0.137529254152153, 0.15471083087108395, 0.18131687073916014, 0.18762726767498206, 0.1602984647858815, 0.16057906822155033, 0.05015852197620496, 0.048056026900940574, 0.04435620914550875, 0.04506723912096644, 0.056907362775141745, 0.03113396753544495, 0.039191337529454695, 0.04655927203388088, 0.0504143748137279]}, "mutation_prompt": null}
{"id": "26e63d52-e919-4547-8342-7f1cdd9e5d64", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                noise_factor = np.random.uniform(-0.05, 0.05, self.dim)  # Random noise factor\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise + noise_factor, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced a random noise factor to enhance exploration in early stages and improve convergence.", "configspace": "", "generation": 51, "fitness": 0.18338456516680118, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3467895978129223, 0.3234117701542113, 0.31075051185055613, 0.29933955985885385, 0.34442735806634994, 0.31590851324349256, 0.3387291866680192, 0.31560118858354314, 0.3580084280994159, 0.08217976210408784, 0.005641825370290454, 9.999999999998899e-05, 0.05873545420417847, 0.011861578707302534, 0.013881592915732432, 0.004166799473962812, 0.009623673684354017, 9.999999999998899e-05, 0.1047632214648575, 0.12438226006344999, 0.07087975034593341, 0.10840542517221585, 0.09839398366651653, 0.09744738789095186, 0.08303845762162587, 0.10594154887363039, 0.09619604182796415, 0.09076013575306807, 0.08421976647256102, 0.07580711236731608, 0.09666042661481844, 0.08977456772855053, 0.07742188911221415, 0.08807624786233714, 0.08644214478019019, 0.08159444902762225, 0.9286225959262391, 0.8469526433233867, 0.9178424845576193, 0.8880020052399714, 0.8587492971220433, 0.9177986688369328, 0.819028088674286, 0.9126941396855407, 0.7875999047493258, 0.19279924863583242, 0.1761658825723531, 0.20326685119275356, 0.226915014195475, 0.23838286079023618, 0.20776002249746894, 0.19079272874206132, 0.2051105622685241, 0.22890538217841128, 0.2237195086382634, 0.14489651898092615, 0.18487418710899017, 0.26618576106515435, 0.19201742384091558, 0.20809965184037982, 0.16456581730327946, 0.1865444431773069, 0.1972527549465729, 0.128207832107882, 0.09711696074151643, 0.11839822548322576, 0.12692229205361238, 0.11351271060440737, 0.12192340794620082, 0.12790657277716933, 0.12873267963034674, 0.12753714200161392, 0.11583164754891317, 0.11930941734726852, 0.10708617886716854, 0.1252582485333429, 0.13689043286870983, 0.09686027334760727, 0.1403786192969646, 0.15785560747292093, 0.1180385732469229, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009417309849375499, 9.999999999998899e-05, 9.999999999998899e-05, 0.008691238195646656, 9.999999999998899e-05, 9.999999999998899e-05, 0.12628623610139733, 0.10412405819949022, 0.10516654693524907, 0.07663014824546499, 0.0774923574245231, 0.04882107211632303, 0.12418716253076001, 0.0746605739921602, 0.08028835179340355, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07814655631236034, 0.06556958980230443, 0.04861649059543416, 0.0741416320664906, 0.051104404195272624, 0.07172562781558522, 0.04371455855018136, 0.055037462380022384, 0.05241202115377874, 0.3307687354280031, 0.3376283525016627, 0.41400247491366826, 0.3432160424858631, 0.31009037247224647, 0.3522840840020073, 0.3599910694662628, 0.353590532734283, 0.3674990700222234, 0.0852274603349571, 0.11382267140513691, 0.08271958836390314, 0.11551942366372003, 0.1340426955341273, 0.1069825318959573, 0.1020422590817468, 0.12541050814904997, 0.12678794836453766, 0.13717458947043126, 0.1348542423139797, 0.1456169548618489, 0.1834725764780324, 0.17942960750649506, 0.14537477587012548, 0.13976561779306484, 0.17479933762178113, 0.2092814261449566, 0.2486658470955535, 0.23032767615165006, 0.22898488942551154, 0.26038953420837707, 0.24806861673990876, 0.2429322190626142, 0.1931018910896375, 0.19636606412607338, 0.2161259880348505, 0.1852741693860921, 0.17053543211337308, 0.1660667339592624, 0.1953669247872113, 0.2155025360820353, 0.1935174638313133, 0.16123192764927152, 0.15295151185856193, 0.15175524455333667, 0.23209572146888524, 0.23838141176644922, 0.22516676411400782, 0.21938561314718386, 0.21798510859031972, 0.22410438889985806, 0.24536798768745727, 0.23822100401363455, 0.2031261520683646, 0.17506941846945834, 0.17248331187792243, 0.1781341276198133, 0.1694441567462205, 0.187080164434133, 0.16874488898502316, 0.1720594297774778, 0.173480704020049, 0.16524110526380065, 0.18519326584844986, 0.4147627517429767, 0.14232632439855064, 0.18155274382355857, 0.19481424839282258, 0.40702267590543284, 0.15540332638633592, 0.11262742516554192, 0.1519383471021285, 0.3897794675333749, 0.19721357176457, 0.39059826730370484, 0.19216973257160197, 0.16499773641522064, 0.19684819360471373, 0.37258676825639225, 0.15804788399918657, 0.24552517477988633, 0.19634852646003687, 0.18611252228622055, 0.1921380307702445, 0.17605029636252534, 0.19011205162945133, 0.18227810291333357, 0.2140535278330642, 0.18925848339854745, 0.17408867887490398, 0.09598749748764546, 0.08097063769890933, 0.10100394284245773, 0.1269143963875463, 0.09987535688314908, 0.114965246817198, 0.08610359418012414, 0.09411027553605023, 0.0910252178885056]}, "mutation_prompt": null}
{"id": "f1eeb9cc-5b63-409c-86c5-4280a8857ea5", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                adaptive_intensity = (0.9 + 0.2 * (avg_diversity / (self.upper_bound - self.lower_bound)))\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * adaptive_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6", "description": "Enhanced mutation strategy by incorporating dynamic mutation intensity based on diversity and convergence progress to improve optimization convergence speed.", "configspace": "", "generation": 52, "fitness": 0.18135558701207982, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32393086079170785, 0.35417467359341237, 0.3431392121397111, 0.3186859453257147, 0.33886175049499545, 0.3562793319893218, 0.3657514905038093, 0.31595499796001103, 0.3687863709265433, 0.01906184816643508, 0.023929113817362846, 0.05783981715887876, 9.999999999998899e-05, 0.050472347568047526, 0.008926544858730123, 0.002730204922459567, 0.010638932205370821, 0.0035808577870800606, 0.09825649827666916, 0.08844443005923297, 0.09363366639701798, 0.12936579547164329, 0.10729378327065808, 0.1015067987961702, 0.09492445643919434, 0.10875864534142254, 0.10263981467478012, 0.08360186479294951, 0.09145281907758962, 0.06355305551080892, 0.10050222023374078, 0.08271261830932364, 0.07526956617442115, 0.08892673995191491, 0.09025062774019266, 0.08476696008772722, 0.9130806043292087, 0.9007029587067081, 0.939856726052382, 0.8737628811226896, 0.8747415104620067, 0.870850406484414, 0.8396057167055143, 0.8606063543417508, 0.8903963130359485, 0.24363064931780232, 0.18298791572459316, 0.21165692571338346, 0.18629094647474131, 0.23811652826700225, 0.19198519111432666, 0.1725013784441598, 0.2260630441461552, 0.20437117970152452, 0.23958692815213, 0.1462363309250686, 0.19263004322008814, 0.21870114892466175, 0.21003061428629344, 0.1967019625330545, 0.1596572353573238, 0.1918497066494731, 0.2004271210510713, 0.11814172066080575, 0.10431020394517088, 0.11533302399115142, 0.11082178430342338, 0.1168793831738143, 0.08603032428303992, 0.11289999359231384, 0.12856379743199853, 0.12277755179264838, 0.12533585082439025, 0.10772208155881469, 0.10387745864356879, 0.12652939269967678, 0.12793520185446705, 0.1070594700610914, 0.11736173324087196, 0.1030300555318634, 0.12413890899381363, 0.017839436455189372, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005612097819816753, 0.1582252142142383, 0.06532292966122788, 0.19475805319364703, 0.060989985957795256, 0.08519062367192198, 0.04864226873873123, 0.134252002670725, 0.0647008919142239, 0.07049964479153137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04564701213557942, 0.05416965734553292, 0.05083755143252833, 0.05925810674312182, 0.054184833225103146, 0.04699770162828376, 0.0517355703809359, 0.04626810498237666, 0.03925892225247285, 0.37297399016186006, 0.34632555418798006, 0.3411052859200343, 0.327714303510395, 0.37215209970505425, 0.31389972189420656, 0.36618528698773767, 0.34856538281953053, 0.34988920205216356, 0.0705811022942735, 0.10223518780305607, 0.10806987200470974, 0.11763761707581688, 0.10716849405583129, 0.13422860743595844, 0.11039990493330354, 0.10016753923398103, 0.10026803835869191, 0.13717648713052044, 0.15585779208062012, 0.14000357269690344, 0.1729688461664648, 0.1758742491447185, 0.15159245689216405, 0.1631589793784768, 0.15557134886455026, 0.18342090005475487, 0.23132075758838455, 0.24996253170194227, 0.24231765260745874, 0.2540581102980173, 0.22426050351894833, 0.25285324722669456, 0.22816576605301864, 0.2439634927288724, 0.18879649316056557, 0.16721750076946684, 0.21475350043463082, 0.14331045296372447, 0.20697059944161644, 0.18329690906681861, 0.1997647612201171, 0.17482481885407997, 0.21014909698879825, 0.1488629288898241, 0.22851254052896597, 0.23265612056756813, 0.2279730094516239, 0.2345689909443459, 0.2839687702541933, 0.21701844323535846, 0.2315884142993041, 0.22012757576487707, 0.2153177715176129, 0.16932592080004727, 0.16703945787616103, 0.16903019745935854, 0.17941318591910205, 0.17916545632434522, 0.17082935028233315, 0.17312220729165007, 0.17416723591622307, 0.174672390919148, 0.18383038259982454, 0.18033185184179523, 0.15104220738991248, 0.39154878816360306, 0.19330848036920922, 0.11320044728354428, 0.09400070092765322, 0.20094593786178738, 0.16430306297678743, 0.45799468132569976, 0.19485871580733738, 0.383042962896609, 0.19913505727149927, 0.14074183315822208, 0.19797937776303987, 0.10366548407262255, 0.09345018405720706, 0.24975214453408945, 0.19711222618651636, 0.18426598464321664, 0.1816736052379383, 0.20557099180499794, 0.1848789174161588, 0.1915855872344855, 0.20428288603353117, 0.17235340834305612, 0.18220034726665002, 0.09900807075270746, 0.11771739464040454, 0.08614346811455764, 0.10592280976082624, 0.09229313904649405, 0.10574231331372774, 0.10705874529217307, 0.08877837941279776, 0.09407670624317765]}, "mutation_prompt": null}
{"id": "89adc35d-c2e3-4d6f-87e8-6f8bcb0bd153", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.98  # Modified decay rate for mutation factor\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate  # Apply decay to mutation factor\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.15 * variance_factor  # Increased adaptation for crossover\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6", "description": "Enhanced mutation diversity and adaptive crossover rate adjustments for improved convergence speed.", "configspace": "", "generation": 53, "fitness": 0.1792848770424987, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32033168930812594, 0.33877528620710895, 0.3521416727793104, 0.3172722368663565, 0.34552428395962065, 0.3266571452873295, 0.3208586285372069, 0.32809226448372686, 0.32698139772938806, 0.007830741098136085, 0.016130956504313176, 0.04301784692058919, 0.00974131628888586, 0.017866740971903328, 0.002847023239943014, 0.004493805331851619, 9.999999999998899e-05, 9.999999999998899e-05, 0.08911650486352263, 0.1100803109058941, 0.10802215392589554, 0.1423482377808265, 0.1045295395784035, 0.10171118056262551, 0.08560007130026404, 0.1054581554976115, 0.09241851267954804, 0.08495062114343144, 0.08545254142976189, 0.07895940220214814, 0.08931562134993887, 0.08120247874767961, 0.078403040947288, 0.08018905263330967, 0.10008153879741222, 0.07862440498360435, 0.889485215268638, 0.9187861815807539, 0.9115352812576345, 0.8722490627952699, 0.875563215583104, 0.8693321467278995, 0.8671838433095375, 0.8723003633688662, 0.8895902154226241, 0.191824417567108, 0.18611079218566762, 0.17631359570699845, 0.24373002297085122, 0.2561792073337993, 0.19022061778846877, 0.17523065250225733, 0.2056715996801861, 0.23860223769329414, 0.22098888477779233, 0.15079794416676362, 0.20166489358441397, 0.2436291783949942, 0.21244514699081563, 0.18235732715673048, 0.1468654811629283, 0.2029556142497847, 0.16811627133871554, 0.1284755291037054, 0.11568190125197975, 0.11285612840506853, 0.1116169533929926, 0.13470137278395633, 0.08405441474626218, 0.11411420244192372, 0.12429273680296704, 0.12635136252498236, 0.1436971317522997, 0.11430201427668907, 0.11861962034677909, 0.12337250836810121, 0.12607083329301172, 0.1221688140046503, 0.1439584410828043, 0.11407527929410155, 0.11602327337816354, 9.999999999998899e-05, 0.006483693653317468, 9.999999999998899e-05, 0.002133586313499136, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04749376104879266, 0.19984954595881932, 0.08363313916666426, 0.1124115721251846, 0.060985497610120176, 0.02143207635479283, 0.05280383611467365, 0.11530032493777742, 0.07131576199505074, 0.08060875388636046, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05745890662453346, 0.054186937251044065, 0.0458430554632705, 0.05430572706771997, 0.046800370967149174, 0.047985469659966085, 0.04240130274447507, 0.03436020680559526, 0.044444843263025335, 0.3210693775995114, 0.3408202598470521, 0.31997641029010093, 0.30061465085545946, 0.3005976108687225, 0.30403812914670203, 0.3252678615147998, 0.3205657658720559, 0.32478323105849727, 0.08827186552191046, 0.1236729340844851, 0.16763402721019516, 0.1403016623741965, 0.10884459373037958, 0.11472777021159308, 0.10753150408435397, 0.10625787625078864, 0.12677171944774235, 0.17808816065051303, 0.19212885236260246, 0.23010844814145792, 0.1732876004184789, 0.16376340988969784, 0.1528625530924641, 0.1288458938074829, 0.1479614404082944, 0.17758073165793486, 0.25595600429354803, 0.24365933307291376, 0.22752188190877842, 0.2605295287685724, 0.2443869893486711, 0.23952338153848163, 0.24572018814420848, 0.21307526818334732, 0.19853938606056165, 0.19725975478124935, 0.19683314913501593, 0.1687482298280223, 0.2091140061240283, 0.16217914636818076, 0.1907740214672362, 0.16941470508375767, 0.16191876876504407, 0.16513248290752913, 0.2546481214947719, 0.25421862541231455, 0.1977985499840499, 0.19017937354266556, 0.2156596462786664, 0.21749185843312302, 0.23314075462166206, 0.20955509604116995, 0.22176852783401535, 0.17290239083876824, 0.1685691810575618, 0.1688944020656301, 0.17732482794703996, 0.1900718221571026, 0.16969310357433265, 0.1788380597385162, 0.1849189939383875, 0.17218145432440946, 0.18279076175393227, 0.10492099876281558, 0.1524512968337164, 0.17279963995025938, 0.19005670788940754, 0.11418663589166922, 0.16223922558079817, 0.20453830837581444, 0.16663701686080057, 0.4691167503275133, 0.19959632885326095, 0.3511092739146382, 0.19801765102564572, 0.1936230907816494, 0.1967470860874212, 0.1031061048365558, 0.16661636074963193, 0.267907227203552, 0.18056437233027678, 0.1794509137824558, 0.18821758673669453, 0.18946879559382446, 0.1852493052275056, 0.19140605884957118, 0.1914228843109137, 0.18524540851030047, 0.1731417217819149, 0.09048472114933881, 0.11390516738402745, 0.08518611033163703, 0.11637137913347584, 0.07998380158546348, 0.08601962510438899, 0.09041148035710644, 0.09499084261714541, 0.09991074358266416]}, "mutation_prompt": null}
{"id": "627a2c63-abb6-4c2a-8cbc-1205c4366e48", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n            self.mutation_factor *= (1 + 0.2 * (1 - convergence_progress))  # Adaptive adjustment\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced adaptive mutation adjustment based on convergence progress for enhanced convergence speed.", "configspace": "", "generation": 54, "fitness": 0.15467398535885038, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32504205707078704, 0.2938710183657386, 0.3540856765451229, 0.21438482619568167, 0.2630428487380163, 0.2888508528664999, 0.24890585879995553, 0.2520957856627568, 0.2736239973539254, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06800598168367011, 0.09072592977068283, 0.06253156016200467, 0.06465346803461347, 0.06422593543979416, 0.07647975823134479, 0.07263032217271681, 0.0704687571032957, 0.08273298881294688, 0.055343422828743716, 0.02980537291283214, 0.04437369838937699, 0.05935503301507339, 0.04899933586617555, 0.04559978525776076, 0.03883328159768029, 0.05777251533167327, 0.0363151301267608, 0.967383083266355, 0.9461981576207825, 0.9738833384325747, 0.978514450423217, 0.9566333445607145, 0.9274638998799589, 0.9691969533046595, 0.9595143970865602, 0.9350420774126607, 0.14694865104214627, 0.09071328042300397, 0.08885159758118133, 0.1132833359066503, 0.09672159189564156, 0.08740833021981942, 0.13811936108013267, 0.08745009091330735, 0.12199455313183849, 0.17569268126333648, 0.11317014028319339, 0.15612727953646843, 0.17866678660542823, 0.17644972749170962, 0.19238807859069418, 0.13016441921895294, 0.1560408003285877, 0.13081604242238487, 0.062764224327301, 0.05484676433111613, 0.026941264085652228, 0.11096563815695537, 0.023261904347177786, 9.999999999998899e-05, 0.09815266954258806, 0.08156816418655255, 0.07043028674253804, 0.0920569985224784, 0.03145976671889672, 0.07796278262270806, 0.08243465348404222, 0.06928749077956708, 0.10242736162381427, 0.11083828134449836, 0.0591823134405709, 0.0968999710705768, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12988960647512282, 0.07878345976887868, 0.11722858955884508, 0.06442446392895929, 0.07124034388551448, 0.04777188666669385, 0.07762009726771246, 0.07734103760610711, 0.09752462407521356, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03105611766206018, 0.017569029098166156, 0.018330814913215754, 0.012071595851563699, 0.011441598172958978, 0.0009338295913013939, 0.028418191870503096, 0.0031478982373813746, 0.02144198112810014, 0.2726486196496757, 0.25512631166814337, 0.2786909679289762, 0.23140645789524583, 0.25560451974693865, 0.2856989876488154, 0.3169998033531666, 0.27250854019775017, 0.31701850716226987, 0.09121524782141555, 0.08922307078640956, 0.056744177210340085, 0.06812971271144419, 0.06628396011824933, 0.12301046332164645, 0.06116007241707144, 0.07882012668269323, 0.10647310866225579, 0.15505661452185526, 0.13453923765945297, 0.14929227062277184, 0.1419300537853051, 0.12710709890389282, 0.12418026892539968, 0.13930355466893196, 0.13975414818947507, 0.16028537930519282, 0.17635566419303217, 0.21676743868677872, 0.1831240176355895, 0.22417529706839745, 0.17088859552426328, 0.20751675681022674, 0.17644627559029524, 0.18592551176012362, 0.17053443507663812, 0.1263694636263315, 0.1683626648364217, 0.1138529672105284, 0.12115851541161793, 0.14875184750641202, 0.13394082883073788, 0.13657024178894606, 0.15201482328798244, 0.10140250913833149, 0.20999193810730754, 0.20103001641197693, 0.19607319216832397, 0.2651117054925636, 0.2009378240900488, 0.19902189315802643, 0.22195257578641325, 0.23376900467164619, 0.23397195197034537, 0.16055117430550725, 0.1631429405346535, 0.16218073533524058, 0.1831254771138663, 0.1567149842385135, 0.15903286282710793, 0.16045944041726545, 0.16961176244377218, 0.16786157402442803, 0.17428820216427643, 0.17416228872143313, 0.15213918730819787, 0.31169509669958717, 0.17749263944235338, 0.1261605745308878, 0.21234902280337387, 0.18279180937100903, 0.16464413677269496, 0.26738814545917344, 0.2024916406906585, 0.35263360330519844, 0.1690493036572066, 0.14587590032870035, 0.14352504405310207, 0.09874461682266555, 0.15655023382294153, 0.1845729831928009, 0.20211715171935052, 0.17793215821190167, 0.20019887012989201, 0.16899336184097846, 0.16977702896343794, 0.18469218184763192, 0.18729767378987805, 0.2029491893336548, 0.2047974099078924, 0.08659720120734549, 0.06721931756815358, 0.07970285377615693, 0.0864958863041666, 0.07447902515568328, 0.07068592814711172, 0.06959895448045228, 0.0876113742348682, 0.09686330375949725]}, "mutation_prompt": null}
{"id": "cedfc73a-bb1a-484d-9f3a-0564db9221fe", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                \n                diversity_dependent_scaling = 1 + 0.5 * (avg_diversity / self.dim)  # Newly added dynamic scaling\n                mutation_intensity = 1 + (evals / self.budget) * diversity_dependent_scaling\n                \n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Added a dynamic scaling factor to mutation intensity based on diversity to enhance convergence.", "configspace": "", "generation": 55, "fitness": 0.18248901704979428, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32229247537742545, 0.38121838655450013, 0.3508481254790987, 0.31715590123372284, 0.34454889126496346, 0.31724828661350835, 0.35399862080221123, 0.37555051520502425, 0.35780964848103936, 0.024806908185538323, 0.0194783776052333, 0.012533340558292694, 0.013220556304618714, 0.03210807530372861, 0.008514170165957125, 0.00858565409547174, 0.016777903166969033, 0.0012455101612974806, 0.08140492344936523, 0.11553654361764076, 0.09329994136086994, 0.11317721110651369, 0.11474332415822286, 0.10368405328116659, 0.09121624200703193, 0.09646097731060677, 0.08025158489353812, 0.08353187046608257, 0.07573677176986326, 0.10119083338450507, 0.08731683249264133, 0.06899073542744572, 0.07141692090015694, 0.09031721089016209, 0.07909118382942526, 0.07527359676021184, 0.9140200737797712, 0.9022933104735935, 0.929207119359493, 0.8759720090459531, 0.8744544777628597, 0.8702060730295028, 0.866401070405856, 0.8742848121596904, 0.8894570554020972, 0.22371982933605472, 0.20984389692530625, 0.228880788989274, 0.2388256605482234, 0.23012098152852956, 0.1896058788082997, 0.2279152415863025, 0.23042310734203275, 0.2138055669589346, 0.22482589831942745, 0.1363512552072742, 0.20668351092440906, 0.2043390714960337, 0.20136468593162848, 0.19599751226177564, 0.14545986405859568, 0.1971778698977653, 0.18782567153985652, 0.12249426690659415, 0.11340237791625873, 0.11291644309279159, 0.12571191356903277, 0.1287659731071248, 0.12142953432111558, 0.129002378327571, 0.10885568536824031, 0.12964649592449273, 0.15337772900745583, 0.1559923611348799, 0.0996606938363036, 0.12674786894219892, 0.13861341825857976, 0.12203873301515, 0.12204005897564218, 0.12204481540176404, 0.11568139493673557, 9.999999999998899e-05, 0.0016827912460317673, 0.020810402652121418, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0036831204423125596, 0.16540749107796726, 0.08529955878766382, 0.18333498258014136, 0.06535883564473044, 0.08215175978927458, 0.045440314395645, 0.12493485109404079, 0.06668491191371917, 0.07471944871990288, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052658749719053044, 0.039633974552743756, 0.05317991866004035, 0.05985178443396777, 0.06735414088826908, 0.05425873801154535, 0.042814303322007086, 0.04047058507507806, 0.043372030056059385, 0.30657308863414723, 0.33006971432800625, 0.34408542617428206, 0.3429702899670979, 0.33191475379144386, 0.3223874012631919, 0.35663204979237273, 0.3736615867012131, 0.3269624953012398, 0.10251055088019967, 0.1119188186917387, 0.09854402811756013, 0.12273801386374894, 0.12303404396987339, 0.11918690843550317, 0.13639835320766358, 0.08925691211292508, 0.10903566402059695, 0.15194330822252577, 0.21129193894842446, 0.14193081638118488, 0.15156851965978946, 0.16439816079380742, 0.1887742631062257, 0.16264731970231916, 0.1835241363585418, 0.12596981850220257, 0.23946423141339768, 0.21978306315903018, 0.22727183787066607, 0.25244026816869036, 0.21297933031324934, 0.2416927041132998, 0.21050682471051885, 0.21062311268434653, 0.19660416032536088, 0.17647424658873812, 0.18942215364510462, 0.19609588100832875, 0.19024976608791744, 0.18623281550181392, 0.20028967049759017, 0.17661324619995544, 0.16063103705574888, 0.15991484283862045, 0.23136375536539422, 0.2164062674687064, 0.23133698284219817, 0.21579179785038705, 0.2229613453900443, 0.2102780554527287, 0.24783204041166007, 0.238645073513731, 0.22374982725291137, 0.17426652911077167, 0.17341084627435743, 0.1693260097877306, 0.20049575842606837, 0.18195498773871377, 0.1693896273080474, 0.1797659887716342, 0.1678926770805712, 0.17177885388293013, 0.18345853096912002, 0.18252981986193995, 0.15066265239899912, 0.43337496181194657, 0.18836942012957147, 0.14711434758489528, 0.14214001908683205, 0.20253304750868673, 0.16462803451401342, 0.4799412324788275, 0.1936777727889446, 0.34040923308420756, 0.19396159011233582, 0.1423217688557934, 0.1970937744451633, 0.1037568434558589, 0.1631103510597186, 0.26399629594041363, 0.1841536552081393, 0.18331667106441407, 0.18276090836634384, 0.20166202038569425, 0.21577471231397094, 0.20079479136309297, 0.17432877597244512, 0.19017384461867481, 0.1775417856202024, 0.09977767292848772, 0.09922100598262751, 0.09549261519661145, 0.10217866510239726, 0.08621987045241097, 0.08226884275546376, 0.10008820239021554, 0.08320993418706002, 0.08865078387442338]}, "mutation_prompt": null}
{"id": "005cd5ee-203b-4157-a2f7-40033b1f3f4f", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Improved adaptive mutation and crossover mechanisms to enhance convergence speed.", "configspace": "", "generation": 56, "fitness": 0.18421141615785305, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32232324630972575, 0.3810779826780777, 0.3498232598428498, 0.31574893128069714, 0.3442944871107403, 0.31690187962128147, 0.3538855045108782, 0.3759692958185705, 0.35761997404545554, 0.010726864823417448, 0.02095254157981996, 0.014538495648796945, 0.015289118776120048, 0.04160775566593533, 0.00858440780784564, 0.009486346709501103, 0.011797453693059068, 0.00126735623576546, 0.0991895973437188, 0.14060501765478162, 0.09483743574206238, 0.09876356505840522, 0.13526136412903655, 0.1085992506989314, 0.08576660019696358, 0.09843590880922415, 0.12284616265448733, 0.08313576245278187, 0.07608778466914023, 0.07979631557531885, 0.09079786156461944, 0.08518244504329142, 0.06629495713485467, 0.08526279915256185, 0.08155732680178485, 0.08008403499612993, 0.9137920550668734, 0.9022792897809753, 0.9292053852257206, 0.8759504193617215, 0.8744564816590736, 0.8699237139956192, 0.8662173682078337, 0.8742615654962407, 0.8894488571618278, 0.22475791625371, 0.2100131823182162, 0.23443255822830988, 0.20399769413808333, 0.2088587940393306, 0.18983545767079235, 0.23265676453880169, 0.23304684508711837, 0.21860123892852867, 0.2310503554798231, 0.1363512552072742, 0.23411033051636654, 0.20433915743900555, 0.18837007293982433, 0.2018401736274552, 0.14628396072873018, 0.1968069286078813, 0.21219381303762752, 0.12248252988306574, 0.11343791526041036, 0.1129098647995248, 0.12587414041954503, 0.13086643459833958, 0.12220420625149964, 0.12901387497509242, 0.10887063833305255, 0.12969821212755783, 0.15365077915014536, 0.15604249485335053, 0.0997927424632471, 0.12482132043797389, 0.13679645759901282, 0.12187706565534029, 0.1199633542133961, 0.1031278144243506, 0.1164548724442731, 9.999999999998899e-05, 9.999999999998899e-05, 0.023134899242969964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011396620507676203, 0.16401614104056372, 0.082034574905823, 0.18420252473851784, 0.06554754690318987, 0.07851051562440847, 0.04688611510774443, 0.12060432346749239, 0.07503541186241369, 0.07176033174691787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07752132737649808, 0.03960780447200485, 0.052308295444360886, 0.05979119252199594, 0.06741771027680554, 0.06090284225148246, 0.03629900658082075, 0.04025277891696244, 0.043345806696528544, 0.30658285238895355, 0.32788683968871646, 0.34938783922818517, 0.32666467190688386, 0.3307878868774815, 0.3203150434245978, 0.35647642166112703, 0.3697600754706263, 0.32693850512457057, 0.1041054081739119, 0.08939374163850666, 0.10340773472608578, 0.11839720126644093, 0.12304142239836346, 0.12017137698871028, 0.11051057396259001, 0.09277103674402043, 0.10872047974627252, 0.1327485248567205, 0.24186392419348635, 0.17035208615196862, 0.18619794167785608, 0.1500192717909138, 0.16272880095234266, 0.15832823741426472, 0.2005858479046737, 0.15023278957541353, 0.2494986351315066, 0.23149629588641296, 0.2349073025192926, 0.2428898748831836, 0.21690650151772195, 0.2531519212430181, 0.23746637542964055, 0.20811462405051195, 0.21236206849110273, 0.17959948614479926, 0.18496528883411956, 0.19420242684481026, 0.23502115272140023, 0.21257712528106854, 0.20819692873592643, 0.192582915921077, 0.1678328391106445, 0.16627592034292082, 0.24111573322675428, 0.2238591546049259, 0.23575057605664784, 0.23251558074486367, 0.23502885807844542, 0.24072141252594248, 0.24836414267507811, 0.22834081383096194, 0.21228683243089386, 0.17307255107832975, 0.17242146842772965, 0.16621706593155228, 0.1927153958763974, 0.1785729810186253, 0.17303052880073666, 0.1776729309272509, 0.1660364586097809, 0.17131906842922284, 0.18343730028718253, 0.1823896441867381, 0.15069990654176724, 0.43347520282119556, 0.18836540082053266, 0.14712924037672326, 0.14369634388518882, 0.2026783614782912, 0.16465006504193258, 0.48004975296521657, 0.19736496378090707, 0.34070665737557904, 0.1953951240564329, 0.14241420079766975, 0.19516989191464307, 0.1037801564214671, 0.1631147368691247, 0.2639727565787189, 0.18812578089787335, 0.18642902039312303, 0.20473438155459556, 0.18766914799669698, 0.18204086015137044, 0.18131113899533624, 0.17640234567454405, 0.19265297306697937, 0.19425510435408977, 0.09186963753853883, 0.10747052775211874, 0.08766950932911421, 0.12904101500680465, 0.08665857307212921, 0.09970686608353085, 0.09029351696160448, 0.09551778378916864, 0.09632101482860034]}, "mutation_prompt": null}
{"id": "03f62663-5bb3-4e95-a2a4-74c9b4d700dd", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n\n                diversity_factor = 0.1 * avg_diversity / self.dim\n                adaptive_crossover_rate = self.crossover_rate + diversity_factor + 0.1 * np.var(self.population) / (self.upper_bound - self.lower_bound)\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Enhanced crossover strategy by dynamically adjusting crossover rate based on diversity for improved convergence.", "configspace": "", "generation": 57, "fitness": 0.18267086163472998, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32976950574007446, 0.37696615037538495, 0.37304948798290394, 0.2930670658753174, 0.3069295014649146, 0.32432626456699043, 0.32759027044517275, 0.3296002681120379, 0.3324510017891995, 0.015794366478823263, 0.048982770718296154, 0.030187167442866092, 0.12161712847403483, 0.011135634641764924, 0.01254362996754721, 0.042994741728011876, 0.01223967948963034, 9.999999999998899e-05, 0.08088363410273725, 0.1106506068244254, 0.09300055190214118, 0.1135721741313942, 0.09955439292015567, 0.10081627886843236, 0.10281360268231732, 0.10524913590103169, 0.11412539318155102, 0.08111626914299341, 0.07972515964131421, 0.07902158484057387, 0.08871105853688854, 0.10870821828776156, 0.08584120241594062, 0.09323426426528436, 0.07770259326277007, 0.0847243725602923, 0.9019631229677508, 0.9162133415302783, 0.9398822071758355, 0.8733819388169105, 0.876757192368501, 0.9009752782719418, 0.8369279533631027, 0.8740835245354676, 0.8919235957469744, 0.2311515902928334, 0.19103616946134494, 0.18735847453614318, 0.2216711197434288, 0.21298406638064304, 0.1983231953055672, 0.21568937514177755, 0.2213500817962759, 0.2336741144758414, 0.22146706699686058, 0.1340065954849171, 0.16925530090669294, 0.20333603170409564, 0.2334427333139214, 0.21371890069660826, 0.15378666524926599, 0.20137577079925872, 0.16621847797523037, 0.14530468014832443, 0.12675080089407853, 0.11390849456546637, 0.10055944495354252, 0.19848976832195553, 0.0972213110349146, 0.11108947778898526, 0.12101959453019862, 0.1265433225712208, 0.1464552181154699, 0.11392559573156724, 0.09865403463066014, 0.12790130466171645, 0.1484620587490193, 0.1314609463683455, 0.12477799887286822, 0.08856601932919639, 0.10685150409504918, 0.05812168765020853, 0.0040165928206504775, 0.03447628786596346, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003161180237219008, 0.17318253082216617, 0.07240277943291962, 0.1583079569798157, 0.12248840776437175, 0.02574450565972597, 0.06490223832414344, 0.10634609857529409, 0.07952807025674624, 0.07484306259323459, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04241735308490857, 0.05591890595769289, 0.03679340727585423, 0.06310658819942705, 0.06745100077663024, 0.05773532741691356, 0.05564292614854893, 0.04428496942455473, 0.04725189285758502, 0.32767566790234126, 0.34516778370251644, 0.3660772526850298, 0.32338104464471074, 0.33891874605086847, 0.32380625028926613, 0.34324921605848746, 0.31906034275662143, 0.3262493256065794, 0.08063601884309368, 0.13587323233452953, 0.11736696363769283, 0.10714961533616119, 0.10787297800472606, 0.10883217984830895, 0.09583537553361565, 0.08030848015920566, 0.12303368408968418, 0.1639748227968717, 0.24487552361642373, 0.176910082043784, 0.16186191890442747, 0.14575643716295494, 0.1717875171797969, 0.12853197295251884, 0.17599312215611185, 0.17143762601972612, 0.22220012816726709, 0.2599978303768906, 0.21798986857355684, 0.25757961024304454, 0.23749899403748043, 0.2400146664655063, 0.23603755948454042, 0.1936480428450824, 0.2256670859484884, 0.18102267770029234, 0.21533281001915505, 0.1388771731567353, 0.20688519969953012, 0.17661891976299016, 0.19593853971851383, 0.16206951473049902, 0.16655873546667677, 0.18308772614488034, 0.20733404783004183, 0.2640648028791145, 0.266481691666149, 0.19804398075383656, 0.26523708073789865, 0.22576937717903411, 0.23533896501012352, 0.22189044794762036, 0.2231036953389407, 0.17510114980901004, 0.16998412876768176, 0.17724542749940642, 0.17960568045289316, 0.16878127429815337, 0.17394107129938163, 0.1807723615725001, 0.17586394652859239, 0.17259246246399995, 0.18316480977311977, 0.105707723953954, 0.15133216122095017, 0.42698071254991665, 0.18969019628619144, 0.11406326790599997, 0.1418686118667274, 0.11245343577308509, 0.16313031281816381, 0.478736109948641, 0.1980886666134588, 0.3286081472461594, 0.19529578092011868, 0.2010984555317249, 0.14005665765961728, 0.10416416774912973, 0.16554881241252717, 0.28418101975943955, 0.1916664185138518, 0.19369594980239102, 0.17726005722588756, 0.1817182952042603, 0.19732833043687792, 0.21971864416162157, 0.18483163796128188, 0.18494517473176453, 0.18826495712580193, 0.1040213024551957, 0.10005300904621439, 0.08743762546202483, 0.10711842300388985, 0.09317425680752023, 0.08618611608736215, 0.09798664028513371, 0.08556983771736126, 0.09374617290714782]}, "mutation_prompt": null}
{"id": "939dbc7e-50e2-4c66-8037-b0f36f51cebc", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.12 * variance_factor  # Fine-tuned adaptive crossover rate\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Improved crossover strategy by fine-tuning the adaptive crossover rate for enhanced convergence.", "configspace": "", "generation": 58, "fitness": 0.1818176288880495, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3229826604933195, 0.33568127680501525, 0.35720691348653844, 0.3159524099940201, 0.30736281036353197, 0.33357537785711733, 0.31891683289662676, 0.38427421340803325, 0.35761997404545554, 0.011671466135480868, 0.016803253674449348, 0.028008858191007846, 0.013635536988431673, 0.0396893038220304, 0.005638748598710164, 0.009648420157025273, 0.014488586415341564, 9.999999999998899e-05, 0.09874812458075233, 0.10058291785198292, 0.11250423841462631, 0.11134364122352303, 0.10591839689461979, 0.11034343429241711, 0.08953625576144919, 0.08260600948192864, 0.11039159008576693, 0.08313576245278187, 0.07304292316873706, 0.06833265578119097, 0.09248755009653564, 0.07664446594521579, 0.08966219220317984, 0.09117830666461291, 0.08435451207970979, 0.0756843470497508, 0.8878753492533159, 0.9001324869560436, 0.9398522565547822, 0.8720256430057045, 0.8749247190818059, 0.8697836145625453, 0.8399670672393886, 0.8732618418801702, 0.8920110760581895, 0.17235258719987778, 0.21195880588000582, 0.21549989884310783, 0.23429470530166363, 0.2078147735798045, 0.18316922359559995, 0.2068315383557856, 0.22657505881984485, 0.20838900503541624, 0.22058569733538658, 0.1363512552072742, 0.19708455268818204, 0.20128974494036012, 0.23225192398126204, 0.21098417821032145, 0.14628396072873018, 0.21351144392406018, 0.187750555091595, 0.12759110482382863, 0.10442089996310822, 0.11146432471720524, 0.11040264510688069, 0.11430733259810788, 0.0843513638455845, 0.11663562779958558, 0.11004356031430329, 0.12641089865249888, 0.15365077915014536, 0.15604249485335053, 0.0997927424632471, 0.12209562526607409, 0.12707524362196831, 0.12187706565534029, 0.1199633542133961, 0.1031278144243506, 0.1164548724442731, 9.999999999998899e-05, 9.999999999998899e-05, 0.0045108667764168775, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021562224863578505, 0.1602415543559702, 0.08973681331753924, 0.10980689702175783, 0.06554754690318987, 0.06747320582194771, 0.05935783762052105, 0.12443339251912144, 0.0798741370316558, 0.08947084371581238, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07752132737649808, 0.051641117870672826, 0.06946689457911592, 0.08236306991162168, 0.037222483088691694, 0.05224445326481675, 0.045115142713815115, 0.047317951893747656, 0.058565350132315674, 0.3413149436872682, 0.33413438646720794, 0.3364206073674968, 0.3139417967508701, 0.36701464544083917, 0.32784741745392, 0.3638388180716807, 0.3697600754706263, 0.33278624512082866, 0.08834125846317842, 0.10391682578104755, 0.129400466742696, 0.13218502883806305, 0.10224115158608671, 0.12017137698871028, 0.10372280239406284, 0.10471473185678082, 0.09350939968220884, 0.1571490367979237, 0.14235774838866233, 0.17223100527348068, 0.14145152257705562, 0.1500192717909138, 0.16347291529121266, 0.22868840538319768, 0.2084931161593523, 0.14799641559059895, 0.2448166949480597, 0.25447670285898416, 0.22064661485178239, 0.25287291095371434, 0.23186616334004861, 0.2487965259062488, 0.2271118488416014, 0.21104766880717307, 0.22156462309586789, 0.17626600339720022, 0.18764551453083878, 0.17640192482658712, 0.19226748708192232, 0.18660987593382639, 0.21612839080028423, 0.1767267644468029, 0.1606841214446274, 0.14744655653212135, 0.22510166216108696, 0.23005630948831113, 0.2521035045122467, 0.20719292158343772, 0.2141045880840876, 0.21146934538576856, 0.2506603945899927, 0.2208444299396588, 0.252852317473903, 0.17024735163548355, 0.17971637254709927, 0.17074806984442026, 0.1949315480712046, 0.1818828763661714, 0.17283315225849183, 0.17172484458634785, 0.17545325521740163, 0.18102395053949216, 0.1846088791526055, 0.1849591207681509, 0.1519743304947564, 0.43347520282119556, 0.19549450553566894, 0.11379016266320163, 0.14253757828043256, 0.19863139194924873, 0.16487865684785652, 0.48004975296521657, 0.19954192911906898, 0.3330928782685101, 0.19546161134473283, 0.13396919167856525, 0.19696119133657441, 0.10403050713987272, 0.09839939117575036, 0.2639727565787189, 0.19552409117949976, 0.1958464492644577, 0.19914021508592816, 0.18947991524712093, 0.18643050559245056, 0.1959151545588823, 0.17889119541425147, 0.20934230576436919, 0.1746934225327954, 0.08913711299492366, 0.11765827282921382, 0.08745078307539622, 0.14213568404243693, 0.09372337648206597, 0.08668758699286805, 0.09516040436171203, 0.08523593212977343, 0.08753390048895981]}, "mutation_prompt": null}
{"id": "78527150-e7aa-4890-8c27-28ce5d1fae7d", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99  # Newly introduced decay rate\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate  # Apply decay to mutation factor\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.87 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced a momentum-based update to improve exploration and convergence speed. ", "configspace": "", "generation": 59, "fitness": 0.18339837342536564, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3170564761883561, 0.3876111929341287, 0.31350761154600293, 0.3382777141251355, 0.3670691915144799, 0.34610470511585156, 0.3277849082382308, 0.3605937411204583, 0.3631620239170147, 0.027697340305922413, 0.03895337088427819, 0.019043446381534213, 0.0650282100589531, 0.08492088079335391, 0.013605504692880244, 0.0008047510512094735, 0.014796266874651187, 0.01219536146686151, 0.084706996349462, 0.13463251715430546, 0.11378837942816589, 0.13134081136971454, 0.12032573075548736, 0.1082558252204523, 0.09941113867426299, 0.11280258165399626, 0.09253084913291454, 0.08435426477426822, 0.07509173114897238, 0.07437798020892628, 0.09885923893663817, 0.07839470925764724, 0.07338513868615937, 0.09431993345425183, 0.07722890959652717, 0.07444668856784431, 0.9127438353305459, 0.9007171721825339, 0.9288974192186369, 0.8717902792895671, 0.8417651309166028, 0.8734030211094603, 0.8660903493355345, 0.9147054895300741, 0.8891597958513384, 0.2616427685942939, 0.21096576868445505, 0.2102745484313736, 0.26147883819445417, 0.24509308912086347, 0.17289407051661887, 0.2311183287459423, 0.1979051617010701, 0.23687851769014656, 0.222810335405487, 0.17280729063964972, 0.20904925063225988, 0.1998656787253963, 0.18695116106139298, 0.2030725827690809, 0.13630474874735066, 0.1867991577913244, 0.1891109065534341, 0.11525919939162255, 0.10460253997660907, 0.11745177621718339, 0.11344129356567667, 0.1302012934913115, 0.09299989457481261, 0.10444760408577092, 0.11034187788736671, 0.1187141472447798, 0.14982365794702912, 0.09262338050873498, 0.11174894938574875, 0.12125366881871813, 0.12890533487132083, 0.11739572216369831, 0.11270774441519493, 0.12714915147194183, 0.11798296178861534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004969503589914215, 0.0029972104281550394, 0.1537458019699678, 0.0876895995350937, 0.18303627310668058, 0.06653601621875094, 0.0765250534200117, 0.05303683916112345, 0.1282589753000799, 0.0838427226666808, 0.07768937369387874, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04844505795333609, 0.034908606687498844, 0.07834819155955297, 0.07816139504989439, 0.06110919406640691, 0.04945533563690985, 0.053011361024006165, 0.049887567206304606, 0.0448008063000509, 0.3343655667028054, 0.33366353808272387, 0.3814589556325223, 0.3217655065289565, 0.3292529023002573, 0.3203364847156339, 0.34605246390973377, 0.35801373600295117, 0.42866539324040354, 0.10316122925837157, 0.11747121574495356, 0.10780609472986358, 0.14570889556307942, 0.09671425467194184, 0.12343406268502499, 0.09778985973320287, 0.11452380590294053, 0.09834998534840855, 0.14546296305481043, 0.20028535024534555, 0.21635720318389506, 0.21769655599997118, 0.18284659064688336, 0.12840447937201338, 0.14064566804947265, 0.1979199107827242, 0.14680499469402952, 0.2288499373471362, 0.2436116361248104, 0.2339247134632858, 0.26804276373540814, 0.2340564866393161, 0.24859936930649806, 0.21055301933322246, 0.22330987380804912, 0.19202760548363684, 0.17043380058182533, 0.2135485007138026, 0.178564895002433, 0.1872048790822669, 0.20974652024020046, 0.18833479124053942, 0.16992136179674433, 0.17080420110455563, 0.17442390767853944, 0.22731123342442539, 0.22025660939416858, 0.2331838788097672, 0.21978383750099828, 0.237206807940179, 0.22559073621127712, 0.23891238252948976, 0.26149370902077895, 0.22603467246985343, 0.17388850601368433, 0.17346436784676922, 0.17268750221583073, 0.19595355813068338, 0.1876011643823413, 0.17910621771323398, 0.171987670083378, 0.16660622797528735, 0.1701761907157392, 0.18403796982948684, 0.1825854403254118, 0.14986383506355305, 0.1707615981041557, 0.19221135313523197, 0.13546709273223823, 0.1448682628842729, 0.2015157157245966, 0.16202564086495508, 0.4684976016389125, 0.1955457990170647, 0.32441421777319057, 0.1973299326723682, 0.1440001777221318, 0.1992040956056932, 0.10369491173361911, 0.16302453269995842, 0.260483605985674, 0.1818998183852426, 0.1857011782238408, 0.18874153905488977, 0.1951975737873164, 0.17699187109518244, 0.18015929132957786, 0.18160112839851006, 0.17769732387502413, 0.19945197099341516, 0.09300641692533118, 0.1082944203532128, 0.08098246498091632, 0.10588736900334883, 0.09468445310096685, 0.08512047335822348, 0.08791101121478828, 0.09190649938811146, 0.09125497032686547]}, "mutation_prompt": null}
{"id": "7c96f9a4-4939-4d9b-bff5-5d6fd38fdf9a", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor * (1 - convergence_progress)  # Modified crossover\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Enhanced mutation strategy with dynamic crossover adaptation for improved convergence.", "configspace": "", "generation": 60, "fitness": 0.18404502022818503, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.32232324630972575, 0.3810779826780777, 0.3498232598428498, 0.31574889157551933, 0.34489386951379597, 0.3206609536174343, 0.3538855045108782, 0.35721107577473454, 0.35761997404545554, 0.010726864823417448, 0.02095254157981996, 0.014709682096272214, 0.016431129664389865, 0.04160775566593533, 0.00858440780784564, 0.025290811867727858, 0.012967406824741734, 0.0033669239212901214, 0.09311718805001623, 0.1406162458239263, 0.09310754264628796, 0.10616561928458756, 0.12854959517386633, 0.10565810231160144, 0.0801621749878696, 0.09344289638537451, 0.10376379514327361, 0.08313857172705341, 0.07680350550518, 0.07979631557531885, 0.09079786156461944, 0.06855610508121246, 0.06504094180904829, 0.09145122381463988, 0.06892511133163992, 0.08027935876637271, 0.9137920550668734, 0.902243876487958, 0.9137906326528082, 0.8738370581953939, 0.8752857768951535, 0.8699237139956192, 0.8663087549729649, 0.8729935804591855, 0.8894329438623912, 0.2161595389175479, 0.21787365032839512, 0.20734609117823188, 0.2101610506941991, 0.22006319887986048, 0.17917434365551, 0.21629726256668425, 0.1943012377194957, 0.1900550290000218, 0.2310503554798231, 0.1363512552072742, 0.23462370804743327, 0.2035016091854096, 0.2550386868351827, 0.20352265929364588, 0.14242057927563967, 0.18144609319574323, 0.18871592745592858, 0.12248252988306574, 0.11343791526041036, 0.1129098647995248, 0.12587414041954503, 0.13086643459833958, 0.12220420625149964, 0.14117636123161958, 0.10887063833305255, 0.12969821212755783, 0.15365077915014536, 0.15604249485335053, 0.0997927424632471, 0.12482132043797389, 0.13679645759901282, 0.12187706565534029, 0.1199633542133961, 0.1031278144243506, 0.1164548724442731, 9.999999999998899e-05, 0.0038234726328133517, 0.023134899242969964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011396620507676203, 0.16089075496034544, 0.07643977460859841, 0.18420252473851784, 0.06554754690318987, 0.07851051562440847, 0.04688611510774443, 0.12060432346749239, 0.07503541186241369, 0.07176033174691787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04755808695174468, 0.03872058794445288, 0.05253712633196406, 0.05621400964634138, 0.07249708790665632, 0.06087747974446733, 0.04157628839067551, 0.04009546561953925, 0.0519073026123098, 0.30658285238895355, 0.33797874612332746, 0.34938783922818517, 0.3243105978995561, 0.3307878868774815, 0.3091386676522472, 0.35647642166112703, 0.3697600754706263, 0.32693850512457057, 0.10472464954798455, 0.11775493310499041, 0.10590448907187289, 0.1164086330645383, 0.12304142239836346, 0.12017137698871028, 0.11082750577759326, 0.10785386050756973, 0.10157929906013174, 0.1307772352026806, 0.24186392419348635, 0.1754401569992493, 0.1893330200996184, 0.1515902419385209, 0.15641622875965255, 0.2136113942437703, 0.2005858479046737, 0.15665815664575822, 0.24703069847582115, 0.23164216548873273, 0.2349073025192926, 0.23981529685943936, 0.21690650151772195, 0.25035778945214837, 0.23319674380094257, 0.20515234246586755, 0.18181724836014201, 0.17959948614479926, 0.18496528883411956, 0.19420242684481026, 0.23502115272140023, 0.21257712528106854, 0.20819692873592643, 0.192582915921077, 0.15989711577150179, 0.1706030687520126, 0.2338256631865523, 0.22420775538498305, 0.23575057605664784, 0.22946090536791097, 0.23015284508003342, 0.2532769248426283, 0.23960961029354844, 0.24088287591070745, 0.23753206323601017, 0.17307255107832975, 0.1737237613720114, 0.17056572098619016, 0.19524866267887286, 0.18121384785610894, 0.17522015230305243, 0.17265801052935092, 0.16473224272666354, 0.17552902977819962, 0.18343730028718253, 0.1823896441867381, 0.1509102486549334, 0.43347520282119556, 0.18840457349688589, 0.14712924037672326, 0.14369634388518882, 0.20302872217552226, 0.1645138869092836, 0.48004975296521657, 0.19932841602609253, 0.34070665737557904, 0.19658003813517388, 0.14209794918908936, 0.19516989191464307, 0.10389387109007242, 0.1631147368691247, 0.2639727565787189, 0.21680237083330378, 0.18290472026673643, 0.20898977138408859, 0.1931537585336257, 0.18234544918736295, 0.17636683378512008, 0.18374988630807265, 0.19265297306697937, 0.1866648675966861, 0.08958833691721324, 0.10918648575210099, 0.08635718243125268, 0.1314537292125939, 0.10402130650387642, 0.09443117917248078, 0.09174895186101495, 0.0956463454384493, 0.08999418624666178]}, "mutation_prompt": null}
{"id": "81d3af21-034b-40a8-8988-2014f24bc079", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99  # Newly introduced decay rate\n        early_stagnation_threshold = 0.1  # Add new threshold for stagnation detection\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n                # Check early stagnation and adjust crossover rate\n                if evals / self.budget < early_stagnation_threshold:\n                    self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate  # Apply decay to mutation factor\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved", "description": "Introduced a dynamic adjustment to the crossover rate based on early stagnation detection for better exploration.", "configspace": "", "generation": 61, "fitness": 0.1784689379133321, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V6_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3274630322950256, 0.3047054210779305, 0.30633048779023053, 0.3027647714797227, 0.30738874048586573, 0.3182516554075958, 0.3144982406233492, 0.3023580895195149, 0.3258571533831408, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09922968921708575, 0.10997042645409638, 0.09145351894064002, 0.12311536709127724, 0.10636286127321837, 0.11021637676588414, 0.0821064795537868, 0.10868199414490243, 0.1315182332517335, 0.0818610884294001, 0.07613399369474771, 0.0751726459832216, 0.0915759187251628, 0.056138623039562296, 0.08042921228025479, 0.09377815269099943, 0.06720029169131336, 0.07277521990920377, 0.8872542230696294, 0.9006167014361186, 0.9397096143596407, 0.8731368937588881, 0.8759260259188134, 0.8704240359507934, 0.8698508591255854, 0.8589393517565556, 0.8915476011157921, 0.1909210320453314, 0.2157339848174653, 0.22584094453146597, 0.17999285212971028, 0.22425775239802037, 0.20353336772809827, 0.1666308238055466, 0.1785864708909085, 0.20981634116517522, 0.25176898680621573, 0.14423152931474037, 0.1636320938191873, 0.24575369646653888, 0.2183121342376687, 0.20950452292600075, 0.1685342723207205, 0.2260967396256568, 0.17053706248272538, 0.10742242104391586, 0.10905015741760327, 0.12308633141980097, 0.14933424711374532, 0.04647014333203292, 0.07425163704662241, 0.13975649838745174, 0.12100690866607688, 0.1097369845187639, 0.1119791821606072, 0.10262426265989633, 0.10219627175740387, 0.12426762736073416, 0.12030190899822935, 0.1050591170160462, 0.1161581394654777, 0.11131087333476464, 0.12093996919509209, 9.999999999998899e-05, 0.015501706687848338, 0.004092041577233085, 0.013082468083264076, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00251414498044944, 0.12797723722246535, 0.06467010286922159, 0.1251266218961571, 0.07927274649212834, 0.014257708434945338, 0.0673319970694265, 0.13134592317291938, 0.08152334704041786, 0.08377326255731299, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04163014607475235, 0.042536418349202854, 0.03331023114963849, 0.044392739065183595, 0.03946083370108011, 0.04806371573843338, 0.03878720370711164, 0.05166364846721572, 0.040411914033044005, 0.31301386421642297, 0.3093259063014059, 0.29541700945826554, 0.30163389964198006, 0.3273550733848989, 0.38219695772974915, 0.3178092046622093, 0.3044643528013158, 0.31620739891879757, 0.10380822694529857, 0.1123139402951252, 0.11413842992268108, 0.11297463348056935, 0.10985073827390246, 0.1289448035447618, 0.10414992686300306, 0.11297115520697842, 0.11029155687513703, 0.15909638408240168, 0.1539316951105264, 0.1338024746296569, 0.2071764267521694, 0.20535710517421546, 0.1537829444321125, 0.19260551053673836, 0.149928154043251, 0.1397011074302159, 0.24194941683847704, 0.24426103607895444, 0.23157528677346229, 0.23638410647680552, 0.23907696340464446, 0.241435799931772, 0.21657761016781274, 0.20654079669164693, 0.20963884719807035, 0.18074658483407802, 0.20086415464056828, 0.15720376551964788, 0.22291189285476698, 0.17841969392488044, 0.18898075547951299, 0.15135324189278598, 0.15615739240397875, 0.16601249226004278, 0.23390365713132266, 0.2273090664648587, 0.21688794828139402, 0.21909511090256162, 0.23913006849593543, 0.22510244518512446, 0.20188702634733868, 0.22676112073500443, 0.21002425490370213, 0.1690555551680496, 0.1720829641754843, 0.17522432435439772, 0.17562897470636563, 0.18487439622275492, 0.16735761529205173, 0.1708737095902768, 0.17314776405941734, 0.16816411812454413, 0.18418513513258827, 0.1774355639693418, 0.15189518179300865, 0.3693112614874444, 0.191453624403484, 0.11382692346339696, 0.1629599074790402, 0.19592692804645984, 0.16886902612165244, 0.5099580176781501, 0.20052726279068334, 0.37484955727033986, 0.18702402641803506, 0.19163238453719622, 0.1929228508121097, 0.31237287312467255, 0.1642823805355652, 0.2743092506124881, 0.18896981079739994, 0.17486135657581547, 0.19216147914964798, 0.20926686042977227, 0.2003884304411402, 0.19974124792659864, 0.17710837710525462, 0.2444775389236291, 0.17640247314900448, 0.09534588922416698, 0.1067058771899203, 0.08699537394594792, 0.10587566007621085, 0.08892036496369526, 0.08528190568106198, 0.09094329700790349, 0.08829202955068072, 0.09855518477436731]}, "mutation_prompt": null}
{"id": "38683409-aedc-4648-9481-e1e4fdc69dc0", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.985  # Slightly adjusted decay rate\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.47 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim  # Slightly adjusted\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Enhanced mutation dynamics through adaptive exploration-exploitation balance for faster convergence.", "configspace": "", "generation": 62, "fitness": 0.18272897946632174, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.31787900219791887, 0.32361387827069577, 0.35737725144849186, 0.32328361937390926, 0.31515594178295947, 0.3321687783041676, 0.3360191279008956, 0.3338275851908198, 0.36552721126155485, 0.008793900404623134, 0.04105001494582283, 0.08750856525996531, 0.0065371156762965565, 0.06249720385197233, 0.011162557344487345, 0.002288650936486558, 0.016917067986392254, 0.0027955459423967266, 0.11400125622251833, 0.10913257382501174, 0.08323188839454088, 0.11816840322180999, 0.1022032157129974, 0.115787720919588, 0.08612329970369026, 0.08890887040321938, 0.1159348320232686, 0.09029940754070398, 0.08772152094879693, 0.06493285367571733, 0.08744164207582328, 0.06788915377432736, 0.07203787043965326, 0.08757120351072045, 0.07446106978292522, 0.08627803573637916, 0.913307007489274, 0.9177685379177358, 0.9287873481752907, 0.8464732884135072, 0.8757082592007546, 0.8702278932215229, 0.8678724785761451, 0.8785470335536243, 0.8903514689358579, 0.19280006429398577, 0.26979724251020687, 0.20457924454857168, 0.23660878200837165, 0.2214235419790076, 0.20982852579716715, 0.18262477389925902, 0.1681454533918466, 0.19869038472793832, 0.274953699300706, 0.13270019225327745, 0.19419905953621797, 0.2130587580236024, 0.2424722527337141, 0.2041581236438187, 0.15052717288389483, 0.1918240559870803, 0.17688940804078923, 0.13554700105801998, 0.09830887872463423, 0.11253373004363676, 0.11192332790071013, 0.07848325525850774, 0.10837598391574643, 0.10996480511989071, 0.11750287501620571, 0.1247116960569623, 0.12400724948165387, 0.09403493776949234, 0.11406713979934413, 0.1426511261412463, 0.13703531339025743, 0.12273129261038485, 0.14473772874310364, 0.10884613153700051, 0.11666787711191284, 9.999999999998899e-05, 0.0006345242337861823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007032454800335097, 0.008054154209936826, 0.15490825285829635, 0.08710028446868623, 0.1367134547639426, 0.06692157518423714, 0.0818581586433682, 0.04819844470645096, 0.11565740222135357, 0.06755484788421018, 0.07899335868760915, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04922875917869074, 0.043532105636818974, 0.03851228946176888, 0.053509621203908675, 0.044286580848480694, 0.05849039320443716, 0.045522443649681055, 0.0409376573476713, 0.05209867712250893, 0.3149719204938676, 0.31992128708448175, 0.3430970612952554, 0.3250238724203781, 0.3276584718680732, 0.31827613768835594, 0.4283369151838191, 0.3899319613008432, 0.38432755889090053, 0.10544849999545991, 0.10697424080608287, 0.11366327841565749, 0.10952561084709922, 0.13810411359792363, 0.10576717977228722, 0.10137127539046065, 0.10774905911369659, 0.12202235131377437, 0.152991831780095, 0.12417699471483434, 0.19242023480738213, 0.15691381611585442, 0.15270476791853393, 0.1827103149685796, 0.18029819910784206, 0.14649523084242755, 0.1448982724342439, 0.23508457951427708, 0.2413892844065454, 0.21904009201847197, 0.24787122831283992, 0.2653900602664573, 0.2639718552034953, 0.21717252190044622, 0.2084183206193737, 0.20996248689552366, 0.18388497470993792, 0.19102502285231904, 0.20686839009000613, 0.19349850854176076, 0.15545715531503468, 0.16291600573565834, 0.16486956575865008, 0.16592860539001852, 0.1752707778671887, 0.2113161679529899, 0.24606988703238053, 0.23550955436761056, 0.22169770742336414, 0.2248375080109316, 0.2308600517847883, 0.24026896723731173, 0.23432578093046008, 0.21780791362940666, 0.17520952303661652, 0.16729411816736706, 0.17298270269056049, 0.17601449781222744, 0.1758023788313049, 0.1665008118242025, 0.1712584461726523, 0.1710498595176161, 0.17921627675312635, 0.18105336463236466, 0.18125310275213224, 0.15129021115583308, 0.4290007182954523, 0.19087034077334963, 0.1194883077482356, 0.1614077036086694, 0.113338797462468, 0.16553394124007792, 0.5533950523677438, 0.19494034096345414, 0.3533269615923367, 0.19020233652450547, 0.14367091131810317, 0.19308120810836427, 0.3024322820286679, 0.1628920917511597, 0.2588836060197244, 0.1951528325709806, 0.189819158515238, 0.1938799124283287, 0.18602477892174052, 0.18222196850447647, 0.1919031576193957, 0.18586889292357955, 0.19781657564370725, 0.1887818748457457, 0.08703033061867915, 0.12310207134922968, 0.08514165082684177, 0.10632367895320582, 0.09275061854646172, 0.0890677858699519, 0.09265517724588612, 0.08561543484011724, 0.09419266238855961]}, "mutation_prompt": null}
{"id": "83f8faae-b1de-4ceb-8e65-a41069b47e87", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress) + 0.1 * avg_diversity / self.dim\n            \n            diversity_adjustment = 1 + 0.1 * (avg_diversity / diversity_threshold)\n            adjusted_mutation_factor = self.mutation_factor * decay_rate * diversity_adjustment  # Adjusted mutation factor\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + adjusted_mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Enhanced diversity management through adaptive strategy for mutation factor adjustment to improve convergence speed.", "configspace": "", "generation": 63, "fitness": 0.18379377687676207, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3560146872292317, 0.33349111676122634, 0.3369161794591413, 0.33995975982436244, 0.33389314168454487, 0.3298816820670687, 0.32244920976807057, 0.3429967129183853, 0.33248064149689827, 0.054764248187470166, 0.032875475307697744, 0.00266757338975554, 0.022415766234096246, 0.05632541425401627, 0.013890237869963351, 0.002105817630120299, 0.0627486149502704, 9.999999999998899e-05, 0.11868465153297236, 0.09828898632763194, 0.11950527988253601, 0.14100730641522075, 0.09233521832155789, 0.12275070708393065, 0.09689977188500709, 0.14334815899253595, 0.1269091594565751, 0.07677102561018179, 0.0865850236323451, 0.08100001049829786, 0.08596314576933617, 0.09049111403561705, 0.09413926721393306, 0.08651510045621158, 0.07642199692015728, 0.07764371640218015, 0.9035996201279568, 0.9960267227974554, 0.9114093820931692, 0.8422104506045901, 0.8735665208248771, 0.9023246860394243, 0.867937795558766, 0.9363944247093703, 0.9987280955612895, 0.19423081204034387, 0.2181925483392987, 0.19955879725072712, 0.22135469800332264, 0.20711541777393383, 0.18908207526614507, 0.2074918890128844, 0.21087681973592698, 0.17303127211105207, 0.21559261973400023, 0.15700745218497303, 0.19178607604203635, 0.33537698102884095, 0.2712246505162148, 0.23742739380307376, 0.16936033902201975, 0.2008102945760908, 0.23687484517067747, 0.12594998282543746, 0.10276865612848518, 0.11543513131500494, 0.1147755981441787, 0.11524066985748682, 0.046574918551957833, 0.1167071927997888, 0.12689922883836824, 0.11457657443252733, 0.13371279253774793, 0.11959171813243907, 0.109978514018084, 0.10572288736250779, 0.13900015487882722, 0.12007297888781754, 0.13072506993370903, 0.14361940788676553, 0.11900346637056225, 9.999999999998899e-05, 0.00016678485016130562, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05751610730270862, 0.0833069379744018, 0.14120592846361502, 0.07073415164965058, 0.06525135000463156, 0.046425912028551286, 0.051327223229283514, 0.07064701760032444, 0.10312786982903854, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06140092372923589, 0.06146222710428706, 0.04743338263375896, 0.06915204407263431, 0.07060938678396411, 0.06331924620708707, 0.05246437205967491, 0.07213222671197472, 0.06088822951605777, 0.33703703693387954, 0.3407404954457728, 0.31137034487175885, 0.3294999741867638, 0.3413309317344462, 0.3469387302493917, 0.33256482949833266, 0.3481542552556999, 0.34535649138731384, 0.09895894662531424, 0.1245924146543892, 0.11173658931302621, 0.10726848304811487, 0.10829956215119907, 0.1285509246711799, 0.1253599898626102, 0.09196663702922547, 0.10322990933888554, 0.13220177882931783, 0.16439111990236, 0.12760684423409618, 0.18663916454387197, 0.13857773651219707, 0.14337692134648894, 0.2168223200372752, 0.1863087069325149, 0.21996577546086482, 0.2392158319250215, 0.263919434070516, 0.2223638740031164, 0.24520714228276763, 0.20311204842555863, 0.2615532859974804, 0.21040115545523308, 0.20270626809086245, 0.208745857188955, 0.18393646560315313, 0.18983601345616785, 0.16095952936128455, 0.1990508794012914, 0.1888823729125002, 0.18609138534393865, 0.17616972582141532, 0.16494974451348265, 0.1713837496831251, 0.24165733172537196, 0.2213980059026479, 0.19628660390694952, 0.2223244350417155, 0.24779331288971773, 0.2371621795780322, 0.21801141349347997, 0.21788204594953708, 0.201188669568512, 0.17404525565208429, 0.1726454782811575, 0.17203318345934882, 0.1660207599387752, 0.17238148035305823, 0.1725046127486488, 0.18029712148864563, 0.17894603376423623, 0.17140134840203158, 0.1829959025885196, 0.17954534150155121, 0.15070501637255473, 0.4191849179409687, 0.1959772745318642, 0.14647912354638049, 0.1653823978155199, 0.11270293270739673, 0.1589936657901977, 0.17038024668880913, 0.20110677765538043, 0.32288687754106626, 0.19897075327914804, 0.19709842181499748, 0.19369644728369173, 0.3420322961493485, 0.16315386641383633, 0.31370475653772545, 0.18782703056651262, 0.18335443734847878, 0.18744467113911556, 0.18914536179569408, 0.1991195389754744, 0.19031094733788445, 0.1814332266230786, 0.1829371845945258, 0.21794828296159852, 0.08935961956560856, 0.10113059275766845, 0.08649551707479819, 0.10519884760383613, 0.09394148977387962, 0.09983096210694098, 0.09780545454140899, 0.10078828204164525, 0.08862152862764983]}, "mutation_prompt": null}
{"id": "12f4d742-5dd5-4572-a6ac-48af33cc6faf", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim  # Modified for dynamic adjustment\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Introduced dynamic adjustment to noise scale factor based on convergence progress for enhanced exploration.", "configspace": "", "generation": 64, "fitness": 0.18818683194400515, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "2246b444-ae41-45ef-a5ad-9ca29154eec4", "metadata": {"aucs": [0.3340575935390717, 0.35291483126643497, 0.3550709963933728, 0.3488976266401155, 0.35563689055020986, 0.3502626950456217, 0.3770075056259792, 0.38021463552126644, 0.3610952223974867, 0.02317016238035363, 0.03147536334304646, 0.015325181044853031, 0.020176790437437697, 0.05110538763506811, 0.000452487530178014, 0.0020232583676320637, 0.011642379907131017, 9.999999999998899e-05, 0.09196319768369243, 0.1405228520456805, 0.10419696862514538, 0.12423021604338924, 0.11531166381177593, 0.10072139534467572, 0.10284525041132331, 0.09572107617553338, 0.10407546148016611, 0.08292298770261641, 0.07882942233391621, 0.06939662395236301, 0.09589619344325073, 0.08956814139560043, 0.07768074107771938, 0.09517862586382597, 0.07100648625269046, 0.08267519943623014, 0.9137655925852138, 0.9008102370275723, 0.940157180173472, 0.874519660510124, 0.8759579330403942, 0.8692139482908408, 0.8653447699689159, 0.8596971084293683, 0.8890638602829485, 0.20596589344010763, 0.22747098813953215, 0.2080265518059775, 0.2304537558574179, 0.27462355952060147, 0.23599120973229415, 0.2370323243865503, 0.22617669832505682, 0.21039611453710505, 0.22652876786238152, 0.13482483929789668, 0.2277234640770387, 0.20985161627201854, 0.24462131451212932, 0.21980000247740028, 0.16435278489185312, 0.19343511859181273, 0.19830574938119316, 0.14381525094334557, 0.12040194124167214, 0.10987868118839017, 0.13432512035052913, 0.12993919683873933, 0.09781817221111067, 0.12110273632435731, 0.11371605452353584, 0.12696367256801844, 0.15559272527891987, 0.12658315487939942, 0.11028993362078021, 0.12650737071002438, 0.15576797681276422, 0.12132559158557144, 0.150439140032545, 0.15167882067982807, 0.11415730250106082, 0.008086165272302992, 0.00885911639960324, 0.01802212778451373, 0.0001181490891558612, 9.999999999998899e-05, 0.013984674175637757, 9.999999999998899e-05, 0.006083294673386308, 0.012913630605328574, 0.1606849486387808, 0.07077735922770045, 0.15495106889167165, 0.06127977032618215, 0.07447640318553772, 0.05012285625629864, 0.12868083527187724, 0.06983028601345975, 0.06994751992637138, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007267960148323094, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05912890922742686, 0.04218879127337205, 0.08505681604481319, 0.05949768522075605, 0.06411040973983162, 0.060993262703009865, 0.04526735521473291, 0.05477223448270507, 0.04869076092855573, 0.34814585976923995, 0.36214463117102025, 0.35042437490602596, 0.35878491482823394, 0.33504166030827975, 0.3329911065574436, 0.36167493755127567, 0.38181341284125425, 0.34439300435215114, 0.07893487361242257, 0.14279524690440648, 0.12655390364945796, 0.12728385099284223, 0.10996985988827668, 0.11488262170409858, 0.10648245082175822, 0.11386488457748623, 0.12879687954628316, 0.20715698233403368, 0.23687515818084626, 0.14599314819708775, 0.21614896593634803, 0.167291873736524, 0.16024140251436114, 0.21259386299597705, 0.1896148310690351, 0.1489026633740561, 0.2672138325271297, 0.2588479007423423, 0.2046483490288975, 0.2552626024949174, 0.22022840573635838, 0.25735539869450985, 0.2263867860038531, 0.2262413789169062, 0.19290209808126946, 0.1792305840230889, 0.20649774814227861, 0.16761625710219397, 0.216708881713764, 0.2038935200675861, 0.1756032645026646, 0.18964975567960585, 0.16926794735013118, 0.17442037460882254, 0.24021714636159341, 0.2151817588123719, 0.21579962755016724, 0.21291911735943647, 0.23954243593293334, 0.23575401136943996, 0.21946771191861114, 0.2244878509465853, 0.24502633550598674, 0.1733837227090711, 0.18098500757012115, 0.17261160417710575, 0.19462321855459963, 0.19381431429712637, 0.17833373733525537, 0.17131202868611706, 0.16619246235827323, 0.17574250876237074, 0.18458996542682427, 0.18419205283575424, 0.15005905421888022, 0.4856331348805596, 0.19517366654358048, 0.13686803243833745, 0.14238192601010613, 0.20182795282700916, 0.16492761909402687, 0.504873981778847, 0.20356826596576016, 0.38221316288991447, 0.19334187087770072, 0.14441637863383272, 0.1975874797348034, 0.10403779943441716, 0.16322924521830684, 0.27863445413371524, 0.18091767193338248, 0.18109286848796768, 0.1866637790041732, 0.1818414966268932, 0.192739346806027, 0.1935376258281175, 0.17526300763090408, 0.2269398345187562, 0.1855401910601574, 0.09440841888086038, 0.10022079067084144, 0.10541668909336044, 0.11247802625317604, 0.08748140108745539, 0.08548927488183256, 0.09131359168538289, 0.09479180728328607, 0.09291900015244758]}, "mutation_prompt": null}
{"id": "ac997048-ff7c-4978-abd3-aa5ba5922ae7", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.995  # Slightly adjusted decay rate\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7", "description": "Incrementally adjusted mutation factor decay to enhance exploitation phase effectiveness.", "configspace": "", "generation": 65, "fitness": 0.18816995180137186, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "12f4d742-5dd5-4572-a6ac-48af33cc6faf", "metadata": {"aucs": [0.35052664275598244, 0.35689679305971267, 0.3611442944597536, 0.3409722733722631, 0.3427626590919838, 0.34924838390248947, 0.3485051963863083, 0.3368683543060561, 0.36383461985982946, 0.023946307995899252, 0.06185070895849498, 0.011196194874500853, 0.024730627601385113, 0.04107942701772138, 0.0011815742799071716, 0.0011515053762779504, 0.025063160242501326, 9.999999999998899e-05, 0.09058644451100029, 0.1316191513115369, 0.07177708780891279, 0.11103742320065835, 0.12406760329586197, 0.10210451119170716, 0.10414482132800329, 0.11608805906102138, 0.1027886660089391, 0.09702179241643605, 0.07312940278781821, 0.09406323408026163, 0.09652960988657944, 0.0770723404903827, 0.07683613382253329, 0.09929050776727633, 0.061654794320312845, 0.08307112988068222, 0.8877994037299313, 0.9170571912535543, 0.9293322733655577, 0.8726350064008381, 0.8364836585617528, 0.8701774049609439, 0.866838852225606, 0.8960969704494786, 0.889365214640452, 0.21118121184853866, 0.1923229689649022, 0.23588047464203643, 0.23744181834795985, 0.2408496777443614, 0.2680922290433785, 0.24570511467207945, 0.22197577274427183, 0.21895018814974032, 0.22977077034320137, 0.1267788926749963, 0.21762202635120298, 0.21755319340852086, 0.20497153520961853, 0.2048485958819587, 0.16952186317131268, 0.18945231276001862, 0.21473523444763465, 0.13520631153330798, 0.12571237616420095, 0.11671483997477794, 0.12470044301214056, 0.2108328420911465, 0.10187366879589188, 0.1360126190801837, 0.11765689412290814, 0.1235480840385319, 0.15690441145746137, 0.1208234077987338, 0.13509262284886914, 0.12905846757165362, 0.13135757652910784, 0.12006695619467989, 0.145145722488631, 0.13905124215172704, 0.11666845253367042, 0.027196230787516984, 0.0119410888120558, 9.999999999998899e-05, 0.0004656155592710487, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0042071629624044204, 0.024405985238078798, 0.16614037058650977, 0.07533384856498049, 0.12872656248804648, 0.06677727197705463, 0.07299166357178022, 0.05016174651675409, 0.12195785561343964, 0.07155108392892451, 0.07372944455608743, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05066659160533149, 0.04731591754454845, 0.05672435178335622, 0.07903286539880938, 0.06650686378890569, 0.0523946032475926, 0.06172918736846644, 0.046199321538309635, 0.05973996138876869, 0.3313567417816554, 0.3248042425970141, 0.36385632157336445, 0.3536844518728175, 0.344496726197423, 0.3499730869296963, 0.38360637450578916, 0.3754639317916588, 0.3954250653536826, 0.09077548392650059, 0.11266188841145963, 0.11893308139717151, 0.10225444577427167, 0.13830643175978707, 0.08623261324402742, 0.11961933311959405, 0.08681652526378825, 0.11201961522429393, 0.1633346045393238, 0.15799134931118475, 0.13241385508614767, 0.15507332955813768, 0.18155239224763964, 0.2022270758807284, 0.17582572244891892, 0.2207141303222716, 0.15288488480804752, 0.26230548269108367, 0.27364837738692793, 0.2535693197390957, 0.2677748868436767, 0.24741073306193373, 0.2686570351767532, 0.23565361270452945, 0.2050365470616915, 0.20141729043603895, 0.1961997272647562, 0.2073312284530061, 0.16170007216972027, 0.2051864532841805, 0.20978876304216565, 0.18618548982870042, 0.1885492175682747, 0.17150170937333808, 0.19656594796536542, 0.23436744264918885, 0.23705691329890588, 0.257684443188408, 0.22322200361084465, 0.2324742681476868, 0.23578682261058526, 0.23510510704691967, 0.2803250339881206, 0.21636764309703305, 0.17751133801928687, 0.17153960206573848, 0.16695922583777834, 0.18593251350932882, 0.1876404775346998, 0.17007727381782445, 0.16806073175230363, 0.1730701888696332, 0.17219679640169194, 0.1843215726127614, 0.18395074019113722, 0.15070460620315973, 0.46824012754853184, 0.1949083511366272, 0.13601106419221798, 0.14300746825916344, 0.2038981234120656, 0.16367608328048955, 0.5004543952772612, 0.20178900566056168, 0.38874441690744876, 0.19842613728855185, 0.14489241682505072, 0.20064896943019217, 0.10379682886317765, 0.1620328133457769, 0.26854823260501404, 0.20335294559304729, 0.19435192552426028, 0.1877069930255555, 0.17641370341979423, 0.19013005429092278, 0.18185975039646918, 0.18647318459826634, 0.17968531005344557, 0.1884921980709907, 0.08947214389055658, 0.1204316726687864, 0.07810852361516696, 0.11074215935811915, 0.10955705627977819, 0.09805861144350214, 0.08823020882102484, 0.09914380908722709, 0.097280735577152]}, "mutation_prompt": null}
{"id": "1a736d3a-7490-4462-9a01-8c51c667fc5a", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n            \n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (2 * (self.best_fitness - fitness[i]) / abs(self.best_fitness))\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V8", "description": "Enhanced convergence by refining mutation intensity adjustment using current fitness.", "configspace": "", "generation": 66, "fitness": 0.18608132017335427, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V8 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "12f4d742-5dd5-4572-a6ac-48af33cc6faf", "metadata": {"aucs": [0.36861269031096666, 0.33714883176241317, 0.37376866611160897, 0.32062632470672603, 0.31279280101322704, 0.33947269809163616, 0.33594454156592457, 0.3472736173076926, 0.3620960460175149, 9.999999999998899e-05, 9.999999999998899e-05, 0.022546084003313815, 0.06422642556891112, 0.05105932755259068, 0.01983456384987281, 0.019041970598937197, 0.015749685539816483, 0.018260303895653807, 0.12573254240578458, 0.12699526694151575, 0.10654590723478596, 0.10653902465656595, 0.09300152945180584, 0.10590492587744049, 0.09314088831078293, 0.10747014374284503, 0.08600630094138706, 0.09812390494594347, 0.09261345520878972, 0.06919945894120172, 0.08881479762586786, 0.0849911257437379, 0.0819669835867497, 0.07614315274505135, 0.08043599800356283, 0.08587322897173721, 0.8869793709685011, 0.9358736356275127, 0.907982097686309, 0.8724837777943314, 0.8753301127669258, 0.8724449780261487, 0.8656368755737445, 0.858976403121695, 0.8894309738202751, 0.22503764130969484, 0.21747929547164313, 0.2169914457982609, 0.2157542802120037, 0.24896981401258433, 0.1887587036907451, 0.23489008395254873, 0.22750168599108178, 0.2135426860194115, 0.253433233525576, 0.16452556841092314, 0.1969187992455943, 0.27017537369753797, 0.21412587769759395, 0.19794762381510667, 0.1638943600061593, 0.17214795797092497, 0.17402531710418767, 0.14038469865490044, 0.11130190679204821, 0.12167986201758774, 0.12284969637471599, 0.15043478030161472, 0.12994410803258327, 0.11923101075768905, 0.11604121059921635, 0.12087147422172528, 0.1273507948764394, 0.1440162164721498, 0.1045801670194092, 0.1194719343295032, 0.1354260080229036, 0.1286803378318533, 0.13497101897652497, 0.1277653447709467, 0.1310269451524173, 0.004695151336817083, 0.002234721692897068, 9.999999999998899e-05, 0.0025196835768112047, 9.999999999998899e-05, 0.002963733003572111, 9.999999999998899e-05, 0.00017045926225367491, 9.999999999998899e-05, 0.0688489061667471, 0.03150112300366659, 0.1423285938618274, 0.055633379679461914, 0.05295190418492712, 0.07407883710324992, 0.11200831401125833, 0.07612561774732407, 0.07890223667690932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045446535578191116, 0.05662800461482842, 0.061646984705948094, 0.060379899127444125, 0.05596985710058611, 0.05484259475344788, 0.05157996707102097, 0.09032476219379781, 0.05023044931224763, 0.3367586442027585, 0.33289990971726424, 0.32900676428880515, 0.3570449873710748, 0.3755450733136213, 0.3430061930085724, 0.33842686537958677, 0.3551644605689753, 0.37607769381377865, 0.11049597998503236, 0.11852362730597654, 0.10981455398476303, 0.12286030588962316, 0.13658487376886574, 0.13904729028482965, 0.11812684920253869, 0.11890543113546792, 0.09933966506721559, 0.17652057489984896, 0.2552854726930256, 0.16244750153323362, 0.18781876375018924, 0.19228534046336831, 0.2229621791874583, 0.21595841895618317, 0.2211210176616868, 0.20699417544025778, 0.23946480447281326, 0.23783534289369823, 0.1771017917742923, 0.24445083465303663, 0.2623086271148515, 0.2583374624848992, 0.21208233725606485, 0.20914713604752855, 0.21001816205730384, 0.21405735190575859, 0.21610860997954184, 0.19302039798621795, 0.16710685044359397, 0.19568671089253042, 0.1834152091285508, 0.18182968818476697, 0.1695065369037233, 0.1871630925063108, 0.23608852914227196, 0.23306592784026503, 0.25332058089949383, 0.2271484434100841, 0.22648161907979403, 0.22764305978103716, 0.23286725611589354, 0.2193301984173167, 0.24512793314081138, 0.16939265133786763, 0.17915447207340895, 0.165934757143547, 0.17532841284454093, 0.16735967536124297, 0.172522965360434, 0.17838326360728696, 0.17763865255501443, 0.16629000253568826, 0.18355275480413913, 0.18541378890456606, 0.15120948873421058, 0.5196738358832822, 0.16609218993976704, 0.12561508953448208, 0.1433279979712665, 0.12043751778246592, 0.17117906106895442, 0.45584639468889887, 0.19999249943889308, 0.36182534649998843, 0.1979887457416949, 0.14343159967283226, 0.19864857432317873, 0.15422042071013098, 0.16358468870155973, 0.26282278272730186, 0.19158065170311434, 0.18440506646417376, 0.17836060683664878, 0.17777590560849643, 0.1770956794609838, 0.18530286136335983, 0.18795668782921726, 0.18828106034803282, 0.17896966081522436, 0.09848491007585491, 0.1124759648995165, 0.09381035308000318, 0.1044405529349387, 0.0896570335486031, 0.09222540454404882, 0.09931128467093453, 0.09039328469793506, 0.08868303371149866]}, "mutation_prompt": null}
{"id": "c8e4319c-6c64-4947-989e-2765ea4fb360", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Introduced adaptive mutation intensity scaling with diversity-based normalization for improved convergence speed.", "configspace": "", "generation": 67, "fitness": 0.18858687731995702, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "12f4d742-5dd5-4572-a6ac-48af33cc6faf", "metadata": {"aucs": [0.3340174882166008, 0.3495638409812163, 0.3514152416388834, 0.3336215113014326, 0.35387709981767346, 0.3496088162039158, 0.3801344988619336, 0.37763577956571603, 0.3631012692403103, 0.02169214319296464, 0.01986155834322434, 0.011937342582965194, 0.006175052467869646, 0.060509833118256195, 0.0017951537442099097, 0.0024859232194119896, 0.022620803545551627, 9.999999999998899e-05, 0.10146683596070505, 0.1412720691362379, 0.08418963486989561, 0.11658681434969909, 0.10774960845584669, 0.11085567422500842, 0.0979589449986199, 0.09520399154000492, 0.12982501641472444, 0.07991487004887765, 0.08655923090953188, 0.06731402861951141, 0.09694834738286795, 0.08310240023096482, 0.08593695742587659, 0.0927689107115921, 0.08463552344772873, 0.08335548790693481, 0.9137927073481733, 0.9007852482986745, 0.9401495223937913, 0.8435015800598408, 0.8759769289770568, 0.8692072240150408, 0.8365043653434208, 0.8596612029622164, 0.8889851114687184, 0.2088434645089534, 0.22798028522691738, 0.21153533299012284, 0.26733760470167134, 0.28578128404821235, 0.25435811722440993, 0.2441485182852784, 0.22609492002248466, 0.21265074941831352, 0.22658053948094303, 0.14196144815438927, 0.20731638901686233, 0.20631350434183238, 0.2070907882053351, 0.21418406348867658, 0.1574828573901288, 0.17199595111357535, 0.20137610063933276, 0.13408278644164706, 0.12006649264873026, 0.10958625366281771, 0.16609843019687998, 0.10718697851065917, 0.11066881153429764, 0.1211645585447848, 0.11883890744364667, 0.12701580165810833, 0.15517424507706123, 0.14856987466221783, 0.11030681899077333, 0.12656097187981163, 0.13672675049042804, 0.12116772036747026, 0.15054632128003254, 0.15200915121256442, 0.11582456455355239, 0.006168780221247339, 0.0003923771446187052, 0.013158478968187781, 0.00010266138016545856, 9.999999999998899e-05, 0.00753120864609047, 9.999999999998899e-05, 0.011603859049520548, 0.011887143946041734, 0.16372887873157482, 0.06968523505232349, 0.16298852711982126, 0.06334712576259949, 0.07549579153455888, 0.04557878534769133, 0.12932577093789277, 0.0707093148838086, 0.07261515685901743, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05933276020190481, 0.04394450490968482, 0.05465361685761272, 0.06108861360163487, 0.06498904117391957, 0.05996557126473745, 0.07740709365572473, 0.05473066602543897, 0.048827772254182, 0.34816210564538475, 0.33657377610203854, 0.3461373764707847, 0.38240618032888674, 0.3361967246233365, 0.34333402778603295, 0.35078276309390255, 0.36918118393772814, 0.34456632212995975, 0.09203994959252637, 0.149839800167475, 0.11477195712243338, 0.1406567125354895, 0.12162816659450926, 0.098817771149181, 0.1109804740483954, 0.09104462821567993, 0.1181571037850141, 0.158614093693213, 0.18657206421942818, 0.15328603445986133, 0.13984558699039495, 0.16410969627225092, 0.20275512778691251, 0.1463008794891466, 0.16143082733003544, 0.13721645323324627, 0.25842048899315895, 0.2505592009409453, 0.2637625592475642, 0.2751546798874621, 0.23195028651510252, 0.2672338233649264, 0.21565305223450604, 0.21637493179648604, 0.19367141375968888, 0.1760108843142243, 0.20574997298393005, 0.19894869717963393, 0.19281730076045656, 0.20081286359620132, 0.18271164799758632, 0.17515606192605315, 0.17756956160310744, 0.1690654023458915, 0.24890866702038228, 0.2405837563474228, 0.21570817108453877, 0.2501484196129483, 0.225605074725585, 0.22193452997287566, 0.23450515829693386, 0.22616335436512758, 0.24842693550993422, 0.1735769868884417, 0.1712981212575232, 0.16787161230563474, 0.2073965778952821, 0.18777012208047172, 0.1685508748629, 0.17885468675402738, 0.17053495002721664, 0.17179262678219598, 0.18456209006950797, 0.1846178534728511, 0.1502123212719524, 0.42439325518744786, 0.19512838827256296, 0.13688867539003136, 0.4885472424368137, 0.2017911705058728, 0.16494862243145403, 0.5010541261529429, 0.2017471555124567, 0.36250225152990934, 0.1976579186270847, 0.14542366372116355, 0.1977297161848358, 0.10405512160958674, 0.16338686922354773, 0.2795352769264795, 0.2143152072972957, 0.17815365267922678, 0.19458179010200216, 0.19249935572566812, 0.18848123161117736, 0.1786022783964969, 0.19105403549228017, 0.20391368340856375, 0.1876747926870147, 0.09834220113387726, 0.11423824400794969, 0.0915320626528977, 0.10768030774314152, 0.09304618308961399, 0.08494739487483005, 0.08944880881489281, 0.09389321031036635, 0.0921704140306816]}, "mutation_prompt": null}
{"id": "58a0fe23-50d3-4881-a2de-b1c4b674467c", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            \n            # Modified mutation factor adjustment using sigmoid scaling\n            diversity_scale = 1 / (1 + np.exp(-10 * (avg_diversity - 0.5)))\n            self.mutation_factor = 0.55 + 0.20 * diversity_scale\n\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Enhanced mutation factor adaptation using sigmoid scaling based on population diversity to improve convergence speed.", "configspace": "", "generation": 68, "fitness": 0.1862778867588558, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "c8e4319c-6c64-4947-989e-2765ea4fb360", "metadata": {"aucs": [0.3380015058313789, 0.37504538023746925, 0.35288595338644246, 0.3436688456679048, 0.34494357931701547, 0.33221610036885385, 0.3647471103608865, 0.3569866765216313, 0.35634369749631734, 0.04051313456326866, 0.02636378482950552, 0.03696088596673386, 0.017926624299536842, 0.041652307628015084, 0.008454287220872936, 0.0014397545287998526, 0.01730063519186953, 9.999999999998899e-05, 0.10195317827369532, 0.10071947392245206, 0.11073619888124397, 0.11875585418726209, 0.10797944469068732, 0.11041740359754482, 0.11311218466532669, 0.10776855659761309, 0.09879369884580469, 0.08303088717737794, 0.08594591275292618, 0.07920098509646012, 0.11006748618294715, 0.09433952036485205, 0.07450910374137398, 0.09197371857138037, 0.08427480824196587, 0.08488662084776621, 0.8882794400119929, 0.902680099998889, 0.9290329891619316, 0.8479924671830874, 0.8436499267127314, 0.8708753068832824, 0.8398747968129816, 0.8757364280080548, 0.888940348645131, 0.250144451646255, 0.20490845766224786, 0.2133601381761644, 0.20513493212693257, 0.22758756910586886, 0.20428783655131488, 0.2409858566086207, 0.22639947359719736, 0.20548771194497784, 0.22745191988385105, 0.13378967498207583, 0.19964399408926992, 0.20901729374234135, 0.23504092909010543, 0.23422468506398075, 0.15477917042531064, 0.22453210379335276, 0.20114823559679618, 0.12965427576597066, 0.12135175985407809, 0.12145205495595834, 0.1183562799098079, 0.14722066923070254, 0.1068260884478841, 0.13537183686149545, 0.12018429136970987, 0.13028497032862174, 0.1528192710645233, 0.11047613715278859, 0.10327692337788286, 0.12293794451072104, 0.15871506557630455, 0.10896071701569943, 0.13808235162261862, 0.1214286590283753, 0.11768672208615949, 0.017766382495091104, 0.005881939069581343, 0.031624254694493925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005333279358654908, 0.006228513487844922, 0.15900903471181793, 0.08816848115559373, 0.12916261745267288, 0.06699547722244281, 0.07225172449357431, 0.04844628732607403, 0.12020301062767846, 0.07660706356180458, 0.08651850808397521, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0628280089708394, 0.06284663709347804, 0.05722917534700278, 0.07216345637941157, 0.07056837494294377, 0.06905369763020885, 0.050316724182200456, 0.0512226533364325, 0.06600355064019492, 0.3301526361134832, 0.33851116279800486, 0.3652539739328279, 0.33546521806901597, 0.32288304572194293, 0.3302543468246111, 0.35776892646763914, 0.3782122947217281, 0.34825576543014425, 0.10686921540098082, 0.13336838857977795, 0.14221948460359812, 0.131318936458924, 0.10158692432702954, 0.10800219581742931, 0.10256880618246089, 0.11080001026386621, 0.1053703213220053, 0.14898589402321882, 0.15907527697642487, 0.16995606465841573, 0.1598325533300431, 0.19010153637746063, 0.14426324158652992, 0.18186448576591907, 0.2569084364883577, 0.22192328684203044, 0.24814667931968837, 0.26936050696573444, 0.2125195972294659, 0.26345390929221246, 0.24329486711634563, 0.2575498167141097, 0.22759196265972514, 0.22681373152643014, 0.18522783704237, 0.17709478786779476, 0.2254812245601835, 0.1597511492380962, 0.22053649653443985, 0.20862732708703569, 0.1977451534332454, 0.16534632846895836, 0.1656320572922908, 0.15320418368066424, 0.21059859004663584, 0.23010102774991337, 0.2111532613251237, 0.20990391222998828, 0.23917446247391128, 0.22422732506101017, 0.2191891998852601, 0.2464719600990808, 0.21691900316391888, 0.17080872137145764, 0.17537937548035132, 0.1767494194438869, 0.17182697037202888, 0.1776852187246477, 0.17164251526510177, 0.17135184761238542, 0.1777570139020208, 0.17864015904631048, 0.18415881398745337, 0.18394279523679624, 0.15021251852476802, 0.4595391716150148, 0.19353722499552706, 0.13610639850904482, 0.14370952286456484, 0.2053185697824228, 0.16666877045545936, 0.4983487662503402, 0.2006195197215156, 0.3525263022089735, 0.19630935774735003, 0.14230269425733166, 0.1974465083619088, 0.10427926634457652, 0.16254054644854987, 0.2740093368054669, 0.18228190068296957, 0.1904351323458605, 0.19949613757358609, 0.18687218062627775, 0.1962885069979905, 0.18156421432072256, 0.18345914796422447, 0.18706370466963618, 0.1899855758529848, 0.09386606674918208, 0.11811172696928751, 0.09123182478941438, 0.1212409408424624, 0.08960624518392157, 0.09923371368943501, 0.08131574832580535, 0.09040902615707125, 0.0914392257060237]}, "mutation_prompt": null}
{"id": "87264c63-5cba-44eb-b4a7-e2305db82de4", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.985  # Adjusted decay rate\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.4 * (1 - convergence_progress)**2 + 0.11 * avg_diversity / self.dim  # Adjusted noise scaling\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.87 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])  # Adjusted momentum factor\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Introduced enhancement in noise scaling and momentum factor adjustment for improved balance between exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.188373384029047, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "c8e4319c-6c64-4947-989e-2765ea4fb360", "metadata": {"aucs": [0.37544359814862804, 0.3736321306845626, 0.38756940669307527, 0.36538894844089986, 0.35511422013716276, 0.3376548711155478, 0.35339724442437626, 0.3942983028723501, 0.337917184495815, 0.013449214420822142, 0.077448507192734, 0.022959732044545267, 0.02144543080928052, 0.04586504160658711, 0.009044746542085202, 0.009064469456065871, 0.03276619618419685, 9.999999999998899e-05, 0.08464734475927038, 0.12354254201951975, 0.11787006609239925, 0.1325184476754615, 0.10851709095078332, 0.10418999901004589, 0.08717862400560084, 0.12642864949328325, 0.08632517794360961, 0.0930389395855602, 0.07582849016630955, 0.05808390004331743, 0.09605512996006005, 0.09263179482038597, 0.0826755238818736, 0.09388414242022336, 0.08444145853822049, 0.09740589724466298, 0.8867435434271368, 0.8789561322345915, 0.9395283376894887, 0.8237351076902942, 0.8360582926615936, 0.8663909763270152, 0.8162180384726919, 0.8566340157110632, 0.8762149009207301, 0.28024354125487494, 0.22311828360548247, 0.24691556118299463, 0.23922551046031038, 0.29408194370269025, 0.20673706766898792, 0.22908607336162112, 0.2351548585889579, 0.20108132346542884, 0.3006714286133866, 0.13487228567542442, 0.2138339078510818, 0.20582669494485473, 0.25333189498229625, 0.22652865199308125, 0.1334245568808341, 0.1911469140104719, 0.2033483556243063, 0.14257062223310224, 0.10638063787383578, 0.13016007510744765, 0.14157855378901585, 0.11817357855017985, 0.1241976651695752, 0.12467001900297914, 0.11931751346059338, 0.1257359084309002, 0.17136170905011272, 0.11475319242443383, 0.1089829668468858, 0.140885537543188, 0.15393378729774232, 0.12898838231072496, 0.16656838839704746, 0.0970901094522949, 0.12727390298716268, 0.013541342626983699, 0.00672001187341098, 0.026726402743563415, 0.047469974417461924, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014228291834847973, 0.002760276860630073, 0.12396100996603832, 0.08584974310458549, 0.14850385106901598, 0.06183774968095279, 0.07201013852219185, 0.058127268802076304, 0.10764665955018315, 0.06106904331822549, 0.0791868309726278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054413808077459214, 0.06625614114876299, 0.09069049365981086, 0.07717075674737184, 0.08261896285277748, 0.08019281095996744, 0.04958825462081351, 0.05137625369461296, 0.04840025432360695, 0.3680818968158298, 0.3495921173530415, 0.3465853273959185, 0.33942345079094294, 0.34232285689110165, 0.40496653884282974, 0.36418620404129665, 0.4240183211457125, 0.3495398816519337, 0.07808961526710811, 0.09898818946494503, 0.10860347631348632, 0.1198851811642615, 0.11314363050669651, 0.13132535026477288, 0.12852791024929888, 0.10927661067483407, 0.1102492766396348, 0.23614732438798236, 0.19158580642414613, 0.14110014760384348, 0.2143787662754595, 0.2055691629500329, 0.1480599417383932, 0.16304268800729238, 0.22105988675445942, 0.1548396925390565, 0.19778878587828186, 0.26346435089690035, 0.15923140821317416, 0.25368174353436146, 0.23654881443903242, 0.22877999256755266, 0.2081225682488782, 0.20394541031195457, 0.2107011047975177, 0.19460948675246892, 0.22088535050843816, 0.15797049934580332, 0.17254325619751076, 0.20343469821310944, 0.20912573097232023, 0.18253300658010962, 0.17539864513003667, 0.1589360493211921, 0.22979903962920312, 0.2398122801712701, 0.20757898270479214, 0.22827994624607517, 0.24276015158879516, 0.2337956460469789, 0.23147252623950665, 0.22373949620414968, 0.2330763317601342, 0.1708162379712681, 0.17902617604404114, 0.17406776525042877, 0.19479669008246758, 0.17694473617999285, 0.17464684162797328, 0.17195891949515896, 0.1725117897577173, 0.16734551898320182, 0.18460285702585666, 0.18636594377158366, 0.15162288503472532, 0.45214891330144324, 0.19415442802137728, 0.11394284601223426, 0.15068700259585288, 0.20324098325127804, 0.16080418421182963, 0.4676855600318208, 0.20190493266858633, 0.4520211935810313, 0.1969232934136108, 0.14674848511480798, 0.1995952548565727, 0.1043458208041842, 0.16231728782564192, 0.2607232429945324, 0.1848714385767064, 0.18458403160459447, 0.20143203267645726, 0.18281577785703684, 0.185324785932088, 0.18946399578916095, 0.18835056314546883, 0.18268809390912077, 0.18727380457727982, 0.08284668046807642, 0.10943805747215951, 0.08568366887547185, 0.1245582669390154, 0.09336986320090346, 0.11018796005874065, 0.08536455871994864, 0.08610510590026221, 0.08344383842373704]}, "mutation_prompt": null}
{"id": "7df1feef-dc48-48b0-9c4a-428a8be43c6a", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V8_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                \n                # Introduce orthogonal mutation for more exploration\n                orthogonal_vector = np.random.normal(size=self.dim)\n                orthogonal_vector -= orthogonal_vector.dot(self.population[i]) * self.population[i] / np.linalg.norm(self.population[i])**2\n                orthogonal_vector = orthogonal_vector / np.linalg.norm(orthogonal_vector)\n                \n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise + 0.1 * orthogonal_vector, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V8_Improved", "description": "Enhanced mutation strategy using orthogonal vectors to improve diversity and exploration.", "configspace": "", "generation": 70, "fitness": 0.18439007996142312, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V8_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "c8e4319c-6c64-4947-989e-2765ea4fb360", "metadata": {"aucs": [0.34854198794845814, 0.37401978097573485, 0.3863738081080492, 0.33010404557931794, 0.3450281872114902, 0.31967813736310235, 0.3614868944175126, 0.36922650872858076, 0.3919562587707617, 0.06611904073057484, 0.07600892665563375, 0.016034153222398206, 0.038519874988272695, 0.03590386708943405, 0.02728063368351963, 0.03291116143109374, 0.011225473319517731, 9.999999999998899e-05, 0.09986692111532958, 0.11118812691217139, 0.1144235646117151, 0.1411296109326995, 0.10580521046099278, 0.08451118076789133, 0.10869081968037975, 0.11128713751786745, 0.11135156395894152, 0.08591698084601251, 0.07132773662341152, 0.06324475175258781, 0.12788458024815785, 0.06971643489454293, 0.07836542810082936, 0.09547920351319594, 0.07029209893688693, 0.08498195300641387, 0.9066001488464809, 0.8345597106358686, 0.9228775560009977, 0.8712762116221147, 0.8105427105518095, 0.8777743523480445, 0.8226387394202275, 0.8810423549267958, 0.8777694612069028, 0.24139745913945576, 0.23177116175436963, 0.2336487894293493, 0.23638205267963897, 0.21899834976281773, 0.21620967495712473, 0.23076778282105248, 0.21844888803007756, 0.20364887941489074, 0.28707740415701277, 0.1620899517754768, 0.16968341976956292, 0.2798226097264567, 0.2339971832571146, 0.21760926940240966, 0.17924752129570865, 0.2173898602345301, 0.1940737258405827, 0.11533010976762814, 0.12087939662768055, 0.11475215943647454, 0.12317923135428044, 0.1250512543967861, 0.12317797314038836, 0.13039258283722377, 0.1182141033053209, 0.12599657769850314, 0.12763618257169806, 0.11625695806898362, 0.11188234213569614, 0.12402126539303449, 0.17108387386517188, 0.12652429047922364, 0.1333290036623337, 0.12979638841795982, 0.12506968063835977, 0.006421126183112746, 0.004986611239700123, 9.999999999998899e-05, 9.999999999998899e-05, 0.022595892208469026, 0.022248546209380993, 9.999999999998899e-05, 0.003063569692683399, 9.999999999998899e-05, 0.08270567294547093, 0.12336999603475673, 0.15820965500448414, 0.06907455245103178, 0.023882936494826534, 0.04164825335694955, 0.07623462958581384, 0.06059258831878489, 0.08487908310667858, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05502696031972576, 0.09338604057330235, 0.056905223871624, 0.0598888928640412, 0.06333142756008059, 0.058201467913026717, 0.055105295591177716, 0.06306591598472855, 0.05103472527081099, 0.3748461020089938, 0.34430787614257663, 0.35348618986279357, 0.345261503060705, 0.35165518066708323, 0.33771700460894816, 0.3427411753834565, 0.36843361089329174, 0.35809699784939397, 0.09386476617008466, 0.1434005183736765, 0.1150611346445074, 0.07291864085178879, 0.10661914380814941, 0.11628962489545558, 0.09512023362614508, 0.11156088382953744, 0.11085049290620375, 0.21548153159391104, 0.15673500945936014, 0.16706221747195704, 0.14193158852070809, 0.20103387871404388, 0.17403673060919733, 0.14820109785090774, 0.18233115277500223, 0.22379576296895887, 0.24783850732867985, 0.2386312136308507, 0.2410952924611809, 0.2604096488694939, 0.20181650164421594, 0.26262662101144685, 0.2473401431960509, 0.20889101184666092, 0.25155895004347895, 0.21461364051106901, 0.19840148117432987, 0.14918254915142337, 0.20957775347501284, 0.15292350155865897, 0.2022892627038343, 0.1679177423044803, 0.14058410703523405, 0.10094137527870284, 0.22676160735544593, 0.2102406114399109, 0.2186226771177745, 0.24293466748567638, 0.2585185019549755, 0.22370924377138868, 0.22308265011538242, 0.216516633974837, 0.22627776714992665, 0.1800982895573634, 0.1835390083139209, 0.1745790732609006, 0.1754995065710795, 0.18274750078342217, 0.17007447450682156, 0.16948646049519955, 0.1817159178377552, 0.1762587370536467, 0.10706710164196032, 0.18261155486904335, 0.15099226507381935, 0.3982618084813303, 0.1942379631540796, 0.16763832554174096, 0.16725533129393966, 0.11236307879173713, 0.1610322830391544, 0.47771352975561354, 0.21095759325959407, 0.08150685920317113, 0.19689719544685724, 0.2054423751353993, 0.20384257409568374, 0.10351710900418476, 0.16423846656924912, 0.2339056377626434, 0.18117952236983947, 0.1785147621158083, 0.1953260307842064, 0.17755313822330154, 0.18371266228391003, 0.18391426771145303, 0.194593906567207, 0.19726168891662466, 0.20804373087467398, 0.10205594453432043, 0.12178239840639526, 0.09607593649060853, 0.10312899737010595, 0.08492077523751318, 0.08709905430873788, 0.08940049299760577, 0.09078766653843562, 0.10022285261261499]}, "mutation_prompt": null}
{"id": "6d9b95c4-aad0-4647-b427-75994b4dd0eb", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1 + avg_diversity / self.dim)\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Introduced adaptive learning rate scaling based on diversity to enhance convergence speed.", "configspace": "", "generation": 71, "fitness": 0.18604086916150833, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "c8e4319c-6c64-4947-989e-2765ea4fb360", "metadata": {"aucs": [0.3481972286122553, 0.3831620695512965, 0.33832366252886037, 0.32934232143116693, 0.3360753665783661, 0.3577317324340994, 0.347738110890224, 0.3660787957609406, 0.3752285843723179, 0.018047326974405253, 0.027960850374121438, 0.029851839480555142, 0.055284762903827, 0.03482251102027656, 0.00015560615131982036, 0.024498236979905608, 0.02724722550544756, 9.999999999998899e-05, 0.07606833848053318, 0.10831512069715155, 0.10222671990090115, 0.10976935228366658, 0.0963005361223972, 0.09786856046827963, 0.1010689593823405, 0.10998849804486821, 0.11390401000912753, 0.08205418134194264, 0.08339604606029694, 0.06601152968839119, 0.09771659431266722, 0.08035465604183722, 0.08725621833010955, 0.08428994677011792, 0.06896030882992987, 0.07803863463730354, 0.9030023229519226, 0.9016846362101794, 0.9326046561260808, 0.829711364806852, 0.8370771246434913, 0.8732708526522779, 0.8170869479165696, 0.8740452704094371, 0.8772771616093595, 0.2598243495950745, 0.2401835296235736, 0.18661101380997336, 0.22379079869992236, 0.2334118200116997, 0.22959111190900483, 0.24315237928821198, 0.2780827492230227, 0.20664278742484588, 0.22117084988003144, 0.11667304369136544, 0.1692629382014773, 0.2139603349335022, 0.24315185262971095, 0.2018997021004867, 0.13386742825707987, 0.19714257551897985, 0.15980996669483172, 0.13963254292012095, 0.11154780626780625, 0.11595844992562421, 0.11236735264033282, 0.1239147519172682, 0.11886795963842545, 0.1288855797664482, 0.11120024519309468, 0.1393438216434244, 0.14212940186790168, 0.12200049258328327, 0.12363574710149083, 0.14072996447267927, 0.1334726165835156, 0.12757591635604382, 0.1558989760376175, 0.10472953444412103, 0.1186847630621416, 0.0027634865167234235, 0.005334786340948305, 0.006310626674699615, 0.008936462150948898, 9.999999999998899e-05, 0.0024350410699433, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018671844803462845, 0.14844261988070406, 0.08382878044065567, 0.1367950806052186, 0.06574007853806396, 0.06592266715439343, 0.05943475190582026, 0.10949614869899416, 0.06569559455609286, 0.07519936117266879, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03703169554466712, 0.05356597476038605, 0.052939022759008525, 0.05662112003674469, 0.05183032933734433, 0.07634224108754917, 0.04928789481284035, 0.04776964213650736, 0.05453996744007872, 0.3912141381882762, 0.35100625426618415, 0.34536848194014136, 0.34106186943174643, 0.379960267305991, 0.3447561538906735, 0.40924874202701866, 0.3342020554070778, 0.3513660357565611, 0.09486529305470759, 0.10984531310258239, 0.09073980464260822, 0.14734529508343708, 0.12458642888137617, 0.1267501619667155, 0.13969799339526834, 0.11961560370314306, 0.11281934220663903, 0.16165549778338917, 0.21829555725928296, 0.1683934409263491, 0.22651800589529358, 0.17160612254605567, 0.16716959680534038, 0.21349749792688288, 0.13705138305446418, 0.17486682536718323, 0.2510067237491167, 0.2536780270903384, 0.21613642823691048, 0.25266460824497106, 0.22461675029523798, 0.25087490161730486, 0.21718551620266158, 0.19813562846785981, 0.18601745726791086, 0.1928353905242992, 0.20116343250345925, 0.1895768648316113, 0.1992357251390824, 0.1944640910297094, 0.22220617603589776, 0.182800674335292, 0.17471478614217828, 0.16581672511457712, 0.23452543581775676, 0.24066388649570647, 0.211699160206264, 0.2295098753977296, 0.23786350983890214, 0.2249475636201793, 0.25719355154673906, 0.23972648604660785, 0.25580752185953304, 0.17807785892376882, 0.18340632134132206, 0.16897595240920948, 0.20026405257991187, 0.18952776652781655, 0.1706570068678539, 0.1664762522482779, 0.17603083011758425, 0.18032823698487388, 0.18342832787972752, 0.18551137041369092, 0.15125048967918753, 0.4310059595571243, 0.19220970890977074, 0.1289987425897059, 0.16376152225793705, 0.20548836586128494, 0.15917690216278502, 0.4600335213730896, 0.201000136005559, 0.37214517687781035, 0.19656053669766926, 0.14305271456821778, 0.20130823678411347, 0.1039174297161084, 0.16308328084779622, 0.26179951980835325, 0.19873522092464002, 0.17783648876159674, 0.19432403588054525, 0.18362456023982843, 0.20587489793107805, 0.1847573706646699, 0.1980179000797172, 0.18606421360535574, 0.20412904628633854, 0.10603905097610311, 0.09713700749896725, 0.09820334997805225, 0.1068701650604944, 0.09466271891018618, 0.07442831255070925, 0.08830394022919263, 0.08559696174826692, 0.08684572580438965]}, "mutation_prompt": null}
{"id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # New diversity-based mutation control\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Enhanced diversity control coupled with refined mutation strategy for improved convergence.", "configspace": "", "generation": 72, "fitness": 0.18951121577611077, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "c8e4319c-6c64-4947-989e-2765ea4fb360", "metadata": {"aucs": [0.3323432514643295, 0.34850075524827717, 0.3544934306951768, 0.3335996332292348, 0.3544487189756905, 0.34419474986177545, 0.38769240909931135, 0.3796381016278889, 0.35953245648465426, 0.027546303283629503, 0.015071543088587713, 0.020691601775603696, 0.005524835436267472, 0.0548202681108676, 0.001831598319585459, 0.0020984547151412514, 0.021583498263200607, 9.999999999998899e-05, 0.10117990388746256, 0.13785546671421767, 0.09941955038456851, 0.1158365847478795, 0.1086746636024436, 0.11214096999576373, 0.0979043727718577, 0.09570792628562719, 0.1298350736057322, 0.07997107204796061, 0.0815933372449914, 0.06837277394644747, 0.08647911187011159, 0.08142912677043879, 0.08637784975386453, 0.09023656922648038, 0.08696646604613745, 0.08317088221007884, 0.9137927073481733, 0.9007852482986745, 0.9401495223937913, 0.8435015800598408, 0.8759769289770568, 0.8692072240150408, 0.8364914553962107, 0.8593272949152211, 0.8889851114687184, 0.22320905183184292, 0.2297270754109093, 0.25822699174563024, 0.2483037687138121, 0.24789114265558587, 0.2336113414007236, 0.2602617809153289, 0.22353582017285123, 0.21381713448570094, 0.22691824177756847, 0.14196144815438927, 0.20731638901686233, 0.20615148804231098, 0.2070774938447787, 0.19638898487316048, 0.15491626525429059, 0.1988629750867864, 0.20775488210200344, 0.13630233916426482, 0.11937986893493524, 0.11597572470627182, 0.16637045006055506, 0.12599448622480525, 0.11127053078563676, 0.12537246289566573, 0.11884456094642282, 0.12725096380105283, 0.15639765218055068, 0.1467856996578124, 0.10989014396216357, 0.1264936810765772, 0.14009665680085148, 0.12118505800021251, 0.15111675928584722, 0.13475904415441997, 0.11573971071647626, 0.0022075157304106696, 0.006911539670741096, 0.03728166977276337, 0.00010331047043132813, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01158116744703852, 0.010248086941814116, 0.16412008037140058, 0.06853180782882318, 0.16245150486349869, 0.06370294846428837, 0.07523055525828604, 0.04897784154060314, 0.12232934815146712, 0.07070719267069858, 0.08953195632484878, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014171273972873877, 9.999999999998899e-05, 0.054884254406759814, 0.0437958319516325, 0.05546896307878746, 0.06108606733638422, 0.07196752966841125, 0.05996411435434024, 0.08707371346440274, 0.05462966943737413, 0.048795189746562384, 0.3518195811120416, 0.34387134771720285, 0.3463813585110237, 0.3560480356301229, 0.33901945955474844, 0.34745586946039353, 0.3514760902916898, 0.3692849103220497, 0.3446195641505365, 0.09645596675285739, 0.149836399378942, 0.11509382929932965, 0.1370354787075605, 0.12600209226536263, 0.09881778053975998, 0.11182892592894567, 0.09104480814206817, 0.11827729290810562, 0.1580008413503714, 0.18865785863572604, 0.16993718814972703, 0.157204857017466, 0.16001528973275547, 0.2451255891922305, 0.14729210170730989, 0.16425860875562814, 0.14031988755621916, 0.26115010837721553, 0.26234363513419345, 0.24001314538764684, 0.273143123863109, 0.2696927443140029, 0.2496137855437367, 0.2152269666048584, 0.22518775295180016, 0.19548006211771585, 0.17920384693689517, 0.20755993809047735, 0.2049315708093552, 0.19667865642860305, 0.21259734864153634, 0.18525975664417438, 0.17130822235806686, 0.17831538127036528, 0.1775810005648294, 0.24890866702038228, 0.2405837563474228, 0.21570817108453877, 0.2501484196129483, 0.225605074725585, 0.22193452997287566, 0.23450515829693386, 0.22616335436512758, 0.24842693550993422, 0.17294140984316542, 0.1711129050993495, 0.17152411946098522, 0.20737000564771546, 0.1837924614993406, 0.16985921390391634, 0.17756844933511928, 0.17061927885142614, 0.17250218612632995, 0.1834676268740305, 0.18451032173776327, 0.15021230083153791, 0.41544205584939764, 0.19556547457816975, 0.1368866430517699, 0.4882212756516726, 0.20179041379339424, 0.16479068911635464, 0.5215467232279476, 0.20188815132503513, 0.3475759687694262, 0.1976503762535191, 0.14541972516604418, 0.19775034739401676, 0.1042699646843932, 0.1633843257499562, 0.2766711898210994, 0.2143152072972957, 0.17815365267922678, 0.19458179010200216, 0.19249935572566812, 0.18848123161117736, 0.1786022783964969, 0.19105403549228017, 0.20391368340856375, 0.1876747926870147, 0.09834220113387726, 0.11423824400794969, 0.0915320626528977, 0.10768030774314152, 0.09304618308961399, 0.08494739487483005, 0.08944880881489281, 0.09389321031036635, 0.0921704140306816]}, "mutation_prompt": null}
{"id": "5348c861-0cb4-45e2-901a-9cccbd846cc5", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # New diversity-based mutation control\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n            # Adaptive population size adjustment\n            if evals < self.budget / 2:\n                self.population_size = int(self.population_size * 1.05)\n                self.population_size = min(self.population_size, int(1.5 * max(4 + int(3 * np.log(self.dim)), 12)))\n                self.population = np.vstack([self.population, np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - len(self.population), self.dim))])\n                self.momentum = np.vstack([self.momentum, np.zeros((self.population_size - len(self.momentum), self.dim))])\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Refined mutation control with adaptive population size adjustment for enhanced convergence speed.", "configspace": "", "generation": 73, "fitness": 0.18951121577611077, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.3323432514643295, 0.34850075524827717, 0.3544934306951768, 0.3335996332292348, 0.3544487189756905, 0.34419474986177545, 0.38769240909931135, 0.3796381016278889, 0.35953245648465426, 0.027546303283629503, 0.015071543088587713, 0.020691601775603696, 0.005524835436267472, 0.0548202681108676, 0.001831598319585459, 0.0020984547151412514, 0.021583498263200607, 9.999999999998899e-05, 0.10117990388746256, 0.13785546671421767, 0.09941955038456851, 0.1158365847478795, 0.1086746636024436, 0.11214096999576373, 0.0979043727718577, 0.09570792628562719, 0.1298350736057322, 0.07997107204796061, 0.0815933372449914, 0.06837277394644747, 0.08647911187011159, 0.08142912677043879, 0.08637784975386453, 0.09023656922648038, 0.08696646604613745, 0.08317088221007884, 0.9137927073481733, 0.9007852482986745, 0.9401495223937913, 0.8435015800598408, 0.8759769289770568, 0.8692072240150408, 0.8364914553962107, 0.8593272949152211, 0.8889851114687184, 0.22320905183184292, 0.2297270754109093, 0.25822699174563024, 0.2483037687138121, 0.24789114265558587, 0.2336113414007236, 0.2602617809153289, 0.22353582017285123, 0.21381713448570094, 0.22691824177756847, 0.14196144815438927, 0.20731638901686233, 0.20615148804231098, 0.2070774938447787, 0.19638898487316048, 0.15491626525429059, 0.1988629750867864, 0.20775488210200344, 0.13630233916426482, 0.11937986893493524, 0.11597572470627182, 0.16637045006055506, 0.12599448622480525, 0.11127053078563676, 0.12537246289566573, 0.11884456094642282, 0.12725096380105283, 0.15639765218055068, 0.1467856996578124, 0.10989014396216357, 0.1264936810765772, 0.14009665680085148, 0.12118505800021251, 0.15111675928584722, 0.13475904415441997, 0.11573971071647626, 0.0022075157304106696, 0.006911539670741096, 0.03728166977276337, 0.00010331047043132813, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01158116744703852, 0.010248086941814116, 0.16412008037140058, 0.06853180782882318, 0.16245150486349869, 0.06370294846428837, 0.07523055525828604, 0.04897784154060314, 0.12232934815146712, 0.07070719267069858, 0.08953195632484878, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014171273972873877, 9.999999999998899e-05, 0.054884254406759814, 0.0437958319516325, 0.05546896307878746, 0.06108606733638422, 0.07196752966841125, 0.05996411435434024, 0.08707371346440274, 0.05462966943737413, 0.048795189746562384, 0.3518195811120416, 0.34387134771720285, 0.3463813585110237, 0.3560480356301229, 0.33901945955474844, 0.34745586946039353, 0.3514760902916898, 0.3692849103220497, 0.3446195641505365, 0.09645596675285739, 0.149836399378942, 0.11509382929932965, 0.1370354787075605, 0.12600209226536263, 0.09881778053975998, 0.11182892592894567, 0.09104480814206817, 0.11827729290810562, 0.1580008413503714, 0.18865785863572604, 0.16993718814972703, 0.157204857017466, 0.16001528973275547, 0.2451255891922305, 0.14729210170730989, 0.16425860875562814, 0.14031988755621916, 0.26115010837721553, 0.26234363513419345, 0.24001314538764684, 0.273143123863109, 0.2696927443140029, 0.2496137855437367, 0.2152269666048584, 0.22518775295180016, 0.19548006211771585, 0.17920384693689517, 0.20755993809047735, 0.2049315708093552, 0.19667865642860305, 0.21259734864153634, 0.18525975664417438, 0.17130822235806686, 0.17831538127036528, 0.1775810005648294, 0.24890866702038228, 0.2405837563474228, 0.21570817108453877, 0.2501484196129483, 0.225605074725585, 0.22193452997287566, 0.23450515829693386, 0.22616335436512758, 0.24842693550993422, 0.17294140984316542, 0.1711129050993495, 0.17152411946098522, 0.20737000564771546, 0.1837924614993406, 0.16985921390391634, 0.17756844933511928, 0.17061927885142614, 0.17250218612632995, 0.1834676268740305, 0.18451032173776327, 0.15021230083153791, 0.41544205584939764, 0.19556547457816975, 0.1368866430517699, 0.4882212756516726, 0.20179041379339424, 0.16479068911635464, 0.5215467232279476, 0.20188815132503513, 0.3475759687694262, 0.1976503762535191, 0.14541972516604418, 0.19775034739401676, 0.1042699646843932, 0.1633843257499562, 0.2766711898210994, 0.2143152072972957, 0.17815365267922678, 0.19458179010200216, 0.19249935572566812, 0.18848123161117736, 0.1786022783964969, 0.19105403549228017, 0.20391368340856375, 0.1876747926870147, 0.09834220113387726, 0.11423824400794969, 0.0915320626528977, 0.10768030774314152, 0.09304618308961399, 0.08494739487483005, 0.08944880881489281, 0.09389321031036635, 0.0921704140306816]}, "mutation_prompt": null}
{"id": "5d124a8f-e255-45a7-9f97-4edf448b5605", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                # Enhanced exploitation through dynamic mutation scaling\n                mutation_factor_dynamic = self.mutation_factor * (1 + 0.5 * (1 - convergence_progress))\n                mutant_vector = np.clip(a + mutation_factor_dynamic * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Enhanced exploitation through dynamic mutation scaling to improve convergence efficiency.", "configspace": "", "generation": 74, "fitness": 0.1850272527176261, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.38047345203589467, 0.33725136426731184, 0.34883306834717254, 0.34941981379732623, 0.3440508665242501, 0.34662476599819314, 0.3740702972196257, 0.3744282336946573, 0.39297023633863604, 0.014600943175559267, 0.01831334723136857, 0.009035222150415967, 0.02915067715763142, 0.01201508863570544, 0.012984402318337973, 0.003683309015281133, 0.03506640168196151, 9.999999999998899e-05, 0.10335349337393451, 0.09614812322443045, 0.09974326227584474, 0.12085738999113804, 0.10874510607898025, 0.11547421510728706, 0.14104187176627203, 0.09764924389057394, 0.11197663153841708, 0.08704316467170159, 0.07030274930931169, 0.0817718948548889, 0.09295749607133563, 0.08659252414667495, 0.09001464233193257, 0.08170519786983332, 0.08946500902320498, 0.08541210997730375, 0.8887614863770825, 0.9183792975861897, 0.9322312625225044, 0.8734191983954912, 0.837795621624487, 0.870688785360541, 0.9122447949725798, 0.9155610109709459, 0.9984745328968843, 0.2329537236289324, 0.2560115538771849, 0.20751870897565472, 0.21656672937470722, 0.26071438115790657, 0.23210419064540633, 0.2682044148586791, 0.24525515636954287, 0.20223648055956023, 0.3024102201904433, 0.11929612722514626, 0.20503391015978745, 0.26658709164035266, 0.23323278285653293, 0.2503746190826591, 0.1715640384196584, 0.21542369319224053, 0.16796364341370285, 0.09929840067404261, 0.11453036613899437, 0.12660511280732045, 0.124212505035181, 0.13076195782939903, 0.11738532005821367, 0.11752657641218844, 0.11709950850468975, 0.1225530633714359, 0.13421062757260394, 0.1221639684928707, 0.13291700427453723, 0.12424176176898216, 0.12336896750525939, 0.12920548042996016, 0.13230656633711946, 0.08146880807939783, 0.14233050161818595, 0.03421250750988436, 0.003575512800185976, 9.999999999998899e-05, 0.021249706061400864, 9.999999999998899e-05, 0.0006125023815342079, 0.0002150051598537317, 9.999999999998899e-05, 0.01631249345261454, 0.10975355157766664, 0.08843119508230735, 0.1932335491455921, 0.05528701940867653, 0.07395097665931805, 0.045364855666435, 0.09429420011729506, 0.0319528528403602, 0.12109928265794878, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058347534328207384, 0.06283295453234772, 0.06078410415322322, 0.06892201279857768, 0.03648938933272916, 0.04285078626568284, 0.050593908513883235, 0.05490188071680768, 0.05368690850644797, 0.3424711693671264, 0.3435204324435778, 0.34777647324344696, 0.36163391003401235, 0.3499370837325606, 0.32754137440841724, 0.34509561565861024, 0.35413204143447785, 0.3553526409882152, 0.09208188792488636, 0.10184201853420527, 0.0866821223254568, 0.11342969605009423, 0.09953206414724425, 0.1302506348465986, 0.14920964739075027, 0.12618951852971572, 0.12290404778573216, 0.172430493396022, 0.21433456711465115, 0.13949945440282796, 0.1945806789993697, 0.15881411636021525, 0.1295191960263875, 0.19578193415093148, 0.14743662073130603, 0.22349235343347884, 0.2667971624598232, 0.26884649670794536, 0.16148105967741888, 0.24200899246281737, 0.21816215332389943, 0.2646950441452597, 0.21521048428317913, 0.21330710961769705, 0.2401127326540372, 0.20629069721810156, 0.2277943786138079, 0.17852087259114524, 0.2000372430414683, 0.15189517915204664, 0.21485093007691736, 0.1876296338679171, 0.16754031078320664, 0.16399372105743537, 0.24581465848339634, 0.24849863735213917, 0.21044272461310576, 0.23501196317038509, 0.24640303465351987, 0.22374178474424966, 0.22145369615600163, 0.22303761288182222, 0.23021354629086366, 0.1733152372083121, 0.18135370376152826, 0.17090441323538685, 0.1819999353977435, 0.1904622379467431, 0.1730271135589444, 0.1802766300458799, 0.18175729097387305, 0.19357529287172093, 0.18453965464543642, 0.18393489701871202, 0.1503946383304987, 0.11437422259129215, 0.1952559760253335, 0.11528786447807637, 0.1336911287886824, 0.11341024317913817, 0.16623845414362204, 0.3867439855478323, 0.20380389315415304, 0.08206971509438721, 0.11133426966493187, 0.14032125669323958, 0.4224326790070222, 0.11161620534645622, 0.162838764058863, 0.30099587160507235, 0.18957792811572183, 0.18428848371228124, 0.18836731922675376, 0.1920809560535639, 0.175884847628754, 0.20980079979994393, 0.21148904302660632, 0.17757706138768203, 0.19084455493935526, 0.09047060400259865, 0.11143355754240203, 0.09811748929801689, 0.08439994244691884, 0.08970728103335801, 0.08215706768962394, 0.0878552103010336, 0.09069483832997194, 0.08924611655329096]}, "mutation_prompt": null}
{"id": "4628a3e0-1e89-45f2-8b08-218867557426", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V8_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.98  # Slight increase to promote diversity\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.02 + 0.01 * (np.exp(-evals / self.budget))  # Adjusted learning rate for better adaptation\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # New diversity-based mutation control\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V8_Improved", "description": "Utilize adaptive learning rate adjustment and refined diversity management to enhance convergence speed.", "configspace": "", "generation": 75, "fitness": 0.1844975617472022, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V8_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.35099318244680144, 0.35606178535382405, 0.34613014724303226, 0.36259100570403247, 0.3476055748568391, 0.339128078657735, 0.37574692246435504, 0.34608249636916155, 0.38607723015786577, 0.017529540922260778, 0.0032988425541800037, 0.052314022100836466, 0.06103668839602727, 0.016263587869721263, 0.012307504887424381, 0.006431479542075236, 0.0015403007402395863, 0.0008284950501441513, 0.09496038737329948, 0.09677873667171588, 0.08236827925345913, 0.14137791031339075, 0.11799148456998354, 0.09748814417094076, 0.09366402205025748, 0.11654320286468334, 0.083001706433533, 0.08233368794995055, 0.06422385103316608, 0.06731469272140733, 0.1015821751763415, 0.05959258486548347, 0.09094180419201947, 0.08604661583640794, 0.07126260882108348, 0.06944514109953348, 0.8867797264294659, 0.8993707326393652, 0.9114869188648779, 0.8720224677135439, 0.8748461644518669, 0.8694197879896625, 0.817942431879433, 0.8583185287865541, 0.8875049768396853, 0.2776437141856044, 0.2246424470097772, 0.22165608910441892, 0.26390762806943124, 0.28286940772758284, 0.21701925628655638, 0.24085550182532545, 0.22725300189531017, 0.2445689308140192, 0.22196477401625447, 0.1282527479621025, 0.21851351133464147, 0.20318179578352202, 0.20700245452773125, 0.22675036548978666, 0.14833909399321, 0.18470664451468832, 0.16685406590679963, 0.1480335674487815, 0.10823020515702264, 0.11695544415806547, 0.10413314567525833, 0.11083019591558096, 0.08173916230002976, 0.13661109423338735, 0.12207804566016234, 0.1278716893220897, 0.1541936593091937, 0.11456966097013555, 0.09490277423966165, 0.12666056095890088, 0.1359304619355547, 0.11758187381697027, 0.13661269332920478, 0.14624359971576373, 0.11437506071643433, 9.999999999998899e-05, 0.016276394594408328, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021861275183926443, 0.019331012937363057, 9.999999999998899e-05, 0.005530557726285745, 0.009602728890684142, 0.16297067634897178, 0.07344283282939601, 0.13543216627373, 0.07127193220827188, 0.0858116171893416, 0.04887162772846221, 0.11993419883018885, 0.08113967323709692, 0.08937562597648174, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04143756380324426, 0.04302646763540219, 0.07332263646289683, 0.06380697461533869, 0.053751571665072384, 0.06443513419921765, 0.0624650582659344, 0.04968668161921852, 0.05205952495900368, 0.35027780786572615, 0.33636138041907826, 0.3518072782608087, 0.34908322766974453, 0.36541650352324695, 0.329524551605741, 0.35652933452981195, 0.4120436134597004, 0.34021064044705895, 0.08322005840594171, 0.10818883346433938, 0.10064355481633047, 0.10919163460958903, 0.10607856173775121, 0.11214553267211491, 0.10760118236825145, 0.1091143768736118, 0.08972539992875028, 0.21246313399585548, 0.1144811052560335, 0.14401467887748787, 0.23128920063114533, 0.18454750204445958, 0.15889237204092532, 0.174159752647694, 0.15959411023535885, 0.19170131578391214, 0.27976512369412965, 0.25833761443044456, 0.21275044668596688, 0.2588185116779882, 0.2444890750594707, 0.25516549829107005, 0.20711828472905336, 0.21949366570107964, 0.21817866553589715, 0.17598136926381758, 0.21865477332510241, 0.1912987636176331, 0.19955571713798392, 0.16547154575136735, 0.20200544199470327, 0.1784632130888134, 0.17349045718508804, 0.11577612367664991, 0.2538145527670955, 0.23049262340573806, 0.2222520279945165, 0.21095318477560931, 0.20924383989949502, 0.23915979220916228, 0.19567968472341157, 0.23391099798317116, 0.21634931713367955, 0.17159303845616902, 0.16986123122055452, 0.17165517401262165, 0.17151155922735672, 0.18727808190047157, 0.17472042725989212, 0.17533067479839626, 0.17376053582124873, 0.1737901122963884, 0.18472977818074465, 0.18551576901282485, 0.15115043900264502, 0.5019353169855132, 0.1912000188710684, 0.12124853497924581, 0.14503701319668105, 0.11369235959189339, 0.16363806239553214, 0.4664538205928802, 0.19987880036732097, 0.36852014824740775, 0.19938217310933093, 0.14083154676890086, 0.19721215880414888, 0.10433402641802025, 0.16333836197029594, 0.2687333327086978, 0.1987470708816328, 0.1751599746360416, 0.17771295808775245, 0.18424897379136917, 0.1862470976661813, 0.1911648446742924, 0.19152586086133205, 0.21262302935041533, 0.19400352954619826, 0.09162771120631041, 0.09269395135895375, 0.09458975129977154, 0.10812205894612492, 0.09467396987485188, 0.08846691225874459, 0.08621069465503495, 0.09089762498599119, 0.07486910407878855]}, "mutation_prompt": null}
{"id": "04d9f13e-1bdc-4777-8549-d6dd0db79c33", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.98  # Reduced decay rate\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor * (1 - convergence_progress)\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n        \n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Enhanced mutation factor adaptation and dynamic crossover adjustment for improved convergence.", "configspace": "", "generation": 76, "fitness": 0.18249011411871374, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.3468666020241026, 0.41244149478735326, 0.3643414489086585, 0.3549257779078848, 0.34065639697838634, 0.33388457627145096, 0.35224293097253234, 0.37192524025766605, 0.3522539313272678, 0.033148525826113606, 0.054728589318528975, 0.03244858875788781, 0.014735680756672087, 0.04754741014104602, 0.010093916102758893, 0.013758780227731804, 0.00014091659462578399, 9.999999999998899e-05, 0.10012602324373687, 0.12206288204048232, 0.10972216256218015, 0.12336514054547132, 0.10724127190084476, 0.12636695093274575, 0.079295902660106, 0.0987279099330306, 0.08447147401615185, 0.08644457653762105, 0.08760949279175967, 0.08459726164205661, 0.09241829572853455, 0.08083645043861065, 0.08405402622956515, 0.08255245212012163, 0.07883568091528759, 0.07655674739577212, 0.888530927057885, 0.8380955714294249, 0.927646203998362, 0.8873698736600794, 0.8536157489404297, 0.8229463558799661, 0.7490813812458186, 0.8366409134325725, 0.7983362492395192, 0.20131109139815673, 0.1962244449135353, 0.28052616035179834, 0.2486165726245596, 0.23885090358084748, 0.25845287757749535, 0.21059315360107844, 0.2121451846398542, 0.21777028974425294, 0.23671747355045203, 0.13717682600668646, 0.15162915216779116, 0.3124069787142538, 0.23186148674493856, 0.24670786571895464, 0.18321229896237035, 0.15964690239254453, 0.20625347922602888, 0.14184569694667093, 0.10717558090322932, 0.12774545537572302, 0.11959218635050417, 0.10361575171681925, 0.09886357112571109, 0.14470188359221048, 0.1226359258189379, 0.13839223261600164, 0.15055076600161488, 0.11355256205672226, 0.11976694977063906, 0.11085165924132467, 0.15613210746451822, 0.11960166029950692, 0.12953547277438304, 0.10352996077526477, 0.12857540976441217, 9.999999999998899e-05, 0.002749213363771208, 0.03849029808961002, 0.01070462883005241, 9.999999999998899e-05, 0.012533338128327909, 0.000391321432383851, 9.999999999998899e-05, 9.999999999998899e-05, 0.11990687595428795, 0.07905867818831991, 0.12052180576096838, 0.04758353872030041, 0.05475294123897967, 0.02897093274848217, 0.14354055427147705, 0.06116197886041541, 0.1272194830337121, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04163437591651453, 0.0590692568985256, 0.07537273821558121, 0.06578145739009866, 0.06589756372938149, 0.06312651366389621, 0.05397152329510846, 0.05110339475235015, 0.050212722410089006, 0.3388056622498363, 0.36857943860672937, 0.3445909187559978, 0.3352319792040592, 0.36186405623807827, 0.3412590502723374, 0.35445119846476014, 0.3443580875146751, 0.3568180027152955, 0.11916661415879204, 0.12106606918661533, 0.09666269873652089, 0.09158771784850561, 0.13022234340916894, 0.10594745514718018, 0.12023967514040357, 0.11212002654211395, 0.10783905040878783, 0.25079001713187155, 0.13984981696379328, 0.1415336306970637, 0.18225956269817367, 0.18051484399246998, 0.15924814372603102, 0.16118149511365898, 0.16030094808094564, 0.17749216224506403, 0.25952513089934304, 0.25009529861433766, 0.25039352892037525, 0.2195330472541226, 0.23175465772581194, 0.26557882304836455, 0.2048333657271747, 0.20336133423856972, 0.2570822730821928, 0.1546487226070119, 0.2055772139102403, 0.20190093011782306, 0.19229208442284063, 0.1858913557535612, 0.21064492459447615, 0.18172696366371355, 0.15484010642377033, 0.19987853814364576, 0.2352290229930729, 0.2301910730770238, 0.20595744136484717, 0.21945411274515503, 0.24098990329448156, 0.24350973376705376, 0.22320391215628665, 0.22938281683852446, 0.22305393861622802, 0.16885082767499082, 0.16991009021642134, 0.16916942107261135, 0.1744105601319288, 0.1720032973169211, 0.17232654091241295, 0.17613326780557748, 0.1732915773087842, 0.1724047944993139, 0.18227897956413575, 0.18447897028870408, 0.1510819735274812, 0.17238976995609046, 0.19493810223611963, 0.13065413721055263, 0.16403338542445034, 0.1136740965882913, 0.16033272481897076, 0.4197377905729438, 0.19494916660906725, 0.3483654594812491, 0.2043985851254957, 0.2057172475328265, 0.19880795832749665, 0.10347265032255759, 0.09239077898291326, 0.25352403803236767, 0.18616038566823145, 0.18000115175340292, 0.18309829845223602, 0.1943085721251041, 0.17564572869871953, 0.17288378107659896, 0.18089736526978717, 0.19725456163976618, 0.1748744228272362, 0.10815453807504583, 0.10277669013718771, 0.08873300227312375, 0.11458876541260232, 0.0918693682070012, 0.0899299592351206, 0.09226467728808241, 0.09785149260951564, 0.09272293502252871]}, "mutation_prompt": null}
{"id": "d24ee503-d90f-4783-9abb-d19b49ca3ee4", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            diversity_variance = np.var([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim) + diversity_variance / self.dim\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # New diversity-based mutation control\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Introducing adaptive mutation intensity scaling based on diversity variance to enhance convergence speed.", "configspace": "", "generation": 77, "fitness": 0.18721982815326002, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.35142850072700726, 0.3589680829322738, 0.3412147781034387, 0.3286623321887766, 0.3234241271672602, 0.3359227066870778, 0.37605332711061945, 0.35559831443834267, 0.43923352486812084, 0.0028869967532931806, 0.054279075657672315, 0.021231084394243815, 0.01388717076220003, 0.010298454255061595, 0.01118721272331169, 9.999999999998899e-05, 0.03930014771854806, 9.999999999998899e-05, 0.12783111285559845, 0.11997791237854549, 0.1183849938988053, 0.13052029849724844, 0.10413246214981631, 0.0998061485991939, 0.09881931931570676, 0.07703048264337264, 0.09186558173978265, 0.08459406942613734, 0.08902548290904833, 0.08849178380546852, 0.10186771628855273, 0.07454431415671259, 0.08879506175785934, 0.09479195920427408, 0.06711579300336756, 0.08076495149693907, 0.8858206990943871, 0.9207543285756725, 0.9101852284423981, 0.8283499411809576, 0.8410580825765148, 0.871112610362137, 0.838276536187049, 0.8580250683897052, 0.9987280955612895, 0.21912497303257583, 0.20247086536699066, 0.23184237203086822, 0.23040183573664108, 0.2639898078292997, 0.23976014629287812, 0.22416840735412213, 0.2656342654405718, 0.21170758831502912, 0.23498344894836398, 0.13264759162130468, 0.19675546010946077, 0.2192323385950139, 0.2730535006432816, 0.2591112397378602, 0.1600180902803593, 0.21627999928145902, 0.15876623638375387, 0.14016622090705, 0.10999098930296403, 0.1315730391298544, 0.1305749097013037, 0.06814254118879037, 0.1063050748756188, 0.12645968124815132, 0.11266297469028796, 0.12025411737838076, 0.13393569436030373, 0.12280151496722247, 0.1622565676553358, 0.11849138996564812, 0.16291044981747038, 0.12406572243795877, 0.14019353472966667, 0.11307874978971866, 0.12435335477472054, 0.0005917573288292122, 0.0003413725344569851, 0.02136912120447465, 0.009634937463499749, 0.003852685891359231, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006059532970982384, 0.07103529823019394, 0.08578041713655715, 0.1760661135343764, 0.07776021259422483, 0.06542182844938338, 0.0514147154848037, 0.10844532413682395, 0.07644610704722998, 0.11331806828294866, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051096931067982077, 0.051000010005945895, 0.052590758128501336, 0.0639750370884602, 0.05418697546146922, 0.08056489705631409, 0.05065752992258876, 0.05256784933246328, 0.06090305938930107, 0.3376675401647975, 0.35569071709722666, 0.3281972478052856, 0.34394352986417587, 0.3387047152335786, 0.3443257512914625, 0.3388394882972746, 0.34343120944262295, 0.3403416750218131, 0.09216967955755495, 0.11613906720661671, 0.1117319073745755, 0.11482495605046317, 0.13334514886785387, 0.10416786115110988, 0.11301625956315497, 0.09687979379864065, 0.1268874659020568, 0.1875553190389576, 0.13263277337773993, 0.21887091848986062, 0.15053511045297363, 0.2503914254508487, 0.1553002844089889, 0.18658929354044274, 0.14878240582911562, 0.1794902168472503, 0.25217120966083173, 0.25446965274378675, 0.24552164004293486, 0.2643561605091951, 0.21820870540732518, 0.2565270256020876, 0.2148308516404276, 0.18974706098146776, 0.22045473591235198, 0.19470118253124247, 0.20825395952399794, 0.15963333082778897, 0.22211466588418616, 0.1721559865799216, 0.21045019877942428, 0.17294030187995157, 0.1587760708554008, 0.1715805753575943, 0.22156879382454975, 0.24054788078537948, 0.21672884745832144, 0.23435392606908767, 0.22463580948098827, 0.23044369202074189, 0.2053712602226868, 0.2220502107871427, 0.2179499455210886, 0.17722532745494013, 0.16975651809043046, 0.17579297441508535, 0.16835273270715823, 0.17915652071495947, 0.1725661115541538, 0.18099260479305135, 0.17092334191841163, 0.1729345154733959, 0.18659530605385088, 0.18360454851221075, 0.14414681672391694, 0.41016646652514976, 0.19142907170305512, 0.454766959442203, 0.165814038708181, 0.11366474906203328, 0.15912983774522949, 0.4689223849716524, 0.2069717134240059, 0.45036472999629795, 0.19706564146582095, 0.13825197853150095, 0.20220693800588752, 0.1043260375153845, 0.16352463607032586, 0.28482887660225964, 0.17983375776656207, 0.1836500251408133, 0.18687862367555352, 0.19232614890590272, 0.19297388240447122, 0.1934984215647365, 0.18285977645092144, 0.17610724530888, 0.17988104844632746, 0.09301548118617742, 0.09474665457937659, 0.09221591723126565, 0.127524863335997, 0.0930686294908255, 0.10027648050572391, 0.08559217142014075, 0.08977332740548138, 0.08189250144087001]}, "mutation_prompt": null}
{"id": "fda1389f-911e-4925-8aff-a1979a950051", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            fitness_variance = np.var(fitness) if np.var(fitness) > 0 else 1e-6\n            mutation_intensity_scaling = 1 + np.sqrt(fitness_variance)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = mutation_intensity_scaling * (1 + (evals / self.budget) * (1 - avg_diversity / self.dim))\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Introduced adaptive mutation intensity scaling based on fitness variance to enhance convergence speed with minimal changes.", "configspace": "", "generation": 78, "fitness": 0.18282451578834671, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.3351239875277754, 0.37288824930992737, 0.3388133914262529, 0.37243105143264343, 0.33537295733835826, 0.33623905215392846, 0.3504871024384233, 0.3459771497684371, 0.33998953237251006, 0.013538607968225147, 0.010668412079451128, 0.004018092272794593, 0.020144450937394365, 0.03594006708413311, 9.999999999998899e-05, 0.0014795169458716728, 0.02228778430406475, 0.03164572491738704, 0.09638688506904947, 0.11626246792935291, 0.1566768160122769, 0.11430197145902743, 0.105814468044238, 0.0925970994172376, 0.09097564019961324, 0.0943405392491895, 0.12885148850023675, 0.0753841257437794, 0.07588770554344337, 0.08031206888064646, 0.09732027768448115, 0.06564082046311559, 0.08696503775002218, 0.08617192455444378, 0.07630520948592989, 0.08368712991406357, 0.9965150997197959, 0.9980607638425784, 0.9316154696283695, 0.9414071991183867, 0.8844682340961546, 0.9018543262269026, 0.8120351989100492, 0.8449316105411473, 0.9987280955612895, 0.209679358715415, 0.19598120959297516, 0.17937404081210584, 0.22070950011122425, 0.2300935993453992, 0.22587230578059825, 0.2575416526131499, 0.2207569722092998, 0.18627995666062502, 0.21078524019865397, 0.13767042588772016, 0.19613282149071465, 0.25746129522943506, 0.19773312013366529, 0.24917197531078505, 0.1564029638099077, 0.2964931687092106, 0.2192022240365532, 0.13659315288226115, 0.11008390511649901, 0.11276035618555835, 0.12503789452794134, 0.12681644620284227, 0.11764764453028087, 0.12005045792857127, 0.10605550493807936, 0.12162098553766232, 0.1262238872355922, 0.11983546888674668, 0.11232851910747554, 0.13105074980320208, 0.16314831889967774, 0.10910852525082959, 0.14249207955046783, 0.12315134784382442, 0.11528575426064869, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005700381868168236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00046642315697353887, 0.011354404367218018, 0.11202704622039017, 0.07478194965688367, 0.1284064496477444, 0.06747025655400596, 0.05837611994184899, 0.05688994469891007, 0.043893874136477495, 0.03862303295479852, 0.08063925709275432, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05395147384188037, 0.05862733366868511, 0.06637371730252728, 0.05702397334016385, 0.046889579241339185, 0.08704271971161304, 0.05948608662245536, 0.05820873675251437, 0.07256229494080613, 0.3622279838378081, 0.3228750371516155, 0.33465178947131324, 0.3439042902943382, 0.3355335761474164, 0.3298722965157619, 0.37398972317197665, 0.3471773175861995, 0.3838812965919469, 0.10606740586070951, 0.14717630069369225, 0.10167517617447452, 0.11525435168737563, 0.11672480065270341, 0.1139491621933747, 0.1040098906716892, 0.11346839104384632, 0.09232902794733178, 0.12616339968375867, 0.13872154134719894, 0.14035757395126858, 0.16262765708477178, 0.17000804333987796, 0.18015643805994985, 0.16130258653853946, 0.13135240077858312, 0.13703416718640515, 0.25131172541878377, 0.25059953404696755, 0.24391624442982973, 0.24736145826959977, 0.2065493340135801, 0.2717872660940527, 0.21508205014923443, 0.21368875103950236, 0.21056787959312295, 0.17363646976399105, 0.18051886253600058, 0.2046965575069961, 0.17530450053228308, 0.16277951622364084, 0.20993593351944517, 0.18397643676626352, 0.1770967485379208, 0.1450868839456101, 0.22097965743798642, 0.23125770184329142, 0.211293769084009, 0.19884161063030648, 0.2519165909892964, 0.2100557509390032, 0.22439873199332183, 0.21776514485568954, 0.2185382737375393, 0.17623514050697886, 0.16648890803718075, 0.16441769164558295, 0.17567050747621726, 0.1793975417404723, 0.16632502933964421, 0.1689612917244554, 0.1699414783952249, 0.18553092541795824, 0.1829602101481711, 0.18117590675216233, 0.15234032088241423, 0.17197185641309587, 0.1932139649346334, 0.1139167751931156, 0.1639763745035696, 0.11319827664374893, 0.16156291893356844, 0.4644555484730153, 0.2065156249660437, 0.09435888486724797, 0.19428082146083647, 0.19826733578222244, 0.1965425961206071, 0.38731339007775933, 0.16205527038873968, 0.24304656775590994, 0.18527188494716207, 0.1810863798482033, 0.17839844348900857, 0.18214092535091464, 0.18334696939004758, 0.1901667745707306, 0.18238650782336452, 0.17988287364135813, 0.18149595915106265, 0.09136164711790862, 0.14507057233124832, 0.08866275536636037, 0.11071826147556163, 0.09765951768379943, 0.08868138197660269, 0.08671701618668326, 0.09119170925450326, 0.10272897366044531]}, "mutation_prompt": null}
{"id": "b77fe7d6-0d60-485d-8588-d38503c34c71", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_Scaled:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor = 0.5 + 0.5 * (1 - convergence_progress)  # Adjust mutation factor dynamically\n            \n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_Scaled", "description": "Introduce adaptive mutation scaling based on convergence progression for improved exploration-exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.18511793080260125, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_Scaled got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.35785868475926597, 0.3496930622517742, 0.341341201238202, 0.3690867476374491, 0.324468850005858, 0.3483761679903761, 0.357098319917162, 0.3494318208044159, 0.37468040204266695, 0.041049464583776674, 0.03539476390926777, 0.04326263824679555, 0.018148633151911064, 0.09595360114430529, 0.005223902805571945, 0.013903363240125866, 0.04865302260162496, 9.999999999998899e-05, 0.09878751597249591, 0.11886213284620228, 0.10898206202066996, 0.12992613472854575, 0.11183260725504496, 0.11239493414298418, 0.09765006622422767, 0.10021820243055868, 0.11281210100467998, 0.08021028564911392, 0.07940112510418584, 0.07300760234896497, 0.09636545274453456, 0.07892060557235347, 0.08615736938639385, 0.10200502591176974, 0.08639329296773268, 0.0905825236764014, 0.8890972948547895, 0.9204425462130945, 0.9290489163607226, 0.8425172881432896, 0.8364210612078515, 0.870260584570899, 0.8682468007418532, 0.8957348581654432, 0.8913504890902558, 0.23205393147417874, 0.22371718260077622, 0.19939375211336896, 0.2539018577429055, 0.2173921683373765, 0.2241682837120751, 0.19807229760217238, 0.23611533156436348, 0.20182403125151482, 0.2831432124856279, 0.12428380360069236, 0.1950244755412074, 0.24271607244245308, 0.2607644779315412, 0.268205218376692, 0.1759226535475953, 0.22138262445348966, 0.16532337588013069, 0.14574485244110424, 0.12128469009296927, 0.12426750354340532, 0.10010141676127737, 0.14125772145011029, 0.10172425743151525, 0.11935875991847367, 0.13156124693136384, 0.12451518329210698, 0.13284995924472676, 0.10972220360704266, 0.12957372932998645, 0.14412248671742323, 0.1386587083893055, 0.11633918366225116, 0.13547086266360908, 0.10218745732873535, 0.1173719049750549, 0.004336658443524377, 0.006815648487815795, 0.047083180521711565, 0.01181144408268242, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013830014187625417, 0.12404654826945227, 0.07263801850512464, 0.21106843444431755, 0.06561566539493013, 0.08763147154659578, 0.04569434598471034, 0.08317169707119387, 0.07548321862635199, 0.12958593109219652, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07917807965486068, 9.999999999998899e-05, 0.056279700275851274, 0.053783748517501784, 0.05131685920902784, 0.07802361739561492, 0.03920711695787382, 0.06252027260484772, 0.05154470556689961, 0.07372072510749672, 0.04728134358965219, 0.3403036007629414, 0.33417636765249226, 0.3370063192150521, 0.3318083609836291, 0.3427571384676046, 0.3229284925574545, 0.35212588821438506, 0.3558962635213899, 0.4023622613872193, 0.08634228985120884, 0.09693408664890646, 0.08478586298928059, 0.10244022344994641, 0.10191617155536947, 0.1231967250476167, 0.10574375401638514, 0.09638741604022438, 0.12968128946347957, 0.1424962857928378, 0.15820136839839638, 0.14926116445940552, 0.1549497589618848, 0.19051808269842252, 0.19791297325171675, 0.14370188939015804, 0.1736943040485125, 0.21478308259234513, 0.24987137694967898, 0.247768772381029, 0.26171777954320163, 0.2808557800736746, 0.2555078317736783, 0.2792452482064588, 0.21774040997520394, 0.2061289823364557, 0.24938914552062075, 0.18183050588015048, 0.1985831456632714, 0.20097025877311536, 0.19070148518837204, 0.1581180290299028, 0.2466009416704774, 0.1872201149175039, 0.1646692365454061, 0.16455507391676416, 0.2321258078229942, 0.23960728301154688, 0.22123960929903397, 0.23260371399849322, 0.23815794271136703, 0.21452860170798993, 0.21109521170150947, 0.21683606879009165, 0.2139203392015746, 0.18676269553921088, 0.17485668463487947, 0.1732347487509005, 0.17436472182888318, 0.17395727885162382, 0.17099087578352123, 0.17819484575311983, 0.1697033559727532, 0.17378867921498564, 0.18566337520355392, 0.18652611512947126, 0.1507254716735732, 0.113875048284926, 0.19229985689756846, 0.11364921922042559, 0.14493011274426193, 0.1130688237635541, 0.16302619292039056, 0.41580980313416516, 0.20359562136419596, 0.41452549709825826, 0.19524912736454636, 0.14210562073409816, 0.1437889211764254, 0.10417783955371884, 0.16472187774194935, 0.2942960433631606, 0.18537215739424684, 0.19965348032374564, 0.18344153992186618, 0.18815292334035616, 0.18545920286281092, 0.1739237976528346, 0.1799707015688593, 0.17006444938069276, 0.20334526287775023, 0.0924352352710972, 0.1289072785227081, 0.0831094124991123, 0.11363426248813158, 0.08825961604060117, 0.09442004642568613, 0.07890443298067729, 0.0804411364670723, 0.09045069599557831]}, "mutation_prompt": null}
{"id": "7d73ce2e-8760-4b70-a760-bfd391bfcfb6", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            fitness_variance = np.var(fitness)\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim) * (1 + fitness_variance)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # New diversity-based mutation control\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Introduces dynamic adaptation of mutation intensity based on fitness variance for improved convergence speed.", "configspace": "", "generation": 80, "fitness": 0.18107827424459555, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.3573160935980244, 0.34711986874431633, 0.36224248439748885, 0.3396450352832585, 0.3509165608163489, 0.32952814253222507, 0.37219145058343805, 0.34753441516796946, 0.35750167753580786, 9.999999999998899e-05, 0.016199727830511823, 9.999999999998899e-05, 0.01609008791733635, 0.014870622053395843, 0.004755285945212795, 0.011459683169970258, 0.014177688662271093, 0.05575918029589688, 0.10215151560948088, 0.1342586749533089, 0.12364084577160961, 0.1309611680503242, 0.09815305721042655, 0.0972400722377662, 0.09734541560839971, 0.09659090715540575, 0.14121824252638493, 0.09401155577400078, 0.0666489875647609, 0.06484621826194092, 0.0944947118906383, 0.08246673320304376, 0.07703919623254984, 0.08787189101786075, 0.07814807088981068, 0.07199583824706202, 0.8884610802418991, 0.9035319462707982, 0.9284271129497097, 0.8705090853780111, 0.8776689169150991, 0.8700143400509969, 0.8659072099415028, 0.8766772298068863, 0.8875567482902373, 0.22667261832796304, 0.2011208284600925, 0.18058587351254718, 0.22759835130027573, 0.2135411594848612, 0.21188069165121282, 0.19397884905003537, 0.2246008847273303, 0.1950155092235495, 0.22902270873891473, 0.14732864823121672, 0.19361706498364661, 0.25406031799823237, 0.22425585985136332, 0.25422348415501106, 0.18398657252951744, 0.2479103993512063, 0.15797100397709307, 0.13874522907232134, 0.10910438189440241, 0.11263648912745461, 0.13091259009260425, 0.11556430686115149, 0.13314748509727292, 0.12455607120458967, 0.1191299214476107, 0.11967313679385316, 0.1502146632273862, 0.12960469236783534, 0.10838615760026182, 0.12716698957854167, 0.1300231405818516, 0.11131042199593522, 0.12151315850294064, 0.14104017794703172, 0.11839514058625644, 9.999999999998899e-05, 9.999999999998899e-05, 0.010724820622981523, 0.01730595309305083, 0.0005389970297410285, 0.021095916009511884, 9.999999999998899e-05, 9.999999999998899e-05, 0.007321725629668041, 0.13660713375257405, 0.04616110468652046, 0.15694488751023605, 0.05987522547834745, 0.0650539602505632, 0.09037286574703396, 0.08359857956023986, 0.0916867312346511, 0.05832044464325137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042826156376422286, 0.0812951786521875, 0.0668454638431264, 0.059742169676102796, 0.051425742014595155, 0.07033523128317465, 0.06901379320109591, 0.10248797630414552, 0.05403111773114999, 0.4028467681893849, 0.33862301522840055, 0.3436672033125948, 0.33745634353319853, 0.33501087501510196, 0.32719486498232586, 0.3674247404111668, 0.34850636644235733, 0.3569562219834477, 0.0892256947811294, 0.11427704952797813, 0.07664450007915946, 0.12792381920355655, 0.10199643519718449, 0.11934770451446364, 0.09972099232822762, 0.08822436654356935, 0.09755497425748327, 0.12731823638448836, 0.1430855449580486, 0.12866939252546128, 0.14378606502011948, 0.15107205494445775, 0.1315626547929749, 0.1465745400811176, 0.16813966142145942, 0.14527897881088558, 0.2580366748018529, 0.2611533178243839, 0.16077499567421927, 0.2629054861674527, 0.2508864632355313, 0.2461939942096646, 0.20469148726748176, 0.22800726826615836, 0.1982990922487048, 0.17872609754281965, 0.16910026442929194, 0.1889421068606777, 0.17134984927491348, 0.14816210056819712, 0.20136650158792724, 0.17143114141225946, 0.17721484753246164, 0.15917220143543942, 0.21570212572391612, 0.2391328180438712, 0.2249552238700704, 0.22916699281951836, 0.246925736259884, 0.21983194362666292, 0.23464223619124047, 0.2376609557371001, 0.21630860403736318, 0.16711481215543555, 0.1742060256568293, 0.16952706416871255, 0.18772499592729597, 0.1825614225642963, 0.16617895726120135, 0.16456037739488294, 0.16557287171477442, 0.1741448360472867, 0.18320083057567615, 0.1823848459555526, 0.15228443555423454, 0.13827828359894534, 0.19369950794282065, 0.11370235827832564, 0.1530624404273071, 0.12096689133252025, 0.1623724917354693, 0.47610159097708205, 0.20105860825479827, 0.35873392358370515, 0.2043012129861378, 0.14441285428377337, 0.19998741051170632, 0.10386219762403848, 0.1653053514272247, 0.27524403092583916, 0.17884596731724922, 0.18068100450182645, 0.1789093850351937, 0.1910311857332242, 0.18896586772333335, 0.17843656799397345, 0.1942919137195599, 0.17808221803178836, 0.18786986881888357, 0.09286024318332675, 0.09708586105609684, 0.08479857350615583, 0.11911954027815774, 0.09573590007787658, 0.08656303544690291, 0.09313104654426585, 0.0986574888365378, 0.08971041859648243]}, "mutation_prompt": null}
{"id": "f2d5a12c-c95a-44a6-92da-1e09084058b8", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            local_variance_scale = np.var(self.population, axis=0) / (self.upper_bound - self.lower_bound)\n            mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim) * (1 + 0.5 * local_variance_scale.mean())\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Integrate adaptive mutation intensity scaling based on local population variance to refine search precision.  ", "configspace": "", "generation": 81, "fitness": 0.18860676381517616, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.3323382075270208, 0.34857819722923333, 0.35456482138346634, 0.3335509429458141, 0.3547020481348069, 0.3406257657135998, 0.391367484295686, 0.379652598707685, 0.35950901170862626, 0.027212958489143402, 0.014937573619055566, 0.020854778757390835, 0.0061860478360282745, 0.05545962329418763, 0.0018308034646610238, 0.0021128516078814386, 0.02053993707007118, 9.999999999998899e-05, 0.10106917902554158, 0.1375999175646151, 0.09935894552061508, 0.1136298201846121, 0.10764071311051793, 0.09795155866654637, 0.09782396907978941, 0.09594283105990109, 0.0977797235003407, 0.09072345299988904, 0.0856922840393467, 0.06836171601270358, 0.08607329934701502, 0.08141750182909668, 0.08637176544669078, 0.09013985806820746, 0.08785899099599026, 0.07798901885592313, 0.9137935550315957, 0.9007851942920257, 0.9401493377811527, 0.8434995431183074, 0.8759796190002603, 0.8692069485945624, 0.8376267863467367, 0.8593242498073912, 0.8889838780840427, 0.22322189679088, 0.2389414804323725, 0.2583109524879852, 0.24845419144154834, 0.2485672847466467, 0.23166995225448395, 0.2603035158778796, 0.22353061258619344, 0.2138479575575254, 0.22691824177756847, 0.14196144815438927, 0.20731638901686233, 0.20615148804231098, 0.20743804081132777, 0.1974411765790225, 0.15491626525429059, 0.19879541702315684, 0.2077023549618049, 0.13629342936222022, 0.11937450069633904, 0.11597167394872776, 0.16634108389060953, 0.127172136002226, 0.11108874154350201, 0.1253735053677556, 0.11885339252808735, 0.12724943758915108, 0.15638867420680946, 0.14336610220585122, 0.10988932831571618, 0.1264954355190796, 0.14046856087501314, 0.12118179343137125, 0.15110594121707854, 0.13481402722385005, 0.11573921740768078, 0.0023456882875155793, 0.006881152761425424, 0.03756051514716108, 0.00010386282986840634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0115740022461428, 0.010188404536990325, 0.1709653086065035, 0.07055497300890057, 0.16286943960442446, 0.06312456261795973, 0.07282237504591504, 0.048726130702053116, 0.1221771612937973, 0.07152037009030532, 0.08886992885864997, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014075397063439965, 9.999999999998899e-05, 0.05489445146299965, 0.042403449800102466, 0.055447073483390175, 0.060959304023421645, 0.07196530687122127, 0.059901460753073454, 0.08714986043321737, 0.05466186568906628, 0.048804443175935686, 0.3515606293321556, 0.35400793429515176, 0.3463053990013808, 0.3559676533170232, 0.3389829907874574, 0.3442459573514589, 0.3513646958714265, 0.36920634134128827, 0.34462758384770575, 0.0964652657480598, 0.14975674058109856, 0.1315560269549766, 0.145444535612134, 0.12599728032477597, 0.10437751093208203, 0.1118136935390257, 0.08630915296617969, 0.11829336430701409, 0.1661867304603275, 0.19147017678153155, 0.1399063299095511, 0.15592855232538028, 0.15827268108787573, 0.20825245766815248, 0.13116776741196623, 0.1565266614840075, 0.1182926007390579, 0.2689172835479273, 0.2529299450321968, 0.2305185052437171, 0.27308189914145875, 0.23617499533118913, 0.2517231214295079, 0.21593600130558654, 0.21308869137200137, 0.19574220865792968, 0.1871680583699905, 0.19736842418026113, 0.20269587648668608, 0.20039902028368217, 0.20613036394949313, 0.19608582438059063, 0.17097198674358638, 0.17818001965117825, 0.16470846753038082, 0.2299082616168665, 0.23276063276174497, 0.20893558602102946, 0.2161634716758124, 0.24236362960123659, 0.28070044591238585, 0.23106777059630712, 0.2850277064453607, 0.218317469934874, 0.17294262279109607, 0.17123485014350448, 0.17177072201651555, 0.20734123115054437, 0.18429646997788263, 0.16986022801565848, 0.17592502355348794, 0.17467166433129844, 0.17448330513831156, 0.18346710770999342, 0.18451121442872132, 0.15014311990872287, 0.41560330910844745, 0.1955670360785211, 0.13689491047986935, 0.48828261088474223, 0.20178841079811138, 0.1647906474591322, 0.5053829880342979, 0.2018895993048433, 0.3475723508107168, 0.19765030558363927, 0.1454214836235871, 0.1977500464035189, 0.10426989774470241, 0.16338547330873876, 0.2766705827142698, 0.17538681272516154, 0.17721409180165992, 0.18673480633909445, 0.20220077117612867, 0.1786179009261496, 0.17950365376731592, 0.19104601021085033, 0.1987387305053111, 0.17395230623150781, 0.09152959725779952, 0.09822050904724544, 0.09909901304722057, 0.12323372048909298, 0.08893568040105004, 0.09106100480357127, 0.09091423948116206, 0.09438054113727445, 0.09810720047058208]}, "mutation_prompt": null}
{"id": "29ffc9b5-9ff0-4450-830a-6e2aef0c4657", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Modulated learning rate based on fitness improvement\n            fitness_improvement = np.max(fitness) - np.min(fitness)\n            learning_rate = 0.01 + 0.02 * (np.exp(-fitness_improvement / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.2, self.mutation_factor + 0.01)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved", "description": "Introduced adaptive learning rate modulation based on convergence speed to enhance search efficiency.", "configspace": "", "generation": 82, "fitness": 0.186990861051963, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.35885951763530477, 0.3691463384834689, 0.36578058214806275, 0.34490679719554873, 0.3423118715822765, 0.40959308335796063, 0.34484352326974865, 0.352777256444206, 0.36519238228122153, 0.01809067373725226, 0.07202917283057264, 0.014861513482357758, 0.014731815114376379, 0.04074523493394777, 0.007922885987999284, 0.02557088989711609, 0.004172453100066198, 0.0005179298966162538, 0.11686850107855296, 0.10402530605247917, 0.09318228423389974, 0.12250578990514316, 0.09728741244932593, 0.10537059225094358, 0.07715119028676731, 0.09867018729006682, 0.11552217773588513, 0.08026146217668684, 0.08641216238782823, 0.08043793649357234, 0.09403802448910537, 0.08836839053305412, 0.07140444495881515, 0.09468494299362662, 0.06791919336343033, 0.08356438896269625, 0.887007211963963, 0.8996668343844377, 0.9293539742828972, 0.8447394894342581, 0.8382571424410572, 0.8715757805136795, 0.815623834140785, 0.8989807440008517, 0.8878322536634111, 0.2740825021051292, 0.22873586050132855, 0.24548168410228322, 0.2721417015108052, 0.2805103269767606, 0.2140352740922854, 0.24014517985989003, 0.2058756784939475, 0.2426569489666719, 0.22313609363167142, 0.14854106138522383, 0.20471771301983477, 0.20745519420497893, 0.24127402064206926, 0.19818487275536123, 0.13078307247991028, 0.21665374610946397, 0.17370790582246987, 0.15590571898689543, 0.12775671894644802, 0.12972313070782404, 0.11069310352884076, 0.1400238709168241, 0.08182076750514011, 0.12441678665708555, 0.12152851181804103, 0.1222174023150594, 0.13833670600611692, 0.13058926609813193, 0.13480042811118143, 0.12750496022576685, 0.14562863203131515, 0.11446400486000619, 0.14416951747387974, 0.13993800464097805, 0.12184321346419524, 0.012802070057540194, 0.02285250888567425, 0.0004151577761686287, 0.011397659675132621, 9.999999999998899e-05, 0.003299292063503545, 9.999999999998899e-05, 0.0030701437729033776, 9.999999999998899e-05, 0.14300404116626309, 0.0922771402560314, 0.17034634236396362, 0.06295330444200553, 0.08215671087868792, 0.054261345568616726, 0.1136099748471332, 0.06637765952144015, 0.08708174796439705, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03120327782468124, 0.04539128350635713, 0.05006364236836924, 0.08172160570329434, 0.06795436828497026, 0.07129188482702098, 0.06454906840478214, 0.04199730339526464, 0.05303830227442086, 0.34789795585692396, 0.38591407312211934, 0.3885674875093458, 0.33202134498395297, 0.3802318875687706, 0.32625409144356365, 0.3550871255194976, 0.3403048143538401, 0.40060942525517285, 0.09882602133102192, 0.11666662582172649, 0.11077701923454752, 0.13100157310218385, 0.10372744496278341, 0.10860691094529118, 0.0877894180830262, 0.12852627188898547, 0.10768873107616306, 0.18302304127947144, 0.13659598959716313, 0.1277542962099777, 0.20595688320847194, 0.1628523658840204, 0.12193074583064989, 0.2080943591150003, 0.1757418205187109, 0.15603204866238995, 0.26891197245576115, 0.2571573777345767, 0.21899261018905003, 0.24868611657027595, 0.22094777033098867, 0.25339409226828524, 0.22529620590462007, 0.20938822343728813, 0.19568634607719504, 0.18650008077887537, 0.20067989270850817, 0.18906400873380325, 0.18700252524320837, 0.20463530689906917, 0.21120107847839664, 0.18233758214240048, 0.17808807576372987, 0.18650199382667954, 0.25465530701874606, 0.24785873238104272, 0.21497909528466685, 0.218449917040891, 0.23288714537949795, 0.2152516085951186, 0.21813271093937103, 0.22810043355094267, 0.20661756267788856, 0.17541175166273992, 0.17246458234253437, 0.1769539107538841, 0.19994344998987967, 0.17481149128873952, 0.16870530303162268, 0.18593179594642184, 0.16981142101068836, 0.17850366973618526, 0.18585032774646426, 0.1852371845313544, 0.15063936233157804, 0.5234353197471353, 0.1917817130361147, 0.11865886972575557, 0.14592689040086793, 0.11342239900939877, 0.16656735187888716, 0.4945327599854954, 0.1998089398893952, 0.3726443284689045, 0.19430341969660359, 0.14084173896482322, 0.20272259461914965, 0.1043978149766841, 0.1631265273580399, 0.27628806760745805, 0.19066175283484776, 0.1735242775408542, 0.1880654031745964, 0.18155103091572178, 0.17834290393293906, 0.1816449727978937, 0.19233763731512066, 0.1976797273683315, 0.19672560405194028, 0.11080738959173664, 0.11396292720948564, 0.09190374103363264, 0.13212939445858374, 0.08426806096307449, 0.07923868119871713, 0.08621684818445663, 0.09115564009344268, 0.10064247341841415]}, "mutation_prompt": null}
{"id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            # Modified mutation factor adaptation\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2", "description": "Enhanced mutation factor adaptation to boost convergence speed by leveraging diversity metrics more dynamically.", "configspace": "", "generation": 83, "fitness": 0.18966383472476275, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "6eb625a6-12bd-4617-a82a-aea774dc24c8", "metadata": {"aucs": [0.3325482713057857, 0.3435910117337867, 0.35456897703770807, 0.3335869502012456, 0.354674040329785, 0.3432843133121224, 0.3804391957233285, 0.3803916962165277, 0.35966277827726034, 0.02588899008692991, 0.015216046422823482, 0.04020569903172566, 0.019615614106871404, 0.05602185723572306, 0.0015939418945852823, 0.0021476497332365563, 0.022743187603468162, 9.999999999998899e-05, 0.09712282660476379, 0.13842299278271875, 0.08690811196416981, 0.11427371603777225, 0.10649770625301003, 0.11205951166124417, 0.09785979061714645, 0.09502982755378764, 0.1298401026114403, 0.08428702491867535, 0.08492771538338095, 0.08031055243695318, 0.0875906955720962, 0.09320928505364756, 0.07956702314211928, 0.09580156476443735, 0.08549102974085565, 0.08712859405441009, 0.9137927073481733, 0.9007852482986745, 0.9401495223937913, 0.8435015800598408, 0.8759769289770568, 0.8692072240150408, 0.8364850383037569, 0.8593065604056097, 0.8889851114687184, 0.22286150544896333, 0.22236129860491227, 0.22253365186504803, 0.23843108558141235, 0.2846209387588745, 0.270649939522446, 0.2622223479459277, 0.23026837179600557, 0.21399345904714684, 0.23042188412803577, 0.14196144815438927, 0.20731638901686233, 0.20635505952946498, 0.2070774938447787, 0.2047333792882282, 0.15852783857402464, 0.17028074008391902, 0.20462882338021704, 0.13628107068849293, 0.11834053384705345, 0.11996871437841183, 0.16710953389351102, 0.12787735318003246, 0.11180450786344609, 0.12179982985143145, 0.11883951025074224, 0.1284328121957169, 0.15481673538502405, 0.143004316478197, 0.1099180470740434, 0.12637613294668648, 0.13935449947547895, 0.1243079722180872, 0.15047366131682627, 0.1375879730662598, 0.11649896087501244, 9.999999999998899e-05, 0.000817399548820319, 0.036590065980173336, 0.00010361496607835807, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011569804514038329, 0.01197728490957961, 0.17212516686601098, 0.06937522826904119, 0.16120054803660855, 0.0638383398936263, 0.07302972806194741, 0.048718885433979064, 0.12213365117154718, 0.07434849595301296, 0.1021329826599855, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00026575963201103114, 9.999999999998899e-05, 0.05489066518465335, 0.04372387420232793, 0.05531728402764946, 0.06108583568885517, 0.07196207424070888, 0.05996335911798689, 0.08537253809150369, 0.054603633161778964, 0.04881982271109997, 0.3514656337865204, 0.34478668283533387, 0.34629422291668843, 0.33976419319799234, 0.33878981130820507, 0.34380437602958247, 0.3526201250996338, 0.3693359978836206, 0.34441766102534066, 0.09526854545637675, 0.14983469825530793, 0.11532614649584816, 0.13703548644134467, 0.11313524739434344, 0.09881779135737356, 0.11189787555109065, 0.09104488575935699, 0.11827094560703988, 0.15799777809051174, 0.21150077763235664, 0.1574991018527031, 0.14864954658930352, 0.16018533848689198, 0.22914518932942873, 0.1518782080874156, 0.17235407786975687, 0.13908035274727082, 0.2617906880526323, 0.24864266573638127, 0.24366077107910167, 0.27320602034678176, 0.25328326763646003, 0.26386075139556, 0.2199312914132857, 0.21063735825853036, 0.1917195152993023, 0.1743825889720294, 0.21166307223470104, 0.22279402322005437, 0.20469549899661876, 0.2103531929850988, 0.18162819662656626, 0.1706605234019355, 0.1710414927075521, 0.1814106934285955, 0.24890866702038228, 0.2405837563474228, 0.21570817108453877, 0.2501484196129483, 0.225605074725585, 0.22193452997287566, 0.23450515829693386, 0.22616335436512758, 0.24842693550993422, 0.17625521704814562, 0.17109178715413542, 0.16707815155425398, 0.21022196585004727, 0.1881962872098769, 0.16985656483701972, 0.18198424615144582, 0.17014248937905618, 0.17587996664052097, 0.18396844055583628, 0.18446445259786926, 0.15021180863314643, 0.4157155699199959, 0.19495211426691295, 0.13688511194076203, 0.4881540155446029, 0.20179003454173883, 0.16475887726454652, 0.5212872595371905, 0.20188813274739337, 0.3475735171912264, 0.1976480166072362, 0.14471711078293936, 0.19774908652846135, 0.10426702824056688, 0.1633791488663061, 0.2771485945316342, 0.2143152072972957, 0.17815365267922678, 0.19458179010200216, 0.19249935572566812, 0.18848123161117736, 0.1786022783964969, 0.19105403549228017, 0.20391368340856375, 0.1876747926870147, 0.09834220113387726, 0.11423824400794969, 0.0915320626528977, 0.10768030774314152, 0.09304618308961399, 0.08494739487483005, 0.08944880881489281, 0.09389321031036635, 0.0921704140306816]}, "mutation_prompt": null}
{"id": "9e94880f-bb31-4c58-9d29-c1f371508155", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            # Dynamic scaling for mutation factor based on diversity and convergence\n            scaling_factor = (1 + 0.5 * (1 - avg_diversity / self.dim) * (1 - convergence_progress))\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = scaling_factor * (1 + (evals / self.budget) * (1 - avg_diversity / self.dim))\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n\n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n\n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V8", "description": "Introduced a dynamic scaling factor for mutation to adaptively respond to diversity and convergence rate.", "configspace": "", "generation": 84, "fitness": 0.18479738535199258, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V8 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "metadata": {"aucs": [0.33529042054001423, 0.3575128633103668, 0.3589794216433968, 0.3418798993419486, 0.3380651191613945, 0.34555565717389547, 0.33271949560625735, 0.3979812183031841, 0.377477613048974, 0.019488593727469583, 0.013872684146073011, 0.045932668201714155, 0.034220707871364886, 0.057742802080654854, 0.007126066268741682, 0.00021673282149781148, 0.03267009379238428, 9.999999999998899e-05, 0.1335359312744394, 0.135163734472306, 0.07883951406447687, 0.11780927643063821, 0.09728151080534475, 0.09565488895299457, 0.08293347100132487, 0.10511048561211211, 0.08451578305405238, 0.07557234386646339, 0.08096160690869403, 0.06251261738476133, 0.0877000096015127, 0.08357070463869454, 0.08113362067836682, 0.09512919249064089, 0.0853335714297413, 0.0877518194262511, 0.8906815570495681, 0.9168990343998709, 0.9112426536459224, 0.8454188411282023, 0.8223709411566948, 0.8671441094328067, 0.8678977645084264, 0.900827551214869, 0.8918143634908386, 0.23652472944221092, 0.195569161241962, 0.2237281506060418, 0.256152525286487, 0.2332070376379003, 0.23977435195615482, 0.24211944977215893, 0.20653303845600435, 0.22469932151209648, 0.21417633875439102, 0.13717133197407094, 0.19091670249753756, 0.2158724448159145, 0.26576605286031185, 0.1986266622374302, 0.17378644029703738, 0.16846260605038244, 0.15410719170915743, 0.13466949310978782, 0.12359340405078478, 0.11731814081677117, 0.11920535276558553, 0.11694281504033965, 0.1042157468677184, 0.17092212507181503, 0.11886346803811854, 0.12010760410696808, 0.14569082701195224, 0.12759986731520967, 0.09771203975497678, 0.1297456936450362, 0.13849801905149783, 0.11150397279094504, 0.13641651468057203, 0.09370908930946842, 0.12309731693299875, 0.01872031861025658, 0.012279184807626242, 0.046112141505712856, 0.014894244766680664, 0.010722858310086347, 0.008151227383839443, 9.999999999998899e-05, 9.999999999998899e-05, 0.009606317065765535, 0.09139811948940701, 0.09715709169183706, 0.10854463188380814, 0.06458801032076167, 0.026559471846688054, 0.03406098513239375, 0.13644884965762105, 0.06812827987704728, 0.05575978539210502, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048439689949480225, 0.046031649361053306, 0.06081818971682584, 0.05581596462149685, 0.06106338052247806, 0.07819309442489542, 0.047412405575853134, 0.051501390452833196, 0.05844394341593029, 0.3462248368734132, 0.3626315929231412, 0.32831275506569735, 0.37632746922437676, 0.36732900874823493, 0.34632855940365626, 0.33488544866000014, 0.3540200843355801, 0.3445257320466615, 0.10006138807266873, 0.1208642676404934, 0.09261907127980862, 0.1351744113194927, 0.10724221537657408, 0.11459522136957989, 0.12406239658895335, 0.12859369355818728, 0.08810650461481839, 0.18050697216861045, 0.15855698285812958, 0.16826871888900696, 0.14002867234212912, 0.1861371847670894, 0.14016970980932453, 0.17451043408219302, 0.20739897489906667, 0.14248394487110705, 0.2678487375505967, 0.25641734685420037, 0.2566119186944439, 0.26729978327331305, 0.2418530273000089, 0.26066285882850615, 0.2133531329794338, 0.23353695945199404, 0.20807230894452444, 0.19030307677702596, 0.2100855647428136, 0.20044619184929757, 0.19631593914169532, 0.20660463644224558, 0.19960764332069436, 0.17802343359867023, 0.15429243213719857, 0.18759993365418692, 0.2167048340111154, 0.2229280538126499, 0.20294966378515, 0.2519163670680816, 0.23047288063442506, 0.21710144167867806, 0.23300195731408313, 0.23789231935629618, 0.1981481246898681, 0.18122171292606326, 0.17626805251183486, 0.18115715369228846, 0.1774768827690596, 0.1832307074271795, 0.17081158620170978, 0.17229732148122767, 0.17086879791987997, 0.1894260319121478, 0.18456619414808828, 0.18160042010302146, 0.1692797649683513, 0.47338243722119366, 0.19518902684039463, 0.11408446888474777, 0.14532934694975952, 0.11355467254530816, 0.16697771591337074, 0.463157370140888, 0.199945740552116, 0.36329259081603726, 0.2008525857797714, 0.1409531776376598, 0.2004972220493878, 0.1044578419112624, 0.16118455921615604, 0.27057103006421757, 0.19198312006070506, 0.18430337635102756, 0.188722055953657, 0.18411896116463022, 0.1928880508176397, 0.19168353902205526, 0.2038610524961142, 0.18972489854946095, 0.1805551690966869, 0.0948411621984151, 0.09494441232564421, 0.09692897611627282, 0.11424760510745513, 0.08529457369182414, 0.09923446881871312, 0.08153265529182285, 0.09391225731728514, 0.08521246097904678]}, "mutation_prompt": null}
{"id": "f631a8b4-94bc-48e6-9b71-f457cdbd35ae", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n        momentum_decay = 0.002  # New momentum decay term\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            # Modified mutation factor adaptation with momentum decay\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015 - momentum_decay)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2", "description": "Introduce a momentum decay term in the mutation factor update to balance exploration and exploitation for improved convergence.", "configspace": "", "generation": 85, "fitness": 0.18902366254291203, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "metadata": {"aucs": [0.3325259938667643, 0.3434096286235494, 0.3545774478489413, 0.3335920520960919, 0.354293130577805, 0.34422292138190347, 0.38099740001733085, 0.3803388974756, 0.3595008024076407, 0.024087278899857067, 0.015230088014967835, 0.028904266397260625, 0.0055075823666649315, 0.057526038210863994, 0.001605033027421432, 0.0021417947308760565, 0.02390778583772013, 9.999999999998899e-05, 0.09225948416738461, 0.13827306172544573, 0.08467976543384959, 0.11374732217308214, 0.11586251395990477, 0.11288526228891804, 0.09787898705464071, 0.0950381777790199, 0.12983809097625143, 0.07999621613916408, 0.08187448778137918, 0.08028452257751106, 0.08775635451956354, 0.08375573350746401, 0.0867420542974332, 0.09042164621821425, 0.0716424898828425, 0.0858795748008162, 0.9137927073481733, 0.9007852482986745, 0.9401495223937913, 0.8435015800598408, 0.8759769289770568, 0.8692072240150408, 0.8364876021307932, 0.8593148798887655, 0.8889851114687184, 0.22849093748570748, 0.22869072190890583, 0.21668526412030997, 0.23875271953023636, 0.2497757420884461, 0.2452956056224742, 0.24928082289736198, 0.23249335266435234, 0.21729171572441996, 0.226365912042649, 0.14196144815438927, 0.20731638901686233, 0.2062962620386829, 0.2070774938447787, 0.21513525459199112, 0.16942026879067473, 0.17044267471670738, 0.21027330734014116, 0.13628911280565337, 0.11962831288500331, 0.12123025054241121, 0.16573057508669353, 0.12920588920130427, 0.11143503343178107, 0.12461561720080805, 0.11886206899165863, 0.12725035893346326, 0.15610780466056218, 0.14338639232539974, 0.10991371725406884, 0.12648106356461086, 0.13934066878036522, 0.12428918850154169, 0.14604344406494363, 0.13661972587417026, 0.11632342129989337, 0.010505815381338657, 0.001741788430635438, 0.03723877066424541, 0.00010349475920334861, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011574351070538946, 0.014743018940001629, 0.17218598357616122, 0.07041961407990727, 0.1623953447914409, 0.06368128410554763, 0.07523911600487032, 0.04896523132297248, 0.12181397376843639, 0.07464744335835183, 0.09109789329802331, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00020816458313599462, 9.999999999998899e-05, 0.05488810597067928, 0.04375264023457626, 0.05536773977434262, 0.06108593561661979, 0.07196414321430733, 0.05996366338576009, 0.08437185598806207, 0.05460318351276672, 0.04882899747586833, 0.35241529614941747, 0.3450876961669235, 0.346283529360243, 0.34309529768517955, 0.3387905910626414, 0.34869877864318455, 0.352730890655524, 0.369315628057842, 0.34441394425751704, 0.09498373998574883, 0.1498353787614497, 0.11514783598836675, 0.13703548334779825, 0.12776767434805025, 0.0988177867727913, 0.1118186117029536, 0.09104485471810864, 0.11827358253986897, 0.15794529431112803, 0.20014262714818587, 0.15732034014120122, 0.14783141384120158, 0.1597735821438815, 0.2345637232906157, 0.1507907625684467, 0.16618262245736404, 0.1457709864627723, 0.261991507419713, 0.2564266375422448, 0.2398642653361548, 0.2735394533018297, 0.23056102826583802, 0.24710916144486872, 0.2142249523727614, 0.20817970826223953, 0.19102747258041053, 0.17800092714118687, 0.19902006129144445, 0.20522306172315974, 0.19787541179436252, 0.21342393799204662, 0.18270615537352697, 0.17186477936523137, 0.17833190086111006, 0.18675783203469187, 0.24890866702038228, 0.2405837563474228, 0.21570817108453877, 0.2501484196129483, 0.225605074725585, 0.22193452997287566, 0.23450515829693386, 0.22616335436512758, 0.24842693550993422, 0.17665169682037885, 0.17114355722487595, 0.16912080156975318, 0.20736202522419256, 0.18427989109365883, 0.16781984973826602, 0.1759398682450759, 0.17329073931400685, 0.17221823979231576, 0.1840340666601894, 0.1845526149745672, 0.1502105127311968, 0.4160327602190518, 0.19495067208129502, 0.1368857656007394, 0.4881998891836373, 0.2017901863141468, 0.16475991345887997, 0.5213875478364572, 0.20188632545782648, 0.34755821549187393, 0.19764891735322732, 0.14449297014774742, 0.19774958739484116, 0.10427506340403125, 0.1633843245255071, 0.2771491968100984, 0.2143152072972957, 0.17815365267922678, 0.19458179010200216, 0.19249935572566812, 0.18848123161117736, 0.1786022783964969, 0.19105403549228017, 0.20391368340856375, 0.1876747926870147, 0.09834220113387726, 0.11423824400794969, 0.0915320626528977, 0.10768030774314152, 0.09304618308961399, 0.08494739487483005, 0.08944880881489281, 0.09389321031036635, 0.0921704140306816]}, "mutation_prompt": null}
{"id": "ee446db1-5af3-499d-b15f-d46fa2c0f549", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n        self.previous_best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            current_best_fitness = np.min(fitness)\n            fitness_improvement_rate = (self.previous_best_fitness - current_best_fitness) / self.previous_best_fitness if self.previous_best_fitness != np.inf else 0\n            self.previous_best_fitness = current_best_fitness\n\n            if current_best_fitness < self.best_fitness:\n                self.best_fitness = current_best_fitness\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1 + fitness_improvement_rate)\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3", "description": "Introduced adaptive learning rate scaling based on fitness improvement rate to enhance convergence efficiency.", "configspace": "", "generation": 86, "fitness": 0.1868620025602715, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "metadata": {"aucs": [0.34871796747687944, 0.34445936805668376, 0.3609207080330098, 0.3359530002014439, 0.36066785025570613, 0.3444814923517576, 0.3560623453062375, 0.3756744386187536, 0.3632130967354549, 0.024863898714650667, 0.025283715230603576, 0.012194596108438649, 0.008214296936981058, 0.029513145025423237, 0.0021573814637744215, 0.007367219972009509, 0.03576429662047398, 9.999999999998899e-05, 0.12504698869147646, 0.13248454131223097, 0.07809177940486511, 0.10890003641621693, 0.10341447084625743, 0.10447494550259784, 0.08551397855563458, 0.118771308698422, 0.11490556623041681, 0.0912612541821598, 0.07874074931878772, 0.08421765132976178, 0.1035579893690628, 0.0784231945353866, 0.08122794003957101, 0.09282474302552723, 0.0838832863293566, 0.0826465307509201, 0.9135174373630799, 0.9030834173364622, 0.9398447088246603, 0.8432493791576242, 0.8759546119197141, 0.8692029744072022, 0.8367121366361319, 0.8581726242629591, 0.8908342606789558, 0.23730877613482126, 0.2029635342419729, 0.21333593395978945, 0.21946605964956312, 0.26567019309195916, 0.2345276133606542, 0.2387077490400782, 0.22195786131762463, 0.2060844395672129, 0.22889491007233054, 0.17083746492085905, 0.23306110044381467, 0.20290301795827004, 0.25522709566583, 0.22185983846454305, 0.1611982520559665, 0.2019581305098217, 0.1939493694668547, 0.11855876737399684, 0.10431790153740783, 0.12141441171296097, 0.1308444516382795, 0.1254299420492474, 0.094087985785695, 0.12526467864455682, 0.1278388863328821, 0.12886104094243733, 0.15376278699288237, 0.13444817565183254, 0.10439114556237072, 0.1317349165374324, 0.14594105705598182, 0.11910105724827624, 0.1248890455407794, 0.139335602859312, 0.1310518077705678, 0.04400876526814845, 9.999999999998899e-05, 0.0061079085018290735, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03211597601771332, 0.001121620166846693, 0.16821578419547223, 0.017288684900032214, 0.1292390604851973, 0.06090153760549022, 0.07672464966788861, 0.04123801495328294, 0.10857010248352583, 0.08249159494173253, 0.08074663314498087, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06195646946959055, 0.05441656336291367, 0.05436414839593218, 0.06948945237351489, 0.06877287713433611, 0.056474151016454366, 0.06042499085341002, 0.04419307981087517, 0.04542355416523858, 0.34998786097651524, 0.3406381508244486, 0.3412086091883161, 0.3466779180514733, 0.33448036864666253, 0.3536348202504641, 0.35233630648922876, 0.38345315551355663, 0.34334217468862493, 0.07886878019154775, 0.15130841515213156, 0.1068255668584629, 0.11821720425921645, 0.11233509146264276, 0.12959069627526987, 0.12455703227027493, 0.09892939826536296, 0.13033692398870445, 0.2265253199768531, 0.20350314752955645, 0.16459942079332268, 0.1550781916704731, 0.15992050912957234, 0.16120569958080744, 0.1592747002814462, 0.1572614279660951, 0.21626833353072017, 0.2569026576580766, 0.24306175963077215, 0.22561758507312146, 0.2637119931407189, 0.2232575896840967, 0.25982837916010193, 0.2130062315535204, 0.21342626469188297, 0.20136140145431858, 0.18653766693996754, 0.20364193962113564, 0.17192492300166273, 0.22338671676606991, 0.2149073332022644, 0.17782143150691831, 0.16575229971714056, 0.16595262804706434, 0.1791931717130958, 0.24379960683812207, 0.2219483549137511, 0.20676107001458688, 0.25022359130638394, 0.22697347145188007, 0.2208905182852492, 0.21868880105023925, 0.23922125274695683, 0.2059973088400665, 0.17695735276350044, 0.17404420698696066, 0.17265493895562212, 0.20741215956479386, 0.18521547307698216, 0.1759837091246762, 0.17873152617780996, 0.17428711964162047, 0.17056361684031274, 0.18468851017088095, 0.18443054769903833, 0.15153500529458108, 0.2057584975831913, 0.19144396338196845, 0.13841544612000967, 0.4626343075116278, 0.20351594129923456, 0.16460267620521774, 0.47098372060438354, 0.20155174963341138, 0.37094409008521867, 0.1938409383431111, 0.14470708977995583, 0.1977811581041402, 0.10393370160228455, 0.16316805744985918, 0.2654348291182682, 0.17985665511093663, 0.17695143589982631, 0.18390667964353968, 0.20088996403134984, 0.1954643830073537, 0.18837524569231023, 0.1857387301218254, 0.18380953979505377, 0.1771710933480506, 0.09935848628943134, 0.12411692740943125, 0.09696263827798102, 0.11053491530461013, 0.09031192772862684, 0.09385829046459204, 0.10441595177159091, 0.08969783831691125, 0.08995240355865153]}, "mutation_prompt": null}
{"id": "d6b21ce8-eb4a-49aa-ace5-47d6cd29ba19", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            # New adaptive learning rate decay based on fitness variability\n            fitness_variability = np.std(fitness) / (np.mean(fitness) + 1e-9)\n            learning_rate *= (1 - 0.5 * fitness_variability)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2", "description": "Introduced a simple adaptive learning rate decay based on population fitness variability to improve convergence speed.", "configspace": "", "generation": 87, "fitness": 0.18966383472476275, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "metadata": {"aucs": [0.3325482713057857, 0.3435910117337867, 0.35456897703770807, 0.3335869502012456, 0.354674040329785, 0.3432843133121224, 0.3804391957233285, 0.3803916962165277, 0.35966277827726034, 0.02588899008692991, 0.015216046422823482, 0.04020569903172566, 0.019615614106871404, 0.05602185723572306, 0.0015939418945852823, 0.0021476497332365563, 0.022743187603468162, 9.999999999998899e-05, 0.09712282660476379, 0.13842299278271875, 0.08690811196416981, 0.11427371603777225, 0.10649770625301003, 0.11205951166124417, 0.09785979061714645, 0.09502982755378764, 0.1298401026114403, 0.08428702491867535, 0.08492771538338095, 0.08031055243695318, 0.0875906955720962, 0.09320928505364756, 0.07956702314211928, 0.09580156476443735, 0.08549102974085565, 0.08712859405441009, 0.9137927073481733, 0.9007852482986745, 0.9401495223937913, 0.8435015800598408, 0.8759769289770568, 0.8692072240150408, 0.8364850383037569, 0.8593065604056097, 0.8889851114687184, 0.22286150544896333, 0.22236129860491227, 0.22253365186504803, 0.23843108558141235, 0.2846209387588745, 0.270649939522446, 0.2622223479459277, 0.23026837179600557, 0.21399345904714684, 0.23042188412803577, 0.14196144815438927, 0.20731638901686233, 0.20635505952946498, 0.2070774938447787, 0.2047333792882282, 0.15852783857402464, 0.17028074008391902, 0.20462882338021704, 0.13628107068849293, 0.11834053384705345, 0.11996871437841183, 0.16710953389351102, 0.12787735318003246, 0.11180450786344609, 0.12179982985143145, 0.11883951025074224, 0.1284328121957169, 0.15481673538502405, 0.143004316478197, 0.1099180470740434, 0.12637613294668648, 0.13935449947547895, 0.1243079722180872, 0.15047366131682627, 0.1375879730662598, 0.11649896087501244, 9.999999999998899e-05, 0.000817399548820319, 0.036590065980173336, 0.00010361496607835807, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011569804514038329, 0.01197728490957961, 0.17212516686601098, 0.06937522826904119, 0.16120054803660855, 0.0638383398936263, 0.07302972806194741, 0.048718885433979064, 0.12213365117154718, 0.07434849595301296, 0.1021329826599855, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00026575963201103114, 9.999999999998899e-05, 0.05489066518465335, 0.04372387420232793, 0.05531728402764946, 0.06108583568885517, 0.07196207424070888, 0.05996335911798689, 0.08537253809150369, 0.054603633161778964, 0.04881982271109997, 0.3514656337865204, 0.34478668283533387, 0.34629422291668843, 0.33976419319799234, 0.33878981130820507, 0.34380437602958247, 0.3526201250996338, 0.3693359978836206, 0.34441766102534066, 0.09526854545637675, 0.14983469825530793, 0.11532614649584816, 0.13703548644134467, 0.11313524739434344, 0.09881779135737356, 0.11189787555109065, 0.09104488575935699, 0.11827094560703988, 0.15799777809051174, 0.21150077763235664, 0.1574991018527031, 0.14864954658930352, 0.16018533848689198, 0.22914518932942873, 0.1518782080874156, 0.17235407786975687, 0.13908035274727082, 0.2617906880526323, 0.24864266573638127, 0.24366077107910167, 0.27320602034678176, 0.25328326763646003, 0.26386075139556, 0.2199312914132857, 0.21063735825853036, 0.1917195152993023, 0.1743825889720294, 0.21166307223470104, 0.22279402322005437, 0.20469549899661876, 0.2103531929850988, 0.18162819662656626, 0.1706605234019355, 0.1710414927075521, 0.1814106934285955, 0.24890866702038228, 0.2405837563474228, 0.21570817108453877, 0.2501484196129483, 0.225605074725585, 0.22193452997287566, 0.23450515829693386, 0.22616335436512758, 0.24842693550993422, 0.17625521704814562, 0.17109178715413542, 0.16707815155425398, 0.21022196585004727, 0.1881962872098769, 0.16985656483701972, 0.18198424615144582, 0.17014248937905618, 0.17587996664052097, 0.18396844055583628, 0.18446445259786926, 0.15021180863314643, 0.4157155699199959, 0.19495211426691295, 0.13688511194076203, 0.4881540155446029, 0.20179003454173883, 0.16475887726454652, 0.5212872595371905, 0.20188813274739337, 0.3475735171912264, 0.1976480166072362, 0.14471711078293936, 0.19774908652846135, 0.10426702824056688, 0.1633791488663061, 0.2771485945316342, 0.2143152072972957, 0.17815365267922678, 0.19458179010200216, 0.19249935572566812, 0.18848123161117736, 0.1786022783964969, 0.19105403549228017, 0.20391368340856375, 0.1876747926870147, 0.09834220113387726, 0.11423824400794969, 0.0915320626528977, 0.10768030774314152, 0.09304618308961399, 0.08494739487483005, 0.08944880881489281, 0.09389321031036635, 0.0921704140306816]}, "mutation_prompt": null}
{"id": "24bdb27a-8847-4f17-a8e1-363b53ec767b", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**1.8 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3", "description": "Enhance exploration by dynamically adjusting noise scale based on convergence rate and diversity to improve convergence speed.", "configspace": "", "generation": 88, "fitness": 0.18701253986749294, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "metadata": {"aucs": [0.3603181162415645, 0.3921602203284863, 0.3496641069821922, 0.31307749973043597, 0.34134330444151906, 0.33645936203064297, 0.35884292828446085, 0.3779752799063094, 0.36756564742587405, 0.0321545316994869, 0.04759604612708934, 0.020520100494811566, 0.021205705197712588, 0.04500932629598842, 0.0031275936878766286, 0.009152505296494362, 0.02902875350798162, 0.00441357570506129, 0.09506950490713739, 0.12817489954901107, 0.11811615064700476, 0.12046682958531107, 0.1185656958426009, 0.12082560326861058, 0.08303105340191774, 0.10711542117771611, 0.1254394236355898, 0.08844030233300981, 0.07586145290396473, 0.07822538799944956, 0.09853328719307153, 0.0823505584292259, 0.08905929091845699, 0.10033038432304753, 0.08346400921343411, 0.08829075143248666, 0.9140413959151903, 0.9010352972339971, 0.9290197052279241, 0.8293418525790545, 0.8748508402795163, 0.8692744167267981, 0.8372921291162279, 0.8585821283777226, 0.8891444409966409, 0.22165846553016144, 0.21609550777923403, 0.2361563554435857, 0.2264746660840773, 0.28273758852746067, 0.19457156114510465, 0.23381224326837002, 0.22640444218335398, 0.2113590699696969, 0.24493087725959717, 0.13627899319198356, 0.2218621401451728, 0.20621836709631547, 0.2439388305726824, 0.2139819660280351, 0.1365257930329884, 0.18238185499161474, 0.19896172106881804, 0.13315403700431327, 0.10758888788555321, 0.11416623075600796, 0.12329042488062336, 0.13064635389884716, 0.09354848185097253, 0.12211938210916051, 0.12086016611242467, 0.12996388078964372, 0.15551579202671817, 0.10722197087928109, 0.10679912490920396, 0.12437266849532858, 0.13160060481428915, 0.12407751274930912, 0.1444972773671086, 0.12560898193070447, 0.11617303709213689, 9.999999999998899e-05, 0.006884702927497766, 0.007045766143358723, 9.999999999998899e-05, 9.999999999998899e-05, 0.004776650357264045, 9.999999999998899e-05, 0.0012563715112002827, 0.01287595804748598, 0.17375136760419718, 0.07064948256269032, 0.1567593710207118, 0.0640092854590466, 0.07881169629098317, 0.04858972891802438, 0.13225516011532346, 0.07464764288377213, 0.07298423733546389, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06015568019837758, 0.045574521797558165, 0.08704135201499663, 0.06313558425308818, 0.06303349927535762, 0.06952106629571575, 0.05441517314896682, 0.048392907779619576, 0.04664546268505876, 0.3486884295662521, 0.3410962072865814, 0.3232816511095725, 0.34504348980505406, 0.34800477367137284, 0.35060074853948087, 0.34641366743839774, 0.3736989213516324, 0.3456421083022815, 0.0993194799212439, 0.1331432182003338, 0.10790105034707553, 0.10538037402079059, 0.10657003898520001, 0.124716419488765, 0.12307852945176223, 0.11512043548253825, 0.11770281216382994, 0.157414385830838, 0.1938085768998994, 0.17466751264321023, 0.14100315844731282, 0.14941706841375235, 0.17171631168863255, 0.1392844106050487, 0.2094948508601321, 0.13446551642507043, 0.2499393312789494, 0.25324955447509745, 0.2461050503249308, 0.25731766487448604, 0.221810235678351, 0.2515060017337851, 0.2245401232970642, 0.20960147522198136, 0.19169736150742078, 0.1657052537157877, 0.21287052060035427, 0.1837094324298193, 0.2068590031618993, 0.20874363753356207, 0.17195568193843935, 0.18566716595957644, 0.18137589600897208, 0.1754797632715558, 0.2111151971542632, 0.24736171826295417, 0.20116819671581554, 0.22640513339916957, 0.25861488066510074, 0.21883413399031637, 0.22113076888756655, 0.2659590834639256, 0.25474654848273715, 0.17235941655010467, 0.17580184501570661, 0.16896303521051725, 0.19271368260169208, 0.18845311562013778, 0.1697057388857267, 0.16669670969301786, 0.17674058149822247, 0.169354036478224, 0.183335054563599, 0.18377951609718723, 0.15043225331672816, 0.5017509213270284, 0.19530863643516072, 0.1390766126310773, 0.14309184359455518, 0.20233694168963645, 0.16474005868525632, 0.5225920822274925, 0.1998986550024593, 0.40233267907157255, 0.19380206678857848, 0.14541380154504424, 0.19738604522998138, 0.10376732713473324, 0.1633925035113134, 0.27054725886212283, 0.1870740678466596, 0.18082045715676898, 0.20147580885071115, 0.19352131837761333, 0.2154217570849154, 0.18939746945596936, 0.17702343950695976, 0.17657138146657547, 0.18373086552541096, 0.09341447709884054, 0.10799754953702179, 0.10186085419239976, 0.14545652790255803, 0.09389853743892673, 0.0863058319505573, 0.09508589126250322, 0.08873122830280811, 0.09938102408072047]}, "mutation_prompt": null}
{"id": "dabf581e-d606-4cda-86af-14c02775ccc0", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    diversity_scale = min(1.0, diversity / (2 * diversity_threshold))\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i]) * diversity_scale\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2", "description": "Introduced adaptive momentum scaling based on dynamic diversity to enhance convergence speed while maintaining mutation factor adjustments.", "configspace": "", "generation": 89, "fitness": 0.18715054910452952, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "metadata": {"aucs": [0.33566679914169884, 0.36258942060234556, 0.3501122178091729, 0.34331074158200814, 0.3566126350079779, 0.3312716984557613, 0.34486292572005206, 0.36197362690749724, 0.3894896136616427, 0.0159167768462386, 0.02945556091254964, 0.026701324432582996, 0.04593186278049055, 0.058361920751089924, 0.00031520199426449125, 9.999999999998899e-05, 0.022979236657350688, 9.999999999998899e-05, 0.10377519557237302, 0.11337194185176502, 0.08867164688123541, 0.10667145786438537, 0.11396880338572479, 0.11343035944687363, 0.10813581678517725, 0.12252385277344002, 0.10640840152580566, 0.080612086571488, 0.08523270284051376, 0.07289646721206722, 0.09586644399838928, 0.08635314691777929, 0.07831122006031255, 0.09082871731656283, 0.07441574471754464, 0.08400689674481365, 0.9137818014001207, 0.9007721186123453, 0.9401474434551597, 0.8432684371941344, 0.8758404532563322, 0.8690543887484249, 0.8363766029428812, 0.8590547393752279, 0.8889676513972563, 0.21013878223259297, 0.2100214441290329, 0.1858201514874095, 0.19874670883643308, 0.23727007977715286, 0.20492453814558143, 0.23020368818591952, 0.19870550767467787, 0.18825528829288107, 0.24029269612573434, 0.13978820242672974, 0.21006886929373436, 0.20479984342678803, 0.22474027174554456, 0.22943159644930122, 0.13860689692782924, 0.19010892515848798, 0.19193303476535262, 0.13189224112333864, 0.1360262485533993, 0.10627417473763345, 0.12237196610538381, 0.12528526546107244, 0.10414796279700389, 0.11470252958412197, 0.12263239987136165, 0.13734985967522229, 0.15527802806045798, 0.13535083879326726, 0.09987714623679134, 0.12132919924908292, 0.12485691542655153, 0.11679480501208195, 0.14391806538692964, 0.1419091648446732, 0.11559224586164196, 0.005370993924893597, 0.0017612012762728835, 0.019712322806844207, 0.010942809467209158, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007422606450081526, 0.013968770535695896, 0.046143656541419165, 0.16795584787221285, 0.08236147259484694, 0.16281677241680903, 0.06101785650204705, 0.0773990866168277, 0.04889207740658841, 0.12033764571555383, 0.07107815381832883, 0.09607189465716925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0649067937069624, 0.04346617746867376, 0.06262858925097137, 0.05741167358893451, 0.07400845586960281, 0.05185537262121542, 0.05525863546586807, 0.04568065110171482, 0.059724352478540466, 0.34074284571724345, 0.34818411533996363, 0.3344796987690538, 0.32844850139119075, 0.3368756738631318, 0.33713634538582216, 0.3357357216617908, 0.3641727645813132, 0.32822168641901517, 0.09283259787938403, 0.11300782814907706, 0.09502862327994588, 0.14891864763617635, 0.1294330037455651, 0.12699041508596842, 0.12164078181624594, 0.112396414062228, 0.11622018043972238, 0.17966957395052618, 0.20472021173714383, 0.18879933221784273, 0.14721293430019455, 0.15917912171197968, 0.18452797554626377, 0.154290750146449, 0.17662628417433457, 0.14438743877621096, 0.256648319395833, 0.25262574166642926, 0.23865308618658754, 0.25212619796928626, 0.2417890200205568, 0.26076591224270773, 0.22160439704187518, 0.21603672872285118, 0.18580426916602055, 0.18445516235648385, 0.20389248778985525, 0.18814424662424067, 0.2063710787772447, 0.19593169105242814, 0.19198355362548958, 0.1767609644671686, 0.1635409758013251, 0.1811680071100069, 0.2156107599275897, 0.21956992682444643, 0.2426605528095893, 0.2101194293927977, 0.2360134835994886, 0.21027320418432216, 0.2269367697103727, 0.25349660903859483, 0.2342397392968577, 0.18967042417559277, 0.18701748721889877, 0.17281749106432376, 0.19530997950947782, 0.18925336358087075, 0.17119218130523073, 0.1720747745350536, 0.16896629643237926, 0.1879471099733403, 0.18503511617055557, 0.18451425656118803, 0.15080039773176612, 0.4409378589256441, 0.19491391886770615, 0.13765366273681667, 0.4491507592870103, 0.20190335300432272, 0.16473203488840504, 0.4885705439624055, 0.20083574601163123, 0.3563732996150082, 0.19594594338738458, 0.14477070193220476, 0.1975982482635401, 0.10421161694477776, 0.16227788663109388, 0.2551452387521723, 0.2143152072972957, 0.18021586892040908, 0.19458179010200216, 0.19073353881993504, 0.18823203325122928, 0.17565124646052077, 0.19105403549228017, 0.20383212004787155, 0.1876747926870147, 0.1000350757205819, 0.10182611705429334, 0.0984959583448255, 0.15103955170820516, 0.09413767621249058, 0.08734067130961098, 0.09720065263761757, 0.08861859511793413, 0.0922569930189584]}, "mutation_prompt": null}
{"id": "d00e25db-e016-41d7-b491-352fb38b9a2c", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            # Adaptive learning rate scaling for diversity\n            improvement = (self.best_fitness - fitness.min()) / (np.abs(self.best_fitness) + 1e-8)\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1 + improvement)\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            # Modified mutation factor adaptation\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3", "description": "Introduced an adaptive learning rate scaling for diversity based on the best solution's fitness improvement over iterations.", "configspace": "", "generation": 90, "fitness": 0.1813322422781132, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "metadata": {"aucs": [0.3384939373730973, 0.35267543532709456, 0.35589243438927864, 0.33636585777621153, 0.3675821648826293, 0.34422837946817386, 0.3803812976503539, 0.3801856215690288, 0.3658211374877277, 9.999999999998899e-05, 9.999999999998899e-05, 0.027987866544851192, 0.007997814876774867, 0.01795766379222563, 0.0021309043378782144, 9.999999999998899e-05, 0.06727518644488606, 9.999999999998899e-05, 0.10807749873872452, 0.149594832994426, 0.08145041810430353, 0.13773427937300353, 0.12380227005030975, 0.1392480423808189, 0.10043075359682985, 0.10714474417929709, 0.1244876205922415, 0.08569711552326875, 0.08788957089665528, 0.07839935122393438, 0.10636603540491174, 0.06827280046952677, 0.07751566568040602, 0.10610390375900713, 0.08074159306055284, 0.08317302964386675, 0.9131400885112041, 0.9133278841557333, 0.9059289101307766, 0.8282209916683517, 0.8761930512293576, 0.8692288295456236, 0.8369871081357568, 0.8592012757997136, 0.8909605374760277, 0.0356485488413959, 9.999999999998899e-05, 0.19214765515968402, 9.999999999998899e-05, 0.24067737602983552, 0.24095060479580355, 0.2461764471010276, 0.011293333694524565, 0.24460535083794954, 0.24939819187989554, 0.14196144815438927, 0.2288437027676743, 0.20379875044260842, 0.25277306160076274, 0.24457910830058305, 0.13814699992440505, 0.2032097514622534, 0.2067716115762116, 0.11665308225253435, 0.12636002997049467, 0.12119178044276613, 0.1261596069160903, 0.1366231764360335, 0.12838720774101364, 9.999999999998899e-05, 0.12369133533411636, 0.12662867905786768, 0.1505417135642032, 0.12221567855505688, 0.1025015602708298, 0.1274604457714087, 0.1454534418605461, 0.11894015794703205, 0.1686637922063634, 0.141138937613824, 0.11741442150428716, 0.0032113531635835635, 0.005940082900580457, 0.004139248809620799, 0.002844116440722022, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11698919311161282, 9.999999999998899e-05, 0.04874868739932603, 0.015860541936920325, 0.053080372363249806, 0.047879364069203234, 9.999999999998899e-05, 0.04501020878704731, 0.06816299083888588, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05911237929342805, 0.04532664332120151, 0.04938195311774618, 0.08768473194635751, 0.07946556536611116, 0.02571635917710413, 0.07495326033444649, 0.05376498721930789, 0.06821754971647587, 0.3519736866669744, 0.3437039159629569, 0.3501895421033875, 0.3372477614794376, 0.3331086695434089, 0.33759867466385785, 0.3535852260801403, 0.37067893173010846, 0.3443693285883943, 0.0906830029790624, 0.1327063861798511, 0.10505889630764109, 0.11765120688323982, 0.12490827531118265, 0.12547814929024081, 0.1411643895936242, 0.1004095964932139, 0.0267656688986897, 0.19225357799723508, 0.21085975627234144, 0.14598438386171186, 0.1536676892382236, 0.1530431114017894, 0.1621996520918112, 0.1520147757655066, 0.13899982109214992, 0.12827477143352028, 0.2614456857952797, 0.2790994477869756, 0.22105949172359274, 0.23856635407564775, 0.24294038660463624, 0.2596689439676748, 0.2160287335838914, 0.21616820816025006, 0.20594401354615988, 0.19265655816669902, 0.2021192265002426, 0.20427571460608185, 0.20713800667688187, 0.20540387152564166, 0.1992131102866791, 0.17082875702488032, 0.1710902492524209, 0.1659189893331311, 0.2902576708894724, 0.22564348630303366, 0.23882041834843193, 0.2341588841407518, 0.22245684730261006, 0.2497732972868033, 0.20662588477129207, 0.22883358220394534, 0.2127751665133959, 0.1737090327758244, 0.1745750533385546, 0.17176354415905704, 0.2070909108629434, 0.1836555989345937, 0.16827429110487535, 0.17593602701684996, 0.16770465222027742, 0.1728990206986949, 0.18372369968635527, 0.1839699448729809, 0.15132951877131706, 0.467709603885508, 0.1207914665021157, 0.1545796137800899, 0.4350023135453974, 0.20333037394474973, 0.1649368542724251, 0.5041433964373522, 0.19816404283864775, 0.34755967259113196, 0.195421644490557, 0.14403898020389772, 0.19788508177757214, 0.10372248513788784, 0.16336650675368547, 0.2812198215124051, 0.18446951066227513, 0.17267879755437243, 0.20526431006701473, 0.1804779332441543, 0.18601944080995192, 0.17891339165867326, 0.1839536913851163, 0.18707191124762523, 0.19666731538760407, 0.09535103033897796, 0.1107251757311728, 0.0896267375575851, 0.11859237722258953, 0.07465877369674179, 0.09168030507966995, 0.09330361812395604, 0.10324671549585818, 0.10197982683591778]}, "mutation_prompt": null}
{"id": "bf3b4a76-65ee-43d6-95e7-78e9e33a7590", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n                \n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                if func(crossover_vector) < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget))\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            # Modified mutation factor adaptation with random oscillation\n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + np.random.uniform(0.01, 0.02))\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3", "description": "Introduced randomized adaptive mutation factor oscillation to enhance exploration-exploitation balance.", "configspace": "", "generation": 91, "fitness": 0.1889056149986393, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "metadata": {"aucs": [0.39353311125773693, 0.33791307153463135, 0.3565198519165077, 0.3594631824610679, 0.3582829778723169, 0.3281578182913779, 0.3541481265032257, 0.3573017148130685, 0.3553353537484202, 0.012624989723869162, 0.03141138998458448, 0.05836391056583945, 0.05492973692677949, 0.05937892623235386, 0.00012274856235305887, 0.05210076466090763, 0.0015928844496259087, 9.999999999998899e-05, 0.09752307759413037, 0.13491139709665112, 0.1326540894049003, 0.11285462986073413, 0.11349521347183344, 0.11281055991974409, 0.09818241361143665, 0.09779074742541338, 0.10411365144845297, 0.07797564225805076, 0.08152564676381502, 0.06530327771931499, 0.08705241037716827, 0.0856854142110155, 0.05883316487697465, 0.09809676381720434, 0.07368456008472768, 0.08481874130910605, 0.8898921134826835, 0.9007852482986745, 0.9401495223937913, 0.8311722871907786, 0.8759769289770568, 0.8692072240150408, 0.8372898352301847, 0.8688960865608485, 0.8889851114687184, 0.21757554579707916, 0.231529336830128, 0.1963790351633753, 0.23140030488246133, 0.24220544415275425, 0.18694909205181676, 0.20287217373752375, 0.2328799067558237, 0.21242329273956395, 0.22652965422476068, 0.11766947915317871, 0.21019462283797696, 0.20204957984034144, 0.20560081812170572, 0.20320376076537117, 0.16591265210369, 0.19945231630071047, 0.18968748072365493, 0.13293355859552392, 0.1214870091350213, 0.11810855878797588, 0.11797123102371732, 0.1295233836272024, 0.08385356762637475, 0.12168994299289693, 0.11271740190256985, 0.11865499415545333, 0.1681056705703624, 0.12484349748788115, 0.1241853022103796, 0.11757552291487516, 0.12131529048369083, 0.12172454525994403, 0.12284638043492635, 0.1196415411618178, 0.11814550324304762, 0.000497215504118298, 0.0035268933807834912, 0.03399383003545664, 0.008009002666880982, 0.0006882715248855975, 0.00022327180954240244, 9.999999999998899e-05, 0.012897756446482944, 0.029637424398303303, 0.14948461101753496, 0.056423015016540234, 0.16768545374832888, 0.09528825607388902, 0.06569386524426113, 0.046221826786866815, 0.12241260850766067, 0.06747717042468104, 0.10414398665982694, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05694189016658857, 0.059682360943027035, 0.09583498492614162, 0.07559851841609411, 0.08146575889998298, 0.05459856391866291, 0.05760854632740953, 0.04618598116468753, 0.05187395384981697, 0.3332180330896478, 0.3308459234588954, 0.38537844826025625, 0.3362119664061237, 0.35588425157504333, 0.3468594968617561, 0.3431124321434874, 0.3837878544680394, 0.3345140576171658, 0.10184230284915952, 0.1640946709079617, 0.11545270232422988, 0.13680164528654748, 0.12369892256132953, 0.09853992358609343, 0.13473600158193966, 0.09063364037094634, 0.12403576289427387, 0.17062025364994493, 0.24836933811257955, 0.1397765426440647, 0.1596671470294454, 0.15099998452564556, 0.1954149131214249, 0.16808797994409574, 0.15295503669458066, 0.1381719346647784, 0.25475758734838516, 0.24829398641147615, 0.2465801687527016, 0.26729367042518715, 0.21905923124580517, 0.2556147081760184, 0.2227396684584898, 0.21826770083097125, 0.19207657660718647, 0.1752724470578878, 0.21553458712804408, 0.2220354617606457, 0.2018232995116186, 0.21240617500409376, 0.186622492317699, 0.18341280441517815, 0.17682170587730028, 0.17186886254533762, 0.24890866702038228, 0.2405837563474228, 0.21570817108453877, 0.2501484196129483, 0.225605074725585, 0.22193452997287566, 0.23450515829693386, 0.22616335436512758, 0.24842693550993422, 0.17476284450645674, 0.17101086284604683, 0.17274342036993073, 0.19534523435855466, 0.1834959237455971, 0.16800673022234336, 0.17620188657710933, 0.17014248937905618, 0.17301294395277123, 0.18309773446549438, 0.18441740399400508, 0.1499737354748255, 0.4791915481874848, 0.1969433932379112, 0.12857777373523727, 0.4691764708277213, 0.2034213659373203, 0.1660723169675512, 0.5176187300032284, 0.20272961314312932, 0.4147368744865274, 0.1935229517115734, 0.14039677759396363, 0.19706729218477448, 0.10427647874372292, 0.15966126129595593, 0.2813788262334397, 0.2143152072972957, 0.17815365267922678, 0.19458179010200216, 0.19249935572566812, 0.18848123161117736, 0.1786022783964969, 0.19105403549228017, 0.20391368340856375, 0.1876747926870147, 0.09834220113387726, 0.11423824400794969, 0.0915320626528977, 0.10768030774314152, 0.09304618308961399, 0.08494739487483005, 0.08944880881489281, 0.09389321031036635, 0.0921704140306816]}, "mutation_prompt": null}
{"id": "0e20ddb3-4adb-49d4-8570-75e506d96e84", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                new_fitness = func(crossover_vector)\n                if new_fitness < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    self.mutation_factor *= 1.001  # Slightly increase mutation factor if improvement is made\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1.5 - avg_diversity / self.dim)\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2", "description": "Introduced a dynamic mutation factor scaling based on fitness improvement and adjusted the learning rate update mechanism for improved convergence.", "configspace": "", "generation": 92, "fitness": 0.18978403836093496, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V7_Improved_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "39f5ea27-1e82-4b7b-84ad-96701b49dc44", "metadata": {"aucs": [0.3380424633941892, 0.34326164133139814, 0.34966050755927836, 0.3557650867308828, 0.34169271297337056, 0.36029066455103564, 0.3578341043201564, 0.34336939770325203, 0.3464904981365049, 0.07874974871376927, 0.06931277941077496, 0.0012159551526361723, 0.06363827603989591, 0.04028825746799425, 0.008412628140627931, 0.03055198184145247, 0.01191898452484419, 0.0003701504515329912, 0.1166337549974209, 0.08418290115089733, 0.08814330053701303, 0.1261221585466803, 0.12049586915030597, 0.11945402504532376, 0.07870704358312142, 0.10915324956084116, 0.12681976554389007, 0.08543187877395064, 0.08820483323901263, 0.06888817264505409, 0.08980750776017432, 0.07125941615181486, 0.08224853840840518, 0.08225253561763746, 0.08488794058479221, 0.07024850578178776, 0.9141867275616522, 0.9193932550017967, 0.9057633931802306, 0.8717912097697816, 0.8755256257846313, 0.8673502994518711, 0.8641919543609602, 0.8487131075267562, 0.8913344596047351, 0.24919672072033094, 0.23178556011482554, 0.2355611586930383, 0.23294806767779108, 0.26060176644863553, 0.20939609275981008, 0.21352966899532322, 0.2328957261215313, 0.2115477189183118, 0.2111729029663103, 0.1600343835501793, 0.20418370844229639, 0.20698977657733875, 0.28903264230724934, 0.20447942048611478, 0.15931628376001516, 0.18373853033605547, 0.19086416660442096, 0.16441305762365432, 0.11988680283539122, 0.11926054166808464, 0.14731006470813224, 0.1171912283125559, 0.09246835213995186, 0.11945553980957868, 0.1238408237077483, 0.1312862218301174, 0.1332210638574054, 0.12091147861961349, 0.10365216904362073, 0.12787181282963156, 0.14828998402769888, 0.1141464821292828, 0.13912501557549672, 0.17175678168808173, 0.12233612452189369, 9.999999999998899e-05, 0.018931402865741465, 0.00023940618852380524, 0.00035328097426334804, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015991960948841588, 0.1427378085704426, 0.07085588616373584, 0.19869821289264789, 0.07058207598888588, 0.08508621037764275, 0.04831205799311833, 0.1145563477571041, 0.07240113814183202, 0.09523915529048177, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06932693653071997, 0.054948612535064556, 0.061233952561469907, 0.07739186672622966, 0.07872907050495581, 0.06366593136456322, 0.05878159396850735, 0.05839863273494739, 0.0642687432495288, 0.3725292542965434, 0.36952182635434505, 0.36040944395528984, 0.33078094710727013, 0.3533676252984981, 0.34876739704074655, 0.3611117624934471, 0.34226422441766413, 0.3380210968826416, 0.1129916483022142, 0.1026893364889937, 0.110264234117178, 0.17182606737976802, 0.09983345116349795, 0.13517694615957987, 0.10535970076727175, 0.09690394015320103, 0.1106307370045212, 0.1576220175104529, 0.19821683966446013, 0.18411801579660692, 0.19632771205096655, 0.19241610764615968, 0.1449598345443437, 0.20735716263644255, 0.18705652406197704, 0.2144360750700477, 0.270012276936472, 0.2495810196863587, 0.1901392462887851, 0.25806595447246083, 0.26893120031208795, 0.2514413768296898, 0.21883912907259506, 0.21389544688339535, 0.19128844631476916, 0.17971843429659418, 0.20216421300328313, 0.19802975116265764, 0.1948988544471949, 0.20875282699022635, 0.18897939162294364, 0.17589237131751723, 0.168198900740408, 0.18145203325906756, 0.27060606341709803, 0.2333611863816355, 0.22040838640879223, 0.2249439235354923, 0.2574479410067422, 0.217770212293532, 0.22052599481151058, 0.25647176007715067, 0.209238582913854, 0.19012753359174817, 0.17228188231651187, 0.1786857643322286, 0.1958681811727513, 0.17685604156699974, 0.17275258678909777, 0.17240212617193973, 0.1791654034150164, 0.17504049010195266, 0.18416577096680498, 0.18549607343122576, 0.1459632282489114, 0.45229311945914186, 0.1975027644958346, 0.15675755387916213, 0.1527261042022645, 0.20517693328050568, 0.16710582212496594, 0.44943638527821517, 0.20084846317615324, 0.4152222755369609, 0.19536925561677365, 0.14487421698188685, 0.19789351548052414, 0.3296531786925361, 0.16338681864292648, 0.2618028605414501, 0.17703041365273053, 0.17946187810119973, 0.19823724900309803, 0.17454923453976623, 0.18211811542689427, 0.19049116271146393, 0.19303633328627556, 0.18043650191224514, 0.19404069640381616, 0.10304409905480338, 0.1161528337098634, 0.09224121189480772, 0.10386764297452777, 0.09357999651035331, 0.07921480047056195, 0.09227309776665682, 0.09012139544398956, 0.09070102825706694]}, "mutation_prompt": null}
{"id": "0d80042b-5925-4e33-aa83-bbbd1ba67740", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        momentum_decay = 0.98\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                new_fitness = func(crossover_vector)\n                if new_fitness < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    self.mutation_factor *= 1.002  # Slightly adjusted mutation factor increment\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1.5 - avg_diversity / self.dim)\n            learning_rate *= momentum_decay  # Added momentum decay to learning rate\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V8", "description": "Introduced a momentum decay to the learning rate for smoother convergence and slightly adjusted mutation factor increment.", "configspace": "", "generation": 93, "fitness": 0.1898041803377821, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V8 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "0e20ddb3-4adb-49d4-8570-75e506d96e84", "metadata": {"aucs": [0.33531214549751176, 0.3458847001606563, 0.3536305562080403, 0.3554726905194098, 0.33493482495913973, 0.4097485572155356, 0.3464260079031749, 0.3535368060946362, 0.3380688022328384, 0.05707638250149538, 0.08992633634928426, 0.011734167003186635, 0.048184026333801144, 0.0786353683615052, 0.005258353045827446, 0.010468828383703666, 0.021564484818667573, 9.999999999998899e-05, 0.09481761488388907, 0.10572042713793983, 0.11513669283122685, 0.13745046816704776, 0.11698338945365994, 0.10779799878035068, 0.07479732237210923, 0.11076324112968527, 0.1182893589952686, 0.07914800273397482, 0.08429100131678802, 0.06688359281085032, 0.10642167309889028, 0.08449486770297587, 0.0610432142719195, 0.10259321645081332, 0.07078876600469863, 0.09181315874509932, 0.9135534444646072, 0.9130227570984573, 0.9058724979025456, 0.8714372815420471, 0.8747817075651524, 0.8686924268376109, 0.865526854614097, 0.8489070349614667, 0.8918688921576567, 0.2565412166807043, 0.22838311151325452, 0.22441397407116503, 0.2204100294964162, 0.24766506517911346, 0.20787420610994134, 0.2402751088883428, 0.2325287119630467, 0.21871645696519015, 0.2103184506310618, 0.13143526655800775, 0.19673860381723407, 0.20347443682692135, 0.1914195955840562, 0.20675469571906147, 0.15286822563162128, 0.18730888298883175, 0.24608364260501558, 0.15722950020303306, 0.11595429885057418, 0.11932987057251887, 0.09168953324876516, 0.12843309630195332, 0.14095186875584453, 0.12182629465581007, 0.11860311301172166, 0.11936111331385912, 0.14330615762252652, 0.12028576428700488, 0.09805697539796998, 0.12508951273454072, 0.15426376006809273, 0.13154593916308444, 0.13900519925447474, 0.13173094473266678, 0.12391949685100068, 9.999999999998899e-05, 0.007809929483874489, 0.00012714385858758614, 0.01769787293522973, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00020834297057148454, 0.00425339048695228, 0.1465247652421252, 0.08683778215940563, 0.18654941857463025, 0.06887921768106697, 0.0827171893398565, 0.0512105736909052, 0.12663287958186464, 0.061436360038181204, 0.07638517054460159, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06433088073657522, 0.05302901839754848, 0.05942791507956424, 0.08564599998646283, 0.06912852074611087, 0.06275041529625847, 0.06100208109394467, 0.05818869083571132, 0.05912898925542154, 0.43816967639617643, 0.3495859355118982, 0.3726236040217954, 0.36125559418983655, 0.3407462044588059, 0.34942806354746725, 0.3340461446943538, 0.34482018559456795, 0.33035440418084194, 0.08555395460299497, 0.12806621283529496, 0.12056022029781399, 0.12995918120840066, 0.11657812077280028, 0.12123374082666194, 0.12265222311405322, 0.10820118235872833, 0.10667833029337548, 0.14189072427355698, 0.22786998939095116, 0.12598293425856222, 0.14126798030745324, 0.19182910190512947, 0.16321322878054145, 0.1728279263337772, 0.21980985130804054, 0.16311840534764976, 0.26271376625724674, 0.2669992955922016, 0.21702105631766289, 0.2795738445771473, 0.24646197975570794, 0.24177004552533932, 0.20192184006680702, 0.20433733407478916, 0.20188692846106548, 0.20793704474268238, 0.19673207497292233, 0.20035967843643632, 0.21107743478537644, 0.2025119683345924, 0.19856664298068816, 0.18669946634202927, 0.17463189198125673, 0.1784556890043918, 0.22263269176302602, 0.2532030450062245, 0.24148756178484054, 0.2179135766368504, 0.22571102813162602, 0.24241818445920893, 0.22718735299300952, 0.2238673658396677, 0.23704145182596315, 0.1752847524327863, 0.1753776529015929, 0.1953544722581998, 0.1841257650864736, 0.19531838285215009, 0.16833988782036158, 0.17375718510116545, 0.16974640448368572, 0.17444080272318208, 0.1833229497458505, 0.18551618110341994, 0.1805714057225679, 0.4605733336525397, 0.19449653321465366, 0.15780100608012415, 0.14382218145542103, 0.20495738350409187, 0.16738775337649625, 0.4857349408972488, 0.20176201862061904, 0.4334155141348325, 0.19578507007681545, 0.14540680912757276, 0.19998360065887388, 0.33090410193125197, 0.1623985954394357, 0.2628920331155883, 0.18007086897797286, 0.19167605860844272, 0.1994151638455789, 0.19012412874457918, 0.17985148152432262, 0.18888896441378633, 0.18488303346016677, 0.1911722274987332, 0.1964299142693925, 0.09623949535360732, 0.1092343860451992, 0.0869638140100506, 0.11232957027204515, 0.08806807407909423, 0.08587912800509112, 0.08540217502891989, 0.09171648637831586, 0.09758329357922646]}, "mutation_prompt": null}
{"id": "80fd4d73-edd6-4a62-856d-f89dbc062eae", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V9:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n        self.previous_best_fitness = np.inf\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        momentum_decay = 0.98\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n        fitness_improvement_threshold = 0.005\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n            \n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                new_fitness = func(crossover_vector)\n                if new_fitness < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    fitness_improvement = (self.previous_best_fitness - self.best_fitness) / self.previous_best_fitness\n                    if fitness_improvement > fitness_improvement_threshold:\n                        self.mutation_factor *= 1.002  # Adjust based on recent improvement\n                    else:\n                        self.mutation_factor *= 0.998  # Reduce if no significant improvement\n                    \n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1.5 - avg_diversity / self.dim)\n            learning_rate *= momentum_decay\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n            self.previous_best_fitness = self.best_fitness\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V9", "description": "Introduced a dynamic mutation factor adjustment based on recent fitness improvements to enhance exploration-exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.18772603998933216, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V9 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "0d80042b-5925-4e33-aa83-bbbd1ba67740", "metadata": {"aucs": [0.3290570333626148, 0.34879700441650396, 0.35107621572195635, 0.33188305707083776, 0.37754874894499035, 0.3398066577177955, 0.3496081119898379, 0.36382132919284826, 0.3465276848373924, 0.061002931890051904, 0.06645383737320332, 0.05060740916215223, 0.012522871387133039, 0.03647689461008363, 0.027074145145913442, 0.011972968871191925, 0.006324237629870555, 9.999999999998899e-05, 0.11098734957107248, 0.08739158666418567, 0.11956960802377925, 0.1259681225972894, 0.10957031986739951, 0.10934836410887205, 0.09064585199197484, 0.1049507212759716, 0.11430192964124086, 0.09583409844302548, 0.08162426940746226, 0.06440264051535283, 0.08750152269538325, 0.06811496146612794, 0.0795031340008745, 0.0890521074765076, 0.06308557571768669, 0.08238155809589409, 0.9122622938720947, 0.90229755631882, 0.939372754816075, 0.8241172167024179, 0.8761970208339438, 0.8655843419070266, 0.8652258256795728, 0.84805402951864, 0.8917367580878559, 0.26052629274578953, 0.2279746150148807, 0.25148727173833973, 0.24860408882372587, 0.24637185733597788, 0.2358847867673195, 0.2453165513729343, 0.20373622553976012, 0.26888999382272305, 0.21267132408361833, 0.13143526655800775, 0.19548157201720906, 0.20603849534274465, 0.22821948027421068, 0.20360540681742112, 0.15463340958168736, 0.17031449905388762, 0.2041888367766379, 0.16579281030244497, 0.11876122362799268, 0.11349300602197343, 0.10200030953754924, 0.13528172298392638, 0.09141918992500941, 0.12891456874006402, 0.1318864298906237, 0.1269818198981899, 0.14184261088622785, 0.11755745702936549, 0.10060049741285748, 0.12438621003291805, 0.14853862628085157, 0.12355102692137321, 0.1270245863143622, 0.11841835205803941, 0.11433805646931738, 0.008938020331040408, 0.013649841028072651, 9.999999999998899e-05, 0.01232163862399216, 0.0037110380524453257, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038299392585268155, 0.0006357100704753593, 0.14023751336834178, 0.07579946866100618, 0.1972246418984568, 0.06658075981487654, 0.08308972876950249, 0.045209999544378876, 0.11346353556376632, 0.0793678417819883, 0.07047340601153007, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056208668947622775, 0.05268908244054238, 0.05572348105795555, 0.06965899322114566, 0.07592026708047561, 0.062475195603532874, 0.05604708018803062, 0.048878099059002644, 0.06357285346797303, 0.3457213761419894, 0.35342119107729264, 0.3465635192697136, 0.3304729390692507, 0.3540379667652577, 0.3541848843197922, 0.3620249722229366, 0.35202220000602835, 0.3378020363228875, 0.10059261474109749, 0.10026379670911267, 0.11642422990152823, 0.11473182705601248, 0.11484270996438595, 0.12001371278330075, 0.1092596712989975, 0.09057067541425878, 0.11929679177340713, 0.15439067382833127, 0.1472091769114715, 0.13148032061308024, 0.19038523049127054, 0.1668778935887023, 0.16206270393237032, 0.1526937120657914, 0.13949312800667502, 0.15142943508386564, 0.2626300791862204, 0.25212805220712864, 0.24431713757855766, 0.2608058080872009, 0.2773472498307723, 0.25768879623067786, 0.23089695901507945, 0.2196732777734195, 0.23102997103690037, 0.19076572207484854, 0.2115382184229131, 0.18064451662867487, 0.1969370799325728, 0.21070917849332804, 0.19318859819334855, 0.1778351697081778, 0.1518524839914338, 0.17534979527921257, 0.2287395608821473, 0.23816414334943725, 0.21456319013193714, 0.24002737831237886, 0.22054024312356857, 0.23813794640419383, 0.2121796208535176, 0.24134687011059508, 0.234395774578267, 0.16541007592581936, 0.17142145145219223, 0.17095036230643967, 0.2028726736788643, 0.18046327521997552, 0.17366214557719217, 0.17086497282686064, 0.17163797203165143, 0.17798865452599222, 0.18342684509890506, 0.18552342383852838, 0.18181737890939298, 0.4752788680870008, 0.1932922362986117, 0.15741386834021032, 0.14084518615644015, 0.20703373894369537, 0.15982784848573084, 0.48448221227013033, 0.2017235462297169, 0.4267494996868776, 0.19642093958086404, 0.14719993312720603, 0.19858332361497, 0.32136313496087865, 0.16253056571190083, 0.27047483072167, 0.20089111257948333, 0.18248924056257887, 0.1820799334834814, 0.18232770648550045, 0.1811115528517121, 0.1854837854468916, 0.18002877575779075, 0.1734160221119695, 0.1921653813696821, 0.10759539125383921, 0.13630392336038255, 0.09259793212305523, 0.10302714157088033, 0.09276451229987526, 0.10090451210236628, 0.09122606677392309, 0.08586470691067538, 0.0847678258030573]}, "mutation_prompt": null}
{"id": "fb41eec6-5854-4597-ad6b-f2941f2154c6", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V9:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        momentum_decay = 0.98\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n        successful_mutations = 0\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            success_rate = successful_mutations / (self.population_size if successful_mutations > 0 else 1)\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n            noise_scale_factor *= (0.8 + 0.4 * success_rate)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                new_fitness = func(crossover_vector)\n                if new_fitness < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    successful_mutations += 1\n                    self.mutation_factor *= 1.002\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1.5 - avg_diversity / self.dim)\n            learning_rate *= momentum_decay\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V9", "description": "Introduced adaptive noise scaling based on success rate to enhance exploration-exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.1715652243856558, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V9 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "0d80042b-5925-4e33-aa83-bbbd1ba67740", "metadata": {"aucs": [0.3205400208792396, 0.30189979439429704, 0.3530810584380052, 0.25656294162318494, 0.29024971955287937, 0.30028726262522754, 0.28180938172510783, 0.33300359900102294, 0.29322157240608515, 0.028327923346570194, 0.017771231124141362, 0.00013052964916748788, 0.006400514759876241, 0.01627957698081095, 0.029453755062970544, 9.999999999998899e-05, 0.024436347057099406, 0.01119491176047449, 0.1150701181420174, 0.08888036672443778, 0.09573550332330683, 0.08288008481684506, 0.08245581438992744, 0.1013468863370185, 0.08960436417403417, 0.0905782059799165, 0.09320574814904392, 0.06590753055338716, 0.05743532198338963, 0.056254797270949175, 0.08127556290669091, 0.056354656628217925, 0.07251184793148346, 0.0741755573587588, 0.05746784332295407, 0.05508475433298443, 0.9593638716489932, 0.9516888422022801, 0.9420119111006273, 0.9420124482566241, 0.9428642126656257, 0.9845137662769498, 0.9327974691595722, 0.9656333807027467, 0.9746457774313335, 0.1385499573658937, 0.13438042264187566, 0.13507935209588917, 0.155918240885637, 0.1633276711834586, 0.16166610635608758, 0.15314940436798985, 0.15266005938292782, 0.14638885871040552, 0.1824312329628246, 0.16140956528465722, 0.17380187510311484, 0.18250379164918873, 0.18422920967161005, 0.19059638001571688, 0.15537061010241737, 0.16880051867244017, 0.16785911895777694, 0.1597550006518913, 0.09397910680697474, 0.07478178378658795, 0.08032127822903368, 0.10138961037787286, 0.09518370351285177, 0.08223327404887515, 0.09706834320063351, 0.12194249872336749, 0.14787095917482662, 0.11036745006037108, 0.10152179142047368, 0.13306339812154933, 0.12471908061214276, 0.09601797781562671, 0.1449149563963521, 0.08704608546789205, 0.0959976431595343, 0.008291375188740124, 9.999999999998899e-05, 0.04437845905714444, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033514306919690817, 0.11116697210669757, 0.0751780606101855, 0.16000257515422545, 0.06830654287674132, 0.08296108290858939, 0.050016205199911234, 0.0995346490996093, 0.09082062350494613, 0.07464970437164542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0658610032733099, 0.0494626114569523, 0.032447727264856785, 0.03240743666430701, 0.04221006819285944, 0.02506394391446287, 0.021915250171675837, 0.03635948726504035, 0.03299652175568013, 0.374076143813716, 0.3107852875043994, 0.30600195419093434, 0.2891658165403629, 0.294998223846902, 0.3163847979951344, 0.3043134886999346, 0.32938411488176667, 0.32566901350136, 0.09694404362939146, 0.06984602795568806, 0.07803555803436735, 0.10400443250250013, 0.0870549657684635, 0.10075072151423192, 0.1029364249650172, 0.08307316008817578, 0.09261377767993584, 0.1342231330583985, 0.12705382218659178, 0.13616279926205244, 0.14233821202930252, 0.12908032502737388, 0.13273016016147554, 0.1330164017722565, 0.12429676533151102, 0.14198615490698263, 0.1941255413014792, 0.20295439203541799, 0.20240862092084033, 0.19051598671380765, 0.20829020037696666, 0.21332137413173757, 0.2189334758174788, 0.2161357483865205, 0.20177875420691305, 0.1573238417582672, 0.18429960224517405, 0.14835691041148424, 0.15311566893728645, 0.16183747827467998, 0.1700639103566426, 0.14696876967678074, 0.14107446935894918, 0.14495537722010854, 0.23709001676991215, 0.24475519494137798, 0.21645017790353505, 0.24108359953541936, 0.254416484026328, 0.23847750780019117, 0.2511747989491091, 0.2096622265073853, 0.24319354647921354, 0.16877981529469877, 0.17067922315455086, 0.16245997941504886, 0.16614716158516607, 0.17566063984187663, 0.15997535649490635, 0.1659800925602649, 0.16567205552603337, 0.16850238006670826, 0.18061983061246079, 0.18461573636740636, 0.14098637203899567, 0.198752584184699, 0.17877627604440005, 0.16590302584889727, 0.16482993835183568, 0.11365989015068334, 0.1781328924568446, 0.41270836066627525, 0.19067163704532408, 0.28880913379376294, 0.1934736854938427, 0.1346394240027059, 0.18091049682151317, 0.3392378748018696, 0.2513538880843016, 0.24361994660099517, 0.18047097984164284, 0.18732518183066504, 0.18267810522353112, 0.17723008762491876, 0.18607578892440346, 0.1991769292599992, 0.19593189835676705, 0.18112499826185324, 0.20845754967517116, 0.0926038205994284, 0.13614067717160017, 0.09197126144502255, 0.12472214088100742, 0.09199699067715705, 0.09494780584525597, 0.10015369370702698, 0.08821553194006992, 0.0919330949762367]}, "mutation_prompt": null}
{"id": "1fa4e86e-d545-4a88-a783-b30c94511eb9", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V9:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        momentum_decay = 0.98\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                new_fitness = func(crossover_vector)\n                if new_fitness < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    self.mutation_factor *= 1.002 + 0.0005 * variance_factor  # Slightly adjusted mutation factor increment\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1.5 - avg_diversity / self.dim)\n            learning_rate *= momentum_decay  # Added momentum decay to learning rate\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V9", "description": "Introduced an adaptive mutation factor scaling based on population variance to enhance exploration in initial stages and improve convergence speed.", "configspace": "", "generation": 96, "fitness": 0.18847341488995, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V9 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "0d80042b-5925-4e33-aa83-bbbd1ba67740", "metadata": {"aucs": [0.3422962555051222, 0.3460104073111384, 0.3639574041336556, 0.35586873108469885, 0.3246481178093379, 0.4106065240947492, 0.3552538686625165, 0.351113659992098, 0.3384145520949955, 0.08429150511810424, 0.056984770874673685, 0.009220452141115443, 0.029377524174061587, 0.04253150057458022, 0.004771153831882313, 0.010577214000218715, 0.03758986361813277, 9.999999999998899e-05, 0.08203522697687404, 0.1021061742417747, 0.10920978465650111, 0.14559821090220681, 0.13969965026840603, 0.10675367602932606, 0.08270556566432974, 0.11947086765325732, 0.11075542437444141, 0.08156551114284827, 0.08541433460546155, 0.07268757006817883, 0.08133169112816963, 0.07114584326320816, 0.06700059359131794, 0.09284516527491082, 0.07550773573327929, 0.09463495954010892, 0.9135356793899506, 0.9022729858236881, 0.905543283947803, 0.8715625474579762, 0.8757351178695725, 0.8694812911098821, 0.8662208819051149, 0.8495638063185891, 0.8914680549705143, 0.2310630715290385, 0.1940246852007621, 0.22336325897827125, 0.23462820682173813, 0.273720698091507, 0.2240373810434707, 0.22297590795272504, 0.210792410278282, 0.2177215249402158, 0.21010093181601164, 0.13143526655800775, 0.1950738770909748, 0.20186214636011302, 0.20829816081891273, 0.20954177084064662, 0.162289142177939, 0.19065135268440492, 0.20002552545623897, 0.1565676147047812, 0.11588711844418009, 0.12324891106469271, 0.0916461511105443, 0.1283447703496009, 0.1415232549086486, 0.12350121455886287, 0.1180799996260199, 0.126097780243124, 0.14351758949341042, 0.1243978539298094, 0.09960524459410314, 0.12507307524154365, 0.14065822001832817, 0.1312686888889335, 0.1277702319339945, 0.13179224915920407, 0.12096130781711123, 9.999999999998899e-05, 0.007629408585132613, 0.0032424737354688205, 0.016444160662394958, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0038526759173042047, 9.999999999998899e-05, 0.14444571892596492, 0.08388923630449541, 0.1965978664804564, 0.06593109762954441, 0.08143241126307443, 0.045312304006393966, 0.1209625044790873, 0.06775631362162149, 0.07460195093542699, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0658770536230795, 0.053204328490808805, 0.05960549060336817, 0.0778949060211378, 0.06982040873717921, 0.0625658263209965, 0.062094043857323755, 0.05949046866256791, 0.05652201255954481, 0.43460894885129486, 0.34929087461703423, 0.35339810015322337, 0.34369848632687994, 0.3276357124393663, 0.34522545176579633, 0.33274318048650964, 0.3481244713746149, 0.3362455645331732, 0.1037213265400091, 0.13268942214329205, 0.10305482375450958, 0.1156467034295311, 0.11569519340594159, 0.10382360128203494, 0.13628562926544396, 0.11656698361657292, 0.09393332185754666, 0.1519840930909533, 0.21806809857444287, 0.12392492674330335, 0.20644878037564662, 0.19851681533406995, 0.12830749288039844, 0.18043046600852353, 0.20646233984964135, 0.1527276204806729, 0.257252695078275, 0.25755740762262935, 0.24777093041357257, 0.2705240933633464, 0.2620991433228531, 0.2579611748968752, 0.20548387863203288, 0.21482841066713554, 0.2068740846282321, 0.1735121594244311, 0.2015786226259293, 0.20645726289174304, 0.2031307833057847, 0.20377375924692076, 0.22385262225715008, 0.17161471970253583, 0.1675618256894773, 0.16940030325674382, 0.22241955916810752, 0.2460295107809316, 0.20917187535793702, 0.21958343018027449, 0.23720081904242185, 0.2026903725405057, 0.23112498598473952, 0.23755598308389025, 0.21211670790908743, 0.1943376841099056, 0.1710666893695878, 0.17050730990106477, 0.17908170256046996, 0.17469921247987752, 0.16882495899673944, 0.17183061132718846, 0.1706265591804753, 0.17853250611045224, 0.18327058952137942, 0.1859619573845791, 0.18049922186877143, 0.46177869017042417, 0.19447170883704712, 0.15780951952137134, 0.1497120105396954, 0.20507284120675628, 0.16739126718449748, 0.49490622473102863, 0.202573863304633, 0.4316881926133772, 0.19563930506780025, 0.14491066883128312, 0.19905014203902482, 0.3308894446709967, 0.1624285891518048, 0.26300464084598396, 0.17209453200760072, 0.19355344628275217, 0.18770935892711327, 0.1841661031165509, 0.17205160808425168, 0.21103391607722255, 0.1818041974352449, 0.1769945579242973, 0.1786684553538015, 0.09980303053780826, 0.13180405903380366, 0.0948431501374678, 0.10694158628258577, 0.09101397979422687, 0.08555413147899926, 0.08153832494446689, 0.08015451854847466, 0.08999260340502968]}, "mutation_prompt": null}
{"id": "9136c223-9422-4477-bc0c-8ac7efc3bf4d", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V8_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        momentum_decay = 0.98\n        diversity_threshold = 0.12\n        decay_rate = 0.991  # Increased decay rate slightly from 0.99 to 0.991\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                new_fitness = func(crossover_vector)\n                if new_fitness < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    self.mutation_factor *= 1.002\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1.5 - avg_diversity / self.dim)\n            learning_rate *= momentum_decay\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V8_Improved", "description": "Slightly increased the mutation factor decay rate to improve convergence speed by reducing the mutation factor more quickly as evaluations progress.", "configspace": "", "generation": 97, "fitness": 0.18867986810810164, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V8_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "0d80042b-5925-4e33-aa83-bbbd1ba67740", "metadata": {"aucs": [0.34294456088218805, 0.34639565039270903, 0.35785608849562, 0.35363010039530496, 0.33132574358030453, 0.37765360721609265, 0.3607451682688695, 0.3452711012765609, 0.33881832597283235, 0.027327378409135017, 0.06575527768713707, 0.04120483868939118, 0.02303549105962066, 0.04318127328901211, 0.007303253211618954, 0.011750340721926156, 0.02392018145848307, 9.999999999998899e-05, 0.09989221427025208, 0.10256529937735814, 0.10421510982883597, 0.12021762291322158, 0.1139993225926339, 0.10612196233769633, 0.07787907942522143, 0.10998007974936919, 0.10109000017301006, 0.09354893626968075, 0.10459578443239737, 0.06514535692698609, 0.08183153006629384, 0.08493740402383587, 0.055217932021652594, 0.09655374926522131, 0.07164558254907794, 0.09268827487262077, 0.9135431065634579, 0.9012801484054761, 0.905502275321448, 0.8712888608445318, 0.8757646530763256, 0.8700238191263698, 0.8672156448192486, 0.8492506001818143, 0.891903995954014, 0.22747072090982934, 0.2110484903112143, 0.22403106368325842, 0.2487909754290365, 0.2529694954878665, 0.20711948412577863, 0.23232456726900386, 0.2565276790761144, 0.21485752739421127, 0.20502723587152571, 0.13606581492876924, 0.19675358368123752, 0.20312437960621033, 0.20654534165072713, 0.20845869624502933, 0.16288669795012434, 0.168738310231333, 0.207298368139465, 0.15457717052425324, 0.12034595665426218, 0.11336860534897442, 0.1423185373099033, 0.12804331513624367, 0.14353076187121738, 0.12214250638880109, 0.11908179841384081, 0.12608513543396316, 0.1373681804803324, 0.12180378841981854, 0.09916344948631572, 0.12327991391486082, 0.14079351663371054, 0.13131255467924652, 0.15052227993129197, 0.12501724807677295, 0.12191255232011355, 9.999999999998899e-05, 0.006935861803017529, 0.012338093970620467, 0.010785279107532908, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0037821155511043036, 0.0021524804161641153, 0.1447680654793192, 0.080563277460457, 0.21964339180431458, 0.06884801423763387, 0.0867464732778197, 0.051254500661909286, 0.12195319133848082, 0.06068636596226973, 0.0987576836262486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06740994633193753, 0.053187857296226326, 0.05911297081706779, 0.06589797950277576, 0.07023801810456243, 0.05597225239280745, 0.062107525592575485, 0.045452213692120824, 0.05695957379388639, 0.436188462126579, 0.3510415778657068, 0.37125485861130314, 0.3471526860357548, 0.33094861228185335, 0.3265794462629814, 0.35287034946104245, 0.3491910230153673, 0.33781313265595325, 0.09363458970848382, 0.10669337740547469, 0.10118281410209906, 0.11233698667835201, 0.12653807051799737, 0.133126821161214, 0.11067552927515534, 0.09121939199367846, 0.11311584552986764, 0.1462797537629038, 0.23356365869256368, 0.14595464402232794, 0.22965162476083156, 0.17684864533867117, 0.1318096239356692, 0.15434237068201762, 0.19576122765469905, 0.14741809296824993, 0.2592507063925318, 0.2586434136783504, 0.24188297430622152, 0.25244640198105883, 0.2676111370399338, 0.2742265882322408, 0.21903704029898252, 0.2050718768849008, 0.2094295221663951, 0.17172469598899776, 0.19110549106632724, 0.21967204070783208, 0.19849932652347702, 0.20231084764798168, 0.1949644538849591, 0.1956673027054473, 0.1706340212950388, 0.1680779281450706, 0.20883395018079942, 0.23063648559061067, 0.22113836548971377, 0.22049400004658692, 0.22375680827044775, 0.23392112509883778, 0.22123950679077276, 0.23321844317888907, 0.23587939215017628, 0.17538489654607115, 0.17946046566206952, 0.17752566082339438, 0.1695705304148356, 0.1768786642869773, 0.1754174815803331, 0.17072045181674078, 0.17313631617801417, 0.1750218288843205, 0.1839712253308301, 0.18554102054767796, 0.18389254377843212, 0.4633364945926657, 0.19469175721792342, 0.1577135815343076, 0.1507404287129368, 0.20507831651698305, 0.16739311846341587, 0.5018555757157923, 0.202580100299792, 0.4303403587956952, 0.19446613054256323, 0.14447494852834408, 0.19914127499198886, 0.32144764121233516, 0.1624706108065015, 0.26166686880889933, 0.18050655725266607, 0.19934370592482908, 0.19060579914122167, 0.18218031671504553, 0.19354474349031514, 0.17743058648012322, 0.18591674837976369, 0.1736631129253423, 0.17945955728124063, 0.09987693808037601, 0.14605973402045325, 0.08611117489684261, 0.11559705580316493, 0.08716172507964892, 0.09592720290707002, 0.09130540685672828, 0.09153901927229746, 0.08846121037323662]}, "mutation_prompt": null}
{"id": "f9811af5-fc4c-41e3-8e7a-6f1541a281bc", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_V2_Enhanced_Modified_V8:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        momentum_decay = 0.98\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            gradient = (np.random.rand(self.dim) - 0.5) * 2  # Gradient-based scaling\n            mutation_scale = 1 + 0.1 * np.linalg.norm(gradient)\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = mutation_scale * (1 + (evals / self.budget) * (1 - avg_diversity / self.dim))\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                new_fitness = func(crossover_vector)\n                if new_fitness < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    self.mutation_factor *= 1.002\n                    if evals >= self.budget:\n                        break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1.5 - avg_diversity / self.dim)\n            learning_rate *= momentum_decay\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n            \n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_V2_Enhanced_Modified_V8", "description": "Introduced gradient-based mutation scaling for enhanced adaptability and convergence speed.", "configspace": "", "generation": 98, "fitness": 0.18470372085010492, "feedback": "The algorithm AdaptiveDE_CMA_V2_Enhanced_Modified_V8 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "0d80042b-5925-4e33-aa83-bbbd1ba67740", "metadata": {"aucs": [0.3731082784114145, 0.38884355736095955, 0.3755335378040998, 0.33520559635184644, 0.34030241421642626, 0.3622666359759149, 0.3904853614216126, 0.38768068794831645, 0.3447254311092658, 0.06614020886276084, 0.05407907321924099, 0.057478993597042116, 0.03296228708361537, 0.05025102292603112, 0.0005583544689973241, 0.002831336993216582, 0.05549532233519383, 9.999999999998899e-05, 0.07557231929241293, 0.09674471453821465, 0.07489128460531413, 0.11803849244686349, 0.11731251223822092, 0.0965166601309273, 0.08414045357738487, 0.08233001425917719, 0.12477353987432593, 0.0822909221773318, 0.07842986818039321, 0.07099539054358062, 0.09290018092681729, 0.09072360822695391, 0.0816776357426523, 0.07997647975765665, 0.09193378373294103, 0.09010707163322162, 0.9269996825226978, 0.8818116334198087, 0.8615411757775386, 0.8918866532868543, 0.8794199654692693, 0.8910370324881853, 0.8779468257484415, 0.8667412373887142, 0.9388870605001965, 0.22019151853464625, 0.2612871739781384, 0.20762279380790372, 0.2195692367438673, 0.22618754060026014, 0.21865428695996592, 0.27558083009794787, 0.21482056006616457, 0.2082854047451428, 0.22670835144518353, 0.14817650127708626, 0.15992343587515956, 0.2305103449881737, 0.2721617405740495, 0.19812607748638933, 0.15716588883602056, 0.1852328390958018, 0.22906545043135196, 0.14392399049058946, 0.12412885820532082, 0.13006232957822228, 0.12037184597001638, 0.10136485892335789, 0.12169900261349975, 0.13866755781028206, 0.12691381769930898, 0.13098439807532702, 0.13027570886277662, 0.12296191796479616, 0.12158899677739299, 0.11603186382368424, 0.11997314866954223, 0.12656926917044298, 0.13034773116518772, 0.12942818150749535, 0.11649008245490045, 9.999999999998899e-05, 9.999999999998899e-05, 0.02019494968956148, 0.000589291413428894, 0.003484859103552118, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13689047541426824, 0.08939211968369742, 0.10953402083322272, 0.07501422999766783, 0.04726401624656795, 0.04435857685416744, 0.1421245000061463, 0.08406324180559399, 0.05247620256066088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07942721430385113, 0.07849581531895689, 0.06948542028987781, 0.058820725006684005, 0.06021272736325556, 0.060386565650951574, 0.05533205321838408, 0.05356947066441897, 0.059736089254622704, 0.34230539724035314, 0.3390796773820288, 0.35324330254339686, 0.33719630899804864, 0.32989936125513875, 0.325282541952417, 0.37654866098741824, 0.3860464907757507, 0.33670217190469376, 0.11795380593217675, 0.07967510764189134, 0.10925377611836429, 0.10985447740581167, 0.1065310881177367, 0.10501719359928607, 0.07777290165536976, 0.09303317794091726, 0.13364809939029054, 0.16838688323535644, 0.14602611166673796, 0.1590822544080811, 0.18961007712382838, 0.212348933987631, 0.15046721823106013, 0.16855528934743103, 0.1924991046161122, 0.1781680408304661, 0.24633265283272598, 0.2543095082151884, 0.24724817343993477, 0.2561020562114401, 0.26132444855247483, 0.25883211988447774, 0.21787340866238725, 0.2079508619883309, 0.25761325826280235, 0.199655586857316, 0.22597206534397762, 0.17581042572385508, 0.1923900060944238, 0.20510336758704284, 0.20643656833825907, 0.18143864025189416, 0.1711015755175147, 0.19184228495116418, 0.21113521096443877, 0.2463429897852597, 0.20346628907802333, 0.20823821030132583, 0.22770358218358644, 0.2386058527664514, 0.21350285651405032, 0.2261758976376167, 0.21024703999457772, 0.17421874390768077, 0.17171938685197907, 0.17934898783210262, 0.17999703225716313, 0.17944489432583832, 0.17184777535987505, 0.17117261541061546, 0.17265451103567198, 0.16695082765353508, 0.18590938068185237, 0.1841431211623682, 0.1426967673906856, 0.1711687142325291, 0.19713023691149734, 0.13761174722993497, 0.16450587819216456, 0.20596460387279403, 0.1670945709519679, 0.4203243541402041, 0.19847871252088656, 0.3850200864140866, 0.2004796874672089, 0.1680350881224083, 0.1955870454611195, 0.10394537711296359, 0.15863404456678198, 0.10324810607159618, 0.18247482799780435, 0.19452734902916302, 0.17362871016507853, 0.18180005255026122, 0.1877364938527024, 0.17926287983280653, 0.19362104523749424, 0.18500090619202214, 0.1886548492767135, 0.10265102398891246, 0.10177437487153906, 0.07946946267169419, 0.11506116469820682, 0.08888107850949944, 0.09943081905927953, 0.08915976837554584, 0.08479098176230859, 0.08672282762879946]}, "mutation_prompt": null}
{"id": "2fbd3493-dffc-4938-8ad2-8b646b2b2c75", "solution": "import numpy as np\n\nclass AdaptiveDE_CMA_DynamicResizing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 + int(3 * np.log(self.dim)), 12)\n        self.initial_population_size = self.population_size\n        self.mutation_factor = 0.75\n        self.crossover_rate = 0.85\n        self.sigma_initial = 0.2\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.momentum = np.zeros((self.population_size, self.dim))\n\n    def __call__(self, func):\n        evals = 0\n        learning_rate = 0.015\n        momentum_decay = 0.98\n        diversity_threshold = 0.12\n        decay_rate = 0.99\n\n        while evals < self.budget:\n            if evals + self.population_size > self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, self.population)\n            evals += self.population_size\n\n            if np.min(fitness) < self.best_fitness:\n                self.best_fitness = np.min(fitness)\n                self.best_solution = self.population[np.argmin(fitness)].copy()\n\n            convergence_progress = evals / self.budget\n            self.mutation_factor *= decay_rate\n\n            avg_diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.population_size)])\n            noise_scale_factor = 0.45 * (1 - convergence_progress)**2 + 0.1 * avg_diversity / self.dim\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                noise = np.random.normal(0, noise_scale_factor * np.sqrt(self.dim), self.dim)\n                mutation_intensity = 1 + (evals / self.budget) * (1 - avg_diversity / self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) * mutation_intensity + noise, self.lower_bound, self.upper_bound)\n                \n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * variance_factor\n\n                crossover_vector = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant_vector, self.population[i])\n                \n                if np.random.rand() < 0.12:\n                    crossover_vector = mutant_vector\n                \n                new_fitness = func(crossover_vector)\n                if new_fitness < fitness[i]:\n                    self.population[i] = crossover_vector\n                    evals += 1\n                    self.mutation_factor *= 1.002\n\n            if evals >= self.budget:\n                break\n\n            learning_rate = 0.01 + 0.012 * (np.exp(-evals / self.budget)) * (1.5 - avg_diversity / self.dim)\n            learning_rate *= momentum_decay\n\n            for i in range(self.population_size):\n                diversity = np.linalg.norm(self.best_solution - self.population[i])\n                if diversity > diversity_threshold:\n                    self.momentum[i] = 0.85 * self.momentum[i] + learning_rate * (self.best_solution - self.population[i])\n                self.population[i] += self.momentum[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n            cov_matrix = np.cov(self.population.T)\n            mean_vector = np.mean(self.population, axis=0)\n            adaptive_sigma = self.sigma_initial**2 + evals / self.budget + 0.015\n            \n            if avg_diversity < diversity_threshold / 2:\n                self.mutation_factor = min(1.3, self.mutation_factor + 0.015)\n\n            # Dynamic resizing of the population\n            if evals > self.budget / 2:\n                self.population_size = int(self.initial_population_size * (1 - convergence_progress * 0.3))\n\n            self.population = np.random.multivariate_normal(mean_vector, adaptive_sigma * cov_matrix, self.population_size)\n            self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n\n        return self.best_solution", "name": "AdaptiveDE_CMA_DynamicResizing", "description": "Integrated dynamic population resizing and diversity preservation strategies to enhance convergence speed and robustness.", "configspace": "", "generation": 99, "fitness": 0.18982001070021604, "feedback": "The algorithm AdaptiveDE_CMA_DynamicResizing got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "0d80042b-5925-4e33-aa83-bbbd1ba67740", "metadata": {"aucs": [0.33531214549751176, 0.3458847001606563, 0.3536305562080403, 0.3554726905194098, 0.33470154734722646, 0.4097485572155356, 0.3464749277030549, 0.3535368060946362, 0.3380688022328384, 0.05707638250149538, 0.0899322345700233, 0.011969760226836268, 0.048184026333801144, 0.0786353683615052, 0.0052594822565228405, 0.010468828383703666, 0.021564484818667573, 9.999999999998899e-05, 0.09480234844760504, 0.1077610352847782, 0.11513879290643292, 0.13722047467687903, 0.11708682477140464, 0.10779799878035068, 0.07516761476128431, 0.11076324112968527, 0.1182893589952686, 0.07914800273397482, 0.08426581699081181, 0.06688359281085032, 0.10642167309889028, 0.08449486770297587, 0.0610432142719195, 0.10259321645081332, 0.07079335912607077, 0.09153507942971317, 0.9135534444646072, 0.9130227570984573, 0.9058724979025456, 0.8714372815420471, 0.8747817075651524, 0.8686924268376109, 0.865526854614097, 0.8489070349614667, 0.8918688921576567, 0.2565412166807043, 0.22841267273669996, 0.22441397407116503, 0.22104570234777687, 0.24763251642708395, 0.2077779494899179, 0.2402751088883428, 0.2325287119630467, 0.21871645696519015, 0.2103184506310618, 0.13143526655800775, 0.19673860381723407, 0.20347443682692135, 0.1914195955840562, 0.20675469571906147, 0.15286822563162128, 0.18730888298883175, 0.24608364260501558, 0.15722950020303306, 0.11595750523690695, 0.11932987057251887, 0.09168953324876516, 0.12843309630195332, 0.14095186875584453, 0.12182629465581007, 0.11860031169044505, 0.11936111331385912, 0.14330615762252652, 0.12028576428700488, 0.09805697539796998, 0.12508951273454072, 0.15426376006809273, 0.13154593916308444, 0.13900519925447474, 0.13173094473266678, 0.12391949685100068, 0.00013697463571737956, 0.0078115817088891815, 0.00012714385858758614, 0.01769787293522973, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00020834297057148454, 0.00425339048695228, 0.1465247652421252, 0.08683778215940563, 0.18654941857463025, 0.06887798701129666, 0.0827171893398565, 0.0512105736909052, 0.12663287958186464, 0.061436360038181204, 0.07638689420122213, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06433088073657522, 0.05302901839754848, 0.059428857719596495, 0.08564599998646283, 0.06912852074611087, 0.06275041529625847, 0.06100208109394467, 0.05818869083571132, 0.05912898925542154, 0.43816967639617643, 0.3495878052495689, 0.3726236040217954, 0.36125559418983655, 0.34080274444779646, 0.34942806354746725, 0.3340461446943538, 0.34482018559456795, 0.33035440418084194, 0.0850419696722996, 0.12801557735387925, 0.1203782204914784, 0.12995534159792876, 0.11657788987852968, 0.12123374082666194, 0.12265222311405322, 0.10812863452520849, 0.10683735108258663, 0.14213874022883577, 0.22792627670829801, 0.12598293425856222, 0.14126798030745324, 0.19182910190512947, 0.16321322878054145, 0.1728279263337772, 0.21980985130804054, 0.16311840534764976, 0.26271376625724674, 0.2669992955922016, 0.21702105631766289, 0.2795738445771473, 0.24645218524700951, 0.24197974508436693, 0.20192184006680702, 0.20433733407478916, 0.20188692846106548, 0.20793704474268238, 0.19673207497292233, 0.20035967843643632, 0.21107743478537644, 0.2025119683345924, 0.19856664298068816, 0.1867205285587873, 0.17463189198125673, 0.1784556890043918, 0.22263269176302602, 0.2532030450062245, 0.2409349558542253, 0.21691734132126617, 0.22427897200905955, 0.24241818445920893, 0.22718735299300952, 0.2238673658396677, 0.23704145182596315, 0.1752847524327863, 0.1753690210112434, 0.1953544722581998, 0.1841257650864736, 0.19607127704699245, 0.16843774423053803, 0.17375718510116545, 0.16865238645892278, 0.1744575297792157, 0.1833229497458505, 0.18551618110341994, 0.1805714057225679, 0.4605733336525397, 0.19449653321465366, 0.15780100608012415, 0.1438239646784265, 0.20495738350409187, 0.16738775337649625, 0.4857349408972488, 0.20176201862061904, 0.4334155141348325, 0.19578507007681545, 0.14540680912757276, 0.19998360065887388, 0.33090410193125197, 0.1623985954394357, 0.2628920331155883, 0.18800148391744909, 0.19167605860844272, 0.1994151638455789, 0.19012412874457918, 0.17985148152432262, 0.18888896441378633, 0.1842342002997731, 0.1911722274987332, 0.1964299142693925, 0.09623949535360732, 0.10762369214517509, 0.0874687750639459, 0.11232957027204515, 0.08806807407909423, 0.08530153532353812, 0.08390823638318712, 0.09171648637831586, 0.09758329357922646]}, "mutation_prompt": null}
