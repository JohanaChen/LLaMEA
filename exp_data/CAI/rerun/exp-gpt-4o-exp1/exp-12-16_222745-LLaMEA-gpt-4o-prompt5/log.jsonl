{"id": "3682f684-c77d-4a68-9af9-5b3f2fdd3b2c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = np.mean(self.successful_deltas) * 0.5\n        self.CR = np.mean(self.successful_crs)\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-tuning Parameters - a novel algorithm that adjusts mutation and crossover rates by learning from previous generations to balance exploration and exploitation dynamically.", "configspace": "", "generation": 0, "fitness": 0.11835623008769137, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.1504468421364823, 0.10042391386742233, 0.14718436811527646, 0.39263817599349105, 0.3887455008036981, 0.4130095629923166, 0.3102898997250678, 0.2783038261558344, 0.2989409759875553, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03268070092546549, 0.03275255318044634, 0.026280902306986542, 0.027507547614044392, 0.03758079344534948, 0.03807430057359884, 0.048699520242957095, 0.04886976727876102, 0.04071536180195767, 0.013517226109473257, 0.0017010023333459134, 0.009579590570359509, 0.023954646936885204, 0.021049326597356255, 0.012714979133992554, 0.022998231326850194, 0.005106256226300898, 0.025529869828286644, 0.9626019736489809, 0.9852711332041213, 0.9646956181922461, 0.9645079866363271, 0.9803163547196537, 0.9693880661887971, 0.9839376948397236, 0.9746267760026256, 0.9660586370043681, 0.08499932729726256, 0.07145310524547133, 0.08858236711824907, 0.09678830493438839, 0.08440147388380592, 0.07900220615245357, 0.07357356072848997, 0.08306015971845004, 0.07367525170242806, 0.10511669273430801, 0.09090745416365975, 0.1245356460498922, 0.10917149843265483, 0.10588048514935455, 0.09978451998290438, 0.09694299518384686, 0.11641690069031652, 0.1083725944185786, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010423678269717573, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009131851766101096, 0.014308767982689652, 0.009098706931774725, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0041372209911655355, 0.0016375373254159387, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0021778034383341804, 0.02629442369069146, 0.009125047499414563, 9.999999999998899e-05, 0.034933561050241924, 0.041548061633416955, 0.01332789717972882, 0.02870638140247117, 0.025236458280574525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00425653513788149, 0.004344575488055447, 0.003792976904337775, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03658824595617827, 0.06753372126281487, 0.09297719294023554, 0.16899772536041602, 0.19704453519180398, 0.1560351313777686, 0.16906500905113808, 0.19209465786566648, 0.17255636728842327, 0.24279760945846574, 0.16951028385568023, 0.17642082280136018, 0.057824657577755345, 0.04823002134968579, 0.05948125541420923, 0.040312006977682224, 0.03145678321637024, 0.028745324360751834, 0.028669173501912892, 0.03813715395988415, 0.031124089854872028, 0.12432407904523057, 0.11733238319759998, 0.15194598292448303, 0.1611599327802269, 0.11318505371705212, 0.1423386538695438, 0.12158923101620733, 0.13765502608671454, 0.13960822742743262, 0.1371223764318802, 0.13336572813549175, 0.16149506246430922, 0.13909437606682729, 0.14241587747055728, 0.15454270760589606, 0.14720927229529335, 0.17806660475648228, 0.1519471475646349, 0.07472664017330366, 0.09380930919017916, 0.08786186808395902, 0.10808749996166367, 0.08017937793362251, 0.09108526412623164, 0.09204091757028621, 0.1050861969233241, 0.09521450631802597, 0.1375188377945895, 0.139857939730468, 0.1501995206450365, 0.16108990402376855, 0.1337881231864151, 0.13846440531553872, 0.12603554820541285, 0.15421635978401682, 0.13481618013512742, 9.999999999998899e-05, 0.13241355580788583, 0.12703571086078025, 0.14568601143234994, 0.0020824281907291242, 0.02919448980833017, 0.13807621178432783, 0.0027747626379422963, 0.13111843534217238, 0.15238040273398634, 0.09889314839243779, 0.1284376745453938, 0.14007071833176665, 0.15851797466968676, 0.13987716714947418, 0.1407263373298414, 0.11701306453230487, 0.12244433868285998, 0.13807937815681903, 0.17014626071894712, 0.13477270394250795, 0.08574382753048759, 0.13162208465977998, 0.10110987580184738, 0.21957876838963664, 0.25386520015105174, 0.1652203020742583, 0.1621207410199349, 0.16288336182691088, 0.17973263583790688, 0.16110304407158105, 0.16093977598530584, 0.15873372557639887, 0.16275622151721092, 0.1472572053747907, 0.16232708378298977, 0.031935370990663015, 0.031966323961574394, 0.031393493129599714, 0.028410520473242662, 0.03907497406246352, 0.04008675730918332, 0.021508995967172484, 0.039383209815537334, 0.04150893323917093]}, "mutation_prompt": null}
{"id": "564732be-dfb6-4d9b-b331-cbb24fd857dc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = np.mean(self.successful_deltas) * 0.5 * (1 + np.random.rand() * 0.1)  # Slight modification\n        self.CR = np.mean(self.successful_crs)\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Self-tuning Parameters by adjusting differential weight scaling strategy for better adaptability.", "configspace": "", "generation": 1, "fitness": 0.11602621613177823, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "3682f684-c77d-4a68-9af9-5b3f2fdd3b2c", "metadata": {"aucs": [0.14050085958486402, 0.12612866997631444, 0.1393452685613571, 0.17564760273799096, 0.3582110689743887, 0.3867105073177146, 0.25232217850128114, 0.2713825403331471, 0.2870552260621947, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0323615523881563, 0.030241323567492873, 0.033235811661381565, 0.04465490081334478, 0.029172696950208188, 0.03275215309234902, 0.038978637386386406, 0.03148462386646933, 0.03174831404184697, 0.009317235870643703, 0.0022507208360257325, 0.010585095327271477, 0.022685899038377255, 0.008677254348431807, 0.004813981990004712, 0.01702996334378748, 0.006814810722428399, 0.023516936730809124, 0.969863300734309, 0.9852711332041213, 0.9647000261596801, 0.9645054208164553, 0.980436616862982, 0.9642124285994909, 0.9839376948397236, 0.974623127608362, 0.9635757856250762, 0.08993679062890736, 0.0710018041262458, 0.05365385071649631, 0.08269395970310833, 0.08681974648950641, 0.0649577698556737, 0.0892758808279357, 0.1080789756439744, 0.0626291671728404, 0.13123699781275133, 0.09876086884764046, 0.11406471059488776, 0.12298742897714565, 0.09042503191918583, 0.13789026846819674, 0.10141657980331331, 0.13297594549638891, 0.09996204172637935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027639573834621345, 9.999999999998899e-05, 9.999999999998899e-05, 0.00012844613366902458, 9.999999999998899e-05, 9.999999999998899e-05, 0.009301443939486176, 0.008767728801169827, 0.008597478510364631, 0.000565627141413283, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002967705048250502, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011546505927314543, 9.999999999998899e-05, 9.999999999998899e-05, 0.044876523273994495, 9.999999999998899e-05, 0.055357077495378326, 0.0038841135316439734, 0.0489850336915979, 0.025236458280574525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012212448116730723, 0.00012273417367247852, 0.0077756655833245425, 9.999999999998899e-05, 0.0006568116850489414, 9.999999999998899e-05, 0.1207002160052787, 0.04323704892897584, 0.03383944539896455, 0.1622277281064064, 0.16744184220597746, 0.15710693989724112, 0.16978079007514968, 0.17230105828271258, 0.18877041865242128, 0.2238398211775081, 0.18708171881681857, 0.17568500582659075, 0.05714353628266067, 0.051855659256408226, 0.04958555804790288, 0.03266886175302153, 0.02919983168927298, 0.020235188199071996, 0.024945268682464716, 0.018811482713552152, 0.026841355513230303, 0.10436977374731582, 0.11032135232817442, 0.13762444507339622, 0.10888359256482416, 0.1276769425568307, 0.1323028506787881, 0.11346002385912402, 0.11770369520525004, 0.1277281917005788, 0.129205524389432, 0.16032261768101197, 0.1613932299901244, 0.14670471257589524, 0.1420035048531494, 0.13085820885243482, 0.1549625879229477, 0.17377774300845283, 0.1614743520413655, 0.09205587690441064, 0.09317093032051416, 0.09468486067839277, 0.08194172453938375, 0.1153598315428962, 0.11750680991337636, 0.10224385685837656, 0.1006119678165247, 0.08922355163426798, 0.13298393007721665, 0.14617302435008073, 0.13937585831991617, 0.13994815115015558, 0.13653439293605574, 0.13699269596583652, 0.1251494844694303, 0.13410975837590033, 0.13171965752974413, 9.999999999998899e-05, 0.13608059712522158, 0.1264248160939303, 0.14568601143234994, 9.999999999998899e-05, 9.999999999998899e-05, 0.13807621178432783, 9.999999999998899e-05, 0.13431524026592911, 0.146041408073037, 0.1594612205001662, 0.16667401796904446, 0.14364128237999008, 0.14844289652979092, 0.14300691616327477, 0.13844242595327627, 0.12107963108179465, 0.11345060832964649, 0.1391752265229217, 0.14918438097607545, 0.13095549761936454, 0.09519679158246686, 0.14241171726215252, 0.10162316269622695, 0.1970887876005909, 0.16971263776278078, 0.17191023211941614, 0.18604649686259167, 0.1824765963372168, 0.195672256166609, 0.15579208460381744, 0.16210603091562148, 0.1667067176669419, 0.16363805021854094, 0.15593717102533178, 0.1936887915221852, 0.03817370037648893, 0.027568034210034065, 0.031393493129599714, 0.028728164533344702, 0.0347812555992677, 0.04008675730918332, 0.02093135850080019, 0.03951284380288611, 0.04150893323917093]}, "mutation_prompt": null}
{"id": "aa23b26e-e6e3-4a43-b8b5-291fff0e6126", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5)  # <--- Modified line for better adaptation\n        self.CR = np.mean(self.successful_crs)\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced parameter adaptation by adjusting F to improve exploration and exploitation balance.", "configspace": "", "generation": 2, "fitness": 0.3491511741402863, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "3682f684-c77d-4a68-9af9-5b3f2fdd3b2c", "metadata": {"aucs": [0.7736679173059666, 0.7388649120201386, 0.7763766216282622, 0.7787385365291724, 0.768781421817298, 0.7767033603994, 0.7489190613591532, 0.7747867395058063, 0.7505813400789185, 0.6013304032495372, 0.5768263932992868, 0.6123499683772906, 0.5844074011761098, 0.59214063156856, 0.5938936972338562, 0.6027481821452454, 0.6091770568042199, 0.5979729880555937, 0.11427814815632498, 0.1248243823698364, 0.11281499192847133, 0.09847283107200744, 0.1144495391214716, 0.12223022897360081, 0.11040328688347323, 0.10785781446007148, 0.11792463198039882, 0.11231939720210904, 0.10143022538214341, 0.08952517572143714, 0.10471446162468889, 0.08984909487972614, 0.08955271439917889, 0.09982318438732873, 0.10745169901508156, 0.10072132459893168, 0.7899690860772264, 0.9395343970062122, 0.9256697098724933, 0.9278089713986721, 0.762209181492304, 0.7374146766380927, 0.9078429191774737, 0.9015920795240534, 0.8516346442859154, 0.4528982900265437, 0.4247412309914008, 0.4274692623330474, 0.4106999331051402, 0.4171073891450019, 0.3714869174468828, 0.3795092027974425, 0.43367304342226287, 0.4166960626459909, 0.7583157407670389, 0.743579555371644, 0.7570107256007217, 0.8078275617488454, 0.7325586486942408, 0.7534063501828927, 0.6978324806680802, 0.7543666376063458, 0.7798401338429526, 0.16114479127124104, 0.24595379755837699, 0.20058512311532017, 0.28576627333415794, 0.2213918685348807, 0.17287114604661402, 0.18504770194443276, 0.16858465553194912, 0.20576404793141434, 0.3785208636908062, 0.19530509657146888, 0.40080945009883673, 0.4084801454214384, 0.22971916846988139, 0.23550974518324463, 0.154972868154706, 0.18205934078794528, 0.1551927657702752, 0.35114709237161534, 0.3464675526428719, 0.3717213802311411, 0.309008842428818, 0.34663002349725447, 0.3491178392973817, 0.3820755888281674, 0.3718968473174876, 0.36762643315130705, 0.5425614802654277, 0.482105113814408, 0.4953040117294224, 0.44949607441279116, 0.48934076349662203, 0.5136100072848274, 0.5180452190455649, 0.5224531599136035, 0.5403268379578512, 0.14319837549849912, 0.08284981063415309, 0.1290759552724885, 0.16108708685760753, 0.23473076590897424, 0.15836143286096016, 0.11219614546675605, 0.12208298209627644, 0.15333148952310982, 0.26262566311971836, 0.29073237318924616, 0.3125859850852618, 0.2944632135905767, 0.32055522108909096, 0.3321814182670205, 0.2703915860503454, 0.28621139885585034, 0.3020732577184587, 0.685753805040712, 0.6675059397347867, 0.69228011611832, 0.659232392811136, 0.7126980429140258, 0.6776825172058231, 0.6779449044011496, 0.6536027572779559, 0.6874720707797819, 0.10241257718744778, 0.08781770440358017, 0.11452430627806676, 0.09894989558147571, 0.10727511020124436, 0.09204227796887576, 0.11200232285331291, 0.10257042509024616, 0.1227780183767323, 0.14097879344899888, 0.14532764774675566, 0.15401088695747134, 0.16267276273702136, 0.1528063609629582, 0.13859365691085335, 0.1506467021480179, 0.14672830670870973, 0.16561424120655133, 0.3836325389266929, 0.3849253338857187, 0.39341211900438866, 0.4066429353916491, 0.3694161872751467, 0.3852153952598377, 0.38845472472426157, 0.43710543406994506, 0.40678278523258915, 0.296623145292787, 0.27686931781455415, 0.30965155127012145, 0.3094299273591331, 0.2965407297446969, 0.27170070052214057, 0.31410693522780553, 0.3038692566004446, 0.3326607722674694, 0.19025624110346262, 0.19705613362878416, 0.17806456936206883, 0.19592688567710526, 0.19198017420713132, 0.20180959249852526, 0.19127227445298278, 0.20272863011045072, 0.21073801980894746, 0.1861868795579431, 0.20261765383055608, 0.19302918478436393, 0.22347934354329402, 0.20802016715749105, 0.20285809325681825, 0.21683585250691118, 0.19734162231102637, 0.281656438170932, 0.1744785669080693, 0.17712515433648457, 0.17843363091608921, 0.187664010669646, 0.745131357971029, 0.5794870949079372, 0.5379222406702635, 0.6989117202552867, 0.3073714821796212, 0.6351093885127473, 0.2023892370873488, 0.2056633883310781, 0.19693958421825308, 0.39883824895343856, 0.1905763143482574, 0.2051558510385536, 0.4920215921723733, 0.21008835320358799, 0.18761215878278936, 0.1825508898819368, 0.17374941737157767, 0.17701770475552236, 0.17422387753289537, 0.1930258116008723, 0.20133542843239915, 0.18412074632880893, 0.18847755887737105, 0.0818759077742307, 0.0784082457905706, 0.08743726662334117, 0.08236316534758703, 0.07810735714197259, 0.07789618715607083, 0.07954417138307945, 0.08276643257133887, 0.0870601066122535]}, "mutation_prompt": null}
{"id": "6af3d1f6-7ce5-459e-bf42-e1ea549fb787", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5)\n        self.CR = 0.9 if not self.successful_crs else np.mean(self.successful_crs)  # <--- Adjusted line for dynamic CR\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced parameter adaptation by dynamically adjusting CR based on success rates.", "configspace": "", "generation": 3, "fitness": 0.3491511741402863, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "aa23b26e-e6e3-4a43-b8b5-291fff0e6126", "metadata": {"aucs": [0.7736679173059666, 0.7388649120201386, 0.7763766216282622, 0.7787385365291724, 0.768781421817298, 0.7767033603994, 0.7489190613591532, 0.7747867395058063, 0.7505813400789185, 0.6013304032495372, 0.5768263932992868, 0.6123499683772906, 0.5844074011761098, 0.59214063156856, 0.5938936972338562, 0.6027481821452454, 0.6091770568042199, 0.5979729880555937, 0.11427814815632498, 0.1248243823698364, 0.11281499192847133, 0.09847283107200744, 0.1144495391214716, 0.12223022897360081, 0.11040328688347323, 0.10785781446007148, 0.11792463198039882, 0.11231939720210904, 0.10143022538214341, 0.08952517572143714, 0.10471446162468889, 0.08984909487972614, 0.08955271439917889, 0.09982318438732873, 0.10745169901508156, 0.10072132459893168, 0.7899690860772264, 0.9395343970062122, 0.9256697098724933, 0.9278089713986721, 0.762209181492304, 0.7374146766380927, 0.9078429191774737, 0.9015920795240534, 0.8516346442859154, 0.4528982900265437, 0.4247412309914008, 0.4274692623330474, 0.4106999331051402, 0.4171073891450019, 0.3714869174468828, 0.3795092027974425, 0.43367304342226287, 0.4166960626459909, 0.7583157407670389, 0.743579555371644, 0.7570107256007217, 0.8078275617488454, 0.7325586486942408, 0.7534063501828927, 0.6978324806680802, 0.7543666376063458, 0.7798401338429526, 0.16114479127124104, 0.24595379755837699, 0.20058512311532017, 0.28576627333415794, 0.2213918685348807, 0.17287114604661402, 0.18504770194443276, 0.16858465553194912, 0.20576404793141434, 0.3785208636908062, 0.19530509657146888, 0.40080945009883673, 0.4084801454214384, 0.22971916846988139, 0.23550974518324463, 0.154972868154706, 0.18205934078794528, 0.1551927657702752, 0.35114709237161534, 0.3464675526428719, 0.3717213802311411, 0.309008842428818, 0.34663002349725447, 0.3491178392973817, 0.3820755888281674, 0.3718968473174876, 0.36762643315130705, 0.5425614802654277, 0.482105113814408, 0.4953040117294224, 0.44949607441279116, 0.48934076349662203, 0.5136100072848274, 0.5180452190455649, 0.5224531599136035, 0.5403268379578512, 0.14319837549849912, 0.08284981063415309, 0.1290759552724885, 0.16108708685760753, 0.23473076590897424, 0.15836143286096016, 0.11219614546675605, 0.12208298209627644, 0.15333148952310982, 0.26262566311971836, 0.29073237318924616, 0.3125859850852618, 0.2944632135905767, 0.32055522108909096, 0.3321814182670205, 0.2703915860503454, 0.28621139885585034, 0.3020732577184587, 0.685753805040712, 0.6675059397347867, 0.69228011611832, 0.659232392811136, 0.7126980429140258, 0.6776825172058231, 0.6779449044011496, 0.6536027572779559, 0.6874720707797819, 0.10241257718744778, 0.08781770440358017, 0.11452430627806676, 0.09894989558147571, 0.10727511020124436, 0.09204227796887576, 0.11200232285331291, 0.10257042509024616, 0.1227780183767323, 0.14097879344899888, 0.14532764774675566, 0.15401088695747134, 0.16267276273702136, 0.1528063609629582, 0.13859365691085335, 0.1506467021480179, 0.14672830670870973, 0.16561424120655133, 0.3836325389266929, 0.3849253338857187, 0.39341211900438866, 0.4066429353916491, 0.3694161872751467, 0.3852153952598377, 0.38845472472426157, 0.43710543406994506, 0.40678278523258915, 0.296623145292787, 0.27686931781455415, 0.30965155127012145, 0.3094299273591331, 0.2965407297446969, 0.27170070052214057, 0.31410693522780553, 0.3038692566004446, 0.3326607722674694, 0.19025624110346262, 0.19705613362878416, 0.17806456936206883, 0.19592688567710526, 0.19198017420713132, 0.20180959249852526, 0.19127227445298278, 0.20272863011045072, 0.21073801980894746, 0.1861868795579431, 0.20261765383055608, 0.19302918478436393, 0.22347934354329402, 0.20802016715749105, 0.20285809325681825, 0.21683585250691118, 0.19734162231102637, 0.281656438170932, 0.1744785669080693, 0.17712515433648457, 0.17843363091608921, 0.187664010669646, 0.745131357971029, 0.5794870949079372, 0.5379222406702635, 0.6989117202552867, 0.3073714821796212, 0.6351093885127473, 0.2023892370873488, 0.2056633883310781, 0.19693958421825308, 0.39883824895343856, 0.1905763143482574, 0.2051558510385536, 0.4920215921723733, 0.21008835320358799, 0.18761215878278936, 0.1825508898819368, 0.17374941737157767, 0.17701770475552236, 0.17422387753289537, 0.1930258116008723, 0.20133542843239915, 0.18412074632880893, 0.18847755887737105, 0.0818759077742307, 0.0784082457905706, 0.08743726662334117, 0.08236316534758703, 0.07810735714197259, 0.07789618715607083, 0.07954417138307945, 0.08276643257133887, 0.0870601066122535]}, "mutation_prompt": null}
{"id": "0670e11c-6811-4bf2-927d-bd87d3a79ea7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5)\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # <--- Modified line for better adaptation\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced exploration by dynamic crossover rate adjustment based on population diversity.", "configspace": "", "generation": 4, "fitness": 0.36021677756144094, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "aa23b26e-e6e3-4a43-b8b5-291fff0e6126", "metadata": {"aucs": [0.7834055135075157, 0.7539065387158493, 0.7932550159935361, 0.7667390436267865, 0.7955619082037384, 0.769117207206907, 0.7682925976676824, 0.7676351304605228, 0.7849341824188166, 0.6022021841186406, 0.591827113341723, 0.5920375907513111, 0.6018222185832989, 0.5998113236471633, 0.6400734070217023, 0.6046482714691308, 0.6032266077412661, 0.6340526739938979, 0.10003881504837586, 0.10166481169009678, 0.10964362474175982, 0.10258036274842564, 0.1000278692121801, 0.11703575854090398, 0.1137568085638253, 0.11048905633244666, 0.10018763129379915, 0.1020789191400645, 0.09697767619099518, 0.10230972595195342, 0.0848368274652439, 0.08942066785933223, 0.11687601175878937, 0.11279925149106751, 0.08877045732789157, 0.09669567612012564, 0.11387467892858005, 0.20687590356637342, 0.2869454082656483, 0.13803043990275254, 0.09817684833452389, 0.09728892090738372, 0.14777368962436999, 0.1423351918122524, 0.1378235953753092, 0.22259542586817305, 0.2459259858106596, 0.15139682191705628, 0.2653807877716775, 0.42795884319356514, 0.21103939706104402, 0.20384272878350662, 0.17929010419395963, 0.21876884648835815, 0.8092556901079198, 0.8160855247529384, 0.7772726291841561, 0.8040481278452719, 0.810353953056513, 0.8055276324830367, 0.8102240147612789, 0.7992059871208675, 0.809216683653594, 0.2509784872869585, 0.29251515165241915, 0.5487944186397578, 0.20526297392939385, 0.14654178424591013, 0.18641163755763102, 0.371145978583618, 0.5507892266300962, 0.14106875814309805, 0.34485315867020083, 0.5924365251063249, 0.16403477573718006, 0.24399480868559054, 0.5602521757651697, 0.18472558560184105, 0.21046063350473987, 0.2380350569627443, 0.16522702129119282, 0.5741471945745564, 0.5435020590333124, 0.5407682035837416, 0.5961208459433089, 0.5877967788918328, 0.5757402786553776, 0.6148945062915756, 0.5835686550925272, 0.547179503129811, 0.6618143734424886, 0.6595372940246129, 0.6834567928506452, 0.6790657632092614, 0.6801111828745432, 0.6692437633195745, 0.6985825968328645, 0.6596275521012356, 0.6583822693872975, 0.12655015668241854, 0.17864190531100643, 0.3029744981954501, 0.16374953666783987, 0.3604870707496204, 0.3342046648970478, 0.2806507119347559, 0.26084235781872245, 0.1780763315276327, 0.41198920751018764, 0.4372091403999311, 0.43666180390250575, 0.3990293532754078, 0.45403405552549103, 0.4094304188448519, 0.40247676799990306, 0.43852098525233474, 0.41489091892400154, 0.7312024385929685, 0.714541082366348, 0.7411294732442685, 0.7737929239778792, 0.7252291358223695, 0.7243774551724937, 0.7670843620913861, 0.7417967203660261, 0.724628914762169, 0.10573670217922793, 0.08994692102967361, 0.09701848573678451, 0.10457008313255867, 0.10899717428862388, 0.10890338436446723, 0.10580684735150192, 0.1012377839495382, 0.1170066207977779, 0.1867001423263367, 0.16215316083027376, 0.31894153505502076, 0.1759071682249751, 0.2595569798659437, 0.15377677589925443, 0.15353260935816815, 0.19683141765279444, 0.15762803447872542, 0.42226919042344013, 0.3915339545457325, 0.43145849759607036, 0.3972036606019882, 0.43951923835490014, 0.41258787824388, 0.4310307291824057, 0.41102804820980865, 0.43078700924198654, 0.3725145083852508, 0.34792232647273635, 0.4079430546262409, 0.34384312492212554, 0.36710118143369563, 0.3461143352689895, 0.3854837073798675, 0.36755514347097973, 0.37079204125835497, 0.22184548515390035, 0.2029851867549095, 0.1887708986476525, 0.21766742269336325, 0.20548680156004073, 0.20256597333109294, 0.2029110025609152, 0.18699353751914527, 0.2199716792458546, 0.19671247327156394, 0.1855777146503138, 0.2001501369803027, 0.22298491926078234, 0.19184151194807664, 0.2190012779368783, 0.3617607228924128, 0.4501657026815663, 0.22376088621882873, 0.17870651789426195, 0.7357345300308471, 0.1653771572665248, 0.7069675731553204, 0.6459286487643442, 0.2386872654267831, 0.16062779368451974, 0.6842104689492573, 0.796265751069609, 0.750060308627416, 0.20794735148128063, 0.20755355127163722, 0.747305394235741, 0.2048561624797428, 0.19771472256404, 0.20732126403069706, 0.24511237623555238, 0.20879593368769422, 0.17294918747522936, 0.17301886473062367, 0.17069275746629942, 0.17502068032743223, 0.18641735057803943, 0.17599133681460355, 0.1907697506741466, 0.1738574365361646, 0.1809781123483578, 0.08014187690369057, 0.075911989381521, 0.08334742060718947, 0.10026074018498532, 0.08419092737243139, 0.08258321577982464, 0.08973574724940936, 0.08493754555827837, 0.07423094921507345]}, "mutation_prompt": null}
{"id": "773a8817-d51e-46ab-9437-1e6e2c613512", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5)\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas))) \n        self.successful_deltas = []\n        self.successful_crs = []\n        self.F *= 1.0 + 0.1 * np.std(self.successful_crs)  # <--- New line to dynamically adjust F", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with enhanced parameter tuning using a dynamic scaling factor.", "configspace": "", "generation": 5, "fitness": 0.057860461733800314, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "0670e11c-6811-4bf2-927d-bd87d3a79ea7", "metadata": {"aucs": [0.14041495447716157, 0.09622344047219944, 0.1392592580543187, 0.09422175141959488, 0.12574969509384593, 0.11033114211644335, 0.10769443282249702, 0.1281487204867401, 0.08882861789839169, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.016627407975144837, 0.014572254733962287, 0.01865957775850058, 0.0159259827977819, 0.017329303837088972, 0.021762746088687557, 0.03480510102530765, 0.018035454965372955, 0.013277870289741256, 0.009180322522183038, 0.0, 0.0, 0.022588163317751597, 0.0007093739579082659, 0.0, 0.014664865741570776, 0.0, 0.023419304708990785, 0.04917975351258197, 0.07799866284993018, 0.08647699835056888, 0.06782289124331076, 0.04694752018532422, 0.04680138276518664, 0.0759109053549597, 0.050951225848653525, 0.059996701999913915, 0.06265423285317917, 0.031037042131756065, 0.027188772255550275, 0.0625099330053388, 0.05189920672730075, 0.06153949144066517, 0.014223256708933318, 0.03836118570731617, 0.0, 0.1001868586914183, 0.0821548355402063, 0.11394874574040603, 0.06661749824786911, 0.07275849405212176, 0.05365609287964268, 0.053586237535104386, 0.05921649636366422, 0.049437875862261116, 0.0, 0.0, 0.0, 0.0009424630251522181, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0414522343970799, 0.0, 0.0286092885550846, 0.02513900374474598, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.15764344561866495, 0.15748132322755004, 0.14829537673711224, 0.1679124458458504, 0.1593858593724906, 0.16556126374656654, 0.16104568613219794, 0.1324796086244696, 0.16123506046399794, 0.020223445729864786, 0.026212028476285232, 0.021886321886607996, 0.0325721299095072, 0.014719603023520489, 0.0177157941869871, 0.022068999577602666, 0.011710671976607578, 0.02666833626569931, 0.08904711520372477, 0.11023241389247085, 0.11833361437130152, 0.10879448287006033, 0.10844057434014065, 0.10897088391894649, 0.08799080449358876, 0.08732248616169236, 0.0940150709779689, 0.114337244964417, 0.12205099587447277, 0.16130937881362284, 0.13792052181401182, 0.13466797076099468, 0.1294296738205205, 0.12671373965013133, 0.1736951248761558, 0.1415436731462547, 0.061840374595879655, 0.05653554827045004, 0.08685295257025916, 0.06842651844748238, 0.06521080437919813, 0.06378707636893266, 0.08364015581209894, 0.09968109929816105, 0.08526023352597223, 0.13036730720614176, 0.1361556676286142, 0.13336421106438578, 0.11402987446107749, 0.11922858741268516, 0.1121462001584792, 0.12237199858757541, 0.10537892692096207, 0.12610897469223925, 0.0, 0.13232697231112833, 0.061202170941804024, 0.14560073791554473, 0.0, 0.0, 0.13799019397043577, 0.0, 0.1310317057194056, 0.08391128095846634, 0.09141736899817365, 0.12127422869389992, 0.09746718606699001, 0.12242114621876832, 0.08446666686391069, 0.10692837481480588, 0.10502535409825287, 0.09387459740147674, 0.1103137036995071, 0.12830579292972832, 0.11453969714668966, 0.06795355974669659, 0.07342630361744562, 0.10068146406568945, 0.09109862918564982, 0.058585516628709366, 0.1206694012141043, 0.15605532664812494, 0.1575445884198563, 0.16463693198341645, 0.1456029037722485, 0.15818236796219842, 0.14422248454942876, 0.1626725106699176, 0.13463659704309539, 0.14680476350940774, 0.03134636203734387, 0.023787381333047586, 0.03129662407793532, 0.02691798931623457, 0.03415436066354671, 0.039990772632933824, 0.018490542896080875, 0.03793735337628057, 0.0414131081134228]}, "mutation_prompt": null}
{"id": "dffb6e58-740a-4e00-ab41-5743e00a14cb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # <--- Modified line for better adaptability\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Implement a dynamic scaling factor in mutation to enhance adaptability, resulting in more efficient exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.36021677790941586, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "0670e11c-6811-4bf2-927d-bd87d3a79ea7", "metadata": {"aucs": [0.7834055135075151, 0.7539065387158567, 0.7932550159935319, 0.7667390436265336, 0.7955619082037478, 0.769117207206907, 0.7682925976675603, 0.7676351304605852, 0.7849341824188231, 0.6022021841337559, 0.5918271133434706, 0.5920375908411756, 0.6018222184391794, 0.5998113236475114, 0.6400734070218288, 0.6046482715036774, 0.6032266077406356, 0.6340526739934333, 0.10003881504837586, 0.10166481169009678, 0.10964362474175982, 0.10258036274842564, 0.1000278692121801, 0.11703575854090398, 0.1137568085638253, 0.11048905633244666, 0.10018763129379915, 0.1020789191400645, 0.09697767619099518, 0.10230972595195342, 0.0848368274652439, 0.08942066785933223, 0.11687601175878937, 0.11279925149106751, 0.08877045732789157, 0.09669567612012564, 0.11387467892858072, 0.20687590356638907, 0.2869454082656483, 0.13803043990275254, 0.09817684833452389, 0.09728892090738372, 0.14777368962434245, 0.14233519181223797, 0.1378235953753434, 0.22259542586817305, 0.2459259858106596, 0.15139682191705628, 0.2653807877716775, 0.42795884319401434, 0.2110393970610348, 0.20384272878350662, 0.17929010419395963, 0.2187688464883666, 0.8092556901079198, 0.8160855247529384, 0.7772726291841561, 0.8040481278452719, 0.810353953056513, 0.8055276324830367, 0.8102240147612789, 0.7992059871208675, 0.809216683653594, 0.2509784872869585, 0.29251515165241915, 0.5487944186395937, 0.2052629739294275, 0.14654178424591013, 0.1864116375575685, 0.3711459785839082, 0.5507892266198418, 0.14106875814309805, 0.34485315867020094, 0.5924365251062069, 0.16403477573717573, 0.24399480868557588, 0.5602521757553656, 0.18472558560184105, 0.21046063350473987, 0.2380350569627443, 0.16522702129119282, 0.57414719448297, 0.5435020590049777, 0.5407682035796205, 0.5961208462797136, 0.587796778893666, 0.5757402786546884, 0.6148945062963445, 0.5835686550776451, 0.5471795031352038, 0.6618143734425785, 0.6595372940246129, 0.6834567928506452, 0.6790657632084238, 0.6801111827740034, 0.6692437633126274, 0.6985825968314188, 0.6596275521067574, 0.658382269396919, 0.1265501566823335, 0.17864190531095026, 0.30297449826556233, 0.16374953666847636, 0.3604870720564961, 0.3342046651056032, 0.28065071188571045, 0.26084235781629206, 0.1780763315284728, 0.4119892047202617, 0.4372091837632931, 0.4366617786666893, 0.39902936834902425, 0.4540337833333511, 0.4094304435410663, 0.402476839351564, 0.4385209562111523, 0.41489116782611246, 0.7312024385719107, 0.7145410823667726, 0.7411294729040945, 0.77379292397704, 0.7252291354222924, 0.7243774551692473, 0.7670843620913861, 0.741796720545931, 0.724628914762169, 0.10573670217922793, 0.08994692102967361, 0.09701848573678451, 0.10457008313255867, 0.10899717428862388, 0.10890338436446723, 0.10580684735150192, 0.1012377839495382, 0.1170066207977779, 0.1867001423263367, 0.16215316083027376, 0.31894153505502076, 0.1759071682249751, 0.2595569798659437, 0.15377677589925443, 0.15353260935816815, 0.19683141765279444, 0.15762803447872542, 0.42226919042344013, 0.3915339545460934, 0.43145849759607036, 0.39720366060205803, 0.4395192383558538, 0.4125878782435831, 0.4310307291824057, 0.41102804821121186, 0.43078700924780655, 0.37251450838212474, 0.34792232647207877, 0.4079430546266306, 0.34384312492240565, 0.36710118143396286, 0.3461143352685231, 0.3854837073798675, 0.36755514347097973, 0.3707920412580372, 0.22184548515390035, 0.2029851867549095, 0.1887708986476525, 0.21766742269336325, 0.20548680156004073, 0.20256597333109294, 0.2029110025609152, 0.18699353751914527, 0.2199716792458546, 0.19671247327156394, 0.1855777146503138, 0.2001501369803027, 0.22298491926078234, 0.19184151194807664, 0.2190012779368783, 0.36176072288120864, 0.4501657026815663, 0.22376088621882873, 0.17870651789426195, 0.7357345300308471, 0.1653771572665248, 0.7069675731553204, 0.6459286487643442, 0.2386872654267831, 0.16062779368451974, 0.6842104689492573, 0.796265751069609, 0.750060308627416, 0.20794735148128063, 0.20755355127163722, 0.747305394235741, 0.2048561624797428, 0.19771472256404, 0.20732126403069706, 0.24511237623555238, 0.20879593368769422, 0.17294918747522936, 0.17301886473062367, 0.17069275746629942, 0.17502068032743223, 0.18641735057803943, 0.17599133681460355, 0.1907697506741466, 0.1738574365361646, 0.1809781123483578, 0.08014187690369057, 0.075911989381521, 0.08334742060718947, 0.10026074018498532, 0.08419092737243139, 0.08258321577982464, 0.08973574724940936, 0.08493754555827837, 0.07423094921507345]}, "mutation_prompt": null}
{"id": "11b80811-fc05-4803-a25c-c450d27966cc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n            self.population_size = int(max(4, self.population_size * 0.99))  # Adjust population size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # <--- Modified line for better adaptability\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive population size control to enhance convergence speed and diversity.", "configspace": "", "generation": 7, "fitness": 0.1719234757174547, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.11.", "error": "", "parent_id": "dffb6e58-740a-4e00-ab41-5743e00a14cb", "metadata": {"aucs": [0.46424003165704564, 0.5916038029977764, 0.30385782359704194, 0.4798254088021705, 0.49312896897687075, 0.4829373849499421, 0.41658925211425224, 0.43138230654877285, 0.3774815219816138, 0.23932419585713516, 9.999999999998899e-05, 0.16213641587204475, 0.08257693432875346, 0.20396117622597654, 9.999999999998899e-05, 0.1654599151111148, 0.14109715106190523, 0.06065691541392404, 0.07876892381152067, 0.07397198860073384, 0.0976432438371807, 0.07443004881133786, 0.08054654249612414, 0.07687375127188256, 0.10530072602863261, 0.09548462037613192, 0.07803607840010696, 0.07153812848869767, 0.06943546522161648, 0.05928533711385553, 0.06414621149441069, 0.07320510288280802, 0.06575157694885014, 0.07989713229842088, 0.07333758728225404, 0.08424166776666298, 0.13215951742970478, 0.12116319442379042, 0.10500744353508384, 0.09921389073370168, 0.3250893934167779, 0.08241201603656301, 0.15305042915344658, 0.10670898279123997, 0.07448735930463735, 0.13969587932677063, 0.12921689918395673, 0.13678655946070106, 0.1467420413136431, 0.1462364731281408, 0.13567366118574953, 0.16249797384343034, 0.11182176353826712, 0.18359257668055962, 0.23390456916684021, 0.3353540539609229, 0.3571284761271418, 0.30115258728630945, 0.34706740154744475, 0.3480765741674101, 0.36616303367528213, 0.39002677672030217, 0.335900931913959, 0.1304942310303746, 0.13451885825951926, 0.18783571384336828, 0.15283273110146745, 0.130140824020336, 0.14056377250006846, 0.11299989887524753, 0.14374015790327488, 0.12885849752160428, 0.033283884650769924, 0.12795306072625223, 0.1386163962817163, 0.14180058213812485, 0.170685378542633, 0.12346962636736847, 0.12180758804497382, 0.1644363522655734, 0.11647341923241838, 0.13751916733167457, 0.0830042362251272, 0.08376802756841295, 0.11400360562133105, 0.08953101409261233, 0.08047952701159178, 0.0804050528943806, 0.059070453439159065, 0.12229528261070388, 0.2329772551226159, 0.2400544113065305, 0.2941022471455448, 0.10985174896981642, 0.17935948315524508, 0.2217446411158568, 0.25541265103342614, 0.2688853971123685, 0.21219359237883495, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01157603933374829, 9.999999999998899e-05, 0.021251370933265235, 0.0038886659258432488, 0.08719832953250573, 9.999999999998899e-05, 0.1132747423341367, 0.15479612005490329, 0.125683674901085, 0.070382967833448, 0.08840884892116663, 0.15361016796006788, 0.10826405879875689, 0.15786225220969574, 0.13215606135401337, 0.4523168132448575, 0.3916669381016512, 0.44420696237224344, 0.4240663437017793, 0.44896673674253673, 0.39767730687635483, 0.5192010908423419, 0.43437068079138397, 0.30594103148556673, 0.09195670317913573, 0.07360421719818311, 0.08218063034698175, 0.08745590264152525, 0.1120665760546713, 0.07909894181500643, 0.08318883193047422, 0.07730267732240059, 0.09633211360273053, 0.14660929726052074, 0.13646070171067948, 0.12806240112048584, 0.12278544339817932, 0.13300097448050852, 0.13877246882908034, 0.1116725589387555, 0.13519290849455046, 0.13667631468685026, 0.23556121493127558, 0.25066037593248003, 0.2538171112218429, 0.32691506674493387, 0.26342704654064386, 0.3079966883909627, 0.26583589104929917, 0.2656538125447855, 0.28547803032428964, 0.23502265393017474, 0.18551097411184125, 0.22362638729265405, 0.17447440103765766, 0.18400464238688008, 0.19915575379666284, 0.24872497814116123, 0.18428981177615578, 0.1775994968165342, 0.1727890238988753, 0.19420280210571816, 0.17821782809238662, 0.16678407094773573, 0.1825531756772243, 0.17339178402797062, 0.17004430425708816, 0.18375512424398244, 0.17055967580666964, 0.1615878890253274, 0.17368243324045562, 0.18082091772621667, 0.16736058035569912, 0.17722069016221487, 0.16389002754236048, 0.16606199270724997, 0.17865593920680967, 0.17535911630864554, 0.16459634369425535, 0.11824257626860146, 0.20174900590437517, 0.19395551657445764, 0.18300255186862469, 0.1808439253950327, 0.167085078042724, 0.19698895055341503, 0.1833486076056795, 0.17760209764309898, 0.19530240837923096, 0.20155340436551072, 0.16660299520705535, 0.19177365041393202, 0.20724177871592397, 0.14999240654380086, 0.2040717249451528, 0.20015814650989217, 0.16564642460789314, 0.16622496406984133, 0.1588775886173528, 0.17353678840746212, 0.18303110491197205, 0.1599393538963514, 0.17283369560324668, 0.18024619013788656, 0.1742815224020815, 0.07770952297907752, 0.06576592998521424, 0.06144009390513461, 0.08091490837497672, 0.06901969353905446, 0.06583090871704622, 0.0630827872563623, 0.07581209440541337, 0.06293486983848362]}, "mutation_prompt": null}
{"id": "5e50ae28-65b7-4476-9b95-bcfe059c935d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # <--- Modified line for better adaptability\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling based on successful trial improvements to refine exploration-exploitation balance.", "configspace": "", "generation": 8, "fitness": 0.34317811374310203, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.23.", "error": "", "parent_id": "dffb6e58-740a-4e00-ab41-5743e00a14cb", "metadata": {"aucs": [0.7660504719264204, 0.7499100288098359, 0.7458289389085009, 0.7554106989115822, 0.7510889561506413, 0.7504732920866521, 0.7683507586989841, 0.7727595494056048, 0.7515040220697587, 0.5712588585724317, 0.5525643407402758, 0.5493336081545888, 0.5489636250560908, 0.5520669208805353, 0.5228611264848566, 0.570604333956032, 0.5534986567282729, 0.5851443762579857, 0.08775435755694538, 0.09926691451612646, 0.1027934549851065, 0.10163641195693995, 0.08735112710022896, 0.10228305601977172, 0.09725949295559344, 0.09867216019744462, 0.08614020842393288, 0.09723941502124012, 0.08804624845501507, 0.09906937010263461, 0.09335270110976912, 0.1034086531610714, 0.08249464349009672, 0.08784175432824881, 0.08583479924891713, 0.08931805057988784, 0.5536077528623572, 0.1818457904801416, 0.3225836558623655, 0.13363009317161034, 0.1405096551100763, 0.11022550426728284, 0.1662707876317372, 0.322955639207008, 0.16842843949551245, 0.34968700545988585, 0.21619565634393612, 0.23839020050010118, 0.2955929269199562, 0.25204363576853506, 0.29586452370501437, 0.26847353412497643, 0.3089647478590979, 0.2585043752226067, 0.7977629647003883, 0.7895963077174121, 0.7298429644176483, 0.783138581826805, 0.7600601408195921, 0.79022948241154, 0.745597190882481, 0.8032493305107562, 0.7976891243835399, 0.21556588996498283, 0.453092382305768, 0.20533335327952917, 0.14700026870599014, 0.14406103416680638, 0.20980778226286112, 0.20133612551116808, 0.18365217312419668, 0.2028529357260589, 0.15101785128796763, 0.16293703729861864, 0.11574759887424602, 0.24657076508441578, 0.22599770246770534, 0.261331639391012, 0.2277457072972382, 0.15486412038636388, 0.2013623117847354, 0.5419886165990038, 0.5486172619117535, 0.5470966078519324, 0.5430196206274966, 0.5273295160268876, 0.546619864429647, 0.5660014979911638, 0.49629005934352255, 0.5404919732070803, 0.657309587317356, 0.6402664700496967, 0.6557159178072813, 0.6616029906701133, 0.6480036520012995, 0.6402213707197634, 0.6521952827449263, 0.6798197959701662, 0.6529190220416636, 0.25257970958259335, 0.12172745038557242, 0.1418350052240206, 0.3608598918218274, 0.1645645078324578, 0.3243610420106966, 0.12196958046758155, 0.1491331154448533, 0.22668620481392754, 0.35543707114669776, 0.3833164776443869, 0.4068066124713956, 0.374910521517443, 0.4158637801668429, 0.4359461096927386, 0.37410063910578584, 0.39068557110015223, 0.42830462146798476, 0.7437661766153436, 0.7172198618834256, 0.713401021311342, 0.715465471241713, 0.7216995605694103, 0.7305717820015207, 0.7187914483821624, 0.6841099146107323, 0.7309315207739819, 0.09597602632721514, 0.08869699048233903, 0.09512904946351863, 0.11335472714957817, 0.10006592163325989, 0.10384416172985733, 0.10813338794810934, 0.10175908532044609, 0.09742388941362856, 0.15203679748834742, 0.21516606818631578, 0.14037064915266295, 0.13743002763196743, 0.13528462285326692, 0.15701814657336455, 0.3065294928343151, 0.1592759109012155, 0.12607917503481347, 0.3976905936882936, 0.4291699235297053, 0.4227341232263725, 0.3916208419845817, 0.3838403811507395, 0.35129843443355924, 0.3676039242791641, 0.3653135520452585, 0.42433720450454626, 0.37863104666229075, 0.35250034319143875, 0.34929354628673326, 0.33073533597392135, 0.3119403784726338, 0.3421968699949324, 0.34903170130973526, 0.3210678684508176, 0.3616814623965635, 0.19793820410570484, 0.19300613243891063, 0.19234475373449578, 0.18201432826388508, 0.18400257319106972, 0.21511389696715022, 0.19681841609818862, 0.21205106312059951, 0.22161220309590302, 0.17348994666560869, 0.19693503544312252, 0.1844744783067397, 0.22412914319025112, 0.21208773753185028, 0.18069108809794965, 0.18516761965205308, 0.20959714883098102, 0.2128374435356436, 0.1683362875900577, 0.7636222928108629, 0.1696979666724031, 0.7404976766195552, 0.5956644034633559, 0.17409321681721035, 0.6302437483519688, 0.6126825625381556, 0.5320598908335795, 0.6934474426266315, 0.20590970746165504, 0.7333071825703911, 0.6371289091308545, 0.19537119581743845, 0.20062977805626836, 0.2046008165165667, 0.1926856947408917, 0.20834501118825222, 0.17216803739412168, 0.17209613157232306, 0.1917995732448209, 0.18105279333945323, 0.19845928267425916, 0.1821497376412886, 0.18945367229800902, 0.19357267289133262, 0.189740984132724, 0.07125993584313162, 0.07800761819710611, 0.08441854095734658, 0.08456505948556481, 0.07372628897598532, 0.07825881567993509, 0.07720897536514837, 0.08787659421675176, 0.07455534663162666]}, "mutation_prompt": null}
{"id": "adb08c7e-a9d6-4d64-b589-724776f8adc6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas))) + 0.05 * np.random.rand()  # <--- Added random perturbation for maintaining diversity\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a small random perturbation in the crossover rate to maintain diversity in the population.", "configspace": "", "generation": 9, "fitness": 0.35143093882134085, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "dffb6e58-740a-4e00-ab41-5743e00a14cb", "metadata": {"aucs": [0.7481917179315777, 0.7591591380541227, 0.7379791129624047, 0.7676985613491818, 0.7747879503163183, 0.7626828116971289, 0.7694136339555768, 0.7745766775635419, 0.7760004884836156, 0.6079103787963677, 0.5457291561952706, 0.6308218824954688, 0.6114966184045821, 0.5930869098949436, 0.5986084964743456, 0.5563195545161159, 0.6122768761111346, 0.5099388582292603, 0.09742273471176921, 0.11261508545816501, 0.09799692745467714, 0.09907907110074343, 0.09785122433690507, 0.09425073272941409, 0.10337324438017936, 0.11122757730262911, 0.11146237585867802, 0.10019488902005191, 0.1084138071521904, 0.08618839641453924, 0.09899096450973943, 0.10900781956343031, 0.10061999127982035, 0.10885685697390124, 0.08743836106010894, 0.10140859121930612, 0.1254934552613236, 0.20533315195639246, 0.29956490496905486, 0.1623102468552493, 0.19879584644253434, 0.0810138776317717, 0.2601768049586879, 0.10508387894695226, 0.1730494355502057, 0.24377479439787197, 0.22417171282331694, 0.23461637972198113, 0.43343899417381004, 0.13507115117670054, 0.2748034306055659, 0.2569340979391098, 0.18691753036437964, 0.21743914935269504, 0.8011418095181182, 0.7880795472765272, 0.7834435209737349, 0.8152808025154765, 0.7899110376412116, 0.7740481685081189, 0.7915649306654023, 0.8199106486552377, 0.7869486349837282, 0.16255998260235371, 0.20269859058770645, 0.22018906105682212, 0.3427407241342174, 0.1773742180510811, 0.18058001078586372, 0.28390996912015165, 0.18964434838382405, 0.23302430410553543, 0.17551874191607042, 0.15060165924738844, 0.22954742074223555, 0.1799671669879399, 0.21380655376179936, 0.18465350140577153, 0.25052284223182975, 0.14037887941589766, 0.15876654220312725, 0.6078228936199258, 0.5637968046753141, 0.5540468777791527, 0.5709350141803551, 0.612471884680459, 0.6133497602433627, 0.5639980746733086, 0.5567762430703184, 0.5636278818707954, 0.6805072800277645, 0.6915339321376418, 0.6873664205013124, 0.629759512759743, 0.6624829373624583, 0.6549511193398039, 0.6597995524158315, 0.7091267302501412, 0.6602590113646956, 0.15450903456245246, 0.318259900187043, 0.1688912048191662, 0.2686543269344981, 0.38532110385542795, 0.3987296413281003, 0.17152791509699405, 0.19701950633962384, 0.28014409715054167, 0.4161282873155654, 0.41405408580232594, 0.4194999255262044, 0.463598209751789, 0.4016110636158051, 0.4136323160159665, 0.4155425483188123, 0.40735561709257373, 0.40847318571941094, 0.7468154953400136, 0.7410662271983943, 0.7597836086076272, 0.7569606030540772, 0.7338157306500196, 0.7372668388850175, 0.7779321404761739, 0.7202071557216787, 0.7511344123193493, 0.10702499618071903, 0.09440949324128944, 0.10294758861680053, 0.11511747597807209, 0.09295340423273502, 0.14226256963782757, 0.10507806385902674, 0.09666511016987134, 0.1090833057128886, 0.12602724116571296, 0.14438606383456842, 0.1502892412368354, 0.22877924319378407, 0.18242056174214927, 0.2093988346481641, 0.17995543802045721, 0.1965092190430492, 0.22556031306616808, 0.4459795304588281, 0.44219282184715425, 0.4690861114818582, 0.4082995942993164, 0.4335248695240238, 0.40793126599383, 0.4414403472691465, 0.4392013870866608, 0.4277539459658799, 0.35591675201809025, 0.3729972554106816, 0.4217007222113044, 0.36332585408054563, 0.3819648126405154, 0.33785345311265824, 0.3697003049347859, 0.3921352426025675, 0.3533960615617131, 0.19836277282812176, 0.19887616729740998, 0.1962128455407698, 0.20877402159768477, 0.20092201262309317, 0.18770528859950342, 0.20285232828322874, 0.1906020274336493, 0.22731415295907564, 0.2056923286297082, 0.3203804106097823, 0.1890936782299334, 0.2028730534963461, 0.44939366359849686, 0.18053065286130188, 0.19632243403636152, 0.18394749786482623, 0.22760417822461942, 0.16214828388512137, 0.17696714241421618, 0.7370662913163804, 0.1733609636296758, 0.7924629910902635, 0.23820870004665184, 0.6898571374058311, 0.7482842471328521, 0.746709725405748, 0.7896357434157142, 0.20626229811552688, 0.19566664360384056, 0.25165493194092814, 0.19096787176107632, 0.19613086197747187, 0.20662674203617604, 0.29923854108816794, 0.2083207791319387, 0.20665437061275416, 0.17643913452697346, 0.17531437718008802, 0.17747753981751468, 0.18032848098311882, 0.18164195166410768, 0.1847070381229211, 0.17730384473761007, 0.19052742547679213, 0.08728082636644974, 0.07680656461402235, 0.07603151393382501, 0.0861527265474773, 0.07880099353524872, 0.08109233963945572, 0.07986847874676062, 0.08204408832652765, 0.0818871371877925]}, "mutation_prompt": null}
{"id": "45d8c479-4060-4112-b27b-9b057958a799", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = min(1.0, np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas))))  # <--- Modified line for better adaptability\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive crossover probability influenced by fitness improvement rate to enhance exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.36021677756144094, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "dffb6e58-740a-4e00-ab41-5743e00a14cb", "metadata": {"aucs": [0.7834055135075157, 0.7539065387158493, 0.7932550159935361, 0.7667390436267865, 0.7955619082037384, 0.769117207206907, 0.7682925976676824, 0.7676351304605228, 0.7849341824188166, 0.6022021841186406, 0.591827113341723, 0.5920375907513111, 0.6018222185832989, 0.5998113236471633, 0.6400734070217023, 0.6046482714691308, 0.6032266077412661, 0.6340526739938979, 0.10003881504837586, 0.10166481169009678, 0.10964362474175982, 0.10258036274842564, 0.1000278692121801, 0.11703575854090398, 0.1137568085638253, 0.11048905633244666, 0.10018763129379915, 0.1020789191400645, 0.09697767619099518, 0.10230972595195342, 0.0848368274652439, 0.08942066785933223, 0.11687601175878937, 0.11279925149106751, 0.08877045732789157, 0.09669567612012564, 0.11387467892858005, 0.20687590356637342, 0.2869454082656483, 0.13803043990275254, 0.09817684833452389, 0.09728892090738372, 0.14777368962436999, 0.1423351918122524, 0.1378235953753092, 0.22259542586817305, 0.2459259858106596, 0.15139682191705628, 0.2653807877716775, 0.42795884319356514, 0.21103939706104402, 0.20384272878350662, 0.17929010419395963, 0.21876884648835815, 0.8092556901079198, 0.8160855247529384, 0.7772726291841561, 0.8040481278452719, 0.810353953056513, 0.8055276324830367, 0.8102240147612789, 0.7992059871208675, 0.809216683653594, 0.2509784872869585, 0.29251515165241915, 0.5487944186397578, 0.20526297392939385, 0.14654178424591013, 0.18641163755763102, 0.371145978583618, 0.5507892266300962, 0.14106875814309805, 0.34485315867020083, 0.5924365251063249, 0.16403477573718006, 0.24399480868559054, 0.5602521757651697, 0.18472558560184105, 0.21046063350473987, 0.2380350569627443, 0.16522702129119282, 0.5741471945745564, 0.5435020590333124, 0.5407682035837416, 0.5961208459433089, 0.5877967788918328, 0.5757402786553776, 0.6148945062915756, 0.5835686550925272, 0.547179503129811, 0.6618143734424886, 0.6595372940246129, 0.6834567928506452, 0.6790657632092614, 0.6801111828745432, 0.6692437633195745, 0.6985825968328645, 0.6596275521012356, 0.6583822693872975, 0.12655015668241854, 0.17864190531100643, 0.3029744981954501, 0.16374953666783987, 0.3604870707496204, 0.3342046648970478, 0.2806507119347559, 0.26084235781872245, 0.1780763315276327, 0.41198920751018764, 0.4372091403999311, 0.43666180390250575, 0.3990293532754078, 0.45403405552549103, 0.4094304188448519, 0.40247676799990306, 0.43852098525233474, 0.41489091892400154, 0.7312024385929685, 0.714541082366348, 0.7411294732442685, 0.7737929239778792, 0.7252291358223695, 0.7243774551724937, 0.7670843620913861, 0.7417967203660261, 0.724628914762169, 0.10573670217922793, 0.08994692102967361, 0.09701848573678451, 0.10457008313255867, 0.10899717428862388, 0.10890338436446723, 0.10580684735150192, 0.1012377839495382, 0.1170066207977779, 0.1867001423263367, 0.16215316083027376, 0.31894153505502076, 0.1759071682249751, 0.2595569798659437, 0.15377677589925443, 0.15353260935816815, 0.19683141765279444, 0.15762803447872542, 0.42226919042344013, 0.3915339545457325, 0.43145849759607036, 0.3972036606019882, 0.43951923835490014, 0.41258787824388, 0.4310307291824057, 0.41102804820980865, 0.43078700924198654, 0.3725145083852508, 0.34792232647273635, 0.4079430546262409, 0.34384312492212554, 0.36710118143369563, 0.3461143352689895, 0.3854837073798675, 0.36755514347097973, 0.37079204125835497, 0.22184548515390035, 0.2029851867549095, 0.1887708986476525, 0.21766742269336325, 0.20548680156004073, 0.20256597333109294, 0.2029110025609152, 0.18699353751914527, 0.2199716792458546, 0.19671247327156394, 0.1855777146503138, 0.2001501369803027, 0.22298491926078234, 0.19184151194807664, 0.2190012779368783, 0.3617607228924128, 0.4501657026815663, 0.22376088621882873, 0.17870651789426195, 0.7357345300308471, 0.1653771572665248, 0.7069675731553204, 0.6459286487643442, 0.2386872654267831, 0.16062779368451974, 0.6842104689492573, 0.796265751069609, 0.750060308627416, 0.20794735148128063, 0.20755355127163722, 0.747305394235741, 0.2048561624797428, 0.19771472256404, 0.20732126403069706, 0.24511237623555238, 0.20879593368769422, 0.17294918747522936, 0.17301886473062367, 0.17069275746629942, 0.17502068032743223, 0.18641735057803943, 0.17599133681460355, 0.1907697506741466, 0.1738574365361646, 0.1809781123483578, 0.08014187690369057, 0.075911989381521, 0.08334742060718947, 0.10026074018498532, 0.08419092737243139, 0.08258321577982464, 0.08973574724940936, 0.08493754555827837, 0.07423094921507345]}, "mutation_prompt": null}
{"id": "09c463ce-aace-46b9-b406-1b9db8711de4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # <--- Modified line for better adaptability\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive scaling factor adjustment based on success history for improved convergence.", "configspace": "", "generation": 11, "fitness": 0.36021677790941586, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "dffb6e58-740a-4e00-ab41-5743e00a14cb", "metadata": {"aucs": [0.7834055135075151, 0.7539065387158567, 0.7932550159935319, 0.7667390436265336, 0.7955619082037478, 0.769117207206907, 0.7682925976675603, 0.7676351304605852, 0.7849341824188231, 0.6022021841337559, 0.5918271133434706, 0.5920375908411756, 0.6018222184391794, 0.5998113236475114, 0.6400734070218288, 0.6046482715036774, 0.6032266077406356, 0.6340526739934333, 0.10003881504837586, 0.10166481169009678, 0.10964362474175982, 0.10258036274842564, 0.1000278692121801, 0.11703575854090398, 0.1137568085638253, 0.11048905633244666, 0.10018763129379915, 0.1020789191400645, 0.09697767619099518, 0.10230972595195342, 0.0848368274652439, 0.08942066785933223, 0.11687601175878937, 0.11279925149106751, 0.08877045732789157, 0.09669567612012564, 0.11387467892858072, 0.20687590356638907, 0.2869454082656483, 0.13803043990275254, 0.09817684833452389, 0.09728892090738372, 0.14777368962434245, 0.14233519181223797, 0.1378235953753434, 0.22259542586817305, 0.2459259858106596, 0.15139682191705628, 0.2653807877716775, 0.42795884319401434, 0.2110393970610348, 0.20384272878350662, 0.17929010419395963, 0.2187688464883666, 0.8092556901079198, 0.8160855247529384, 0.7772726291841561, 0.8040481278452719, 0.810353953056513, 0.8055276324830367, 0.8102240147612789, 0.7992059871208675, 0.809216683653594, 0.2509784872869585, 0.29251515165241915, 0.5487944186395937, 0.2052629739294275, 0.14654178424591013, 0.1864116375575685, 0.3711459785839082, 0.5507892266198418, 0.14106875814309805, 0.34485315867020094, 0.5924365251062069, 0.16403477573717573, 0.24399480868557588, 0.5602521757553656, 0.18472558560184105, 0.21046063350473987, 0.2380350569627443, 0.16522702129119282, 0.57414719448297, 0.5435020590049777, 0.5407682035796205, 0.5961208462797136, 0.587796778893666, 0.5757402786546884, 0.6148945062963445, 0.5835686550776451, 0.5471795031352038, 0.6618143734425785, 0.6595372940246129, 0.6834567928506452, 0.6790657632084238, 0.6801111827740034, 0.6692437633126274, 0.6985825968314188, 0.6596275521067574, 0.658382269396919, 0.1265501566823335, 0.17864190531095026, 0.30297449826556233, 0.16374953666847636, 0.3604870720564961, 0.3342046651056032, 0.28065071188571045, 0.26084235781629206, 0.1780763315284728, 0.4119892047202617, 0.4372091837632931, 0.4366617786666893, 0.39902936834902425, 0.4540337833333511, 0.4094304435410663, 0.402476839351564, 0.4385209562111523, 0.41489116782611246, 0.7312024385719107, 0.7145410823667726, 0.7411294729040945, 0.77379292397704, 0.7252291354222924, 0.7243774551692473, 0.7670843620913861, 0.741796720545931, 0.724628914762169, 0.10573670217922793, 0.08994692102967361, 0.09701848573678451, 0.10457008313255867, 0.10899717428862388, 0.10890338436446723, 0.10580684735150192, 0.1012377839495382, 0.1170066207977779, 0.1867001423263367, 0.16215316083027376, 0.31894153505502076, 0.1759071682249751, 0.2595569798659437, 0.15377677589925443, 0.15353260935816815, 0.19683141765279444, 0.15762803447872542, 0.42226919042344013, 0.3915339545460934, 0.43145849759607036, 0.39720366060205803, 0.4395192383558538, 0.4125878782435831, 0.4310307291824057, 0.41102804821121186, 0.43078700924780655, 0.37251450838212474, 0.34792232647207877, 0.4079430546266306, 0.34384312492240565, 0.36710118143396286, 0.3461143352685231, 0.3854837073798675, 0.36755514347097973, 0.3707920412580372, 0.22184548515390035, 0.2029851867549095, 0.1887708986476525, 0.21766742269336325, 0.20548680156004073, 0.20256597333109294, 0.2029110025609152, 0.18699353751914527, 0.2199716792458546, 0.19671247327156394, 0.1855777146503138, 0.2001501369803027, 0.22298491926078234, 0.19184151194807664, 0.2190012779368783, 0.36176072288120864, 0.4501657026815663, 0.22376088621882873, 0.17870651789426195, 0.7357345300308471, 0.1653771572665248, 0.7069675731553204, 0.6459286487643442, 0.2386872654267831, 0.16062779368451974, 0.6842104689492573, 0.796265751069609, 0.750060308627416, 0.20794735148128063, 0.20755355127163722, 0.747305394235741, 0.2048561624797428, 0.19771472256404, 0.20732126403069706, 0.24511237623555238, 0.20879593368769422, 0.17294918747522936, 0.17301886473062367, 0.17069275746629942, 0.17502068032743223, 0.18641735057803943, 0.17599133681460355, 0.1907697506741466, 0.1738574365361646, 0.1809781123483578, 0.08014187690369057, 0.075911989381521, 0.08334742060718947, 0.10026074018498532, 0.08419092737243139, 0.08258321577982464, 0.08973574724940936, 0.08493754555827837, 0.07423094921507345]}, "mutation_prompt": null}
{"id": "ff7358f8-d3e7-4b38-b1ba-733f7aed1e14", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas))) + 0.05 * np.sqrt(np.var(self.successful_deltas))  # <--- Modified line for adaptive CR\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability by incorporating fitness-based feedback to improve convergence.", "configspace": "", "generation": 12, "fitness": 0.35270789833269667, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "dffb6e58-740a-4e00-ab41-5743e00a14cb", "metadata": {"aucs": [0.7795854201228671, 0.7646315905175295, 0.7519985138491438, 0.7461145718818456, 0.7606395389610923, 0.767040822436149, 0.7807402536039022, 0.7811816281854828, 0.7849341824188406, 0.5769728639133593, 0.5690433536733512, 0.5957292325527732, 0.5969147193613276, 0.5944157802112143, 0.6108243068186185, 0.6125474772900108, 0.590198684896422, 0.5555375243779339, 0.09745278568124982, 0.12279364387776681, 0.1006776558331196, 0.11065267769393339, 0.10158103663597284, 0.23831422479930708, 0.10070471291896754, 0.10569446572367924, 0.09787819991344682, 0.08669246846146328, 0.09914136379664573, 0.09662245661923441, 0.08652174740617447, 0.0825741876924978, 0.10745468581730477, 0.08997007379478783, 0.08999641238078038, 0.09419612363762775, 0.10672207466052275, 0.2517134234777132, 0.3324648061402974, 0.11513397900271594, 0.13422353237222773, 0.08404353952023425, 0.21918148501840795, 0.11936970743009534, 0.17226353199594668, 0.4285248453516769, 0.3987796975389246, 0.27207039524993226, 0.25695531149458006, 0.31506311325321523, 0.21103939706104402, 0.2038427287835025, 0.25539611273540375, 0.296584529200561, 0.8197219836265092, 0.8160855247529384, 0.7824349443588543, 0.8040481278452719, 0.8230805785147369, 0.8010835022269499, 0.8102240147612789, 0.8060447405510269, 0.7847385050105121, 0.22201082248375015, 0.2925151516524074, 0.22864820809003206, 0.15194503242106472, 0.15104194359913814, 0.1328104151144056, 0.37114597858446463, 0.2339767569046245, 0.21295311370397274, 0.19020362242817979, 0.5397861950206624, 0.16403477573717573, 0.279405237630478, 0.22635083850071525, 0.2359298679220485, 0.18804486239828644, 0.16237058543286753, 0.16522702129119282, 0.6036269676437449, 0.558410298293871, 0.5407682036098624, 0.5673999884190577, 0.5526454567440381, 0.5981822463819042, 0.5896402510437095, 0.554944502568735, 0.5773536130903509, 0.6618143734263604, 0.6685744406015448, 0.6656233938281253, 0.6548648609976743, 0.6539703190128139, 0.6737817237594438, 0.6912348037668821, 0.6971224646866057, 0.6786833301003765, 0.10056180208267629, 0.17918149719541798, 0.21538226809886218, 0.22793611208099152, 0.22001785665202112, 0.33420466480634436, 0.29860892496829405, 0.2651384621035312, 0.17807633152845537, 0.41198928470864704, 0.44160658778268524, 0.42621289076233515, 0.4367247085940109, 0.4352072373241874, 0.40943073446473865, 0.4024767846609021, 0.43909227654961025, 0.4324104720310107, 0.7312024387208989, 0.7299420050332408, 0.7260108227766233, 0.7580256559944604, 0.7284825769570804, 0.7310497592134912, 0.7457937933995361, 0.7485574346964552, 0.7055482746598072, 0.10272755316856996, 0.1141590679082799, 0.08777189082294024, 0.09812306190274633, 0.10816642253221398, 0.10773313249886884, 0.10037450863098107, 0.11779342932006875, 0.11240231266067113, 0.14749570924807065, 0.14431303624454084, 0.15611499289286712, 0.1327062567845385, 0.17728067616039767, 0.2042946851119053, 0.1642244431972978, 0.18907321667254484, 0.16192193041062508, 0.4046339960390337, 0.3836145665879904, 0.3995590101501295, 0.455017671296135, 0.43860951759696354, 0.426839149086792, 0.42010301244121306, 0.4187418425721413, 0.41363745818551023, 0.35729026616763426, 0.3545567200279617, 0.3885725803159542, 0.3777150300399178, 0.3566541935407648, 0.39873447785849137, 0.39710750996193867, 0.3367592369746366, 0.38479185834516727, 0.18648574470495427, 0.198200494915987, 0.2024564877783972, 0.1930425285906071, 0.2028780040435454, 0.1886924921663724, 0.20272824459546623, 0.20956382401626517, 0.1933084735120132, 0.19671247327156394, 0.24942263340645765, 0.22172432648313523, 0.19140153801109305, 0.1961151732614812, 0.2065007658754937, 0.2115193229932042, 0.18580935614458993, 0.18772543629917715, 0.16125925048058365, 0.1604933779923745, 0.6048398796560954, 0.4056868608602694, 0.800566790157413, 0.2386872654267831, 0.6770179449025666, 0.16693300617921925, 0.6868177547179882, 0.7713815113234446, 0.20482412360997526, 0.6907311892260961, 0.7186962330678279, 0.2039072249989231, 0.20295573719714988, 0.20556430512850787, 0.15073183786039535, 0.20865023318316145, 0.17091391133246292, 0.1804484876888116, 0.17697231699070126, 0.17747753981751468, 0.2124951328726714, 0.17599133681460355, 0.1782370914171033, 0.19817819424727745, 0.19065051504557007, 0.09392539292836355, 0.07672998972258449, 0.08334742060718947, 0.09123527871933945, 0.0831689051476967, 0.08258321577982464, 0.08280852275279538, 0.08294322419032596, 0.07843644996478338]}, "mutation_prompt": null}
{"id": "516426a7-0399-4e2c-8799-9a7c3637dc11", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c) * np.random.uniform(0.8, 1.2), self.lower_bound, self.upper_bound)  # <--- Modified line for better exploration\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing a random scaling factor to the mutation step size.", "configspace": "", "generation": 13, "fitness": 0.36108549811280793, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "dffb6e58-740a-4e00-ab41-5743e00a14cb", "metadata": {"aucs": [0.7768306650174299, 0.7673674637757959, 0.7669175768492563, 0.7570414593617347, 0.7183786199601954, 0.778723117458242, 0.7755040141486551, 0.7346810715046965, 0.7704742152141679, 0.6131915349902934, 0.6089594005723163, 0.6105513918437482, 0.6009874341939819, 0.6014974833439088, 0.6304732558433173, 0.5806332812230615, 0.6274301771038173, 0.6064034811358016, 0.11440922693503164, 0.10104285073268582, 0.09429652861070059, 0.09788378272870923, 0.10440439736752904, 0.09358617258668367, 0.10265775669339239, 0.10403331126576376, 0.09590036198727214, 0.10283106600797687, 0.08027008894074839, 0.09506609453259462, 0.09595930986363543, 0.09390717951282679, 0.10531991787827488, 0.09255815062329875, 0.0983730073943958, 0.0977199445421566, 0.13130562510259425, 0.09013673493414354, 0.19497320964915388, 0.19359708624550842, 0.22794749506179424, 0.20249737572860405, 0.21862418352875057, 0.10698771813016861, 0.168803342252541, 0.27561874078127646, 0.1147381122226423, 0.167307457596496, 0.33797332236983835, 0.1835055029031123, 0.2012291233675354, 0.1804199222582874, 0.36486897456033685, 0.19336527743753262, 0.829611135960362, 0.8191209465666751, 0.8243012421324467, 0.8060749188579734, 0.8562963665233014, 0.8172922710918187, 0.7818372514543698, 0.8298736288987785, 0.7905834363362543, 0.2567824606069069, 0.2807142569342401, 0.16367562246876532, 0.20101638227240715, 0.15614439703837413, 0.17945710977590457, 0.17856233827444068, 0.6032839597122095, 0.2428536868668255, 0.24794692524226614, 0.21525111499701732, 0.1511754158623433, 0.1416358279709251, 0.17789689516795948, 0.21168496929216318, 0.20888890661376402, 0.1859722011666567, 0.16205324785203923, 0.5690870131916274, 0.5529618614692031, 0.5546342902352054, 0.5817382307242123, 0.5846510170333271, 0.5786388467549926, 0.579105484553163, 0.5954645121914872, 0.6107708404646353, 0.6806261244239034, 0.6840301623970109, 0.6959629566681622, 0.6753418643843772, 0.6168592272503872, 0.7077186588776544, 0.6674529162758929, 0.6830945757765039, 0.6563397508766334, 0.09585124241168996, 0.11443071754408551, 0.2171912068071854, 0.4379881834476248, 0.22291763353783423, 0.3564317019542994, 0.1479043734918989, 0.2892946212874885, 0.26481808407823104, 0.4434548304369098, 0.45551521924596283, 0.42302048167410444, 0.41935658054922564, 0.4450574530820097, 0.41292516796744516, 0.43696583193029315, 0.4428401917026922, 0.39130586193839223, 0.7455024106524497, 0.725766226478689, 0.7651393416863927, 0.74915222243121, 0.7526923337838112, 0.7224248426223047, 0.7335675805486577, 0.7350416768080889, 0.7460872488114196, 0.10854786300986685, 0.13501893739701687, 0.09893404964476071, 0.12358333569019797, 0.11976825716471107, 0.09115394038096236, 0.12101983026757424, 0.12608051409867949, 0.11431237986774068, 0.16528867692519977, 0.144232877022886, 0.26635498509060784, 0.14268290517082838, 0.16277920595505946, 0.14236231646868414, 0.3940325533082595, 0.23027412181862705, 0.186106446983772, 0.4332772857186078, 0.4483866110748025, 0.43341635915321197, 0.45759828199922203, 0.4394080990962249, 0.45180291013038965, 0.45787881457015667, 0.4275020953871821, 0.44593544646651706, 0.3860640426845936, 0.4101607120903016, 0.39396858713353833, 0.3304408630118356, 0.35972379972206725, 0.3951505780320821, 0.3888116769051013, 0.3850803791113543, 0.3644325081931188, 0.19008241749655486, 0.21051516980177232, 0.2007182128741869, 0.21076603813105188, 0.18375247438198838, 0.1834756969692355, 0.18834475509880633, 0.210476106039018, 0.20485640504255764, 0.19825827804363794, 0.17850976117465778, 0.18543008477948586, 0.18724796112910913, 0.2000994700952029, 0.22255963499703513, 0.1852575556259891, 0.20195552746294798, 0.19586469049868915, 0.7682994311723992, 0.20463626448603245, 0.16702963045971664, 0.8253229740634711, 0.6998754711298931, 0.6677189102963916, 0.18285577880707038, 0.6492197022990083, 0.7260177362480926, 0.7930101440887749, 0.7372804411277474, 0.7271051606682539, 0.7188125244444914, 0.1590314769049297, 0.16527602290556553, 0.15181500943578574, 0.29887225868673795, 0.21084394141387974, 0.18057944490860867, 0.17996813819665225, 0.1811170041853365, 0.1845832356452093, 0.19970630470179163, 0.17834385648911288, 0.18588158360747176, 0.1883078822149763, 0.1892482494844684, 0.07693615578684532, 0.07705519154491525, 0.0849350059358801, 0.08329159909853401, 0.0717842254794403, 0.07886129443941658, 0.0838139613154184, 0.07929056555237257, 0.08072601648377753]}, "mutation_prompt": null}
{"id": "073df800-9305-42a9-a241-e4e0046ab5c5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.elite_fraction = 0.1  # Fraction of elites\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            elite_indices = fitness.argsort()[:int(self.elite_fraction * self.population_size)]\n            elites = population[elite_indices]\n            new_population = np.copy(elites)\n\n            for i in range(len(elites), self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_adapted = self.F + 0.1 * np.random.randn() * (len(self.successful_deltas) / (i+1))\n                mutant = np.clip(a + F_adapted * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population = np.vstack([new_population, trial])\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n                else:\n                    new_population = np.vstack([new_population, population[i]])\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            population = new_population[:self.population_size]\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce elite preservation and adaptive mutation scaling based on success rate to improve convergence.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 10')", "parent_id": "516426a7-0399-4e2c-8799-9a7c3637dc11", "metadata": {}, "mutation_prompt": null}
{"id": "52cf671c-bc5d-4974-bfed-caa2bf46b7f9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.success_rate = 0.0\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c) * np.random.uniform(0.8, 1.2), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n                    self.success_rate = (self.success_rate * i + 1) / (i + 1)  # Update success rate\n\n                if len(self.successful_deltas) > self.population_size:\n                    self.update_parameters()\n\n            self.CR = 0.9 * self.success_rate + 0.1 * (1 - self.success_rate)  # Adaptive CR based on success rate\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover probability based on success rate to balance exploration and exploitation.", "configspace": "", "generation": 15, "fitness": 0.3534843516365933, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "516426a7-0399-4e2c-8799-9a7c3637dc11", "metadata": {"aucs": [0.7909011051392081, 0.7478725095843815, 0.7714489887940132, 0.7711337687217396, 0.7785279854443808, 0.7828865489449001, 0.7979076250921155, 0.7659972618987054, 0.7842411276266998, 0.6011586810667431, 0.6227980904751457, 0.5973223188830588, 0.5658788016709249, 0.6279732270858078, 0.5723800335963516, 0.5938894660650575, 0.6196647833995667, 0.6124271320906531, 0.14031569781665698, 0.10826630142808369, 0.11070823885610703, 0.1133510453769695, 0.11292581886546071, 0.11987862203455935, 0.12603037602666867, 0.1105130274745969, 0.10738638713542425, 0.1134616554424348, 0.11232307408115472, 0.10838128344674336, 0.11131310036111774, 0.1102144339745249, 0.0972792837968045, 0.10566994085095571, 0.1148396509707329, 0.10418800076354306, 0.9180244816932506, 0.8360273918001808, 0.8021922762249631, 0.9074617409495512, 0.9020589764252954, 0.7791345571006133, 0.9308409500637917, 0.8414696426668138, 0.8780396428492581, 0.4041671486630256, 0.38645166035591416, 0.3929851751785609, 0.43119716302096045, 0.43256947545043267, 0.36679378440827093, 0.4555686691544034, 0.4405721726046128, 0.38119577724883824, 0.7775262183703727, 0.7320196454355548, 0.7163972638143519, 0.7293600709498133, 0.7395026698324219, 0.7877848918910273, 0.7291815449725113, 0.6980414556661592, 0.7359311326250193, 0.2425335306398565, 0.17279772146407923, 0.19488287584970576, 0.3608062404924769, 0.3040140764598802, 0.1611764248188201, 0.1658526755525883, 0.19028048356642457, 0.21330003089302996, 0.17731301904068442, 0.1560900002541542, 0.1834034494961405, 0.42869037338284954, 0.18685754309661506, 0.21080517116780273, 0.1879097050841021, 0.2033590485697523, 0.18849254678378924, 0.31390133011866184, 0.3353731123536309, 0.4191216008729022, 0.38711657070377836, 0.3833480914556693, 0.36040483659601796, 0.33318158278607235, 0.40229377926604004, 0.32279556133663145, 0.5672416984613071, 0.5253326788888386, 0.4743866426822769, 0.5361510239750826, 0.551219169333222, 0.49254036279642854, 0.5476082567497341, 0.5667878559671897, 0.4989948623447844, 0.07475073626269846, 0.07955219999150664, 0.09895906628482132, 0.2032048143514762, 0.21592276941282051, 0.19546720847508303, 0.10734112625067171, 0.1302781748050873, 0.09991857781570856, 0.2798928607226323, 0.29161599068942834, 0.283961065174541, 0.3030142564117162, 0.29945347862817095, 0.3180776038227142, 0.2762782425399768, 0.3018910140233225, 0.28793591468737045, 0.6706426740345108, 0.6581094699227539, 0.6656047620186472, 0.6637994221060814, 0.66024880160091, 0.6693065650636301, 0.6888308116517516, 0.6495925900382632, 0.6902128951863369, 0.08820614971058605, 0.09904741687892671, 0.10570620592340962, 0.11234881829412646, 0.103133411798082, 0.09609976404237386, 0.08493455905701719, 0.09498714021021748, 0.09976350885441954, 0.13352350471320573, 0.13480061002807964, 0.14708404433524624, 0.15119758022291807, 0.13863582227605553, 0.15485096175443047, 0.23525331002899852, 0.1313310043258834, 0.16247533408776493, 0.3875642170351733, 0.38038883957403513, 0.4034823483570942, 0.36888705656587095, 0.3593516897424952, 0.38023919615485, 0.43865524588430527, 0.4036266057128832, 0.4023504808119901, 0.3366146054893122, 0.29521682760178247, 0.2989499043617757, 0.30600220366680364, 0.28247978336753954, 0.29825436526741445, 0.3633422343894389, 0.34894003333011625, 0.2952118332557576, 0.2145970292502517, 0.1968127621985022, 0.18655422881457584, 0.20124144806005706, 0.19825514897316465, 0.19024841883303212, 0.1996533911590529, 0.1904564894710763, 0.21161832026962102, 0.20959329198196552, 0.21758125268419015, 0.19874385610432177, 0.21267983053166362, 0.19385139496152248, 0.2131818659958722, 0.19071923055736884, 0.18919158902900246, 0.1875471080050577, 0.6980572813681731, 0.20047218968650327, 0.16972660229938008, 0.5465073568793435, 0.618524667965376, 0.7182609361507146, 0.1830329979376395, 0.18081729028935056, 0.17895257563509714, 0.53546170172374, 0.6491664472786602, 0.24669475273164598, 0.19796247971180214, 0.4700589870487166, 0.6598153353146375, 0.20510573351450667, 0.6472918645256132, 0.210631147553766, 0.1802600399822415, 0.1807981066266966, 0.19073768431613514, 0.18897418654411435, 0.17960928655137087, 0.196004199918685, 0.19316762812951582, 0.1862316701001656, 0.20220626329376523, 0.07432493633019455, 0.08055894386103679, 0.07939216923944625, 0.08016732313466235, 0.08044930960711494, 0.07648219444618387, 0.08151290050231874, 0.09332235131479005, 0.09223913902877245]}, "mutation_prompt": null}
{"id": "1824c537-3bac-4260-9fdd-d70dcfea89a7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.5, 1.5) if self.adaptive_scaling else self.F # Adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(self.CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Utilize adaptive weights and dynamic mutation strategies to balance exploration and exploitation in differential evolution.", "configspace": "", "generation": 16, "fitness": 0.3668636836676342, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "516426a7-0399-4e2c-8799-9a7c3637dc11", "metadata": {"aucs": [0.7681754089145006, 0.7508641406229826, 0.7738350845810975, 0.7977960605637833, 0.7589766361888497, 0.7826833235239687, 0.7829558733187177, 0.7509425582750834, 0.7587963714770072, 0.5891148911481389, 0.6188539013557297, 0.6022260913827786, 0.6133505673183068, 0.5860785111067455, 0.6200230795309327, 0.6182127434357658, 0.6063899209463686, 0.5873268016902411, 0.09615956757653188, 0.12209279431561049, 0.10072622241455154, 0.11438820519017101, 0.1114767403311615, 0.09451859683790498, 0.11677798500908376, 0.19578090041368745, 0.11787535721136078, 0.10080931229520229, 0.08206684917215223, 0.10110349938669838, 0.10211225530176049, 0.10138284782419738, 0.08543664680178131, 0.12595858960310102, 0.08784769194827091, 0.08889173263571337, 0.10219243604040762, 0.16147039385243822, 0.11088273244093083, 0.18937476532510222, 0.2549804863359786, 0.28881592557593516, 0.25263346916156537, 0.09909069910083124, 0.18780775901815927, 0.21988805275562795, 0.18931148483204874, 0.19184324052702062, 0.19496280971269164, 0.20362338268036306, 0.28292726943725144, 0.3355864627382692, 0.27669709144243204, 0.19574961908080035, 0.804887314185151, 0.8439967271977652, 0.8053500688820792, 0.8122082775691204, 0.8105559475536691, 0.25372525184198635, 0.8076634928251696, 0.8026886208079174, 0.8316398711883903, 0.27413056775666467, 0.49808519378094085, 0.21518320753009534, 0.15397969452968197, 0.14046299178337662, 0.4367462592687885, 0.2619111811352325, 0.21462312825075536, 0.2459331704472565, 0.26642203306583445, 0.07129129350705476, 0.1914557264726784, 0.5813300293353294, 0.23438137806246218, 0.2564607569156364, 0.14705371667307354, 0.17193348424273425, 0.14466073873579677, 0.5943353876468183, 0.603122423611624, 0.5815335709908358, 0.60112451967595, 0.5751630410369318, 0.598347132298379, 0.5691628599711717, 0.5642695181445238, 0.5848013216259873, 0.6760373360973615, 0.6918784250366589, 0.7132811044474034, 0.649149919017552, 0.6447200893451059, 0.6766389280932319, 0.6989816373405598, 0.6562122740831937, 0.7022120674782267, 0.15969151221720967, 0.15332948839938998, 0.17368442240576565, 0.13447428782820914, 0.2487396718756456, 0.4060929665607884, 0.16917938712827507, 0.15221920882140583, 0.12659330917284517, 0.44005269580189965, 0.4303056029004668, 0.4174862340807677, 0.4047776798992224, 0.4491697231358095, 0.44062129696882446, 0.39181792309460084, 0.434792880448844, 0.4149005917854446, 0.7220251165418533, 0.7400797047598155, 0.7673471483125736, 0.7271132137654078, 0.7584712680113737, 0.7318227907330422, 0.7471744879013894, 0.6877400911556193, 0.735246648225089, 0.09544823939993041, 0.11382574390944733, 0.10975916028968791, 0.12937155026670555, 0.10577692365600011, 0.11792026423503144, 0.22437083015225912, 0.09932325329822456, 0.13118302195101528, 0.16846534025239868, 0.1359145578430485, 0.22330579258589356, 0.19319886311121548, 0.2118814481838166, 0.19905592410225803, 0.29478755370073373, 0.25527703174362226, 0.16648259479368777, 0.4354977769186118, 0.4439698666452978, 0.4317648390036801, 0.4298721639722628, 0.4635982376129607, 0.41925366573647393, 0.41240446950493925, 0.45741127689828076, 0.44770455451773117, 0.36601057515199076, 0.3401675687620288, 0.4299503682933091, 0.3863098232442912, 0.368644953638381, 0.408874666035522, 0.4096647163889735, 0.38490404562804026, 0.3777063080881935, 0.2177802802959139, 0.18392767509276564, 0.19396545159238443, 0.20470217680177716, 0.2517667953562236, 0.20705597635488593, 0.21016474553260345, 0.20736394459752328, 0.18466532056378349, 0.22518773204685572, 0.1965741667490345, 0.3973096283889298, 0.37771608813463387, 0.4684158161217369, 0.22757483476981766, 0.21019001648752333, 0.21344836806044665, 0.197593544646968, 0.19969730654511553, 0.20593060226728144, 0.8265112330690072, 0.8367345383831626, 0.6684296149434183, 0.7457750437259336, 0.182769798607072, 0.6804555061094125, 0.7962775884071203, 0.8047807003329206, 0.2043125530524077, 0.8191388401911422, 0.7755149573627299, 0.197468875122909, 0.5374525622025115, 0.27024605078646813, 0.2076972489972928, 0.20868486005634357, 0.19336200816168125, 0.1919354661095286, 0.17992483690201444, 0.1810800617524525, 0.1966909430440691, 0.17474052861392608, 0.19079393563068325, 0.1756375653635589, 0.19972607835097544, 0.07984811426981797, 0.07488066536850724, 0.09820400755662795, 0.07915115299298581, 0.09300309057154843, 0.08308822595384391, 0.08717677295333448, 0.08257295722203162, 0.07387397899388815]}, "mutation_prompt": null}
{"id": "f50fe3ce-374e-4db4-a688-417bf881430c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Implements a dynamic crossover strategy and adaptive mutation to enhance global exploration in differential evolution.", "configspace": "", "generation": 17, "fitness": 0.3740583163316791, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "1824c537-3bac-4260-9fdd-d70dcfea89a7", "metadata": {"aucs": [0.7830663923679075, 0.7559377564628504, 0.7512607772956472, 0.7591004697392277, 0.7697994064328608, 0.7788822403926882, 0.7829691472920726, 0.7641092552626937, 0.774230752874789, 0.6023648794003409, 0.6084318557979868, 0.6215583803234577, 0.6028281548608991, 0.6072788426441669, 0.5848429846319614, 0.5762188670322737, 0.5726282736725707, 0.5737783026070452, 0.12959655137863724, 0.11444786787171524, 0.10585600728480005, 0.10952814878968475, 0.09514421266653772, 0.10595110649993966, 0.12783346485480251, 0.13521438077971748, 0.11416489017311526, 0.09549246697529579, 0.09824075919727238, 0.09616805305038523, 0.10932138670691616, 0.08914394776866796, 0.10558520961621942, 0.11633663122235516, 0.09918852131531242, 0.11534310742392517, 0.10078547369001312, 0.45574914884951034, 0.13882174873570508, 0.9530304068854016, 0.10437687519170535, 0.12778681176262796, 0.28060923021129225, 0.17883393714398899, 0.27022417865599924, 0.22413208926056338, 0.211486587026113, 0.20766689795895032, 0.23135431963028086, 0.30179641508184496, 0.45268959483418825, 0.30344952639818357, 0.21390098016200543, 0.3215963676704745, 0.8517242383804065, 0.7572763107108909, 0.7814862844956096, 0.8040164730506425, 0.8140785660621263, 0.7863307507605959, 0.793505029080042, 0.7840038850434183, 0.8158843629716998, 0.14744160600957623, 0.24396338579502852, 0.22112809218157103, 0.17298242127422803, 0.12464460687014456, 0.21092303832322745, 0.2173344715445653, 0.19176339445711665, 0.47382396539916183, 0.19949130198955667, 0.42689166107474563, 0.18546958677617442, 0.19509629336695677, 0.15231317272353628, 0.24859224889364673, 0.6050191950201478, 0.16331227289474792, 0.2774259013788398, 0.5708672754296658, 0.5618917900469118, 0.5539233963702899, 0.5662021668748456, 0.5900388493923724, 0.5766558578079907, 0.5933054208786329, 0.5680359618800563, 0.5665647142979682, 0.6606359961838069, 0.6409236062308854, 0.6580881465570811, 0.6885939508679393, 0.6702187080770248, 0.6895687520240394, 0.6715313478436125, 0.6915271101155702, 0.6879624980659145, 0.1302164164785996, 0.13037402135614318, 0.2215202835434814, 0.4483872119486356, 0.41341655376329134, 0.4254436889163662, 0.292010692693648, 0.13193333959442466, 0.23851385771408207, 0.4204263480988524, 0.3950060876637782, 0.38630963910779115, 0.433457790921536, 0.4330240101961661, 0.43118282599418, 0.4102581201552036, 0.4138230697246197, 0.43094160745605126, 0.7358342083575198, 0.7226376498540066, 0.7274519794534205, 0.7355700906933577, 0.7077355710322264, 0.7271567209497392, 0.7375990659535163, 0.7527991821172455, 0.722202903090381, 0.09387296521396493, 0.09905683741445681, 0.12999786022232473, 0.13558806121695777, 0.13593860722347506, 0.1264412099097817, 0.13344347355942376, 0.10502760487657703, 0.13783610223336296, 0.16563220160185865, 0.14244977135785497, 0.1555279322908033, 0.14885642906477803, 0.22476099020282758, 0.1652058255527662, 0.3585142374514758, 0.1362207097761009, 0.16702395171991502, 0.44172852583459943, 0.4322779665417852, 0.439935947923774, 0.43547777113129016, 0.41313117471335503, 0.4558806179447804, 0.42398061253387764, 0.43084956596359025, 0.48195022652239017, 0.431545821429123, 0.3939674160761165, 0.3610247119732862, 0.373089968412081, 0.4193368046157556, 0.39638303660357965, 0.4227215772326658, 0.362696313733913, 0.4437330104754298, 0.21754716637077887, 0.1844656642264515, 0.2216092153786524, 0.20422747155479215, 0.19291088220182617, 0.21889939415706594, 0.215510477558004, 0.21185705801677412, 0.20405352116752629, 0.21668155437779502, 0.34419805882355115, 0.20285339911125577, 0.4020315065215383, 0.18996245802903422, 0.2072347298538736, 0.2159855743525937, 0.1989820082057182, 0.1908260471424117, 0.5404146193536814, 0.19230807316261778, 0.1973807739344383, 0.8333506652057272, 0.7770717200321267, 0.7731748249308714, 0.18491548117354129, 0.7710560166358896, 0.8095105883263825, 0.5715093255051484, 0.33632422335766843, 0.2057598556221667, 0.6874992051694789, 0.7159921163359633, 0.5210952761176717, 0.5191372606830029, 0.20354629526012036, 0.20528988279874694, 0.18329568118527628, 0.17907321367913953, 0.19386988704715336, 0.19305308479842587, 0.18211622583619314, 0.19818058024522456, 0.18255434733192977, 0.19002723631538643, 0.20740795257707778, 0.11995054580683062, 0.07734721827246815, 0.09225146787603211, 0.07566014178345981, 0.08718686947306686, 0.08095197065690773, 0.07505895921920114, 0.07856802049462108, 0.07593964972244305]}, "mutation_prompt": null}
{"id": "9f1e48ac-2bd3-4754-a005-dab447d18cda", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n                elif np.random.rand() < 0.1:  # Enhanced selection pressure (1 line change)\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Implements a dynamic crossover strategy and adaptive mutation with enhanced selection pressure to improve convergence in differential evolution.", "configspace": "", "generation": 18, "fitness": 0.3437603742660886, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.22.", "error": "", "parent_id": "f50fe3ce-374e-4db4-a688-417bf881430c", "metadata": {"aucs": [0.7059664848574508, 0.6714583163481846, 0.7295126258101702, 0.721862798989197, 0.7297246040891343, 0.7272061301901767, 0.7433724125934671, 0.7181984063184983, 0.7527052599222399, 0.5212224218933773, 0.516647967734398, 0.5574138217010451, 0.5029029702712262, 0.47105539208519553, 0.5235937477514665, 0.4907984968325777, 0.49875107304014277, 0.48547828893816936, 0.11195251576767973, 0.09019705527593014, 0.1184235170208191, 0.09619954275624565, 0.08895963460073475, 0.09990295413689287, 0.10700004435772537, 0.08940480507234172, 0.09477681011149142, 0.08597941123621544, 0.10319427573031204, 0.07776717526715271, 0.09187522643559587, 0.09238700044327797, 0.0780559402812272, 0.09786125742938634, 0.11076771775653638, 0.08087615747575871, 0.3182298202878836, 0.46541281792522815, 0.8304613575214856, 0.4149786508142461, 0.31530547739005843, 0.3793615305341449, 0.5760631040815505, 0.8830703134912551, 0.51671291156892, 0.3396119026961476, 0.3151344620908608, 0.2002341108449348, 0.33504002589079707, 0.29060729045019607, 0.29127350564566445, 0.16287846678596507, 0.42350407451525685, 0.33264533803106644, 0.806220259940597, 0.7799910915577842, 0.7578036653969342, 0.7735249111265796, 0.8035987777320719, 0.7448520863725131, 0.7131702901965009, 0.7861767474251365, 0.8245699880678744, 0.3165566277103452, 0.2021964332553674, 0.18866543107584743, 0.3588615512205655, 0.3035508555230221, 0.14391521530541873, 0.5007494665696015, 0.2185011484356989, 0.38106766317594964, 0.13059075171694434, 0.39509888847650276, 0.1767891252069408, 0.14679651981095265, 0.1675712127284521, 0.14032501534009767, 0.4702515684378925, 0.34856938130898474, 0.17027350008757658, 0.4830814549649425, 0.4421433620325571, 0.47334535329247696, 0.4546916380002698, 0.4596454629389557, 0.48722268646281786, 0.5387140537487343, 0.45713514149645884, 0.4862372007381587, 0.5814695783476589, 0.6039530075343753, 0.5999650943882275, 0.5817810706985751, 0.6361583157838988, 0.5968462548217868, 0.5456717950569989, 0.6134647192716807, 0.5521272821992124, 0.22046787283668423, 0.14079079557070728, 0.22244226610379114, 0.2801559249689063, 0.3423313863580113, 0.1806068950258879, 0.23853467433755082, 0.24631114219415873, 0.17643878258377788, 0.3233150626686182, 0.33940020771596235, 0.3288946093119013, 0.3301018908749992, 0.3436849709237412, 0.33695946687614564, 0.37708383910546517, 0.3168214219064407, 0.3088711339770511, 0.6984688066704823, 0.7034771478082733, 0.6788271120160881, 0.6603675364012482, 0.6766434223553961, 0.6584829519901021, 0.6748247045114293, 0.6953309604250413, 0.6753958414734018, 0.09312064577313939, 0.10067652252375192, 0.10711469847846233, 0.11089838717184397, 0.09936480808138781, 0.09386987353308274, 0.10919379491545456, 0.10477771604386321, 0.08952914145005109, 0.13589878664450283, 0.15296996032195542, 0.15371066907810416, 0.15181938490710822, 0.14800137183483153, 0.16998848682121392, 0.20078710179133108, 0.16198770307840082, 0.15007687400562097, 0.361832504526322, 0.3846064974264124, 0.3819523587713187, 0.3890572679898643, 0.400292063621135, 0.36009962979924215, 0.36711201219456424, 0.38710613894097856, 0.3557696375880134, 0.3235434098950897, 0.35488120375682364, 0.34368397416805374, 0.330040493621398, 0.2829467156023986, 0.3225828348399743, 0.3226391980359774, 0.3437268775045229, 0.28367187994054044, 0.19500454779624066, 0.2020973968864267, 0.19665962171372653, 0.18570942210279617, 0.20375712218219222, 0.1878171486864343, 0.21818794629770633, 0.2033751069434836, 0.18697443889885246, 0.1923894283908466, 0.17071604128579987, 0.2052927537058873, 0.17699599405227362, 0.17709106778506445, 0.18972699158899387, 0.21498363033703405, 0.18165693592778143, 0.17081696315817974, 0.8329460212560366, 0.1768959430916449, 0.833160780344285, 0.7508757630262877, 0.7052395787595096, 0.7057179321420326, 0.18195004765613754, 0.6255435858497691, 0.6980662414827861, 0.2129603740729361, 0.19055475484183504, 0.2054370750732557, 0.1937929140054837, 0.19839025496344898, 0.15976835946302104, 0.20205563377731572, 0.12490425854637233, 0.15215009947551572, 0.18126452243381974, 0.1837400131474186, 0.18489734832145666, 0.17369189539425844, 0.17412930229304113, 0.18903099507254573, 0.18391874820061382, 0.17600248181164857, 0.18082951416076876, 0.08476961281963635, 0.07538222710195097, 0.076636815691557, 0.07523008049417967, 0.07306129556476659, 0.07334747084657445, 0.07870196821468689, 0.0788717605057554, 0.07684209609802273]}, "mutation_prompt": null}
{"id": "74a09d0e-8444-4d87-b33c-008d570fa0c4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Cooling schedule for dynamic crossover\n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) * (1 - 0.5 * (evals / self.budget))\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduced a cooling schedule to gradually reduce crossover probability for fostering exploration in later stages.", "configspace": "", "generation": 19, "fitness": 0.3295027187325745, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "f50fe3ce-374e-4db4-a688-417bf881430c", "metadata": {"aucs": [0.7927753559879975, 0.7503007580524218, 0.7711270160459973, 0.7610943455138304, 0.771865224710125, 0.7716616744646366, 0.7694393837276814, 0.781846015753735, 0.7624172451603268, 0.5795921579925922, 0.5931202779254074, 0.5870170093900372, 0.6026240077690935, 0.5813363900974347, 0.5978336714101141, 0.6355638132479136, 0.5874995096420779, 0.596210617216681, 0.21269957906995307, 0.24526840914842718, 0.2414042443538449, 0.2267832999531293, 0.17042081661403785, 0.21672563153067526, 0.30672580248599335, 0.23434099543104625, 0.22794235309797217, 0.23146779295554276, 0.19140902913052538, 0.19342791141550486, 0.2379414617379566, 0.13126136666216348, 0.20214860847164096, 0.13601706269234892, 0.18231006300276753, 0.16126529384214083, 0.844538842869598, 0.8776904379859363, 0.7829406306288516, 0.7887641412718002, 0.8068052577792055, 0.7947956289013048, 0.7951447010851929, 0.8096359170400196, 0.7376587381796856, 0.32888818774201145, 0.1659774515043715, 0.27773320622149633, 0.33008982997617276, 0.2649980199097274, 0.30026765357216123, 0.2544604266304733, 0.25742383850143247, 0.3175009228114175, 0.7733560265908469, 0.7073029805244565, 0.7516425499234225, 0.8179221920173056, 0.8379512028843611, 0.8050709648370139, 0.7582461984844691, 0.7926355898083838, 0.7916756822668777, 0.15508677381836056, 0.15038565357305056, 0.18457985021958534, 0.1641330100357984, 0.16430735544589392, 0.19858493872168925, 0.15787262191072804, 0.2287861516923959, 0.1853415822340988, 0.1549192033601925, 0.1331180621577216, 0.16674632827215596, 0.13885529761522375, 0.12773736188631446, 0.14597481988587135, 0.15777144214054917, 0.19742331700210225, 0.16762763467252084, 0.27541038535685136, 0.25150103158192993, 0.2530231842035373, 0.2638326728915382, 0.24735548351253656, 0.283780741394278, 0.2906305179381333, 0.22519278303087753, 0.26901874589666264, 0.35475615552968864, 0.36621065246817097, 0.33882344544015963, 0.36870502715966913, 0.3700181970058599, 0.3524953818986686, 0.36758042305745087, 0.39722073014213244, 0.3719090580629282, 0.09608254395989935, 0.1044438993742709, 0.10271690416988133, 0.05662497614244599, 0.09819595580423157, 0.09207896687809902, 0.1210918125821625, 0.07464946475753675, 0.12097298154613378, 0.1792848948241852, 0.19883495236751103, 0.19472350722546716, 0.2077172600261119, 0.20167433207030938, 0.1924238192015436, 0.20689464873003582, 0.19532132910259192, 0.1882481056628309, 0.5024260140909753, 0.5295806894583845, 0.5321476015576436, 0.4833266568131629, 0.4995094871662771, 0.5122383912402618, 0.5030358922842342, 0.5011437795523954, 0.4982814159225619, 0.09887948338105412, 0.11415141371454429, 0.11546557064336993, 0.10097009967846826, 0.09842164024276512, 0.1056928326169222, 0.11230225326472487, 0.10017232872763471, 0.10468330657865677, 0.15832153927727954, 0.13052791482823523, 0.1571161292312654, 0.1699762257487637, 0.17651400089207037, 0.14766399367861327, 0.16053827560594014, 0.14999762686869722, 0.17106758795430976, 0.36901283695244713, 0.31333308909296154, 0.3551707039809393, 0.31913191241500993, 0.33313933159453013, 0.35946568605897045, 0.3576361584875716, 0.3772163721214602, 0.35818241965126085, 0.2826999351852084, 0.2627786634797704, 0.29378223329548336, 0.31248167249041603, 0.2726763017253172, 0.28600274722138397, 0.31013733677645094, 0.2822475999118128, 0.28074072551199203, 0.20977852902293903, 0.20128412195269352, 0.19233333347035564, 0.20270950107970287, 0.23848585618879337, 0.1937400357233714, 0.18914639412547918, 0.1981180305210063, 0.18596987397032594, 0.19857676200941854, 0.19515683342043733, 0.21836894686649277, 0.2079097608514131, 0.3573014187326031, 0.19478166518456896, 0.23462134238969734, 0.26715457656637154, 0.1925702677627159, 0.5970955721494087, 0.19811936826762688, 0.1968834645587142, 0.8206892768190099, 0.624244241428833, 0.7735477553688289, 0.7401261694003619, 0.6962079983094656, 0.7130488057257316, 0.47440598788382315, 0.4399291008481586, 0.2052684579037959, 0.20590196260252192, 0.16270294431602328, 0.5122208808117739, 0.20210076137581223, 0.202861189716376, 0.3719837384307111, 0.1771126562054245, 0.18959467887051018, 0.1797844288659498, 0.19203829634216374, 0.18810075034207507, 0.18822857008153737, 0.1928224384975996, 0.18966749842506336, 0.19533968377181876, 0.07809267594458491, 0.08208870609001229, 0.0772918520882071, 0.09134936325646537, 0.0753419618703447, 0.07564229641307574, 0.07669095781183533, 0.0931493625277362, 0.08222047481178985]}, "mutation_prompt": null}
{"id": "b37f7617-0ea4-49d8-b829-25113d00103e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.8) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * np.std(self.successful_crs)  # Adjusted parameter update\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive scaling and parameter update to enhance convergence speed in the Adaptive Differential Evolution.", "configspace": "", "generation": 20, "fitness": 0.3588662855056945, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.22.", "error": "", "parent_id": "f50fe3ce-374e-4db4-a688-417bf881430c", "metadata": {"aucs": [0.7049453258028016, 0.6929923612949545, 0.7035405179880987, 0.7565606651030673, 0.7100424717900486, 0.7298229264763603, 0.7188429883060954, 0.7008196507274685, 0.7186850941485581, 0.5191518583086457, 0.502755362859137, 0.4919743861705206, 0.5560316184459064, 0.5103544598019694, 0.4966895635062709, 0.49224674329547535, 0.5214789799243902, 0.5115240387420403, 0.11036436375012382, 0.08973141429922693, 0.1179235179302297, 0.10180072337101809, 0.09706371588530871, 0.1180347086252792, 0.10905316145485322, 0.10581692272154108, 0.09870632531286483, 0.08754493152198306, 0.09188443216246256, 0.08418225033081594, 0.09238913099841395, 0.09638751440812698, 0.09618553910721417, 0.0884633715339167, 0.11321032541928377, 0.08844362666487993, 0.3029963476944807, 0.4576393467187674, 0.9329014814364777, 0.3021568845231324, 0.18364128036056715, 0.7196354701629617, 0.3958951113160578, 0.2515008144369546, 0.24457630388592577, 0.3332524824894646, 0.3821221312334946, 0.3211071295633947, 0.36336587110674134, 0.3802345308649385, 0.3337740761478305, 0.3869785584000881, 0.4064784440822583, 0.37368954799119003, 0.7818466037315537, 0.7905006307956259, 0.7223318727716734, 0.7607668604870107, 0.7457393539895494, 0.719671279335683, 0.7573874374828533, 0.7511508494458361, 0.7528649939445775, 0.48419462224930077, 0.41712535174490206, 0.18827481108491462, 0.3720794387430625, 0.18441583360720437, 0.5454964908068534, 0.18942776826016006, 0.43068696887186175, 0.45570529690119677, 0.39062131114254595, 0.5999755140054115, 0.19448958696923402, 0.29067029070501216, 0.19178915240601746, 0.20795693223163736, 0.2859882549048183, 0.2540923408555166, 0.41515261564478, 0.49433910623947097, 0.41943220331376674, 0.4410673595110999, 0.5079292094457508, 0.5009890638032, 0.42940106104069875, 0.49056579953077295, 0.4783316370834183, 0.54832780839457, 0.6262337522628012, 0.6268164438066839, 0.5796123256782864, 0.6373367912637586, 0.5888684617927165, 0.5965867932854327, 0.635751706902733, 0.6305767390949604, 0.6216308745330807, 0.10992884643070333, 0.18142288879211943, 0.19061564640597395, 0.17382766058076105, 0.18140065619542134, 0.30260092021816853, 0.16601254492142614, 0.16709677470355577, 0.1692492853384312, 0.31527378312666876, 0.36097021196649093, 0.2949222151089872, 0.35594717439848933, 0.3154699637290299, 0.3519879596430243, 0.33874486549998384, 0.330789474958475, 0.3120769240116289, 0.6816242210473452, 0.6625302490483803, 0.69158201308294, 0.6893016272181106, 0.6708679737975609, 0.6750359205497872, 0.7167747985653279, 0.6413345220500577, 0.7120927858891973, 0.08873496598091313, 0.09438063566133148, 0.13108730257809165, 0.1086951869222228, 0.0905047464486104, 0.09395288221204756, 0.11221378884254518, 0.0759971408065323, 0.10388140127616685, 0.22928864684832362, 0.13982175019557286, 0.14984408910342717, 0.20276325251364202, 0.14973654182648266, 0.16938101343424627, 0.20226573273493575, 0.1774811329865268, 0.15314969160071068, 0.4103936101275092, 0.3458893107311295, 0.38925640969168485, 0.38248653151858725, 0.3543432446863305, 0.380475113877363, 0.39913911836694116, 0.3918449001150721, 0.3594464131098253, 0.30511206776359845, 0.3467043406085508, 0.31789970621119923, 0.29394800833889845, 0.31027025060300917, 0.3115309761743824, 0.34285107099731316, 0.32985119429870025, 0.3153415026585592, 0.20595426081362356, 0.19728131678097738, 0.20618917090739697, 0.19931908447075608, 0.19230754511107873, 0.18377145983539778, 0.1916675056037741, 0.20807980754035216, 0.18817428503929146, 0.23403243189300227, 0.1919921169554616, 0.20509511880732112, 0.21126185810007259, 0.188952780041725, 0.19190806326996412, 0.19105132592121987, 0.2075688730200249, 0.20523662591701997, 0.7299003632861772, 0.18656934664115632, 0.7344859319226806, 0.7635579380771832, 0.5523654360249508, 0.1860332160793935, 0.1821825758902803, 0.5946921923745749, 0.6610437505740603, 0.6774333958280063, 0.20704903583429746, 0.7025048999265675, 0.6612292410047065, 0.19894605329047876, 0.6958822061336212, 0.7484122564479208, 0.1504565187073762, 0.7172395295386478, 0.1802245143150225, 0.18485722415112282, 0.20022262125859414, 0.20547376539591955, 0.19189791036391557, 0.17602297984012016, 0.17741914523439284, 0.19774025118674055, 0.17687248681506462, 0.0846900861727532, 0.08035928908785572, 0.0728721657784952, 0.07917730914540733, 0.08370710418075267, 0.07902252558483924, 0.08129848280042062, 0.08854193660267828, 0.07365437387026919]}, "mutation_prompt": null}
{"id": "af6f0c7a-0f54-4cb3-9bc4-a41000404621", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                \n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) * (1 - np.std(fitness) / np.mean(fitness)) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces a scaling factor to the mutation differential weight based on fitness diversity to balance exploration and exploitation.", "configspace": "", "generation": 21, "fitness": 0.2843780239238052, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "f50fe3ce-374e-4db4-a688-417bf881430c", "metadata": {"aucs": [0.7954125127476898, 0.7585356321267636, 0.7633151525516846, 0.7484292023905179, 0.7914113050251185, 0.7808159161053466, 0.8032890687362404, 0.7863546631063385, 0.7449757989832893, 0.3847885815024379, 0.40154833910690324, 0.3847562095905418, 0.21736942737439824, 0.36961814948538607, 0.07601775891318974, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10572138333210046, 0.10243174493737572, 0.09285659080061215, 0.12263285039711502, 0.13997274605384213, 0.11636043031518895, 0.11640037854676388, 0.11932410693981366, 0.1366271727791294, 0.10611794489715487, 0.11535970963896414, 0.08279257913178484, 0.1257969983116396, 0.12641161279385538, 0.10487137993606954, 0.10691651129354285, 0.09725635915647923, 0.09595015666923412, 0.11594965463537832, 0.1362638065980536, 0.1611152396843083, 0.9214003436942041, 0.14031101883191788, 0.10959821229476019, 0.19300082449164302, 0.09722113215872519, 0.25465103003895473, 0.1910563812504431, 0.13283198727946544, 0.208391604026141, 0.22720182476466666, 0.28836936782919254, 0.46439637962705926, 0.15025435846185242, 0.22266428724524057, 0.19210581708736874, 0.7809204140937627, 0.7930480568376764, 0.7973633172909325, 0.8312475661336689, 0.8605065383532976, 0.739981677124663, 0.228624004460374, 0.1694239423655718, 0.5565917891294139, 0.662785843304843, 0.12453848560574521, 0.06393409649123982, 0.07554001828802737, 9.999999999998899e-05, 0.0010105874091647093, 0.16233666610313524, 0.37044525254093574, 0.13285892335245375, 0.48197971770599624, 0.11587307094798815, 0.18927892369694066, 0.20742602994590575, 0.32047496494807437, 0.12507957332878394, 0.16747363740235455, 0.149538137694322, 0.13062826762927593, 0.06184030766317339, 9.999999999998899e-05, 0.119871723151588, 9.999999999998899e-05, 0.11125534558616745, 0.00452203652381411, 0.005506932251431729, 0.032984321005969486, 0.5030988178395253, 0.6812028174840002, 0.6694720069674194, 0.72436695817866, 0.07372363796305181, 0.17679018668638602, 0.08162549216170534, 0.7181663546073074, 0.6251554090430764, 0.7022255389877078, 9.999999999998899e-05, 9.999999999998899e-05, 0.00838509163173462, 9.999999999998899e-05, 9.999999999998899e-05, 0.10794723089475355, 0.020518846450345296, 0.1361037607670471, 0.08758395172665534, 0.4386507541393184, 0.4324765715010851, 0.4017069949325316, 0.04482428178382647, 0.09861468934514528, 0.2844167898787008, 0.0035790404692584987, 0.2011035032241263, 0.03452309770062889, 0.7319973587536297, 0.7225936957793018, 0.7468615480288847, 0.7085005703080955, 0.7411934746775466, 0.7077500940736398, 0.7528784735316245, 0.7300636583221974, 0.7383874053970336, 0.11514686089628234, 0.10234954281010833, 0.09485424119576202, 0.11017951622762356, 0.10742137263812745, 0.13705297166862906, 0.0904670694925448, 0.05347246051141208, 0.07544326491346653, 0.19345779548846154, 0.24284639781823603, 0.17913737458200973, 0.24389277417661237, 0.15747093453320926, 0.20023109659227356, 0.15485044106530532, 0.15296207647310622, 0.1898348702481334, 0.4078879233875301, 0.4038882760543201, 0.41588521836247094, 0.4546968149406322, 0.41460421241156087, 0.4616219325085036, 0.44908122193730937, 0.48517744684307973, 0.4635659150062399, 0.12691988104114516, 0.1698229493030987, 0.27626560109899634, 0.3828912452910036, 0.38760436190950986, 0.3941233822520521, 0.36265213943124874, 0.374871502045492, 0.38689028470643705, 0.20741977468423145, 0.18877378528308586, 0.20049142758555827, 0.19016983145179434, 0.20457062931166248, 0.22234112128411965, 0.24216991988430758, 0.2012102752837278, 0.1841414972227602, 0.16988141210132945, 0.15588563831786928, 0.1537333927124599, 0.23478928446105096, 0.4988790937864451, 0.2879307036033131, 0.18813938855365808, 0.19278711316136043, 0.18892678838423005, 0.1756689771637091, 0.16891811509990506, 0.7666121101843884, 0.3825129019015834, 0.47906255109318585, 0.18931146553699785, 0.18628686405791717, 0.7868739985332902, 0.7796727034921744, 0.1611160343484337, 0.7211839014356893, 0.7464582773120659, 0.7085024032258896, 0.15849067141735573, 0.16650985096077497, 0.19427945549957082, 0.20647598605519246, 0.1950865343063679, 0.18439029150319686, 0.1909965252138095, 0.18545278997280135, 0.18583844801959415, 0.18356120978115364, 0.21259396859782387, 0.18492941251258121, 0.20301245259032175, 0.1804367641726059, 0.09111415367374409, 0.08986427818356713, 0.08057599389466541, 0.0789340658518749, 0.07614677341087595, 0.1079792479998799, 0.0867566546858276, 0.07472822893179276, 0.08395674470788583]}, "mutation_prompt": null}
{"id": "91c3a0b3-e5bb-47db-b4c2-802660565487", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Incorporates adaptive mutation scaling based on historical success to enhance exploration-exploitation balance in differential evolution.", "configspace": "", "generation": 22, "fitness": 0.3762570740759614, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "f50fe3ce-374e-4db4-a688-417bf881430c", "metadata": {"aucs": [0.7689866078576022, 0.7464961937169561, 0.7509328240534986, 0.771553172142471, 0.745349524307007, 0.7631616680682928, 0.7638813399770639, 0.7451037295953389, 0.761268174947595, 0.5713883828591668, 0.5685519128101717, 0.5778617538160475, 0.5668534341080391, 0.5698910192674635, 0.5623821422554688, 0.5865408659806135, 0.5808740486662317, 0.5932042558098359, 0.16491683153608006, 0.1146475648226375, 0.13685004215680419, 0.1173732053042339, 0.10716546876348843, 0.11649905918666359, 0.11370755565424628, 0.11260590157520767, 0.12661246668824055, 0.12839128579111037, 0.09896535238915771, 0.1222209241107588, 0.12148891481950996, 0.10884424983329466, 0.11182599553813655, 0.1227665086403329, 0.11481408194988219, 0.10373387967002667, 0.8994230841156907, 0.8929945395486665, 0.921300042835539, 0.894479139231289, 0.9541727238024263, 0.8763694872585753, 0.5346152327564706, 0.3185938103298267, 0.9245601804369834, 0.387616137678498, 0.2748206964331391, 0.27837202406084804, 0.2861997957082333, 0.34017797878326217, 0.2892857211918134, 0.37950586363141925, 0.32726192103627605, 0.342570369038404, 0.7483953253705238, 0.7782209851508193, 0.7749727199659194, 0.7258356219490041, 0.7822433980596837, 0.7675441177207988, 0.7531948920271934, 0.7427866755410026, 0.7776475807273513, 0.28193451100927724, 0.499868195255595, 0.5215518013141034, 0.24298876671044245, 0.23418111264934827, 0.14130863468992316, 0.22436589930434359, 0.23003770388793388, 0.2191974594451419, 0.13933406253764857, 0.11856284475438916, 0.19477885657220817, 0.1815493805570555, 0.19875840111616794, 0.2636471197164014, 0.18653167112537383, 0.19675356625205487, 0.15955368996976882, 0.5379560746115595, 0.4574974759928415, 0.5179416342588803, 0.5530746519187026, 0.524970984160797, 0.5204232538115531, 0.5840903400994222, 0.49508060711092616, 0.5262827189220575, 0.6167240400853913, 0.642736817228265, 0.6129455774832824, 0.6555724749571159, 0.5825337955985019, 0.5898708510507398, 0.6859080439994583, 0.630419673380429, 0.6415315510311941, 0.18362644578477116, 0.07525493918542903, 0.19518245568263148, 0.3632559935475269, 0.362592939081368, 0.1439525459199955, 0.2409139005569717, 0.14238503410379122, 0.16740587669877838, 0.371395204092418, 0.37970223284458005, 0.36701829255689045, 0.3876743783395986, 0.36538041005485045, 0.36778122232993515, 0.4052362816413738, 0.3745980837490641, 0.37944911911472734, 0.7127264276140147, 0.7105577681670976, 0.7264870358329227, 0.713658328189602, 0.7030259771175494, 0.7398452223652849, 0.7180115623786547, 0.716370502912336, 0.7226976448475535, 0.08660120489190326, 0.10907755781046202, 0.10422856207904496, 0.10708797886906052, 0.09982668498586866, 0.09662944134109608, 0.1077882959061972, 0.09177178152546894, 0.11030019536217184, 0.14684526197991576, 0.13647130213861036, 0.14692407810313324, 0.14869682181054011, 0.15350996432982378, 0.12470824430201632, 0.1567640399617194, 0.13241904403845106, 0.17955844128000686, 0.45034514165605055, 0.4274996020789674, 0.43829119068939637, 0.3960152805670176, 0.42640962981828734, 0.38474996915925663, 0.4710433976381583, 0.46516632084859444, 0.47093358602373514, 0.4473833936547902, 0.31089590875892736, 0.3439591096896908, 0.3801938704936012, 0.3132918687837116, 0.33412668729484285, 0.35356203121376695, 0.34223501493288955, 0.4150095418680634, 0.19977603110285924, 0.18269488988278315, 0.19242585364111942, 0.202777680738491, 0.18413742533295063, 0.19239285840881704, 0.19641699364918053, 0.19451300743694855, 0.18813534065695126, 0.23267460078864022, 0.20382490393314368, 0.19236231865761044, 0.19885857793318928, 0.1791596324231074, 0.18890723080255478, 0.3237579387620515, 0.191716548785812, 0.1912981060211436, 0.16799627049605437, 0.19543617728754992, 0.7894173206308255, 0.7177495178578195, 0.5599206882538819, 0.6464693872945828, 0.7922544050945549, 0.18145997027107919, 0.6654830286309092, 0.6671543571451628, 0.1998370140763952, 0.4896295163090515, 0.19828915845381723, 0.6319872500713666, 0.6900707770796671, 0.14973073976105733, 0.20251930248833994, 0.4462145818299853, 0.17617025900027383, 0.1793181584455884, 0.18092488883355595, 0.17929023377395226, 0.18296599929895085, 0.19020747615572797, 0.17409644794300527, 0.18679439799403286, 0.19672090725075364, 0.08013685405249815, 0.07542653080269679, 0.0825658508606244, 0.076716709660408, 0.09570908675492595, 0.07774218123724752, 0.0758794461339023, 0.08451037305824027, 0.08106188094023004]}, "mutation_prompt": null}
{"id": "c7c5c893-c111-4fbd-92c5-46af0b6da181", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        # Change made here\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas))) + 0.1 * np.mean(self.successful_deltas)\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptation of F and CR by introducing a history-based component for improved exploration-exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.26929029822637884, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "91c3a0b3-e5bb-47db-b4c2-802660565487", "metadata": {"aucs": [0.702016818906208, 0.6499195231193171, 0.6855971927875948, 0.7168826091231959, 0.6889033849037823, 0.7146894276801483, 0.7095933899558872, 0.6919485688364743, 0.7016598498726117, 0.3134573665493575, 0.33956686676479775, 0.3615189977805615, 0.32880186980992654, 0.3612804821275126, 0.3617767560050048, 0.3687896533078808, 0.25882972562174933, 0.32196562156920505, 0.10112745414709967, 0.092182063117203, 0.10782506146248638, 0.10123005029605481, 0.10101320153773519, 0.09832818426220913, 0.10775197106575507, 0.09021724595454583, 0.09032622294185289, 0.07662267805353007, 0.08158611360616719, 0.07834765782806685, 0.09193937993597323, 0.08724240969352903, 0.09166983865980405, 0.0970553009290741, 0.08390414353123266, 0.07888787978014933, 0.942345747090171, 0.9282511840616389, 0.9667833699348402, 0.9390013303925758, 0.960480221286722, 0.938253377674864, 0.9417856885484372, 0.9410706916487139, 0.9366049854258411, 0.2771831788906769, 0.27479096612820864, 0.2645265345178469, 0.27200011335682583, 0.20673650022672196, 0.28794173294830605, 0.27192243936045957, 0.32850088519362, 0.335603194996165, 0.43825843838670264, 0.4676564738945159, 0.545086085579616, 0.5110047085647538, 0.5371357218777135, 0.5969092035157344, 0.6337051267666844, 0.5767987038547444, 0.5272371068502397, 0.13253734590963429, 0.15103337261474115, 0.2629258883972574, 0.20094121889216288, 0.2841119731954691, 0.18919916334010245, 0.31438813798964504, 0.1700658830200047, 0.16246625536753667, 0.010022429951486611, 0.21353871811427572, 0.009644997791341647, 0.13084038642066675, 0.36204860247154125, 0.14989441670390702, 0.12332079623046832, 0.12725548622821048, 0.1223927657348941, 0.101128418825152, 0.12947177562501233, 0.14157323473313466, 0.2306513881097525, 0.10780624852409437, 0.06594670321259888, 0.03485324569761483, 0.0905911172383318, 0.08195424588207478, 0.08739315193804742, 0.1197154154175174, 0.09054358115648775, 0.08290619658477627, 0.09712371932907882, 0.11110651946986927, 0.1549576299059756, 0.2890436998133372, 0.2597656496811521, 0.05058753123276416, 0.16345358871695148, 0.0784356914364811, 0.15019369866031307, 0.15761365192691645, 0.11164903958185601, 0.05286431616953979, 0.08718556142310185, 0.14942055879867877, 0.26059654158157186, 0.21625203001391669, 0.23800826447050694, 0.3104733312744691, 0.2809545187425039, 0.2669207122935052, 0.32546390569529327, 0.3259282744599501, 0.3175542584768992, 0.5963296261287692, 0.6118396204107355, 0.615175464389061, 0.6267570725337686, 0.603361749943391, 0.5951969904478189, 0.5990837132226556, 0.564107434058752, 0.555429400333725, 0.08754263211753843, 0.08366604417053625, 0.08719936320527555, 0.0799589204648371, 0.07303108565911332, 0.08848916092215964, 0.07328879642587982, 0.08821825228274027, 0.07991432442836377, 0.1956454285088396, 0.18567293160654663, 0.13845284303923067, 0.21043152552546673, 0.16700287697700567, 0.14734077355897857, 0.1501096422340965, 0.1276566929092101, 0.17511778158204871, 0.3266046243398295, 0.29491232891722186, 0.3248917943104539, 0.3492453620826871, 0.2347030165458608, 0.26403267377312445, 0.3508009006306273, 0.3117493922485417, 0.33889770417174137, 0.25361930432830126, 0.19974169886514825, 0.23785599645062838, 0.18129350234248331, 0.14917305304738016, 0.15771578715362466, 0.20867251136086906, 0.2325261405618313, 0.24983295849059217, 0.15534555464183608, 0.162668802168912, 0.18407916722845707, 0.18100140863292158, 0.1522879212480166, 0.1637553119822862, 0.16622169066117787, 0.16395553673550056, 0.18752467365876468, 0.17750844035024638, 0.1664198780779208, 0.16707426668608005, 0.16503050918407391, 0.17080250463848645, 0.17340300034383982, 0.17135352019989913, 0.17331539791191752, 0.1745190895991524, 0.1629759342415419, 0.18646835976656406, 0.4866815594906154, 0.5235440029977001, 0.44204010378251346, 0.17253653747145747, 0.48222363334474716, 0.1765174470102091, 0.2883712045531034, 0.15192753471818665, 0.18069741477502899, 0.4528530362876456, 0.202103617566478, 0.2142181669379385, 0.19694181577908143, 0.1984146410535229, 0.19701493494075584, 0.19940212733466178, 0.19061371639273694, 0.17018678545264232, 0.18171824413950521, 0.17928085964874496, 0.1745278668831537, 0.17482366246410597, 0.1702310661369867, 0.19239173676305787, 0.20029674845666, 0.06797543090788405, 0.061009378757396426, 0.060932198578005914, 0.06737737951568257, 0.06632487465844117, 0.05778809966644771, 0.06139017911758948, 0.0669138792840015, 0.06069074039646516]}, "mutation_prompt": null}
{"id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces stochastic adjustment to initial crossover probability to enhance robustness against varying problem landscapes.", "configspace": "", "generation": 24, "fitness": 0.38547287431988775, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "91c3a0b3-e5bb-47db-b4c2-802660565487", "metadata": {"aucs": [0.7748464961126806, 0.7789702131706979, 0.7540516529691332, 0.7687450467904621, 0.7674711393844942, 0.7537486030077765, 0.7651636670551478, 0.7911977919416088, 0.7687208756128627, 0.6025852393341563, 0.5641390452152131, 0.5665350379272935, 0.5712128834052064, 0.5715874066933875, 0.5758443733574681, 0.6024945703408231, 0.5697879464479783, 0.562126318552387, 0.13112056122192772, 0.11900328261538984, 0.1392928858510344, 0.12201881674906123, 0.11728992981071606, 0.12246246670594807, 0.11048162538933282, 0.11622781423771578, 0.10382122993109733, 0.10673700410240361, 0.1108507154599736, 0.13140519426212594, 0.10656172211377957, 0.10359018323338953, 0.1029399207617514, 0.12222579270783118, 0.10280138554251206, 0.1080018421028146, 0.9301441471482056, 0.8432601647617872, 0.8750805198447409, 0.8617996662413493, 0.8293336701997498, 0.9193651074771242, 0.9227487764393825, 0.9513240334931139, 0.9312065618781205, 0.3624603956586179, 0.352720509745162, 0.30236111763510976, 0.2984477840634481, 0.2485131015350336, 0.36576973819882774, 0.3751391436908923, 0.2578391997441015, 0.322000496684266, 0.7835061533290987, 0.7487413078355096, 0.7376174544418475, 0.7841193516872242, 0.7762489269412463, 0.7718077900792177, 0.7803764802364646, 0.7833074237655524, 0.783955037202765, 0.21620323784084028, 0.5122314724086235, 0.2787203997938542, 0.1971766098169715, 0.1881040693739584, 0.28821625052085287, 0.1767157814173792, 0.1735692348507306, 0.4443540101525272, 0.2169574757497168, 0.1198543737063461, 0.22210175957030542, 0.1568748131481681, 0.1582314043963301, 0.15759437018410083, 0.167833409731183, 0.2964523677821803, 0.24027054159813677, 0.534248328003176, 0.5069098655406745, 0.522315698567376, 0.49812834712747667, 0.4601273761891165, 0.46831434235555247, 0.5268364360852936, 0.5326511294386805, 0.511953361420326, 0.6473566225317282, 0.642391882321764, 0.6411860038544155, 0.6490871457284519, 0.6113001743838771, 0.589564369422566, 0.6779657708306512, 0.6330785573958483, 0.6253263870060268, 0.2478277078926009, 0.11493496132713787, 0.062225636201015955, 0.37033389946669326, 0.13502523587103843, 0.32478178327814866, 0.1499945881095417, 0.1660509145219048, 0.20158133815630164, 0.40265329977168784, 0.40408431579613036, 0.38355373257495207, 0.41471986247000725, 0.4207520687312918, 0.34566904100932083, 0.3753744720713942, 0.38565406813588876, 0.3634642626686594, 0.7009153778861317, 0.7143452071972013, 0.720696250541154, 0.7510106398738388, 0.7062312052073663, 0.7058887272490257, 0.702520112905418, 0.7232092847490128, 0.7177270089753234, 0.11074225417424755, 0.09298463425951464, 0.10103806433729445, 0.09824275080363254, 0.10755352849727262, 0.12572893632837057, 0.10821617895919478, 0.1196210743895979, 0.11633179099200097, 0.14684258280808649, 0.15305960041826716, 0.17595372454675018, 0.14424622000218956, 0.15324808471940576, 0.1464645756936428, 0.18137144034797137, 0.15085750405281617, 0.15676424333194794, 0.4400649851856113, 0.4254715630429319, 0.4378636324866496, 0.43796466222305974, 0.41491158034988207, 0.3917768987637964, 0.42085097900995194, 0.4025254665886754, 0.4409622933080575, 0.3643593083910267, 0.3365005730275662, 0.35288967512247915, 0.33810908588334965, 0.3213263147233051, 0.34827027349701767, 0.37464344651354353, 0.34595922352108377, 0.35079040170998554, 0.19852390540532971, 0.18539321745163462, 0.20615357993301475, 0.18038789997703775, 0.19083447892876382, 0.17968006306281914, 0.1905506252363206, 0.18910138444778957, 0.19872473092395437, 0.1911214747847232, 0.23157188417004304, 0.1888954949251319, 0.19564309817775472, 0.17945678281320454, 0.20072451323781093, 0.1974171801959428, 0.28679367757717833, 0.1951717972890411, 0.7200396045467861, 0.7352076940166123, 0.8078032657976936, 0.5933514578664254, 0.6840135547495012, 0.6333003025805264, 0.7422722435720867, 0.7286674599831671, 0.6989910319278287, 0.7522224476872066, 0.16471747469580622, 0.2002405657258851, 0.768013663587656, 0.6265386824718491, 0.19761551367125252, 0.2100274041762683, 0.20301026521961274, 0.20196122259113536, 0.1807726892652607, 0.20154444687995865, 0.20102908447937007, 0.1812633180933202, 0.18964389007543203, 0.1864008143091248, 0.17921269299862086, 0.1865193826361775, 0.19595565750798205, 0.0774698463526523, 0.07497823043364826, 0.0757227265203968, 0.07137787241380988, 0.0753466857180709, 0.0826121797571876, 0.07496655991265722, 0.07378835868835487, 0.07820609867982709]}, "mutation_prompt": null}
{"id": "930c3850-db48-4397-91ff-c48c9aafc3ad", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) if self.adaptive_scaling else self.CR  # Changed line\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces stochastic scaling to both differential weight and crossover probability to improve exploration diversity.", "configspace": "", "generation": 25, "fitness": 0.38547287431988775, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.7748464961126806, 0.7789702131706979, 0.7540516529691332, 0.7687450467904621, 0.7674711393844942, 0.7537486030077765, 0.7651636670551478, 0.7911977919416088, 0.7687208756128627, 0.6025852393341563, 0.5641390452152131, 0.5665350379272935, 0.5712128834052064, 0.5715874066933875, 0.5758443733574681, 0.6024945703408231, 0.5697879464479783, 0.562126318552387, 0.13112056122192772, 0.11900328261538984, 0.1392928858510344, 0.12201881674906123, 0.11728992981071606, 0.12246246670594807, 0.11048162538933282, 0.11622781423771578, 0.10382122993109733, 0.10673700410240361, 0.1108507154599736, 0.13140519426212594, 0.10656172211377957, 0.10359018323338953, 0.1029399207617514, 0.12222579270783118, 0.10280138554251206, 0.1080018421028146, 0.9301441471482056, 0.8432601647617872, 0.8750805198447409, 0.8617996662413493, 0.8293336701997498, 0.9193651074771242, 0.9227487764393825, 0.9513240334931139, 0.9312065618781205, 0.3624603956586179, 0.352720509745162, 0.30236111763510976, 0.2984477840634481, 0.2485131015350336, 0.36576973819882774, 0.3751391436908923, 0.2578391997441015, 0.322000496684266, 0.7835061533290987, 0.7487413078355096, 0.7376174544418475, 0.7841193516872242, 0.7762489269412463, 0.7718077900792177, 0.7803764802364646, 0.7833074237655524, 0.783955037202765, 0.21620323784084028, 0.5122314724086235, 0.2787203997938542, 0.1971766098169715, 0.1881040693739584, 0.28821625052085287, 0.1767157814173792, 0.1735692348507306, 0.4443540101525272, 0.2169574757497168, 0.1198543737063461, 0.22210175957030542, 0.1568748131481681, 0.1582314043963301, 0.15759437018410083, 0.167833409731183, 0.2964523677821803, 0.24027054159813677, 0.534248328003176, 0.5069098655406745, 0.522315698567376, 0.49812834712747667, 0.4601273761891165, 0.46831434235555247, 0.5268364360852936, 0.5326511294386805, 0.511953361420326, 0.6473566225317282, 0.642391882321764, 0.6411860038544155, 0.6490871457284519, 0.6113001743838771, 0.589564369422566, 0.6779657708306512, 0.6330785573958483, 0.6253263870060268, 0.2478277078926009, 0.11493496132713787, 0.062225636201015955, 0.37033389946669326, 0.13502523587103843, 0.32478178327814866, 0.1499945881095417, 0.1660509145219048, 0.20158133815630164, 0.40265329977168784, 0.40408431579613036, 0.38355373257495207, 0.41471986247000725, 0.4207520687312918, 0.34566904100932083, 0.3753744720713942, 0.38565406813588876, 0.3634642626686594, 0.7009153778861317, 0.7143452071972013, 0.720696250541154, 0.7510106398738388, 0.7062312052073663, 0.7058887272490257, 0.702520112905418, 0.7232092847490128, 0.7177270089753234, 0.11074225417424755, 0.09298463425951464, 0.10103806433729445, 0.09824275080363254, 0.10755352849727262, 0.12572893632837057, 0.10821617895919478, 0.1196210743895979, 0.11633179099200097, 0.14684258280808649, 0.15305960041826716, 0.17595372454675018, 0.14424622000218956, 0.15324808471940576, 0.1464645756936428, 0.18137144034797137, 0.15085750405281617, 0.15676424333194794, 0.4400649851856113, 0.4254715630429319, 0.4378636324866496, 0.43796466222305974, 0.41491158034988207, 0.3917768987637964, 0.42085097900995194, 0.4025254665886754, 0.4409622933080575, 0.3643593083910267, 0.3365005730275662, 0.35288967512247915, 0.33810908588334965, 0.3213263147233051, 0.34827027349701767, 0.37464344651354353, 0.34595922352108377, 0.35079040170998554, 0.19852390540532971, 0.18539321745163462, 0.20615357993301475, 0.18038789997703775, 0.19083447892876382, 0.17968006306281914, 0.1905506252363206, 0.18910138444778957, 0.19872473092395437, 0.1911214747847232, 0.23157188417004304, 0.1888954949251319, 0.19564309817775472, 0.17945678281320454, 0.20072451323781093, 0.1974171801959428, 0.28679367757717833, 0.1951717972890411, 0.7200396045467861, 0.7352076940166123, 0.8078032657976936, 0.5933514578664254, 0.6840135547495012, 0.6333003025805264, 0.7422722435720867, 0.7286674599831671, 0.6989910319278287, 0.7522224476872066, 0.16471747469580622, 0.2002405657258851, 0.768013663587656, 0.6265386824718491, 0.19761551367125252, 0.2100274041762683, 0.20301026521961274, 0.20196122259113536, 0.1807726892652607, 0.20154444687995865, 0.20102908447937007, 0.1812633180933202, 0.18964389007543203, 0.1864008143091248, 0.17921269299862086, 0.1865193826361775, 0.19595565750798205, 0.0774698463526523, 0.07497823043364826, 0.0757227265203968, 0.07137787241380988, 0.0753466857180709, 0.0826121797571876, 0.07496655991265722, 0.07378835868835487, 0.07820609867982709]}, "mutation_prompt": null}
{"id": "c4a0a310-799d-4088-9ab7-6a737b2c7e89", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = max(0.1, 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas))))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces self-adaptive scaling of differential weight to enhance exploration capability.", "configspace": "", "generation": 26, "fitness": 0.38547287431988775, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.7748464961126806, 0.7789702131706979, 0.7540516529691332, 0.7687450467904621, 0.7674711393844942, 0.7537486030077765, 0.7651636670551478, 0.7911977919416088, 0.7687208756128627, 0.6025852393341563, 0.5641390452152131, 0.5665350379272935, 0.5712128834052064, 0.5715874066933875, 0.5758443733574681, 0.6024945703408231, 0.5697879464479783, 0.562126318552387, 0.13112056122192772, 0.11900328261538984, 0.1392928858510344, 0.12201881674906123, 0.11728992981071606, 0.12246246670594807, 0.11048162538933282, 0.11622781423771578, 0.10382122993109733, 0.10673700410240361, 0.1108507154599736, 0.13140519426212594, 0.10656172211377957, 0.10359018323338953, 0.1029399207617514, 0.12222579270783118, 0.10280138554251206, 0.1080018421028146, 0.9301441471482056, 0.8432601647617872, 0.8750805198447409, 0.8617996662413493, 0.8293336701997498, 0.9193651074771242, 0.9227487764393825, 0.9513240334931139, 0.9312065618781205, 0.3624603956586179, 0.352720509745162, 0.30236111763510976, 0.2984477840634481, 0.2485131015350336, 0.36576973819882774, 0.3751391436908923, 0.2578391997441015, 0.322000496684266, 0.7835061533290987, 0.7487413078355096, 0.7376174544418475, 0.7841193516872242, 0.7762489269412463, 0.7718077900792177, 0.7803764802364646, 0.7833074237655524, 0.783955037202765, 0.21620323784084028, 0.5122314724086235, 0.2787203997938542, 0.1971766098169715, 0.1881040693739584, 0.28821625052085287, 0.1767157814173792, 0.1735692348507306, 0.4443540101525272, 0.2169574757497168, 0.1198543737063461, 0.22210175957030542, 0.1568748131481681, 0.1582314043963301, 0.15759437018410083, 0.167833409731183, 0.2964523677821803, 0.24027054159813677, 0.534248328003176, 0.5069098655406745, 0.522315698567376, 0.49812834712747667, 0.4601273761891165, 0.46831434235555247, 0.5268364360852936, 0.5326511294386805, 0.511953361420326, 0.6473566225317282, 0.642391882321764, 0.6411860038544155, 0.6490871457284519, 0.6113001743838771, 0.589564369422566, 0.6779657708306512, 0.6330785573958483, 0.6253263870060268, 0.2478277078926009, 0.11493496132713787, 0.062225636201015955, 0.37033389946669326, 0.13502523587103843, 0.32478178327814866, 0.1499945881095417, 0.1660509145219048, 0.20158133815630164, 0.40265329977168784, 0.40408431579613036, 0.38355373257495207, 0.41471986247000725, 0.4207520687312918, 0.34566904100932083, 0.3753744720713942, 0.38565406813588876, 0.3634642626686594, 0.7009153778861317, 0.7143452071972013, 0.720696250541154, 0.7510106398738388, 0.7062312052073663, 0.7058887272490257, 0.702520112905418, 0.7232092847490128, 0.7177270089753234, 0.11074225417424755, 0.09298463425951464, 0.10103806433729445, 0.09824275080363254, 0.10755352849727262, 0.12572893632837057, 0.10821617895919478, 0.1196210743895979, 0.11633179099200097, 0.14684258280808649, 0.15305960041826716, 0.17595372454675018, 0.14424622000218956, 0.15324808471940576, 0.1464645756936428, 0.18137144034797137, 0.15085750405281617, 0.15676424333194794, 0.4400649851856113, 0.4254715630429319, 0.4378636324866496, 0.43796466222305974, 0.41491158034988207, 0.3917768987637964, 0.42085097900995194, 0.4025254665886754, 0.4409622933080575, 0.3643593083910267, 0.3365005730275662, 0.35288967512247915, 0.33810908588334965, 0.3213263147233051, 0.34827027349701767, 0.37464344651354353, 0.34595922352108377, 0.35079040170998554, 0.19852390540532971, 0.18539321745163462, 0.20615357993301475, 0.18038789997703775, 0.19083447892876382, 0.17968006306281914, 0.1905506252363206, 0.18910138444778957, 0.19872473092395437, 0.1911214747847232, 0.23157188417004304, 0.1888954949251319, 0.19564309817775472, 0.17945678281320454, 0.20072451323781093, 0.1974171801959428, 0.28679367757717833, 0.1951717972890411, 0.7200396045467861, 0.7352076940166123, 0.8078032657976936, 0.5933514578664254, 0.6840135547495012, 0.6333003025805264, 0.7422722435720867, 0.7286674599831671, 0.6989910319278287, 0.7522224476872066, 0.16471747469580622, 0.2002405657258851, 0.768013663587656, 0.6265386824718491, 0.19761551367125252, 0.2100274041762683, 0.20301026521961274, 0.20196122259113536, 0.1807726892652607, 0.20154444687995865, 0.20102908447937007, 0.1812633180933202, 0.18964389007543203, 0.1864008143091248, 0.17921269299862086, 0.1865193826361775, 0.19595565750798205, 0.0774698463526523, 0.07497823043364826, 0.0757227265203968, 0.07137787241380988, 0.0753466857180709, 0.0826121797571876, 0.07496655991265722, 0.07378835868835487, 0.07820609867982709]}, "mutation_prompt": null}
{"id": "bd424e71-1ae6-4df7-8da7-7f7152948da1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = np.mean(self.successful_deltas) / (np.mean(self.successful_deltas) + 1)  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Utilizes feedback from successful trials to dynamically adjust the scaling factor, enhancing adaptation to the problem landscape.", "configspace": "", "generation": 27, "fitness": 0.2719177974893916, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.5045018236037699, 0.4918746401847459, 0.4508758213111266, 0.48831089902143787, 0.5295963680254844, 0.5072339439794487, 0.5034711469425173, 0.5790430119979881, 0.4912215758627705, 0.3653358611424421, 0.2831679881944933, 0.25909135550001006, 0.2918110557857039, 0.3109408412554321, 0.3343743225356878, 0.3390461664743981, 0.29007621890531476, 0.2692081336688057, 0.11066625576198441, 0.10148716492630205, 0.13434088994780813, 0.10436389560621906, 0.11140902038709266, 0.11382511238319126, 0.09701004519521172, 0.1236773829103206, 0.09979029635180048, 0.1072566430795836, 0.09322305304661438, 0.12910219715533044, 0.09902832870753464, 0.09325291728076868, 0.09524092343794854, 0.10526464167261895, 0.0934716422391848, 0.09714680209632609, 0.9805236512270121, 0.8770225889219214, 0.38887866133747406, 0.927648592077701, 0.9472897596300983, 0.9665769274302595, 0.9400699801241817, 0.965474890068493, 0.9342475708037425, 0.22881561934235028, 0.22359399513164102, 0.21273535154844336, 0.2478528923875053, 0.24474670088831585, 0.22492696217226393, 0.2089543736807764, 0.19884925163101774, 0.25464730177233086, 0.6495066579182078, 0.7032602258447415, 0.6771210785174584, 0.763292264691379, 0.7116493136592059, 0.7303933756214519, 0.7326977056258646, 0.7255720250066757, 0.6712538759282403, 0.1472632733017012, 0.14968720080521924, 0.17071530518732447, 0.11480782883200114, 0.16572420022818424, 0.13031698599738006, 0.13126210560803442, 0.19719708083840315, 0.12870020944435112, 0.0875212070086121, 0.20458964214288688, 0.19140470055216374, 0.13483440751725373, 0.12264941999426104, 0.19638172085860728, 0.12949454675808525, 0.15745657499941956, 0.12322175287184567, 0.2528453306338554, 0.26136449497811487, 0.2565434258182858, 0.21804712881225996, 0.23438641864762078, 0.23847824658803307, 0.2457095265709387, 0.23046277844596164, 0.22797499134328214, 0.2785883684751381, 0.32548723086062936, 0.35686345318906365, 0.3216146409149867, 0.3137712102605519, 0.31641023983339644, 0.3068534241321875, 0.33396683726634213, 0.33697746990371646, 0.10144890840188892, 0.09344537044075729, 0.08683530278699614, 0.11212143457260826, 0.16848246936570954, 0.13809819111603283, 0.09403275224592689, 0.12371775499681392, 0.15036176508735555, 0.18358456146841862, 0.15499938013500814, 0.20663785020839143, 0.18283335269057055, 0.18520215264788709, 0.1519069731639947, 0.16836520365011043, 0.18566219669631712, 0.17234951232029416, 0.46459073477680723, 0.42260707043521806, 0.4515321576114255, 0.4348125138020018, 0.47372059607195205, 0.46445777987182224, 0.4570298059018749, 0.46816225410473966, 0.4323417696698616, 0.08926118334688327, 0.08827805084668161, 0.08998606684023358, 0.11100951198379394, 0.07576129531794307, 0.10028017370172071, 0.0966959642007077, 0.10539013321401869, 0.08643199314884353, 0.14241802885092836, 0.26621188463198486, 0.1402291669918615, 0.1574009410738041, 0.20920090989190543, 0.19735216885109208, 0.1741575454702573, 0.1604099903759989, 0.16489860012344948, 0.28616080729053306, 0.293143967740756, 0.30477168764922924, 0.30461878030729017, 0.2946851829353805, 0.3033500366268157, 0.30594582690030414, 0.34483754579853476, 0.32440376750777244, 0.25153212024276195, 0.2507872662265076, 0.27068075763490473, 0.26997214865987984, 0.2598019974519622, 0.26288884309590144, 0.26580198270536914, 0.26608180146859595, 0.2741522228194474, 0.16554970238914535, 0.17560445991791662, 0.1859160531137708, 0.1808599341408631, 0.17659607406567535, 0.20436117397015352, 0.1614979302670414, 0.19005681253470552, 0.19597500685658398, 0.20430074534032094, 0.1841898491653141, 0.17733556666054284, 0.18369881870286076, 0.17665898371248567, 0.17911113354083774, 0.1722724629121487, 0.18756468902256962, 0.18818130185410553, 0.542481244767504, 0.1827011830695161, 0.5875410562167169, 0.3151777597236205, 0.1768725029190089, 0.1642771810748347, 0.6655668521775309, 0.5671595885850014, 0.3584593319251904, 0.19359195321778588, 0.19846795325251987, 0.16521882416360856, 0.4428353571427448, 0.18366553736987967, 0.1813443810027262, 0.20775593290157868, 0.20406546991378027, 0.2049714942538884, 0.1793700179893345, 0.18421264623908906, 0.16669024841468905, 0.17954166319190668, 0.18884585970771295, 0.178301116399339, 0.18082325192018878, 0.19411473231241516, 0.17669102762474975, 0.08335433609956622, 0.06622713015280801, 0.07677932532094744, 0.06565808627478797, 0.06350152851988355, 0.0776127512406134, 0.08422150455423216, 0.08287210375371956, 0.07929910079700786]}, "mutation_prompt": null}
{"id": "478d1af5-7d46-430f-94be-ab778bd1b47b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.6 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces adaptive selection pressure via stochastic scaling in differential weight for improved convergence.", "configspace": "", "generation": 28, "fitness": 0.36507717093031744, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.23.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.73931785756632, 0.7242687253138604, 0.700212963835359, 0.7334570153066918, 0.7081388867491906, 0.7292592991674152, 0.7557819507223763, 0.7213215673856752, 0.7289242019249278, 0.5336438011873498, 0.4882664686171615, 0.5033060058954961, 0.5131380266912504, 0.4831489823913434, 0.5443241745823322, 0.5520211360429206, 0.5047270502175676, 0.4955952670097509, 0.10936369293231218, 0.1068901498105359, 0.12589906101054116, 0.12186354787352283, 0.11338689055312079, 0.11475922900603275, 0.10607629462069179, 0.11862382711057107, 0.11444844731451631, 0.11620258600761246, 0.09366706014198467, 0.11405930259245667, 0.09969417741335296, 0.09248086155743329, 0.10394738647858648, 0.11336310147775097, 0.09587829730416375, 0.10581829385662767, 0.9468812474550844, 0.8839461753784525, 0.9025220047385552, 0.9394976226483154, 0.9047559344059946, 0.882631491843389, 0.8819178606625625, 0.88522237090335, 0.8220943950998066, 0.32700854158612436, 0.37479731964463037, 0.35420700446995645, 0.3932416082970548, 0.3493892917923763, 0.38058675717013835, 0.34558490215898274, 0.3416519099458125, 0.3599557817807325, 0.739245770787976, 0.7048999543765335, 0.7357176636176894, 0.7111739538137486, 0.7481085938051055, 0.7011696135468168, 0.7372589042156759, 0.6835495257956249, 0.7095600820087287, 0.21254693102683508, 0.4264186747388974, 0.20245293227677663, 0.184127061027076, 0.2316941683981274, 0.4527609168791129, 0.281358723643923, 0.18282510585943668, 0.258147102901665, 0.49033277437731204, 0.38233400658938954, 0.23548891471570665, 0.4226685084622359, 0.24223197553881004, 0.35909314427698347, 0.42398239087806455, 0.34044600974411976, 0.3362949886318196, 0.47834242733220567, 0.43202831621759497, 0.48461705882370987, 0.43735066769902387, 0.4208597133741764, 0.4540159562942442, 0.4383953578024993, 0.4028170117084253, 0.39519044617320276, 0.581216880427492, 0.5552871351871282, 0.546360458721639, 0.5812499064899656, 0.5134675897366534, 0.5371032846578985, 0.5895811308763459, 0.5549780695012858, 0.5736377632746854, 0.11706897853376341, 0.17575868194255906, 0.12135585628783663, 0.24419536179155288, 0.29494886382020447, 0.24299996104739152, 0.12971706207405043, 0.11971151488867326, 0.1990929307721272, 0.3076210915791304, 0.33112409431043455, 0.31336290342130224, 0.30173358172696185, 0.3327814986886444, 0.29906333661694506, 0.3238588490166039, 0.3195866613798133, 0.3143209853923197, 0.6995424191143296, 0.6940408914623646, 0.69337036552781, 0.6760149416846997, 0.6724909479219314, 0.6627768783519052, 0.6743713310387967, 0.6521009031601446, 0.6741477656914079, 0.10449910100501003, 0.09835647649305812, 0.10845777542288926, 0.1150124363140983, 0.09623605264601143, 0.10732520937486656, 0.1033282071666114, 0.09778834417615467, 0.09877704026081247, 0.15199185436274698, 0.14592899445323837, 0.1628098033349331, 0.14729008688758405, 0.1621078428489352, 0.18427995633775052, 0.17236526544308184, 0.15589416712279502, 0.1485309295167384, 0.3823088545074199, 0.33694462395846125, 0.3701920568667353, 0.38794435727214094, 0.33600669601424993, 0.37429585136907495, 0.4009468796002085, 0.37333669873478725, 0.43449885086283513, 0.31257638567878343, 0.32588858466744186, 0.28678908872916287, 0.3044907056973434, 0.28537276176486304, 0.29640758007730905, 0.31425893972328256, 0.2971219905792768, 0.29557912890162197, 0.20510959021891695, 0.18582490163451815, 0.19127882296739185, 0.18210318378306245, 0.17463981797432626, 0.2048202721104886, 0.18513706065231705, 0.21662178138469068, 0.1830440313132683, 0.19844905214680764, 0.17725316339589026, 0.19022373397138714, 0.18924404166678965, 0.18357954268743482, 0.19099235739395748, 0.193451013866498, 0.18018090746207105, 0.2030013388742825, 0.17994988746751894, 0.6390392609970754, 0.7685893534910381, 0.5737983457466295, 0.7107213434863262, 0.6024723259620397, 0.5763282267249137, 0.6866648232850294, 0.5575515140302747, 0.6456965169756279, 0.7544315158332782, 0.20678152280531414, 0.5628004666376223, 0.18774206744137567, 0.20150820959520344, 0.20992175475120545, 0.20213298849770522, 0.20460507705799136, 0.18008854779028838, 0.19969654463507291, 0.18895981939505413, 0.18383304034656, 0.18152712859221287, 0.178301116399339, 0.18503044657135237, 0.18714341703379278, 0.1972160294420897, 0.08018923025445024, 0.0761042053653187, 0.07360709739484483, 0.07653091081906949, 0.08063786133272821, 0.07284827354420997, 0.07300710486414952, 0.07579562771492687, 0.08380909586432861]}, "mutation_prompt": null}
{"id": "cf11529c-1a1b-459d-971d-57418cab8d72", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.5, 1.6) if self.adaptive_scaling else self.F  # Slightly enhanced adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Slightly enhance the adaptive scaling factor in the mutation step to better handle diverse landscapes.", "configspace": "", "generation": 29, "fitness": 0.36710699566991684, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.780950270391571, 0.7381886788147901, 0.7227316630472129, 0.7517970536837071, 0.7470166765388003, 0.7469677909986641, 0.7551011229078436, 0.7628595320007686, 0.7554436161276724, 0.6090790030660571, 0.5763808217643496, 0.552072781253076, 0.5665007642109252, 0.5433622439970853, 0.5546600308107519, 0.6035182951863792, 0.47970945490154904, 0.5303932085091574, 0.14021340172004948, 0.11700899496991657, 0.11313321075715232, 0.11199163190192574, 0.10969562567409574, 0.12232868371875683, 0.12085053368112353, 0.10597011254344657, 0.15799023078294416, 0.10709703131413917, 0.12303126634842743, 0.10956929501817436, 0.11742865052817342, 0.10371785823295487, 0.10614443500057369, 0.10837463319355611, 0.10459623860515821, 0.11136874548079156, 0.9302063859924812, 0.9397121453148197, 0.8748991774056756, 0.9091158098583314, 0.8991726765395714, 0.8965393553009132, 0.8048927506850874, 0.9146842681197828, 0.8239888634321444, 0.3862245174747534, 0.35860205840104953, 0.317949821333549, 0.38105543457249835, 0.37325805759654107, 0.30824491650723607, 0.26778146043637574, 0.2881627805338779, 0.38685010083336413, 0.7640361399668476, 0.7394199651609383, 0.746934144332748, 0.7728080500486096, 0.7577098741373696, 0.769351273347614, 0.7102611009384314, 0.738742764692786, 0.7620842454162837, 0.1699169916073341, 0.26280415495413934, 0.21319807569855864, 0.20781459590671025, 0.2298857401215444, 0.1654660756625892, 0.19940641539378434, 0.21989981103827538, 0.200721676996367, 0.11682992669452286, 0.2343005131547139, 0.22177967158158873, 0.1673137618479954, 0.16742654488041842, 0.2198971396830981, 0.19073114028684524, 0.4564105629534261, 0.21815447142346078, 0.5218534513018469, 0.45846917254708897, 0.5069392322979855, 0.45635395510966814, 0.4748797979462652, 0.5073185497984413, 0.46815975185285186, 0.49050136128738886, 0.4591579077532447, 0.6317457798832492, 0.5903761891200339, 0.5952531138285719, 0.6352895535297571, 0.6025216043272581, 0.6073611589421368, 0.6202699236822349, 0.6061452893412302, 0.6037954015827653, 0.10450479771653842, 0.12412371298820657, 0.20497997774372, 0.20133232457973171, 0.29710497572343464, 0.33437504084365033, 0.11146143503872386, 0.12285381780669125, 0.11998639887910156, 0.35785288166513196, 0.33516622452511824, 0.380678634521601, 0.383218118855717, 0.33834675530539393, 0.3415880041291124, 0.3764174529353337, 0.3590080667889328, 0.3422488157825665, 0.6870429210503651, 0.699730114917464, 0.7026416712996166, 0.6989193206160991, 0.7180124017579452, 0.6961716827883773, 0.697724676994224, 0.7138555579854438, 0.6935091458962163, 0.11224435344785655, 0.09292103674362728, 0.11339866258975129, 0.08829198328269927, 0.09023088103974064, 0.10215155157699085, 0.09319567686870855, 0.08181710291515587, 0.09980350983619812, 0.27717641280899574, 0.17055035766074156, 0.15875464502722714, 0.13007092227057315, 0.14933656091564862, 0.151200955184574, 0.1462970871315541, 0.15117217603496014, 0.13862728953510595, 0.39482140942165267, 0.4039911717076995, 0.3818681656950843, 0.40958646676829336, 0.403869279197128, 0.38280908210594466, 0.3839368911983293, 0.401740330478361, 0.4092976141437512, 0.3322895167411424, 0.3405093242642073, 0.36512840665349, 0.3314131226772945, 0.3284457997517408, 0.35479886036663844, 0.3508815484782334, 0.32433046059480564, 0.353436748912195, 0.20329645858219614, 0.19827140716485459, 0.18200569505735642, 0.1998240864822557, 0.19273874313845074, 0.20446469124864397, 0.1919492605197668, 0.18666642885094564, 0.19588090138243042, 0.37240477399768623, 0.1976931831578268, 0.19867320383309395, 0.19099757562437103, 0.19348937795577414, 0.36383555041694493, 0.200671149923223, 0.1822497059593946, 0.18249183327438745, 0.747210909209451, 0.16705192268318692, 0.7759180600264813, 0.732024764217331, 0.5168113708920302, 0.1605957222003329, 0.46534546002992994, 0.6935180282376465, 0.48202633704121467, 0.31632720785365187, 0.20257682314394587, 0.20188600766967169, 0.6838386335067718, 0.4768994637396833, 0.2668046136753838, 0.21087034474146993, 0.2062103168829168, 0.20191112976080183, 0.18225302915917463, 0.19534996243018476, 0.19465849719919193, 0.17571800103293722, 0.19099463461781374, 0.18122581242994185, 0.19739872187678587, 0.17974962351323953, 0.19344989196248363, 0.08062798547564543, 0.07465777404570695, 0.08952920070524306, 0.09021215964577622, 0.08252437893503284, 0.07268771221676362, 0.07186255811149145, 0.07856406084777368, 0.08668543517599736]}, "mutation_prompt": null}
{"id": "da65e7e0-190c-46ca-bb56-b710f52d4345", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []\n\n        # Adding variance-based scaling to F\n        self.F *= (1 + 0.1 * np.var(self.successful_deltas))  # Change: Fine-tuning mutation strategy", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune mutation strategy by implementing variance-based scaling to enhance exploration capabilities.", "configspace": "", "generation": 30, "fitness": 0.060420969106612446, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.15691525194733114, 0.12911435602172983, 0.1098065105902577, 0.09302859347508197, 0.128475374668107, 0.10557984323667347, 0.11367651780208832, 0.15373924621850643, 0.1722595913992323, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.008062046924192656, 0.02152161969793054, 0.023489544682590346, 0.03440865036453833, 0.0333632542212452, 0.01719725214534451, 0.006919366907035318, 0.0437977290528212, 0.010686732688759415, 0.007920069396445961, 0.0, 0.011943850648228227, 0.014751649081941487, 0.0, 0.014934094019302013, 0.0020563355067588773, 0.0, 0.022822145380725467, 0.06326960434001816, 0.0752388051986822, 0.05284757512137328, 0.09944882446106584, 0.08309641002896317, 0.05848898369912803, 0.07817022157618536, 0.08115278374482082, 0.05180095099433024, 0.09336718660725729, 0.03601425396896207, 0.0, 0.08564969716949544, 0.0, 0.03975893121913654, 0.07519251063514798, 0.018331015833144337, 0.07018415740473682, 0.03790438358476911, 0.04847388417716614, 0.05151297303538793, 0.16065743199639837, 0.12101991893337527, 0.0841215959166155, 0.1419759672091816, 0.05911535734619411, 0.07661077529749238, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.035256277288254534, 0.0, 0.0, 0.0, 0.028140406697056863, 0.0182913255013053, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.15808358538855793, 0.15045968588166436, 0.14356772185168265, 0.16858090988016405, 0.12620463262660397, 0.15776284486469372, 0.12491867165006187, 0.14998185954712406, 0.1877867566974213, 0.020003472030272862, 0.01650119555300167, 0.03416514783700475, 0.028477346047462326, 0.03291411710842529, 0.053103855998411054, 0.01742191382556013, 0.03192532709415208, 0.024208880069519934, 0.10208161870172516, 0.08396000188515806, 0.10278148114337704, 0.10802370968617647, 0.08364381557769707, 0.11110630226555929, 0.16398307456998118, 0.09737111661430953, 0.08913653230045127, 0.1219410654990456, 0.1479328130396379, 0.1275470559177847, 0.1342918714158755, 0.13373958762298266, 0.13750773157552953, 0.12805174075161596, 0.13498869606515018, 0.15499123020576788, 0.08326523449503997, 0.08584046078228291, 0.07919024263886809, 0.07747417615441776, 0.08474604142886033, 0.07108657739623869, 0.0704365753727112, 0.06741770421493398, 0.0973766779672014, 0.1199317623334828, 0.12352987186956543, 0.1548912458968147, 0.13270854307934077, 0.11024643177434157, 0.12167266817472921, 0.11043464560353111, 0.13045714109341444, 0.16639795756662812, 0.12321075265492887, 0.004261105826766642, 0.0445669733478824, 0.07784483546211718, 0.0, 0.141308608520336, 0.0, 0.0, 0.0, 0.10658796111406443, 0.10713207101256117, 0.11192348478612779, 0.10191196647468204, 0.11291812742335627, 0.059505172139975526, 0.1308615180536613, 0.09262475358642974, 0.09513395688930981, 0.1314291413320754, 0.05269889669249006, 0.09481282429111526, 0.16197704268747237, 0.06340623128916012, 0.1028674987439181, 0.1687956914655795, 0.10259458695009893, 0.06615077223467247, 0.1527079111391364, 0.15701593260295865, 0.14881637388501567, 0.15638337545919168, 0.14710169369156734, 0.17821898647264678, 0.15385253661324683, 0.17293724706905433, 0.17143705270015175, 0.02624812750128347, 0.026282790902555697, 0.04175222950702806, 0.033580231466858845, 0.02205984608290512, 0.035439242647407276, 0.057209478075131104, 0.037452299044529735, 0.04009683749431647]}, "mutation_prompt": null}
{"id": "704746e4-f8bb-4c4f-9aa0-059f9d98ebfa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces adaptive mutation by dynamically adjusting the differential weight based on historical success rates to enhance exploration and exploitation balance.", "configspace": "", "generation": 31, "fitness": 0.38547287431988775, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.7748464961126806, 0.7789702131706979, 0.7540516529691332, 0.7687450467904621, 0.7674711393844942, 0.7537486030077765, 0.7651636670551478, 0.7911977919416088, 0.7687208756128627, 0.6025852393341563, 0.5641390452152131, 0.5665350379272935, 0.5712128834052064, 0.5715874066933875, 0.5758443733574681, 0.6024945703408231, 0.5697879464479783, 0.562126318552387, 0.13112056122192772, 0.11900328261538984, 0.1392928858510344, 0.12201881674906123, 0.11728992981071606, 0.12246246670594807, 0.11048162538933282, 0.11622781423771578, 0.10382122993109733, 0.10673700410240361, 0.1108507154599736, 0.13140519426212594, 0.10656172211377957, 0.10359018323338953, 0.1029399207617514, 0.12222579270783118, 0.10280138554251206, 0.1080018421028146, 0.9301441471482056, 0.8432601647617872, 0.8750805198447409, 0.8617996662413493, 0.8293336701997498, 0.9193651074771242, 0.9227487764393825, 0.9513240334931139, 0.9312065618781205, 0.3624603956586179, 0.352720509745162, 0.30236111763510976, 0.2984477840634481, 0.2485131015350336, 0.36576973819882774, 0.3751391436908923, 0.2578391997441015, 0.322000496684266, 0.7835061533290987, 0.7487413078355096, 0.7376174544418475, 0.7841193516872242, 0.7762489269412463, 0.7718077900792177, 0.7803764802364646, 0.7833074237655524, 0.783955037202765, 0.21620323784084028, 0.5122314724086235, 0.2787203997938542, 0.1971766098169715, 0.1881040693739584, 0.28821625052085287, 0.1767157814173792, 0.1735692348507306, 0.4443540101525272, 0.2169574757497168, 0.1198543737063461, 0.22210175957030542, 0.1568748131481681, 0.1582314043963301, 0.15759437018410083, 0.167833409731183, 0.2964523677821803, 0.24027054159813677, 0.534248328003176, 0.5069098655406745, 0.522315698567376, 0.49812834712747667, 0.4601273761891165, 0.46831434235555247, 0.5268364360852936, 0.5326511294386805, 0.511953361420326, 0.6473566225317282, 0.642391882321764, 0.6411860038544155, 0.6490871457284519, 0.6113001743838771, 0.589564369422566, 0.6779657708306512, 0.6330785573958483, 0.6253263870060268, 0.2478277078926009, 0.11493496132713787, 0.062225636201015955, 0.37033389946669326, 0.13502523587103843, 0.32478178327814866, 0.1499945881095417, 0.1660509145219048, 0.20158133815630164, 0.40265329977168784, 0.40408431579613036, 0.38355373257495207, 0.41471986247000725, 0.4207520687312918, 0.34566904100932083, 0.3753744720713942, 0.38565406813588876, 0.3634642626686594, 0.7009153778861317, 0.7143452071972013, 0.720696250541154, 0.7510106398738388, 0.7062312052073663, 0.7058887272490257, 0.702520112905418, 0.7232092847490128, 0.7177270089753234, 0.11074225417424755, 0.09298463425951464, 0.10103806433729445, 0.09824275080363254, 0.10755352849727262, 0.12572893632837057, 0.10821617895919478, 0.1196210743895979, 0.11633179099200097, 0.14684258280808649, 0.15305960041826716, 0.17595372454675018, 0.14424622000218956, 0.15324808471940576, 0.1464645756936428, 0.18137144034797137, 0.15085750405281617, 0.15676424333194794, 0.4400649851856113, 0.4254715630429319, 0.4378636324866496, 0.43796466222305974, 0.41491158034988207, 0.3917768987637964, 0.42085097900995194, 0.4025254665886754, 0.4409622933080575, 0.3643593083910267, 0.3365005730275662, 0.35288967512247915, 0.33810908588334965, 0.3213263147233051, 0.34827027349701767, 0.37464344651354353, 0.34595922352108377, 0.35079040170998554, 0.19852390540532971, 0.18539321745163462, 0.20615357993301475, 0.18038789997703775, 0.19083447892876382, 0.17968006306281914, 0.1905506252363206, 0.18910138444778957, 0.19872473092395437, 0.1911214747847232, 0.23157188417004304, 0.1888954949251319, 0.19564309817775472, 0.17945678281320454, 0.20072451323781093, 0.1974171801959428, 0.28679367757717833, 0.1951717972890411, 0.7200396045467861, 0.7352076940166123, 0.8078032657976936, 0.5933514578664254, 0.6840135547495012, 0.6333003025805264, 0.7422722435720867, 0.7286674599831671, 0.6989910319278287, 0.7522224476872066, 0.16471747469580622, 0.2002405657258851, 0.768013663587656, 0.6265386824718491, 0.19761551367125252, 0.2100274041762683, 0.20301026521961274, 0.20196122259113536, 0.1807726892652607, 0.20154444687995865, 0.20102908447937007, 0.1812633180933202, 0.18964389007543203, 0.1864008143091248, 0.17921269299862086, 0.1865193826361775, 0.19595565750798205, 0.0774698463526523, 0.07497823043364826, 0.0757227265203968, 0.07137787241380988, 0.0753466857180709, 0.0826121797571876, 0.07496655991265722, 0.07378835868835487, 0.07820609867982709]}, "mutation_prompt": null}
{"id": "be93e53c-d196-43c4-a4b4-a403aec7b54b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.lognormal(mean=0, sigma=0.5) if self.adaptive_scaling else self.F  # Change here\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Incorporates a log-normal distribution to dynamically adjust the differential weight, enhancing adaptation to problem landscapes.", "configspace": "", "generation": 32, "fitness": 0.37541010086136284, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.7348841419263965, 0.734982204001262, 0.7289204396056852, 0.7642692808417679, 0.7562408709171373, 0.7534183095028939, 0.7305903000943902, 0.7724957065323195, 0.7605563285893107, 0.5241574100335518, 0.5379986621661825, 0.539973390302042, 0.5196084731157935, 0.5191454541620089, 0.5086451432119241, 0.5349400691440858, 0.5286243859505114, 0.5483844205047348, 0.10987397393317055, 0.11670709906643262, 0.10957374339419512, 0.09747672726098533, 0.1286378643877495, 0.12305866156476508, 0.10633191197675496, 0.14741977915004467, 0.11796723088194017, 0.10780889643252922, 0.12090516797648432, 0.10934089953983017, 0.10655570577363183, 0.11121771300297478, 0.10462569359248186, 0.10373177007495815, 0.11926454908862727, 0.10921739416065446, 0.9099916701006119, 0.9335267421845341, 0.9282928802636954, 0.9483793105158831, 0.9053989910181497, 0.8265633562183812, 0.9348962462672873, 0.8732001199343008, 0.9007300563921943, 0.3586936481184614, 0.4651441647544369, 0.40116040872400194, 0.37993155167670534, 0.30048056342242657, 0.3065468858608258, 0.3469804461728899, 0.37007275799127326, 0.36446121323027914, 0.72465049546817, 0.7452564651228901, 0.7396564851439217, 0.7436132382256277, 0.7491291044448448, 0.7473949787913607, 0.7564031857476032, 0.7843134969650081, 0.7569469643574651, 0.24145617051022705, 0.2090818866177948, 0.4361356719028525, 0.30982847391377477, 0.1926263009670457, 0.294883035439669, 0.20273803442072014, 0.27019640545636603, 0.19468729895017634, 0.17342064504870436, 0.3109185765655612, 0.20426100886746512, 0.5165137341384096, 0.22861790049300657, 0.42285164172737555, 0.24863844324717155, 0.13033506574677045, 0.1666524731194442, 0.5519711785362166, 0.5298246637639351, 0.4668172070823906, 0.4616590682652376, 0.44634753994555665, 0.4971680522594145, 0.5211964877744669, 0.4546390787986201, 0.5071263567418343, 0.6199749594513024, 0.6209344908485965, 0.592481819863742, 0.6143638880071614, 0.588805824381897, 0.6636972441489967, 0.5890206192999843, 0.6355924479948389, 0.6001111469300999, 0.1271341102473511, 0.236392008048825, 0.2038492428065336, 0.2874516599658359, 0.28091044454718805, 0.2763646593078798, 0.19589114461946222, 0.19101878425984364, 0.24547386765189927, 0.3535370589843394, 0.38519374090086167, 0.36076330349262575, 0.36720331545508567, 0.3818759755815305, 0.37765005590700096, 0.38652159685649234, 0.3500948490704472, 0.36801195650763596, 0.692966142072531, 0.6833798061631928, 0.707877358114691, 0.7112401396869026, 0.706355530708709, 0.688179361231483, 0.676704077098669, 0.6843415204508118, 0.7016149261929344, 0.11057570847963416, 0.09812188540272504, 0.0971985908640911, 0.10282844407048541, 0.09094438321805487, 0.08666632271780783, 0.08661394563854852, 0.1096409217109251, 0.08757387448500742, 0.1580444852646673, 0.2582569555232743, 0.15292285569374853, 0.14276150061078063, 0.1782507889056273, 0.16236880591382163, 0.14233351045587184, 0.1682420175717867, 0.1545249451976597, 0.3972068337550835, 0.38069001237663136, 0.38900340410108125, 0.3558309599953968, 0.406458253585232, 0.4217991849110494, 0.43683954762407473, 0.3795769332997315, 0.4211275769033497, 0.3199782176167498, 0.3214306283195829, 0.34061477289427633, 0.3333062999783578, 0.3489572367808953, 0.28596603516390384, 0.35363600070614176, 0.31781586526349836, 0.32680426243576166, 0.20340013870789686, 0.19708108409350922, 0.18698037831075165, 0.19322831768002902, 0.20409313421922592, 0.19393664731716298, 0.19401921736424355, 0.20437424032597196, 0.18989129240485159, 0.23484141260663138, 0.21170941178134695, 0.20163239669796018, 0.3080178403470828, 0.22662425686624665, 0.2063773520830955, 0.18371184786389727, 0.1774333414090855, 0.1903169031335027, 0.19133469965289884, 0.7147531967193539, 0.17962157207650742, 0.5375357956101378, 0.7297040443077305, 0.6479359195886009, 0.6356725141909447, 0.6956339039604422, 0.64462189817312, 0.6589911263882686, 0.199849664081011, 0.16707853937088113, 0.16421757085545474, 0.5677464116127335, 0.19898098378169038, 0.2042704644026465, 0.6545667727041793, 0.20068557755358218, 0.1775630755799562, 0.18152549033036336, 0.17936898689873437, 0.18308271489708816, 0.1858848599021682, 0.19146525914151558, 0.18636896846830608, 0.18768119237014436, 0.18501260496371263, 0.07693656680390448, 0.07072560963444452, 0.08181324633130915, 0.08470366769992799, 0.06869239744122024, 0.08205273201774466, 0.0726669964634944, 0.0912444404946493, 0.08307446480667846]}, "mutation_prompt": null}
{"id": "64a02dd6-d8a9-4886-a790-dc6aecbda8ff", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        initial_best_fitness = np.min(fitness)\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n            \n            fitness_scaling = np.max(fitness) - np.min(fitness)  # Shifted fitness scaling\n            if fitness_scaling > 0:\n                fitness = (fitness - initial_best_fitness) / fitness_scaling\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhances diversity and convergence by integrating a shifting fitness scaling and diversity preservation mechanism in adaptive differential evolution.", "configspace": "", "generation": 33, "fitness": 0.09459504627869741, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.15784863873909705, 0.14849295550256358, 0.16269146037397153, 0.16243314094370054, 0.19871631999196604, 0.1710219037538454, 0.16971277244083627, 0.1730360139989403, 0.16448807205967786, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04198376732410691, 0.03592957113916784, 0.05003827383565518, 0.05059389454767793, 0.04168097934166004, 0.052396290512209065, 0.04101837930817476, 0.04607698839176233, 0.04264200767431525, 0.033650402604591734, 0.031346983620690105, 0.03106461405601113, 0.0323361758932833, 0.035710114418429306, 0.032357552649667, 0.02492279454804247, 0.019680374801207323, 0.045555833675879676, 0.10974474339770002, 0.12496812186322126, 0.08059313473361596, 0.14429327009268822, 0.11615440490204798, 0.11651663744882967, 0.11035773367194035, 0.7274029635358075, 0.08565519369860741, 0.0934577391065784, 0.07082113955403146, 0.08351173848045779, 0.088620998958722, 0.0739415642264748, 0.053518296805488696, 0.11432333325253352, 0.06923963334732341, 0.09610064738009028, 0.12092815855304584, 0.13330684615871502, 0.1576462588483395, 0.16074133285496295, 0.11643201329220698, 0.12436438395516014, 0.14380142795527828, 0.10773669689821685, 0.13142345064902983, 0.0009357350811209919, 0.006614491765695285, 9.999999999998899e-05, 9.999999999998899e-05, 0.029720548711784756, 0.09251425045865758, 0.004494032489767208, 9.999999999998899e-05, 0.004167695363357371, 0.01138628263258723, 0.0026402765755101365, 0.029448538208749375, 0.015152239015677194, 0.012579130714161724, 0.022229760320702008, 0.01842821388883653, 0.0012215217934014033, 0.002682740821320806, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056370444112137874, 0.03876219551961968, 0.07285109507625165, 0.08446331438584753, 0.06034326478612384, 0.027651042629336375, 0.039191674582247815, 0.047123718347532484, 0.04587924224599249, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04359673500909578, 9.999999999998899e-05, 0.19739607243916557, 0.20261472229631006, 0.19532964651674767, 0.17370443291054727, 0.17484577143361857, 0.1745909680883153, 0.19364691852927218, 0.20577845843450782, 0.2062647599813785, 0.05051282177074279, 0.041197331730998266, 0.0457019048793178, 0.056462254867554074, 0.04490022932299165, 0.05768948441646593, 0.04303776377091295, 0.04634744529028034, 0.04477605974108634, 0.14145000369805116, 0.15509591772656273, 0.13786488615213766, 0.1517648383968606, 0.12759296477818316, 0.12077346155700175, 0.16406656113496543, 0.13793647399768982, 0.1365214981137669, 0.17029113165959808, 0.17043558518754576, 0.17917561437705498, 0.1517678836870927, 0.16356003274593223, 0.17156620742673168, 0.16197407270488418, 0.1525869738575386, 0.16374771435052116, 0.10867907810443356, 0.19169283702653028, 0.11303123850045471, 0.11211911344379388, 0.11290602308643793, 0.10489472892606733, 0.11427002549357346, 0.09669767215794778, 0.11394986304404209, 0.15829476554034372, 0.17034869196613767, 0.1671551669162754, 0.1587257534095965, 0.16688692801736293, 0.14687183187603736, 0.15093724660907626, 0.1631413294086579, 0.16973416144040132, 0.1860463012255048, 0.1048637521788991, 0.1699009527748796, 0.1505891126531127, 0.13386324666531413, 0.1511450375320481, 0.15491889136095272, 0.13737594812795473, 0.14686852176202247, 0.13388314414979652, 0.17989996113932427, 0.17902930427195152, 0.1755781706083781, 0.13684329835349252, 0.18181370070606095, 0.1364407590568466, 0.17768666309283054, 0.13169482184015957, 0.1514418426767148, 0.13410111155355475, 0.2594301682318344, 0.14925667140016252, 0.13328525681660353, 0.15443915967465782, 0.19787031097591623, 0.1978800356208561, 0.18638562108721968, 0.1712814320068068, 0.18332410196119786, 0.18375412588690665, 0.17804672019719514, 0.18523772646458525, 0.18091219887530008, 0.17630641911753098, 0.20686280683689795, 0.19400965430169959, 0.05763714275654552, 0.05065396399309341, 0.05510854692799816, 0.04327744412334089, 0.05007268668568654, 0.049069381824989655, 0.057317420251029816, 0.060070658688278544, 0.056474152519248255]}, "mutation_prompt": null}
{"id": "3ffa7336-a6d0-4ada-bfed-bf34b43ca2bb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            # Dynamic population adjustment\n            if np.std(fitness) < 1e-5:  # Convergence condition\n                self.population_size = max(4, self.population_size // 2)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces dynamic adjustment to the population size based on convergence, providing an adaptive exploration-exploitation balance.", "configspace": "", "generation": 34, "fitness": 0.36291981230062687, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.23.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.6560257959046596, 0.6637850259436568, 0.6430245252090339, 0.7192361475610951, 0.6911729231956619, 0.6513535380290066, 0.6693739759199702, 0.6651662992759522, 0.6365640598073145, 0.519010331414146, 0.5110156988096655, 0.5172972898331393, 0.489797952605763, 0.5265467154660576, 0.48265586186914966, 0.5315355058865916, 0.49337543591465005, 0.48236788938796793, 0.13112056122192772, 0.11900328261538984, 0.1392928858510344, 0.12201881674906123, 0.11728992981071606, 0.12246246670594807, 0.11048162538933282, 0.11622781423771578, 0.10382122993109733, 0.10673700410240361, 0.1108507154599736, 0.13140519426212594, 0.10656172211377957, 0.10359018323338953, 0.1029399207617514, 0.12222579270783118, 0.10280138554251206, 0.1080018421028146, 0.9301441471482056, 0.8432601647617872, 0.8750805198447409, 0.8617996662413493, 0.8293336701997498, 0.9193651074771242, 0.9227487764393825, 0.9513240334931139, 0.9312065618781205, 0.3622795258379362, 0.3524687055467096, 0.30236111763510976, 0.2983887733132201, 0.2485131015350336, 0.3645875148261407, 0.37012286716545295, 0.2578391997441015, 0.321988669408273, 0.7835061533290987, 0.7487413078355096, 0.7376174544418475, 0.7841193516872242, 0.7762489269412463, 0.7718077900792177, 0.7803764802364646, 0.7833074237655524, 0.783955037202765, 0.21620323784084028, 0.45147804352893395, 0.2786942620160462, 0.1971766098169715, 0.1881040693739584, 0.28821625052085287, 0.1767157814173792, 0.1735692348507306, 0.4111148211774309, 0.2169574757497168, 0.11985436859738985, 0.22210175957030542, 0.1568748131481681, 0.1582314043963301, 0.15759437018410083, 0.167833409731183, 0.2964499415234447, 0.24027054159813677, 0.4727492210248495, 0.45038284942228735, 0.45423507589942524, 0.43369917688547455, 0.42181665456853423, 0.4139033096209047, 0.449752060934984, 0.44484562225855495, 0.4690596549534882, 0.5596180567236723, 0.5720251323138729, 0.5426011839520546, 0.5386574436818202, 0.5202634425707329, 0.5095581285568372, 0.5793942492546131, 0.5333991968007361, 0.5094193603584323, 0.2478277078926009, 0.11493496132713787, 0.062225636201015955, 0.31975344760396196, 0.13502523587103843, 0.310103100729725, 0.1499945881095417, 0.1660509145219048, 0.20158133815630164, 0.3834575401006335, 0.39197746810035383, 0.3677180318018347, 0.39524974290834636, 0.39320378213022344, 0.3393571833473866, 0.36425181673979845, 0.37581104475312455, 0.3551428096117375, 0.607316398406833, 0.6153389528911108, 0.6056351264133829, 0.6252346849280186, 0.6074893310967183, 0.5824974193159302, 0.5878534223165266, 0.5918082726750218, 0.6112011010938025, 0.11074225417424755, 0.09298463425951464, 0.10103806433729445, 0.09824275080363254, 0.10755352849727262, 0.12572893632837057, 0.10821617895919478, 0.1196210743895979, 0.11633179099200097, 0.14684258280808649, 0.15305960041826716, 0.17595372454675018, 0.14424622000218956, 0.15324808471940576, 0.1464645756936428, 0.18137144034797137, 0.15085750405281617, 0.15676424333194794, 0.4357063799442398, 0.4247804204746022, 0.4317277789279168, 0.4361384180742299, 0.4147177161308734, 0.39137861406463714, 0.42084052809780736, 0.40222996054348337, 0.4377389550856071, 0.3643593083910267, 0.3365005730275662, 0.35288967512247915, 0.33810908588334965, 0.3213263147233051, 0.34827027349701767, 0.37466268938783376, 0.34595922352108377, 0.35079040170998554, 0.19852390540532971, 0.18539321745163462, 0.20615357993301475, 0.18038789997703775, 0.19083447892876382, 0.17968006306281914, 0.1905506252363206, 0.18910138444778957, 0.19872473092395437, 0.1911214747847232, 0.23157188417004304, 0.1888954949251319, 0.19564309817775472, 0.17945678281320454, 0.20072451323781093, 0.1974171801959428, 0.2866350146357548, 0.1951717972890411, 0.6851575476257707, 0.6715071662806695, 0.7297988465639411, 0.5520162509635742, 0.6453948772420128, 0.6327138620976988, 0.6728921633705081, 0.6960826777385398, 0.6543310450760993, 0.7141874599595504, 0.1647174157840371, 0.20024053971721412, 0.6435342324319251, 0.6058095148816639, 0.1976154704369123, 0.21002717563481865, 0.20301022724880202, 0.20196115158052697, 0.1807726892652607, 0.20154444687995865, 0.20102908447937007, 0.1812633180933202, 0.18964389007543203, 0.1864008143091248, 0.17921269299862086, 0.1865193826361775, 0.19595565750798205, 0.0774698463526523, 0.07497823043364826, 0.0757227265203968, 0.07137787241380988, 0.0753466857180709, 0.0826121797571876, 0.07496655991265722, 0.07378835868835487, 0.07820609867982709]}, "mutation_prompt": null}
{"id": "f52162de-11a7-489f-9301-73ae46ea9328", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = np.mean(self.successful_crs) > 0.5  # Make this one-line change for dynamic scaling adjustment", "name": "AdaptiveDifferentialEvolution", "description": "Introduces dynamic scaling factor adjustment based on fitness improvement for enhanced convergence.", "configspace": "", "generation": 35, "fitness": 0.3756205934053743, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.7477535968720459, 0.7531032631508424, 0.7557848147200151, 0.7592083958041803, 0.7663889252974293, 0.7757548140855217, 0.7600256414211547, 0.7684450624258825, 0.7800062667485491, 0.5712624461279019, 0.536365551556592, 0.5555629804083262, 0.5896499315737418, 0.5678963861182706, 0.5572777295942661, 0.5761025498536927, 0.5672506901025265, 0.5917234688508377, 0.10919167626475867, 0.1197831787802317, 0.11175512956310285, 0.11149000126046194, 0.11381163740665001, 0.11841520952382356, 0.10578963382058426, 0.11669370172231208, 0.12367409418561093, 0.10170203992747806, 0.1035525470592551, 0.103863280356985, 0.10500067632092325, 0.1055177395241319, 0.10756999604030293, 0.1059478234658352, 0.0999795994956818, 0.09937911440574576, 0.9551726628427566, 0.9493284708767312, 0.895961544869359, 0.9242901109724273, 0.8904993877136728, 0.8865863312689507, 0.3903958002741156, 0.8911409965503869, 0.9416144981572834, 0.31154462993150167, 0.24097904201145204, 0.28664914781760653, 0.3481311384405391, 0.3071934851810235, 0.2869787855374618, 0.3263884923721535, 0.42478345560560116, 0.3099517175348496, 0.7692187382490093, 0.7486860523606902, 0.7820377117554471, 0.7546891513928864, 0.7574242850255396, 0.758026712938195, 0.7587272961720137, 0.753645449392665, 0.7307167761435426, 0.16899603999982626, 0.46688273427413185, 0.16523481558942132, 0.41525203514860776, 0.1485448003531965, 0.2707784925999369, 0.2542018677772233, 0.1393380393371927, 0.17354565032437508, 0.12420871431939962, 0.410718853971456, 0.24643327809229854, 0.24403556071651233, 0.5106623671909059, 0.2081407880665005, 0.1955320548978443, 0.15578152938253698, 0.21092591367496227, 0.5283249979553547, 0.5456671828905197, 0.5089035410874019, 0.503304804373844, 0.5512666536083142, 0.49852683696732125, 0.5001424638565577, 0.513136743832464, 0.5062865420784534, 0.6202937232574807, 0.6419697431633262, 0.6346923642188333, 0.6082654103693178, 0.62380262737499, 0.5652331655430333, 0.6374143186567264, 0.6315691689216276, 0.662879631722894, 0.11562656586288755, 0.21130382547987026, 0.17183574726231288, 0.3788454515679627, 0.3559862002060443, 0.2397484907908164, 0.1869302419345491, 0.2007876923898494, 0.16319663356926517, 0.37209307999051133, 0.34309494563980625, 0.368275592593703, 0.3964223775604049, 0.35803672731268343, 0.3966632889973879, 0.38156978210478987, 0.3599908634208183, 0.36387123375803787, 0.726374951739932, 0.6919696501383471, 0.7056077043428666, 0.7459466087069295, 0.7378596956904369, 0.7077535967839305, 0.7172575692887195, 0.6961547689428627, 0.7135177101585393, 0.09788101139853456, 0.09458489852848284, 0.09805000002426656, 0.08542644665672139, 0.09114940513782166, 0.09471560405984236, 0.09412676428058842, 0.08460681715357243, 0.08328148862588769, 0.1553769234542871, 0.13269948799431308, 0.12603425470815832, 0.14606620813350069, 0.1737756832980658, 0.13647304816737083, 0.1703272832768662, 0.12593947554918905, 0.14905880299834695, 0.3831367299658236, 0.4254475418203507, 0.39693848604100634, 0.366316888324161, 0.39786220640848124, 0.39332180369575986, 0.4462874804229525, 0.39401651355437284, 0.4182029678549598, 0.30991636762057795, 0.3340752452391381, 0.34989579247091884, 0.3074357417974124, 0.35654786753719414, 0.32700846930503935, 0.3474210404393818, 0.3431535370040957, 0.3774445925264407, 0.19976086669837745, 0.20656185260119664, 0.20236775853520417, 0.17419551457988147, 0.209112073178935, 0.19850813186845218, 0.18966781664234267, 0.1872454525201962, 0.2121942170658594, 0.21291323551346208, 0.18962874021884013, 0.1944134581863859, 0.17619800571316446, 0.1696739174352624, 0.18790802828503717, 0.19669456573808752, 0.17234047270485475, 0.25176440909590125, 0.17412367518701155, 0.6558233046175929, 0.19162345962822158, 0.6960254840899162, 0.6530785255880338, 0.7267177551920416, 0.6674125286777249, 0.612291228470196, 0.6631535095978257, 0.27193430313117617, 0.20005546709458233, 0.20058482793187904, 0.680241778824634, 0.6164724200372766, 0.195915602006426, 0.3901363246298222, 0.7333341143021388, 0.19739298074302547, 0.17470575005642963, 0.17941384644331015, 0.18673937643553196, 0.18246529538702916, 0.1807848462372207, 0.18625846205389884, 0.19243359368863688, 0.18361411419190532, 0.18356095789988214, 0.07481055998963149, 0.07179268079313028, 0.07289669255517695, 0.07471788934020096, 0.07761742612753075, 0.0815347417026051, 0.08301641920007607, 0.07383223740483014, 0.08132868719639608]}, "mutation_prompt": null}
{"id": "331e0f65-85ac-4645-84f5-a8f96677cb52", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5 + np.random.uniform(-0.05, 0.05)  # Slight randomness introduced to F\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)  # Initial crossover probability with stochastic adjustment\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F  # Adjusted adaptive scaling\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n            \n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Adjusted line\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tunes the differential weight `F` by introducing slight randomness, potentially enhancing convergence speed.", "configspace": "", "generation": 36, "fitness": 0.374558608830577, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.7694173311326726, 0.7684767217404773, 0.7605183055245407, 0.7630455862975778, 0.7448461726587641, 0.7703001368743405, 0.7760593628625235, 0.7661538124705067, 0.7732268654259088, 0.5982636319741368, 0.5793145029213499, 0.5723019510569725, 0.5727585142526144, 0.5541641171615429, 0.5833753735958073, 0.5908307340569414, 0.5590285117475386, 0.5589656664375589, 0.17234593715170432, 0.09010154966586814, 0.16909434834312764, 0.11048824821829362, 0.11683241144356693, 0.13332208146402502, 0.1172037325363563, 0.098926207726445, 0.15186602852255726, 0.10403246898825613, 0.10791800254994599, 0.11798180353909515, 0.09806176421218793, 0.10426519160479797, 0.13712272664591985, 0.1337831907890168, 0.11079992549937157, 0.11903149228093157, 0.946969876980738, 0.959757490523866, 0.935919274589482, 0.42970795363874836, 0.8442710165032757, 0.8962707004196626, 0.7544264124839395, 0.7382272112193027, 0.9024248817281307, 0.38012841972727973, 0.30137791819488124, 0.3013711673649585, 0.4383505373230322, 0.2801822556596826, 0.3764745247450092, 0.2768943379599186, 0.39450821316290174, 0.3301349363997862, 0.7766278600037919, 0.770630693970499, 0.6366336916546799, 0.8082550810159606, 0.8134590925058081, 0.7421560894003683, 0.7874756080111085, 0.7986569286661034, 0.7482499945675627, 0.1841736362141021, 0.2928586588414821, 0.1672877668790992, 0.3248097683338679, 0.15713590418400358, 0.4154192704078906, 0.16673240014575785, 0.19694127470275424, 0.21749136790400403, 0.5245156213701223, 0.3231512930964343, 0.38455159651615367, 0.2405341701092314, 0.20005266346192663, 0.17385858679872346, 0.1670432508780677, 0.15258771078174582, 0.41866229144892164, 0.5340811819523411, 0.5013215047492248, 0.47176467338702965, 0.5238838366681722, 0.45844725190026725, 0.48812571171689023, 0.5537672373355029, 0.5131237441038943, 0.41163520862422187, 0.6626562754936061, 0.6597249127261215, 0.5756880500234878, 0.6450159157190329, 0.627134438522919, 0.5237367227097087, 0.6513165389208834, 0.62785007699923, 0.5464791091847507, 0.24958239013647476, 0.1544468189576632, 0.09674752754034965, 0.21331775521787866, 0.34642475005343953, 0.32505835351477685, 0.1705638326414164, 0.1523324704047505, 0.16539525300013647, 0.4186725950079936, 0.3957144527567281, 0.3818145644039834, 0.4151044283604556, 0.41162464803083676, 0.35083544006536793, 0.3884113137228653, 0.4178737215988544, 0.36764804875766854, 0.7083543160055966, 0.6997488276417134, 0.6942524412294464, 0.7288518372667074, 0.7285355783658547, 0.702143315442816, 0.575362005045251, 0.7217791471069712, 0.6795070538668402, 0.10905823893465627, 0.08566690302162627, 0.10511492437897119, 0.1077548989570909, 0.09799214192156303, 0.10004731675594813, 0.11716347221322632, 0.11682905197540094, 0.11080393966413704, 0.18052900790859727, 0.1659507091257667, 0.15526638797669878, 0.17575234042440846, 0.14259262347931834, 0.13995110144307332, 0.19339357129994328, 0.1477455831899228, 0.13321216461751595, 0.43333644534563975, 0.43653858325771355, 0.4067414386463415, 0.46628172617178676, 0.4241191103870069, 0.3652223834580347, 0.4373791010759378, 0.4420749805697539, 0.3959937515315024, 0.3757213723795152, 0.3533511511328733, 0.30410893345645784, 0.34026495690931824, 0.34495258614964186, 0.30389067187300345, 0.4040189894991848, 0.37414332888029767, 0.3285818716597677, 0.1998180633595218, 0.2597757146909626, 0.1964659526840915, 0.2069094597674671, 0.19690728758229092, 0.180973207839348, 0.2020513043541161, 0.20232647201836063, 0.18893573782120276, 0.18827780713091224, 0.20136882027509773, 0.21720322517559876, 0.3188225402763083, 0.18097520355312868, 0.24256435310641222, 0.1861468929607567, 0.20096287838993, 0.18123588510064215, 0.17967617940102187, 0.8215093467122815, 0.6537204500461921, 0.6310634964568923, 0.7559442767760949, 0.5189235536008577, 0.6557476511722895, 0.16979500462075992, 0.39590854763828087, 0.16662278526079988, 0.16187435759976543, 0.18606812765201752, 0.7064521988222114, 0.6613942808385602, 0.1858757677076176, 0.2120702994732333, 0.20932626655133135, 0.19957942105425697, 0.19031565021811003, 0.18342354920123338, 0.18876946609915302, 0.21827433523095974, 0.17983326590180038, 0.17666030613695638, 0.18589250948243885, 0.17716169996147857, 0.1842598651179025, 0.07885400288053357, 0.07182932148861854, 0.08448848538023246, 0.08157732444643129, 0.07756115056515467, 0.07098723980566901, 0.08549369517517857, 0.08155112280791577, 0.07547885361447793]}, "mutation_prompt": null}
{"id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            # Change: Adjust population size based on improvement (1 line change)\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces dynamic population size adjustment based on convergence speed to enhance search efficiency.", "configspace": "", "generation": 37, "fitness": 0.42472825931298497, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "1a77c399-b9de-4a34-91be-8ffdb99b52e7", "metadata": {"aucs": [0.8672159723282055, 0.8012112193134666, 0.8242473484485486, 0.8462344849171597, 0.8672750675882919, 0.8575892369827743, 0.8724961343951949, 0.8511827817849897, 0.8625346493775341, 0.5742694024789133, 0.7481764304884864, 0.74032960728699, 0.7097141235806279, 0.5487174648352284, 0.7602087145039025, 0.7139291892895983, 0.757478429391961, 0.759937012899028, 0.18880140341843976, 0.44134280081056076, 0.2522922493973784, 0.2985561898393432, 0.36396469220924343, 0.16082496700747395, 0.37888714566914805, 0.4043417231249863, 0.15636839182457607, 0.17018495135597334, 0.14753712958630694, 0.13689246373172304, 0.14324344462851002, 0.14412164396357707, 0.13990853560391603, 0.1542671797464169, 0.4348975858478805, 0.13524188904201528, 0.9442704817638197, 0.9607959464349796, 0.954921707607515, 0.9645439961788689, 0.946061590752422, 0.9736828452327789, 0.9569445450243192, 0.9689519719709391, 0.9486988510302546, 0.34929264847855124, 0.29937823678091013, 0.34504633662830053, 0.44464382001683767, 0.3838741284927738, 0.4929484284436786, 0.5007679528203585, 0.27188325651534584, 0.35858106310330073, 0.8208739065690096, 0.22518545205300455, 0.8426076384412224, 0.8382085446251648, 0.8690530227591613, 0.8576541083082297, 0.7699303104631587, 0.8586344338149337, 0.8596117673699941, 0.7276595139006554, 0.1704161296861676, 0.15715843763645132, 0.18401248257015035, 0.16399994932947592, 0.1308228406319073, 0.3060244979815149, 0.1957615716325074, 0.21343252951609681, 0.31862583183708126, 0.15684455976724343, 0.1717917208975479, 0.17162926483664886, 0.21173540401312052, 0.1419847383795817, 0.3603532915922507, 0.1775150774673242, 0.2926165096439458, 0.6895620522969228, 0.7041328509756721, 0.5316348391058765, 0.6565540444616298, 0.7463882156015513, 0.5442583507489329, 0.7259564321777253, 0.32986494960390345, 0.6922121229073019, 0.7889812130243323, 0.2758382172123893, 0.7710286174592914, 0.7847221032257841, 0.5451800915158255, 0.8103854429124495, 0.4327066576373926, 0.6815438371607556, 0.784053042741659, 0.17336952570310493, 0.3445253175730909, 0.2185249221538268, 0.19721367941822954, 0.2062517309252495, 0.34899831418667926, 0.215377693134575, 0.10541098035230712, 0.16196350053612918, 0.4893634069803743, 0.2971844234035905, 0.2472641085391678, 0.436675878806693, 0.3490206722300139, 0.3589808153197074, 0.3329572573352797, 0.5153325378277003, 0.5979324521562046, 0.8093864898869789, 0.7252155807837384, 0.816299499577175, 0.8436590392014395, 0.7059185931087125, 0.8366967517860657, 0.7238647721166893, 0.6555233872369178, 0.8244727736202159, 0.11153790208672199, 0.15010700365314078, 0.14849142640766344, 0.12305309649159824, 0.13517294837516403, 0.1331525979385364, 0.1369203478545642, 0.15268441671118904, 0.14133795051413778, 0.16519798653022477, 0.23492390307418665, 0.203453874032137, 0.5089431301743546, 0.1129101235828186, 0.1612924942945625, 0.16539551679488818, 0.22253892567536837, 0.21605880013768286, 0.48879576873089436, 0.46873116073345134, 0.4257002366537016, 0.4263117850870818, 0.4833654523655808, 0.4184756102419699, 0.49890706252597183, 0.42051507260607546, 0.5285647961782949, 0.4697567158585474, 0.4620158865764109, 0.327997863326313, 0.4289448833668035, 0.4860504300062801, 0.4305410986050153, 0.5217096894577413, 0.46550149660359474, 0.3721012512087929, 0.20776847374253204, 0.18447899259327216, 0.19393470627639786, 0.20982619483756326, 0.1729481319285202, 0.20170477264268694, 0.20040265917283495, 0.23056121348051917, 0.21572544749709832, 0.23297829851374263, 0.5966136156444337, 0.19680966089649432, 0.23239519023574484, 0.41317755730625605, 0.6343820445844603, 0.48916614555266824, 0.4093226141426719, 0.21085306540360438, 0.1933612185721345, 0.19794359389556648, 0.8599566536926252, 0.17638342132279194, 0.16010628229983925, 0.797803767796622, 0.8314705386466941, 0.8109888983940354, 0.16606511383990785, 0.20482812862383482, 0.20217356733366754, 0.7319763851567908, 0.20646856479344033, 0.8488078651352043, 0.20854056377772834, 0.2086908856675177, 0.2110003408710721, 0.20729595791519362, 0.19071679901659233, 0.1762607628385675, 0.18374247666225318, 0.19797002411144016, 0.1841474553286343, 0.17952101352876748, 0.18399560263762482, 0.1861611595012258, 0.17816956042001042, 0.09357294003126648, 0.07778057400009586, 0.0787357236109345, 0.09091971213889449, 0.08405806374269631, 0.08002042619089622, 0.08386435500783829, 0.09126660070859305, 0.09009134111365913]}, "mutation_prompt": null}
{"id": "3dffcf75-2793-470c-b700-9ef570c373be", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n                    # Local search step for high-potential candidates (1 line addition)\n                    local_search_candidate = trial + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_candidate = np.clip(local_search_candidate, self.lower_bound, self.upper_bound)\n                    local_search_fitness = func(local_search_candidate)\n                    evals += 1\n                    if local_search_fitness < trial_fitness:\n                        new_population[i] = local_search_candidate\n                        fitness[i] = local_search_fitness\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhances exploitation by introducing a local search step for high-potential candidates.", "configspace": "", "generation": 38, "fitness": 0.4078406123822371, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.7864126249820707, 0.8195032937007571, 0.8287928919073453, 0.8098454122313731, 0.826111403020316, 0.7893820908500174, 0.8058273814961927, 0.8059403479735672, 0.8476027119280801, 0.6023422497093076, 0.67974205485885, 0.4833338054932448, 0.5812618836129703, 0.6449324092608801, 0.6179341788128763, 0.6845927015231408, 0.6886243939039359, 0.6705127577618344, 0.2617432781995257, 0.32005628790593144, 0.3861817866438033, 0.14090813925303702, 0.33392170082985106, 0.15245837080434355, 0.38215086627583317, 0.154369605282192, 0.37055560845448154, 0.1545818915395465, 0.09282290438060592, 0.12289237640155393, 0.13037285494863515, 0.17036216148435013, 0.14326239219503045, 0.10280173610278254, 0.25724153950577433, 0.14416122609674842, 0.8764280289871208, 0.9462129901860342, 0.8980971040971859, 0.9229301004121394, 0.9373020610801612, 0.9468360183776257, 0.9197191870062589, 0.9530224422875526, 0.9069562587820894, 0.38489533343777205, 0.38744684898138615, 0.43597408644563573, 0.37573532802695453, 0.382997064467273, 0.3337894535841167, 0.38355595340766035, 0.36844641689528723, 0.48031229915764484, 0.8392282880301294, 0.8317176283789851, 0.8099984547671681, 0.8305066210750487, 0.8814587239618739, 0.823592832959775, 0.7938204257290312, 0.845024209102326, 0.8425975671945247, 0.18760386987668265, 0.22233983052737072, 0.234633842885275, 0.20395035442084486, 0.12523011773713277, 0.20802212086872585, 0.2134368169211105, 0.2253840528772869, 0.1932497296330098, 0.1884575588584787, 0.24096942115906128, 0.21254273546377844, 0.18812144444357914, 0.5835982677625005, 0.21895037798145267, 0.19077176584032185, 0.22175901717328017, 0.33036431125520116, 0.6841086744393273, 0.693726266357227, 0.5045389234653261, 0.13198266547336113, 0.31508212895425614, 0.23099285770400846, 0.6440361869643803, 0.627698490296268, 0.6689768861280885, 0.7697505672721869, 0.7838740690165479, 0.6963372462380244, 0.6908904042983208, 0.7156894795611024, 0.4918210313890712, 0.5014373902353051, 0.7396483663560789, 0.5406094021033754, 0.1029145117211363, 0.16305103634675322, 0.12012868286383527, 0.39794141788818826, 0.37554543707704047, 0.08958682953358077, 0.11300507657070324, 0.09694125878201043, 0.24124521483712025, 0.3353795039700168, 0.21797308173258334, 0.14449797701296774, 0.3791528158724703, 0.2991663244587006, 0.4474316959130821, 0.19546033946760288, 0.3627510176352855, 0.5077163167854912, 0.8220077535422221, 0.6662130280067451, 0.6397771588119079, 0.5913997476542006, 0.6512717781649648, 0.7729913432073006, 0.7943764166090939, 0.7621485382111863, 0.6465943563429781, 0.13084762392748162, 0.11931644352079251, 0.13632654802101807, 0.1597632321245379, 0.11541379902096782, 0.14266506224630793, 0.13206255943814416, 0.12937050997461774, 0.12997969313320812, 0.15446678175253492, 0.15717452300918067, 0.26807140398054674, 0.39219102566583697, 0.27767958648284863, 0.22784697125203102, 0.22455573242512972, 0.35876948700815703, 0.1969315509470222, 0.5017702212540562, 0.5084824448759686, 0.47052992239860125, 0.5083048651928868, 0.5148461505507363, 0.5766082329829891, 0.5099835878326455, 0.5661614658936545, 0.5235725025742445, 0.3876815346262984, 0.39254363738702636, 0.33765267949651023, 0.40488930983328364, 0.5025278490026108, 0.3901353405404361, 0.47915045683555635, 0.44059714266374317, 0.32982325134928236, 0.20680809021962798, 0.20444075066759015, 0.2027765089460356, 0.1941379055666279, 0.21174892778042853, 0.20664078242412998, 0.2015490101242925, 0.23457823499185892, 0.2133390368931839, 0.2176965759566829, 0.3715349214556847, 0.45646727673698095, 0.22270127588966016, 0.21619115058656813, 0.2298697528972552, 0.21640570710770446, 0.2049189489891512, 0.4253550264703879, 0.16993943629803798, 0.813277383926067, 0.8741517072318781, 0.194124849099664, 0.8053451762979998, 0.16915850657857923, 0.16962303810017942, 0.17146098926019604, 0.17474534146740572, 0.8711234477842328, 0.7420842156169924, 0.20566577870924496, 0.16510693338905602, 0.8536486570954224, 0.2041628702073266, 0.7934335350830133, 0.15397617754144488, 0.16587393439189002, 0.19159115120912273, 0.18521257500374333, 0.21299606903368218, 0.18612958277361824, 0.18369133674669136, 0.1948307537313897, 0.1739694235467636, 0.18070062009771304, 0.19591898750382308, 0.08866425362358876, 0.08953079477002635, 0.07834938851887618, 0.09414691204659897, 0.08088390821283575, 0.0815910434361129, 0.08966128123079198, 0.08531128682048461, 0.0782415381479159]}, "mutation_prompt": null}
{"id": "88c6603c-2b59-456e-b4a7-288c45e2e92e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F\n                directional_mutation = np.random.choice([1, -1], size=self.dim)\n                mutant = np.clip(a + F_dynamic * directional_mutation * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            # Change: Adjust population size based on improvement (1 line change)\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Incorporates directional mutation strategy alongside adaptive scaling to enhance convergence.", "configspace": "", "generation": 39, "fitness": 0.3529708917491373, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8382023421224873, 0.8438384148765996, 0.8712421745206236, 0.8557536876191912, 0.8652735861284475, 0.8632713835722009, 0.866978257400431, 0.8460309075925755, 0.8566191147222508, 0.7057778986252553, 0.7499774372177336, 0.719594948148605, 0.710738904748827, 0.7216670013970257, 0.743786227019289, 0.7368780546219232, 0.7278100775646734, 0.7440961629165881, 0.5962247916715324, 0.43478058142566567, 0.34313309925829016, 0.22800615764560628, 0.3632947456825034, 0.15681548029530512, 0.5321215019674546, 0.39819155536866724, 0.22076670935990794, 0.34245160583020506, 0.13158392518685558, 0.1349017476396308, 0.13420925934766115, 0.14650842501762018, 0.15297070180751982, 0.13611844312000698, 0.13805477095568552, 0.13233859916019486, 0.9625363491573059, 0.9578849086810634, 0.9404867400496929, 0.9321688207375807, 0.8999268392063378, 0.9504016436093251, 0.9803697601141321, 0.9672682067447428, 0.9583554760301704, 0.5711108011850007, 0.39911346100897804, 0.5854533317750346, 0.5983376228755394, 0.5660838630581664, 0.6085692668190439, 0.506196742197347, 0.530855061621216, 0.5965656146929779, 0.34542041900394027, 0.6489814364184654, 0.2216899727177465, 0.844659815315904, 0.2628363032412101, 0.7394190104521925, 0.33963931134698455, 0.8113774580246652, 0.8084865104329692, 0.5876170827726566, 0.17758134913944723, 0.19008234539132296, 0.34248280875776216, 0.1680012128954299, 0.16519308684063239, 0.16663986291816268, 0.15077014550338486, 0.27987322260236547, 0.1837252903834058, 0.20524054841493844, 0.15496049791923028, 0.19121368337487976, 0.1597282078719936, 0.16834101362766274, 0.13592408556403823, 0.1583718755200738, 0.14836849481882308, 0.008776460932788721, 0.08228663501762801, 0.04830139011110457, 0.10196109694418609, 0.02184063594897523, 0.07745081389710828, 0.01941374091967496, 0.02574155402960865, 0.026405903835038602, 0.13223602678290813, 0.1263356375724476, 0.11620490316680021, 0.0974253387218369, 0.10244809671499533, 0.145668077607241, 0.11172695985343961, 0.16695161295433214, 0.16752786395079278, 0.026492809088211056, 0.08263543901020243, 0.12944016983500772, 0.08190078949029045, 0.06614797060870259, 0.17092330697435953, 0.13098229356792712, 0.11226549816345543, 0.157970401310635, 0.2809305358222626, 0.22755636493409748, 0.10393881818132344, 0.2370957806870273, 0.2506217331256244, 0.22049561724961753, 0.25629975736894384, 0.22458560422720897, 0.1688030694247329, 0.5532506564963791, 0.5773963359502928, 0.5125241584323639, 0.528137830284295, 0.5612202691276909, 0.5630366204822288, 0.6183946485511895, 0.5345979286012484, 0.5625370463888368, 0.12764550588574497, 0.08893219986584466, 0.09875177092744747, 0.12975557957256245, 0.1268556909205354, 0.1243475768133725, 0.09827250355399242, 0.1427597973800182, 0.11258150328380834, 0.13506497066886436, 0.23026860741640587, 0.2701277570990973, 0.1495957108001783, 0.414747484931975, 0.498872849868801, 0.22247048988637153, 0.17349186836157005, 0.21478180154027482, 0.49981210125133224, 0.5291236448372509, 0.4049253812825837, 0.4218101319817956, 0.6032147350233614, 0.44867433410826907, 0.5191564235020145, 0.5581421976073668, 0.5028174190394421, 0.2987013421831114, 0.34103958269725065, 0.31700188830273535, 0.2758425747521225, 0.29423653971796926, 0.3032043502812731, 0.36121668436298315, 0.32467851641540546, 0.32913286952791654, 0.20031636821650656, 0.2074162403515898, 0.2060707522471752, 0.20908072533786848, 0.18778337083377417, 0.20250221467781326, 0.2092887673649787, 0.19545366699920574, 0.18916281182835804, 0.2086457204664236, 0.21215595174886026, 0.591175426644529, 0.6959860461133933, 0.20994758159205984, 0.4669899137200094, 0.20243577239806665, 0.46440696386644, 0.30617714786084516, 0.205463969393352, 0.8077341933179764, 0.8327010042522512, 0.8459026033301609, 0.1595546217870606, 0.18187548818960908, 0.18296765000679727, 0.1625943537237361, 0.8419174281746269, 0.738983238881237, 0.1667351604845131, 0.7206491408712028, 0.20461796818172628, 0.20255925119073614, 0.20110380827107988, 0.20698501685414927, 0.31445566143128867, 0.20729451884393835, 0.19316631344238344, 0.18316644340434618, 0.18190769206176938, 0.18381265064056784, 0.183738564703948, 0.1828493923127127, 0.20782311995918146, 0.18955055770500195, 0.19119724532506943, 0.07601409915642854, 0.08100102102130657, 0.08343683827343285, 0.07970326306859354, 0.0825004339243085, 0.08597690922355283, 0.07653801801723803, 0.08399723713415919, 0.07698546860123023]}, "mutation_prompt": null}
{"id": "607a92a8-61a4-4604-8069-2adb3f128a85", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            # Change: Adjust population size based on improvement (1 line change)\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            # Change: Dynamically adjust F based on fitness variance (1 line change)\n            self.F = 0.5 + np.clip(np.std(fitness) / 100, 0.1, 0.9)\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by adjusting mutation factor F based on variance in population fitness.", "configspace": "", "generation": 40, "fitness": 0.29440961899845125, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8183011207261012, 0.8264021136732814, 0.8136638422715885, 0.8288023998629774, 0.8023221592749583, 0.77879522725962, 0.7907801063520157, 0.7940914026472652, 0.8137141815169238, 0.28244975769701897, 0.28885975566570854, 0.28341472671903245, 0.2510442284880253, 0.2611837463327148, 0.2458262956042282, 0.226055071052795, 0.22082746376482454, 0.25594920795396203, 0.10154706478580444, 0.09209463393009332, 0.11655495288441375, 0.10109237642905666, 0.10569588885156866, 0.10417838028847093, 0.09582296028568982, 0.11523381154785839, 0.09505279622526208, 0.09647745530655283, 0.08159799165801163, 0.0847103721979674, 0.09687790457086864, 0.09891196568765959, 0.09282032718618904, 0.07527476393059007, 0.0861475248171315, 0.08088116147189339, 0.9729029644165395, 0.9602247969351211, 0.9718138421669247, 0.9698737646561182, 0.9586685410211085, 0.958820444830012, 0.9600288690718025, 0.9739029330636527, 0.960756205088167, 0.20889970189083862, 0.1800700944227911, 0.17874071546611536, 0.22523754019890518, 0.1823232299155495, 0.23860506185151475, 0.21105978239582168, 0.23245800479975798, 0.22988640312043684, 0.4435977238898541, 0.4635215997796801, 0.2984687668616779, 0.26183801480379887, 0.39070165937666146, 0.5226405924476161, 0.49872329720478414, 0.5862205408092436, 0.4319257961807269, 0.11511797567518112, 0.12210465458469877, 0.11689248284995868, 0.17802989949655823, 0.08169563247332134, 0.17719259243501362, 0.11932932138963681, 0.13082159792424441, 0.16460832524404012, 0.009955236887267738, 0.0512664020503818, 0.021634661511283237, 0.10598669113164882, 0.15824554050595963, 0.134655813573757, 0.15582156678924042, 0.11616949503122709, 0.11117610381768339, 0.20071562849533098, 0.049002299887366485, 0.19196103232252137, 0.16414851371330874, 0.1439431280087654, 0.1560682821306929, 0.1477494696853957, 0.10734786602520685, 0.15955761039060345, 0.2705719379497745, 0.26979521629300496, 0.29304742902158787, 0.30232729849202256, 0.4171898735884225, 0.22924509866102005, 0.3380813338873716, 0.33409766145782904, 9.999999999998899e-05, 0.0161510081761429, 0.009010867950670187, 0.0267325283515093, 0.012117304567401677, 0.012704585957375114, 0.017184091089194387, 0.031042149024510635, 0.0004721146004615928, 0.04995190852952114, 0.141078392721534, 0.11917602505152136, 0.14932930513517384, 0.1501465777305535, 0.13777798959830945, 0.13664156382786607, 0.15402989148271917, 0.1623568155724885, 0.12992029248277615, 0.7718124267369333, 0.6014254341247084, 0.6208561629053735, 0.7185055430925994, 0.6900613854119264, 0.6925708622361089, 0.6043207626075375, 0.7767218551520101, 0.7871541397427111, 0.07103585988825689, 0.0847151358715259, 0.08586499460043229, 0.07113298867274898, 0.10156606875933472, 0.07735518508897932, 0.08563936258903726, 0.07479990657784819, 0.06163611071553732, 0.15942417726867897, 0.17370542694857083, 0.16441143725861473, 0.17844269684146352, 0.2378261733317678, 0.16117973631292737, 0.18903914941537192, 0.21382371406168477, 0.1820651525660919, 0.3905856587344535, 0.516006370612903, 0.44566674398371864, 0.5938032439710461, 0.4971812326583961, 0.49097043619558645, 0.5421507087456441, 0.5588290529700763, 0.5294867359814407, 0.2749575976100559, 0.2691009179800109, 0.2167546851924066, 0.32213542506382764, 0.2013848303079966, 0.33700578518168955, 0.3037330272938833, 0.18131393508347815, 0.3247530123250756, 0.20536174312637712, 0.22697814584325937, 0.1997006896505661, 0.18635941112254517, 0.2128802670405754, 0.2196812635865626, 0.18500997120421603, 0.17796006374669104, 0.2170267807381313, 0.1740457290752031, 0.16470641558238364, 0.16357139572527413, 0.16388026293642866, 0.1635121164408172, 0.19498481101401688, 0.16840797512324557, 0.17911373464086555, 0.17199339831997618, 0.18334675621921392, 0.20387764837528544, 0.8011905503297136, 0.17624608542464015, 0.7267823121281061, 0.8131467513727675, 0.17317803142477584, 0.18097184686825663, 0.7489936131939701, 0.8379158248339559, 0.8134886010612798, 0.803278849134426, 0.20161358559104425, 0.6597769514537145, 0.663913141842823, 0.19247253505482276, 0.20813249347288432, 0.8094238451364703, 0.18463353688353767, 0.18312545751078924, 0.17622769154203466, 0.19173752077583295, 0.17387777232841073, 0.1789418556171557, 0.20059445453937552, 0.1822617581450935, 0.17226084714236656, 0.08371637395300491, 0.06834164760347905, 0.07648909162931672, 0.07017723652108565, 0.06588418336100932, 0.06705425519291441, 0.07209864420586387, 0.08883501042302755, 0.07354240897102104]}, "mutation_prompt": null}
{"id": "8f13e523-efea-4866-8b6b-131730ef598a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) * np.std(fitness) / np.mean(fitness)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhances exploration by dynamically adjusting crossover rates based on fitness diversity to avoid premature convergence.", "configspace": "", "generation": 41, "fitness": 0.35274500294083533, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8324146568379946, 0.8227807757720993, 0.8233180589591316, 0.8213684791034914, 0.8194472260498477, 0.8314261546790457, 0.8281875208074401, 0.8538999916787926, 0.8326428964167052, 0.24026861120552412, 0.7162703201378031, 0.7530561097401275, 0.6719855984945255, 0.49083569290856466, 0.6973215231452778, 0.3845668319150709, 0.7355812227924426, 0.681603917222819, 0.6496679671138788, 0.6185098772255818, 0.6552506637254902, 0.11879249827893545, 0.109604420325072, 0.4951309540989388, 0.10016299312049237, 0.4589351725459907, 0.14164788783699134, 0.11830180010660274, 0.1026501192488356, 0.1448234871348928, 0.10500501269413087, 0.11318129065192173, 0.09296265531591685, 0.1031674966637256, 0.11942574218379509, 0.09708791464732403, 0.9461991644648627, 0.9615784978243608, 0.9475027701878748, 0.9591332961058511, 0.9559066305442838, 0.9551598318277758, 0.9634773669172265, 0.954733447121478, 0.9784768198778745, 0.2808910823297176, 0.2711007318099442, 0.41076793950735324, 0.24993237382641287, 0.2535664116036621, 0.42351044270784977, 0.23829891457545505, 0.26511186058474046, 0.42407567048287964, 0.8643968070497627, 0.20211765470619214, 0.18366937517293758, 0.8722185021112456, 0.8599916537003718, 0.845731627334217, 0.9007237447763328, 0.8823658449628116, 0.8700355799517246, 0.757958642753834, 0.16283077687956193, 0.5199667842903728, 0.12131480750167523, 0.1295509184010034, 0.1934752738219926, 0.20924743303348237, 0.5057488303301372, 0.1369178742316064, 0.15120709521669995, 0.31562819977129375, 0.13802500815863894, 0.22165213175424536, 0.1957751356184514, 0.13709774371423467, 0.6610109235081364, 0.12680288132185702, 0.2260865763219979, 0.11751404532214094, 0.14008008371079939, 0.6934853443837138, 0.7341450436731065, 0.5581795427071904, 0.7366987815202535, 0.691894067155896, 0.27711928338447134, 0.2471935410953653, 0.23156466199209058, 0.8481918312245549, 0.7967521128557619, 0.7905544271470264, 0.24644966130444979, 0.6588230917463909, 0.6594536467092952, 0.7546286803723091, 0.4604471630897229, 0.11110350165935923, 0.11878119079370442, 0.3213420771283123, 0.6250175647070536, 0.09350212246416978, 0.19540917303697658, 0.13199702185391593, 0.12276670147481095, 0.33818040911941505, 0.0525592440968945, 0.11525173525387633, 0.14440636062101553, 0.40733746177921326, 0.32549174718201845, 0.19707996375834624, 0.3255494745025882, 0.45171806264917314, 0.4434734609481169, 0.6034912248180193, 0.6121109126724387, 0.5977595057892197, 0.5231496214252531, 0.39742472883880986, 0.39084366777488755, 0.4254088330548115, 0.42615631253816455, 0.4058055311280052, 0.09640068726171791, 0.08313133861554434, 0.11647261966709122, 0.06908969850574376, 0.08322217742628368, 0.08565218826395371, 0.13938023902588081, 0.12216783429037315, 0.09311029183628217, 0.1734348131382225, 0.16502524377431493, 0.156353009365658, 0.1962639812430662, 0.18019818626782402, 0.16375191191992122, 0.1600422172230025, 0.15026609495910237, 0.15369824873390425, 0.40161420577526974, 0.43838284380428605, 0.37030749891161785, 0.21580152802387975, 0.22650757306859415, 0.22139169430938777, 0.23886838756994433, 0.19579157721089846, 0.21129859815536178, 0.35364139169875264, 0.30361641150818963, 0.4457308166783157, 0.1864084856636089, 0.15715481591697844, 0.200296266711271, 0.15141907793625686, 0.16459651357567784, 0.15557239138970658, 0.18415540766194494, 0.18730464215777587, 0.1968708780133075, 0.20530885963189838, 0.20906044355253928, 0.18840687681816837, 0.1878002632101876, 0.18042110021047042, 0.2199438752961187, 0.22221632275169323, 0.18183120602017677, 0.19134139548076667, 0.19806987828947842, 0.19651785453415682, 0.22468322603744373, 0.187840875561454, 0.19983398421599863, 0.21642235332616588, 0.23081469589312142, 0.2634420779680775, 0.2612865347883536, 0.31526710270324554, 0.29502461401429336, 0.25815279141165837, 0.35185089698676997, 0.2479713039314484, 0.3893886476237308, 0.3666112181856701, 0.2869185934606029, 0.19527339812088151, 0.17255109658131984, 0.2097555118361346, 0.1869772881730437, 0.20589871285547412, 0.20756517950713083, 0.1965847470095865, 0.1848659250225264, 0.1988619955848394, 0.1861749960687098, 0.18385957162415512, 0.1749140118910567, 0.1907942155211847, 0.19248336051505743, 0.18030366752442517, 0.182201723671382, 0.08987612188305882, 0.07958194609839175, 0.07791304591042902, 0.0820164314060794, 0.08199298662451437, 0.08249063184246097, 0.07978704868519848, 0.07191971288274124, 0.06891128927530077]}, "mutation_prompt": null}
{"id": "dd6b4b6a-04d3-494e-b037-91583906db6f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            # Change: Adjust crossover rate based on population diversity (1 line change)\n            self.CR = 0.9 - 0.5 * np.std(fitness) / np.mean(fitness)\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Incorporates a dynamic crossover rate adaptation based on population diversity to enhance exploration.", "configspace": "", "generation": 42, "fitness": 0.30574356448395684, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.7755896271251996, 0.7512955760108146, 0.7556112890658162, 0.7776862837352133, 0.7595916645397419, 0.7710047480512381, 0.779261937868662, 0.7557865195517908, 0.7928684641485142, 0.578184388253687, 0.5856347719393105, 0.5507458982781277, 0.5653989117925347, 0.5393018399928797, 0.5487528336420151, 0.5401957189842814, 0.5676100644554825, 0.5474994080320021, 0.12683893860680273, 0.09903878499299512, 0.1258404311018656, 0.1071475623340058, 0.10849903167794095, 0.11591588685210485, 0.1144335529039614, 0.12236856614417879, 0.10918839037830985, 0.09650312645907377, 0.10699051479154098, 0.10449801262428138, 0.11764841559788652, 0.10346955081193843, 0.09985243182269155, 0.11346783102668867, 0.10033539430595029, 0.10365838200538113, 0.9684867046390472, 0.9508744118251918, 0.9392379312626119, 0.9352762440572994, 0.8644958107902032, 0.8115853993085784, 0.8504507512202388, 0.8886041279124235, 0.7713013711747275, 0.2911658021568234, 0.33523043683872533, 0.22906015072852004, 0.3094938290476297, 0.31140154738819215, 0.3401760758742427, 0.3991543939551222, 0.43434092626542276, 0.36100755712633104, 0.7061388642163495, 0.7069330039278556, 0.7550217235324829, 0.7279609218713115, 0.7112693616208503, 0.7104013455606579, 0.6692644648693374, 0.6820020507531825, 0.6405859857852105, 0.16072864983798896, 0.1750540296558093, 0.20189074601395962, 0.1571440568997936, 0.19165072158843022, 0.1546741493627225, 0.29689677545274407, 0.29648968020105515, 0.3048775005008485, 0.14205679594898557, 0.14718126038246537, 0.19572387377664946, 0.1259996672807442, 0.2907991698250064, 0.2209322040582481, 0.11959589898557044, 0.12419754767281121, 0.20834281188287018, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08715773770760371, 0.09020593063953397, 0.14154344148343057, 0.049132130884227965, 0.06243064041720514, 0.03983576791374577, 0.11428084666394911, 0.057313650993976784, 0.1151348326905729, 9.999999999998899e-05, 0.019951773059862177, 0.008508274729894016, 0.0004695160576556612, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04413916780847793, 0.0003327100190677612, 0.22898900928391297, 0.25221303803046935, 0.23404478652721405, 0.24078828493758964, 0.26470777331912454, 0.2533319235648287, 0.3261533758860504, 0.2895458932733965, 0.2926672430738314, 0.6594071328795077, 0.6496759484080648, 0.6641205456377706, 0.6763893385772467, 0.6617212264574459, 0.6734822209665476, 0.668155320703967, 0.6919914903192316, 0.6855837658130772, 0.1076081003567606, 0.11072395996055073, 0.10266895372152629, 0.10947156129768099, 0.09485919395098663, 0.08999140001637229, 0.08963155387081168, 0.10423698795143388, 0.1003883810951195, 0.1489586704599778, 0.1598561060865521, 0.13594393747174494, 0.14752699406114111, 0.1493618350496243, 0.14770841448593341, 0.13046203940640877, 0.1645633911019393, 0.12673979164287685, 0.4082460695476474, 0.371190331321563, 0.40201310580053407, 0.35066909709221594, 0.39706510187714494, 0.39938347825983866, 0.3816761357635121, 0.42598084484045906, 0.4293804509360575, 0.24604900245610017, 0.2741988888078124, 0.25873267330949967, 0.31462387910791034, 0.27182465841326786, 0.3591283400251518, 0.32039662009706193, 0.30253232788764883, 0.32455740111663767, 0.2056484121592237, 0.1963442049193006, 0.18321260185705646, 0.17542938406605502, 0.1783465430302098, 0.24208888331730927, 0.19045560990597543, 0.19408795191913775, 0.20120185550120218, 0.37435766673968174, 0.22193853088739202, 0.19561474193557837, 0.19819147639413048, 0.2051674346010518, 0.19031779162739193, 0.21130224779779527, 0.18242905685636457, 0.19642960539199295, 0.7239160264867903, 0.6417023623090052, 0.7601748027475614, 0.35254650506217455, 0.32721626507410595, 0.18312666503224495, 0.6898990876582899, 0.18806590534796652, 0.6484054203566514, 0.6717524082872862, 0.20321410393074169, 0.1656102434988399, 0.19578420793661522, 0.6188021951718117, 0.20209293680936014, 0.20349848227355705, 0.19986786997030181, 0.5026745890603243, 0.20312955082511563, 0.1814193511347747, 0.17184773126928976, 0.18834529218939966, 0.18767002923951093, 0.20462686892305537, 0.18401603235048536, 0.17793047180513855, 0.1770064211501724, 0.07660435780980801, 0.07927165171783146, 0.06940159451706296, 0.08964125197467643, 0.08550758192147245, 0.07406165305153589, 0.07496068433258918, 0.07505133235623507, 0.08327809572988665]}, "mutation_prompt": null}
{"id": "4c9f0f2b-687c-48ff-9443-ef824d0686a1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2) * (1 + 0.1 * (np.std(self.successful_crs) if self.successful_crs else 0))\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            # Change: Adjust population size based on improvement (1 line change)\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces dynamic crossover probability adjustment based on past success to enhance exploration and exploitation balance.", "configspace": "", "generation": 43, "fitness": 0.406837570361965, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8660670583406727, 0.7335271201734425, 0.6785507578562764, 0.6388515938155876, 0.7771621336528911, 0.8546001850376643, 0.8055332853700949, 0.8638830485237936, 0.8582391861938801, 0.24226995319109212, 0.7535985196153365, 0.7304944019121407, 0.7485539866234645, 0.6610787188590723, 0.7341555403511417, 0.7280412301520729, 0.3511014126262315, 0.6730396699835145, 0.1442163236129863, 0.14763343498789694, 0.13405567239278737, 0.1403763984922669, 0.5211553697410263, 0.31244588059356926, 0.14535605262155005, 0.13058852932151788, 0.14327985686104805, 0.26063193718221445, 0.11270263387753743, 0.11758567034500811, 0.12289037319711626, 0.33963306057922216, 0.08786387655837136, 0.12624855687277015, 0.17424378592516132, 0.10297493782236233, 0.9480387358122191, 0.9520809100556261, 0.9571574910472614, 0.9393444034057858, 0.9289097420875448, 0.9430278470617119, 0.9533823893163973, 0.9497861511266501, 0.9560969459643824, 0.4859318901674937, 0.31981850114658417, 0.42476626329663614, 0.5492203604384605, 0.28667958266234794, 0.27356555859328513, 0.25255656000064164, 0.3403354367573824, 0.174015079674401, 0.8775885635817119, 0.8590825117313059, 0.37488524664859546, 0.8803356526462838, 0.3707132574390172, 0.8873477806139297, 0.8675214025824578, 0.8246640123519897, 0.8994781345748332, 0.7286332154397064, 0.16457782582314595, 0.13966542231892887, 0.13050143087771537, 0.13636037409906399, 0.28874622249593285, 0.18491740919274102, 0.18883705920608718, 0.18942395263318546, 0.2570769743780277, 0.12801696090358905, 0.19567062743357377, 0.13191814122848933, 0.1508704943556417, 0.20216419354504522, 0.1624974760831447, 0.1728169500883625, 0.2929598449427828, 0.6356287632791437, 0.2511053769579231, 0.7483941157015679, 0.6573042314721615, 0.6965558192265294, 0.5739614603261582, 0.6503493562351546, 0.7082023296490861, 0.18262948957801806, 0.686128826895658, 0.7891047004779242, 0.5627748236971758, 0.772526943089786, 0.45088159425483587, 0.7919160810158684, 0.8095345006148033, 0.8087824842319111, 0.7991057821479423, 0.1658457824905576, 0.21162196107162168, 0.07740454442345779, 0.6310074368771604, 0.08851399925799941, 0.25664991140285487, 0.21541610098396913, 0.3647390550463864, 0.12014225906735088, 0.5668644127758456, 0.3670604776325367, 0.5076409060863483, 0.4672191067033392, 0.3412481060001511, 0.3712108711574379, 0.3825130506879767, 0.46976321391014386, 0.6202354604702764, 0.8500564432216489, 0.8345248700325887, 0.7123253906365923, 0.7474049911063368, 0.8048035015234132, 0.8130000063720386, 0.6232348644064838, 0.7935729036645758, 0.41571892300674795, 0.159556547952304, 0.1458354903081499, 0.0990931258118195, 0.10651754672195968, 0.13782542681509258, 0.12184160651483744, 0.10995941270982434, 0.12065209156613454, 0.30739145978338944, 0.21101374298101438, 0.1573083878306738, 0.13722286888815838, 0.2115723564248969, 0.3835368144622324, 0.1331693433853356, 0.20853070581549105, 0.13032151428927286, 0.13292186968995667, 0.5442924289279972, 0.4877448186195976, 0.4078695806906325, 0.5606238093886549, 0.5054299049067648, 0.34119369492688256, 0.42596350106210223, 0.3995467028329529, 0.3918439796833818, 0.48591951771153874, 0.44747511912551907, 0.4571492675873964, 0.4245727364611944, 0.38896828080559265, 0.4262074974848523, 0.558308147266583, 0.3289971251047161, 0.41673398430581066, 0.20577277107573122, 0.19327407550663278, 0.20676773527381342, 0.1998550137784043, 0.21837993438162884, 0.2063953524031633, 0.22411978686476752, 0.21070513152233594, 0.1949252512219668, 0.2341037341857788, 0.20479175409259298, 0.6863058859047768, 0.5649551900765426, 0.23013030319285221, 0.23769455367414372, 0.42772699233156075, 0.18478226701325018, 0.2368734448394334, 0.18143119404062014, 0.1644089787584091, 0.7402755794590551, 0.17591363230677615, 0.8725618247544769, 0.1656778472633288, 0.8286916245196179, 0.8409148740681026, 0.19153472944152805, 0.16674175961916993, 0.16640649644041638, 0.6087029179152621, 0.7863376571755726, 0.16509281995087877, 0.2088934444902577, 0.2086087249536578, 0.21237140938177934, 0.19158945329412924, 0.1844754793743021, 0.19097020694142808, 0.18034015891585986, 0.19602518552709902, 0.18938014480789211, 0.20740689530377576, 0.1703256872033342, 0.1824121347063853, 0.18354283681155859, 0.07930830006705947, 0.09486855702812025, 0.07670031507332076, 0.07028700020273537, 0.08961406195715793, 0.07665345421503877, 0.1083345416572532, 0.08340046733775996, 0.07680484907885543]}, "mutation_prompt": null}
{"id": "2ac0bb20-8cd6-47f0-a790-0099bc597797", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n            fitness_variance = np.var(fitness)  # Line 1: Calculate fitness variance\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            if fitness_variance < 0.1:  # Line 2: If variance is low, exploit more\n                self.population_size = int(max(4, improvement_rate * 5 * self.dim))  # Adjust population size\n            else:  # Line 3: Otherwise, maintain exploration\n                self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces adaptive local search by combining exploration and exploitation strategies dynamically based on current fitness variance.", "configspace": "", "generation": 44, "fitness": 0.42472825931298497, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8672159723282055, 0.8012112193134666, 0.8242473484485486, 0.8462344849171597, 0.8672750675882919, 0.8575892369827743, 0.8724961343951949, 0.8511827817849897, 0.8625346493775341, 0.5742694024789133, 0.7481764304884864, 0.74032960728699, 0.7097141235806279, 0.5487174648352284, 0.7602087145039025, 0.7139291892895983, 0.757478429391961, 0.759937012899028, 0.18880140341843976, 0.44134280081056076, 0.2522922493973784, 0.2985561898393432, 0.36396469220924343, 0.16082496700747395, 0.37888714566914805, 0.4043417231249863, 0.15636839182457607, 0.17018495135597334, 0.14753712958630694, 0.13689246373172304, 0.14324344462851002, 0.14412164396357707, 0.13990853560391603, 0.1542671797464169, 0.4348975858478805, 0.13524188904201528, 0.9442704817638197, 0.9607959464349796, 0.954921707607515, 0.9645439961788689, 0.946061590752422, 0.9736828452327789, 0.9569445450243192, 0.9689519719709391, 0.9486988510302546, 0.34929264847855124, 0.29937823678091013, 0.34504633662830053, 0.44464382001683767, 0.3838741284927738, 0.4929484284436786, 0.5007679528203585, 0.27188325651534584, 0.35858106310330073, 0.8208739065690096, 0.22518545205300455, 0.8426076384412224, 0.8382085446251648, 0.8690530227591613, 0.8576541083082297, 0.7699303104631587, 0.8586344338149337, 0.8596117673699941, 0.7276595139006554, 0.1704161296861676, 0.15715843763645132, 0.18401248257015035, 0.16399994932947592, 0.1308228406319073, 0.3060244979815149, 0.1957615716325074, 0.21343252951609681, 0.31862583183708126, 0.15684455976724343, 0.1717917208975479, 0.17162926483664886, 0.21173540401312052, 0.1419847383795817, 0.3603532915922507, 0.1775150774673242, 0.2926165096439458, 0.6895620522969228, 0.7041328509756721, 0.5316348391058765, 0.6565540444616298, 0.7463882156015513, 0.5442583507489329, 0.7259564321777253, 0.32986494960390345, 0.6922121229073019, 0.7889812130243323, 0.2758382172123893, 0.7710286174592914, 0.7847221032257841, 0.5451800915158255, 0.8103854429124495, 0.4327066576373926, 0.6815438371607556, 0.784053042741659, 0.17336952570310493, 0.3445253175730909, 0.2185249221538268, 0.19721367941822954, 0.2062517309252495, 0.34899831418667926, 0.215377693134575, 0.10541098035230712, 0.16196350053612918, 0.4893634069803743, 0.2971844234035905, 0.2472641085391678, 0.436675878806693, 0.3490206722300139, 0.3589808153197074, 0.3329572573352797, 0.5153325378277003, 0.5979324521562046, 0.8093864898869789, 0.7252155807837384, 0.816299499577175, 0.8436590392014395, 0.7059185931087125, 0.8366967517860657, 0.7238647721166893, 0.6555233872369178, 0.8244727736202159, 0.11153790208672199, 0.15010700365314078, 0.14849142640766344, 0.12305309649159824, 0.13517294837516403, 0.1331525979385364, 0.1369203478545642, 0.15268441671118904, 0.14133795051413778, 0.16519798653022477, 0.23492390307418665, 0.203453874032137, 0.5089431301743546, 0.1129101235828186, 0.1612924942945625, 0.16539551679488818, 0.22253892567536837, 0.21605880013768286, 0.48879576873089436, 0.46873116073345134, 0.4257002366537016, 0.4263117850870818, 0.4833654523655808, 0.4184756102419699, 0.49890706252597183, 0.42051507260607546, 0.5285647961782949, 0.4697567158585474, 0.4620158865764109, 0.327997863326313, 0.4289448833668035, 0.4860504300062801, 0.4305410986050153, 0.5217096894577413, 0.46550149660359474, 0.3721012512087929, 0.20776847374253204, 0.18447899259327216, 0.19393470627639786, 0.20982619483756326, 0.1729481319285202, 0.20170477264268694, 0.20040265917283495, 0.23056121348051917, 0.21572544749709832, 0.23297829851374263, 0.5966136156444337, 0.19680966089649432, 0.23239519023574484, 0.41317755730625605, 0.6343820445844603, 0.48916614555266824, 0.4093226141426719, 0.21085306540360438, 0.1933612185721345, 0.19794359389556648, 0.8599566536926252, 0.17638342132279194, 0.16010628229983925, 0.797803767796622, 0.8314705386466941, 0.8109888983940354, 0.16606511383990785, 0.20482812862383482, 0.20217356733366754, 0.7319763851567908, 0.20646856479344033, 0.8488078651352043, 0.20854056377772834, 0.2086908856675177, 0.2110003408710721, 0.20729595791519362, 0.19071679901659233, 0.1762607628385675, 0.18374247666225318, 0.19797002411144016, 0.1841474553286343, 0.17952101352876748, 0.18399560263762482, 0.1861611595012258, 0.17816956042001042, 0.09357294003126648, 0.07778057400009586, 0.0787357236109345, 0.09091971213889449, 0.08405806374269631, 0.08002042619089622, 0.08386435500783829, 0.09126660070859305, 0.09009134111365913]}, "mutation_prompt": null}
{"id": "7b005849-dd7e-4bc3-9c3f-6fae605d6bbf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = np.random.choice(range(self.population_size), 3, replace=False)  # Change 1\n                a, b, c = population[idxs]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            # Change: Adjust population size based on improvement (1 line change)\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces stochastic selection of individuals for mutation to increase diversity and reduce premature convergence.", "configspace": "", "generation": 45, "fitness": 0.42257458859525815, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8368314129391552, 0.8276731000426713, 0.8382649980632806, 0.8579490771376003, 0.8654304437185434, 0.7239159785523701, 0.7534439907890536, 0.8473042698824447, 0.8709941824971209, 0.7323168390923146, 0.7031314131812543, 0.7355001068938949, 0.7463477201007478, 0.7452229306550692, 0.7071680252498292, 0.6966407645443476, 0.41426882036090684, 0.732666594325045, 0.5112723834494941, 0.20668022502102557, 0.17979734888923127, 0.15530235387089908, 0.15547347465043893, 0.12362290350681981, 0.2893168379999308, 0.32547222384820307, 0.34150253271319575, 0.1603879746521497, 0.1393131507443972, 0.13271013298684498, 0.14814719419032407, 0.22140565049542116, 0.14804851026337107, 0.14282327981482323, 0.18245578076316382, 0.14537069252056245, 0.9398410133468529, 0.9476439026743839, 0.9378968339101376, 0.9175994152722589, 0.9420483256535508, 0.9642710786653584, 0.9611122539557677, 0.9505622379677496, 0.9359696451588746, 0.3827858576150599, 0.39093783116098857, 0.2778582803107714, 0.26648282416843405, 0.2933720062280769, 0.37062027233050243, 0.30398897703941874, 0.29623077226359706, 0.413355996055658, 0.8557588089123654, 0.8358756374615351, 0.8383997785296742, 0.8938652617637963, 0.8577020132588574, 0.8356945633787478, 0.8715332151014947, 0.8232443053286737, 0.8446332501820007, 0.18591694912559165, 0.20034591483749364, 0.19577406407265352, 0.12196603605992129, 0.23806394502502026, 0.2547272208537241, 0.21596481677960755, 0.7472750823676203, 0.2024527378330564, 0.20236914839836606, 0.19056807465402748, 0.18530919944969315, 0.16349793834103565, 0.3617839121042703, 0.690637625720022, 0.1350418104476987, 0.5975209069827676, 0.28129281059445777, 0.4524137428168783, 0.7170959770277483, 0.3584215818095873, 0.6990596998887502, 0.6966202071479004, 0.6310358930584314, 0.7393699138554581, 0.7098932679384433, 0.7153348103640732, 0.5041862580789087, 0.7639136811509573, 0.7474104598544064, 0.7896451120428646, 0.7767235875187071, 0.5993712640024982, 0.6958081026782864, 0.7672466178612206, 0.6970578421712844, 0.14482709759167045, 0.09569580796862343, 0.11238671219254848, 0.20164469345529734, 0.17650774613032882, 0.3371664182084686, 0.2248220878768198, 0.23537036011015222, 0.2505863009373558, 0.5837287736230135, 0.1499800856382686, 0.3491744669939877, 0.5671269216058332, 0.2544813343223591, 0.392617527679862, 0.403897991198672, 0.6242078235983418, 0.6128537950445228, 0.8178721908167605, 0.7560899335979046, 0.6998023256670634, 0.49126339824355303, 0.7149287225094392, 0.8099666825728962, 0.7989449458451807, 0.807742691961014, 0.800938725348155, 0.11108914013196558, 0.09834417839116338, 0.12903343127391487, 0.11391340757966262, 0.09477706014193954, 0.1260230486394308, 0.12250705760403757, 0.08849473642987671, 0.17364493682511262, 0.15687381613454032, 0.15959820445317596, 0.20368254049535495, 0.27073846707510774, 0.21249408848266016, 0.30753284369085543, 0.1597111676778339, 0.2200880475326844, 0.2970049983046884, 0.4192071864104482, 0.4828057154168959, 0.4169095414698698, 0.49180724907338313, 0.45427277902083874, 0.4134876267594746, 0.3854498103208467, 0.5170720001521871, 0.4960103997269134, 0.3088474937847744, 0.43729089184671155, 0.3879955374472327, 0.4195829935662664, 0.49865039748035733, 0.29574817606198966, 0.4065021348385891, 0.4951279163533503, 0.48409899843124393, 0.1782367947869179, 0.19113951495115167, 0.20705048652790436, 0.21048729613768868, 0.22325562576568225, 0.19289189079881164, 0.18702979796523322, 0.19851066749807145, 0.19508516358479688, 0.22879235768887973, 0.46829229695766506, 0.23046844854140702, 0.27537451774222743, 0.22039674306233836, 0.4851148212209635, 0.2350039887119164, 0.233724346045055, 0.20355083367994098, 0.1965838154016828, 0.15079891434695725, 0.8584574833530932, 0.19372594012325228, 0.7046113350810705, 0.16591224390158332, 0.8196404122310295, 0.8325202069459446, 0.20860557430087312, 0.2037744209611343, 0.8287897045793746, 0.2097889344137589, 0.7660075819186222, 0.5335957000402674, 0.20777571447669296, 0.20820443671406352, 0.20670168794631139, 0.20996031587812924, 0.18495004446567387, 0.17474185002878317, 0.18264604615024782, 0.1790241067094599, 0.18888434123611786, 0.174343932064704, 0.1974719247845872, 0.18687511939778712, 0.18001657490975598, 0.08489228187224507, 0.07941734343311546, 0.0838829755814593, 0.0871250753727536, 0.08777314974748429, 0.08509659095824207, 0.09539396855812576, 0.07862180648907047, 0.07947652175823328]}, "mutation_prompt": null}
{"id": "3be1cf9b-092e-427e-a145-d0d1f8e1e182", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                candidates = np.random.choice(idxs, 3, replace=False)  # Change: using tournament selection\n                a, b, c = population[candidates]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            diversity = np.std(fitness) / np.mean(fitness)  # Change: calculate diversity\n            self.population_size = int(max(4, (0.5 + 0.5 * diversity) * 10 * self.dim))  # Change: use diversity\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "AdaptiveDifferentialEvolution with enhanced diversity preservation via tournament selection and fitness diversity measure.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 53 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 53 is out of bounds for axis 0 with size 50')", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {}, "mutation_prompt": null}
{"id": "1e5195d3-e62f-40d9-a2d6-a02a4b6d4953", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            # Change: Adjust CR based on success rate of changes (1 line change)\n            self.CR = 0.9 * (1 - improvement_rate) + 0.1 * improvement_rate\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces dynamic adjustment of crossover rate based on past successes to enhance exploration.", "configspace": "", "generation": 47, "fitness": 0.29836788692636634, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8350944498762312, 0.8289906823911054, 0.8401053420991133, 0.8286526055382339, 0.8337912631105252, 0.8288730440249787, 0.82703372597191, 0.8353898759231264, 0.8595974568742586, 0.7040410115140856, 0.68327374624006, 0.6754002610809945, 0.7237532721700249, 0.6649388213991692, 0.6849206753570124, 0.6897738401143911, 0.683675360589741, 0.6797598394748727, 0.5090174558908196, 0.5384167969822677, 0.4554636557694426, 0.4863554875168795, 0.5965742536487866, 0.587881316935349, 0.5539781396473524, 0.5393164057664233, 0.5238378514871102, 0.47206202927969454, 0.3515935586163186, 0.44319969585815566, 0.452935144691214, 0.46688951971930737, 0.3807995791078136, 0.48189702167218285, 0.42269560900285397, 0.17023074296529994, 0.9398301376617246, 0.9625746747690943, 0.9563538522195696, 0.9593586423284856, 0.9531004945939412, 0.9530293079976936, 0.9440845880488299, 0.9681630811682924, 0.9542619297098843, 0.3591667187901768, 0.303045859376766, 0.3390942557845682, 0.3719381212366799, 0.32513421911307094, 0.32020574385814893, 0.27577444210729685, 0.28151855503263545, 0.28517895799794435, 0.24248140086719894, 0.27841372935002195, 0.27661383582611865, 0.4851254285866273, 0.31942843066118887, 0.24719492022884437, 0.30746591213799823, 0.2981843217486092, 0.6248045419665584, 0.2043708520301789, 0.1808358260488221, 0.1847335721658787, 0.1830956047549076, 0.15612876387563068, 0.15479639406474266, 0.15470173650629526, 0.17253633366293575, 0.15682076419184343, 0.15816455870150348, 0.13102383645718907, 0.1615739664558209, 0.13993743263055058, 0.18043012232228428, 0.17104040522456576, 0.16465234130603568, 0.14188437271253884, 0.15345785741985363, 0.011408643794319717, 0.004905337997337833, 9.999999999998899e-05, 0.0074287873160042706, 0.04293806306621484, 9.999999999998899e-05, 0.0036450866470939536, 0.023468380067967365, 0.022935308355540807, 0.10949529887367004, 0.10876991624782872, 0.08487950206851436, 0.09994507265331554, 0.06111006796945406, 0.06570548082401817, 0.1360386161486633, 0.09886568264142825, 0.14813172356082616, 0.009355329865920026, 9.999999999998899e-05, 0.0010525526687124032, 0.00332016640285715, 0.003354674240970801, 9.999999999998899e-05, 0.020552399449377257, 0.015242571103478486, 0.006069794170709741, 0.11556569597991784, 0.07474842305763252, 0.11812333758738791, 0.1459139320230799, 0.12225938103249023, 0.14288198631105864, 0.12858228368089808, 0.13099870554130488, 0.1159631379298457, 0.5045737928637233, 0.48842279000581734, 0.49086218046523955, 0.5150821021935286, 0.5036354310735924, 0.5145150330112362, 0.5156327647761949, 0.4920116054762862, 0.49037273369416934, 0.104955550952894, 0.11876179979568802, 0.10739355453305921, 0.09628062728486897, 0.09808823557518065, 0.0958905298603806, 0.10580977623452748, 0.11686758002695985, 0.11123968953927654, 0.18649465973823165, 0.15689813974445954, 0.13217989518981088, 0.15144740380532307, 0.14189905521348134, 0.1340541267940909, 0.1455099249876255, 0.14378958503689665, 0.14156477386221855, 0.3191537363571232, 0.3369065238630016, 0.3036801943716443, 0.30481083292182054, 0.24713161622639834, 0.27890546034749464, 0.3307964173235787, 0.36426409871384935, 0.37670294080971267, 0.21812993996510865, 0.2037790153680299, 0.206707097711756, 0.23221745640169245, 0.16838888616283165, 0.19642705578771769, 0.22755278660460643, 0.21180284999598797, 0.21482494393899054, 0.2113164704539069, 0.20188916391871137, 0.1911347344185541, 0.19181696689160566, 0.18922770306050474, 0.21885969289360796, 0.20436157122755705, 0.19889647265875277, 0.2040919360652651, 0.25584735041627316, 0.29459437483784334, 0.3207945034576901, 0.20938213808567052, 0.26009371877364007, 0.3401148720222775, 0.29196841509532956, 0.24729031121621747, 0.22871018425607437, 0.17923921177122704, 0.17616627199728396, 0.20903923255418633, 0.3068988537278897, 0.4355101550239576, 0.16588601187030705, 0.23485115927929823, 0.39218457767441295, 0.2251124997209869, 0.2355780261672854, 0.16951530476357823, 0.19409939587059966, 0.19740162000652484, 0.2503837685302588, 0.1986463907541165, 0.33337663731182643, 0.2630464131297573, 0.25399306622516793, 0.18892597381611453, 0.182491027259033, 0.1770964465754914, 0.1849226014696026, 0.170684977617372, 0.18859428915635024, 0.18605684950046175, 0.18962569382753347, 0.17728410865725241, 0.0786204901138593, 0.0864172040808695, 0.08628619455529174, 0.10429706239063397, 0.08512591134512637, 0.07964506602177335, 0.07870522494151988, 0.07979560970508304, 0.08917875304302147]}, "mutation_prompt": null}
{"id": "e5200292-6f3b-4809-967a-d52026a70aa7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.3, 1.7) if self.adaptive_scaling else self.F  # Change 1\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)  # Change 2\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 12 * self.dim))  # Change 3\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.2 * (1 - np.exp(-np.std(self.successful_crs)))  # Change 4\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Integrates adaptive mutation scaling and crossover probability guided by recent improvements to enhance convergence and exploration balance.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {}, "mutation_prompt": null}
{"id": "a32ea3fd-7d5b-40e5-a455-dee2bd3f17d9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n        self.memory_size = 5  # New memory parameter\n        self.memory = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F\n                \n                # Enhanced mutation strategy with memory\n                if self.memory:\n                    memory_choice = self.memory[np.random.randint(len(self.memory))]\n                    mutant = np.clip(memory_choice + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n                    # Update memory with successful trials\n                    if len(self.memory) < self.memory_size:\n                        self.memory.append(trial)\n                    else:\n                        self.memory[np.random.randint(self.memory_size)] = trial\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Integrates memory-enhanced mutation strategies and adaptive crossover probabilities to boost exploration and exploitation.", "configspace": "", "generation": 49, "fitness": 0.3854190889957137, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8445201374008595, 0.49437191565861616, 0.8331433256674166, 0.8733892976696673, 0.8218819512073295, 0.5171224739827467, 0.7316575878477014, 0.8787199127976875, 0.8670999170938158, 0.7749913303670277, 0.700924019187064, 0.7732434610477824, 0.7265596621431976, 0.7370712997820372, 0.7305764681295197, 0.7728697583266955, 0.769670625772223, 0.7886685431360625, 0.2836635756099466, 0.33087298118898145, 0.47753718459226013, 0.32631575320953565, 0.12585873791090196, 0.5235263030724774, 0.13759400034016944, 0.3915466712359925, 0.4449085321959473, 0.0924636252232296, 0.10627282235470625, 0.10203172127528759, 0.13710095692279778, 0.16893598533930998, 0.1286337105284734, 0.13018108261507388, 0.14561252963922655, 0.10403683748065085, 0.9027967640882006, 0.9847359527350953, 0.9871528169200754, 0.9643355943642827, 0.9488028604274638, 0.9596338743535964, 0.9600662271792132, 0.9699839837391627, 0.9353590989365277, 0.381186935855681, 0.4548779581264837, 0.4731792017816052, 0.34379723166456644, 0.4582238109817768, 0.40788320754308316, 0.2941858330598415, 0.38808116418152916, 0.3751325874727053, 0.830546759376821, 0.8992833523917108, 0.9145882767749632, 0.8923306596704542, 0.8795651439710761, 0.8928144517378318, 0.8793989171920611, 0.22962891359596738, 0.8678788416156457, 0.18146406092619838, 0.1970418316560023, 0.12841273963358713, 0.3223718945119919, 0.18994383762759937, 0.24592380049073703, 0.2654221536777901, 0.24551157319943673, 0.16835410218922497, 0.22254722248053072, 0.1421059760867196, 0.19218870689889744, 0.18221922152306314, 0.4376621520427202, 0.13454893436416038, 0.18909651695375662, 0.25227000126391586, 0.17028498403833525, 0.3808275992905693, 0.18712142292484513, 0.11039901121675355, 0.38586707523514685, 0.493173141849531, 9.999999999998899e-05, 0.014984292034292634, 0.6140715276574148, 0.682344129848196, 0.3814108517751932, 0.4414314563767251, 0.15168035958589843, 0.7570045466697269, 0.8084593971312377, 0.4741013907099608, 0.7740710134153835, 0.36395555023969894, 0.39022202908776327, 0.34149840736294446, 0.031023836751903566, 0.049107069689029226, 0.2963246377105394, 0.07743255407699434, 0.1216443144662166, 0.10821731139996427, 0.20602972387618512, 0.2072145821706356, 0.22413043007537647, 0.2785572210118107, 0.3101162770958441, 0.22696142863237767, 0.2834045136884532, 0.4316990771360567, 0.505406060343421, 0.2620619056841641, 0.2803690308853961, 0.7131127275268268, 0.6080884884494149, 0.7592624080612529, 0.8541481450926653, 0.7087120094558159, 0.6150699185772113, 0.8302804739354867, 0.7513411756017957, 0.7278579447067701, 0.11131219133919312, 0.10340224968708522, 0.12590476605404965, 0.1378950949005564, 0.11310185133688977, 0.11115689941998586, 0.14611934288005957, 0.10848989944750342, 0.13295609787435492, 0.18009197725340875, 0.1595237026318116, 0.4192202440026567, 0.15211534188449483, 0.20373566734748405, 0.14947408387093186, 0.19659335666366817, 0.25735813762855, 0.1380099167563914, 0.46513876603064397, 0.45360130603586923, 0.3593247629302515, 0.46513604408005205, 0.5181367625075959, 0.49595241794766065, 0.4757176618046077, 0.4318704643707518, 0.5583244934931291, 0.47496421280056644, 0.33631052723240606, 0.38972511567133206, 0.3575228091885624, 0.3924054152425389, 0.3834175369447357, 0.3934238138731626, 0.3694851664969774, 0.35472765547767127, 0.1941290034482629, 0.19222563383785174, 0.20581345474521717, 0.2025587762705523, 0.22689360966579786, 0.17970347850758772, 0.18243157768387486, 0.21802054886427424, 0.22697685715393445, 0.2365771808912679, 0.18882811746668882, 0.2464693662322407, 0.23916930513298518, 0.23327789745927796, 0.1952031810585656, 0.7854718757815098, 0.24037911015092772, 0.2350030002080412, 0.1678676516849582, 0.8830878673697897, 0.15218968002987077, 0.13112503312223311, 0.8596085010663848, 0.8649661910126388, 0.1711378420888261, 0.12128947460521666, 0.1407843022986648, 0.16668711077045517, 0.16485079523035107, 0.20623365038338992, 0.2074962163043269, 0.881587255418105, 0.1685780242465058, 0.2129230724697423, 0.11231281142804528, 0.744111452973143, 0.19262714568607675, 0.1980341893971378, 0.19175564935196465, 0.1839703157168311, 0.18929246917462983, 0.19009844008722399, 0.2074807404195187, 0.18083318581972485, 0.1852443164127251, 0.0800069355343187, 0.09704890200992156, 0.08184995490092495, 0.07957987424964053, 0.08424583955976772, 0.08573711095587044, 0.0847559365315359, 0.08894118533826079, 0.0847150759915849]}, "mutation_prompt": null}
{"id": "a2d296c2-309c-4423-ad34-8af3e7e26099", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n            \n            if self.population_size < 5:  # Change: Introduce random population when size is small\n                new_population = np.clip(np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim)), self.lower_bound, self.upper_bound)\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhances exploration by introducing random offspring generation when population size is small.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 18 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 18 is out of bounds for axis 0 with size 4')", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {}, "mutation_prompt": null}
{"id": "c1d1dbae-4561-471d-9224-813dd7be93c7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            # Change: Adjust crossover rate based on recent successful improvements\n            self.CR = np.mean(self.successful_crs) * (1 + 0.1 * improvement_rate)\n            \n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces a dynamic crossover rate adjustment based on recent fitness improvements to enhance exploration.", "configspace": "", "generation": 51, "fitness": 0.28202207523072353, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8373947358983516, 0.8362388217569962, 0.8249756481129344, 0.8225095850938111, 0.8228417222800252, 0.8380293041533408, 0.8239173648600243, 0.8354778133165457, 0.8300474365238879, 0.6909549576123872, 0.6710919091233853, 0.6713933536406425, 0.6907947959812628, 0.6804506670028803, 0.6876012244606724, 0.6706793711094676, 0.672094600841346, 0.6634757193286167, 0.604810189375065, 0.6158027392122961, 0.6372920521258498, 0.578785302089759, 0.6581699268772805, 0.6070837811293524, 0.6483721251315507, 0.6179512284401147, 0.62053692470348, 0.5833456406122258, 0.5538860166087329, 0.5389611244728105, 0.5948757366740793, 0.5802263775420585, 0.6236033163141175, 0.5822153536595881, 0.5911408568758943, 0.5283307852542086, 0.9527883233055389, 0.9634905322275001, 0.9529818505745764, 0.9503767466398652, 0.9691325984374161, 0.9592032544429963, 0.9584267374158671, 0.9494185977199815, 0.9531009514140073, 0.18563837898825486, 0.17601781129880023, 0.16454351016372493, 0.19078216477295196, 0.21744457559736996, 0.1611639515979283, 0.15873612589919395, 0.16119838920632878, 0.13335244368519938, 0.16984340209013227, 0.17707213953719492, 0.13534378194131202, 0.26118029895059236, 0.21681710617980665, 0.2426737203527668, 0.1919270962565287, 0.17631035789432148, 0.20467264105112615, 0.19581893440783804, 0.1449334130343608, 0.18435754961636797, 0.18737365566602826, 0.17573189002334488, 0.18720610731319787, 0.2667120740608139, 0.23490205128397978, 0.19781266123958774, 0.13901750531931434, 0.13578143133912568, 0.14302653828423262, 0.17561396691273623, 0.14747466131123566, 0.14456742658023303, 0.13402547046195756, 0.1180703932567354, 0.11957928664952855, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07999086876126749, 0.10363124960987591, 0.0854740773884285, 0.07601576355068462, 0.0708871125102527, 0.07334591532245505, 0.06622834759972684, 0.07628760436433002, 0.1352594141157828, 9.999999999998899e-05, 9.999999999998899e-05, 0.006866827043137125, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02453504301716347, 0.0010100439946734152, 0.0001825384813287645, 0.09290949854966979, 0.07069075641515132, 0.08576289783761826, 0.08278979789552654, 0.10360601663776392, 0.09665819021561861, 0.0825452282352539, 0.07642939096608026, 0.10229962272095239, 0.4400618638365148, 0.42946056360775087, 0.40831743520692865, 0.3975451024244496, 0.4306115847611318, 0.4229799239411296, 0.45174452908503726, 0.4135435189836122, 0.42114146903034655, 0.10082979279959559, 0.09890825793019598, 0.10984478052378222, 0.10104882717535768, 0.08604420730690432, 0.08886250303803933, 0.09248844317465788, 0.07612256438395704, 0.10129048246932293, 0.1785422362569994, 0.19968706171389206, 0.1511610269830519, 0.2222455385459694, 0.14824162925540518, 0.14363056634533, 0.17982957587338788, 0.15009794179155056, 0.17286244851515453, 0.182784555009477, 0.24111073789594273, 0.20419069447901161, 0.230657628579515, 0.20106351523347632, 0.22497979153318748, 0.21684007213659529, 0.21885036135885194, 0.2307994811701134, 0.1620512230184462, 0.16026883453672236, 0.1629578469443591, 0.17117355009117308, 0.16998636737419615, 0.1785389573078774, 0.17162204661529346, 0.1554718108098263, 0.14800478460928557, 0.20829406257249816, 0.19178808413655057, 0.21626926111005074, 0.19514644128457026, 0.2010002481857991, 0.1924040546930499, 0.1786955327468338, 0.21858126950944057, 0.2080150303623547, 0.22311849976956388, 0.26676937455490624, 0.29612950915818137, 0.21733174480801343, 0.22193684346676779, 0.2543780163902718, 0.26726703866080426, 0.22600108955775766, 0.2869055440169229, 0.17288032760206518, 0.2357643888109785, 0.2439169099918539, 0.2218842056870749, 0.2500662063831829, 0.3119245860939637, 0.15744510553381297, 0.30071375548691537, 0.286945876055124, 0.19792699825741178, 0.1987840536998886, 0.19212010045277428, 0.18249768712253212, 0.17914642965003114, 0.1762851771234003, 0.2623243419268151, 0.23985042997625905, 0.1404150862736938, 0.18003640202189797, 0.18599616438247146, 0.20098538837404745, 0.17738541812117603, 0.1865574492031543, 0.17922715241351617, 0.1828990161118873, 0.18595417989539254, 0.17783769485512602, 0.07600248811667898, 0.08186296468539878, 0.07912080740402339, 0.0808926931832673, 0.08390446795828443, 0.07511847713468855, 0.08000638892797374, 0.0726523322873438, 0.06510210215535228]}, "mutation_prompt": null}
{"id": "138cb47d-8312-40c8-8baa-dd0ac629b69f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.5, 1.5)  # Changed line\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.2 * (1 - np.exp(-np.std(self.successful_crs)))  # Changed line\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces adaptive control of crossover probability and differential weight based on recent success rates to improve convergence efficiency.", "configspace": "", "generation": 52, "fitness": 0.4058830697152384, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.857188716249923, 0.7431124517423234, 0.8297932766013041, 0.8394083721209167, 0.6914331047442827, 0.8522916307154674, 0.8548085464877643, 0.8655490535292837, 0.7668490066825198, 0.7486422026923072, 0.5250566849651219, 0.7187680571999382, 0.5106530172433443, 0.7422233147114272, 0.7356241860469986, 0.6115734022190171, 0.6628460067471191, 0.5188851220276985, 0.3289552968643754, 0.4108573904677735, 0.4368877755555919, 0.3211194010029309, 0.14302262406513833, 0.13614130667037405, 0.40614563551164573, 0.5209836652725672, 0.4874593211399588, 0.29383900506221616, 0.3368849589119308, 0.12993465622883726, 0.45618419782806807, 0.4259443523866848, 0.16836200672241708, 0.2264247622795218, 0.2890438717560634, 0.4271055467301603, 0.9699894982711542, 0.9711967158944238, 0.9589736605004237, 0.9043217686405463, 0.9741061738264997, 0.9444279870426956, 0.9617163361840257, 0.9725867471991555, 0.9301545525916971, 0.3444343366319126, 0.23259435427197428, 0.18196143977661772, 0.2758492655824112, 0.35186057335768406, 0.3656991898044817, 0.25677103750237984, 0.3540256002891574, 0.2466836568089077, 0.8742840145115907, 0.8380175667567991, 0.880134580206108, 0.875263285070756, 0.8713601849881707, 0.8476491134101278, 0.8597236290645855, 0.34157302619620866, 0.8737875074222828, 0.6644159340578598, 0.3146208416215335, 0.1513492889938277, 0.19958131400757861, 0.14473077255924816, 0.19620134872183181, 0.16954110845562376, 0.1726823421135567, 0.6725820616063662, 0.18786032171186995, 0.3321338238256284, 0.06483658171806206, 0.17477726974985452, 0.15875531915259944, 0.18214668654120025, 0.19104143069262203, 0.15392264607399297, 0.18091420629278798, 0.7373724515011029, 0.4775636608648307, 0.6784366239321848, 0.6426115900044398, 0.7369065075882764, 0.7373161334433443, 0.7443684425191908, 0.6435722412529925, 0.574423778266008, 0.6947764918689803, 0.7885114005277828, 0.2044361389613727, 0.8087949027205708, 0.7768583407771832, 0.28218281724707484, 0.2416917888972313, 0.7395980845328912, 0.795323715832649, 0.1738257556095577, 0.1303474130643617, 0.2231423163088473, 0.4359719297479224, 0.49389804367806767, 0.24758209398495623, 0.23014184675565852, 0.1685210699524512, 0.14473490305829195, 0.5698710090820781, 0.2616382846759884, 0.3931421084840523, 0.3389117580815795, 0.6396475608689856, 0.41714296210085866, 0.31866760032000185, 0.629722270620579, 0.37719948908912937, 0.824953211529355, 0.4933594182614599, 0.6814106831862952, 0.8307698971953612, 0.5765719720297854, 0.6020757834382583, 0.638743852556112, 0.7279681924830426, 0.7793385240966683, 0.1166797909848194, 0.11126948807176307, 0.12533363966728084, 0.15604247849575203, 0.12625918434301253, 0.1360050942870994, 0.09816006017298406, 0.09427455481892044, 0.14919816733375535, 0.1343060724323537, 0.17262825768898604, 0.14634893840054952, 0.125362537688108, 0.13727076207533517, 0.17982589750728872, 0.1562616241066146, 0.21195018019898104, 0.3071443418690908, 0.5065257448028102, 0.41999238741619715, 0.4521505963846223, 0.43851620842803196, 0.5008050110731233, 0.5181161539471406, 0.39209058425255927, 0.5573075379755116, 0.4258117523785413, 0.4727165972239422, 0.37620704729201815, 0.3200085871162893, 0.4152503909443461, 0.2620251169908797, 0.415512929155616, 0.37793039223746383, 0.4807667230228182, 0.35631690313387, 0.2050488220776101, 0.18528570942266298, 0.24150951648727936, 0.21137339566274727, 0.21624356286402835, 0.20314067765868982, 0.20388952362403434, 0.1911091773741581, 0.21236453686799017, 0.33133175651682345, 0.40956846768180843, 0.2103623652875406, 0.20560945077417925, 0.30488494505549835, 0.23130918911756393, 0.1847824360357443, 0.19539563738520038, 0.2618109883450319, 0.18537105680388566, 0.1951930483465213, 0.19558530919454542, 0.18545629969784072, 0.8784427748010093, 0.16289920026142335, 0.1853030629424104, 0.16736320935136006, 0.186835255997563, 0.20728896035858346, 0.2078227866528175, 0.6444749424557679, 0.20392969459680088, 0.3312425187545506, 0.20635716768201517, 0.6294839978560443, 0.20553995470529218, 0.21103916511944165, 0.18542114557226874, 0.18547852053592762, 0.20003950949044225, 0.17832717930080966, 0.19832614680182692, 0.18477352214607312, 0.1806013740591108, 0.17801933902820855, 0.18592121736521783, 0.08096859634687714, 0.0822767401902984, 0.08062370454078449, 0.07557539320451179, 0.08138299874674026, 0.09206618585633664, 0.08525047024657129, 0.08991503127964029, 0.1134695981652547]}, "mutation_prompt": null}
{"id": "4792ad60-24fb-47ce-986e-555e8a8293d6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            # Change: Adjust population size based on improvement (1 line change)\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            # Change: Adapt mutation factor based on improvement rate (1 line change)\n            self.F = max(0.4, min(0.9, self.F * (1 + (improvement_rate - 0.5) * 0.1)))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces a dynamic adaptation mechanism that adjusts mutation factor based on fitness improvement ratio.", "configspace": "", "generation": 53, "fitness": 0.4138389813054032, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.7916485114761034, 0.7895341151456927, 0.7522190070191522, 0.7756433999405102, 0.7565416220898482, 0.7851807709848964, 0.7936009497117897, 0.7914172737640316, 0.7924572028811294, 0.6044434743513836, 0.6024705911946071, 0.6102398980595393, 0.5830301330395483, 0.605028471508029, 0.6316077441765737, 0.5961172981821157, 0.5981248012397797, 0.6313105167307639, 0.13540523222944267, 0.27546771301739414, 0.16980848667161785, 0.3050518717455628, 0.2178705635735647, 0.2506953414357739, 0.20072793279094292, 0.2550734883157395, 0.13979083113644553, 0.20808650571818932, 0.12620855697909428, 0.13847488394645646, 0.1380908922721572, 0.1265557310689963, 0.13387989863033256, 0.13719996997064832, 0.1308897163126298, 0.17462073907285436, 0.9574096503495109, 0.9807984231120587, 0.9475691778875474, 0.9627224082843294, 0.9359466684261017, 0.9834813313147177, 0.9700136938855111, 0.964628382848229, 0.9646942168425048, 0.48557781728483806, 0.46713204023262944, 0.41538291033152785, 0.4744689056216881, 0.4180713857149706, 0.42748516407980675, 0.4910927138018174, 0.49766558216617884, 0.4963904567453348, 0.7461253720789206, 0.8220782963664947, 0.37011639058291723, 0.7984283118326825, 0.8108038095000488, 0.7392995271912772, 0.755864450381717, 0.7697529787925422, 0.7939411438837874, 0.41841872971494554, 0.45574796291320685, 0.5012192051255071, 0.48597750427763986, 0.5099100867561546, 0.5140955563769594, 0.5301061662325663, 0.5174176856148242, 0.49136983152305, 0.38061279341818977, 0.35146004176806056, 0.5907651118904906, 0.38885043031276023, 0.5710443228020041, 0.5205836165689921, 0.39953352193046954, 0.4585626711816412, 0.33451459675723916, 0.5370418811433972, 0.4916131762449403, 0.5385635194735148, 0.5291706380210961, 0.5242255010539123, 0.5768888185486898, 0.571765585093136, 0.534509581899911, 0.5892447334798769, 0.6502730498266942, 0.6899959686705068, 0.6818825585871643, 0.69117539656775, 0.6784331549887657, 0.6492176284364763, 0.6463223639537388, 0.7093185917254307, 0.7049899583365515, 0.19049541711987483, 0.16928714407724332, 0.3334967898270461, 0.19795250284409271, 0.2668554173237744, 0.42938419399410466, 0.2264725909331522, 0.2595823494498454, 0.1493508009194795, 0.34396271674173795, 0.39953310663675834, 0.358303954482063, 0.3883319538062563, 0.39626484622782643, 0.3884149073682619, 0.42381196638401264, 0.39573299738328527, 0.4147398141926939, 0.7085078793300946, 0.7141935236477042, 0.7299736039893947, 0.7632524410377334, 0.7342088581349169, 0.7517352442741576, 0.7207945084833238, 0.6840978032888299, 0.7607460973777775, 0.10697576386765051, 0.1288235501039824, 0.12899065929014653, 0.12222253891029045, 0.09754300101568625, 0.1191113423226905, 0.1259826724215649, 0.11763136825850362, 0.1151802581029222, 0.22011522456405141, 0.3045545036398237, 0.14534438728036425, 0.28441045958964983, 0.14650680138148287, 0.1586230672231762, 0.3210615121622009, 0.19487440544171586, 0.2706016597404648, 0.3745576566973513, 0.43514333109655345, 0.3904208629639594, 0.41762626756784405, 0.4214242087675164, 0.3751476106381235, 0.4028218784944202, 0.40494192533962947, 0.3898443774319311, 0.33252868524867596, 0.3443681400990678, 0.33557102834127206, 0.38286858091450215, 0.39187980265419065, 0.3332954642295807, 0.3545756526669819, 0.33381517029477703, 0.31151010225618947, 0.18857688385347204, 0.22738766754297057, 0.22023480685791252, 0.20394335279857612, 0.1911257256759159, 0.19679933157286678, 0.19577964571172035, 0.18128851888596575, 0.20070997870543583, 0.5037483863134831, 0.19542923802881673, 0.21398428113461754, 0.39911344710103236, 0.44298461249280585, 0.2735222142010407, 0.2101441320605617, 0.1836169975304942, 0.17969560370267101, 0.18385055735361333, 0.18262021352922753, 0.8386853411828826, 0.8319497995180692, 0.7580243311465151, 0.16205636129504497, 0.1915258577999236, 0.16649550967489157, 0.7258465728429739, 0.20436235953519688, 0.2022467235104709, 0.16412339637189743, 0.2009791279124713, 0.1931072971268296, 0.2089425203598455, 0.2073130347490596, 0.2117176532589896, 0.20914302185412226, 0.17719629035587536, 0.19868662217248068, 0.16754011799602286, 0.17667341084341914, 0.19617256508808312, 0.18032698360390675, 0.17815175421660445, 0.17006373807671882, 0.1821291032472504, 0.08372277434638253, 0.08450167676938858, 0.07354821362479691, 0.0865374886199275, 0.07703854555993417, 0.08370306215222933, 0.08914747355712438, 0.08844525643498746, 0.08790574467590306]}, "mutation_prompt": null}
{"id": "98f557c7-3a3d-449d-b6ca-a5cea30ef5a9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            # Change: Hybrid strategy with local search (5 lines change)\n            if np.random.rand() < 0.3:  # Add a probability to trigger local search\n                best_index = np.argmin(fitness)\n                local_best = population[best_index] + np.random.normal(0, 0.1, self.dim)\n                local_best = np.clip(local_best, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_best)\n                evals += 1\n                if local_fitness < fitness[best_index]:\n                    population[best_index] = local_best\n                    fitness[best_index] = local_fitness\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Employs a hybrid strategy of differential evolution combined with local search to enhance precision and convergence speed.", "configspace": "", "generation": 54, "fitness": 0.4059464617174872, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8375254106486352, 0.8797547957919113, 0.8284304672025574, 0.8180287511943132, 0.840271628842338, 0.8576651595417282, 0.8384777559357843, 0.85179968928878, 0.6667941231737655, 0.7304293028841786, 0.7221744300355173, 0.7452322834234788, 0.5975996792173812, 0.4758718979741058, 0.7396409250592366, 0.731313901095308, 0.7222516916126265, 0.7224411507150745, 0.10486131875304561, 0.23120930794731942, 0.4580201444644222, 0.1566875818623068, 0.2997428526526643, 0.21762021179426339, 0.2804132417506018, 0.15624370320416414, 0.15796376479928875, 0.1418032358241368, 0.15558982428848744, 0.1470265645969524, 0.14607910015704306, 0.1384202097613212, 0.1031984207673804, 0.13223832679017034, 0.1435702136575714, 0.4117692709232845, 0.9602187761474534, 0.9578977730964909, 0.918557501398678, 0.9614007063440843, 0.9515505379838517, 0.9232274732996093, 0.9722719769363045, 0.9520058723603843, 0.9362809986899812, 0.22509292858391305, 0.3154481137841709, 0.37358846321163575, 0.40944920584577515, 0.36713813295670705, 0.36798473030357925, 0.5298790667043729, 0.4343233796661047, 0.2854800204977882, 0.897004496899731, 0.8378879759711408, 0.8467688238746187, 0.8631860992398978, 0.8870756436549105, 0.8454298223500433, 0.8695475165973745, 0.8441449971832218, 0.860903559226825, 0.20834164616918494, 0.12666132437663147, 0.2015037391374057, 0.13269749350268534, 0.22521958605121362, 0.21425086776664293, 0.2013201855675214, 0.18201156889478698, 0.15749405921619286, 0.18655906457741345, 0.12032023568847561, 0.12981086506746198, 0.26801933680095613, 0.22734513242364984, 0.15454086631960728, 0.17685527583457383, 0.31361130022041883, 0.16064484300641202, 0.7125646945000506, 0.6768230333425524, 0.6751912454697833, 0.6827277999352266, 0.6051243753684872, 0.40453291128774427, 0.6000919835738324, 0.6737041354261848, 0.7159721635291554, 0.246429497558036, 0.7738345086530861, 0.7761499989372552, 0.77744090069246, 0.5532656029373866, 0.5070417540979635, 0.4358513591252249, 0.7564507014022213, 0.7885913263936113, 0.1925731208590451, 0.11262689150148886, 0.12130667538649509, 0.31447755125921417, 0.21675956901631066, 0.4824781181747432, 0.1755007072382303, 0.13709453232824031, 0.15422250565809914, 0.22215389088899296, 0.21043318435509828, 0.49272059961364667, 0.3495228735431972, 0.5019968533267878, 0.3861518776754005, 0.40164519131806053, 0.4611656159860682, 0.3127451094119543, 0.8401603915319211, 0.8458835478351722, 0.6030366961766115, 0.6345018511183953, 0.7494805268388267, 0.8396300050136583, 0.8337094872584092, 0.819877788698218, 0.8474642169086438, 0.12657367364557393, 0.12666415259194275, 0.10570509428917463, 0.10630813210293377, 0.14435650687047696, 0.10404348297601829, 0.11161478830200955, 0.13023753106325842, 0.13077835616833522, 0.20840639014175832, 0.18646788846073437, 0.32310185728480467, 0.18155892712935606, 0.27338848277425876, 0.19506075362295516, 0.23390616023618993, 0.15373898567047994, 0.16138299306467707, 0.4513703777614758, 0.4083536872097524, 0.4029591867954536, 0.3899056042908654, 0.44339572886368883, 0.5041189564430592, 0.4609986927159977, 0.5429938355088705, 0.46591052016103685, 0.350545549895253, 0.3924706368167089, 0.3198529870265089, 0.510759109726869, 0.2987285009216476, 0.3666351417686493, 0.4153741293019301, 0.536480255481123, 0.3977202944362461, 0.21098238959168414, 0.20248005803304792, 0.1912011250735003, 0.19666870861833552, 0.189559942044072, 0.28408105899741176, 0.19710449750822456, 0.266805140954369, 0.21030569877692795, 0.19760401740221467, 0.6261974230854497, 0.23830771892266067, 0.2057897571285866, 0.21231566354314813, 0.649629370466372, 0.20911034969698405, 0.22676439335232834, 0.21237119307319063, 0.1831003188279956, 0.17397924773608153, 0.18528329611111505, 0.8333866299811382, 0.19102013390156525, 0.8476745754471033, 0.4192063550101809, 0.7817241568647799, 0.16546831302590348, 0.2071660183755083, 0.8262701890674549, 0.16543153842281044, 0.20206661684207516, 0.1646482656710212, 0.20853669133761554, 0.11249923681816831, 0.2105150948001191, 0.20672553593060738, 0.18436821975578543, 0.19385733281041306, 0.18242514873451532, 0.17456558825273427, 0.1803545355506394, 0.1962941977039725, 0.18070752511045307, 0.1864900124147726, 0.18943862585450966, 0.08618069819043994, 0.08278572598440148, 0.08819902696061166, 0.07539838085753892, 0.08715974579512986, 0.07707261938883836, 0.08939853861708202, 0.09104882292828664, 0.07462322189508452]}, "mutation_prompt": null}
{"id": "c7e7d991-d803-4a7f-8597-60a09cb7297d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n            # Adjust mutation factor based on recent successes\n            self.F = 0.5 + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Implements adaptive mutation control for improved exploration by adjusting the mutation factor based on recent successful mutations.", "configspace": "", "generation": 55, "fitness": 0.054094626499886764, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.10498664819051917, 0.12911435602172971, 0.09715242135613866, 0.09302859347508197, 0.1284753746681072, 0.09798231664729595, 0.1206541530420554, 0.10311241681838967, 0.12623832864468054, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.008062046924192656, 0.0060732342980797105, 0.011745461675660374, 0.024554026638096915, 0.022914869616898814, 0.010015031318484247, 0.03321818000368293, 0.016839097369443334, 0.007048025686722248, 0.007920069396445961, 0.0, 0.0, 0.013711909195099348, 0.002498660231119887, 0.014934094019302235, 0.0020563355067588773, 0.0, 0.005225842567389782, 0.06326960434001816, 0.05256727228615621, 0.03402382839968521, 0.06546153607585437, 0.054773452528473876, 0.05848898369912803, 0.06436248074740725, 0.06422062946585683, 0.06240308752236001, 0.01882409664833118, 0.06822942951773914, 0.0, 0.08564969716949544, 0.02056386829587209, 0.010220613553522329, 0.0751925106351482, 0.0, 0.07018415740473682, 0.03790438358476911, 0.04369253167478271, 0.05151297303538793, 0.16065743199639837, 0.060843012983847644, 0.0841215959166155, 0.1419759672091816, 0.05590497870760225, 0.03201071922316645, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.035256277288254756, 0.0, 0.0, 0.0, 0.028140406697056863, 0.0182913255013053, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1580835853885577, 0.1253949986472508, 0.13518689456119715, 0.16431783563337177, 0.13449049126940515, 0.15776284486469372, 0.13088887563807783, 0.13722932475260896, 0.1877867566974213, 0.01800587121679076, 0.01650119555300167, 0.022249737829323046, 0.028477346047462326, 0.03291411710842529, 0.02580645883114996, 0.017421913825560242, 0.0319253270941523, 0.012499647793134172, 0.09416433208598118, 0.06760068615316539, 0.08712666362674504, 0.10802370968617647, 0.09110084186503187, 0.11110630226555951, 0.08386299093082361, 0.08943346615737169, 0.08932436217624096, 0.1219410654990456, 0.1479328130396379, 0.11878605408950549, 0.1342918714158755, 0.13172450866783092, 0.12668696515919398, 0.12047802845723798, 0.12004211310777624, 0.1549912302057681, 0.07273196232349544, 0.08584046078228291, 0.06159390393777908, 0.07102561649993933, 0.08223680343728501, 0.07108657739623869, 0.07043657537271142, 0.059507895164821134, 0.0973766779672014, 0.12278968875990393, 0.1085998946554586, 0.1548912458968147, 0.11774975457123382, 0.10494182933385332, 0.12167266817472921, 0.10631764542462752, 0.10039435926806894, 0.16639795756662812, 0.12321075265492887, 0.01632674102373277, 0.1302409651009746, 0.0, 0.0, 0.14130860852033622, 0.0, 0.0, 0.013355389324708478, 0.07829204971469061, 0.0702482000425767, 0.148185170937442, 0.10191196647468181, 0.07058699378982236, 0.06906428619150251, 0.13086151805366153, 0.09262475358642974, 0.08752656896690336, 0.10348976236560536, 0.053576012409006446, 0.07046968305409651, 0.07368811918216356, 0.06340623128916012, 0.07245264175350208, 0.06500266067152227, 0.0700121675519988, 0.05389269078101311, 0.15270791113913618, 0.15701593260295865, 0.13636208595514943, 0.15638337545919168, 0.15526974252236814, 0.15937302885966487, 0.15385253661324694, 0.14702439409968193, 0.14842410325252453, 0.03659089957605943, 0.019549908647171654, 0.039698592365936536, 0.023284058282163955, 0.014444691113936647, 0.025386803197729346, 0.057209478075131326, 0.037452299044529735, 0.04721446043534683]}, "mutation_prompt": null}
{"id": "dcd30825-4168-4962-9152-0dde7e90e530", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n        self.adaptive_crossover = True  # Change 1: Enable adaptive crossover\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                if self.adaptive_crossover:  # Change 2: Adjust crossover rate dynamically\n                    dynamic_CR = min(max(0.1, self.CR + 0.1 * (np.median(self.successful_crs) - self.CR)), 0.9)\n                else:\n                    dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                \n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces a feedback mechanism to dynamically adjust crossover rate based on recent success for enhanced exploration-exploitation balance.", "configspace": "", "generation": 56, "fitness": 0.3512214200758538, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8670840569241163, 0.856192078900002, 0.8691890936393335, 0.8464287171508438, 0.8607421476508826, 0.8396561703853277, 0.8474833788170774, 0.8636766669577189, 0.8475858972237476, 0.7325378252156289, 0.7190447684595418, 0.7011094610023849, 0.7308327125948666, 0.7273272348760634, 0.7297818918158241, 0.7169240574316397, 0.718907049646358, 0.7249270138705908, 0.41812812104923314, 0.46796021404570143, 0.4937340417566033, 0.28691174303864486, 0.3922929665840502, 0.4557634392072585, 0.4179701755776264, 0.5141043471169656, 0.4704912346002851, 0.16938196238221248, 0.15085227799988676, 0.3925225204759273, 0.2839043247663372, 0.16644805359464843, 0.15975983583002196, 0.35685549865042643, 0.3141677553326555, 0.2553533868735124, 0.9309391971665676, 0.9542917980748912, 0.944767635116439, 0.9485329495514724, 0.9573095325524474, 0.9602250667979639, 0.9301260900045956, 0.9600386888718357, 0.9536150447732769, 0.4020373148523272, 0.4311552959430013, 0.4046125466661269, 0.43851775936161097, 0.4877329521724384, 0.4329738285017588, 0.41925491265570136, 0.44010036531285623, 0.3981251884817645, 0.7706173498126087, 0.6781718467181743, 0.6724425075395964, 0.7877632157730892, 0.6464593226411506, 0.7376268499474098, 0.8004540629371827, 0.6834567852231379, 0.8149828516300242, 0.24225623714547206, 0.17152936461216506, 0.1645084943727878, 0.16181185612801952, 0.16827481373087827, 0.30446554865117426, 0.17403931766672232, 0.17668076645656106, 0.1702147788895223, 0.17016115703998602, 0.10011372614310898, 0.14894797121036885, 0.18376822787459346, 0.20571346795751067, 0.15733126003208175, 0.18408880682579554, 0.18884510585393677, 0.17497068225730017, 0.17995274623021051, 0.08769739807685328, 0.12703096551800774, 0.08152010128393139, 0.06772028533455965, 0.10654762340000945, 0.10428395893728903, 0.08049093438302768, 0.11947465956116321, 0.22419133433916472, 0.22860379479908088, 0.24555458732165503, 0.22099818111532754, 0.15073333884680118, 0.13860580554552215, 0.25931418057369826, 0.22646326935210237, 0.33400557059906566, 0.05875311032637143, 0.016187084258373008, 0.008286029405724316, 0.07573853497946748, 0.046812584412270875, 0.036987356800379345, 0.043787412550530425, 0.09671425219177088, 0.0642661834985584, 0.19030719336162139, 0.1798030245975275, 0.2027779380601813, 0.23102274602518635, 0.19876183920619728, 0.21105549518141986, 0.1292458284634609, 0.2016674645367128, 0.17826858925935052, 0.566053498869528, 0.539894186948706, 0.5703079239006157, 0.5439253133667705, 0.5338174186399459, 0.5272746654730132, 0.5524550193081731, 0.5592255567789722, 0.5371185755916759, 0.12106499380142355, 0.11782280279209756, 0.10486495738543089, 0.11093126178564594, 0.08951999263816035, 0.11797939521771783, 0.10746489703536988, 0.09586382417286643, 0.09355669245891118, 0.18681223649264045, 0.13398390758581025, 0.16327136997188152, 0.17813521335348648, 0.14354201027309044, 0.15079362355894266, 0.23850440701136544, 0.13959259836530924, 0.18393933466349577, 0.41986031887875197, 0.37138241417598006, 0.352345155041801, 0.38761611045587274, 0.38657257508740883, 0.42460649531834715, 0.4834375128102415, 0.42033302637055125, 0.4507292758105296, 0.2521325814769678, 0.2582989293305361, 0.2861703415326837, 0.30672721299071803, 0.27765120231343055, 0.2783195527642415, 0.298946760565059, 0.3369214619318084, 0.29016639606960093, 0.21564623980793762, 0.18812121225213707, 0.2002665397355654, 0.18586948603296627, 0.19419185644206338, 0.18420257724030642, 0.19958548975133794, 0.19624383279321256, 0.18597212879155645, 0.5128430637323175, 0.20193142387929486, 0.5302472023701389, 0.19944203823003626, 0.42236194942349314, 0.2861555060679196, 0.2281695358309247, 0.20548707650606557, 0.37777085631413354, 0.7269890889023922, 0.6513176648151326, 0.8077813555720575, 0.8085860561127322, 0.8207055569871732, 0.16299437803815509, 0.6838280210578134, 0.5182201399201356, 0.18285026634000212, 0.16483349710279271, 0.20417137329118973, 0.2063027579492298, 0.20484907805094876, 0.22961520377943256, 0.20348040950460677, 0.21163481862343547, 0.3238961644816126, 0.16227443614839265, 0.1906879342380321, 0.1853486242145176, 0.19344751318250408, 0.21148669016517363, 0.17956012306893787, 0.1926332343694206, 0.18617852018673875, 0.19521816027613492, 0.1815417287788288, 0.07954934843657957, 0.08073103958905792, 0.07881336757734914, 0.07553703887108565, 0.08312568993292913, 0.08418725411998662, 0.07822537949082287, 0.08000443135637048, 0.07506331058177806]}, "mutation_prompt": null}
{"id": "b3c92aee-f4dd-478d-b364-4777c9d40840", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 1.6) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            # Change: Dynamic crossover probability based on success rate\n            self.CR = np.mean(self.successful_crs) + 0.3 * (np.sum(np.array(self.successful_crs) < np.mean(self.successful_crs)) / len(self.successful_crs))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduces dynamic crossover probability adjustment based on recent success rates to boost exploration-exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.2564035592453544, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.7575949140154641, 0.7767286779536853, 0.7640207759898493, 0.7779138277024696, 0.7687890594659821, 0.7761169261352604, 0.7572248210289555, 0.7610930255806754, 0.7784650439535135, 0.5481878662984072, 0.5459454296971814, 0.540782906095246, 0.5408164866041729, 0.5813616041243139, 0.5705230830647792, 0.5339194923368802, 0.541251207879819, 0.5305165153034208, 0.4950865824535694, 0.4835482845193001, 0.4850757452619019, 0.5007043918512913, 0.4796695404103851, 0.49679654332262524, 0.47910796911262143, 0.4880244563163516, 0.5007364726891819, 0.4180364966335506, 0.1634562901932104, 0.43557929140794127, 0.4125797933496227, 0.41365589563448124, 0.39789748010031945, 0.35900588345525775, 0.40188117249045585, 0.4294941682132237, 0.9334415607796078, 0.9505706790063932, 0.9260609636073035, 0.9487924430399217, 0.9294454546573161, 0.9273409573558224, 0.9529921753648707, 0.9573455920312305, 0.9292456976236253, 0.15958205432353822, 0.17232472062139537, 0.10462290085497916, 0.17244179934520976, 0.1584447378080751, 0.12978457735811844, 0.17087915289324496, 0.1511506639274367, 0.1413493658198799, 0.1488345648376761, 0.16548330345155082, 0.14877284590390394, 0.27335020894371054, 0.24221646017148613, 0.24806838692742372, 0.24322120225744315, 0.20793617439254297, 0.19876427770787763, 0.19071446470948616, 0.15884243841436796, 0.1485906229848084, 0.14472708101903176, 0.1653699618520479, 0.1855146143742441, 0.18821272842021786, 0.1628871815707147, 0.1902426073195641, 0.11410343183890037, 0.12035500430190604, 0.12159893489582918, 0.13873518385686257, 0.12261550005486299, 0.14653112815116331, 0.12104853882492062, 0.1243737597950727, 0.11403553267975297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06765960843222929, 0.06695366312197981, 0.08291663425167028, 0.0914266328592559, 0.06875309769136362, 0.06376624880222448, 0.08661256739942669, 0.10187428749106453, 0.05015972037670835, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02474078565311777, 9.999999999998899e-05, 0.0018398767420987339, 9.999999999998899e-05, 9.999999999998899e-05, 0.06520080436147258, 0.07023016294187878, 0.08337849208646952, 0.07752927979341162, 0.0859154773543398, 0.10007147048499643, 0.10289992977621076, 0.08394845487260139, 0.07886958430153757, 0.3967462290852585, 0.41776061784018015, 0.4206802577468469, 0.3961467729909325, 0.39622897759524156, 0.38181902785320476, 0.44246819247318847, 0.40119873638434933, 0.3994999532768767, 0.08787878760166368, 0.09883782656708195, 0.10595494978361752, 0.08435913630994474, 0.08445379270882292, 0.08881355871589514, 0.10526747515674029, 0.10277265725108553, 0.09048391598345829, 0.16206446567371569, 0.13871147732318734, 0.1720199233771995, 0.16196466537218035, 0.12984657699914226, 0.15402753456492924, 0.19103308941072117, 0.16111300405135331, 0.13682043094547558, 0.19994579399587775, 0.21212001111439716, 0.2227315390178588, 0.223921048526178, 0.2198587613683699, 0.23927163711630406, 0.2105043749693597, 0.22689313985905157, 0.23486501556342265, 0.17747680019739398, 0.16493303431430906, 0.16340381441241625, 0.16171387281531857, 0.16762925946578033, 0.16160763548421286, 0.15923669030739274, 0.147621574094551, 0.1775739854351912, 0.19941569555278815, 0.17987781538530512, 0.20513671150145185, 0.19153669491579206, 0.20844348598086948, 0.21605437905736546, 0.20222134228384603, 0.19158554069712308, 0.20146402215303827, 0.25425089879992224, 0.21502125720301324, 0.2122861047940453, 0.27239543213320117, 0.21760968432661343, 0.2540848373283713, 0.26401551786295163, 0.21915312732646064, 0.24831700764482667, 0.17890015427840789, 0.2859266937218, 0.21403179574898568, 0.25196669461727716, 0.3306778498223767, 0.16689933170682836, 0.2997592214298158, 0.24299456422407306, 0.22113749566766627, 0.28132508431848424, 0.2212584246324465, 0.18529701208853866, 0.20056299932675314, 0.22498900809150657, 0.18710770402845323, 0.26568605601569983, 0.29084830566156206, 0.17766618515719146, 0.18909579074687177, 0.17713309798640808, 0.17097873875045266, 0.17462497016405631, 0.18614323852289094, 0.19376685705716523, 0.1831817302342622, 0.18158048793507453, 0.17923483221451264, 0.08717846419111919, 0.08564487009890054, 0.0674136326684136, 0.07959948688032203, 0.07317544782456575, 0.07549980534720802, 0.07075637259432221, 0.06941907551021687, 0.0796612061705031]}, "mutation_prompt": null}
{"id": "0c6cc095-4151-401e-90bf-13019e8061ef", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.4) if self.adaptive_scaling else self.F  # Change: Narrow the F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Slightly reduce CR scaling\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate adaptive mutation factor scaling based on recent successful trials to enhance exploration capabilities.", "configspace": "", "generation": 58, "fitness": 0.4310129054507153, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "f35bcece-28bc-44c0-942a-e6ce3b4c577b", "metadata": {"aucs": [0.8452823219361726, 0.8576084350999591, 0.8425886779968265, 0.8573130687301961, 0.858164169838608, 0.8548689922308543, 0.8626020219890868, 0.8641674910134002, 0.8569615880681999, 0.744937230172996, 0.731159013157525, 0.7255921518328349, 0.7363126339933268, 0.7457071581823697, 0.7560652445776215, 0.7298212846406267, 0.7445025867795266, 0.728326796109867, 0.15788485792915286, 0.31613932965715696, 0.48836022218302055, 0.44053422859290126, 0.5715794727949206, 0.3622290724510817, 0.18969395332566086, 0.3362670168516678, 0.2581526384396381, 0.31793343381558703, 0.12490154578136992, 0.1384340417327512, 0.13454511039665706, 0.3020901261087786, 0.27967885063298503, 0.11717435196180226, 0.1394680450977268, 0.22901645581120944, 0.9506759997111536, 0.9410475077847859, 0.9541500542795451, 0.9562752702826872, 0.9390367905035929, 0.9711956101258236, 0.9313239398123149, 0.9325473835338342, 0.9479315152390544, 0.5491582825915424, 0.3315607136038642, 0.34192097841998637, 0.581704330803015, 0.48890371378821096, 0.5393115917382632, 0.6590026443926537, 0.5212605619154441, 0.5052137961474186, 0.8841254234345467, 0.8726425842617822, 0.842616879853336, 0.8684370501182169, 0.8446672717557203, 0.790130848672884, 0.8696455883358278, 0.8616113853116211, 0.833291137699912, 0.1663619577560307, 0.19197668454141126, 0.12802516223431248, 0.20214076474100628, 0.21333924172564545, 0.27611989746497445, 0.16591861975235167, 0.17369550684693402, 0.18192979829965616, 0.24457239128166397, 0.18727617359315196, 0.07095173229486551, 0.20759450693689552, 0.2312308278348899, 0.15614911686919097, 0.23807104338233598, 0.16529866576790886, 0.17604812251392976, 0.692287268595425, 0.722190462576626, 0.6941870386232535, 0.39910290526130066, 0.7217690999834423, 0.7302661482679496, 0.5060012562644229, 0.72684711987965, 0.6217927498593753, 0.6984214109393724, 0.746939080234891, 0.7666145592211063, 0.7496038163489891, 0.582290400068072, 0.22220164023249156, 0.8015235051913587, 0.748118681585233, 0.5248922184140625, 0.3275916807193322, 0.250766141105774, 0.33909877058900706, 0.46607417848932886, 0.4006589024174525, 0.19189433360297936, 0.17853576788825753, 0.18885809364800243, 0.33127285504418647, 0.5791256820628917, 0.5879798883284395, 0.4975241138116093, 0.39192345234256987, 0.6651701590738905, 0.424737430791602, 0.3809657825404812, 0.3598637220945877, 0.6089311321097318, 0.8087917954248742, 0.7479900999893108, 0.7343110987895278, 0.8184904484151966, 0.8180769209863921, 0.7460178815889582, 0.8170461726416085, 0.7941837181967408, 0.7603819564051953, 0.12723032739608986, 0.10525499480218437, 0.11845612568040176, 0.0974967509104896, 0.12578449557010496, 0.10807891269204006, 0.1117525501096015, 0.1320287634535915, 0.12801359634012022, 0.15661334886966238, 0.16812044644597446, 0.13070468647038191, 0.12303017909474934, 0.1956793428977085, 0.14950405277340706, 0.14151404122354594, 0.2085368312267175, 0.14754698829216817, 0.40655683986104296, 0.5931753783421481, 0.6099698898983923, 0.46609390629951586, 0.5056359089948665, 0.5178279226483551, 0.5711596920771932, 0.5273330727578293, 0.6129896867693521, 0.4832124909805411, 0.4872325951282378, 0.4939330813145182, 0.34087451519260636, 0.4107195017346845, 0.4457143152669055, 0.49037011137726527, 0.4224711206561719, 0.377102521019519, 0.19877322418297938, 0.18630027431138574, 0.20254965041359807, 0.21714989931200313, 0.17844820059950195, 0.2143243486736749, 0.19178136373691845, 0.21064256104076262, 0.1925644972565288, 0.1826879758700054, 0.20077518866077815, 0.564508177564879, 0.20816296727382577, 0.1965432637905441, 0.21500371093453818, 0.39695401794333385, 0.22915463342065823, 0.2103036935454332, 0.19946585021097563, 0.16223679252755463, 0.18275671584607334, 0.1750828866685311, 0.8544136117030715, 0.2046463934095083, 0.3520422527807541, 0.7924586482868077, 0.2025950252015487, 0.8651616403356656, 0.20810851863511814, 0.1655701105094306, 0.1532820587321163, 0.15927817675833245, 0.7259346243366513, 0.20808890661418344, 0.2078434080692494, 0.20762634252780277, 0.1726598897701449, 0.18121065778717582, 0.1792312590631303, 0.1713442554975405, 0.17830571216091118, 0.20038440114606504, 0.18636087114136057, 0.1937120767798941, 0.18533383844188245, 0.0990541375382471, 0.07985151388541978, 0.08292934256447482, 0.08840269766163944, 0.09371420928877616, 0.08894121353040751, 0.09041472716896992, 0.07860691236588879, 0.08392703679655622]}, "mutation_prompt": null}
{"id": "be58a56e-1b62-4eb3-9157-7f4ffb89f221", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n        self.decay_factor = 0.99  # New: Introduce decay factor\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.4) * self.decay_factor if self.adaptive_scaling else self.F  # Change: Apply decay factor\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n            self.decay_factor *= 0.99  # New: Update decay factor to gradually reduce scaling\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Slightly reduce CR scaling\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a decay factor for adaptive scaling of the mutation rate to balance exploration and exploitation.", "configspace": "", "generation": 59, "fitness": 0.27362453223236727, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0c6cc095-4151-401e-90bf-13019e8061ef", "metadata": {"aucs": [0.613162348935913, 0.4884747341443164, 0.5347132804881771, 0.7145971161572524, 0.5400817982010835, 0.5316556498710597, 0.5860555807661812, 0.824098996933472, 0.7820721200514973, 0.41666680848178916, 0.22529798010673663, 0.7068331570602397, 0.1589383623145708, 0.17780736722656, 0.3802283128611551, 0.2749777231993694, 0.3170991524533098, 0.09169453344424161, 0.39766672215323395, 0.16979727854692994, 0.1710172504531724, 0.17747056106329406, 0.1377408737831538, 0.1528937330290171, 0.17223905649898041, 0.2397929759903057, 0.1682848248887412, 0.15108368085708257, 0.16501243866715343, 0.1694410701591189, 0.15129239899814606, 0.10623221135374694, 0.13718928807895814, 0.16813076065415622, 0.1509454114958848, 0.1496025073002727, 0.9340722048704934, 0.9489787229177655, 0.9420154672509721, 0.9120717486709621, 0.9314323633967226, 0.9535975873147973, 0.9633246027205286, 0.9090990730878519, 0.9336951771210706, 0.2137893343433812, 0.17276667182356265, 0.19899682790368511, 0.3013181787207382, 0.17953915733441284, 0.15328163751435298, 0.2301212777670869, 0.1095260820763404, 0.24107299499851975, 0.874013772300285, 0.38485609349402494, 0.21341728888701683, 0.3552771015150835, 0.3266907686070053, 0.35574799208760466, 0.23124031431946745, 0.36550305541881145, 0.3589573864041642, 0.13876701343772524, 0.14733709995107713, 0.14165092381824418, 0.13036868624733433, 0.12728282642747724, 0.12820853634611817, 0.14701724559375418, 0.1603022778673301, 0.13377307058494903, 0.12911242529501743, 0.12732996633487015, 0.12981562995361073, 0.3553630797854618, 0.18807707603639334, 0.13337520647045964, 0.12761017408157516, 0.21191481366588782, 0.20247766201475603, 0.11702068467828908, 0.047690146581991555, 0.09860162094054081, 0.040592086807067274, 0.16967770062579168, 0.03702872096676979, 0.14951381428802957, 0.14788965933701126, 0.22695596822944553, 0.1993519973694009, 0.2788093300384509, 0.17868216377996438, 0.2468787950239043, 0.31542647041900596, 0.18377074575341779, 0.29517951650615537, 0.26059430501604475, 0.3668983395943596, 0.04767283687486579, 0.13606085689517344, 9.999999999998899e-05, 0.1109600519247751, 0.09282905400315289, 0.035628636552469506, 0.027668178146522227, 0.14878835468317997, 0.15790448973401305, 0.11453010539782338, 0.12022047063760255, 0.19116526853997962, 0.1564628469909607, 0.2468148048848937, 0.13259634238545093, 0.16870886967024967, 0.11393414883578212, 0.13147281888072504, 0.6715982373671587, 0.3760775451709597, 0.47349757774332735, 0.49670706516681584, 0.3929675192653064, 0.46604748257438666, 0.4121495957226703, 0.5499552415034195, 0.4714133380737199, 0.13064395870152057, 0.13180470444791792, 0.1418621214743302, 0.1124734881573457, 0.13761899680396805, 0.14042839963205445, 0.16933886489028305, 0.1459076934478668, 0.13227717415644524, 0.2365957762678177, 0.17057110581138824, 0.1669920815917998, 0.14678516352330284, 0.16896229986051725, 0.2314485719275845, 0.1651628562219597, 0.1758990673207036, 0.2359363348628094, 0.3305452743163756, 0.365903725342816, 0.3667925695018547, 0.29402322135751524, 0.3718503086163045, 0.36318302716178164, 0.43626632831262124, 0.23687312821617335, 0.30560044965832045, 0.29691272153399695, 0.3329142471920038, 0.3072068339273807, 0.32213803893353754, 0.30055983923654617, 0.2384054874764946, 0.23454754209444317, 0.2780099498209274, 0.2792144390943039, 0.22984656595102548, 0.20379563182095384, 0.1996559927416527, 0.2539976444279005, 0.23992204260635686, 0.2214955461472914, 0.2064858692105368, 0.22635188473639123, 0.23486738799681406, 0.209098924219822, 0.2035203105544059, 0.20377158159753794, 0.4968963730254726, 0.18852365050882325, 0.19673843424572557, 0.2053310926666193, 0.2043187037952191, 0.21763247411940234, 0.1794432715217965, 0.48860325026953444, 0.9045502465683605, 0.17491111733911024, 0.5711555202374228, 0.47754403946528723, 0.38601884456883395, 0.20207359367712274, 0.16490069842638, 0.3096863532404124, 0.20706380113245337, 0.1919481855210171, 0.6177467392666973, 0.16346987371849386, 0.19901055002643453, 0.20978972998973655, 0.21008005164802412, 0.20935539342444054, 0.18811778106689492, 0.19190149818237756, 0.20085456136914415, 0.1786270349547756, 0.20773004159682618, 0.20368840117257137, 0.19759500235646443, 0.19414595722332728, 0.20462292992049202, 0.09622507441662242, 0.0969755865162315, 0.07588366817416392, 0.09809786747378779, 0.09354819932856917, 0.09769822169782805, 0.10830384699380702, 0.10421305394575087, 0.09444460746713235]}, "mutation_prompt": null}
{"id": "b3ff3c47-1682-439a-b197-e121837c203a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) if self.adaptive_scaling else self.F  # Change: Narrow the F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)  # Change: Narrow the dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive scaling and crossover probability adjustments for more stable convergence.", "configspace": "", "generation": 60, "fitness": 0.43867989535759977, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "0c6cc095-4151-401e-90bf-13019e8061ef", "metadata": {"aucs": [0.8516924626284668, 0.8553255824029803, 0.8445108193242861, 0.8495370255006602, 0.8637846290114998, 0.8633517144763769, 0.8621206471426364, 0.8407803741208595, 0.8552160307568415, 0.7412945186293858, 0.7336989268545309, 0.7391422219178443, 0.7110938237261917, 0.7326164345335908, 0.7438381894818976, 0.751421535335772, 0.7445809476274332, 0.753457382433847, 0.48760473716371644, 0.17119612681929997, 0.32736920535061187, 0.26267570042114674, 0.28872273725625364, 0.16716527101046863, 0.17742026363477725, 0.1675644811396545, 0.12627227566978705, 0.2505055145012831, 0.12314876069939418, 0.1388154378381643, 0.14426739577729242, 0.19539931534413313, 0.3271274868608488, 0.15822393819060476, 0.1421111768398885, 0.12484451464404844, 0.9279922967953158, 0.9530053458391867, 0.9473624780251928, 0.9158075272436508, 0.9502666595621736, 0.9583798446757559, 0.9647869469944356, 0.973296297303242, 0.9230238900909667, 0.4957147088376751, 0.4345548267048206, 0.5370223974707804, 0.373161932653468, 0.4079371533670746, 0.3339072880776731, 0.3290234297707165, 0.5053126225717807, 0.6388544152275742, 0.8543724545599978, 0.8196973712817176, 0.16996204226556888, 0.8484155782450324, 0.8485755699024915, 0.8637031905034193, 0.845192772920937, 0.8504260728062147, 0.8189513270963708, 0.19792752715556994, 0.18562130369033225, 0.239791530607825, 0.17061188444057585, 0.16415727426713833, 0.19052465353652537, 0.2247022418508453, 0.20262686987844858, 0.2618786324079587, 0.4108529384313322, 0.44095843126063894, 0.059814153743596554, 0.20433838350740108, 0.21507818585274985, 0.14801399073425614, 0.18985829303679747, 0.19401514142679, 0.35267445527649954, 0.7183833151005337, 0.681378959929164, 0.6330726608184489, 0.32097836906576094, 0.6855200477295977, 0.22041683867145812, 0.6917784069729835, 0.1194959734922535, 0.7080255180525818, 0.7457165534007484, 0.5807113868361782, 0.5280775447009367, 0.23332736165917534, 0.774680595669013, 0.7170348694748285, 0.7857750683116147, 0.7287924475200627, 0.7214129825484259, 0.12089338304187747, 0.13326956939510437, 0.32241540263927226, 0.3514615036743336, 0.13760392258005671, 0.4049549646756345, 0.323787519653138, 0.17295679239405293, 0.2175255460318608, 0.5935084616960684, 0.5292299982068168, 0.48905131444850947, 0.6235061703226017, 0.6489865362318203, 0.6554977920443321, 0.6184164886156176, 0.6425065504294125, 0.5228008741799908, 0.8317522090513705, 0.8098883739493272, 0.7639460644403128, 0.8254703280331348, 0.6399706503351008, 0.8273162749402343, 0.8490441024775296, 0.8183005935190178, 0.5622154561882003, 0.11318979755455671, 0.09254364459303033, 0.10118780823732576, 0.10528499086527665, 0.09205075101500115, 0.11387608947517491, 0.11077363590730038, 0.1157927834705853, 0.11023047296638977, 0.14596728783839752, 0.5164528663095185, 0.1451041904333109, 0.29155611386446567, 0.22532684625099553, 0.17170228459578551, 0.2386847739885859, 0.14553876871940996, 0.17959689022505043, 0.5732782880628773, 0.5879775259210933, 0.5359341486277305, 0.5238807401240112, 0.5217138045844781, 0.4867254475277074, 0.5431730703476378, 0.6458859962249277, 0.5872124091805316, 0.42135541826818124, 0.49194877615425314, 0.4266707360232588, 0.42855602293405126, 0.40498366620998816, 0.4784204202632619, 0.489748945825489, 0.39601499330860523, 0.48557193294843937, 0.18467893784232003, 0.1973691842523554, 0.21225623441982777, 0.212171708762676, 0.18146180268154566, 0.19122468659740577, 0.19496743051402732, 0.19043051694677982, 0.18896505277871967, 0.21656726228763168, 0.5686663198293516, 0.23799433171017192, 0.6346652870073781, 0.24272787184629585, 0.2338246574179067, 0.22837987941139637, 0.22489165519029097, 0.36548359532860986, 0.8105428307166171, 0.8357574334213027, 0.851188188124482, 0.19335258493199203, 0.806331937468628, 0.16393082908354895, 0.16062893418549373, 0.8474596938129201, 0.7360068702096987, 0.47430739189205695, 0.77758756815062, 0.20763363959490344, 0.1653676559465843, 0.6854789106060435, 0.2051914040672962, 0.1531741163674447, 0.5871070409374493, 0.2075318419024349, 0.19040784074472705, 0.19340974714652948, 0.1904349683677281, 0.1942429525496947, 0.17039818015510477, 0.1809883649872207, 0.1930806902393719, 0.1908371480392017, 0.20080356980787795, 0.07837808199724727, 0.07943799237822025, 0.07500864556088183, 0.08438440587035823, 0.08526847128552417, 0.08387878091738565, 0.07459815988152863, 0.0832141454472809, 0.0959619466612901]}, "mutation_prompt": null}
{"id": "808d144d-d29f-4dcc-81b4-03fd75fd8e4f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) if self.adaptive_scaling else self.F \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim)) + np.random.randint(-2, 3)  # Change: Added adaptive population resizing\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance DE by introducing adaptive population resizing for improved exploration-exploitation balance.", "configspace": "", "generation": 61, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {}, "mutation_prompt": null}
{"id": "df5f50e6-f3d3-44d8-ae50-d1ff07c0f833", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) * (1 - (evals / self.budget))  # Change: Adjust F_dynamic based on evals\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a more dynamic update for the mutation factor by adjusting it based on function evaluations.", "configspace": "", "generation": 62, "fitness": 0.36296416063887565, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {"aucs": [0.8572385862808477, 0.8818392334730645, 0.8552574277190768, 0.8714999933557718, 0.7999042972973462, 0.8611456209217432, 0.7958190101602381, 0.6091157971193439, 0.7708957834944146, 0.5958629981927317, 0.7619816501087919, 0.7219321566794876, 0.7582851088441492, 0.7979269720113005, 0.7537708764681397, 0.5511439669734042, 0.7528497136364911, 0.539414042135028, 0.1350351035163827, 0.15015969061452727, 0.15933381573854566, 0.14767087389624745, 0.1550543708088098, 0.2719395173096404, 0.4789898106014081, 0.1906718541414374, 0.5015264405721092, 0.14780186076297053, 0.13789230414453146, 0.12638464613131817, 0.13335456561064873, 0.1341014069598907, 0.15522509404337181, 0.14923938815384297, 0.15866808265975318, 0.15636833220602042, 0.8995361564907964, 0.9619335502875527, 0.9252758230972915, 0.9459992331258933, 0.9341896322776864, 0.9487942562477278, 0.9647906104338508, 0.9504926969324685, 0.9443416820200536, 0.2195101280572077, 0.22477196555596224, 0.350778757372216, 0.33770969099972303, 0.3271756980054471, 0.27861547069006243, 0.3240437435633927, 0.4190030419628613, 0.3752202761069996, 0.8803379966868231, 0.8554447351243348, 0.8849686728498871, 0.8628970726490965, 0.27213553083251696, 0.8906881034277637, 0.17693601600144504, 0.35753170570707793, 0.8750724417473003, 0.17439057294966132, 0.15255596581648567, 0.15656942180793998, 0.15742625292254564, 0.16042567295140775, 0.21724458903584165, 0.4457836073826744, 0.35161763992489503, 0.1778044842760813, 0.12948006111659904, 0.17339153296270526, 0.27915555544312043, 0.19129123955104743, 0.2003271737100526, 0.13567802207119017, 0.19897443581109797, 0.1833496652134814, 0.2904391291270363, 0.2977808441945843, 0.1051549124756117, 0.1652032159134902, 0.22163678579861223, 0.48688710827551474, 0.4962544504126978, 0.5552327651655136, 0.442097041514267, 0.3900632636161888, 0.5896739301656689, 0.41238707867881874, 0.6517950958080712, 0.4086896039428587, 0.21630799097747933, 0.5704824934828492, 0.596655271074789, 0.5067030509443314, 0.6596165500109484, 0.29625312736697584, 0.08903169009735323, 0.07062020789632129, 0.21742519190252807, 0.3563740302802171, 0.2622048944194755, 0.35463123968964927, 0.1442106030868252, 0.31112088553474737, 0.42388345542447137, 0.2369313854256988, 0.17171283147075211, 0.42893759779712004, 0.23358682795511176, 0.17134194387135226, 0.23028075744396415, 0.4151174658822916, 0.27399271728123287, 0.6382237643047217, 0.6159037966313419, 0.8215759114553404, 0.8427261879413388, 0.6063111277801887, 0.8266806337423687, 0.8558626483546539, 0.5385086544072899, 0.6936580834025506, 0.14053268632729554, 0.12505084626954122, 0.12649681857471384, 0.12175476861416135, 0.129903202684441, 0.14981338431621893, 0.10651195069945807, 0.14142943342486558, 0.14800135506129686, 0.18461163861306218, 0.17109160324748007, 0.14671835621151696, 0.14274907524561353, 0.2259965836604193, 0.164609806634188, 0.47086817576923956, 0.1468235278818889, 0.17245308657625724, 0.436951475380313, 0.48806090968437355, 0.458422863821066, 0.46897911298840167, 0.4010164481978197, 0.37837829220737496, 0.5559294284900143, 0.37592326340889726, 0.5127441067484966, 0.3357551457852552, 0.3403511149352354, 0.30933561552393807, 0.35697305476040064, 0.3892545981522808, 0.33229556859297216, 0.36978172120162645, 0.41092190702135745, 0.3780838717594105, 0.23196383243207508, 0.22218315886761775, 0.19986691848151905, 0.1921961287667887, 0.21149757944896574, 0.24321163800468493, 0.2040974796234174, 0.20114364876030544, 0.19529173317729787, 0.23578549255529246, 0.3219701075494158, 0.4861781362729616, 0.3168706670274889, 0.4734529895060582, 0.21880743668810654, 0.19145172189993287, 0.20659336251184535, 0.28349579737186836, 0.13993935683354708, 0.15774555607766105, 0.18325763951619378, 0.19139498767228236, 0.5530141579986829, 0.16257842855270954, 0.12822398282935132, 0.3331281033622304, 0.1890203703585116, 0.30805727466904786, 0.27545256859413025, 0.20828983134905532, 0.16406973912113754, 0.1884645388753463, 0.165654834547439, 0.10448913119751835, 0.2071454908845457, 0.20558924554165514, 0.17727288951573628, 0.204553617273182, 0.18610308548274124, 0.17598914729508575, 0.21523204441872346, 0.186957414823695, 0.19331577624336027, 0.18819420993412306, 0.20186067220241388, 0.09913147071297623, 0.07993166252294182, 0.07812461227457446, 0.09355060577399688, 0.08682516112691208, 0.08888014637454178, 0.08057988292596474, 0.07751717192262386, 0.08096204540767082]}, "mutation_prompt": null}
{"id": "e47a56e4-6a1b-45b4-85b0-b8b41493d0f9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) if self.adaptive_scaling else self.F\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 12 * self.dim))  # Slightly increase population size factor\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced population update strategy to improve convergence by increasing the rate and diversity of successful mutations.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 51 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 51 is out of bounds for axis 0 with size 50')", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {}, "mutation_prompt": null}
{"id": "79da6756-2f93-4e61-b5a3-fa03a9c22fd9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) if self.adaptive_scaling else self.F  # Change: Narrow the F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)  # Change: Narrow the dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim * np.random.uniform(0.9, 1.1)))  # Change: Introduce randomness in population size\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas))) * np.random.uniform(0.95, 1.05)  # Change: Add momentum in F update\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive behavior by dynamically adjusting population size and incorporating momentum in parameter updates.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {}, "mutation_prompt": null}
{"id": "c411c9c7-b956-4e4c-9a0c-f391c50e2c2c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.6  # Change: Adjusted initial scaling factor\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) if self.adaptive_scaling else self.F  # Change: Narrow the F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)  # Change: Narrow the dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive scaling factor F to enhance convergence stability.", "configspace": "", "generation": 65, "fitness": 0.4287140172439119, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {"aucs": [0.8524228691864324, 0.8489788363706197, 0.8400213339552716, 0.8581368445921177, 0.8554030648485353, 0.8593834246456248, 0.845888720284772, 0.8626070421015978, 0.8611596580777566, 0.761934430433864, 0.75968805850272, 0.7465675355203292, 0.7533818388712317, 0.7369210176398864, 0.7406521249681134, 0.757194669194236, 0.6943977880936083, 0.7488099990825077, 0.11322051111087839, 0.2852961261623608, 0.2599873660959128, 0.1677337224835883, 0.20327250655453355, 0.1691776772593223, 0.17745573280031168, 0.1440669322179905, 0.14231412908831587, 0.11879748495260134, 0.2952518581320551, 0.14003204511496536, 0.1337729024754608, 0.2553890146011938, 0.1242567553870988, 0.1414371965207054, 0.1206078782540031, 0.2172255639530828, 0.9599099476731837, 0.9657156090800897, 0.9572058388602159, 0.9612981248446669, 0.9787267399359842, 0.9708801310347, 0.9194204760394865, 0.9697945259255588, 0.9625213882997435, 0.5141751811327504, 0.5477811736584445, 0.33833029889095423, 0.41257035715093715, 0.40699897947102226, 0.5526716067691464, 0.3519557088149413, 0.42904197412201006, 0.4196426882104174, 0.3792758486932869, 0.8540524022904339, 0.4698776627339306, 0.8586240140005673, 0.8629288016223338, 0.8302241763461672, 0.8771242666368076, 0.8618228853561245, 0.8020769894261727, 0.3567894240366981, 0.24105531704270045, 0.152977509489025, 0.19587821806054184, 0.14604809655743134, 0.2565604276945793, 0.2115929781669389, 0.20698846166834306, 0.18990301161347112, 0.726168615199333, 0.1554917142737866, 0.4586102479515799, 0.2602459271560942, 0.24067930664733483, 0.2456249950695789, 0.15171124466915187, 0.24716302646977883, 0.22826799572740175, 0.4726271358501154, 0.7209457686252155, 0.6012449088888914, 0.5667330247718776, 0.634578727823979, 0.6896072258794175, 0.7359427044968068, 0.6995613541455202, 0.7000674732285355, 0.8155007965427391, 0.7807734314809722, 0.7525635809114013, 0.6290130878540205, 0.704689608241386, 0.1464413192825439, 0.7777244034337094, 0.7874174787808073, 0.3474925594400695, 0.1419506786477468, 0.29677640153916607, 0.20926976502652517, 0.5627174620132477, 0.3163712080997889, 0.21625508528378767, 0.22768251116300608, 0.09416756850061825, 0.14438191648578247, 0.3805547494749336, 0.624073138697468, 0.6313028364276262, 0.5952826511266582, 0.6049079147232794, 0.630411853172045, 0.5310425646827768, 0.3043160886045645, 0.3435693519243641, 0.6301637769904394, 0.8200952414149099, 0.8234660391414083, 0.8210130531495026, 0.7184935865128212, 0.6063639671214575, 0.826959861583837, 0.8089644616157687, 0.816067634379248, 0.13180440945378324, 0.14504232930354433, 0.1201865365734448, 0.16563780498121372, 0.1027056152574618, 0.15742701484518762, 0.2225840151286247, 0.10843814982287259, 0.12318830392137348, 0.14059451396103562, 0.20194721887160527, 0.18997286454159723, 0.1670774990578049, 0.14877478392548782, 0.1550425434183469, 0.18844653854715498, 0.1563835717183536, 0.1593378343397155, 0.5700779135677725, 0.47765626325871147, 0.5253633204036776, 0.4892634793159406, 0.5006986638124626, 0.5854070877784827, 0.49617246739638576, 0.5915248514484158, 0.54210967973637, 0.4520944566927283, 0.5689395011407161, 0.48205565647724447, 0.5107803288159645, 0.43937571462298797, 0.4668114293313408, 0.4597954856808901, 0.4758076317546567, 0.4863025797580144, 0.19938017222249915, 0.21599649249231856, 0.20195423793771072, 0.19670870629003834, 0.17940229054636547, 0.21515679710644975, 0.2091875015374587, 0.20653079581961675, 0.1903749838801232, 0.4958019632332934, 0.2606425780404328, 0.465468184197223, 0.5598622315198344, 0.2501320870211682, 0.24985447009745754, 0.19275893340686245, 0.23153660355073624, 0.2301356078885023, 0.1922038417671169, 0.8316558015591706, 0.7698834648005315, 0.18841226622005947, 0.17064041052972567, 0.18738966884193498, 0.1594735119102455, 0.8676593369894787, 0.1836644984091239, 0.8729535759560476, 0.17487433551801712, 0.20441298581899436, 0.1633699825824957, 0.7643293552302931, 0.20287712166997052, 0.20926098290231954, 0.2085234724854711, 0.20511294809874092, 0.18029952682403438, 0.17986049647334823, 0.17548392138564084, 0.19435335038372425, 0.18972017048235978, 0.18364184029309094, 0.1903077776368699, 0.18243347351115924, 0.206795522966014, 0.08978698957830078, 0.08005417557688255, 0.08527935585926694, 0.08224388474192401, 0.08318071452194964, 0.07583082772426752, 0.08400007770569495, 0.08312922182966831, 0.07462120922333337]}, "mutation_prompt": null}
{"id": "f3e81b33-67cb-4853-baab-a7aca60777a0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) if self.adaptive_scaling else self.F  # Change: Narrow the F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.9, 1.1)  # Change: Slightly narrow the dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Slightly narrow the range of adaptive crossover probability to enhance convergence stability.", "configspace": "", "generation": 66, "fitness": 0.435863868020729, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {"aucs": [0.8403111545328406, 0.8470862262181911, 0.8617947782994557, 0.8434215706788921, 0.8503593953860193, 0.8555392452982813, 0.8521868528519451, 0.8470634590277811, 0.8642988460142328, 0.7426486173257519, 0.7210683913923289, 0.7487695252378799, 0.7268141084965485, 0.735068314438444, 0.7491199725352594, 0.7786667406505776, 0.7362386679509108, 0.64256491820987, 0.11750144134766505, 0.12428459632465783, 0.4233292872279799, 0.19136210693693223, 0.2281925266955599, 0.11181992919110362, 0.1187421716446907, 0.15193655289548824, 0.18996299000218275, 0.17988579391964465, 0.14272200430387383, 0.1138711307105057, 0.1297346604988352, 0.12939555977886685, 0.13238890179852691, 0.14706818410526734, 0.11443464729673147, 0.1402493011133622, 0.9454223317204283, 0.9540181271772062, 0.9312081264699468, 0.12924953902295255, 0.9508518377528861, 0.9460320974834041, 0.9810626569620338, 0.9583559560599776, 0.9452117009631521, 0.6258216238308179, 0.4104494875922552, 0.5716529728865967, 0.4546302062175859, 0.5724132760627103, 0.6279232198948974, 0.5788290613336846, 0.3653207577355646, 0.6343504721394484, 0.8106321186773716, 0.8535414835725833, 0.8096291764943353, 0.8650622679235581, 0.8395703770286435, 0.8333158498658773, 0.8767871195968735, 0.8245950864204583, 0.8095854551125573, 0.26289441792400026, 0.20393480190281343, 0.162202540115571, 0.19785112308920538, 0.21588756955034272, 0.4036863018008573, 0.23248196812877553, 0.17823578474886181, 0.12698206623798125, 0.13828989407162284, 0.23129851082732966, 0.18764745847836717, 0.3289191255455688, 0.3014098785453936, 0.12756449073673215, 0.1899516099147589, 0.22575275803886885, 0.2328618085288181, 0.6527853076518252, 0.7119163503306538, 0.46957225065638997, 0.6855466762949042, 0.23265840705289742, 0.6904167909948844, 0.7172332343347503, 0.6484110507532164, 0.26597997430329523, 0.7697819025197619, 0.7364527274617296, 0.7666696121912532, 0.7745183146410032, 0.7610700157453102, 0.4262342231460362, 0.7464399313613796, 0.7559549410274368, 0.2704702559714196, 0.1372476714133838, 0.0830732236968732, 0.13975558052285797, 0.17968021991498828, 0.2024177853385256, 0.16722130673745084, 0.30408415030080604, 0.24736140955720087, 0.29982496891081023, 0.5992138105460506, 0.6008969519433544, 0.4835310718641984, 0.6540796216622877, 0.588263687199118, 0.5713480131399922, 0.3435374749237765, 0.331077522777525, 0.6422508189353375, 0.8175528048973733, 0.8162350356619932, 0.8271008761311361, 0.6160544943185589, 0.810547536473943, 0.7924169557833078, 0.8427778629466534, 0.8044710714558984, 0.8052477600336494, 0.09666463857365637, 0.10677034431272203, 0.1100510816037229, 0.12030569024298987, 0.12342546094694973, 0.10921338337151609, 0.1006295333046634, 0.08900298354788028, 0.10259217331667769, 0.12314703534853766, 0.16207763398360364, 0.19922431438292632, 0.1856447609038283, 0.1631591337402688, 0.14123506830717159, 0.1867433553020097, 0.18990905802111024, 0.1516832822323968, 0.5182621793812865, 0.4451679802333345, 0.47367499181951644, 0.5247378077048694, 0.5001787377438336, 0.572568819899535, 0.5707062775338785, 0.5382915246206705, 0.5913688396491663, 0.5323612075519559, 0.4834752077242268, 0.42451216325520424, 0.4279419954854228, 0.5260463830946573, 0.4546914996172158, 0.4712803911696658, 0.47452242471700967, 0.3754939169754997, 0.20793650768663974, 0.19956808631367362, 0.19341726958492678, 0.1924642942049215, 0.1928826762685777, 0.1958690382239573, 0.19371549246826802, 0.20090142791716792, 0.23922133307292637, 0.23312447185276963, 0.42278768308960324, 0.5220028615223058, 0.18829979138182407, 0.4909402474499447, 0.5349305107374289, 0.5411783175499525, 0.2857439772845527, 0.20510175694045252, 0.16240888544191456, 0.8724691397504867, 0.8854056221278959, 0.19628476588448063, 0.7905835366601633, 0.7488744920079913, 0.15905061056680148, 0.1836734293606448, 0.1676321634239415, 0.8979514245931537, 0.2004770760658734, 0.20531129098358347, 0.7897964617495766, 0.8403363537306897, 0.8489868341804171, 0.8308261728187506, 0.2104687336406198, 0.2072978665611741, 0.1773740247921094, 0.18280928364022753, 0.19779646024816544, 0.1777280552572894, 0.1890993476356383, 0.1717080833046546, 0.16987002190897638, 0.1890798363165327, 0.18414881667810334, 0.08064867353104455, 0.07794314013479275, 0.08632267145285699, 0.0852393680437954, 0.08796281776673864, 0.07995654468858959, 0.07591888486926035, 0.0769829448289514, 0.07866591661616673]}, "mutation_prompt": null}
{"id": "adab0291-2600-4e80-befe-3eaed8875408", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) if self.adaptive_scaling else self.F  # Change: Narrow the F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.9, 1.1)  # Change: Further narrowed the dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Refined the dynamic crossover probability range to enhance convergence stability.", "configspace": "", "generation": 67, "fitness": 0.435863868020729, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {"aucs": [0.8403111545328406, 0.8470862262181911, 0.8617947782994557, 0.8434215706788921, 0.8503593953860193, 0.8555392452982813, 0.8521868528519451, 0.8470634590277811, 0.8642988460142328, 0.7426486173257519, 0.7210683913923289, 0.7487695252378799, 0.7268141084965485, 0.735068314438444, 0.7491199725352594, 0.7786667406505776, 0.7362386679509108, 0.64256491820987, 0.11750144134766505, 0.12428459632465783, 0.4233292872279799, 0.19136210693693223, 0.2281925266955599, 0.11181992919110362, 0.1187421716446907, 0.15193655289548824, 0.18996299000218275, 0.17988579391964465, 0.14272200430387383, 0.1138711307105057, 0.1297346604988352, 0.12939555977886685, 0.13238890179852691, 0.14706818410526734, 0.11443464729673147, 0.1402493011133622, 0.9454223317204283, 0.9540181271772062, 0.9312081264699468, 0.12924953902295255, 0.9508518377528861, 0.9460320974834041, 0.9810626569620338, 0.9583559560599776, 0.9452117009631521, 0.6258216238308179, 0.4104494875922552, 0.5716529728865967, 0.4546302062175859, 0.5724132760627103, 0.6279232198948974, 0.5788290613336846, 0.3653207577355646, 0.6343504721394484, 0.8106321186773716, 0.8535414835725833, 0.8096291764943353, 0.8650622679235581, 0.8395703770286435, 0.8333158498658773, 0.8767871195968735, 0.8245950864204583, 0.8095854551125573, 0.26289441792400026, 0.20393480190281343, 0.162202540115571, 0.19785112308920538, 0.21588756955034272, 0.4036863018008573, 0.23248196812877553, 0.17823578474886181, 0.12698206623798125, 0.13828989407162284, 0.23129851082732966, 0.18764745847836717, 0.3289191255455688, 0.3014098785453936, 0.12756449073673215, 0.1899516099147589, 0.22575275803886885, 0.2328618085288181, 0.6527853076518252, 0.7119163503306538, 0.46957225065638997, 0.6855466762949042, 0.23265840705289742, 0.6904167909948844, 0.7172332343347503, 0.6484110507532164, 0.26597997430329523, 0.7697819025197619, 0.7364527274617296, 0.7666696121912532, 0.7745183146410032, 0.7610700157453102, 0.4262342231460362, 0.7464399313613796, 0.7559549410274368, 0.2704702559714196, 0.1372476714133838, 0.0830732236968732, 0.13975558052285797, 0.17968021991498828, 0.2024177853385256, 0.16722130673745084, 0.30408415030080604, 0.24736140955720087, 0.29982496891081023, 0.5992138105460506, 0.6008969519433544, 0.4835310718641984, 0.6540796216622877, 0.588263687199118, 0.5713480131399922, 0.3435374749237765, 0.331077522777525, 0.6422508189353375, 0.8175528048973733, 0.8162350356619932, 0.8271008761311361, 0.6160544943185589, 0.810547536473943, 0.7924169557833078, 0.8427778629466534, 0.8044710714558984, 0.8052477600336494, 0.09666463857365637, 0.10677034431272203, 0.1100510816037229, 0.12030569024298987, 0.12342546094694973, 0.10921338337151609, 0.1006295333046634, 0.08900298354788028, 0.10259217331667769, 0.12314703534853766, 0.16207763398360364, 0.19922431438292632, 0.1856447609038283, 0.1631591337402688, 0.14123506830717159, 0.1867433553020097, 0.18990905802111024, 0.1516832822323968, 0.5182621793812865, 0.4451679802333345, 0.47367499181951644, 0.5247378077048694, 0.5001787377438336, 0.572568819899535, 0.5707062775338785, 0.5382915246206705, 0.5913688396491663, 0.5323612075519559, 0.4834752077242268, 0.42451216325520424, 0.4279419954854228, 0.5260463830946573, 0.4546914996172158, 0.4712803911696658, 0.47452242471700967, 0.3754939169754997, 0.20793650768663974, 0.19956808631367362, 0.19341726958492678, 0.1924642942049215, 0.1928826762685777, 0.1958690382239573, 0.19371549246826802, 0.20090142791716792, 0.23922133307292637, 0.23312447185276963, 0.42278768308960324, 0.5220028615223058, 0.18829979138182407, 0.4909402474499447, 0.5349305107374289, 0.5411783175499525, 0.2857439772845527, 0.20510175694045252, 0.16240888544191456, 0.8724691397504867, 0.8854056221278959, 0.19628476588448063, 0.7905835366601633, 0.7488744920079913, 0.15905061056680148, 0.1836734293606448, 0.1676321634239415, 0.8979514245931537, 0.2004770760658734, 0.20531129098358347, 0.7897964617495766, 0.8403363537306897, 0.8489868341804171, 0.8308261728187506, 0.2104687336406198, 0.2072978665611741, 0.1773740247921094, 0.18280928364022753, 0.19779646024816544, 0.1777280552572894, 0.1890993476356383, 0.1717080833046546, 0.16987002190897638, 0.1890798363165327, 0.18414881667810334, 0.08064867353104455, 0.07794314013479275, 0.08632267145285699, 0.0852393680437954, 0.08796281776673864, 0.07995654468858959, 0.07591888486926035, 0.0769829448289514, 0.07866591661616673]}, "mutation_prompt": null}
{"id": "fbc1d75c-b5bd-42a2-8204-7d992e8431bb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) if self.adaptive_scaling else self.F\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.9, 1.1)  # Change: Refine dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance parameter tuning precision by slightly adjusting the calculation of `dynamic_CR`.", "configspace": "", "generation": 68, "fitness": 0.435863868020729, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {"aucs": [0.8403111545328406, 0.8470862262181911, 0.8617947782994557, 0.8434215706788921, 0.8503593953860193, 0.8555392452982813, 0.8521868528519451, 0.8470634590277811, 0.8642988460142328, 0.7426486173257519, 0.7210683913923289, 0.7487695252378799, 0.7268141084965485, 0.735068314438444, 0.7491199725352594, 0.7786667406505776, 0.7362386679509108, 0.64256491820987, 0.11750144134766505, 0.12428459632465783, 0.4233292872279799, 0.19136210693693223, 0.2281925266955599, 0.11181992919110362, 0.1187421716446907, 0.15193655289548824, 0.18996299000218275, 0.17988579391964465, 0.14272200430387383, 0.1138711307105057, 0.1297346604988352, 0.12939555977886685, 0.13238890179852691, 0.14706818410526734, 0.11443464729673147, 0.1402493011133622, 0.9454223317204283, 0.9540181271772062, 0.9312081264699468, 0.12924953902295255, 0.9508518377528861, 0.9460320974834041, 0.9810626569620338, 0.9583559560599776, 0.9452117009631521, 0.6258216238308179, 0.4104494875922552, 0.5716529728865967, 0.4546302062175859, 0.5724132760627103, 0.6279232198948974, 0.5788290613336846, 0.3653207577355646, 0.6343504721394484, 0.8106321186773716, 0.8535414835725833, 0.8096291764943353, 0.8650622679235581, 0.8395703770286435, 0.8333158498658773, 0.8767871195968735, 0.8245950864204583, 0.8095854551125573, 0.26289441792400026, 0.20393480190281343, 0.162202540115571, 0.19785112308920538, 0.21588756955034272, 0.4036863018008573, 0.23248196812877553, 0.17823578474886181, 0.12698206623798125, 0.13828989407162284, 0.23129851082732966, 0.18764745847836717, 0.3289191255455688, 0.3014098785453936, 0.12756449073673215, 0.1899516099147589, 0.22575275803886885, 0.2328618085288181, 0.6527853076518252, 0.7119163503306538, 0.46957225065638997, 0.6855466762949042, 0.23265840705289742, 0.6904167909948844, 0.7172332343347503, 0.6484110507532164, 0.26597997430329523, 0.7697819025197619, 0.7364527274617296, 0.7666696121912532, 0.7745183146410032, 0.7610700157453102, 0.4262342231460362, 0.7464399313613796, 0.7559549410274368, 0.2704702559714196, 0.1372476714133838, 0.0830732236968732, 0.13975558052285797, 0.17968021991498828, 0.2024177853385256, 0.16722130673745084, 0.30408415030080604, 0.24736140955720087, 0.29982496891081023, 0.5992138105460506, 0.6008969519433544, 0.4835310718641984, 0.6540796216622877, 0.588263687199118, 0.5713480131399922, 0.3435374749237765, 0.331077522777525, 0.6422508189353375, 0.8175528048973733, 0.8162350356619932, 0.8271008761311361, 0.6160544943185589, 0.810547536473943, 0.7924169557833078, 0.8427778629466534, 0.8044710714558984, 0.8052477600336494, 0.09666463857365637, 0.10677034431272203, 0.1100510816037229, 0.12030569024298987, 0.12342546094694973, 0.10921338337151609, 0.1006295333046634, 0.08900298354788028, 0.10259217331667769, 0.12314703534853766, 0.16207763398360364, 0.19922431438292632, 0.1856447609038283, 0.1631591337402688, 0.14123506830717159, 0.1867433553020097, 0.18990905802111024, 0.1516832822323968, 0.5182621793812865, 0.4451679802333345, 0.47367499181951644, 0.5247378077048694, 0.5001787377438336, 0.572568819899535, 0.5707062775338785, 0.5382915246206705, 0.5913688396491663, 0.5323612075519559, 0.4834752077242268, 0.42451216325520424, 0.4279419954854228, 0.5260463830946573, 0.4546914996172158, 0.4712803911696658, 0.47452242471700967, 0.3754939169754997, 0.20793650768663974, 0.19956808631367362, 0.19341726958492678, 0.1924642942049215, 0.1928826762685777, 0.1958690382239573, 0.19371549246826802, 0.20090142791716792, 0.23922133307292637, 0.23312447185276963, 0.42278768308960324, 0.5220028615223058, 0.18829979138182407, 0.4909402474499447, 0.5349305107374289, 0.5411783175499525, 0.2857439772845527, 0.20510175694045252, 0.16240888544191456, 0.8724691397504867, 0.8854056221278959, 0.19628476588448063, 0.7905835366601633, 0.7488744920079913, 0.15905061056680148, 0.1836734293606448, 0.1676321634239415, 0.8979514245931537, 0.2004770760658734, 0.20531129098358347, 0.7897964617495766, 0.8403363537306897, 0.8489868341804171, 0.8308261728187506, 0.2104687336406198, 0.2072978665611741, 0.1773740247921094, 0.18280928364022753, 0.19779646024816544, 0.1777280552572894, 0.1890993476356383, 0.1717080833046546, 0.16987002190897638, 0.1890798363165327, 0.18414881667810334, 0.08064867353104455, 0.07794314013479275, 0.08632267145285699, 0.0852393680437954, 0.08796281776673864, 0.07995654468858959, 0.07591888486926035, 0.0769829448289514, 0.07866591661616673]}, "mutation_prompt": null}
{"id": "0dd3228e-5d05-4fa2-bf8d-ef6859a41105", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.3) if self.adaptive_scaling else self.F  # Change: Narrow the F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)  # Change: Narrow the dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(5, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune population size adjustment to enhance convergence rates.", "configspace": "", "generation": 69, "fitness": 0.4253195663332267, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {"aucs": [0.8503742739144374, 0.8639261229365762, 0.8642967045697827, 0.8599219351200342, 0.8581017408299374, 0.8631991300169831, 0.861472354162303, 0.8449755836004773, 0.8800859506448119, 0.7632571650379065, 0.7188280846128705, 0.720160382532067, 0.7433091003449083, 0.7406166134448989, 0.7636243737922297, 0.7450039935936497, 0.7394944992283318, 0.7189639541208069, 0.14690872336103256, 0.1561605199675098, 0.2639078316623038, 0.26781410690307317, 0.41717978411965173, 0.3458335421666918, 0.1612729923445173, 0.2951988473362839, 0.4090999571857691, 0.13295707005210755, 0.15287238055140273, 0.1373964134216894, 0.19018620462654545, 0.1430438641891224, 0.23649191078881882, 0.13881418976173898, 0.15290548215796207, 0.18206248952535986, 0.9550554752010504, 0.9557440745567043, 0.9596257866402194, 0.9617298276163986, 0.9585888918999047, 0.9159562546925685, 0.9446691672393155, 0.9362227160425156, 0.9380323537674891, 0.2821162756599632, 0.459829467243979, 0.4259370725163012, 0.41141706167227654, 0.3738355838891382, 0.5850789748939618, 0.4134320950666214, 0.4785162989424533, 0.4382224329743317, 0.8682457490083285, 0.8501243563155447, 0.8655971829468486, 0.8340680499767037, 0.8110178212495023, 0.8478645804061651, 0.876215012329552, 0.8695031895797367, 0.8713173844365439, 0.151765108327941, 0.24982472788108023, 0.19042010538677157, 0.6584150886863572, 0.20071581771709202, 0.1836330927139137, 0.2102051267199001, 0.21594154726691472, 0.2000154919737548, 0.12316958369277686, 0.14838930491614577, 0.5343583310159181, 0.23570261629477496, 0.2681218965631693, 0.23300422827319434, 0.1740237334500604, 0.12803327862153313, 0.3293528730753864, 0.2122452526821137, 0.5436136851276678, 0.7259992164075697, 0.658175365490913, 0.4500009707223236, 0.6424251164531914, 0.6913522375383215, 0.324015064023778, 0.7007085503144039, 0.5632733652819613, 0.37269545971039575, 0.7791211437328729, 0.7974258286203, 0.7749649451356428, 0.7788507313170113, 0.7493009281614595, 0.7714341125208909, 0.6235391759217636, 0.09772319933969775, 0.25106694062576973, 0.31742490905925724, 0.21338607713291513, 0.3473062710265902, 0.5431326868904334, 0.10982449901662039, 0.13983687516492704, 0.28312779110254027, 0.5989507792971938, 0.4540615939489834, 0.5554361645533952, 0.600405233957241, 0.38908679780556765, 0.5998145783292063, 0.15224641300393704, 0.6161549754448645, 0.621527959403912, 0.8238209898708312, 0.8085733591080596, 0.8396074141319074, 0.7237290336500902, 0.8408078918999926, 0.8501088088618663, 0.8311261714798944, 0.6436739088101902, 0.8296712387108944, 0.13572627134064552, 0.13581473238845043, 0.11785610597044904, 0.10764156440459227, 0.2155100711999588, 0.13610354937419633, 0.11756910585939839, 0.11487954725032035, 0.10680837780872554, 0.600553053726107, 0.16354627779116804, 0.1607188514354544, 0.1362591830794061, 0.17956441887037833, 0.19529823721636874, 0.26640600273234494, 0.22645393783367218, 0.27335205702991006, 0.5576450850105233, 0.48709107616683966, 0.5113346064815879, 0.40176145680168773, 0.5281193855945899, 0.48694974463316265, 0.6021798105000362, 0.6270289170128549, 0.5150333330625372, 0.5521551634833748, 0.5073162411701535, 0.40613621508825126, 0.45128792834459264, 0.35462352658815144, 0.3262275194860065, 0.48589977216507285, 0.46996174626119547, 0.49096458853816716, 0.1992397217015155, 0.18662186027450178, 0.20151804101576887, 0.19561141340638277, 0.2292570434401675, 0.2221084716139614, 0.18477609069053003, 0.1833960727406696, 0.20999560073871848, 0.24888011207519212, 0.5253418200069562, 0.2083972430655452, 0.6107731844572915, 0.1853565049501742, 0.19968383021600744, 0.2354150891102158, 0.23271056524785605, 0.28852830320639944, 0.18233486027094303, 0.1799221323489859, 0.15432030549392783, 0.1818526815689705, 0.8062424781881605, 0.16573618275469126, 0.1629728472875075, 0.17732144686624085, 0.7592634731364305, 0.2046018123832536, 0.16628738559492762, 0.20617525072741294, 0.1668820556202376, 0.16032585623937212, 0.1947163456280897, 0.36398269674847483, 0.21212180797196767, 0.2089442799505331, 0.19378547899383725, 0.17721851895369345, 0.17596587478115466, 0.18382658402108287, 0.18141715297874206, 0.18506920105678926, 0.18362200423989872, 0.1759144639219481, 0.1811223931887399, 0.10032184544534617, 0.0908334231249186, 0.07811424967358471, 0.09410185522428383, 0.08403361994064251, 0.08827452884011877, 0.09229412500901768, 0.08411682585814373, 0.07205478153197031]}, "mutation_prompt": null}
{"id": "6ca156bd-7e3a-4da3-abe8-a09b0ac4673e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        stagnation_count = 0\n        no_improvement_threshold = 50\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                \n                F_dynamic = self.F * np.random.uniform(0.6, 1.4)\n                if np.random.rand() < 0.1:\n                    F_dynamic *= 0.5\n                \n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n                    stagnation_count = 0\n                else:\n                    stagnation_count += 1\n\n            if stagnation_count >= no_improvement_threshold:\n                self.adaptive_scaling = not self.adaptive_scaling\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance the convergence by introducing dynamic population resizing and adaptive mutation strategies.", "configspace": "", "generation": 70, "fitness": 0.42511721139351255, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {"aucs": [0.8362826587989065, 0.8506771517802818, 0.8751266036957808, 0.8534532295075743, 0.8651571725189157, 0.8657120700248845, 0.8718960933466564, 0.852769596791749, 0.8697081188993007, 0.7284677333795793, 0.722518817621026, 0.7362551400447713, 0.7511401960590695, 0.721400832692292, 0.7698164720078349, 0.7311237201414229, 0.7648427842513302, 0.7373399495285344, 0.5572416407052534, 0.40708449050671625, 0.5397654231392308, 0.26088834161754126, 0.4108428987523588, 0.34324032230248636, 0.3268273133424059, 0.17152120256846903, 0.4655708671398592, 0.1382078524886412, 0.4155446709780639, 0.23983704686395957, 0.15370300316525043, 0.14801157208816418, 0.14852034479013732, 0.15559111223990063, 0.22064995480333616, 0.13704397060565954, 0.9865446437990769, 0.9431499710896767, 0.9470000243406126, 0.9689506680038654, 0.9582001662935468, 0.9502420170267677, 0.9684030755671551, 0.9561807231681211, 0.9736931240237647, 0.4402997762939914, 0.476780202849561, 0.431679890549044, 0.4058050080964878, 0.3349285667455921, 0.32780808770380077, 0.3630378787410784, 0.3288894508504068, 0.3894756462326645, 0.8865019398969263, 0.8777642399749377, 0.8677721637646819, 0.8679771750208045, 0.8662597978463797, 0.8797927041332093, 0.8498268905991224, 0.17550301420524517, 0.8760641392106238, 0.14113175360709285, 0.22912429865459605, 0.18823774064001852, 0.22911659307139065, 0.1635534711357184, 0.20993772287499946, 0.19270630969436986, 0.17573559282268725, 0.24138243019198813, 0.15513381433373907, 0.20415602522977405, 0.1895398159561994, 0.18671457498000643, 0.19393342542448144, 0.21673453934993658, 0.20620091788079198, 0.19484370270939289, 0.16951453294443586, 0.7245616299145878, 0.4604383960465348, 0.1310846395430284, 0.17442710036919018, 0.5918693074197843, 0.748350454656291, 0.7109071115202039, 0.7378078995829354, 0.729831972662359, 0.7724232170256409, 0.5135685094403655, 0.7887457614797083, 0.4824419396725198, 0.45109513920665034, 0.756621244692556, 0.5780581962071023, 0.7967845077927874, 0.721761372201044, 0.3703577024160375, 0.21139405812287582, 0.16808342858393244, 0.4739649309062067, 0.37320028862979604, 0.12796337885662745, 0.2484395574401287, 0.25186383698174386, 0.33289936365028594, 0.38577778112064376, 0.2575915633917897, 0.4038965701710808, 0.4103998006561983, 0.23817626446625328, 0.27114821987951376, 0.6212278869471508, 0.2057377543326695, 0.27678138009855724, 0.7423868166243919, 0.7545092725386912, 0.7584456259557445, 0.6698203627517887, 0.8030565941973619, 0.8172855859429489, 0.8072917006851881, 0.6061112289481998, 0.6512712098904517, 0.11602221043373828, 0.13954794486377464, 0.12444255682336025, 0.11142630217733562, 0.13119793979358851, 0.106337048808826, 0.11518314027742782, 0.10076083853853002, 0.11925415977360587, 0.25338409278086693, 0.14197667096705735, 0.17820646094266468, 0.2508848018881594, 0.22018269361000276, 0.1790666625597116, 0.40974301070403885, 0.3938797029573817, 0.2750473068386551, 0.4014211289804287, 0.5804338312488493, 0.49053175968989626, 0.33103183596649866, 0.5580807308408906, 0.5123868573014922, 0.4257696614870867, 0.5347395336806554, 0.6637968119393705, 0.25092062262251236, 0.46000659063478067, 0.47937166782687035, 0.42133351519028206, 0.47151534862160693, 0.30990166905518046, 0.6333602003137253, 0.29666640513160636, 0.4944211525213349, 0.20092731414632814, 0.1886771860870312, 0.19673431566559652, 0.21139132626791401, 0.24246598723599977, 0.20379082764013345, 0.18773363525464393, 0.18758590750902282, 0.21439815560271214, 0.4968742050094962, 0.2114624487174015, 0.5377764279450057, 0.2309327999135986, 0.2346154050638869, 0.22910738775533723, 0.19017336842322197, 0.6009521514311122, 0.2362670225610859, 0.8486319026565604, 0.43517916641182697, 0.8541375847288186, 0.17221123450611808, 0.19684646994338262, 0.8984118529476566, 0.1832489723456181, 0.1652141499802754, 0.15522872217334538, 0.8509116516331123, 0.2069023929548296, 0.7958827438926375, 0.16636731703743302, 0.6681279215539735, 0.20727405624889794, 0.1259365199964868, 0.20795980938017844, 0.205527300846294, 0.19678490187107978, 0.1807224170937729, 0.1717793997242525, 0.19147901703000425, 0.17968745304997336, 0.1813042038271233, 0.17311073121596932, 0.18996272473974973, 0.19232314015043506, 0.09185522381262146, 0.08539117751366088, 0.08469874286263801, 0.08790948275793542, 0.09767938910346652, 0.09074662227238384, 0.09203674484283642, 0.09096170190753983, 0.07891689762883558]}, "mutation_prompt": null}
{"id": "4b88f2c7-ded7-47ff-af90-b8c1c1200607", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.5) if self.adaptive_scaling else self.F  # Change: Adjust F_dynamic upper bound\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Further refine the mutation strategy by adjusting the scaling factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 71, "fitness": 0.4401812114454636, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "b3ff3c47-1682-439a-b197-e121837c203a", "metadata": {"aucs": [0.8506327734844734, 0.831959813487868, 0.8604882495590795, 0.848275538184136, 0.848624142710194, 0.8500283184043776, 0.8445219956257622, 0.8664105156828715, 0.8420183324266773, 0.7220139074763045, 0.7215965388674249, 0.7370443040947336, 0.7323018134406947, 0.7230047796888435, 0.7207099964530359, 0.7236340642750752, 0.7172336848362293, 0.7447204439651642, 0.17399189482420518, 0.17820612887462595, 0.12563196020978706, 0.2657554665060735, 0.21468609124715876, 0.15406472113533942, 0.2284862189746013, 0.3130742716731274, 0.1602432330705318, 0.15011553828173296, 0.12271955147797975, 0.14171884556646852, 0.12400028983677003, 0.13604362731625774, 0.1323530031005854, 0.1167615954797997, 0.13259546954844825, 0.11569501263089954, 0.9449799095187774, 0.9221806066353062, 0.9307211368325116, 0.9726492469558259, 0.9787276710921639, 0.9627940261626118, 0.9776773371002039, 0.9506271112125159, 0.9601520230057214, 0.6038658497373084, 0.6261238052499711, 0.5857464651798612, 0.5302484322311563, 0.5703581332591445, 0.4946589450782922, 0.5370205078858069, 0.4932283604343767, 0.5270686958930462, 0.7870785978255184, 0.8186219905455205, 0.8632841506476853, 0.8440625072414611, 0.8068238946124459, 0.8398727746346287, 0.8129773717912081, 0.8122732105876185, 0.8127800248774842, 0.26432725265854196, 0.17374923608950432, 0.21822020397731934, 0.24626367651011483, 0.28408310076871324, 0.25653603968262984, 0.23059931119568045, 0.15581035134927423, 0.12578266439369412, 0.1647920155089858, 0.15352741396857705, 0.1281095429990874, 0.2099739805856745, 0.16638807568639113, 0.1918123633905392, 0.19662054509586646, 0.1564394732535046, 0.6037043355371972, 0.655136957127179, 0.6558359194936795, 0.7162280947950759, 0.6888088488990396, 0.6727095620560144, 0.648480026916063, 0.6659537599111227, 0.6317886964764405, 0.6736668906243939, 0.7452215299054004, 0.6976820224739286, 0.7666455932983265, 0.7717998377536329, 0.7628580779489496, 0.636476539374264, 0.7804047837624467, 0.7631242647186453, 0.8002531764671537, 0.059247513305999755, 0.18837068177828387, 0.308139708957623, 0.5352379053912864, 0.36203110084019285, 0.22348403821300555, 0.3008510162346175, 0.11951750966460095, 0.10146946646204758, 0.5798173367315285, 0.5946034197363261, 0.5805234178949077, 0.576379637072865, 0.3733546773523867, 0.5013687716605648, 0.5291441212710936, 0.5477414332154078, 0.5620819065792804, 0.8206985800795364, 0.7220853963323934, 0.8297376396733966, 0.8053281222821216, 0.8218615312997066, 0.8234760080826262, 0.8228761288996141, 0.7847448205711016, 0.8226942677389449, 0.11234483523593009, 0.12456737733229895, 0.09691865821138235, 0.08997641373733223, 0.1302031176106231, 0.1291244476203528, 0.18911160137098948, 0.17271856980826217, 0.1282557030873016, 0.13344100863523722, 0.14939778999313336, 0.17097623988424826, 0.15689513250824327, 0.4671913910231906, 0.20948038548991044, 0.2010320199289386, 0.1400469307882406, 0.2839006316514704, 0.5208112448205244, 0.4856660100654634, 0.5460594398868936, 0.5325905711530992, 0.5107779442134153, 0.5227318843475051, 0.5260093142208386, 0.5263646562607991, 0.5469231048821355, 0.5158310494988898, 0.4276115299888861, 0.41004964529564414, 0.4258066927950376, 0.5026696579335332, 0.3878606486569617, 0.3108355922240249, 0.4120250644689797, 0.36583038084817554, 0.21550020938868142, 0.222865707770889, 0.17824119279390815, 0.18673338750055557, 0.18805099478655918, 0.2157303141794441, 0.19415148754872524, 0.22513564272445097, 0.22015144095520933, 0.6071410647387652, 0.22651937779923115, 0.2712007360408909, 0.41995987538021096, 0.21420186779090422, 0.2128820942886318, 0.2212328442395176, 0.20595563230957037, 0.3509764315166811, 0.7530767356744492, 0.7991657372624988, 0.19598820929572447, 0.16620863219617554, 0.18743266084591137, 0.7078963069401742, 0.17188707539257264, 0.7614586514090368, 0.6255731524925549, 0.20479917522677005, 0.7735583589767279, 0.20903947826594627, 0.2020738720648354, 0.19881606393881412, 0.204915904011584, 0.20689025063465283, 0.2078979413246338, 0.812385709842826, 0.19350263569095016, 0.1946799937355922, 0.18766282093729791, 0.18802972631118753, 0.2060526477902065, 0.17431030608873532, 0.19188788110045307, 0.1841364366999585, 0.19221127828789153, 0.08792293858212885, 0.07571052927536148, 0.08298234607655164, 0.07866346216226305, 0.09464426535067527, 0.07853839309466215, 0.0848033991970647, 0.08726469316192875, 0.07376177503061865]}, "mutation_prompt": null}
{"id": "645b1121-d8ca-4b5b-892c-64b101d10d4a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.5) if self.adaptive_scaling else self.F\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n            if len(self.successful_crs) > 0:  # Change: Consider history of CRs for adjustments\n                self.CR = np.mean(self.successful_crs)\n            \n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        # Change: Adjust CR calculation to consider historical adaptation\n        self.CR = np.median(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the mutation and crossover adaptation by introducing history-based parameter tuning to improve convergence.", "configspace": "", "generation": 72, "fitness": 0.43093518115895285, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.27.", "error": "", "parent_id": "4b88f2c7-ded7-47ff-af90-b8c1c1200607", "metadata": {"aucs": [0.8231224912883202, 0.8510942678573883, 0.855273053479285, 0.8278861437026703, 0.840165921038229, 0.8592149621702806, 0.8383529079919027, 0.8233002039145181, 0.8533744649824846, 0.7293335558402563, 0.7157427432583369, 0.6939858633142781, 0.7118294164272128, 0.7082099484852078, 0.7049763212092031, 0.7354788957845284, 0.7156430110203023, 0.7250239098628113, 0.09799527235457028, 0.4614051622572648, 0.3814576649211564, 0.5078275369826057, 0.4614901692262562, 0.5586850511180093, 0.4195885003816424, 0.23939029398836342, 0.3368036204810554, 0.41076088688518564, 0.23929514988141487, 0.41135054369039015, 0.2148368494125351, 0.24301348771102038, 0.3962543881922662, 0.11128862065648759, 0.46423099669798573, 0.44861192500378055, 0.9389851210726936, 0.947411097880319, 0.9301678442119995, 0.964397100397066, 0.948103024829184, 0.963478067539253, 0.9765671396151836, 0.9563698821825627, 0.9274547652629274, 0.519321204416352, 0.47315369722542056, 0.5388736263656076, 0.44127497160472373, 0.5641855945750579, 0.23523849179402978, 0.46424474921079706, 0.5112415073543655, 0.5551386541182771, 0.8296729469957115, 0.7536101441546166, 0.29887756724401926, 0.8499322250709802, 0.8637237357479988, 0.8012711449320632, 0.7891912663677466, 0.8248298308139274, 0.7980648272851261, 0.21978274970893874, 0.22840081175661386, 0.14848725132977325, 0.24590824954869206, 0.27996485220390677, 0.19743080009224412, 0.20524899044038325, 0.29492442554803044, 0.18347777450956815, 0.14562660983140596, 0.19538365972084826, 0.2815455047880355, 0.20126547831069486, 0.225914506735868, 0.22972975604124757, 0.241100335053551, 0.17478751484365185, 0.2322051116507159, 0.6554749224857941, 0.6832064868352914, 0.37941906080465027, 0.686959296116586, 0.6250618191474446, 0.6402186450147112, 0.6959363590097061, 0.6301773266215435, 0.6136526002468987, 0.7755448785422235, 0.7883412347373586, 0.7519217896871875, 0.754203142044675, 0.7721119421211136, 0.710815453906588, 0.7717898470603181, 0.7543135577362534, 0.7237065790712907, 0.17652779771863225, 0.10167360351605059, 0.13707388371505136, 0.5641399999454754, 0.42414336554617116, 0.4060620278299536, 0.13604748328102, 0.29304232036040845, 0.22106017607523165, 0.587751209967911, 0.5696944526393659, 0.5291406093126131, 0.5507556697887764, 0.6046998265593269, 0.6005855701342921, 0.12304916225242346, 0.6105771824805932, 0.10136080725211938, 0.838977218986311, 0.7513073878110765, 0.8373946240703167, 0.7910958294289111, 0.8114609823248525, 0.8167726903169831, 0.731828483922162, 0.48667565111496847, 0.8136163036586299, 0.12023131464515535, 0.10386852229924648, 0.1023904047677403, 0.09640250712704923, 0.11025306772113586, 0.11378255414675009, 0.09199516489239756, 0.09326486898743747, 0.12049247451445955, 0.1943588242749934, 0.13442482259171606, 0.1640510560355266, 0.12957135140784048, 0.12953085100093464, 0.13426179220695889, 0.1990214836325256, 0.13514851193499966, 0.23962788234453003, 0.5512255691020103, 0.3222581241128659, 0.4592729246028202, 0.40778140100080984, 0.3338956088198741, 0.5319929020252998, 0.4402900225556402, 0.5672936618325162, 0.5120725995934668, 0.43188522733275514, 0.4332480976420209, 0.23618237508887308, 0.40665264904611864, 0.22858230027850912, 0.442422450526504, 0.49763123018965993, 0.4710184167930883, 0.38419511040949594, 0.18930630687906214, 0.20110236403526016, 0.1860238944687942, 0.216973602046446, 0.1879614356560222, 0.20155234068727468, 0.19553375485429136, 0.20436313198336964, 0.2151020220033335, 0.21384170426901117, 0.4451839081189062, 0.22208011643602754, 0.22772520238958704, 0.20998155467938462, 0.2059298951278714, 0.22730992331837407, 0.1870837525059792, 0.2317884911565239, 0.17814105842078365, 0.7876997829981649, 0.16216468653895577, 0.19477748818382257, 0.780026702430541, 0.16469469276751136, 0.48188079159524855, 0.5962620886899048, 0.8126013265202146, 0.2982425629963238, 0.8507856709052363, 0.1670764621416967, 0.16555338399366049, 0.16340117327510506, 0.20298640908794752, 0.2091821609966884, 0.2059245278477697, 0.20447147987567438, 0.175558256383068, 0.19177848605078485, 0.18386833793516966, 0.18400119416339855, 0.17772948313549275, 0.18175666746976893, 0.18481155023356166, 0.1945711170383292, 0.1829677440753913, 0.08475075559242229, 0.08122576176526197, 0.06970378206746741, 0.06842410777984498, 0.0806595405073629, 0.08224696919512697, 0.07704589947667206, 0.08461402354535208, 0.08936340550419986]}, "mutation_prompt": null}
{"id": "e09b2955-aa5a-405c-8370-14e8d97daf8a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.9, 1.8) if self.adaptive_scaling else self.F  # Change: Adjust F_dynamic bounds\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the exploration by adjusting scaling factor dynamically and introduce selective mutation for diversity.", "configspace": "", "generation": 73, "fitness": 0.4090020997866056, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "4b88f2c7-ded7-47ff-af90-b8c1c1200607", "metadata": {"aucs": [0.8055628862771183, 0.8138777720989014, 0.7701716001555527, 0.7992973243514515, 0.8207365138825653, 0.799687346334101, 0.7887736022898939, 0.8173145155220078, 0.8038143789722956, 0.6320777913426818, 0.6353252364885251, 0.663884131694313, 0.648401615167387, 0.6443458482616776, 0.6124247828982257, 0.6624322354855348, 0.6133263449836784, 0.6608472206715835, 0.11415768366306434, 0.13457708060149087, 0.12317008758186732, 0.11854453226384631, 0.23636634660982425, 0.16304595751135165, 0.16479330838442563, 0.12893712151998005, 0.12014045073374202, 0.10915851196578974, 0.1340562365436524, 0.11850689663840552, 0.1171716215588876, 0.09863183914601681, 0.16580059562137972, 0.11773295873914891, 0.15061046399535483, 0.1500933478325116, 0.9651248955652855, 0.9775867240317312, 0.9831200871724399, 0.9693011753902183, 0.9576291436045611, 0.9752324860422837, 0.9736627151998739, 0.952458184754569, 0.9556779715529179, 0.5270555972251788, 0.5483755570215649, 0.5071849807807829, 0.5002701515928729, 0.5035596208588284, 0.4807282627052837, 0.5683883614883509, 0.5623880752191553, 0.5131917545976534, 0.8063170547362293, 0.7140234140980136, 0.7933188151110704, 0.819982126215458, 0.7330861090008507, 0.773505719111538, 0.7599520069293078, 0.7232149046480592, 0.7645500023211271, 0.44501584899449653, 0.5670473281207957, 0.42585345105236194, 0.2798161516680653, 0.29824478897436146, 0.36496734942961606, 0.5416715531609061, 0.524574828887276, 0.3764018736085504, 0.4373604471934427, 0.5350149443309433, 0.12316639788032568, 0.47587389936102487, 0.4043711872015914, 0.27752901034003685, 0.4897538048611547, 0.19490069438417845, 0.5904943696628877, 0.4949771135314227, 0.5643395023909284, 0.5454188663535127, 0.5685237298366532, 0.5170413999691446, 0.5392493375561143, 0.614371087380726, 0.5489643779891213, 0.5771090543749982, 0.6914306452838926, 0.6363724470569012, 0.6605628781994073, 0.7036499798056102, 0.6120728809596498, 0.7014785622242412, 0.6988962348774037, 0.7093218664542027, 0.7100805195211785, 0.17191406367942852, 9.999999999998899e-05, 0.11412163132178554, 0.42468484829258446, 0.16757120209717435, 0.43390667381614234, 0.1318332534560419, 0.1286055372420929, 0.06680265568204102, 0.5165499052994798, 0.4729382589048575, 0.4717054812681386, 0.46109355738069235, 0.46526299614581546, 0.40989910825764575, 0.46144039632689526, 0.4266535812761484, 0.45174997418154295, 0.7777942977103549, 0.7503503164972881, 0.7464756545776565, 0.7751707197454469, 0.7917037494010842, 0.7638307901783068, 0.7544864350992437, 0.7546455183453095, 0.7625253835272627, 0.12105153832563975, 0.08822551637866849, 0.06994685480791651, 0.10590075455174575, 0.09321874078711989, 0.10428743436456711, 0.09175521049407676, 0.10084236896438847, 0.12646115689013515, 0.1882082871474553, 0.14169954629639836, 0.15993891015163464, 0.2496366779229987, 0.14336391214940414, 0.1958731085853871, 0.1852589525363334, 0.1424141511449497, 0.2213497831918917, 0.4105480421534319, 0.3827732079082451, 0.38287922292748133, 0.35031960427386655, 0.34356900024214776, 0.39236624266007325, 0.3520117996629345, 0.35766116619825217, 0.43205880095810856, 0.25358348632673755, 0.2988665959831954, 0.34556482628497875, 0.2941785545913017, 0.32367382161614866, 0.2718111376294341, 0.34287138060770617, 0.3806046244736775, 0.38357075744499713, 0.17605118714721668, 0.17549643476383225, 0.19318639286278128, 0.1841658745866227, 0.1921668645450717, 0.20689695739430047, 0.17758797391759107, 0.19129971747400187, 0.1815756177916007, 0.34557127071745275, 0.33221816481745925, 0.18895627941315674, 0.34399610652454693, 0.18778560446312353, 0.37479086772290515, 0.31605887998605775, 0.23523084898827207, 0.38775732582381783, 0.1902924660081884, 0.653631236620812, 0.7679267568683614, 0.16004592297648612, 0.1766807027166828, 0.7171596970389869, 0.16871607489497942, 0.1734075330377569, 0.20197619434318625, 0.1818027126828995, 0.20515943101622158, 0.20239390327821882, 0.16126836710749504, 0.6765304755078143, 0.711819610923683, 0.12615673075374012, 0.20906826927546207, 0.20746014564806725, 0.2019331632824709, 0.18412796511298912, 0.18192573035131943, 0.18326409377967712, 0.2002717717831829, 0.1737585505141136, 0.190283630553295, 0.19487729816737043, 0.17721509217528475, 0.07793151222500383, 0.0650344979416928, 0.08195996171967657, 0.07280875553699917, 0.07999712560078187, 0.06866735545275027, 0.07181644323732506, 0.08362087416278197, 0.07790946868679605]}, "mutation_prompt": null}
{"id": "cdac9e5b-c813-44ba-bcbe-52c8fd8bf96f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.5) if self.adaptive_scaling else self.F  # Change: Adjust F_dynamic upper bound\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.15)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce an adaptive mutation probability to balance exploration and exploitation dynamically.", "configspace": "", "generation": 74, "fitness": 0.4401812114454636, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "4b88f2c7-ded7-47ff-af90-b8c1c1200607", "metadata": {"aucs": [0.8506327734844734, 0.831959813487868, 0.8604882495590795, 0.848275538184136, 0.848624142710194, 0.8500283184043776, 0.8445219956257622, 0.8664105156828715, 0.8420183324266773, 0.7220139074763045, 0.7215965388674249, 0.7370443040947336, 0.7323018134406947, 0.7230047796888435, 0.7207099964530359, 0.7236340642750752, 0.7172336848362293, 0.7447204439651642, 0.17399189482420518, 0.17820612887462595, 0.12563196020978706, 0.2657554665060735, 0.21468609124715876, 0.15406472113533942, 0.2284862189746013, 0.3130742716731274, 0.1602432330705318, 0.15011553828173296, 0.12271955147797975, 0.14171884556646852, 0.12400028983677003, 0.13604362731625774, 0.1323530031005854, 0.1167615954797997, 0.13259546954844825, 0.11569501263089954, 0.9449799095187774, 0.9221806066353062, 0.9307211368325116, 0.9726492469558259, 0.9787276710921639, 0.9627940261626118, 0.9776773371002039, 0.9506271112125159, 0.9601520230057214, 0.6038658497373084, 0.6261238052499711, 0.5857464651798612, 0.5302484322311563, 0.5703581332591445, 0.4946589450782922, 0.5370205078858069, 0.4932283604343767, 0.5270686958930462, 0.7870785978255184, 0.8186219905455205, 0.8632841506476853, 0.8440625072414611, 0.8068238946124459, 0.8398727746346287, 0.8129773717912081, 0.8122732105876185, 0.8127800248774842, 0.26432725265854196, 0.17374923608950432, 0.21822020397731934, 0.24626367651011483, 0.28408310076871324, 0.25653603968262984, 0.23059931119568045, 0.15581035134927423, 0.12578266439369412, 0.1647920155089858, 0.15352741396857705, 0.1281095429990874, 0.2099739805856745, 0.16638807568639113, 0.1918123633905392, 0.19662054509586646, 0.1564394732535046, 0.6037043355371972, 0.655136957127179, 0.6558359194936795, 0.7162280947950759, 0.6888088488990396, 0.6727095620560144, 0.648480026916063, 0.6659537599111227, 0.6317886964764405, 0.6736668906243939, 0.7452215299054004, 0.6976820224739286, 0.7666455932983265, 0.7717998377536329, 0.7628580779489496, 0.636476539374264, 0.7804047837624467, 0.7631242647186453, 0.8002531764671537, 0.059247513305999755, 0.18837068177828387, 0.308139708957623, 0.5352379053912864, 0.36203110084019285, 0.22348403821300555, 0.3008510162346175, 0.11951750966460095, 0.10146946646204758, 0.5798173367315285, 0.5946034197363261, 0.5805234178949077, 0.576379637072865, 0.3733546773523867, 0.5013687716605648, 0.5291441212710936, 0.5477414332154078, 0.5620819065792804, 0.8206985800795364, 0.7220853963323934, 0.8297376396733966, 0.8053281222821216, 0.8218615312997066, 0.8234760080826262, 0.8228761288996141, 0.7847448205711016, 0.8226942677389449, 0.11234483523593009, 0.12456737733229895, 0.09691865821138235, 0.08997641373733223, 0.1302031176106231, 0.1291244476203528, 0.18911160137098948, 0.17271856980826217, 0.1282557030873016, 0.13344100863523722, 0.14939778999313336, 0.17097623988424826, 0.15689513250824327, 0.4671913910231906, 0.20948038548991044, 0.2010320199289386, 0.1400469307882406, 0.2839006316514704, 0.5208112448205244, 0.4856660100654634, 0.5460594398868936, 0.5325905711530992, 0.5107779442134153, 0.5227318843475051, 0.5260093142208386, 0.5263646562607991, 0.5469231048821355, 0.5158310494988898, 0.4276115299888861, 0.41004964529564414, 0.4258066927950376, 0.5026696579335332, 0.3878606486569617, 0.3108355922240249, 0.4120250644689797, 0.36583038084817554, 0.21550020938868142, 0.222865707770889, 0.17824119279390815, 0.18673338750055557, 0.18805099478655918, 0.2157303141794441, 0.19415148754872524, 0.22513564272445097, 0.22015144095520933, 0.6071410647387652, 0.22651937779923115, 0.2712007360408909, 0.41995987538021096, 0.21420186779090422, 0.2128820942886318, 0.2212328442395176, 0.20595563230957037, 0.3509764315166811, 0.7530767356744492, 0.7991657372624988, 0.19598820929572447, 0.16620863219617554, 0.18743266084591137, 0.7078963069401742, 0.17188707539257264, 0.7614586514090368, 0.6255731524925549, 0.20479917522677005, 0.7735583589767279, 0.20903947826594627, 0.2020738720648354, 0.19881606393881412, 0.204915904011584, 0.20689025063465283, 0.2078979413246338, 0.812385709842826, 0.19350263569095016, 0.1946799937355922, 0.18766282093729791, 0.18802972631118753, 0.2060526477902065, 0.17431030608873532, 0.19188788110045307, 0.1841364366999585, 0.19221127828789153, 0.08792293858212885, 0.07571052927536148, 0.08298234607655164, 0.07866346216226305, 0.09464426535067527, 0.07853839309466215, 0.0848033991970647, 0.08726469316192875, 0.07376177503061865]}, "mutation_prompt": null}
{"id": "7452f096-12d6-4847-b166-66f6e16e908b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.65, 1.45) if self.adaptive_scaling else self.F  # line 1: Adjust F_dynamic bounds\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.85, 1.10)  # line 2: Narrow CR range slightly\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 12 * self.dim))  # line 3: Slightly increase population scaling factor\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic mutation strategies by incorporating success history for improved exploitation-exploration balance in Differential Evolution.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 53 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 53 is out of bounds for axis 0 with size 50')", "parent_id": "4b88f2c7-ded7-47ff-af90-b8c1c1200607", "metadata": {}, "mutation_prompt": null}
{"id": "b5ef2cb7-ec03-4442-b74b-be0325a879c7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.4) if self.adaptive_scaling else self.F  # Change 1: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Change 2: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n            self.adaptive_scaling = improvement_rate > 0.5  # Change 3: Adjust adaptive scaling condition\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.6 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change 4: Adjust F range\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # Change 5: Adjust CR range\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Refine the scaling factor and crossover rate based on success rate to dynamically adjust exploration and exploitation more effectively.", "configspace": "", "generation": 76, "fitness": 0.42648400412259335, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "4b88f2c7-ded7-47ff-af90-b8c1c1200607", "metadata": {"aucs": [0.8123435484982979, 0.8385841649939618, 0.8390358283542154, 0.8245615417538277, 0.8445137053928453, 0.826436959658723, 0.8273085530588273, 0.8147624064394157, 0.8322358822810196, 0.6838520043622742, 0.7103083234867105, 0.6836306812217438, 0.681928008819378, 0.6848309952856249, 0.689095609238249, 0.7011735117860034, 0.6863557062302748, 0.6802794500295772, 0.3062398701206732, 0.1349704013293569, 0.308857599683397, 0.19583865000277922, 0.18909660862033395, 0.18044824489165423, 0.23465761329029167, 0.13028232847347576, 0.11873528535111377, 0.11870211883323611, 0.1515880795100094, 0.24445893702034227, 0.12364097382615125, 0.1200800026638772, 0.10334906341367056, 0.1406946797338705, 0.10444685397709286, 0.1282428597864702, 0.9224465033813457, 0.962612572966201, 0.9624018290629489, 0.9615219694363605, 0.9335950727078459, 0.9408490391680936, 0.9505407986271255, 0.9691832294016746, 0.9462968470836636, 0.5482065816842661, 0.5507523200575428, 0.5071631308965963, 0.5041619905311516, 0.47103644582452164, 0.5175633032517226, 0.5282077081632437, 0.5084753879745619, 0.5863316248204784, 0.8075065414896903, 0.26237637650792034, 0.8736211598726273, 0.8510756031197595, 0.8485944975294354, 0.8277434859381465, 0.28430466251763864, 0.7258741598539242, 0.8321541936647713, 0.4155552622251848, 0.49554095872883797, 0.5354046130438301, 0.1957395492650823, 0.252756609355131, 0.13085430448496171, 0.28267780481229643, 0.3918644472412749, 0.3752952073009185, 0.05159681359688617, 0.4687939809657753, 0.16774279001026993, 0.6067275505486562, 0.2663792990563245, 0.3149454306090308, 0.26801168052208224, 0.37340151493892204, 0.21426439653141693, 0.6526763070734374, 0.639740068449788, 0.6256381986585655, 0.6801977428296757, 9.999999999998899e-05, 0.6977268025775321, 0.6659643590019187, 0.6379318244867629, 0.6675981609052897, 0.5686219676425626, 0.7228630765123194, 0.7488414087868205, 0.7009740086263566, 0.04331845288756153, 0.7486445860157418, 0.7409756284324152, 0.5913577428513888, 0.7332787295122423, 0.010442037245152136, 0.17504429688601908, 0.16834911232670113, 0.2808518965793706, 0.33437653785336163, 0.5034922509580273, 0.15521559088158265, 0.05124771469707412, 0.11678679038185036, 0.5044153368301241, 0.5406923837858748, 0.5418140283375781, 0.5244268186447788, 0.5515271410951785, 0.5642577149010277, 0.5820005981783529, 0.6084323122393724, 0.5527345266078758, 0.8108258492357996, 0.7931659012353315, 0.7851827789451731, 0.7955430929713714, 0.8080851499972789, 0.8072935894550897, 0.8229355672615088, 0.812760870381528, 0.8145386455765296, 0.12783898562027918, 0.10591583430974838, 0.09153639644823763, 0.0987978684206855, 0.09868612571398627, 0.10208787705807698, 0.08911898592772449, 0.10024620968335185, 0.09947122697838973, 0.1665098634448373, 0.12383414517410296, 0.10851962508330415, 0.16588551116015082, 0.15731851117777385, 0.13814288433517263, 0.14160329311649966, 0.13043430182325955, 0.15675325539123264, 0.2790335876366383, 0.41667571233833123, 0.34495577806198696, 0.43807402980527244, 0.4476851100464546, 0.34371224671532485, 0.4976539267280943, 0.4221413246481138, 0.4850190339561147, 0.33421987210427373, 0.3564618939417571, 0.21763523028601517, 0.23170588264273762, 0.2494969504182123, 0.28880611699815284, 0.41346199863360056, 0.31635656885639496, 0.4492228434034037, 0.17562487104839164, 0.18639871415442444, 0.20243165479892133, 0.1941607000951091, 0.1902276062123468, 0.18643966441966708, 0.18089904230756015, 0.19246896715440576, 0.18799648864810037, 0.18646557998686963, 0.5140411948262446, 0.2238405579742595, 0.3255211858478535, 0.20698404897514533, 0.1969635812677143, 0.27726696813679996, 0.36544093737710104, 0.20642362896935174, 0.641467084841776, 0.8114781421892759, 0.8510272324085751, 0.7617428999926978, 0.7913551774882225, 0.7251646803223968, 0.18692251653559677, 0.278546928265776, 0.1801669799553991, 0.7707839375806801, 0.7917700851960059, 0.20607836357489573, 0.16088832708436385, 0.7680103394542661, 0.7552522334350894, 0.2097308017870001, 0.7669491564695305, 0.20915392452370885, 0.1734304646881656, 0.20346644201667619, 0.18065483830762497, 0.1753429977628661, 0.1910053686379921, 0.18111921422284372, 0.1645777155646101, 0.17212853088075408, 0.18043102751942441, 0.07506406124807874, 0.08353641638836273, 0.0776642145917894, 0.08142861864205009, 0.07495071656718699, 0.08033552761940521, 0.08600080854402004, 0.08019457807306263, 0.08750623888384668]}, "mutation_prompt": null}
{"id": "f024b706-e2fd-41c2-999b-9ff58f4f7a4b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.5) if self.adaptive_scaling else self.F\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive scaling by refining dynamic crossover rate adjustment to improve convergence stability.", "configspace": "", "generation": 77, "fitness": 0.44772342548798527, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "4b88f2c7-ded7-47ff-af90-b8c1c1200607", "metadata": {"aucs": [0.8543363012124203, 0.8586236761375707, 0.8343884914162286, 0.8250975293009646, 0.8427310499584091, 0.8459933513456739, 0.8545912620370781, 0.8323760205942284, 0.8311467927390943, 0.6977604353518521, 0.7366317101435382, 0.7246550216624555, 0.7075987533129149, 0.7124416747080811, 0.7105237492937526, 0.7251721179761266, 0.6956667686589788, 0.6956112194251949, 0.3064674927269839, 0.4616532177536502, 0.2504580517389411, 0.2190172651532467, 0.37358158954972864, 0.3827844134219718, 0.4096765949085942, 0.25255007171129396, 0.18363245812409823, 0.28361518416041065, 0.2388455752438312, 0.13523175473291138, 0.2649190450779303, 0.25301022531157347, 0.15021903167641648, 0.18639400394594807, 0.14276548544939682, 0.15456504207551347, 0.9703889940194231, 0.9705937976721676, 0.9523226378432974, 0.9501773712776781, 0.9681157239265817, 0.9711271663407182, 0.9276127222007439, 0.965011484881939, 0.9035295748143115, 0.6061811157550089, 0.5088161977247023, 0.5412932068778253, 0.5482942877852799, 0.45149208658780504, 0.3646369341823156, 0.45816448742376004, 0.5746039208662685, 0.5514573690713982, 0.8120338531325964, 0.830653684707264, 0.8119517375356297, 0.8264408493146359, 0.8545415231715803, 0.798237461985482, 0.8659168742890047, 0.8503671165709851, 0.8588202045859143, 0.15367135788693354, 0.185987379905462, 0.6228640140769778, 0.24024891123602943, 0.15297515436614229, 0.19367927500335969, 0.33178073835067257, 0.20846515944186272, 0.2054913894174658, 0.11788299498672639, 0.01626566446141664, 0.2022693340852345, 0.25380432144487397, 0.24154815223983783, 0.6481543013610211, 0.22828884408952688, 0.2441627229788753, 0.1164823106873637, 0.667379226885892, 0.6918151528801821, 0.6908855503654395, 0.6931349150964043, 0.6975497337721056, 0.7266597748111505, 0.6743854794344661, 0.6811319833520827, 0.6958164231760197, 0.7889024730701362, 0.6464892279513379, 0.7359017940824519, 0.7450711123895801, 0.6917300335500591, 0.7526593470232865, 0.8139421714515589, 0.7166073227691764, 0.7796503111386942, 0.22052777619204378, 0.29022087378439343, 0.28806617920678634, 0.6329128809647173, 0.2271004077495774, 0.5157601327448937, 0.16959399641557016, 0.17833603529645659, 0.14893892655400565, 0.4224035736736961, 0.5857827944272447, 0.6050327248390424, 0.5747640333734644, 0.5699828447952647, 0.6091678736070121, 0.5820221802458266, 0.5461497723776435, 0.5915744473561748, 0.8037656963336673, 0.8153734616678228, 0.8024826093329143, 0.8183426416778056, 0.8233251449082426, 0.8045483210148292, 0.8095799813212982, 0.8103583859335883, 0.8375140953556536, 0.12092032939283248, 0.101552126653774, 0.09439931321104345, 0.10109363224022272, 0.13679818665085386, 0.09052926175301435, 0.13571518028858431, 0.09707140425536831, 0.12285041251584061, 0.2806437036826308, 0.1736230521427764, 0.18742031983623886, 0.17188039857536874, 0.2672739586640639, 0.133176664294834, 0.16139267751992448, 0.1630189720697226, 0.1462215235445401, 0.5297089627676512, 0.5775761531118284, 0.5544397698107923, 0.5166182582878779, 0.5452825394292626, 0.5155329407764311, 0.5787804919867738, 0.50157273077925, 0.5493178002437217, 0.45332407711426725, 0.48169798755425497, 0.3737397443550151, 0.4253597037662157, 0.4059745233968649, 0.42743127572139605, 0.49337621207593907, 0.4272303850057215, 0.3999325990140945, 0.20747966207356028, 0.19201196185750502, 0.19360260276790486, 0.20916896988020828, 0.20848800294685066, 0.20489060661090963, 0.18233997781019784, 0.18887692889431873, 0.1923693215901472, 0.19188522950671938, 0.1912592665290903, 0.22257822936161553, 0.2749276382240151, 0.2249190218842596, 0.21785196479055435, 0.45142100963644216, 0.38867938520661005, 0.23328653661938115, 0.7982434966530987, 0.2059027384406814, 0.8582039873915401, 0.18532647634354749, 0.8037456751692666, 0.16525071340225073, 0.19962436776755055, 0.7489455010377527, 0.8708390420118758, 0.1672254732919377, 0.16566395797972255, 0.20699752146076356, 0.20006584941909633, 0.16397916990414763, 0.7700923282693009, 0.15189510419173402, 0.12609485984808977, 0.1638208090377884, 0.18127985244083766, 0.19731499962316135, 0.19596880379156223, 0.19413270573130426, 0.21860435837621472, 0.18729763655094156, 0.17845872774864713, 0.1809030821258656, 0.18523438925424307, 0.07952378702649787, 0.09153258936150155, 0.07659135759514069, 0.08183738383120476, 0.09180409716730287, 0.08157853363342948, 0.07795438500016061, 0.0865370533691816, 0.08639883952743965]}, "mutation_prompt": null}
{"id": "5f51eb4c-59c9-4820-afc3-5328858d6e1e", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n        self.history = []\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.5) if self.adaptive_scaling else self.F\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n                    self.history.append(trial - population[i])  # Update: Record successful trial vector\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            if len(self.history) > 20:  # Update: Use history to influence population size\n                improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n                self.population_size = int(max(4, improvement_rate * 10 * self.dim * 0.8))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.history = []  # Clear history after updating parameters", "name": "EnhancedDifferentialEvolution", "description": "Introduce a history-based crossover and mutation strategy to enhance exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.39563468546540387, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.28.", "error": "", "parent_id": "f024b706-e2fd-41c2-999b-9ff58f4f7a4b", "metadata": {"aucs": [0.9023990942141669, 0.8985438140312955, 0.889942098662033, 0.9034289347066446, 0.7148926383058519, 0.7739502324188221, 0.896514632288578, 0.8734575389985545, 0.8902460123363494, 0.8125142076026508, 0.7718688627586621, 0.7781497038266965, 0.8184325328499642, 0.8279600982331696, 0.3672613135625026, 0.8293550327696113, 0.8213555520683582, 0.7949635552334704, 0.49659597781597153, 0.548613437209325, 0.16684077800958708, 0.16524060670052332, 0.5792989338558533, 0.5283764840640965, 0.5800359259129455, 0.49475464803489844, 0.6024433059417944, 0.16510386325354198, 0.1348041003661632, 0.12968404541281053, 0.11753777484801797, 0.16994756636192065, 0.15665829472227, 0.4394296814840939, 0.36508118813814183, 0.166257835377025, 0.9336645461452567, 0.9238132875991099, 0.9600083095590807, 0.9134725521590275, 0.9604766329566994, 0.887904374504686, 0.9287114262229497, 0.953578282396192, 0.9365300642873254, 0.21636336884188145, 0.3635640892406118, 0.3984362696021898, 0.6624554110487336, 0.1806605626650304, 0.25110145456339383, 0.3493933261862463, 0.35480738854380056, 0.2633100752382389, 0.877915018445031, 0.3828668828664291, 0.8929217832540404, 0.9320340848910784, 0.8805498678236084, 0.898428097826757, 0.9121053368888985, 0.3526614335068211, 0.8938723751378198, 0.16151730090953897, 0.16158617426179211, 0.144402451531782, 0.1997025836895342, 0.1674184909455354, 0.19550708604142675, 0.15533223340624824, 0.26296333524265414, 0.24935734665866194, 0.010078815277554942, 0.17898290872299016, 0.2034232789591902, 0.12796276777432214, 0.14537631519614058, 0.381327231769783, 0.16971775514326182, 0.22818123041794447, 0.25501022215406266, 0.4080200765929981, 0.24813119401325345, 9.999999999998899e-05, 0.23436863922886808, 0.08939083081908905, 0.36303624137962565, 0.16791151431572238, 0.1774899067574648, 0.1452770301087326, 0.5862781223397291, 0.3188943721235331, 0.28764091733032926, 0.284791913848508, 0.35795003951075044, 0.803149351408255, 0.14224944762153013, 0.2765811171761111, 0.14465559860499455, 0.18613635741018353, 0.2007850604634016, 0.08434815553297959, 0.16001214511705253, 0.12890245832122404, 0.198112603988016, 0.1489785609904024, 0.2596156311763581, 0.14786018299542703, 0.31148561785757667, 0.1832642910756911, 0.10047815790948211, 0.2854663789588475, 0.43880296112084993, 0.32750006858474423, 0.40082222243446153, 0.36908147052090146, 0.19183486294186036, 0.4323460357941046, 0.5785886038718107, 0.773055708085045, 0.6277833522460288, 0.6374809362638585, 0.5491883453967038, 0.7739100993728195, 0.7306844692805325, 0.7033984742553518, 0.16032187693006072, 0.09990762868766656, 0.09719294022294112, 0.12736419749738903, 0.1000211913484732, 0.10127651247256142, 0.10025096156119673, 0.12816273669021683, 0.14686621339127692, 0.15409705813909025, 0.32056520888573903, 0.22425854130349732, 0.1814571462012129, 0.22815944676027067, 0.17832477177136885, 0.22962276010095273, 0.14062735897403633, 0.164230980575373, 0.5222976973548707, 0.5111526486652357, 0.5235467900119025, 0.5655674001056741, 0.3974575658962688, 0.5751708220275784, 0.6857850728915507, 0.622175261336481, 0.5351422212557555, 0.3478401100437941, 0.3319802768585619, 0.3713812933298495, 0.31975940064996866, 0.3409378481477724, 0.36085620720397327, 0.5221886206995048, 0.25112092316258317, 0.4577712353898511, 0.20634198508914958, 0.17728873382602428, 0.18511842034311654, 0.18518285293349135, 0.20442981828987106, 0.19630204873158663, 0.21115931918852582, 0.18280459770335056, 0.19432779714656723, 0.6428554590496471, 0.6977843063260791, 0.7055593659568506, 0.6361522720436574, 0.47707706316081366, 0.61662676733098, 0.23385272429190607, 0.5789929364915737, 0.22822367474383032, 0.8319565521383085, 0.8532351811023351, 0.8076694441187613, 0.1819765014536251, 0.8746539928235297, 0.16555447068227225, 0.8128370425153584, 0.1817418466286762, 0.1642420478828721, 0.8840850453497742, 0.8645502349422448, 0.20701509035359367, 0.16604886706509392, 0.20738779833898002, 0.2067916702819066, 0.11226062120253777, 0.21237251458242212, 0.20938232206022034, 0.20133487706092457, 0.17914194045922527, 0.20545335784979724, 0.18781078514449945, 0.20158518390070712, 0.16188520352573033, 0.1709450143766753, 0.1764447673228271, 0.184188132284284, 0.0943949629532641, 0.08823044033898952, 0.09170290727552999, 0.0754846952910797, 0.07959097240146007, 0.07691468433954818, 0.08985199940002109, 0.08412597115785447, 0.08209219470584705]}, "mutation_prompt": null}
{"id": "c6ed8b4e-4132-4ad5-88e7-60378a10087e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.8, 1.7) if self.adaptive_scaling else self.F\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce minor dynamic adjustment to mutation factor (F) to enhance exploration capabilities.", "configspace": "", "generation": 79, "fitness": 0.43600442466912986, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "f024b706-e2fd-41c2-999b-9ff58f4f7a4b", "metadata": {"aucs": [0.8163210331286045, 0.814698325604023, 0.8238781787710564, 0.8195736391711081, 0.8208912453544284, 0.8451968652153999, 0.8017075376632128, 0.8511230169872823, 0.8228034553796607, 0.6343418651373142, 0.6672598187828618, 0.6672764296638174, 0.6740436989671168, 0.6679098609962186, 0.6721249385969522, 0.6579732977624095, 0.6852233692678725, 0.6495390554468663, 0.10880877565247049, 0.22768653056038024, 0.20187793805238685, 0.3002684450322878, 0.22570482676234382, 0.2208721497225985, 0.20121811371315113, 0.20248799160157738, 0.18765084031291834, 0.17810494052682047, 0.21923535902257774, 0.1770946609756442, 0.13528012107538256, 0.25317756839222605, 0.12704559263270443, 0.21199537925698542, 0.16537817312870662, 0.11218990086320768, 0.9691435866153182, 0.972605086612162, 0.9701978109087582, 0.9739959010009966, 0.9596040608917967, 0.9822153254201995, 0.954568017810983, 0.9562777585889811, 0.9862633899633124, 0.5550752354329835, 0.5311690285259077, 0.5658574096104912, 0.49567580246176635, 0.557987551539558, 0.5506655451705447, 0.5438470612909178, 0.5623008656031703, 0.5656616142616753, 0.7865078215345349, 0.807990683683989, 0.8004799412463477, 0.811916728587873, 0.8155198908850427, 0.8105815142953343, 0.7517333993097095, 0.803655180288329, 0.7600691060555032, 0.2117940568735729, 0.5592699536196697, 0.4697739861765462, 0.12555168188406096, 0.45966476732992645, 0.32814323996261996, 0.5376623654668955, 0.4425153394070962, 0.22366482175999658, 0.03727882447484354, 0.7008423347073771, 0.4809463692044409, 0.41625057152517175, 0.5504356787633433, 0.47850338120874947, 0.55035913839382, 0.4743248938311061, 0.33641863145552675, 0.5887386447759084, 0.6297109779627255, 0.6461143463410735, 0.6406765800471621, 0.6500756490871935, 0.6241984754174588, 0.6625278472835261, 0.5894400536303999, 0.5873337027325445, 0.7517474996966088, 0.6831408409103543, 0.7379147911758602, 0.7193357491051506, 0.7396448065739377, 0.6894242529724897, 0.756865164607748, 0.6827272469903016, 0.7304084912736446, 0.29573628376202765, 0.3137842096353468, 0.3137563506471156, 0.5144317846576525, 0.4989828642583395, 0.1577379020628179, 0.31295242334431406, 0.24837981867895886, 0.28740743539938984, 0.5260953012710792, 0.4523890105597953, 0.501257862670738, 0.4681579571416491, 0.5385942057307938, 0.5452673008315754, 0.48587165737226656, 0.4889907206132039, 0.516753746681341, 0.76837867380477, 0.7883644104336851, 0.7807446568094587, 0.7955191855107426, 0.7826940860378755, 0.794287681934448, 0.778151401042601, 0.7999043032298705, 0.7676765264532209, 0.08686160603574478, 0.10313739945293188, 0.08630822200284671, 0.14149148619009444, 0.08894538696280929, 0.1132917572640263, 0.1039153448719462, 0.11245421668545152, 0.08947318105268731, 0.15581993108120673, 0.12679972135625062, 0.373299154324221, 0.1520578500861668, 0.23429017744411407, 0.2967962649275745, 0.1670674178483037, 0.19515341915922435, 0.19269782561128046, 0.49753733358376795, 0.41880945921134327, 0.40558676066575694, 0.4391108028802122, 0.4410751809376797, 0.44415393163690264, 0.4588166369682172, 0.43603256061775475, 0.37897816877839685, 0.3572156805183062, 0.3986282817095158, 0.3771798258482263, 0.3679251518214878, 0.3211458827170812, 0.33444047883597117, 0.4298955729310585, 0.4323905953899384, 0.40600728081880977, 0.19659231130927224, 0.18249237051933553, 0.1872962137823686, 0.18387321318326033, 0.17573346574305326, 0.18977071774610055, 0.21206673551118405, 0.19597912715219779, 0.19220916673649246, 0.2976989207944689, 0.21047286941621823, 0.19204016085550546, 0.20895543146616924, 0.3442049253812184, 0.23312576097679516, 0.20161512492507072, 0.16844233834486388, 0.18559393095888566, 0.1515154776864951, 0.16694824426013988, 0.8592294309048341, 0.17473067266726627, 0.1936950083706953, 0.13720038491945252, 0.16294752692605396, 0.42257065322674625, 0.4353084821108383, 0.7986722627776397, 0.2037080695096093, 0.7868025933760187, 0.1955039602533155, 0.7023069965301462, 0.19933164870835185, 0.20557995927547434, 0.20855047719946596, 0.20033033076491746, 0.18105752310015766, 0.1804547414664487, 0.18490418454936075, 0.1924259193024087, 0.17446635948299538, 0.19163452150441063, 0.18751170683716456, 0.1888753319092683, 0.2082115062259321, 0.07326253932487758, 0.07112777548774685, 0.07849416428119371, 0.09270152254653308, 0.06804688981482776, 0.07431649920314343, 0.07413256222826947, 0.07426716384495125, 0.08795873094444417]}, "mutation_prompt": null}
{"id": "0b2bf150-8477-4550-8b4b-e395cac9fe58", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.5) if self.adaptive_scaling else self.F\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n            self.F = self.F * (1 + 0.1 * (improvement_rate - 0.5))  # Change: Make F sensitive to improvement rate\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Slightly enhanced dynamic scaling factor strategy to further improve convergence by making it sensitive to improvement rate.", "configspace": "", "generation": 80, "fitness": 0.05208603193116546, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "f024b706-e2fd-41c2-999b-9ff58f4f7a4b", "metadata": {"aucs": [0.1051334417192844, 0.11164149870243711, 0.0969100654163696, 0.09516063500410543, 0.12235599876257708, 0.08400029918286112, 0.13368032931802099, 0.10311241681838967, 0.12623832864468054, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.004494605974469823, 0.0, 0.017125344933174746, 0.01726035819895988, 0.03128839682528084, 0.012988149936900895, 0.031232907481396954, 0.014374157104186103, 0.00998110466482105, 0.007920069396445961, 0.0, 0.0, 0.01371190919509957, 0.0, 0.014934094019302235, 0.010718999238616522, 0.0, 0.005225842567389782, 0.06597273214835297, 0.07039283765551496, 0.03402382839968521, 0.08083882900858119, 0.054660648968662295, 0.07674226003757245, 0.08065528290469282, 0.06404410460770793, 0.05214890216367185, 0.01882409664833118, 0.04751226024956745, 0.0, 0.08925980907251274, 0.0, 0.010215507067468543, 0.0751925106351482, 0.0, 0.09096094232869478, 0.03790438358476911, 0.045668482880721006, 0.1280894299821762, 0.13826874000416356, 0.07388705599153422, 0.0841215959166155, 0.033293618688773674, 0.05590497870760247, 0.0564207900599748, 0.0, 0.0, 0.0, 0.0, 0.0, 0.009267400805818005, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.02537005635563183, 0.0, 0.0, 0.0, 0.0, 0.0, 0.037741192765339604, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.15215282903637561, 0.1256320031453373, 0.12460106847987995, 0.1453786345682353, 0.1092245951759665, 0.15776284486469372, 0.11444093780850195, 0.12839507952839446, 0.18562638945897902, 0.01800587121679076, 0.01650119555300167, 0.016799314335703475, 0.02237264861316668, 0.01780100283578301, 0.025806458831149737, 0.01742191382556013, 0.007232646823672417, 0.008974928440280916, 0.07863824919281737, 0.06662439689813437, 0.08712666362674515, 0.10021761648367278, 0.07798290643992734, 0.09618527061704807, 0.10788644279216153, 0.10495205663114271, 0.08913653230045127, 0.14080033373950374, 0.1479328130396379, 0.11428044756960243, 0.1342918714158755, 0.13528879297600194, 0.11855160551627764, 0.12811661016993203, 0.11778240938835338, 0.1486227060923191, 0.06128780604967432, 0.08584046078228291, 0.05335269985480118, 0.07102561649993933, 0.08223680343728479, 0.0810866708775273, 0.0659836523805497, 0.0591946068687379, 0.10081243334557899, 0.14736891895790738, 0.09197627989208834, 0.14220874480080747, 0.11689079240022182, 0.1049418293338531, 0.12859025491734188, 0.1261361563909742, 0.0950001343375847, 0.16639795756662823, 0.12321075265492876, 0.0, 0.0, 0.0, 0.0, 0.14841179991506248, 0.0, 0.0, 0.0, 0.0746044035613761, 0.0702482000425767, 0.10293877186006228, 0.08380500060912577, 0.07971987669558489, 0.07400060742504333, 0.10912545006951135, 0.1048908144275722, 0.09340340444209505, 0.09795218363370173, 0.06293468680078873, 0.07976366498820664, 0.07743159067146954, 0.06340623128916012, 0.07245264175350208, 0.055740268699735696, 0.08943981849462357, 0.05389269078101311, 0.14590646219773484, 0.15701593260295865, 0.13636208595514943, 0.15638337545919168, 0.14136855986135488, 0.14134539916409417, 0.14346272923127834, 0.13880488995867157, 0.14615427644315226, 0.01742826987609547, 0.02016525598918384, 0.03630441585237132, 0.03436222408544376, 0.010567111871573998, 0.030261838592307355, 0.057209478075131104, 0.02746098540924491, 0.01689561082274582]}, "mutation_prompt": null}
{"id": "571129e0-1046-4708-a622-73a5c9af9a96", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5 + 0.3 * np.random.randn()  # Change: Introduce dynamic adjustment to F\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.5) if self.adaptive_scaling else self.F\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic adjustment to the initial scaling factor F for enhanced diversity and adaptation.", "configspace": "", "generation": 81, "fitness": 0.4376954035696173, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "f024b706-e2fd-41c2-999b-9ff58f4f7a4b", "metadata": {"aucs": [0.8434937296059621, 0.8527303842983328, 0.8468553388239544, 0.8491226154989902, 0.8531559011769347, 0.8374032694650009, 0.8401302229324128, 0.8360123795204965, 0.8360361999319366, 0.7640899148499415, 0.7094916283690613, 0.7180929676740566, 0.6731291259740226, 0.7057572861635133, 0.7413641601720127, 0.7213107621366275, 0.6848858794138195, 0.7307350423191504, 0.24978353068107595, 0.4544592657981852, 0.39181216674994557, 0.13381877889446736, 0.5230946171761329, 0.3312389900428929, 0.19713335443772617, 0.510933884659702, 0.21268848306412225, 0.18069918473918223, 0.4046353875592883, 0.10033683778889158, 0.14965051580043798, 0.24658126817748238, 0.1371425194300615, 0.15876571637822412, 0.15909345693102372, 0.15214006917334633, 0.9378071127127379, 0.9618958855061039, 0.9550427951295987, 0.95430483350401, 0.977379866701352, 0.9515596589534436, 0.9856552110964912, 0.9835688884821682, 0.9573850435454606, 0.5319693218982783, 0.45495363461910376, 0.5390721493597761, 0.2969412824688821, 0.5176607320563794, 0.6133628629450929, 0.6487827745180155, 0.4227691568871611, 0.41322518849427314, 0.8246849480967253, 0.7761313887084627, 0.8591037434604853, 0.8420162447915831, 0.7974325329855019, 0.8441530145080047, 0.8286293400708896, 0.7233564045863272, 0.8584572558255394, 0.21932487088878871, 0.1820987902616159, 0.14852788574514486, 0.23218190128555527, 0.24578936402160823, 0.19531112106105164, 0.45834166971367685, 0.19579096820944175, 0.25348337181448355, 0.21024814287491134, 0.19257416302711794, 0.5597343728842941, 0.1772697106368507, 0.1757205335056573, 0.5431874900627143, 0.17151144844982358, 0.1535593477333137, 0.37256277084762646, 0.6610505652823355, 0.6257468594580853, 0.6197986475589007, 0.6556444028578027, 0.5366356431931519, 0.17689002473136828, 0.7000179488587301, 0.5147605865027494, 0.6801206659715271, 0.7295432635815282, 0.7219296966506432, 0.7380282780612367, 0.7666726553350067, 0.7154294441726676, 0.7449805853154241, 0.7519237110578307, 0.7054278905511588, 0.7672565025209211, 0.1699647564037341, 0.2952996273210815, 0.13749822649622, 0.5570725706443769, 0.5846011026300455, 0.5469054879289581, 0.2949294386177802, 0.16383594578003635, 0.37905163286270194, 0.4816723589909273, 0.5867701053347084, 0.607172878998758, 0.6190245757583426, 0.5998384518526458, 0.5520634402758909, 0.6017275413986205, 0.5448554249553916, 0.6037161575397456, 0.8027260593406962, 0.7798531339504758, 0.82285152120715, 0.5230612991714181, 0.7534060507944595, 0.7985951984368538, 0.7592954949393159, 0.7807283160659506, 0.8174270659320851, 0.11189338088837864, 0.09634884175621905, 0.1071315180457777, 0.10355917461337483, 0.11355190435708451, 0.11354538248634394, 0.11460067485796788, 0.09097520981249796, 0.08538619767051747, 0.16310507807453722, 0.17327414991628998, 0.21184714501009838, 0.1407986570557267, 0.15019345259523798, 0.1539980025104496, 0.15125683651401067, 0.15721976315378883, 0.21611173305692188, 0.42511854904923896, 0.43533858724666274, 0.48346422649761145, 0.4841518763587114, 0.48573347168845415, 0.5927979988512109, 0.5433793101851729, 0.5364530270205206, 0.5133778140129117, 0.5012434225722718, 0.330787058923821, 0.4608770443578143, 0.32582911531086167, 0.35051885066030286, 0.43872022697399893, 0.4478343059238419, 0.35861489982062833, 0.4946804227992775, 0.20090401624191911, 0.21525085109523578, 0.19081629332127137, 0.20007195761218055, 0.2023368800827694, 0.19153393582513556, 0.19326713778786409, 0.19388523839540406, 0.216514147234241, 0.17693913069890077, 0.40615222113940397, 0.40881437164284495, 0.18561099900678757, 0.32982559860694605, 0.20388105965036807, 0.21803818058325097, 0.3398707706546249, 0.2193362723123261, 0.19535969026463706, 0.17873223271641914, 0.20926349738033823, 0.19183242968464687, 0.646469176548419, 0.16918634322552495, 0.7674610540288912, 0.1788312833394211, 0.22245018242532377, 0.7462075079992849, 0.2013494031823232, 0.1660171365863975, 0.31687886708603585, 0.6801064777028304, 0.7724015408867009, 0.20991379570477298, 0.2071737943552049, 0.21235771536530668, 0.19183604162971402, 0.17988142893775216, 0.18860188086299345, 0.18642899656730016, 0.1869022588444862, 0.18778959067102519, 0.19039133619516124, 0.21413433695365447, 0.18196549223787484, 0.08532046800324677, 0.08379687796342239, 0.08728357700899247, 0.07331967361464231, 0.08346825743326658, 0.08313555641310466, 0.08591759098751406, 0.08151899676186891, 0.08363104291544254]}, "mutation_prompt": null}
{"id": "ca50185f-c4ec-46c4-a4fd-f1f167fcfb9b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * (1 + 0.1 * np.std(fitness)) if self.adaptive_scaling else self.F  # Changed line\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.8, 1.2)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.1 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.05 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic F scaling based on fitness variance to enhance convergence in varying landscapes.", "configspace": "", "generation": 82, "fitness": 0.10837295622134195, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.20.", "error": "", "parent_id": "f024b706-e2fd-41c2-999b-9ff58f4f7a4b", "metadata": {"aucs": [0.2312345103824316, 0.3410265776009753, 0.2985223842508278, 0.15802085184286407, 0.26994065659653244, 0.17330820811255765, 0.22638864579743723, 0.22814368564800602, 0.19407574439862552, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02321653592755213, 0.01700753895553775, 0.02506108863644607, 0.02034199480283727, 0.028590605490977583, 0.005064169092020343, 0.009493176710102302, 0.022961649394609207, 0.0019762373375966646, 0.008230618200458228, 0.005198465613959535, 0.00027442717427150765, 0.013810532082703109, 0.03390188939630023, 0.021400976193380328, 0.002156128902131571, 0.005985442431649557, 0.01179699337578144, 0.9795739914758136, 0.9862176089002982, 0.9938359128451167, 0.9865128821981812, 0.9904122423784885, 0.9777904413642377, 0.9878738218162718, 0.9770425481033799, 0.9892596341841472, 0.01892221159958385, 0.032882417605534786, 9.999999999998899e-05, 0.012646823388751338, 9.999999999998899e-05, 9.999999999998899e-05, 0.07528496270215201, 9.999999999998899e-05, 9.999999999998899e-05, 0.038000587109201844, 0.039695097608898555, 0.051607821222809824, 0.11391750639571474, 0.060936912368182106, 0.08421315082115433, 0.08743807539552673, 0.05599937307460301, 0.032865533208990216, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0071428440646492675, 9.999999999998899e-05, 0.0037804264619498706, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0060026702890231265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1352892790301765, 0.1562253620368731, 0.13826172074298937, 0.14919928845995878, 0.22823582251718155, 0.15784705640416197, 0.22777770630028404, 0.26605445139142603, 0.13172859679244975, 0.018104065883271847, 0.016599539138954067, 0.032373704209932797, 0.018531624367708166, 0.0025647063354438115, 0.025903876894395994, 0.01752016481289198, 0.02133151920540699, 0.012442085096306843, 0.14656624248510308, 0.12570808885575402, 0.1390446941490593, 0.12335074903121257, 0.13954865724479149, 0.11505082233139652, 0.09902382636877005, 0.13838076891662565, 0.10988607857862631, 0.1529232117037571, 0.14801799595218945, 0.17684120027190042, 0.20113268426402442, 0.1824308944726245, 0.15198141441684876, 0.2291049421028446, 0.21426503485907156, 0.22980024250148223, 0.061381669281600826, 0.08593185248622082, 0.0724267136584611, 0.07111851148074688, 0.09104943628587003, 0.10555770813322074, 0.0763278675318041, 0.07217786471225096, 0.06602576385328407, 0.1638255448004824, 0.11231678081299745, 0.1422945159009682, 0.1429385805306218, 0.1321490179459266, 0.14612165277709277, 0.14059577684418478, 0.12340797725762387, 0.16941201834436614, 0.13538507274419176, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003109991052370642, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11331529752507563, 0.12174935852581059, 0.10567604749763104, 0.1575863656762937, 0.15663006111232203, 0.1492336294507075, 0.12101547455757444, 0.15636360236379276, 0.22773690958521842, 0.15274463371017188, 0.1423689687009997, 0.1564799134175131, 0.12814545976223868, 0.20728703940498527, 0.12401313938171554, 0.18262763646045777, 0.17991244205219592, 0.17931461982843955, 0.1930183369374605, 0.17842444069520758, 0.17959303387476555, 0.17668753023776262, 0.18753331630482506, 0.18456452525275469, 0.1897401833381771, 0.17623832643939608, 0.16309172007061135, 0.028211961338970637, 0.040140374965474845, 0.03517955306570508, 0.043337756579325815, 0.033535969608291416, 0.03838105942683612, 0.057303757127379895, 0.03667432049645136, 0.03791411354590868]}, "mutation_prompt": null}
{"id": "d10cb204-2cb5-4ce0-bea7-aca40431102e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.6)  # Change: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change: Increased adjustment\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Increased adjustment\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce enhanced adaptive scaling with dynamically adjusted mutation factor and crossover rate based on success history to improve convergence speed.", "configspace": "", "generation": 83, "fitness": 0.4493525136585515, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "f024b706-e2fd-41c2-999b-9ff58f4f7a4b", "metadata": {"aucs": [0.8443340211437758, 0.8550112374770743, 0.8284884986232303, 0.8205072347636502, 0.8267478211916629, 0.8483445670817413, 0.831026368547511, 0.8551066601537352, 0.8564574831518358, 0.7170299463615242, 0.7183520388422184, 0.7039249473838574, 0.6990621235705872, 0.7111786093491475, 0.6946859860361756, 0.7227745163093799, 0.6916185203531768, 0.7049112717463331, 0.4782599156779386, 0.47157824805268866, 0.3889038809340034, 0.2991985916886304, 0.3939908236454972, 0.13742075692566524, 0.3524194708466093, 0.24120448868947675, 0.36061736733656624, 0.1503420315211521, 0.20454182035172241, 0.3680178709044801, 0.35732185054531984, 0.27252970893051964, 0.3343709739097047, 0.15191931459434405, 0.21383178546999893, 0.3505442439227401, 0.9636776717083833, 0.9287860669916262, 0.9631267178179441, 0.968289574586861, 0.9372266835080354, 0.9610557853133902, 0.9097244020328945, 0.9614983285254595, 0.9629062112246817, 0.5788062577948189, 0.5855194325109465, 0.3566716961687304, 0.41905277275636155, 0.3821070247362215, 0.5340341624348394, 0.6221519221226339, 0.442322246720088, 0.3764371512014888, 0.3636071806867459, 0.8018423519976599, 0.8155017238925405, 0.864357430103741, 0.834311823627681, 0.8246049886549005, 0.798018734166643, 0.8044414715466444, 0.8399258863694274, 0.548810592485371, 0.7414436208093484, 0.15564021978617526, 0.12666197584703842, 0.18816873025956815, 0.1316031836339413, 0.19503163216602648, 0.1912445422106912, 0.4501452928657417, 0.663442306343754, 0.05644539843457319, 0.1677413667799128, 0.27410448793710207, 0.610043035755142, 0.3223071345367148, 0.6880775629450975, 0.4311837925180605, 0.49129457008576904, 0.44806268153189155, 0.6649656386758533, 0.6746017877539202, 0.6845250604070254, 0.6942450680515388, 0.6502325743781898, 0.7083131529391202, 0.6987590136245119, 0.6594710451043928, 0.7509078501740131, 0.7675209195361251, 0.7840429324643923, 0.509472963813216, 0.777031078109111, 0.748472682608583, 0.7758980773814157, 0.7481598887774824, 0.7593924400052324, 0.2932919250213034, 0.16173232487998235, 0.09154369315169375, 0.5386249695451593, 0.12198939749588134, 0.5897660964053385, 0.3036186894351073, 0.2527182045434567, 0.26234584572969, 0.5919873604327355, 0.4092311924285784, 0.5470593698333241, 0.5791663736968335, 0.5748508962317191, 0.5659055542504554, 0.5832238568852947, 0.5679501269952562, 0.46021425943309346, 0.807541085615253, 0.8093175879440594, 0.7936601239091284, 0.710274881934952, 0.7754351716450493, 0.8247517032287641, 0.8020997176366118, 0.7918860509384802, 0.8043701284604561, 0.1235907197586712, 0.09139176241757874, 0.09102151363535982, 0.09857350082313843, 0.12965434103333684, 0.1452943345819978, 0.10495946120864663, 0.1062848389266472, 0.10678006756984126, 0.15553673828725767, 0.24471675960113237, 0.3653287966563131, 0.12456766446845036, 0.14212248969687424, 0.2477898358664289, 0.2183839170602886, 0.26310431061830053, 0.12515460897427455, 0.5509468170510776, 0.5443276412691807, 0.5070747202894638, 0.5627415854844235, 0.4636402555206438, 0.4899228710039871, 0.46899000164342575, 0.5032679187504088, 0.5434201651308936, 0.49920432628731337, 0.4419939920885265, 0.46640622594861947, 0.4490965912198839, 0.4163570668487814, 0.4438557547847346, 0.44071141191996044, 0.4556948440606531, 0.3497596372450281, 0.22077843993712842, 0.18889446129105547, 0.20139092085816102, 0.18438872181618748, 0.19582898497550216, 0.17976396375042092, 0.18731030739831356, 0.19366323742338876, 0.2015251775593483, 0.24580174647519493, 0.20198998635686582, 0.19310221441675568, 0.2610030629611455, 0.3003941783933317, 0.3603545478054917, 0.38609721764143434, 0.4573556785676052, 0.2170363188839115, 0.18016257150948845, 0.8852299871665298, 0.8954898267518959, 0.1760819046452209, 0.751793974931027, 0.18759257672256613, 0.16259819411444476, 0.17474802540214374, 0.15712885756676898, 0.20457593417328912, 0.1643046644920867, 0.202008145392242, 0.2002484072605345, 0.7590860928730395, 0.20547318655510804, 0.2024603450855278, 0.20994662058551117, 0.20879876148542376, 0.19281332710322596, 0.17895557576641896, 0.19246233310473204, 0.2207715676600821, 0.18839448145725657, 0.18634184108411178, 0.20479703752642286, 0.18115262035882274, 0.17928839212226633, 0.08550206843146202, 0.08021077983414793, 0.08400018185533498, 0.08828420623192046, 0.08421925645338402, 0.07118101867214077, 0.07579560036057209, 0.07674629037994418, 0.09455005721047638]}, "mutation_prompt": null}
{"id": "3d0d9cd8-3aa3-4f59-84f3-9ee0d0dcca38", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.6)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)\n                cross_points = (np.random.rand(self.dim) < dynamic_CR) | (np.random.rand(self.dim) < 0.1)  # Change: Added mutation to crossover points\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.random.rand() - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.12 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Adjusted CR update factor\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance crossover diversity by adding mutation to the crossover points and tweaking parameter updates for improved adaptability.", "configspace": "", "generation": 84, "fitness": 0.43661355001974583, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "d10cb204-2cb5-4ce0-bea7-aca40431102e", "metadata": {"aucs": [0.8216773209301712, 0.8473538402421137, 0.8747243288392212, 0.8444841157236455, 0.8380787044823119, 0.8347936419314962, 0.8193064389693125, 0.8390403086210847, 0.8420191649567448, 0.7192490318394105, 0.7038476404910988, 0.6861076226939924, 0.6823366297358424, 0.6862152930879488, 0.7195758954717851, 0.7067078705092549, 0.7200940045764908, 0.7104901838836887, 0.15405855036446814, 0.11518167744998686, 0.31543122323410266, 0.3112047956500653, 0.28295038228969527, 0.4029617334985107, 0.33336824082533145, 0.16409471490726013, 0.3831986893598912, 0.13306808473214804, 0.3831995723225041, 0.31770012975251205, 0.14538698616962065, 0.1687746082566255, 0.10567125082233086, 0.13734059136767296, 0.2635970442518957, 0.18339895402085227, 0.9649954049105302, 0.9744501796965686, 0.9637761836751553, 0.9109954574716899, 0.9591240456645095, 0.9274816125839668, 0.9710699035719417, 0.9588483257785685, 0.9600312657198893, 0.6262910669713557, 0.47077106992242357, 0.44951125596358077, 0.5361508037520013, 0.4649713318342089, 0.4209680056960011, 0.35388106102143013, 0.2891252312456597, 0.36792343133062466, 0.8572788595518613, 0.8631112764868667, 0.8428076225965788, 0.8532536005936888, 0.8314384887776446, 0.766501613001402, 0.8080555817012757, 0.842849953238155, 0.8783183986953811, 0.27949659594096066, 0.27275758553133056, 0.15119721969580346, 0.21515336320211886, 0.15528676316422385, 0.21103799957073932, 0.20898415507014, 0.22506869426028608, 0.21561326553322768, 0.11669026125843629, 0.11896434907521303, 0.16544382520027645, 0.17038514372001357, 0.34797897208060435, 0.632643851180565, 0.1758536261251209, 0.32692300537431407, 0.35709795958708257, 0.6563659972049112, 0.6726183185585816, 0.6937977438380489, 0.6927807252049002, 0.6768095136170104, 0.6673708816358039, 0.6593397084509858, 0.6469622650250691, 0.6497128869426723, 0.7432953869192557, 0.6512097593887163, 0.7624399555861363, 0.7480353275052841, 0.7393423285569487, 0.7384927488740471, 0.7560695251617822, 0.7672178541277963, 0.6279709125043833, 0.15063763902320282, 0.11631398911825219, 0.25103529554390513, 0.14078486534339008, 0.2716736854771744, 0.15090614666441193, 0.17335345719953943, 0.2172862625956138, 0.3105141441302164, 0.5819271391000258, 0.5469404657087891, 0.5582645484461344, 0.44762701362330715, 0.5734742456754747, 0.5791488008524956, 0.48839923901179905, 0.5546006720683223, 0.6026443305992015, 0.8147087942817793, 0.8287779174190196, 0.8048904193282536, 0.8122390764855391, 0.8125100848499791, 0.8232038491268997, 0.8091039446517512, 0.5856162940237597, 0.779775229772547, 0.10254882807039434, 0.09303713079801679, 0.11009588287134031, 0.12321017652064892, 0.12059628093136165, 0.12654778404875633, 0.10982254421406701, 0.12485529261372463, 0.17030871614914667, 0.1473782783121409, 0.16418074037304997, 0.20892306489217394, 0.18860673177482068, 0.14101111849461867, 0.18958895923847685, 0.22481579453131506, 0.1412333967243118, 0.17366061589503812, 0.444667414339897, 0.49525676484923, 0.5465001085602719, 0.5239857095250471, 0.5400748082218447, 0.42883954623148834, 0.48706784559496796, 0.522516264342383, 0.513393601531356, 0.47590567357625024, 0.45794005169526897, 0.37538928228309787, 0.4420966076845426, 0.4284986632274045, 0.4467707680495817, 0.4248480032812001, 0.38591932264082984, 0.5399609318482662, 0.20845695507345074, 0.20329671069084287, 0.20636702329517487, 0.17703136820931975, 0.21486854424611834, 0.20364238356180642, 0.200752178625058, 0.191525426497973, 0.22226780598013574, 0.6453006027910968, 0.19321281731809914, 0.41410422747066067, 0.20780506159905476, 0.2082600640129466, 0.22865416108754155, 0.47810841615158384, 0.18129140771196006, 0.6440101332651949, 0.1845507446652589, 0.16980500201992177, 0.182001063074806, 0.604370489052984, 0.15329090204221485, 0.7838414193977804, 0.7703512850912422, 0.20003471162222597, 0.7613069815338693, 0.16631226457125992, 0.20699882336492348, 0.20532240843011917, 0.7950654261315582, 0.760556379461502, 0.20460251684545205, 0.21072379259273244, 0.20868290381062826, 0.2067110452328914, 0.20552388100694097, 0.20115059838107952, 0.17118302727603585, 0.1794819585051759, 0.18347460332931775, 0.18313239227415623, 0.1867253207379962, 0.17251790328131267, 0.18073709046565223, 0.0835449175667149, 0.07078132471550458, 0.08504218396224528, 0.07639084047322942, 0.07151291263620019, 0.0819648513812421, 0.07944423256411626, 0.0768976528523011, 0.08204863988254163]}, "mutation_prompt": null}
{"id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.6)  # Change: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change: Log-scale adjustment\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Increased adjustment\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Improve convergence by refining the adaptive scaling of the mutation factor using a log-scale adjustment.", "configspace": "", "generation": 85, "fitness": 0.45493539069899425, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "d10cb204-2cb5-4ce0-bea7-aca40431102e", "metadata": {"aucs": [0.8410780121020178, 0.8625725060362592, 0.802855676824567, 0.8625996377960085, 0.8533082209821711, 0.8398373559462775, 0.844725880235796, 0.8544804327636256, 0.8623534335019504, 0.6856170063286688, 0.7331824507666559, 0.6850289742519191, 0.7164406883603249, 0.7276951752821542, 0.732668637948384, 0.7345748816466222, 0.6386486708507135, 0.716305513762135, 0.3923330947808781, 0.4327530636710175, 0.5000943338837005, 0.490222557920757, 0.30455781170611573, 0.3545736816177627, 0.28132602234447046, 0.37737541897778626, 0.42206264370903845, 0.31237627674962887, 0.11099814989148382, 0.160924763934031, 0.37954190619102723, 0.2875067787326595, 0.2724673603830434, 0.29625200381147465, 0.30108953118913107, 0.1316624771978422, 0.9611406421616012, 0.9436920881850122, 0.9714944954602882, 0.9530035079740609, 0.9456253877506368, 0.971248014905266, 0.9451357611982691, 0.9556479422974072, 0.9477576905316876, 0.545620642871345, 0.3471899276962961, 0.21113991060913972, 0.3211302894342146, 0.30624858909412067, 0.4832650978419323, 0.4026318795775279, 0.49635350862332406, 0.39307673507696195, 0.8660340291963385, 0.8350822877858171, 0.8562140372892473, 0.8362682139194878, 0.8383995866283677, 0.8676447663716482, 0.8236958094700746, 0.8408102176491805, 0.8298870009013025, 0.21203277068699622, 0.12796249942166638, 0.1913793076256649, 0.22012173155445292, 0.2277851459401804, 0.1429551082759013, 0.24318487032411085, 0.20254194103603607, 0.15806704733385757, 0.13040859845679043, 0.12488258302939814, 0.15136106585279008, 0.16659753908307307, 0.21374565460323725, 0.29999441210650346, 0.21228129292480202, 0.41976681124252946, 0.3320227269510305, 0.6540814045189784, 0.5130605783274641, 0.6920308322981575, 0.6987175995073494, 0.6651617050317218, 0.699438356151171, 0.6807090963809863, 0.6575718504136683, 0.6813952921399709, 0.5329823746743576, 0.7818305013725961, 0.7432047701706687, 0.5165475906428609, 0.7990586828066313, 0.7675009766792876, 0.5124708562195122, 0.6874422016239319, 0.7587140757356521, 0.3292219566024438, 0.10832993360132659, 0.15484587631121427, 0.454543695587723, 0.1679525220368907, 0.32372955825899064, 0.15698151776444302, 0.2096870350642741, 0.2544835613390649, 0.5992790514326305, 0.6129348336455244, 0.4196772614613561, 0.6045285648193202, 0.6167435306880622, 0.6153762361510826, 0.566586012307327, 0.5852819763504917, 0.5992775457368751, 0.647171819876839, 0.8040886880371461, 0.8028628995917814, 0.8262501086074372, 0.8401711778785106, 0.7622602007049184, 0.7594939598365457, 0.6714546184902994, 0.8150582705550453, 0.10785462082465469, 0.10486597166853695, 0.10150939870460729, 0.11766641100057329, 0.10469027575151835, 0.15371308262194838, 0.12819716457247354, 0.10628608610672585, 0.11071083801636872, 0.1466997718269436, 0.14274475833991185, 0.17906226284337934, 0.1502399713790077, 0.35162092290549174, 0.15163450829237923, 0.3876024749619803, 0.6677111166914997, 0.2010401795103055, 0.4850399803234553, 0.5632282515902488, 0.5356759453214829, 0.5750937457771178, 0.466394707106491, 0.5745962183879829, 0.5742859183959225, 0.5174111018255432, 0.3839765557179813, 0.47478579857070924, 0.5018410768161863, 0.4365027508534377, 0.45830787787296723, 0.43911496802406913, 0.30885532193602616, 0.4166086756306355, 0.4634359054243481, 0.4367250315593536, 0.2094043243037771, 0.20846404785697858, 0.20353016753336262, 0.1921313070698375, 0.1853932233496114, 0.20826494614158142, 0.19061849201754288, 0.2216966106386269, 0.20844078249361886, 0.5572048561660168, 0.22965977861032938, 0.26284269761547707, 0.3433756913942132, 0.3973116310234155, 0.20962466780229905, 0.5077064881841007, 0.1896036721375739, 0.17539311805907543, 0.18541304204647446, 0.8112331690440721, 0.8859991510430989, 0.17514118784519583, 0.8305564472452364, 0.17660734415802126, 0.8157572077357943, 0.8162614102311001, 0.8101788503360643, 0.1990615781347551, 0.6793775488302318, 0.2049402662512384, 0.16383548563778716, 0.7787270126329583, 0.8221770255464913, 0.7407445104516293, 0.2081815697216438, 0.20918031022560057, 0.187382709288048, 0.17485100936836118, 0.18387580540591542, 0.17601426721891889, 0.17940462566086612, 0.19282130320878332, 0.20718114151660816, 0.18175143805445693, 0.1814788613993482, 0.08830194048989815, 0.0809784690506663, 0.07800344605779375, 0.07831817021891874, 0.08804771390954103, 0.07685456998285922, 0.07845371628146913, 0.08140140147603447, 0.086343179266966]}, "mutation_prompt": null}
{"id": "4e668d11-7bb0-466e-8676-c5f00e6800f3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.4, 2.0)  # Change: Broaden F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.5, 1.5)  # Change: Broaden dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim * np.random.uniform(0.8, 1.2)))  # Change: Stochastic adjustment\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the exploration-exploitation balance by introducing a dynamic mutation strategy and stochastic population size adjustment.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 52 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 52 is out of bounds for axis 0 with size 50')", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {}, "mutation_prompt": null}
{"id": "56250009-1fb9-454b-a56e-cf0a6db9f577", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.6)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim)) * np.random.uniform(0.9, 1.1, (self.population_size, self.dim))  # Change: Broaden initial population scaling randomization\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing diversity in the initial population scaling through a broader randomization.", "configspace": "", "generation": 87, "fitness": 0.434828639057956, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.27.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.848648885179769, 0.8388424674071756, 0.8294339373128531, 0.8384780353198965, 0.8481140879169512, 0.8549024740790538, 0.8360386049770607, 0.8501641111260567, 0.7964559615275537, 0.7088340770753928, 0.7102803226376633, 0.718648707964159, 0.6848150172653442, 0.7200477605008042, 0.715762040784533, 0.7259167436821545, 0.6864858863429003, 0.674997399421684, 0.461846937505356, 0.28606594532789364, 0.34348037752155225, 0.14286225058347646, 0.41394588435486135, 0.1306994042911871, 0.1703639070555828, 0.36627814491246513, 0.12692539027707095, 0.2567154403173081, 0.2634832583132031, 0.3391421743082009, 0.235119086223453, 0.3092540949802467, 0.14776693805950836, 0.3239907564613238, 0.3849191703843001, 0.1553335334395659, 0.9339120110929285, 0.9625690733051733, 0.9498238032248681, 0.9553994048869645, 0.9662442243008331, 0.9217310379802778, 0.9475788326657728, 0.969993821530756, 0.9088629527957341, 0.33309548347222184, 0.4145364269720544, 0.4715050648588074, 0.516312071546709, 0.4002768542133103, 0.5510069411155761, 0.4610172396201161, 0.47869555502089456, 0.46284245143403024, 0.3627563609284923, 0.865634950893031, 0.8701840564700802, 0.8406255420011179, 0.8454095404218938, 0.8607622486029107, 0.8496364548739362, 0.8235505975830846, 0.8278494648848775, 0.14658934011925162, 0.21823977930920013, 0.12603888002867092, 0.12603174811425255, 0.1579791741791714, 0.15405422499056898, 0.16062879518835338, 0.21230449258349882, 0.14286233758906763, 0.1997511919708812, 0.12665843348559924, 0.13770527994384796, 0.2400706188354933, 0.16841992460787492, 0.15779920837322314, 0.21250331719515525, 0.17553280102688873, 0.14278741623892088, 0.686526672172509, 0.51044779298751, 0.6108136707221683, 0.6782384215698505, 0.6745763182812696, 0.7177533023885856, 0.6821775897149573, 0.6211478329423717, 0.6960131943684771, 0.7057671407845061, 0.7837836230399724, 0.757855867632105, 0.7344285934129134, 0.6431978185477198, 0.7640171371563355, 0.7712150789132786, 0.7305768043712948, 0.776245787979494, 0.216415282781123, 0.15572311982815135, 0.3155764798220809, 0.4045727684985524, 0.4290461482086779, 0.5346041971576716, 0.1635534069753607, 0.20435754513772786, 0.19958142173970994, 0.6346293536357097, 0.5344346569862162, 0.4391421317864084, 0.6039614850382375, 0.5618924423261256, 0.5627648041214455, 0.40685606224266857, 0.5824674381273592, 0.646116820849717, 0.8261778002767907, 0.8209967737118974, 0.7991025780567866, 0.8138540593973282, 0.48101180078968864, 0.622450232771466, 0.7986375646832253, 0.8139820821807893, 0.8379458958117281, 0.09100379369255263, 0.10131583371165653, 0.09348951804345984, 0.09565292606415987, 0.1040336348125056, 0.10820558651133438, 0.10747797099606304, 0.09967320106120436, 0.0931173920745827, 0.1990299187862361, 0.24138338439998963, 0.14822946111762025, 0.4669363824332856, 0.1801781376402425, 0.13403221023715106, 0.2141023724599288, 0.20996084706053542, 0.5730473106692533, 0.4168651479510954, 0.4873968856095756, 0.4578346158122345, 0.5386971388382277, 0.5150566479850175, 0.5975313229822488, 0.5146715468984718, 0.5200076489430601, 0.5363765724578402, 0.4786260412539115, 0.3256545390899531, 0.5255406479911078, 0.37098395749819923, 0.33253228831445447, 0.46680359569335284, 0.45998021658790345, 0.47425245852880105, 0.3593329781416562, 0.20669238806019186, 0.19804009952368107, 0.20005032666132772, 0.18988162804384612, 0.19306860543649407, 0.1930426420989907, 0.20213931730127266, 0.19438794349091781, 0.21199721927183712, 0.1977002642522797, 0.20995360620681403, 0.19867570827294034, 0.3278015123867811, 0.38112211755431513, 0.22823973438436473, 0.4279103551401966, 0.22625001181298632, 0.4012279704913664, 0.7739569923328864, 0.8424940071247551, 0.1837702094068463, 0.2072774857784211, 0.17997290340142102, 0.1965608919131736, 0.7220458323863448, 0.1801949595379101, 0.7842829797594202, 0.688251511141013, 0.8444364303690965, 0.20785821461897558, 0.20081215468111935, 0.19603178992961034, 0.20828742295026414, 0.21180757989184207, 0.20792029697866432, 0.19754212632104973, 0.17773264187635163, 0.19075946633609442, 0.20056491588053738, 0.194227049395162, 0.19078039512727418, 0.17294604932980073, 0.18651913644166584, 0.1741416969175299, 0.1760917658497052, 0.08563371053154767, 0.0820673533841515, 0.0940380402064076, 0.08199205187963421, 0.0773804563469106, 0.08777703371856482, 0.09128592964186988, 0.07130680678066059, 0.0695765203704326]}, "mutation_prompt": null}
{"id": "44c1ef7f-04da-47e0-8370-e7c7260d62a3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.6)  # Change: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.35 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change: Log-scale adjustment\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Increased adjustment\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune convergence by slightly enhancing the log-scale adjustment factor for the mutation scaling.", "configspace": "", "generation": 88, "fitness": 0.4339407222997469, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.8507196198937838, 0.8493679289075969, 0.8440573854177554, 0.6479102861330909, 0.8515726521029368, 0.8347833700586362, 0.8359194719924932, 0.8451528626904732, 0.8635414111020875, 0.7136099761072099, 0.7201448123525329, 0.7117296177593051, 0.7125819641276246, 0.7165952801925906, 0.7383660753224079, 0.7072004046438412, 0.720989434135943, 0.6957996577821222, 0.26966893798541347, 0.22369457681220906, 0.1592428067822782, 0.4284762223687206, 0.40374840511597354, 0.4009660446004999, 0.23759354616453532, 0.22950901609704222, 0.4321798738748258, 0.1389106236032852, 0.3510326384808278, 0.3900578945530564, 0.1532229116590328, 0.3063852697316978, 0.3001511273214683, 0.13167434802931055, 0.2474146269683981, 0.15289342398038475, 0.9428390782085283, 0.9721526458804692, 0.9714780626305666, 0.9324818358262732, 0.9468905450226296, 0.96046512261095, 0.9302626616595651, 0.9478732106062469, 0.9641090956030398, 0.24611250063440016, 0.3916661604996081, 0.6683435825518904, 0.46230418976452115, 0.42500781471312254, 0.38944212474265627, 0.3670812949636988, 0.4436356197901844, 0.5123924003186988, 0.8335417843562457, 0.82857753404291, 0.864086043649653, 0.8413138351633586, 0.8365621829547982, 0.8215955486735366, 0.8206741350265558, 0.8296181715606776, 0.8261430757070408, 0.22705381614845388, 0.28117290579177645, 0.3582057324958615, 0.2492515406322836, 0.14615877331316318, 0.1411593648919821, 0.2351109542962636, 0.20732308231848262, 0.1827265906564094, 0.12992502143036433, 0.09818298202859643, 0.13616354500368688, 0.139500996880339, 0.17667293238048043, 0.1684615886669797, 0.2557868419626649, 0.6789269939825702, 0.16693710767370828, 0.6893574586220945, 0.6516731580161007, 0.7084911177452828, 0.6797591123854991, 0.6945559955761185, 0.6567977955363427, 0.688897930095491, 0.678507606457228, 0.6638227402117585, 0.7771868022343189, 0.6996461325932938, 0.7402610172597968, 0.7595775462303802, 0.7203133752557163, 0.7594207827333852, 0.6049933546250882, 0.7802280189111154, 0.7426239701839676, 0.13607593083286829, 0.23205871680719725, 0.12146420742995201, 0.3041310231389224, 0.41258765254506735, 0.6180180576189304, 0.28378830185745363, 0.28638224300072646, 0.14239396983941588, 0.35665319329845413, 0.37716244276330346, 0.5153347802387743, 0.6176093023017899, 0.63354068776929, 0.31898747769244173, 0.5803853823128489, 0.6413798224146314, 0.6300044743876045, 0.7664946951022003, 0.8350408445009717, 0.8257937619991259, 0.8100076491549826, 0.8281683056543789, 0.7313009245689676, 0.7391221275348481, 0.8131146071370183, 0.7628333742267166, 0.11647754273296829, 0.10173144169861803, 0.15072450162710482, 0.2677161819231366, 0.12030299232030484, 0.1473775471202201, 0.08769894236947584, 0.11883934495059478, 0.1109210961908278, 0.15921197151111444, 0.1966728299891869, 0.18671178446380077, 0.21177596707811197, 0.14438251912413957, 0.16474864782865406, 0.21168955642187282, 0.21031912442612422, 0.13132637541391612, 0.5061068614692719, 0.4837835991517042, 0.6082578188888258, 0.5922700628095804, 0.5093926864779931, 0.6089663510617851, 0.4722080411049112, 0.5384746398115468, 0.44371678008426185, 0.3833112689354129, 0.4011936862859793, 0.40488673705157985, 0.38277367484821256, 0.40755466310655253, 0.49614787302349295, 0.48787791269266834, 0.43072830494387115, 0.4921765834965427, 0.1789288480361192, 0.18112767210549596, 0.201736616139497, 0.18975830259470927, 0.19380638652981041, 0.19380246674465884, 0.19751815302955156, 0.20154784574894036, 0.20350676204432128, 0.21623638905257625, 0.48676684583043384, 0.37561089722058394, 0.21448838352870692, 0.2652741579461403, 0.2302981467481976, 0.193592583069068, 0.19752229071809735, 0.24968382609766215, 0.1809365527565554, 0.16910010597600267, 0.8735368189436612, 0.1733083762427381, 0.8355840099322619, 0.15517975260585448, 0.7903708009607604, 0.7515371230254042, 0.2657824369272589, 0.2025665847491016, 0.19822957050170675, 0.20445755553213418, 0.16433946119172504, 0.16380020397074224, 0.2048105630767857, 0.1253613179547809, 0.2079617536803159, 0.2099072046182452, 0.20669602709734392, 0.17769854472952684, 0.18754414169132194, 0.18581010830887845, 0.1824728483574487, 0.177771504942293, 0.17691565998901693, 0.17597721298781455, 0.19381277553180454, 0.07612038773599417, 0.07928988230924983, 0.07507788352021594, 0.09476343607902271, 0.08281368909847442, 0.08619879819634102, 0.07854352088420069, 0.07855984598163046, 0.09051366767065205]}, "mutation_prompt": null}
{"id": "8c76bf1a-5712-4480-936c-90135ebddd07", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n    \n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n        max_population_size = 15 * self.dim  # New: Max population constraint\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.5, 1.7)  # Change: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.6, 1.4)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(min(max(4, improvement_rate * 10 * self.dim), max_population_size))  # Change: Adaptive resizing\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive population resizing and dynamic mutation strategies to enhance exploration and exploitation balance.", "configspace": "", "generation": 89, "fitness": 0.4328930254068373, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.27.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.8408559273209528, 0.8561346912530711, 0.8644065530217739, 0.8342855494388987, 0.8627098852210299, 0.8570757801882434, 0.7950405189099745, 0.8766433124334417, 0.8481746272183489, 0.6442578032275026, 0.7249028150539802, 0.7085937056025213, 0.7167546169530739, 0.7092227640931351, 0.7131667833099534, 0.7190985188316987, 0.7102906869825175, 0.7198316747220912, 0.4320823541936405, 0.4493564973240237, 0.41310055985900795, 0.5340123971788122, 0.42524323681051035, 0.5121171107717557, 0.4326734366097106, 0.38791959166466405, 0.39385999636007196, 0.4612782984827567, 0.15706426608603907, 0.11054877793567175, 0.15675559495249913, 0.16829701090425242, 0.3659657340260778, 0.3253160580606085, 0.22514539601939532, 0.1271672129993493, 0.9450061206092343, 0.9508707179851541, 0.9531441206922028, 0.9667040797308933, 0.9512223834080313, 0.8905333286753039, 0.9483389012918356, 0.970007695654671, 0.9432630379713418, 0.5138843142695652, 0.18986197195419674, 0.32952845616630444, 0.33957593725906643, 0.44266495591901056, 0.24428065824573686, 0.4364253680166781, 0.4047637148362343, 0.5380454315941083, 0.8498246125912267, 0.7890820328194899, 0.2246167328665961, 0.845682443947546, 0.8226424652041641, 0.8532216054708399, 0.8245988689074661, 0.8460085716927275, 0.8263236769676743, 0.2630766063405705, 0.17679720799601617, 0.2984190553993781, 0.12176116588878305, 0.2555769917166403, 0.3528615997088691, 0.3386990091847699, 0.1456561400825529, 0.2004983105810627, 0.18127952804529013, 0.18809662056162013, 0.17605493725481847, 0.20606848092890573, 0.14086909066384756, 0.15021310837791646, 0.20044569877707374, 0.35889838777697347, 0.1426980030233066, 0.6962776393004155, 0.724233233413355, 0.7242289231999242, 0.6957548903162496, 0.5910939952052989, 0.678124542966932, 0.7019010781656482, 0.7173965368826989, 0.6974905862358083, 0.6322037871969288, 0.7732735511625326, 0.7628349648491449, 0.736445961908979, 0.7565585097326417, 0.7093098819475814, 0.7449766273236333, 0.8030292898258868, 0.7809349471987482, 0.31042003700141574, 0.3264742712813934, 0.13984082202788417, 0.5980428797504951, 0.26342614308588086, 0.23938476304000966, 0.13828753703857277, 0.30097629233403245, 0.20748832287666752, 0.35445064439242957, 0.5051930939487099, 0.611941825306669, 0.3241256763439433, 0.5852724097326379, 0.3994697116774364, 0.5945743169808934, 0.6242654347415497, 0.582091128510563, 0.7088108146601962, 0.8154780401727201, 0.8068310359028913, 0.8056794048425483, 0.6569933521991271, 0.8298742384617906, 0.8391779151702784, 0.8390616563155308, 0.8206375133214098, 0.1363822475675417, 0.12731413894935395, 0.12363613640970983, 0.1428963786545563, 0.12112913641729028, 0.12430592741573365, 0.12444258844125689, 0.1007808837204841, 0.1282769487128642, 0.13630873521540143, 0.23640969769642928, 0.15234757205828786, 0.17540849448152074, 0.15990299430620103, 0.14623759001311498, 0.2937816681102384, 0.1705796069579355, 0.19953159276146804, 0.5182807139850191, 0.48147096558596725, 0.49738086228568024, 0.5126540566419728, 0.4873771107941052, 0.4664908186517497, 0.5099125210391984, 0.4500311800773177, 0.4525861045203614, 0.3272725769202439, 0.37497956251549747, 0.500853883002981, 0.4601126027997896, 0.3685042920643553, 0.48613683844061983, 0.5130339794637679, 0.5535784228219016, 0.5051418445807373, 0.21994471234746715, 0.18114387625482242, 0.20509628564250348, 0.19542767774710768, 0.20802669333272772, 0.19744249080752208, 0.19813774092776482, 0.18089989509419824, 0.22712456031128536, 0.22413011392720772, 0.5984170724997842, 0.20149916917421173, 0.19928962614396095, 0.25941518821250154, 0.2859181643545142, 0.42940239322655493, 0.20559922539960085, 0.38934811903588495, 0.20952910419190862, 0.8209979007150776, 0.16351875940786353, 0.19256744751927057, 0.19396034220091019, 0.18757751253387756, 0.15796649186039635, 0.17477902660306277, 0.20170459709656552, 0.7829053179824185, 0.20466822970243026, 0.20845174520175203, 0.6925632759055651, 0.2007860584774518, 0.16426902553591027, 0.20807109380293787, 0.21072025617292434, 0.20930408704067127, 0.19280766808477268, 0.1905237750734481, 0.19628246857015108, 0.1746686541490008, 0.18226787584475512, 0.18087137153377675, 0.2344889416533975, 0.18203842278089044, 0.19516377605988988, 0.09119446567146117, 0.0866721276297947, 0.08233878664087446, 0.08737272082112124, 0.07750372756429347, 0.08036621882203121, 0.07897012054974328, 0.07946771301931099, 0.08404058391003599]}, "mutation_prompt": null}
{"id": "969e471b-3748-41cb-bf67-b9db9da2b501", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.6)  # Change: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.tanh(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change: Use tanh adjustment\n        self.CR = np.mean(self.successful_crs) + 0.15 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Increase adjustment\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing a dynamic scaling factor influenced by previous successes, while maintaining diversity.", "configspace": "", "generation": 90, "fitness": 0.43849758652398296, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.8635012821986652, 0.8430735962713866, 0.8424688596082139, 0.8366521904628431, 0.8460575180525672, 0.8368804067465243, 0.8515846763387406, 0.8466998469199218, 0.8507032083626098, 0.7265629124309047, 0.6872804195300986, 0.7201630471540352, 0.7302968774700913, 0.7125048950371922, 0.7423572410119044, 0.6894229408098088, 0.46312723800661504, 0.6878440218326843, 0.3621185226259319, 0.36501960833086733, 0.18536904462563963, 0.36905637384502654, 0.21791847402022857, 0.27567390601237696, 0.2727388550882234, 0.30710564414646246, 0.4079962354829134, 0.2713071524513453, 0.29668464258371574, 0.3200075094008761, 0.13109637432047816, 0.15290118487974758, 0.1254082423328311, 0.134075388253036, 0.23767632052575505, 0.12894385683435217, 0.942810005981114, 0.9770092310537722, 0.9636813344897903, 0.963975871554997, 0.9518168230451771, 0.9243899133624611, 0.9456111401625816, 0.9466295342308928, 0.9399548760932672, 0.5453453458304257, 0.5644910975612154, 0.2502409349807885, 0.30353100949519685, 0.3473260760066118, 0.3631327715264304, 0.4630729255738588, 0.3563427343342779, 0.43363539264639595, 0.8458700792008701, 0.8102192809072782, 0.866051717669957, 0.8421888469106984, 0.8396759439633575, 0.8226202639095295, 0.8517330987171874, 0.8616262944104585, 0.8514501944094749, 0.13093089270043978, 0.20674635405088715, 0.20645972631589482, 0.5132455540985603, 0.28772795666938267, 0.13060560341132565, 0.16279704704963227, 0.22997457642511554, 0.31908409173486385, 0.13966790146124386, 0.12478310707261553, 0.24435331480063804, 0.3237914563955404, 0.2194551595045081, 0.20102074237237155, 0.23257708963971568, 0.2892217064161877, 0.6113373503964612, 0.6686677848310206, 0.6694425888468366, 0.7236511607884556, 0.6822187753174915, 0.6883649983221136, 0.6257587610088866, 0.6415691562889418, 0.6143643301727888, 0.6984593715241141, 0.6916593546660634, 0.7966830589663769, 0.6832672563513875, 0.7682074017559521, 0.7581148906102566, 0.7380337020842205, 0.6401014784842154, 0.7903434448841283, 0.7509671122410475, 0.32945798693659756, 0.14192320061498287, 0.1600616244020936, 0.4278017205963299, 0.44227412657629217, 0.16624049497236715, 0.14337155414584335, 0.33700274978410105, 0.1377267542934516, 0.5176621372878228, 0.6518728171091168, 0.572826327209368, 0.608923338936997, 0.6405999766786602, 0.36168396978061, 0.6179363642088971, 0.59825247930633, 0.34697454592502797, 0.8220655872718986, 0.672614289298398, 0.8126349486451698, 0.8109814277001545, 0.8134721499147544, 0.8221595000820934, 0.8318543933629983, 0.8056714906601066, 0.7752853984693858, 0.13107130252311816, 0.08671775995197006, 0.10859689191168431, 0.11373557089855368, 0.1020584475711126, 0.11719846672946299, 0.09817505463545673, 0.09798139526896377, 0.10225646126574939, 0.1409404394073165, 0.1716784850349472, 0.17209989044973828, 0.14754390874261358, 0.1289684262690236, 0.17699870173927834, 0.2412433121665778, 0.1358285009445046, 0.18436492534433702, 0.5314165815777272, 0.6014573586162599, 0.46123478173353694, 0.4752984138054811, 0.3993653851644241, 0.38237297457565933, 0.5512427672218119, 0.5243550883517656, 0.49885351401424627, 0.4203580841129063, 0.45395703784742947, 0.46981794368104546, 0.409865944250167, 0.3600652480449674, 0.41959903930607356, 0.4011576841540261, 0.44981604608665693, 0.5073523685536728, 0.18960767113514998, 0.18864152458122152, 0.18787256338718017, 0.20383477860439703, 0.22562728928170872, 0.21522205419739082, 0.17247255904616665, 0.19740369211087205, 0.20116546672543956, 0.29209772608194806, 0.185456863821018, 0.34104649708515744, 0.2003600293937534, 0.19386250013730966, 0.20776996728446906, 0.19561592685280915, 0.6663260576427565, 0.21140603540212144, 0.1815108756897985, 0.16892148373175608, 0.8947797054614504, 0.19246572015794383, 0.8648301611643774, 0.1637756305299597, 0.17392245479442403, 0.1642043014056157, 0.6345752035276027, 0.16697463021843073, 0.2045046789598468, 0.805436920123095, 0.8509717340582482, 0.16530452425395503, 0.6377479762473084, 0.8466894222183018, 0.20989181880840158, 0.20425725207776968, 0.17976575843384268, 0.1768790518041593, 0.1888417382461346, 0.1794628441121947, 0.21126631485544, 0.18936891379868914, 0.19647567053905102, 0.18932660616700048, 0.19249303881670843, 0.08240716780458002, 0.07950134276083609, 0.09430737998213956, 0.08717767971251356, 0.09648428983599366, 0.07380444911912676, 0.08186561800209091, 0.07507694852233093, 0.0736791146538468]}, "mutation_prompt": null}
{"id": "ca6211c2-3a5f-4bf8-8566-6c5f324543b0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.5)  # Change: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by refining the adaptation strategy with improved dynamic mutation factor scaling.", "configspace": "", "generation": 91, "fitness": 0.4336844117822461, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.8503820498244377, 0.8577128650438518, 0.8581377418958487, 0.8539770317195438, 0.8661524083159601, 0.8735761322823932, 0.8325614489347293, 0.7653504447752772, 0.7730599776085666, 0.7122264084125007, 0.7387956022950382, 0.734669937186071, 0.5594136501972147, 0.7048212961728242, 0.737077390677928, 0.7211314546446136, 0.7152361712340178, 0.7137397440957423, 0.2525180569913743, 0.36495316411909373, 0.33930315850679393, 0.4770169276037368, 0.2924101705134027, 0.2653536090693358, 0.21760018652413748, 0.31023885614502333, 0.3228964614034717, 0.35093556610713217, 0.16156521326946627, 0.16243128178890676, 0.24899357081486628, 0.14541850092860864, 0.24095366727131828, 0.13101852434658545, 0.42968865654543775, 0.13134333743773563, 0.9708962648906778, 0.9645560074952049, 0.9584221481240136, 0.9554040325435293, 0.9309052389378693, 0.9453466415306001, 0.9362362333461817, 0.9641152478640379, 0.9799088197085012, 0.4667081047043906, 0.4311013367578229, 0.34341624502804025, 0.5175353045446596, 0.3063430533935736, 0.3843404224030006, 0.4307688925375577, 0.38138185125742396, 0.46257894901610486, 0.8697499015408428, 0.8151466243124487, 0.860462857305523, 0.8700536328661335, 0.8573485394414759, 0.8460071460286425, 0.8479227417288391, 0.8447953525707134, 0.8637469131452338, 0.2146203111893652, 0.647064485191247, 0.24934292325085716, 0.23211976517470911, 0.2016137179830112, 0.24472211914418374, 0.586548100482336, 0.1864008902571609, 0.1526222562249634, 0.15929556089522268, 0.16313001632610036, 0.11616431951099326, 0.19347736937273052, 0.18872684665450645, 0.413466774076664, 0.18210608247033055, 0.15105577078885668, 0.12763656446002936, 0.6535906696057758, 0.6382609059490889, 0.7080444792860956, 0.7135338775984192, 0.69116578096148, 0.6926948871789019, 0.6093974437307891, 0.6760467741497188, 0.6997851191536506, 0.7510256468672859, 0.7489339870551519, 0.7563802473579281, 0.7575778782950736, 0.42621686860036045, 0.7283933854184463, 0.8016703472213368, 0.7644980505231197, 0.7894809294809532, 0.07953668778070422, 0.1107497603380656, 0.10911851541532691, 0.019955513773154743, 0.25735331808888373, 0.40555012101346544, 0.334064543125847, 0.2927465341118112, 0.3249515517849847, 0.5987414392460674, 0.3646316760444366, 0.6079602895819595, 0.5466262568135096, 0.5935873882613631, 0.6274550092105862, 0.6279818619004058, 0.6127894419410853, 0.4063773313524748, 0.8177455032561285, 0.6742963057328247, 0.8157067369504898, 0.8146382910651925, 0.8376880840893055, 0.5198750604437496, 0.8125630385117102, 0.7864700404304946, 0.7781072423905834, 0.11484998718608508, 0.09942421043742777, 0.1120192528823114, 0.11257730025308244, 0.12119944816710615, 0.12105341546048354, 0.0997566323308614, 0.09960621429797334, 0.0841387833299676, 0.38613017844068664, 0.18812666533024358, 0.3181991896963995, 0.15539735679609834, 0.16512624167000012, 0.211428517503363, 0.1910541749459448, 0.14428113057291214, 0.15333104808498466, 0.4898312435173867, 0.5326127620589076, 0.468987191947155, 0.551098955581086, 0.5685026367570905, 0.5310715913276642, 0.45157825483620184, 0.5074345522840957, 0.39801249710450415, 0.40056976815486656, 0.4191235031140347, 0.42211094277317185, 0.45275049158946545, 0.4158791849994804, 0.3644620986858014, 0.46002761582551066, 0.4885257815852019, 0.46978650828865376, 0.18534625897715296, 0.1837948297826456, 0.18860258154107912, 0.19213495631888133, 0.18618108642895448, 0.20956295566481964, 0.1834887620165928, 0.20138452136770835, 0.20269187860039228, 0.40665393300011987, 0.171079253508578, 0.5365351206329874, 0.31082250220056007, 0.21102433730478654, 0.6992950581395423, 0.32957894842761903, 0.22354838190532944, 0.5269440452310983, 0.18083467197090974, 0.8519584420998239, 0.8503943591022753, 0.1750506679319056, 0.18223279963963546, 0.19472634821274537, 0.1662923706745476, 0.7978105149678324, 0.16762132803390706, 0.20858153735808604, 0.1636618515546725, 0.20293563234814138, 0.20039790860668483, 0.1994966185789685, 0.2033733324043262, 0.2096089996290167, 0.20374693216571327, 0.20108303341469236, 0.1742985822089157, 0.1816230523553347, 0.17692574955335127, 0.18194429698206072, 0.18187777802851213, 0.18015230998005083, 0.16694472454928033, 0.19682967257256523, 0.17614217477542138, 0.08868231645545999, 0.09052828250339295, 0.08728427417258988, 0.07238050269430019, 0.09343754023483819, 0.08213149632982808, 0.09793340356574676, 0.07888302279829218, 0.07735381537878727]}, "mutation_prompt": null}
{"id": "4dac058b-1f72-40f7-a3b0-d5a3914151c0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.6)  # Change: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 15 * self.dim))  # Change: Adjust population scaling factor\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change: Log-scale adjustment\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Increased adjustment\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting the population size based on recent improvement rates and success history.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 54 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 54 is out of bounds for axis 0 with size 50')", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {}, "mutation_prompt": null}
{"id": "679e401c-63ae-4bc6-b239-f69d8a998f09", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50  # Change: Fixed initial population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.5, 2.0)  # Change: Wider F_dynamic range for exploration\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.6, 1.4)  # Change: Adjusted range for dynamic_CR\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            decrease_rate = np.exp(-np.var(fitness))  # Change: New dynamic population adjustment\n            self.population_size = int(min(max(4, self.population_size * decrease_rate), 100))  # Change: Adaptive population size limit\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.2 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change: Fine-tuned log-scale adjustment\n        self.CR = np.mean(self.successful_crs) + 0.15 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Increased adjustment\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance exploration and convergence by introducing an adaptive population size and mutation strategy based on landscape feedback.", "configspace": "", "generation": 93, "fitness": 0.09262011644195525, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.08.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.11869729595922507, 0.12122261497871079, 0.2636641133856341, 0.2858635646104938, 0.10750000009520266, 0.11042008850345264, 0.12326567805787303, 0.2438207756696893, 0.11975713134751098, 0.2806915206899261, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10044839976087183, 0.018868215435801305, 0.015239690362355174, 0.03819418887307491, 0.04333423275483528, 0.06328754906362499, 0.07074832271546039, 0.04151056602507852, 0.03496821576322817, 0.09025700642202517, 0.020676567405189084, 0.05706975577853446, 0.01959972157639278, 0.09235357756462437, 0.06587753671077667, 0.014763392921912755, 9.999999999998899e-05, 0.026137699681951343, 0.06509297290631966, 0.059250803136232544, 0.21001841346892902, 0.1011923811489609, 0.09421494516253826, 0.07381128083662714, 0.0933175423768704, 0.08482513041590589, 0.27140791935083164, 0.06274794416174423, 9.999999999998899e-05, 0.02608140348673682, 9.999999999998899e-05, 0.08913283204115963, 0.0911197211367899, 0.12856198294227927, 0.06029716383835271, 0.06487991664166093, 0.1345395291348035, 0.08335093712817943, 0.09025559348785084, 0.11411704210373741, 0.07285119553694963, 0.17622039465705053, 0.05498943618675145, 0.06842315324783299, 0.12170683071120825, 9.999999999998899e-05, 0.08210615218595574, 9.999999999998899e-05, 0.1185721534762797, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15288390140721553, 9.999999999998899e-05, 0.07985286422278481, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05697934280958561, 0.04155579007374888, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03177041934965308, 0.07820111258466877, 0.017283915507292802, 0.056106087481391786, 9.999999999998899e-05, 0.02438995548113221, 0.04079836984498597, 0.029524489173831547, 0.027693442132737944, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05484878126343118, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11034098917183166, 0.16709881423443151, 0.2804900129201293, 0.12502274300631455, 0.11614788321128033, 0.11159870658088933, 0.23067334258529204, 0.12217493222959597, 0.15371483673315944, 0.04356579417990414, 0.038225886971736456, 0.1346272925430254, 0.1176641808942882, 0.10026140212695478, 0.01759993274736349, 0.07483783533283606, 0.061579910646278546, 0.04865963577582699, 0.13688408472789215, 0.17718637419610184, 0.16852211213705792, 0.17697537082802006, 0.20311834285981611, 0.15485415745541664, 0.11829769082516373, 0.16862228361165688, 0.15854498050405563, 0.22867864197660115, 0.1262145820164018, 0.29738573696874415, 0.2225726679981196, 0.1526749133138705, 0.17338622632733236, 0.22561655397623193, 0.17377774300845283, 0.20227959122192474, 0.12058812983216427, 0.06382709899872008, 0.08878944362505403, 0.14538947257588575, 0.1233703387734606, 0.22965844360281606, 0.115809271343157, 0.0997711199450243, 0.11357243661342364, 0.2026209597976245, 0.18333031561847557, 0.17398535083650257, 0.19592115710603886, 0.18027485114832675, 0.19917247353999656, 0.2189268571045896, 0.1469128852722411, 0.19855030574721033, 0.1979032418899218, 9.999999999998899e-05, 0.14854547255336825, 0.16004547605137487, 0.1659701423948725, 0.16222003584875344, 0.18150733972484, 9.999999999998899e-05, 0.1401682650955074, 0.15020591240757453, 0.07466602457976645, 0.16825023998304878, 0.15661198747950789, 0.19374823998025215, 0.1680616171083923, 0.14183034736050104, 0.11339926851176385, 0.11507777838097699, 0.1693079140244499, 0.10695525611581347, 0.06932034027342138, 0.07917225846310161, 0.10444390048843688, 0.17200283904500835, 0.1560703916293933, 0.08891628526213047, 0.11262736317016353, 0.18604794177675532, 0.18425978132128262, 0.1792760852562093, 0.1899575074362505, 0.21237986902363104, 0.18515068368736742, 0.16228600812806526, 0.18588333715126681, 0.19082048915508953, 0.08448727104185694, 0.07417544299903223, 0.06267660286798804, 0.09778445787518808, 0.09999055023408177, 0.07240823761458581, 0.06624327760202176, 0.09223642036461499, 0.08409548842554071]}, "mutation_prompt": null}
{"id": "319f7b50-2b21-44cc-bc60-50daa9edb5a4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.8)  # Change 1: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.6, 1.4)  # Change 2: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 15 * self.dim))  # Change 3: Modify population scaling\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change 4: Log-scale adjustment\n        self.CR = np.mean(self.successful_crs) + 0.15 * (1 - np.exp(-np.std(self.successful_crs)))  # Change 5: Increased adjustment\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Incorporate mutation diversity and adaptive population scaling to enhance exploration and exploitation balance.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 53 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 53 is out of bounds for axis 0 with size 50')", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {}, "mutation_prompt": null}
{"id": "800c1980-1fb8-4c0b-b7b2-88144cc7a8f1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n        self.dynamic_factors = []  # New: Track dynamic factors\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.4)  # Change: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.75, 1.25)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n                    self.dynamic_factors.append(F_dynamic)  # New: Store successful F_dynamic\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = np.mean(self.dynamic_factors) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change: Use mean of dynamic factors\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Adjust CR update\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.dynamic_factors = []  # Reset dynamic factors", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by introducing dynamic adaptation in both mutation scaling factor and crossover rate using a feedback mechanism based on successful trials.", "configspace": "", "generation": 95, "fitness": 0.3263168401397158, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.7925327638580851, 0.7959711771262548, 0.8059240245681788, 0.7360984150634551, 0.7473296616899462, 0.7588444286619537, 0.7704206061832686, 0.7997612326454279, 0.7994636791181949, 0.32486341424612697, 0.38672189279840374, 0.2341421647710099, 0.18354060286249396, 0.3730022217799518, 0.38059504500066377, 0.34233457945189316, 0.25896299612542095, 0.3381149870592939, 0.09550101749176099, 0.11946543641018492, 0.17255636312158074, 0.1739766363094788, 0.13116166171432564, 0.22348330465700394, 0.18099613808373727, 0.12286500785931254, 0.14261753821125767, 0.12058190375045197, 0.10758900045821007, 0.11125641373091943, 0.1102700379914735, 0.1110007166076753, 0.11452986507362206, 0.11129880843816864, 0.08952064920272529, 0.11693301209937867, 0.9579022243198, 0.9640782269204551, 0.9604838004273489, 0.9641437232009662, 0.95129072467451, 0.9577119879446907, 0.9595432105663472, 0.9768554888959339, 0.9476338125075603, 0.3344810303018506, 0.3108486706729995, 0.3347828615784363, 0.4466554723937739, 0.33528586622221, 0.38522893878490705, 0.2946869533485721, 0.3226368939894555, 0.2739990167272167, 0.46851468699349275, 0.3330082964688208, 0.6329927991278408, 0.6291427501400477, 0.7281029143370035, 0.49445888942075067, 0.25511270758063165, 0.5825632501260063, 0.6654830504468747, 0.4729035511979428, 0.20097417051572375, 0.260053480473765, 0.1741140511656165, 0.1913814194845137, 0.4764204017682626, 0.3621246752190397, 0.344797265448735, 0.4055271394658949, 0.14661285989572426, 0.052029696458541386, 0.5113323714517906, 0.1579050077601878, 0.5319525058979646, 0.3036787262968227, 0.24340777827575222, 0.17887650480359285, 0.10387843040801159, 0.35497875505501053, 0.34480742251606633, 0.3831303757163661, 0.41429961947829275, 0.03860014552590618, 0.364198074534379, 0.29866087244490547, 0.38193156794320626, 0.3599227110390144, 0.6261819089733058, 0.24916411956728357, 0.5754430844245955, 0.5551403944084548, 0.620730489286788, 0.5025372753412725, 0.5151653909523379, 0.6503565676150043, 0.5953935986247005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05120865698439936, 0.12326223199755404, 0.020913388068204974, 0.12860359888533945, 0.038481724874334544, 0.06987871927697742, 0.24043823778770257, 0.32502915799635523, 0.3310431962232615, 0.30961921133197834, 0.3968213659521318, 0.44119035660285655, 0.3709198973702964, 0.35229052183184695, 0.4188349084363897, 0.6347118231600246, 0.7319991021345937, 0.7831858030241114, 0.6565916151386573, 0.6896991199530871, 0.6321836843368811, 0.7339074100665346, 0.6949462868074263, 0.7659046213497458, 0.08757224348136228, 0.07417096300386583, 0.07655203258450616, 0.08232900693541012, 0.0920087205241995, 0.1118703805973722, 0.08324788860627563, 0.11665233603024949, 0.079034270709199, 0.1376752424869555, 0.12887202274128995, 0.19310721371883188, 0.13946167745596338, 0.12760921252705704, 0.17285559016651786, 0.15890945181329752, 0.284643624535159, 0.13503635693135851, 0.38499681616019465, 0.28270582685403234, 0.27454965106896656, 0.34971154987262354, 0.37497260078067607, 0.3501719106468979, 0.3279351712869458, 0.3337908643288151, 0.39843399897470744, 0.23873013815345356, 0.2975696962402774, 0.24722499981327584, 0.24601259306016787, 0.1854134941572384, 0.28787264772857746, 0.17749974001178048, 0.19852097677116043, 0.2715700600411687, 0.17786090861103043, 0.17157918092550206, 0.192320174909413, 0.2031097573369307, 0.17680893172633572, 0.17808351277760992, 0.19366352274785525, 0.18639502896062632, 0.18945804574073755, 0.18278913301883692, 0.1963545055612531, 0.17508099309406921, 0.1873210000698754, 0.18361176432299564, 0.1978755294029878, 0.1959394403255007, 0.19363440553931832, 0.18564405306981913, 0.7047016947714166, 0.2055955539249802, 0.7312527808198426, 0.17317140261699482, 0.1842176099858397, 0.695080427828904, 0.1439098748234393, 0.2130725256665672, 0.36811980497214614, 0.19113734732310406, 0.1619044088990369, 0.20005828305358297, 0.4737752076610722, 0.19400592574835696, 0.44162493966733274, 0.19990429400862963, 0.19879489396053407, 0.20314751461833047, 0.17928007415620995, 0.172145692896588, 0.18831512399555073, 0.1870419669698773, 0.20857248861737565, 0.19499097946576927, 0.22012324853355925, 0.1938122695942247, 0.17944383833721222, 0.07349544111648643, 0.07036948543851362, 0.07660068697183398, 0.06416888417220556, 0.07344791131006623, 0.07384461012563348, 0.07592937046013049, 0.08299040396648649, 0.06713694339498855]}, "mutation_prompt": null}
{"id": "1076b143-dfbe-47e1-92fc-57e91bf6fd9d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n            avg_diversity = np.mean(np.std(population, axis=0))  # Calculate average diversity\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * (0.6 + 2 * avg_diversity)  # Change: Adjust F_dynamic based on avg_diversity\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation diversity by dynamically adjusting the mutation factor based on the average population diversity.", "configspace": "", "generation": 96, "fitness": 0.10788304422360372, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.20127717654160737, 0.18339869829245592, 0.1813285252118032, 0.1742925305960512, 0.17182416538731082, 0.2232584383814551, 0.12522558674544904, 0.24822993274936145, 0.2638542631377243, 0.021550139163722948, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008633933265399185, 0.07012506352435288, 0.060587501282928, 0.056493026440395444, 0.06469480298172203, 0.07020909991094182, 0.06161435697055517, 0.003207711295338922, 0.07822313204650677, 0.040935592230244455, 0.042630046565170776, 0.04910750528049834, 0.05310181654410662, 0.056044895319720456, 0.04231430396726554, 0.03506097304876854, 0.07522172796788162, 0.045086792036522993, 0.03407090032017368, 0.9841508917777324, 0.9887302888754952, 0.9865519848080464, 0.9777120047242029, 0.9904039464516589, 0.9819403998821689, 0.9858593977127815, 0.9845316086497264, 0.9840883450868043, 0.04616695855755404, 0.06239890540505899, 0.06090088099918245, 0.012646823388751338, 9.999999999998899e-05, 0.05798666446970113, 0.07528496270215201, 9.999999999998899e-05, 0.07662445500381632, 0.05219468598181798, 0.019036580482180376, 0.051607821222809824, 0.11391750639571474, 0.09485879111748252, 0.08421315082115433, 0.05658365818564648, 0.05599937307460301, 0.080810280487015, 0.017119461869365638, 0.0013704961005077676, 0.006914182564981219, 0.006144137397920746, 0.015856917327809583, 0.013062712146017064, 0.00768316351741527, 0.010700187013185314, 0.004208753877872007, 0.010033402981834638, 9.999999999998899e-05, 0.009544978600132925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006839810643989308, 0.0032644126288592368, 0.005097652443899592, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006707589556791738, 0.0006181072896063178, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026580685920946423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001080461179201464, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014514416412737208, 0.007904510183102675, 9.999999999998899e-05, 0.17166901025889014, 0.1706591462132303, 0.1586673699734229, 0.1862096167553936, 0.1471044612477166, 0.21844816640555276, 0.11452949371468912, 0.12639094677679152, 0.12247655928102208, 0.045348220745681234, 0.029268598906980525, 0.06431823412275339, 0.03449528413350578, 0.03884821176335096, 0.041981829673044424, 0.035393595301252745, 0.03775759331994688, 0.03500213398911878, 0.10705406539479012, 0.15925321745011023, 0.12083437044119438, 0.10030757322266093, 0.13991801588858632, 0.09614296163066105, 0.09959889652964116, 0.08141846704669009, 0.08940846746076792, 0.1486366429719408, 0.14801799595218945, 0.1272837812406995, 0.13999565763066224, 0.14290156243145502, 0.13763631817104816, 0.14241332231291381, 0.1362160987104708, 0.12314416550310125, 0.08219782219768257, 0.08593185248622082, 0.0774956285911459, 0.07621762126779374, 0.08232857728239085, 0.07117946500379635, 0.06607704941952397, 0.10767718885637345, 0.09738325613837784, 0.12663156937511288, 0.1276704410658025, 0.14273727968765337, 0.13879127071919406, 0.12836208092277868, 0.14916009471082214, 0.14949190932767664, 0.11678714545906166, 0.16648128963766595, 0.12818245237776993, 0.0921895161083034, 0.09942060546047138, 9.999999999998899e-05, 0.08711232369031208, 0.08369238933891443, 0.10846777661247742, 0.053143919797851935, 0.07973435733963175, 0.07226359385841774, 0.09030566881724611, 0.12238390081503225, 0.10438308703106702, 0.10590832343482903, 0.1112441438689522, 0.15286159098607022, 0.10429513730895068, 0.1016070281970044, 0.1128114639090465, 0.10774514420572356, 0.10249502646605646, 0.0750178952456848, 0.11092325903970146, 0.10641336634352261, 0.2205158188972739, 0.12085446945930722, 0.11354177696860135, 0.1441408623489011, 0.15710021354856474, 0.18898748652228914, 0.1564677192691204, 0.17253663999939706, 0.15824338627410395, 0.13939456368013037, 0.15706901799064565, 0.14213381731446428, 0.03529829306882093, 0.046386436611387194, 0.02959947718479128, 0.038314602062240244, 0.03469532885887161, 0.02976333527846997, 0.057303757127379895, 0.025728874412892955, 0.03138731196271871]}, "mutation_prompt": null}
{"id": "a31eeb2e-05c0-4540-96ab-cb096da5400d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.7, 1.5)  # Change 1: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.75, 1.25)  # Change 2: Refine dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.2 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change 3: Refine log-scale adjustment\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by adjusting mutation factor based on successful trial performance and refining crossover rate adaptation.", "configspace": "", "generation": 97, "fitness": 0.4310476611214287, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.8420518503689352, 0.8503146863022641, 0.834895324678973, 0.8285553900434751, 0.8537746048247558, 0.8414493686098962, 0.848395142897184, 0.842715627562671, 0.8615142446250645, 0.7064669836832858, 0.7205820519245618, 0.7379376027001858, 0.6724204022826665, 0.7227916127572447, 0.7292741845499209, 0.711908851061646, 0.7182227429149646, 0.6830979633990719, 0.2361913648488594, 0.2673210798518437, 0.27457593077282016, 0.2856441116432672, 0.29888931490221227, 0.44172570301923975, 0.31298854989542313, 0.30465316671834297, 0.3183189817158647, 0.14197788159452307, 0.18368805780517572, 0.3308457030928317, 0.14798280584299062, 0.14942486294920454, 0.2008257955407169, 0.30979445306298226, 0.18900019728967643, 0.09815995953593826, 0.9577651721487008, 0.9531500657454288, 0.9640655533830006, 0.9352343441470213, 0.9364303561358582, 0.9614239627335426, 0.9455771112951463, 0.9370278590868715, 0.930150409717543, 0.4436827936118828, 0.4549571608132529, 0.2892444704393462, 0.3713568478261944, 0.3988150387003234, 0.591696488130623, 0.35049691761235824, 0.31846868680780116, 0.3121632685186656, 0.8205282740844269, 0.8474567904516198, 0.8827809191343367, 0.8380971981474772, 0.8412196545653614, 0.857169586193536, 0.8419674610124432, 0.7989009913063674, 0.8311671870214095, 0.168052236865198, 0.15763581834496876, 0.1731834267887209, 0.1967644669417158, 0.17597285477853308, 0.21796730518826646, 0.23749139100651095, 0.16666222692570465, 0.23229100771276368, 0.18789261843025318, 0.22255751649088962, 0.16187347530510665, 0.6437630164613615, 0.37293970618534644, 0.17286809687710336, 0.3894674351535975, 0.1873705962117289, 0.19561934344215093, 0.6648561913001547, 0.6832482377452045, 0.6593641988423118, 0.6788006244925961, 0.6851940790339978, 0.6841411109028241, 0.7052972004460702, 0.6864363149866217, 0.6637430820609567, 0.7821773432769954, 0.7590860242670192, 0.7559723095099483, 0.7536035171779234, 0.7541203395444501, 0.7658996028036226, 0.7954106682464902, 0.7616647931641686, 0.751839818006217, 0.24907124218605858, 0.052794736482366766, 0.12876685496333284, 0.6192702129118759, 0.591639187692059, 0.5984420534286696, 0.1937772729610553, 0.1996333110546198, 0.17096504995414086, 0.5801595320317762, 0.5874273565932902, 0.3473134689611457, 0.5899527986675533, 0.5728628257243742, 0.6074426291040989, 0.598437110330504, 0.5722556964832805, 0.5935851978167547, 0.810931360514968, 0.8040486301900875, 0.807150550398666, 0.8251923835992342, 0.7981130141632583, 0.8115327523752998, 0.8142739942095629, 0.8153466578764085, 0.8337944873545734, 0.09938738462275709, 0.10865651613014493, 0.08921342608970895, 0.0932213424550058, 0.08977225072684725, 0.11437202543217428, 0.09124707777851038, 0.11386188388458873, 0.08859696737528377, 0.1512753889995644, 0.14645763597913808, 0.1515409164464494, 0.23417744544761931, 0.19697574526809114, 0.32546375865933774, 0.12759426943939867, 0.2397391292226616, 0.1506030465888193, 0.4389593145266968, 0.5304739759109547, 0.4971523571391814, 0.4103632097245282, 0.5859705520588955, 0.4120988669474174, 0.6226105593623494, 0.5340342300261571, 0.4877407255424825, 0.46965686052305555, 0.3952072021797014, 0.4953338091647408, 0.299828461122423, 0.36684113254577877, 0.442511760920842, 0.47943253366768335, 0.508602764131658, 0.4590880378559321, 0.20238276275056977, 0.20890516938843762, 0.1991190314563468, 0.17647140727981947, 0.19369743391155048, 0.18363223295935083, 0.1924287561781558, 0.18728035546856459, 0.1887288491016612, 0.22100547777895618, 0.42019294997849743, 0.2337895028239788, 0.1846785527886584, 0.1910499756663956, 0.2190784349904472, 0.2036247482670943, 0.2106770032158235, 0.41592801491596276, 0.1972125727998193, 0.16917052774362396, 0.1550581818971859, 0.1772577591086465, 0.7517535251323648, 0.16267553186242256, 0.17796753184845115, 0.1816593683591492, 0.1620983113007214, 0.2060146246336605, 0.7574665449913636, 0.2047558189350559, 0.2041632143058688, 0.7280569012965521, 0.2015422904432982, 0.20574764520321476, 0.20786203746183085, 0.20473472656347103, 0.17145508646159324, 0.18343536437490426, 0.18525145864886694, 0.18602606695636603, 0.18467080211606335, 0.20803320057487495, 0.17294883806836314, 0.1972031136804956, 0.21597528457832726, 0.08767797281181389, 0.07692319922789215, 0.06951068538389937, 0.07370704737094691, 0.07843083345192392, 0.08029232127205455, 0.0944032775621032, 0.08843112685279064, 0.08120929914604713]}, "mutation_prompt": null}
{"id": "c57314ea-2e7c-491b-a4c8-df68796bacd3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.65, 1.55)  # Change: Adjust F_dynamic range\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.75, 1.25)  # Change: Adjust dynamic_CR range\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.3 * (np.log1p(np.random.rand()) - 0.5) + 0.15 * (1 - np.exp(-np.std(self.successful_deltas)))  # Change: Log-scale adjustment\n        self.CR = np.mean(self.successful_crs) + 0.1 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Increased adjustment\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune the mutation factor and crossover rate adjustments to enhance convergence precision.", "configspace": "", "generation": 98, "fitness": 0.4337425899578778, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.8564763594304428, 0.8595468805026789, 0.8551860388660788, 0.8629219248739647, 0.8653671983743934, 0.8464035207004807, 0.82895429851893, 0.8525865781397719, 0.86204771171515, 0.6665268966762132, 0.724594272202232, 0.727441758163589, 0.6416502403788085, 0.6887689084104529, 0.7226680234425493, 0.740046911016871, 0.7365214313943853, 0.7404344496286075, 0.1648561007868744, 0.28525803431618946, 0.47696044459817044, 0.28568409580205845, 0.12095368958016084, 0.15676985233573437, 0.4040250708298724, 0.25034247354282146, 0.2821341475874397, 0.3468308571155917, 0.16188667977336513, 0.16269847496249545, 0.2001798953177587, 0.37234373483700123, 0.2179565875221594, 0.10040387462620692, 0.2760836828092138, 0.2750186531833879, 0.9573154502970947, 0.965696382471285, 0.9555721055346955, 0.9653112309392577, 0.9573195271227689, 0.9210483080762477, 0.9628964144791173, 0.9476412920545236, 0.9645235943171513, 0.2719714820611593, 0.35950985987878525, 0.34382851345160903, 0.48226606664144367, 0.32312747862226, 0.42164958888961257, 0.19127552528823943, 0.30872688598594333, 0.46581186396830154, 0.8407409345863454, 0.8317473819934855, 0.373865255335611, 0.8464386198576728, 0.8540167021699354, 0.8338512870116723, 0.8661045300478099, 0.8459288632929105, 0.8011994114520075, 0.3161179691750061, 0.196882580781381, 0.1947351947140893, 0.11821189612925809, 0.17506746890823377, 0.2432806588746963, 0.1730766174772772, 0.7122638736659064, 0.19381594201761376, 0.17548388284503402, 0.24162731696400364, 0.5840398286714501, 0.20228956917135588, 0.25973552686662005, 0.21017809032370183, 0.13921375795433755, 0.25270075426296135, 0.18186109923989047, 0.6756843303343083, 0.7168010716665201, 0.6962289037046518, 0.6561448786897435, 0.5014328262282572, 0.7058148113899252, 0.663851430407064, 0.5522995291620139, 0.6734214098956498, 0.7443622355030819, 0.8062433135869909, 0.32847063167862556, 0.7700326674597904, 0.7585224106497893, 0.7668784861863907, 0.7914935216064177, 0.741392386489604, 0.7851350265684909, 0.10566369350981153, 0.11059045919206378, 0.1382575711373778, 0.4833963770500721, 0.3683560484828764, 0.501798327150596, 0.28547348806178163, 0.2345599720639513, 0.15500913501199975, 0.5952281571718478, 0.5136497670711786, 0.6125144152550577, 0.5577483060180284, 0.3407050654006728, 0.633330887401091, 0.3882312578845242, 0.48326223752049546, 0.5633971405371896, 0.7880484536191286, 0.6921804076009979, 0.8162120392071744, 0.8110607100479522, 0.8182997801819243, 0.8371799210761545, 0.8318868632747065, 0.6858261613016301, 0.6338866791285227, 0.12181548983430635, 0.15596608193762873, 0.11047882578483348, 0.12470350403652597, 0.10162672926166938, 0.12472934845732797, 0.10512591621963474, 0.10015995899135055, 0.09141023470946819, 0.17140466003001098, 0.13336505692527845, 0.1502072547080634, 0.14852685283838996, 0.1697428663943501, 0.23380128098082387, 0.19799266664431436, 0.2754776116941099, 0.14326006905646171, 0.4141627827989133, 0.5064853170444463, 0.5042392741642188, 0.49245970085105306, 0.41050516732493325, 0.5695723784467863, 0.5333006966610577, 0.5357035860783981, 0.4318575166879528, 0.40981176300219313, 0.5235320383784712, 0.4445914801371148, 0.5431620791077538, 0.45171248338984327, 0.4887268018971279, 0.5134176629770013, 0.4661963791809579, 0.3738613831822285, 0.18752472605738912, 0.19946232015783893, 0.20388281027948418, 0.1848962375508797, 0.23647395264631366, 0.2335137657151719, 0.1893349218557805, 0.19343672376242438, 0.1868552479058181, 0.21806643135385184, 0.20402328409143133, 0.30820275628162586, 0.19314239049315052, 0.366741561533411, 0.5400017237352486, 0.24275096477570968, 0.20249899722111464, 0.20697269450223088, 0.17696523843929646, 0.7305849728522028, 0.16421156263102366, 0.8509715505500434, 0.6906760084904724, 0.19194932550695798, 0.41951033562761186, 0.8128260813998459, 0.17439015699507454, 0.20581107584250757, 0.8163606538611718, 0.20691350724087276, 0.8470061000041313, 0.19742399847808279, 0.20197980707167162, 0.20983899095822123, 0.21073716431823775, 0.20843466089873486, 0.19004628181471683, 0.2005503316799513, 0.18067509959139227, 0.19234817251675895, 0.1942258293319039, 0.18193468917145394, 0.19803036699917953, 0.17911261448022375, 0.18529882162663602, 0.08377458669053395, 0.07911602992308742, 0.07659296358444934, 0.07294330524304116, 0.08311994902875319, 0.08048957561915138, 0.08764325701567355, 0.07884825902609349, 0.08772416826057383]}, "mutation_prompt": null}
{"id": "67416e26-fa09-4296-9aa4-2879111b9f5c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.F = 0.5\n        self.CR = 0.9 * np.random.uniform(0.8, 1.2)\n        self.successful_deltas = []\n        self.successful_crs = []\n        self.adaptive_scaling = True\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = self.population_size\n\n        while evals < self.budget:\n            new_population = np.copy(population)\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                \n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                F_dynamic = self.F * np.random.uniform(0.6, 1.6)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n                \n                dynamic_CR = self.CR * np.random.uniform(0.7, 1.3)\n                cross_points = np.random.rand(self.dim) < dynamic_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_deltas.append(np.linalg.norm(trial - population[i]))\n                    self.successful_crs.append(dynamic_CR)\n\n            if len(self.successful_deltas) > self.population_size:\n                self.update_parameters()\n\n            improvement_rate = np.sum(np.array(self.successful_deltas) < np.mean(self.successful_deltas)) / len(self.successful_deltas)\n            self.population_size = int(max(4, improvement_rate * 10 * self.dim))\n\n            population = new_population\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def update_parameters(self):\n        self.F = 0.5 + 0.2 * (np.log1p(np.random.rand()) - 0.5)  # Change: Modified scaling factor for F\n        self.CR = np.mean(self.successful_crs) + 0.15 * (1 - np.exp(-np.std(self.successful_crs)))  # Change: Adjusted CR update scaling\n        self.successful_deltas = []\n        self.successful_crs = []", "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by refining parameter updates through dynamic scaling utilizing the success ratio of trial vectors.", "configspace": "", "generation": 99, "fitness": 0.41792053510407096, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "73ff25a4-cec4-4a9e-9499-fca1ef548071", "metadata": {"aucs": [0.8553436960964826, 0.8639729455486338, 0.852023742710764, 0.8438336344208781, 0.8701584722117204, 0.8640086868166847, 0.8495338270018147, 0.8658270566683552, 0.8659839742740868, 0.7529723731322732, 0.7524703384979692, 0.7381041545867983, 0.7392988660831042, 0.770743541982898, 0.7445655527236084, 0.5870793485343297, 0.3725425371400216, 0.27910082083577814, 0.20349012229965746, 0.3228652915210982, 0.12451233180646104, 0.44395824108187487, 0.2886785575972918, 0.5156933732325284, 0.26977475076715995, 0.37800998133036146, 0.26262227658859716, 0.1332187539889954, 0.14455621694584664, 0.24430430573648976, 0.13388837678339893, 0.2301161976099958, 0.1430020042576876, 0.15771948572944605, 0.25390862172373707, 0.13041321289471985, 0.9659375289622355, 0.9478420344998687, 0.9549997045012414, 0.9820859965865009, 0.9558492453291098, 0.9536137585435589, 0.9421702865279505, 0.964272301014196, 0.933562049117448, 0.48481723842082847, 0.19903927861721227, 0.22921003507157922, 0.38480449118089133, 0.30990078947973865, 0.29169803761694035, 0.2381227443462821, 0.3949922020456169, 0.4087165926564469, 0.37685042590538664, 0.8458935143992015, 0.8709339602433336, 0.8871024486580076, 0.8789362113685281, 0.8572865284233266, 0.8597815510360167, 0.8797103732087441, 0.23059305710186362, 0.7203340784946692, 0.26031091473475176, 0.13819026294349046, 0.23756114666475292, 0.36838060101935177, 0.17482399926269887, 0.7165712667296358, 0.22449184132650513, 0.18643151639240652, 0.11508923824262907, 0.1299374720389016, 0.1296103028713138, 0.1299030897364446, 0.225230293790583, 0.13157672682973187, 0.20201652751839771, 0.21142662780936206, 0.193014880089589, 0.7295469133236105, 0.11659629190008658, 0.7326021826671485, 0.5431544859904286, 0.2657800388302938, 0.697701707225533, 0.27369868079638937, 0.36915488546588726, 0.1894805848960125, 0.8074462770827976, 0.795002598424098, 0.8041443134908899, 0.12332859949891517, 0.7427265638094238, 0.8009765719755, 0.7883673337800037, 0.7922977443342909, 0.7026228915053732, 0.09354072562690674, 0.10857878347725491, 0.22502521599197978, 0.3102887591672887, 0.17742688282072483, 0.6067283077746342, 0.1656449043104702, 0.16630918998264865, 0.12537157137541166, 0.6353444343471313, 0.6593027501760828, 0.5880397209274573, 0.651704990592703, 0.6000246998233997, 0.6583010926073951, 0.14220973492628164, 0.6339496337845254, 0.377909775880788, 0.6559924754640023, 0.8153210963016532, 0.8536164700453145, 0.6601909780676746, 0.8557922300053746, 0.8591302329033674, 0.7319879986587872, 0.8319404762766084, 0.7661731044091284, 0.4144513869039068, 0.13892467693211819, 0.12894059641966438, 0.12538324827364378, 0.1367308688621257, 0.09709336345403496, 0.14753346489442265, 0.09391980916275422, 0.14093185658464868, 0.185219557873613, 0.18187570712436396, 0.1418460210046416, 0.16276178039688893, 0.4126436486425782, 0.1979083182991178, 0.2545842692619893, 0.15697500519897856, 0.38441747659430403, 0.48086742167451824, 0.5726069287140211, 0.5567602562386685, 0.4455456845814877, 0.4284174716184266, 0.61363392662907, 0.47104474189459666, 0.3051421410204974, 0.43209873238538643, 0.45454986899607475, 0.44571933024841404, 0.5334360855044337, 0.5524971171646307, 0.5216311250490653, 0.4896685337953254, 0.4910319416648459, 0.46733329881729824, 0.4950907943820202, 0.21036889004864234, 0.22079604072493597, 0.18421228260493894, 0.1940601909352513, 0.198013661639594, 0.202704417527509, 0.22394023970015065, 0.22449675822798587, 0.21862788991617543, 0.1886209232979421, 0.18514652213557248, 0.19852842824849082, 0.24473402520165743, 0.20507012671742741, 0.24680891581900755, 0.2314514450570857, 0.6118244648567073, 0.20438358939480672, 0.2005241702013646, 0.5238468468106229, 0.8621372062438413, 0.17530115312554628, 0.8585844603182486, 0.16464255363288427, 0.8728691186382588, 0.17278193848281187, 0.20486944710230748, 0.21066148908358295, 0.4468944984556785, 0.8273449192635147, 0.16693643792022705, 0.16544688177751, 0.2068090021169131, 0.1252035391665307, 0.20430128306579098, 0.21035102592850663, 0.18586880741995193, 0.18739225177531693, 0.17225002750547225, 0.18615424951378867, 0.17946514041343686, 0.18013696473604213, 0.18353127970779326, 0.19868430241026536, 0.17925143616721484, 0.08225875958904816, 0.08179127669295361, 0.08188037465667786, 0.07746474049997487, 0.08677740622994279, 0.08908511643486561, 0.08298828347200449, 0.0867993201011712, 0.09415086226231084]}, "mutation_prompt": null}
