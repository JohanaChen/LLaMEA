{"id": "b98c0795-1e97-4727-8813-bb172312bece", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Adaptive Covariance Matrix Estimation (simplified for this context)\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "A hybrid metaheuristic combining Differential Evolution with Adaptive Covariance Matrix Estimation for efficient exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.3730526295475581, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": null, "metadata": {"aucs": [0.938737490984471, 0.9407994402105563, 0.9071375907927056, 0.8175894667608278, 0.9373744909963451, 0.9382971437657547, 0.8904039224446482, 0.9428681965669438, 0.45189581414828894, 0.8211825838442548, 0.8370045696734377, 0.812975254084344, 0.8371827499246377, 0.6777291524330035, 0.8503698594414004, 0.7529654427865242, 0.8377770300391332, 0.8440549176466097, 0.1715402233264255, 0.170162762872913, 0.18228055503897744, 0.5753343667026025, 0.17911380466581106, 0.11543047335680623, 0.3011173876046024, 0.07148529593883102, 0.0699505624571164, 0.08578598346039668, 0.09706629508551268, 0.16138095508256833, 0.5604711174125085, 0.10554106618348558, 0.12055234341257237, 0.15636149783314413, 0.12563112748578364, 0.13063997659104387, 0.9420015619841741, 0.9351952986643843, 0.913031034833277, 0.9444982392106692, 0.9240980812496414, 0.9308100484816406, 0.9875412234519362, 0.960042974387761, 0.917467756359379, 0.5939229878762602, 0.36431166956162975, 0.6917522051310021, 0.10174621331974232, 0.3993382813248244, 0.27046603494729526, 0.6929851634352303, 0.7027017441648469, 0.26117629920930563, 0.9693989094763481, 0.12690850722636837, 0.15130299801812108, 0.9706106087472097, 0.19214793584364653, 0.17681214997140182, 0.3657664472103336, 0.23749363567090853, 0.9439301086559857, 0.29813039829954646, 9.999999999998899e-05, 0.16268773076217602, 0.20297690645813216, 0.2178744867643474, 0.7182218938539936, 0.38443233446482705, 0.2115979978123712, 0.2335231222839228, 0.20420435065656217, 0.24104130066001206, 0.1616894474465489, 0.19893758374482184, 0.2773846771391555, 0.26256174959404266, 0.4112530739041098, 0.22723687955140892, 0.5348706482008404, 0.2862734022152942, 0.29625051103770217, 0.004921562903558718, 0.016338755165618002, 0.013509950681254712, 0.01728039876580134, 0.10945649096857923, 0.15839459048304905, 0.25142847189589046, 0.19956562557130608, 0.4366653129287109, 0.2667100246442635, 0.1196694580912594, 0.26146532752282037, 0.18791349395572343, 0.2849396606080683, 0.32892144400538936, 0.1671655158158415, 0.20337523585597828, 0.25411485071598183, 0.38828731553707774, 0.1311604896812365, 0.3029147288160179, 0.11148435592306627, 0.23809143380535303, 0.24710187405253414, 0.10613701231485428, 0.3413549785047342, 0.1888868338757207, 0.2966285089916457, 0.2937383534748982, 0.31607392951037017, 0.46017212528800944, 0.26353385169522225, 0.22997453967642534, 0.25188874758723967, 0.6604303739426682, 0.6243112107893899, 0.6464230981664383, 0.4653662027742257, 0.5455608435553757, 0.7222886692796399, 0.7196054074375685, 0.70059600906238, 0.6758497094589316, 0.14544684652913697, 0.13759128762733142, 0.027775657224639372, 0.11209630044466923, 0.14500552246574494, 0.1237788857592883, 0.16137129664948113, 0.14228309506871883, 0.13998075421392187, 0.494299382144589, 0.18019368365128408, 0.19776105302759683, 0.3047427632253116, 0.18925823107683315, 0.17688473784065994, 0.6203775006867811, 0.4063029315732485, 0.12077954958383252, 0.2698397939596925, 0.41795351962464233, 0.25374783686346347, 0.29278588685290075, 0.7284899704766483, 0.27310249203660253, 0.2505831116361308, 0.2956766864189754, 0.33951889450823014, 0.20911696505744204, 0.3065636534518359, 0.22862375000314694, 0.48860870242190835, 0.21398721695026435, 0.3209858126446202, 0.2563683945986046, 0.4849894895341328, 0.1822886199172401, 0.22012680132718887, 0.24184531752186222, 0.23289113735961953, 0.1977525925256718, 0.22297552204096216, 0.23984204038994517, 0.2708439488601031, 0.24282783232264304, 0.1893513796839601, 0.8118922644100182, 0.19810259215028458, 0.21015181642289082, 0.8207332475898127, 0.24314513858183795, 0.2459947960044624, 0.8563102805588607, 0.5072730094547425, 0.7651581656915649, 0.18742760570468975, 0.18816738523434406, 0.15219414177351154, 0.923024110619727, 0.200412944119561, 0.8784660070100831, 0.6540279007446888, 0.8897296920628535, 0.9345664443558758, 0.814567144727147, 0.32568472703845786, 0.21205957242188755, 0.21243308108602466, 0.1283307519853346, 0.20420574662008373, 0.21291690704794064, 0.12872584244643426, 0.1557503869664273, 0.23833589436644287, 0.22853560113238536, 0.18491646892307478, 0.22601011002188187, 0.3896708124577136, 0.2633181536046726, 0.19550789791329626, 0.24830505722143204, 0.20932403105891895, 0.07553769709847236, 0.08409377136394092, 0.09842960469332973, 0.09182010785769712, 0.0781490358714797, 0.08749892145478155, 0.10458833295650749, 0.0931482823023374, 0.09851535326487593]}, "mutation_prompt": null}
{"id": "48a5f845-5796-428e-b09f-4ada2fb4b8d0", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)  # Adaptive mutation scale\n            elite = self.population[np.argmin(self.fitness)]  # Elite solution\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)  # Adjusted mutation\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Refine the mutation strategy by introducing an adaptive mutation scale and integrate elite solutions to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.4112643822138193, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "b98c0795-1e97-4727-8813-bb172312bece", "metadata": {"aucs": [0.934293427192753, 0.9356166464151845, 0.9407975063360557, 0.9295748069173384, 0.9258966174982304, 0.9356467528883194, 0.9413140264838856, 0.9224013733399424, 0.9392749838329876, 0.8156082973048779, 0.8268738964927997, 0.8157552034435548, 0.788275835188883, 0.8122741741664171, 0.8235488517082714, 0.7933171547760786, 0.822548834723296, 0.8205057116422286, 0.14979548113786567, 0.13487438154174036, 0.13183623303803782, 0.14943421512260702, 0.12583812669165417, 0.14011259054035108, 0.12278000163807523, 0.15439584408019857, 0.1484653329065435, 0.13243704957087143, 0.1334917540888797, 0.10678070797237815, 0.10074367789287264, 0.05576990838283613, 0.11324392837703767, 0.10076588494675143, 0.14575129736878623, 0.1302699164926251, 0.9351775968508084, 0.9936304171788768, 0.9693013356255656, 0.9742396961969358, 0.9916305268657332, 0.9806561921115264, 0.9558483810659409, 0.9804260486760613, 0.9695146973087876, 0.7435931401636211, 0.7577926299633839, 0.6312853443587791, 0.6248134950065105, 0.6945088827939214, 0.8298946095346591, 0.5496503459583768, 0.6930765715560631, 0.7671339287427208, 0.25771864775597975, 0.20948569363145264, 0.18628672259507462, 0.2850018182057542, 0.105844300445606, 0.22100272555676415, 0.3798038945743283, 0.9553670733324388, 0.36931748973114287, 0.7469559808350248, 0.6033409159376322, 0.4769171684510869, 0.4110590200350872, 0.12892192323667317, 0.5147761768075048, 0.4772431376465345, 0.4298420944272565, 0.49544667836636513, 0.6206723902988811, 0.6639113710965141, 0.494842679605492, 0.1379384145242959, 0.13653916953982348, 0.6352931943563693, 0.6476099629011215, 0.40692414480929395, 0.7210490432474993, 0.2911255677233434, 0.19707116944488812, 0.4254166491687801, 0.30446511608293125, 0.45618794144648334, 0.4637383557949508, 0.4149815092411321, 0.1848102905621628, 0.3640085785600109, 0.3053553721731027, 0.7637383187037168, 0.780959983435841, 0.2517192784122173, 0.36084306118593035, 0.08622776040183144, 0.7524207318924095, 0.780510555997715, 0.7092021381728915, 0.09570676760988461, 0.19342464653984837, 0.11988241338529493, 0.33841908929011333, 0.5094382714761461, 0.2590609492964129, 0.14227961238693732, 0.43676636382321665, 0.42630715361784255, 0.5200211866451416, 0.555642768471968, 0.47583616454300537, 0.5562143631855303, 0.5524140640038165, 0.4146646691419531, 0.4346625367839272, 0.3782195442486098, 0.25061462738080587, 0.8428515785872043, 0.841556548594392, 0.80133393274611, 0.8669800881895766, 0.8725122524507148, 0.8809077016841192, 0.7196181638647141, 0.8429562840209646, 0.7795994076731569, 0.13177315982805526, 0.15037144433235627, 0.12631700447698657, 0.13134586566413986, 0.15455414131343093, 0.12019002006251633, 0.17011976550495833, 0.1146128484006338, 0.09942138735870654, 0.1434988128631085, 0.15223303936217547, 0.4021530321350295, 0.20361289719639597, 0.1373683519537583, 0.24788427365635057, 0.15122417722291703, 0.2164865165109643, 0.1714625073940319, 0.629168370884084, 0.5667647065771035, 0.39686572481442406, 0.336284840862615, 0.644375366110624, 0.27688977190173425, 0.5918830503960569, 0.25926173495914195, 0.5471271130434896, 0.2776635685779614, 0.27461791627172993, 0.5035516515021261, 0.301495815550204, 0.2850660225291607, 0.4890551331937739, 0.4262157364228629, 0.33717223703259847, 0.4693048028213317, 0.22528371232280886, 0.20802825189221108, 0.1880791789538232, 0.2099916827808842, 0.2307197347516976, 0.2180821620444774, 0.2165838078064427, 0.21724797678427232, 0.22677405044037957, 0.1926203322501543, 0.22545871914143567, 0.22388649754885614, 0.20974219513159542, 0.2476134299859768, 0.2074750937737263, 0.214166753093174, 0.20674610207484578, 0.20992942123661973, 0.18836889478844898, 0.187945891840258, 0.1482053972764097, 0.17395514142412427, 0.1984108949417609, 0.9104882763977347, 0.16806983309597345, 0.15768424275973125, 0.12282221120473147, 0.9006934051317677, 0.17000617499877313, 0.11289224144639431, 0.8560815751273415, 0.1557441733045447, 0.20863122017544178, 0.12831750290686028, 0.12833243783053006, 0.15704992187264855, 0.2005332880767836, 0.18229681612551019, 0.19224639985382475, 0.18758994549485586, 0.17535159038256953, 0.19524977198857174, 0.17718171755802137, 0.18489627838412037, 0.18478107302102809, 0.08450646564576769, 0.08315806536353854, 0.08272479598052218, 0.09835650334519574, 0.08771331500306168, 0.0870215702285062, 0.11227018693734103, 0.0763788364985607, 0.08905895898055316]}, "mutation_prompt": null}
{"id": "93d04dbe-1c1e-40be-9068-4313dcc27868", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)  # Adaptive mutation scale\n            elite = self.population[np.argmin(self.fitness)]  # Elite solution\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)  # Adjusted mutation\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i]) + np.random.normal(0, 0.01, self.dim)  # Gaussian noise added\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve exploration by adding a Gaussian noise perturbation to the trial vector.", "configspace": "", "generation": 2, "fitness": 0.29992220984223006, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "48a5f845-5796-428e-b09f-4ada2fb4b8d0", "metadata": {"aucs": [0.7775483631841488, 0.7236990743018057, 0.7307836588805692, 0.7674937644813171, 0.7233877397169226, 0.7352959720508956, 0.7618093393918478, 0.7380697106909585, 0.7390493600651696, 0.2240070454128743, 0.05480256750938328, 0.06313177514702495, 0.13357022009279684, 0.05189433678133626, 0.2980742964383589, 0.3490708041447883, 0.24730764597282617, 0.18803945224551522, 0.12382065003116582, 0.12701389263877794, 0.1425446872494176, 0.12431101596010319, 0.15611343815130185, 0.14170327273094485, 0.14602527510107544, 0.11053940730375833, 0.11561080011359104, 0.13221927069091421, 0.14544033798167344, 0.10083678386534012, 0.09311888997101103, 0.14175278137729708, 0.04112200171642888, 0.10346625267134602, 0.07526033728015358, 0.14323272924710673, 0.9527772823089471, 0.955245527928183, 0.9621307694024742, 0.9541155365118643, 0.963311726462773, 0.9617291381834363, 0.9502046205211162, 0.9702253858367104, 0.9672005048186392, 0.5360564810726294, 0.5041387520649413, 0.5111055935945874, 0.5149345741207942, 0.5426083316766943, 0.5436691703727937, 0.5504228781256125, 0.5336636867495907, 0.5282542761995537, 0.23100822914942287, 0.14567856138873647, 0.09909747794785739, 0.28214260610800346, 0.38527430345957014, 0.9602962919668152, 0.14551573904943393, 0.25001153814458765, 0.15436856769742913, 0.13687925612769236, 0.26428357829598637, 0.2885929035397785, 0.28109369739061396, 0.13593873491991215, 0.2292159696306847, 0.2905690750007367, 0.2814232518238978, 0.27930743620940446, 0.2601205975656631, 0.12670793025862037, 0.27451241100252266, 0.26789528994990386, 0.24888352043003825, 0.26923980958064186, 0.28192758928469586, 0.1350871006451554, 0.13370397208191243, 0.06523590323839057, 0.08826495051925598, 0.151820214454636, 0.04728290405005342, 0.2663832363572344, 0.028776455708360626, 0.1664846763349922, 0.004008059420574139, 0.049306916405503776, 0.190820925431469, 0.20919104603531824, 0.2326504595470411, 0.11878785261666691, 0.14248587322447215, 0.12372347830389263, 0.2064794601931137, 0.17248064857224454, 0.1511979285161047, 0.15153172183677066, 0.13333234114388748, 0.19807346591764152, 0.0914169419901798, 0.13858468776274713, 0.13623033036532217, 0.18324386851787355, 0.19315531793296947, 0.12956063332451107, 0.11380277127957639, 0.09475095890612795, 0.22592021140823249, 0.2788096789604667, 0.2001720637964416, 0.15687566889242677, 0.1741293548426116, 0.24331501055925553, 0.21319938180863773, 0.6203341521149632, 0.5557461947778253, 0.5802487542303122, 0.5864445875120172, 0.5951494978485528, 0.585717145043559, 0.5665566777788696, 0.5802428351759272, 0.5351726501592935, 0.10315911398452704, 0.12293678993813628, 0.1618766823601856, 0.18326998618650892, 0.11383329695892275, 0.11942700185794308, 0.15680298855201313, 0.155324464606029, 0.11877928721375242, 0.1549810775657301, 0.13704778263751904, 0.24595640126888962, 0.1273232044129734, 0.13632825464784404, 0.14789341855947424, 0.23457299986456825, 0.2443107897203488, 0.24052025129754695, 0.2568826376219705, 0.32537342065376795, 0.33706585838246506, 0.45925247743050346, 0.4334641263538245, 0.2298171891691163, 0.454973054715862, 0.43486764025839, 0.4134084270624516, 0.3021814202254326, 0.2881769370095836, 0.2069140674378932, 0.24267253911735687, 0.19392388303469632, 0.34400687376065997, 0.3803454630917228, 0.21434002375626182, 0.37998304778682457, 0.22584307053237795, 0.20750588952914173, 0.2047334117499392, 0.2140917189226884, 0.2428496760663672, 0.21419270070944874, 0.2029415364783268, 0.21406987548701661, 0.20646046325118295, 0.24475671153340972, 0.20899427516810198, 0.22134362443951894, 0.2256073534315911, 0.24183090167895327, 0.18552763852080834, 0.21831338101021047, 0.451385326523735, 0.22658893784905287, 0.9636803432101675, 0.14186696118934083, 0.15422076293541742, 0.9295561238986465, 0.18771248449211575, 0.9530787359405982, 0.9227607154088271, 0.163285666888642, 0.15933834526358714, 0.16910604137561258, 0.21307772585811868, 0.46524516767895907, 0.2065995573195627, 0.8166171704108648, 0.21076603363409196, 0.8456562849752942, 0.2129999618286066, 0.1572810549897551, 0.188282749149564, 0.17926208240793928, 0.1738614655491485, 0.1853262535348088, 0.20792606652594126, 0.21689531435947373, 0.20583854870539198, 0.18796932536562327, 0.19565449594618745, 0.09283944628256524, 0.08849808580376428, 0.08656740974491617, 0.10074697843312896, 0.08384841300990031, 0.10362741418523291, 0.08070828085688841, 0.09018206446712862, 0.09444990490498639]}, "mutation_prompt": null}
{"id": "2f3d779a-81d4-4e6a-894d-7da34d694046", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Integrate an adaptive crossover rate strategy based on population diversity to enhance exploitation capabilities.", "configspace": "", "generation": 3, "fitness": 0.4384379246986344, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "48a5f845-5796-428e-b09f-4ada2fb4b8d0", "metadata": {"aucs": [0.9307845766393439, 0.9275099004403777, 0.9353435597019754, 0.9333485782733009, 0.9367745811545669, 0.9317047695678385, 0.9299957435586839, 0.9216099651991734, 0.9367088062957898, 0.8278490294889783, 0.798916335339588, 0.8274370657291577, 0.8445196510838591, 0.8283607180067505, 0.8404199297706514, 0.8113060619893531, 0.8218746101013148, 0.8141273731975582, 0.1251195281209322, 0.16132162077978895, 0.1521959082234856, 0.12766590013356582, 0.1473909285960051, 0.13099577272496787, 0.14486082102001396, 0.1495169671101534, 0.16139446389870826, 0.11125458491039575, 0.11152031660611705, 0.14167716024455546, 0.12985408732941273, 0.13199639109120542, 0.1545700886700604, 0.11712632508502152, 0.12428434780546394, 0.11179594866841758, 0.9508660972077652, 0.9779287844166917, 0.9590659307420933, 0.9728127678497906, 0.9729724725559689, 0.962524699215299, 0.9587203979774457, 0.974510296898947, 0.9786889338517872, 0.6871377519631259, 0.687439323201538, 0.7454464952462421, 0.7405232008951355, 0.7877531120475726, 0.776659506023813, 0.774591839743815, 0.7290300037142629, 0.620893590248838, 0.23063487866287535, 0.11843669935889434, 0.22419617659509572, 0.9506244483348483, 0.2803884336273039, 0.3299820798983927, 0.8609553998324077, 0.4084244982034847, 0.4130262015201158, 0.4623223271037693, 0.6157818460873892, 0.3423248510378597, 0.4965490780664299, 0.46507405428008475, 0.6776639419405669, 0.757238385766508, 0.4273285943684061, 0.5541839118879905, 0.6635975467794176, 0.5594882077622358, 0.5656230391101651, 0.6006638636240982, 0.49542027186804993, 0.13706573428427837, 0.725349597115766, 0.609879157403623, 0.6224342982927025, 0.3207928444008803, 0.3357832124210969, 0.45600091917436847, 0.17422851629583824, 0.4430098001380526, 0.12417210798760647, 0.5206927935636063, 0.4871020809078589, 0.13372709703666186, 0.41842586448936736, 0.2571336597218328, 0.20225991641325658, 0.2452770675034569, 0.14659628350747267, 0.31560078893114574, 0.7819538645911642, 0.5186347095235269, 0.6265949267082851, 0.4037546118702121, 0.2987558354049836, 0.3754333045770236, 0.20448369677416645, 0.37215544672790846, 0.2853864290061078, 0.09709215757308487, 0.4157493846206666, 0.13426819493406983, 0.34210336923352014, 0.47473799767432834, 0.4973267895058361, 0.4899812456191477, 0.5335856819219174, 0.44377852601709633, 0.5203790288374144, 0.4292952273817916, 0.5284667244727728, 0.8586408797715321, 0.8564289043235773, 0.8379960175376644, 0.8816861125687924, 0.7156557405267625, 0.8162364841923473, 0.7820836161502304, 0.8250667927667452, 0.8372010841859698, 0.11377707110563728, 0.14823118174962024, 0.10114919253748145, 0.1689206861493252, 0.11640655645400422, 0.184997267407359, 0.10629443907761582, 0.43257086544430745, 0.14489313920116642, 0.20218058711363296, 0.19631646049245166, 0.1690388849996305, 0.14640807311454518, 0.24621997519832028, 0.15019677213461746, 0.17277343136139256, 0.15149028337698234, 0.19581805906793448, 0.34566081816883376, 0.530009846897858, 0.5767199206611378, 0.5846519594219958, 0.5955867236348126, 0.58383990796742, 0.616500277023294, 0.6017980406678911, 0.27008375477092206, 0.24521091235883474, 0.4646642958222029, 0.2250481439224683, 0.25471539823053446, 0.4481424673050204, 0.49804159331194553, 0.246087922742254, 0.2273902696084127, 0.4932737967873938, 0.19321724586533273, 0.21904067975849562, 0.20544420133058994, 0.21797434642335223, 0.21825920922216768, 0.24950297450839765, 0.24751445112798998, 0.23623871989570144, 0.20037444102277735, 0.21362552737396068, 0.23884359602231375, 0.2788652407238086, 0.2124970443767662, 0.6114047025838691, 0.1905320798630451, 0.20869793712401186, 0.21832390280022607, 0.2565842481871189, 0.18751024332641741, 0.1871468418326515, 0.18774782567995185, 0.9265078200328295, 0.1982439202956604, 0.17723121597109115, 0.9066761929958387, 0.20865185597401836, 0.9286524711070757, 0.9217146399292707, 0.9093828622583825, 0.9133919612304362, 0.21351334364623653, 0.21235522703252496, 0.20872433544627578, 0.6954990776143686, 0.7658238423022885, 0.15422918223130566, 0.19681600385530518, 0.1803213691767589, 0.190832518809543, 0.19685558274538995, 0.18695943397417603, 0.17881340556085834, 0.18218368127847318, 0.21040363046940413, 0.181644497037868, 0.08829093255462117, 0.08698045414615585, 0.09042730479017924, 0.08506068499961295, 0.11141364655030517, 0.11086373627242341, 0.11719196711106639, 0.08865130277388766, 0.09275831973262216]}, "mutation_prompt": null}
{"id": "136e96ba-41a3-43e6-907d-8a292b20c7d4", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = 0.85  # Changed from 0.8 to 0.85 to increase exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by slightly increasing the F parameter in the mutation operation.", "configspace": "", "generation": 4, "fitness": 0.4501967265924403, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "2f3d779a-81d4-4e6a-894d-7da34d694046", "metadata": {"aucs": [0.9360425777733339, 0.9332849784428822, 0.9451964235477895, 0.9314171543909787, 0.9184300274098925, 0.9343463692239226, 0.9382618527663514, 0.934361492167984, 0.945034920414841, 0.8158175272101595, 0.7938093301280116, 0.7989140237769592, 0.806080770057243, 0.8115751441410268, 0.8062996003205661, 0.8248565235503759, 0.817631376814878, 0.8146495686722436, 0.15452677365875278, 0.165915533833233, 0.14519769659403703, 0.15589187986188657, 0.12511254047706277, 0.13589711832087414, 0.14966320238948339, 0.1463252859159183, 0.14402631787998255, 0.1231290713997083, 0.1283225698339755, 0.1129904691115804, 0.15544223319907047, 0.14167966597304638, 0.12672550383952164, 0.13330298016769626, 0.11198552749683821, 0.1433011353398017, 0.9705696581671648, 0.9487723741929535, 0.9539510503867871, 0.9461755090308478, 0.9620538217198209, 0.9800661022212199, 0.9555931603590264, 0.9569451274209232, 0.9454995661658168, 0.6819277725578888, 0.7740239086600682, 0.7832597056461114, 0.7439273033062743, 0.766861452303196, 0.7038095080849683, 0.7681748392407199, 0.7498746037819635, 0.7819521339064109, 0.930124045511763, 0.14048477302200446, 0.9510304661780817, 0.33172326178026035, 0.9490707922167668, 0.2820163467634266, 0.9678539887960662, 0.23531632497893984, 0.9589048491984875, 0.7636929711059529, 0.8039352988968491, 0.5290772476136179, 0.6853664913508208, 0.6526307886607288, 0.6929141417820699, 0.5303365185374261, 0.6387345685458432, 0.6531196143542854, 0.6144261231103487, 0.5280107064133475, 0.5697097654825363, 0.6525239206615265, 0.44607721308809667, 0.13667692818884591, 0.6545048207501302, 0.6029027247724259, 0.5577396641338188, 0.4137762451932967, 0.38906655509703847, 0.4410807638594312, 0.6993403579506836, 0.19283205542234305, 0.45353000874594607, 0.17754946788828385, 0.273185098022962, 0.6243815758419193, 0.21731361779127356, 0.38495909229367886, 0.14809214609649446, 0.2840595496165813, 0.33731105570258857, 0.17304317123923862, 0.586295720654297, 0.4940090579706201, 0.47308586864457014, 0.17080149695201197, 0.35817185827366693, 0.1569036820576355, 0.28165435118153037, 0.526155727209763, 0.3520587461337742, 0.3622395138700978, 0.19448910551862486, 0.13873959821664994, 0.35160705934133796, 0.42198250992049124, 0.5312883231406906, 0.5818230769567282, 0.48110136524099756, 0.44566858792660247, 0.48021511340847045, 0.5087116604168789, 0.38426537588273424, 0.880534246870852, 0.864156692506189, 0.8815420727132611, 0.8447967859735066, 0.852280527044208, 0.8684572459962517, 0.7245470147505698, 0.8732183009566248, 0.7868513877010956, 0.11289655794220943, 0.11211040166125008, 0.11835825838143488, 0.46057427354136093, 0.1503092115841087, 0.16218492340365243, 0.10664381393188738, 0.131507613954161, 0.09691499972300555, 0.15486330428144868, 0.14134683830293326, 0.16244442839040463, 0.16427105769185402, 0.1437664417390604, 0.15108215315744233, 0.25459569389905046, 0.18111318833207934, 0.16481828193391668, 0.5862890537129342, 0.5491916193970371, 0.5762810544608196, 0.5537110592698943, 0.523866525581208, 0.5436866511336307, 0.5472820295357061, 0.6203385646306829, 0.5560946410508238, 0.22512965607576518, 0.26519567556602797, 0.16613173599064535, 0.2718010503339341, 0.24782335250576581, 0.5366897549508283, 0.24373154002033848, 0.4234450936248598, 0.37737290280205193, 0.21590866163691413, 0.2176469638562737, 0.21211341729301358, 0.21456305572270473, 0.21730038632941906, 0.21364016153859688, 0.21434085875081899, 0.2151772595663043, 0.2240552849058508, 0.23885621471641771, 0.2045436035570829, 0.21978338644174122, 0.21924741190121677, 0.24328305889360835, 0.2087718453112083, 0.6370881300456157, 0.2304194047675009, 0.21206451875924626, 0.18324390749192032, 0.18741436053846938, 0.1867705749752221, 0.9465051994768474, 0.1974057648905313, 0.9293603831180293, 0.16793621298113104, 0.8932675883674149, 0.8505449603274313, 0.86583896575854, 0.9451779569598117, 0.8846289698412169, 0.21197254529927545, 0.21160142265377457, 0.2109394494412099, 0.16861456484740334, 0.15566922645968773, 0.15491071918922483, 0.20889701809401007, 0.1809094102859995, 0.18287673327713005, 0.19037260802561828, 0.1930937444747186, 0.1838918457839417, 0.17334641333761247, 0.1804821407468007, 0.1888704246150954, 0.08150954610691297, 0.14080687352477161, 0.08917318121358764, 0.11764079766698066, 0.10269416215023053, 0.1473070918240288, 0.09097754343074194, 0.09459383318846903, 0.09561982377454092]}, "mutation_prompt": null}
{"id": "f084208d-05b4-4f46-b03c-a1d7d1070847", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = 0.85  # Changed from 0.8 to 0.85 to increase exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                progress_factor = self.evals / self.budget\n                mutant = np.clip(a + (f_scale + 0.1 * progress_factor) * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Increase exploration by adjusting the mutation with a dynamic scaling factor based on iteration progress.", "configspace": "", "generation": 5, "fitness": 0.43658643655590895, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "136e96ba-41a3-43e6-907d-8a292b20c7d4", "metadata": {"aucs": [0.9365665009852053, 0.9375105502764063, 0.9369840824552316, 0.9383455278236927, 0.9318848734391811, 0.9351552062805678, 0.9355326265264281, 0.9325582839008607, 0.9373863986982685, 0.784834862884685, 0.8000192876055652, 0.7702009002305433, 0.8165747949387412, 0.797739614905134, 0.803503800238873, 0.8069422959363934, 0.8293552683030079, 0.8104303689884692, 0.12924401755991044, 0.14246724358776486, 0.12436492433350754, 0.1395632722783423, 0.12945743978114388, 0.1527511232778146, 0.15271694104518796, 0.1272869912873108, 0.14639455766256237, 0.11474169071907292, 0.12120490940380702, 0.12209865763667926, 0.1325273772596809, 0.12674219753410765, 0.12886207125865934, 0.1283548383052575, 0.11733250505471948, 0.1290905401879585, 0.9760813092346134, 0.9650694968043648, 0.9600818505078115, 0.9543183971463963, 0.9651530697287025, 0.9800658336220371, 0.9691165575209209, 0.9724286634435295, 0.9600695889092757, 0.8054058509384675, 0.7449455705370406, 0.6414348939056356, 0.7462683598665711, 0.7579264215431102, 0.7979421073208217, 0.7997135968717194, 0.7216117077664967, 0.6861347219707314, 0.1839910721990603, 0.22789727268545912, 0.9366244743629469, 0.9590948925071131, 0.3878651805775667, 0.2828656535275269, 0.9656329565370102, 0.35961336948126754, 0.36875167388537955, 0.7612907151671036, 0.7527108330459318, 0.5649994866414996, 0.42404409536934895, 0.5048742061245182, 0.6115787325237556, 0.4626032849247451, 0.5216201766023862, 0.5423177900752605, 0.5629803323089235, 0.13603912650121364, 0.5236723632279283, 0.7213759488388821, 0.6659153983340085, 0.1369871430548405, 0.5311723104888877, 0.6359153444403853, 0.5289946951040114, 0.4820260224879508, 0.5239052997661375, 0.27513530914324635, 0.4350837641772194, 0.20058619229063457, 0.29986625677033474, 0.5435124920013781, 0.1983029178092024, 0.5974428479747766, 0.6699193995564481, 0.30018710975313967, 0.1405664912841489, 0.43746286921014665, 0.3270047421900407, 0.16336543088096078, 0.6844416998625148, 0.5921560874097089, 0.5503257499672707, 0.17376576492872609, 0.18782055604906178, 0.13755302735800412, 0.35540275356001505, 0.2793221936252891, 0.5570732166035983, 0.36210500879840624, 0.13709444599075882, 0.14252417509494686, 0.3929357387896477, 0.4460169617539953, 0.48929450161765364, 0.5035120570831009, 0.45769590828202766, 0.47359777248678736, 0.3934204709950684, 0.4769557414427481, 0.45940040799364057, 0.8694474241186874, 0.8380530517788649, 0.8375132922393462, 0.7030079213931367, 0.8578840694928425, 0.8740812001285603, 0.7872642976729745, 0.744068258233785, 0.871877479565752, 0.13356228872843745, 0.6634303616777647, 0.08018522660082583, 0.13161563748913485, 0.17730840589037322, 0.12285346194067459, 0.1384489642586948, 0.1153760447592116, 0.12196413230882686, 0.158084194454021, 0.18324057894768842, 0.17105859312751415, 0.14838937681943953, 0.16794147911655233, 0.18339576412925684, 0.16700311788039923, 0.15988850409898037, 0.2024145636235437, 0.5239259219610359, 0.5831171307434908, 0.5769955188348692, 0.313741385838491, 0.3890156051389453, 0.5533987326169858, 0.5593446168935251, 0.19345767414160142, 0.5384505149484805, 0.2606915513933681, 0.47070909547588957, 0.2511882190499093, 0.44229138052012495, 0.2581101505059056, 0.4884749126582154, 0.424117932134628, 0.2848601004645124, 0.24610938787443415, 0.2277126025323858, 0.21342137378373804, 0.2542612623130681, 0.21504841789467588, 0.2147205592916024, 0.220016554356109, 0.24002325395177337, 0.2167309374124241, 0.20127593295155133, 0.2137554343690662, 0.5552550911186065, 0.20043864573374337, 0.21924346037925635, 0.2193162775305766, 0.2158518508689513, 0.19797323970774094, 0.21852311106164457, 0.2059542716698871, 0.18393418481951607, 0.18735967572284506, 0.1867194923934682, 0.9221599611371503, 0.1972777589756166, 0.9421149140479176, 0.16794353506879212, 0.8909612746184512, 0.8127462843061002, 0.8267777759501105, 0.762846294757224, 0.8576821970593584, 0.21212491783731413, 0.21109444679562628, 0.21066702451616903, 0.16857844654976484, 0.15617044249190692, 0.15510914726092728, 0.18521652107627928, 0.17029304371097476, 0.18512151824081313, 0.18560918121100145, 0.19428349281783308, 0.1812386994369325, 0.18706094747949287, 0.18819010179614437, 0.1931644865652432, 0.091362342929735, 0.10920934272704141, 0.08650715993694669, 0.07636637274140723, 0.09841053370012365, 0.10966176933209026, 0.09001659934298045, 0.09195713048857668, 0.09114902588327456]}, "mutation_prompt": null}
{"id": "5fe15d69-8d5b-4fd5-b9b5-930f42b0d83f", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = 0.85  # Changed from 0.8 to 0.85 to increase exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            self.F = 0.7 + 0.3 * diversity  # Adaptive mutation factor based on diversity\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce adaptive mutation factor F based on population diversity to balance exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.43057196542442383, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "136e96ba-41a3-43e6-907d-8a292b20c7d4", "metadata": {"aucs": [0.939715968200213, 0.9476605886808653, 0.9403582681719744, 0.9359478207011492, 0.935809333035029, 0.9253161656157587, 0.9332487360724043, 0.940351149328907, 0.9393663878341502, 0.8176560993058289, 0.8059721970641135, 0.8132886785699516, 0.8565597703006369, 0.8185102667424604, 0.8149569192580393, 0.8139871727690562, 0.8400077831213195, 0.835763094194077, 0.13359113677142087, 0.5183649796871443, 0.13878503085209049, 0.13217620704973365, 0.14898548163531888, 0.15022060743380095, 0.15134137175589113, 0.14984245115644312, 0.14189892875370513, 0.12824340031524428, 0.11359708543581915, 0.07278999297500066, 0.11686229611301224, 0.16402866638770375, 0.14686412170175622, 0.12412353039764135, 0.11208241749502035, 0.10497457514139785, 0.961171401645757, 0.9567579671217153, 0.9774353723992416, 0.9660428383761317, 0.9823808913988726, 0.9715176494719971, 0.9599381486609427, 0.9571284142466898, 0.9635438412418468, 0.7695712563693387, 0.7757123173869769, 0.7698187774009595, 0.7450576536336044, 0.7332212701380573, 0.7858348861152602, 0.674711956240808, 0.7148207180037901, 0.7148718243294505, 0.23041664467659384, 0.14089616725199539, 0.1709062074623624, 0.9630674528387407, 0.16058998406957692, 0.954612768752187, 0.3675717284939356, 0.291832604614753, 0.2361717799527424, 0.4209022057862555, 0.47179984553121, 0.7498267204390987, 0.48925259570140567, 0.6195776944735347, 0.13604340009795046, 0.13617849475445132, 0.3395424747554142, 0.568805612487019, 0.5927787730750165, 0.44267200876509594, 0.4740823080368908, 0.5056226144420117, 0.782045514138016, 0.563335432290489, 0.4093382804772444, 0.6035273324658674, 0.44787980836862673, 0.4895970464808175, 0.5835116270723533, 0.49755779281084755, 0.34314727896581143, 0.07481139539875059, 0.32648192196253745, 0.5797579203294579, 0.2941938780619363, 0.25947673565465823, 0.29560371001990393, 0.2102415065591675, 0.36066547364725665, 0.42435007132226255, 0.1288182762047987, 0.12723143992587738, 0.4236065514966767, 0.40686236903463335, 0.5404446805655857, 0.41176082183472484, 0.15194374236793684, 0.1290420361411556, 0.3823626409615728, 0.19775677745061104, 0.33219155787831156, 0.18071525790949527, 0.36533782053146746, 0.12300749325655436, 0.4762622259626965, 0.4620241391846507, 0.3682868060769585, 0.48049998234194935, 0.5602542559919361, 0.5420456989673893, 0.5355517015079707, 0.42224695811015867, 0.43237297859228085, 0.8659472990553547, 0.8231456349274461, 0.7379109664725372, 0.7514313530167033, 0.8733911308755151, 0.6843959231668417, 0.8062015451135673, 0.884167978260438, 0.7155478768629423, 0.1255402539306535, 0.1155745899677415, 0.09287083413606545, 0.12597012457720957, 0.11894121541434632, 0.13126788451634763, 0.1029181876859806, 0.15857502996603323, 0.14179486660939133, 0.14590851508503966, 0.1572382121783148, 0.32686948491199563, 0.1497121590299696, 0.24960633585490366, 0.18997485000870973, 0.15124381719301305, 0.2025549615106529, 0.21063268670990865, 0.6007173254081628, 0.59497628596586, 0.6084854351623692, 0.554946920705452, 0.5652608494224547, 0.5647303150365277, 0.2812474891979799, 0.6075673053325918, 0.5758421539608056, 0.27291229663798744, 0.4794654676360306, 0.2745688015467591, 0.3646445921690975, 0.5148667163169388, 0.49175084826342463, 0.2790676151956114, 0.28755793410583896, 0.2318861870314235, 0.2317819829649974, 0.2915524510001596, 0.2040823354712088, 0.20424947790962145, 0.21329666718749163, 0.20551705830841616, 0.215111523799559, 0.21898026777995605, 0.20366517052609456, 0.2375281682907121, 0.23076855947262986, 0.2300848035384523, 0.22133728572995293, 0.24932997766712328, 0.24368062245278832, 0.22422614873309898, 0.24136148803034208, 0.21340721500127802, 0.18535407094597678, 0.1874817565772936, 0.18240893424879068, 0.9153692312321886, 0.8103101016805433, 0.9372824996037358, 0.9147289163097906, 0.16291447365563294, 0.8328035241820987, 0.9136977388436582, 0.20913959699998164, 0.8973631460109978, 0.2097203968336817, 0.47751770420236794, 0.20546579652346197, 0.2134559160855921, 0.15651834752383442, 0.6387285325652253, 0.18594338617555506, 0.2019826445799655, 0.17947423468872625, 0.1767249164956638, 0.18309551838342764, 0.17651608989900847, 0.18289541896345896, 0.18462997893254296, 0.21151142435700432, 0.09303674850470778, 0.09289836108152905, 0.09403611643529075, 0.08149363435809831, 0.09404056943670325, 0.09580161085917094, 0.08579221562946437, 0.08584104216464272, 0.10569558772375642]}, "mutation_prompt": null}
{"id": "0cf6cb00-3b6a-4d0d-93e0-12addefc3c4f", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce stochastic element in F parameter to further enhance exploration.", "configspace": "", "generation": 7, "fitness": 0.45308531394137197, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "136e96ba-41a3-43e6-907d-8a292b20c7d4", "metadata": {"aucs": [0.9376765449264219, 0.9323937408444973, 0.9327048673459067, 0.9267933614794147, 0.9366604489720356, 0.937986792211115, 0.9347502793723564, 0.9303897281789508, 0.9358635538419025, 0.8125397168310042, 0.8004500793202185, 0.8227854666565373, 0.8268597149223403, 0.8236449379934652, 0.8217677136134831, 0.8133793838541078, 0.8303516481095896, 0.8357961589728842, 0.15219752443010315, 0.1412693420525416, 0.14867653954339843, 0.1953617964315827, 0.12945800470233138, 0.1584374295400507, 0.1466122584190318, 0.16137510599177307, 0.1497224944540445, 0.12276072293231266, 0.11829781677436169, 0.12728341818775812, 0.130965890366462, 0.11350988760364566, 0.11959122361330288, 0.1126711160788324, 0.11461046404015796, 0.13920931279180482, 0.9747959889049556, 0.9621372243056151, 0.9802125509386156, 0.9742781291230317, 0.9882486326829841, 0.9661769112618185, 0.9473738247811802, 0.9686409707767317, 0.9842845220941076, 0.7205703493321678, 0.7531157892359909, 0.7142080090424883, 0.7980111499471623, 0.693986061395921, 0.6670236315963258, 0.7320354346292676, 0.7242771512935038, 0.7446178180779965, 0.953943741401693, 0.22781041505501232, 0.21631953936915826, 0.924714362888385, 0.21501453425009243, 0.3892591146306743, 0.23837656709956578, 0.23232585432510466, 0.9141176140184725, 0.6562743969359732, 0.40138818487061567, 0.5638308270941106, 0.6179979212259754, 0.5137940128891403, 0.795528329583602, 0.4824450982467485, 0.6808191872564797, 0.1373833736664004, 0.5806572177576951, 0.7016659252278896, 0.4900343538011682, 0.749398304306449, 0.6339944663349524, 0.6507145379464048, 0.6710326564156917, 0.38845999339196535, 0.5725332601427615, 0.29359856664088524, 0.4216686437551702, 0.40866495657322177, 0.6912969611967852, 0.3487798152650665, 0.3850389972008784, 0.6201206325873543, 0.6766760788433615, 0.4525254115361841, 0.31304912855051825, 0.749180887492959, 0.27755981148430664, 0.22969189878290286, 0.35121935771388035, 0.4193416940593364, 0.714463592980212, 0.735192025328522, 0.4485056255049198, 0.33174980865454584, 0.12182228692474328, 0.16515846192725459, 0.39497633750985284, 0.373692779886608, 0.4135289545296228, 0.197788633987525, 0.28307735985247207, 0.13147237213366203, 0.5567124250320192, 0.46104512692755695, 0.44870982752596544, 0.5743423807428575, 0.586038848294849, 0.452211138971365, 0.5911943591480464, 0.5260478989538238, 0.4985975302191832, 0.8509102456119052, 0.8456475130553701, 0.745403575293333, 0.7481726152882711, 0.6745776249795947, 0.7846208219526805, 0.8694262061095237, 0.8970335092607976, 0.8431734139747603, 0.12570281086003576, 0.14260852554713344, 0.10914589784196127, 0.11212313836561827, 0.12153933004890038, 0.125378540929328, 0.13865640217454678, 0.16209227104999868, 0.12574037281577022, 0.14675188460069677, 0.1395439692696555, 0.24222160673179494, 0.18484009448752825, 0.1351504287353702, 0.17892745680462996, 0.1685663595870296, 0.16697790575295945, 0.16916876745803533, 0.5610689748546266, 0.28984758415319145, 0.5425153185437537, 0.5504818915090774, 0.25848254686175365, 0.5521118885451746, 0.5795452619750177, 0.6017828272150305, 0.5928108506689176, 0.30524663543820685, 0.4746873154975404, 0.4849512186901702, 0.5282810742762298, 0.33306479002537714, 0.2583933385407796, 0.523052664206371, 0.2441425291634025, 0.4078717244096618, 0.20440817773435338, 0.21932950620158886, 0.21153087073077126, 0.20960655001985762, 0.24850806283499316, 0.21608348586560466, 0.23642098207497675, 0.2093112219292339, 0.21995723387415544, 0.21823262981399905, 0.2164135256861246, 0.6973650445096429, 0.2244271318050377, 0.2045547073519196, 0.19540367397831448, 0.7655485924973988, 0.2449014885321491, 0.23220530267652517, 0.18799077479808024, 0.15426775443454332, 0.9274107146629911, 0.19971106314196563, 0.9423254493297795, 0.16792790856513673, 0.9292033494268913, 0.4533337222572038, 0.1692664238588144, 0.8630781990035608, 0.9334654744092454, 0.21120578331255413, 0.20705217561607647, 0.16766971836326683, 0.7567660360586097, 0.8929602046408007, 0.21206637514846294, 0.16893642024110578, 0.19108444999217733, 0.2019954673835772, 0.19158441274515803, 0.18000781245218545, 0.1708860701362528, 0.1945146313034628, 0.18850794067818355, 0.1875764623182713, 0.1747834236549426, 0.08873905059746245, 0.09010006179378072, 0.09376564842096957, 0.08035960141498455, 0.08644986099838481, 0.08022823034198068, 0.11798894177642594, 0.07886384169988492, 0.09433340341082708]}, "mutation_prompt": null}
{"id": "2ba2d9c6-6f38-4bde-82b3-e20c397818ed", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.6, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by adjusting F parameter range for broader adaptive behavior.", "configspace": "", "generation": 8, "fitness": 0.4346266240156789, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "0cf6cb00-3b6a-4d0d-93e0-12addefc3c4f", "metadata": {"aucs": [0.9379772153566739, 0.9373124637389707, 0.9509252847581114, 0.9343973440444147, 0.935113601657732, 0.8786869674338976, 0.9397866811584719, 0.9304666775603339, 0.9367633324415944, 0.8279961954493147, 0.8052091703216824, 0.8387806478602744, 0.8236995868267946, 0.8127610462334924, 0.8400512743158794, 0.8262547169532428, 0.8296255961851138, 0.8196218630950475, 0.15609758151683417, 0.13662734737515858, 0.1277344929819284, 0.12690070999120018, 0.19440830302497647, 0.14543033723056287, 0.14777516727686157, 0.13134801836882093, 0.19023835644647424, 0.1358282005333329, 0.10563276210333461, 0.13499307842937813, 0.11921443588326652, 0.11891366276376525, 0.13499974249754687, 0.1314891528185702, 0.11841292156582162, 0.1234301406111552, 0.972321779092005, 0.968266517984807, 0.9518894344324159, 0.9702268005823794, 0.9851795821691663, 0.9744087558860328, 0.9405176167063092, 0.9577174887810611, 0.9551265404469668, 0.7362697760409678, 0.6308726758364236, 0.7015669056283067, 0.7457716491664333, 0.7951048100151399, 0.769809850514186, 0.7124317742389195, 0.7895359598654739, 0.758526233079017, 0.14075326501114083, 0.36698166011360267, 0.9596024713743763, 0.2830567470429237, 0.18077676029661138, 0.3877196766388079, 0.23592375644634522, 0.37982663338630196, 0.947015700449186, 0.769324848958566, 0.5402340322323712, 0.5348529061127261, 0.8312424771176568, 0.1353454966895442, 0.42866949009098454, 0.41466507001547004, 0.6202095987533004, 0.5173870236979913, 0.5111819868002159, 0.6453053707714421, 0.38703330050716744, 0.60637353444838, 0.6054069294660441, 0.5658790518614725, 0.6399330154454966, 0.6886105488672134, 0.6121281880216831, 0.4194789961190081, 0.3525384647645009, 0.4406849998316835, 0.19449027998915158, 0.21712079536915396, 0.14221369530879058, 0.3205929598241569, 0.3536864671405612, 0.021464417873193087, 0.236557677809203, 0.1562380726417909, 0.2573108996758309, 0.7230327149964204, 0.3914825252569709, 0.14408179110026864, 0.5751191689304832, 0.7544993807024334, 0.6633355123224929, 0.24628645462936916, 0.1638349531252734, 0.23631438040541608, 0.32578070751979593, 0.19139538173932968, 0.3222864296394543, 0.3596525929700206, 0.20264263324022336, 0.38883698686707113, 0.42875728910571265, 0.43781454592545965, 0.355803154969892, 0.5490515508559441, 0.4381295259696897, 0.4663412977477607, 0.4301100122390902, 0.4001407789221726, 0.49785229228019945, 0.8447383488700477, 0.8431223966572152, 0.8337646726683146, 0.6962629510663308, 0.7583887087132986, 0.8352805592124045, 0.8835110754106574, 0.8655379322735345, 0.895697796413891, 0.1274811850331493, 0.14712886478955278, 0.18485650041776935, 0.11105317728210029, 0.10221093141737625, 0.1203779802739644, 0.13015291404015294, 0.20367446644843235, 0.12207493370985978, 0.17332991413341792, 0.15900688907962668, 0.22732107908432075, 0.1726080828902301, 0.1654303648131592, 0.1877657709365701, 0.1771603116931192, 0.43870904045870507, 0.14220532747136627, 0.49902135141306336, 0.5674051904450818, 0.5788242803123187, 0.6171565590045915, 0.6190843466750274, 0.5498044440896284, 0.5252050232954542, 0.24113648546860011, 0.5828207764406048, 0.334515964860052, 0.2735305762478103, 0.3255170570962036, 0.3360315290985374, 0.23529513352946307, 0.506630656098636, 0.23492027632832102, 0.21136482739462814, 0.5844483045607072, 0.2390417856315954, 0.22482781136895258, 0.23384017467804996, 0.21216791600325224, 0.2256692624506682, 0.2227350809227414, 0.21698031498282022, 0.21510479369196478, 0.1817001835562917, 0.2411437989453764, 0.24263879152442291, 0.2423255960979659, 0.7823057297290055, 0.2175232955041878, 0.6651815613184265, 0.24927498726134134, 0.20628959950767078, 0.246229297558324, 0.18609822968948697, 0.18775671037319663, 0.1888780091263348, 0.8768959235360322, 0.8959381091302855, 0.19829687041391564, 0.8794806896402376, 0.7807223302962142, 0.1677194113526581, 0.9306733471747584, 0.9124848566280492, 0.21046928796739917, 0.16462464905441576, 0.20642999705743525, 0.1685355036150088, 0.21254852493961285, 0.2124633436583654, 0.16770553471892058, 0.18975845085902798, 0.17649935599197453, 0.1896732416142578, 0.1917555589290072, 0.19200255940674138, 0.17734373609859466, 0.1812574490561779, 0.2022904110407876, 0.19630797861458082, 0.0933197116462341, 0.08893466307829623, 0.09937527403928614, 0.09962099672108471, 0.09602633643914926, 0.08984808149322432, 0.10773777959507025, 0.09188254552399489, 0.09060283481543685]}, "mutation_prompt": null}
{"id": "93dd6174-a4c0-4b54-9f5a-b18b0eead2cf", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.F = 0.5 + 0.5 * (best_fitness - trial_fitness) / (best_fitness - min(self.fitness))  # Adaptive F\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce adaptive scaling factor F based on fitness improvement rate to enhance convergence.", "configspace": "", "generation": 9, "fitness": 0.13880475569694325, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.12.", "error": "", "parent_id": "0cf6cb00-3b6a-4d0d-93e0-12addefc3c4f", "metadata": {"aucs": [0.12606142427449463, 0.23982911178079847, 0.13716337069455098, 0.10469350522758902, 0.1898901623917827, 0.0820897035360888, 0.22987933151210815, 0.12005886616504469, 0.23952326288740178, 0.01437970694509838, 0.0, 0.0, 0.0, 0.0, 0.09392634028890556, 0.0, 0.0, 0.0, 0.12974552069481216, 0.09035198077010576, 0.09047696354353096, 0.01942058187889595, 0.06470197875388473, 0.023169184626877226, 0.015196786605721324, 0.12450707105013115, 0.07056184975809032, 0.06440067595499965, 0.009462498854399426, 0.05792632067349912, 0.09607521082354253, 0.0, 0.02840995782803113, 0.08700087910478282, 0.003530885189474753, 0.09404055985322668, 0.03675636805201754, 0.037871487835232975, 0.03255246448296367, 0.01821012380941467, 0.0921934717013726, 0.02702975936339458, 0.02729672961156515, 0.1446774220142132, 0.04052855632891328, 0.045945498667763984, 0.06425417303499015, 0.0393063593935189, 0.08075436912199407, 0.038296166308889434, 0.00955323500858618, 0.03639346598499249, 0.20856429617489214, 0.08553924815974401, 0.11884374327465708, 0.19742421832824608, 0.17297245756242696, 0.17556842499479386, 0.07754794076896432, 0.07169410968353873, 0.15519421858310856, 0.1520509995433238, 0.22985760775250674, 0.0, 0.15423757942120542, 0.0, 0.14640616968079434, 0.17274356106811117, 0.04004073855417989, 0.4542354841123716, 0.46334852864092746, 0.10893628020577895, 0.2660213591663303, 0.14359244611390554, 0.12191447877058814, 0.16965023648526167, 0.017041014124350107, 0.18345134280793374, 0.13649266199181054, 0.2979986831834418, 0.1539176469268898, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1525562386683087, 0.09729755318920363, 0.12247337286172655, 0.22253040653156442, 0.06814737513230362, 0.08497136171035491, 0.1883188512454793, 0.01564706547085648, 0.09438505935403141, 0.10586018942577047, 0.0, 0.13406884912864914, 0.0, 0.09561131713775595, 0.0, 0.0, 0.12836810560208323, 0.0, 0.03773671286171243, 0.011572162431483402, 0.0, 0.0, 0.0, 0.02398287557789658, 0.0, 0.12210067199299779, 0.00805425354518119, 0.3736424861165437, 0.32967780601091257, 0.5768666159739442, 0.2133249154262452, 0.5166152938684949, 0.4857288340928603, 0.44949997062005387, 0.27785792827128475, 0.24233580561520596, 0.18334737661717593, 0.1350799299307287, 0.034336264025270014, 0.11552063986557948, 0.1264922583866146, 0.10172815714513617, 0.0777421331501198, 0.1433015193714695, 0.06615978054408356, 0.18190293126703583, 0.19088141172714312, 0.2386041568564098, 0.22582054121016293, 0.2573996607248391, 0.16836887508847398, 0.2613875771233717, 0.2637738020681337, 0.162481258149902, 0.1540343033842677, 0.15917197884004142, 0.2250412043194563, 0.22450511290234665, 0.2725825039081726, 0.27179454970402617, 0.2030960979808989, 0.19846437911739379, 0.21514521481054993, 0.11787893484317102, 0.224605929078455, 0.09987325911608846, 0.18506628533236424, 0.13786665969755563, 0.18314712431084457, 0.18410401407262456, 0.22884947348166151, 0.1831033868998958, 0.23056927737152477, 0.25087990508182123, 0.22524514210939317, 0.2488499526067326, 0.22943716437128825, 0.23994129890335736, 0.1932039926531901, 0.20705224291808644, 0.21021274281300073, 0.16954768126111663, 0.17952544796576253, 0.15470754929840036, 0.17061191356518413, 0.17723350133057647, 0.17915721950321672, 0.1623398898896008, 0.1866912629317269, 0.20538601150665559, 0.18877729190015935, 0.1658221954672161, 0.1889763207833064, 0.1316870903141253, 0.9306902616935453, 0.14314890451200513, 0.15639673258359177, 0.15885044693846317, 0.16139572563661164, 0.3663223776543657, 0.15725706658298855, 0.2850975178543864, 0.11660056017280951, 0.4501194536769896, 0.16770646975714953, 0.09478543912432069, 0.0949317114335867, 0.16975946014502774, 0.17944970917277114, 0.21453984391942882, 0.1920974394530991, 0.17646509439358593, 0.18045980438021847, 0.18923036846581687, 0.17936146389772933, 0.18687809587680237, 0.2413437379218265, 0.10415017868035537, 0.07281899061584152, 0.08391141984877337, 0.10010218919366376, 0.08383906369270866, 0.09857797285889569, 0.1116531532434637, 0.08785026370301352, 0.0749116375283243]}, "mutation_prompt": null}
{"id": "cbcb858d-3f7b-49a8-9229-2607227c033a", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            sorted_indices = np.argsort(self.fitness)  # Adaptation based on rank\n            f_scale = np.linspace(1.0, 0.4, self.population_size)  # Adaptive f_scale\n            elite = self.population[sorted_indices[0]]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.4 * (1 - diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale[i] * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce adaptive mutation scale based on the rank of solutions for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.43077896850138325, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "0cf6cb00-3b6a-4d0d-93e0-12addefc3c4f", "metadata": {"aucs": [0.9275635250857703, 0.9384623471143508, 0.9429867319582128, 0.9243851258425992, 0.942825811427465, 0.942536579484693, 0.9338298695799947, 0.9346271590822736, 0.947630314053119, 0.8280326527664733, 0.7843800018786812, 0.8127056586486823, 0.8389351892648168, 0.823925068295719, 0.8325103808845135, 0.8240421550056345, 0.861205445584779, 0.8218044354364838, 0.1588252162037075, 0.13832315157376684, 0.1443514088731681, 0.13666096739484712, 0.14144751653887666, 0.18190456182214432, 0.1382681135527175, 0.16022442178081708, 0.15537273602795354, 0.147237621007833, 0.13622952336899052, 0.13458459160712732, 0.13236189502157025, 0.13438367464340883, 0.11317750475493327, 0.10136026547133092, 0.11322508483269544, 0.12583374283721893, 0.9644981555100247, 0.9456621380147032, 0.9764323779227222, 0.9811250519244783, 0.948152138463817, 0.9726895591087209, 0.9686776675880354, 0.9814171957649208, 0.9544451402577642, 0.669729676758446, 0.7835431432985118, 0.7424076710598986, 0.7524903088113575, 0.6187053822864741, 0.7482390724340795, 0.775819745384607, 0.7634858592493619, 0.8173512559762216, 0.3973152649965316, 0.21349950534827988, 0.23034608357749276, 0.3688924154796084, 0.21461672473297633, 0.9647343700035402, 0.23910292482455575, 0.2478301979893467, 0.9492601311082653, 0.5882169615448631, 0.2919973609302119, 0.380549665819531, 0.6450559289731522, 0.6818247667111681, 0.4670820165234385, 0.7832699016881484, 0.74159135503195, 0.5751365189139723, 0.5379110975304537, 0.13460590155736596, 0.42033208605190575, 0.4666976882373318, 0.518452755749701, 0.35729740194167703, 0.565806403340988, 0.5477498158534092, 0.704944953076042, 0.24875883818107958, 0.600952390569724, 0.08036936576024978, 0.35777888023806625, 0.16518551230424383, 0.5959814001033563, 0.5803063900826841, 0.3692286055803875, 0.6268468927134445, 0.17739767802292006, 0.2851782141517204, 0.24530230071654469, 0.2952806918866995, 0.4510342047189084, 0.23209281882293908, 0.2204180662266575, 0.22694535205006727, 0.24993874453913156, 0.2155673783844928, 0.31996050133760134, 0.17645958832469, 0.21060507180188026, 0.29334879583305107, 0.29400330120548046, 0.2651170196813054, 0.12501654751292846, 0.2278412940163571, 0.48950178510283127, 0.4377276353171011, 0.4696458204743561, 0.5314215332825126, 0.48323976135696234, 0.4560218631008066, 0.4971190876733472, 0.3495267711406146, 0.480277446909827, 0.8399342465937553, 0.7553549880816169, 0.8603534293105403, 0.7896830258435283, 0.7481766612198528, 0.6706487852407359, 0.7559202891672663, 0.8856510718994632, 0.8504216473812891, 0.7678238692288379, 0.1444653612009359, 0.13856337978224165, 0.1527553662888551, 0.17940245925903597, 0.15561932893221242, 0.1503029554606533, 0.1507521856321168, 0.13876260089567916, 0.18933468790899277, 0.15181254806626898, 0.1852285830093766, 0.14578294984903328, 0.16287861538722703, 0.17466754089459136, 0.16309397654609548, 0.14742049973702398, 0.19004025202659014, 0.5900856880663456, 0.5901547336084632, 0.5206449853780759, 0.6267055345603494, 0.6023002227769474, 0.5597182068341315, 0.5550586207720706, 0.5768383784594039, 0.548970324864098, 0.38022776046408957, 0.3005870638043914, 0.4851388898656469, 0.3091062510976019, 0.23718318901551838, 0.5051185466897915, 0.5064804876391247, 0.2553718324671559, 0.2548217546160384, 0.2198011823480449, 0.24181890437581222, 0.19615296179988617, 0.20273530416516328, 0.20673278156716424, 0.19436067749606112, 0.21683460367382945, 0.1985312237602086, 0.19351026491333934, 0.2264532061409683, 0.21870536754946657, 0.698074408313783, 0.48951751341030314, 0.23916891172988974, 0.21824665475583782, 0.715258417575689, 0.2164814640872451, 0.2071954727856442, 0.18757581830410242, 0.18810487943282284, 0.18826133932240885, 0.16139999009433703, 0.926490350158508, 0.8716983725532906, 0.840331824068111, 0.16175440656936557, 0.16551345221451497, 0.795807778635626, 0.9355852012484329, 0.16928154538799645, 0.16880687836040054, 0.20934044298987464, 0.16871883480999128, 0.16747472072742853, 0.617199979110336, 0.1694464223641582, 0.19228922113866598, 0.18609369217923366, 0.19180513707474478, 0.20063542303863646, 0.19631270540927437, 0.1915464474799865, 0.18321332957049075, 0.18582267906138294, 0.1834569158480508, 0.08908695550860501, 0.0960561125423468, 0.08062798820095851, 0.09877359929109553, 0.0899472715136922, 0.08912488997461676, 0.08215123005137615, 0.08674997599867329, 0.09627855461143664]}, "mutation_prompt": null}
{"id": "93f98cc9-5add-48b7-aa87-0d45d6b8feef", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            f_scale = np.random.uniform(0.5, 1.0) * (1 + diversity)  # Dynamic scaling\n            elite = self.population[np.argsort(self.fitness)[:3]]  # Select top 3 elites\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite.mean(axis=0) - self.population[i]), self.lower_bound, self.upper_bound)  # Use mean of elites\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by incorporating a diversity-based dynamic scaling factor and updating the elite selection strategy.", "configspace": "", "generation": 11, "fitness": 0.4036913769209227, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.", "error": "", "parent_id": "0cf6cb00-3b6a-4d0d-93e0-12addefc3c4f", "metadata": {"aucs": [0.9367803861017159, 0.9220281329080698, 0.925845139544113, 0.9321673288443693, 0.9333370830821885, 0.9420812092750244, 0.9367088009851411, 0.9404948611677125, 0.9342446494329477, 0.8084368919119324, 0.7977778798066502, 0.8150790320717866, 0.800197782688533, 0.7958456000953148, 0.8075070176455125, 0.8172072046597224, 0.7990260292290963, 0.801021335719822, 0.11865035902626098, 0.14441102787545046, 0.11215123640321378, 0.1131586770555546, 0.1538942178413064, 0.12907058116101233, 0.14605741488313229, 0.122006831465725, 0.12172962676516508, 0.1541183385549968, 0.10701239828648956, 0.1197539718403492, 0.13400435355823048, 0.11556340060212933, 0.13116208875238045, 0.1166840114051354, 0.11590413222015672, 0.136276485825214, 0.9872794303536429, 0.9777431389366649, 0.9584997733502988, 0.9784462105678826, 0.9584635391123613, 0.9583905910604661, 0.9553237049118142, 0.9897180942460791, 0.96902583256656, 0.7372295746902776, 0.7315206206861968, 0.671130999642779, 0.7088919563432352, 0.6959858589686743, 0.7059267408808787, 0.5389652581411517, 0.6684880454434092, 0.7682299292905358, 0.22868367537081558, 0.1357720718520382, 0.401235483446582, 0.9335013103520439, 0.2085651819116504, 0.2803187343147915, 0.23194414124168783, 0.2366653749574229, 0.9518531407538413, 0.48123678348370935, 0.44776751591273467, 0.1343535917515044, 0.13506881119126646, 0.13481600588048737, 0.42799753731028256, 0.13582457047786434, 0.2713251617301107, 0.41797074029816983, 0.5115592323205922, 0.6186026300766176, 0.46516459556354384, 0.13549104779503052, 0.4372133065752154, 0.5445347478276692, 0.5704331866645129, 0.3010169924239354, 0.13559646656372093, 0.5537351166035283, 0.5663302116155187, 0.22089335590022297, 0.45785780970870393, 0.10657521897324318, 0.12054980506355017, 0.12139794682079241, 0.3077921047519452, 0.3657969600721753, 0.22471899705428233, 0.3194193521014369, 0.1473889494067735, 0.6135392670692521, 0.22512929334491028, 0.3782931946309658, 0.5035168116017057, 0.591821289827139, 0.1521929811640237, 0.15422358001446046, 0.422019292643126, 0.17803671289127165, 0.21272840395321146, 0.3523829213942933, 0.35765524680962035, 0.2616280428887773, 0.29424883338639884, 0.18143094458334375, 0.4109352597765291, 0.38772723802124043, 0.40458989962633407, 0.5353502979451878, 0.5474917049048404, 0.49151764808554566, 0.46578768386210145, 0.39735138795480685, 0.41125618229593974, 0.8376089312948625, 0.8524659091958969, 0.8252037449815814, 0.8828914336072227, 0.8639986973413865, 0.7627934323360279, 0.8617146153021563, 0.7285137115437504, 0.8648151777049253, 0.1262966230125172, 0.12935757426279137, 0.5040816042990017, 0.15239505866789604, 0.16763989600919593, 0.13064630500798435, 0.1481168287706368, 0.14520676960063517, 0.13643277447046398, 0.1769818700915632, 0.1380075579416401, 0.20067940409525564, 0.14732802327272254, 0.13644235825015183, 0.17186198033357492, 0.17781371140578672, 0.14415727921009092, 0.16352953507021006, 0.580916775550069, 0.3948246919819911, 0.3952414780815916, 0.5267216436055977, 0.6255321589017048, 0.36122898829591565, 0.5379263376427542, 0.3248562255354698, 0.27773815820918857, 0.22286971083627916, 0.350619843264116, 0.4463963546528129, 0.31661937338387336, 0.47789668776108407, 0.5017541787782063, 0.4967968152567891, 0.2555259475721957, 0.2738199400101051, 0.19838408664599438, 0.20026580568949648, 0.23714910903485475, 0.2545192864412493, 0.2096428167727853, 0.24216030686906653, 0.20682406509589346, 0.19956099546984485, 0.20803614708823825, 0.25362907688481073, 0.4663391250391149, 0.24239136238931036, 0.22022158191623153, 0.25191427964370106, 0.24069407199230586, 0.21491198031543257, 0.21549324022260208, 0.20683536427362337, 0.18717429742394553, 0.18672172912783958, 0.1864069453595596, 0.7640897706739158, 0.9185785221701136, 0.16637908037471738, 0.8951783944313925, 0.8788965841611702, 0.7267137278327728, 0.21088712442875546, 0.1270420208937627, 0.16933905452157394, 0.16895148273124905, 0.1685566848649782, 0.21091355741953743, 0.21212172844903066, 0.2125713791771151, 0.9048459132751389, 0.1833274807170363, 0.18635356478325082, 0.1796775621223312, 0.19671592310108976, 0.18444928687953055, 0.1670901178304548, 0.18795358768161363, 0.17979068161725842, 0.17685574271490534, 0.08616203324480898, 0.0892298009222493, 0.08924639793142941, 0.0961558062491642, 0.08259355493254572, 0.08399488532403432, 0.08355402171799664, 0.09054739966977665, 0.09055594929952149]}, "mutation_prompt": null}
{"id": "ec351baa-ed95-4caa-8445-8c38cb0d4798", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.6 + 0.3 * (1 - diversity)  # Adjusted adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Adjusted the adaptive crossover rate to further improve the balance between exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.4218834907478192, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "0cf6cb00-3b6a-4d0d-93e0-12addefc3c4f", "metadata": {"aucs": [0.9249831689340491, 0.9398171601207465, 0.9387048322169393, 0.9358179846546079, 0.9269520371746224, 0.9360978856133637, 0.9263104019176039, 0.9419365826909202, 0.9435399517877692, 0.8169996305295033, 0.7993489415056019, 0.8224305747046732, 0.8119343924705054, 0.7685879087347166, 0.8123512122926058, 0.8113213806531976, 0.8090521191393028, 0.7924625373456253, 0.18697500234559183, 0.1259934975830176, 0.1396957834079252, 0.13818597673446187, 0.13627299071693655, 0.13275949338285575, 0.15035643058636738, 0.15214773647536772, 0.1416828390341185, 0.11455699603397607, 0.11588048558035968, 0.15587667537657213, 0.130876472828375, 0.11870762225682707, 0.1146062378134084, 0.136071735054622, 0.14302851165975994, 0.11865278854049033, 0.9309199578020876, 0.9890881722227803, 0.9590809794122779, 0.9759662788937217, 0.9822198950775305, 0.9561443041305189, 0.9569218142327395, 0.9735237005092345, 0.9544779399812939, 0.688526075823678, 0.7074072009357485, 0.7380057689392631, 0.6815234341717469, 0.7233826696236751, 0.7737488079939312, 0.5705803892523922, 0.6266539526031527, 0.6461996693238317, 0.21664728122516952, 0.8418900383213694, 0.3217443885656881, 0.3908334378509417, 0.2788433772739328, 0.221918267522473, 0.24916891584817946, 0.9525142891847987, 0.9103041347303528, 0.5434593710981876, 0.6203402184915962, 0.13610974619380234, 0.5817564224161986, 0.584339218472152, 0.6882727382954111, 0.41471347423513727, 0.5237794773872817, 0.1364778547016311, 0.5837008131486507, 0.45759468737309483, 0.7176142808125525, 0.6359590451979793, 0.6462179704477741, 0.47288489716959026, 0.7085299661818336, 0.6209073555871159, 0.5588345612724731, 0.191694224166018, 0.35331498911209425, 0.25594261605362323, 0.507169853918948, 0.5856263765769398, 0.6982330947791928, 0.5217020678907871, 0.5963151261300381, 0.4829695270594957, 0.41445930743059456, 0.2536600323832098, 0.09327059025741669, 0.2704238337402133, 0.22067656691828796, 0.14917736325140918, 0.3786770122629962, 0.6333030831168256, 0.4777627706015133, 0.13453339541628773, 0.4429708197227983, 0.27258040824273677, 0.2775239023181234, 0.467812228118466, 0.2220896912483924, 0.24381423071365405, 0.13889906696119392, 0.16281050699627464, 0.6043416206251513, 0.5044860154118508, 0.38672030327942264, 0.5231109802558731, 0.5334969564411433, 0.35917810002873707, 0.4132551474813825, 0.3703441346167833, 0.5434627627179993, 0.7965475718479804, 0.8564655149083085, 0.8812804841397898, 0.8713690887047282, 0.7625345627779576, 0.8218730560820902, 0.8452168489832145, 0.8073152433121923, 0.7291512945910004, 0.12491686759127951, 0.14321690370501783, 0.09506536791091935, 0.11609422297675265, 0.14355586887910865, 0.13038725031017073, 0.13973215457976818, 0.12346479573448832, 0.1434684112985416, 0.16266961971140304, 0.16182434030587534, 0.15123544556114998, 0.19122363302549028, 0.15533520988887917, 0.1559831629556716, 0.13849128380161468, 0.15545903606700395, 0.17334844667418514, 0.31700991732502504, 0.5469402862368464, 0.5514498957351146, 0.36261731087910654, 0.3611645668374235, 0.5723458494145361, 0.6277112376480973, 0.49344332205088426, 0.232993077264252, 0.30564160286129904, 0.2519513586391705, 0.33078474415847425, 0.4306134161281455, 0.2771473434972316, 0.425859560231604, 0.27540960673848547, 0.4900226868924965, 0.3039327648139529, 0.22837577414426513, 0.22290220280769601, 0.2491099804785757, 0.22097056628206813, 0.21801802919440538, 0.21454633885350305, 0.21897234616181172, 0.20600505034769845, 0.21058762645609574, 0.2512015033308195, 0.18806939907784526, 0.21343749543715285, 0.6182667262195989, 0.23385432841452558, 0.2930083846100129, 0.21180749221309547, 0.23636595094293122, 0.7878307978582832, 0.18868611151262082, 0.19785498242816313, 0.1870313021562895, 0.1658269688724071, 0.19909551373700662, 0.16396631720149923, 0.13667336605085378, 0.1903676742160998, 0.19756295582751227, 0.960900851542641, 0.8894118381450965, 0.16963614267065263, 0.21466146917581586, 0.7500329626443065, 0.16883393245545808, 0.16681941962965863, 0.7282490494007869, 0.16832996047183957, 0.19426066051529423, 0.17214514029732786, 0.1970417186487814, 0.1729913661169794, 0.18516940920673608, 0.18173137150904062, 0.1815285981135022, 0.17719795276798944, 0.18489248361545463, 0.11100057454035595, 0.08871679574695734, 0.09165120078188216, 0.08434821539197623, 0.09155017187712378, 0.09117997641614073, 0.08978091005435529, 0.0975227588392168, 0.08607772836577787]}, "mutation_prompt": null}
{"id": "2c22db55-38cc-4061-8186-11216842a1e9", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = np.random.uniform(0.5, 1.0)  # Stochastic CR for adaptive crossover rate\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            # Removed adaptive CR logic\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce stochastic element in CR parameter to dynamically adapt exploration strategy.", "configspace": "", "generation": 13, "fitness": 0.3871531973403168, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.29.", "error": "", "parent_id": "0cf6cb00-3b6a-4d0d-93e0-12addefc3c4f", "metadata": {"aucs": [0.9443903404775075, 0.9327847302699166, 0.9424478093195401, 0.9410598582506601, 0.9325698843202653, 0.9281160961751931, 0.9483897050803415, 0.937344506735586, 0.9453497503028839, 0.8285175265399031, 0.8169979964174581, 0.78966151358728, 0.8310886707293295, 0.8034134151990473, 0.8217131553439531, 0.8268467575002528, 0.7819426339965222, 0.8441908074268378, 0.14430772414707882, 0.17908606507414027, 0.13655600480897023, 0.11525701391217302, 0.13503808104302584, 0.13273669771605023, 0.1452435793893716, 0.1427118664233441, 0.14282410703116966, 0.13288954336784986, 0.13451717733412638, 0.15053030044545013, 0.1445233290482174, 0.1289148757170282, 0.07914779189779708, 0.13665048958427817, 0.12063275304720356, 0.12600624849098874, 0.972604082163394, 0.9895119397991707, 0.9748633797588604, 0.9659066865782827, 0.979348666944055, 0.9869105076642406, 0.9746398715253599, 0.9600580184558558, 0.9845217236229803, 0.729592797086805, 0.753656963326747, 0.7326380907839969, 0.756799140904985, 0.6683039790517327, 0.639806368271679, 0.7252636620328697, 0.6352360939372477, 0.6646486452201493, 0.9490094612169856, 0.3505785272317997, 0.2882026011622003, 0.9487112015331658, 0.9465571510676589, 0.2837025424374763, 0.9512554672524346, 0.9345385381074507, 0.9595718669074376, 0.33515967726452345, 0.31819612575505685, 0.29056685660124915, 0.3055004333721245, 0.1368667669405691, 0.37475412402114117, 0.13680123071067596, 0.2972267878567154, 0.5862329580590885, 0.38529576808808874, 0.3852178444404928, 0.3760078958257296, 0.3639696444218844, 0.36509477054628814, 0.3066701980123434, 0.4300520578789858, 0.13657546246147778, 0.5432907636334501, 0.0412849527820357, 0.2830833390116627, 0.08168976602177846, 0.3793332344467183, 0.3961699796590107, 0.250099481040007, 0.2559867132345738, 0.14907518131719422, 0.21226817678210597, 0.1868194821311009, 0.1848828351979862, 0.08629733773709525, 0.1824364849603699, 0.41837992681318414, 0.09557264279692712, 0.5137986215397023, 0.46259037923950197, 0.42132893020954654, 0.2202396460370375, 0.14942362288845523, 0.14268704720551884, 0.27087992820973306, 0.2237851581979604, 0.2551505651290571, 0.12016374170732702, 0.22993888075780378, 0.11635805392304555, 0.31470989576903297, 0.3297031026185786, 0.3593050141558244, 0.3542362786492683, 0.3085149842743956, 0.35185110959509436, 0.3227643638215466, 0.2826441728996828, 0.3913343464026554, 0.7520586616885938, 0.7295557376411475, 0.6719876121188864, 0.7629594980666888, 0.7187410591947774, 0.7481911885456234, 0.8217348749877252, 0.6956470970187076, 0.754450389100764, 0.1618710755518732, 0.12261256900005191, 0.11628359950064371, 0.151882142373844, 0.12861140255884962, 0.13899657117448516, 0.14335940419723414, 0.08849817408185934, 0.15139108954527003, 0.17794229423933172, 0.15280168390716098, 0.18963108517062188, 0.16294228291677793, 0.402930283283638, 0.14012110898931918, 0.16675550740463463, 0.2446784567111968, 0.14789250362095885, 0.34678611699569406, 0.3138818232713535, 0.3252692781495361, 0.5245272980212772, 0.37643617749170655, 0.5571355402826533, 0.5677269684986579, 0.5336925136879282, 0.4077592222714942, 0.42057700256885056, 0.4083233341899677, 0.3452107031349205, 0.42531380988680734, 0.414298901521458, 0.30237548520178825, 0.23212729792143305, 0.278774405686644, 0.3102342874886119, 0.21414033747276073, 0.22531172299472524, 0.2392482496865086, 0.20819471890736319, 0.2248404530844852, 0.18789913435111016, 0.24652126619200032, 0.20815150623588263, 0.2316724534126462, 0.2230263530751725, 0.2106626612616458, 0.2413266358406727, 0.23007450177898237, 0.6346155661250458, 0.23476955387379317, 0.25237893854692584, 0.24204471751089063, 0.22175742541848353, 0.17235486811398892, 0.18893855209139698, 0.14812652930286352, 0.16484418602218442, 0.16883166614680523, 0.2001945750123969, 0.9261246751223601, 0.16952090911311846, 0.18752160063451395, 0.2127372783237781, 0.21253162538773795, 0.7139197928173187, 0.16813069491297483, 0.21416684000806185, 0.21074951561386523, 0.15713533852940276, 0.15590858641904382, 0.15702755286648085, 0.18360508417457622, 0.17405072244155384, 0.1821592818432054, 0.2014500322248962, 0.1846067514250077, 0.19081314183289955, 0.19785368794864922, 0.19258096631475774, 0.2006199460835062, 0.08754058887125904, 0.09050638908785003, 0.08735755550138025, 0.0864660421315151, 0.10538358052810304, 0.09156747401413468, 0.08790106458096492, 0.09915192346788315, 0.09199436871927968]}, "mutation_prompt": null}
{"id": "21b448cd-7387-4799-b900-315d9ce8f671", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by adjusting mutation strategies with dynamic scaling factor.", "configspace": "", "generation": 14, "fitness": 0.45924502936579653, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "0cf6cb00-3b6a-4d0d-93e0-12addefc3c4f", "metadata": {"aucs": [0.9269351805220212, 0.9228973734260824, 0.9293969182802839, 0.9248975561340582, 0.9344163788306996, 0.9326031205243148, 0.9328623558188918, 0.9284201600345972, 0.948894954846792, 0.80179840229158, 0.7636771397667138, 0.8003460505422093, 0.8087665692227741, 0.7764960752830198, 0.8002742269532381, 0.7642868567575126, 0.7590918840705936, 0.7898715823051761, 0.15244638018995593, 0.12357064154645125, 0.15233793682667307, 0.1392421677079394, 0.15927482220718125, 0.4809283479940504, 0.15019876124863762, 0.14313873481398953, 0.16540595754558785, 0.14895174915614717, 0.13187213654700658, 0.13212515018561843, 0.11541535715139073, 0.11607416057364461, 0.11290898053487963, 0.09563061498165859, 0.12403604636854904, 0.10715685640796979, 0.9559244203968447, 0.9625122569865813, 0.9769982607979554, 0.9500405889321645, 0.9565860353971944, 0.9729695763552338, 0.9628109475498007, 0.9680295343729446, 0.972533782156883, 0.7400447986731893, 0.7074340160965815, 0.7051009569097493, 0.742715716051662, 0.6948724994692959, 0.728962114152287, 0.7117507395918412, 0.7107712221426736, 0.6720373167769793, 0.22809080779633373, 0.3148922300888539, 0.23184014122507135, 0.3561154902666751, 0.933661077738466, 0.9088034306736139, 0.9367315956254898, 0.1820722359158402, 0.37047536489918453, 0.6276363598314753, 0.5403237008280697, 0.45230965121378364, 0.13562474496409793, 0.5274523206232133, 0.4912814802720834, 0.5816412008821614, 0.7010356691439985, 0.6059105312034997, 0.508037738566574, 0.5897968222891166, 0.599178931467414, 0.5510942109098146, 0.6870059457775994, 0.5394585511776, 0.6367925684240299, 0.6792648745170389, 0.6378101122660689, 0.08630808274801183, 0.4013923779875108, 0.39277299034654356, 0.6487965157035143, 0.6573642681153853, 0.39796472033603236, 0.45517708285700387, 0.6182493041955452, 0.6141881062940342, 0.2577853643028378, 0.6031089669904434, 0.5123656309976796, 0.5519106336435696, 0.09624000478737216, 0.28995974429644644, 0.6719237154314055, 0.6586222705225095, 0.3638614201301962, 0.3976314658446035, 0.15316267647328552, 0.34750875645754864, 0.5727755354081567, 0.33157071310608754, 0.4256724653584274, 0.4048770489477176, 0.24326082961472495, 0.37059925361150414, 0.516076174590552, 0.45610649486273847, 0.49538845890596916, 0.5460366374856552, 0.5253567278258997, 0.39154137288932467, 0.5183067360178394, 0.42155942534022683, 0.4326348374267066, 0.8163189855784587, 0.8244214792592389, 0.8791794338013932, 0.8474772626765912, 0.8185802564208524, 0.7467746733378677, 0.8405026018497473, 0.8219819363948013, 0.8335866960100928, 0.1143077186805409, 0.14819807973710863, 0.17373972734344478, 0.10648777806706655, 0.13219088981670646, 0.14294074520552003, 0.1351529093456848, 0.14024225973445392, 0.4003153748931618, 0.18480833589212697, 0.34169466374553303, 0.17253321686428047, 0.1840936021283116, 0.17726325680071187, 0.22344625386916472, 0.20476539572822616, 0.14996875939650867, 0.3632041277718264, 0.5422011802032716, 0.5215391178735187, 0.32981188903393155, 0.5257470108882677, 0.3899432037824454, 0.5325770944235039, 0.5396830781691764, 0.5618868390259032, 0.5497424561238378, 0.42352198239244887, 0.33343260931424246, 0.38538094081404317, 0.48454285685551124, 0.4332531554952501, 0.3979586111120743, 0.3645151859655079, 0.22855329192832674, 0.451608899378236, 0.22991067199045012, 0.2157020210047904, 0.2134857917462114, 0.23535881471305797, 0.23239118934768876, 0.218556982340804, 0.2384716339407229, 0.21819355515828043, 0.222851506770826, 0.8485110235891489, 0.2353149190165027, 0.7301604330396364, 0.20727669847251606, 0.24885730933633143, 0.2508472928302178, 0.21150839862615256, 0.24580588658439428, 0.2083001096446776, 0.18661180294794333, 0.9519743139880315, 0.1881525917917345, 0.20041917361249306, 0.8701765379571569, 0.14813144882528084, 0.9280034587359374, 0.7816569612774142, 0.9176217786059521, 0.9343376395772369, 0.770747795998347, 0.21158406024513132, 0.1671961720068592, 0.2096928291207676, 0.21018579682705818, 0.8070189664584362, 0.2099045286268585, 0.1689925138482753, 0.2055608514062217, 0.18759766070137962, 0.1915482216051031, 0.1972614042687748, 0.18773150603010347, 0.1698454820741685, 0.19442074407005416, 0.17959501160754332, 0.1839442694321256, 0.08079027330757393, 0.09516381380857852, 0.09266808061941123, 0.0958459066990417, 0.08887310989954256, 0.09347157944654849, 0.09811017585151782, 0.0962194794188519, 0.09315337218533137]}, "mutation_prompt": null}
{"id": "7e0e49b6-a7df-419c-834a-fa5477b4879c", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance * 1.1, size=self.population_size)  # Slightly increase sampling variance\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by adjusting mutation strategies with dynamic scaling factor and adaptive sampling.", "configspace": "", "generation": 15, "fitness": 0.4510655985816579, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9236214820316269, 0.9253302959713058, 0.9359909656796986, 0.9257592491401176, 0.9326058462089128, 0.9310986340676086, 0.9215921480905408, 0.9340235018559402, 0.9375382927281306, 0.7898146167106883, 0.7954420225008383, 0.772379067373775, 0.789217757877396, 0.7665675149660635, 0.7700970256891098, 0.7824126144973733, 0.803436986948141, 0.7463449725398041, 0.17178460191995948, 0.12918134532535042, 0.16974915389100842, 0.14238273659360834, 0.15067084929298125, 0.14172979435450883, 0.13878362997255878, 0.13202311307655312, 0.14851891909596993, 0.13171029765077436, 0.1298200396015713, 0.11506364595881291, 0.12106734802994867, 0.12726957760463808, 0.11341372273039418, 0.11600787005316382, 0.11754750468480857, 0.1259641490386464, 0.963681712911582, 0.9544112188510264, 0.9809794225507571, 0.9438005457475903, 0.9859864523313588, 0.952947443841556, 0.9507085169060382, 0.9735596506898091, 0.9829654620148526, 0.7473562121586002, 0.7478475556508382, 0.7054608976878032, 0.7381826539442095, 0.7612269821272126, 0.7171358485055938, 0.6904600585709386, 0.6918205934944437, 0.725519258404768, 0.38890893740538823, 0.2296604304866473, 0.23070410668816976, 0.2830204650348641, 0.9125145115593132, 0.9523302868457931, 0.23893062407236576, 0.942267153836773, 0.7986867450598804, 0.7178435008964246, 0.5730042314020054, 0.6240388075307542, 0.5334714256627693, 0.7331299250303389, 0.48280443035554654, 0.6490034262070947, 0.6232050946874297, 0.5486419142292124, 0.5934675410947277, 0.6016784512522546, 0.5953990021510773, 0.5380525193142996, 0.6385474959655087, 0.620526899855405, 0.13735171743529806, 0.6472248545541626, 0.7187549188548246, 0.6273935247563883, 0.25083908931175347, 0.5333880717078635, 0.5673271234039964, 0.6275078190095578, 0.6202290798908596, 0.5058602092001022, 0.5757085020995123, 0.23262295543313494, 0.31087960584184826, 0.5349857840778384, 0.550951744554101, 0.6814988655713272, 0.6800494748226338, 0.18362915172285943, 0.6897458398494778, 0.7138138345134548, 0.5471209509739, 0.38855018746530623, 0.2849151757728883, 0.10716679312702149, 0.2893303322458648, 0.39413803248367163, 0.41091394236263423, 0.10545069938798846, 0.21890181821246957, 0.4146825839829059, 0.5597068812954318, 0.46019280371931004, 0.47568844184602976, 0.43305102943555407, 0.481714256048263, 0.5174054470305047, 0.42065297008187774, 0.49803528769602545, 0.39093501105362893, 0.877882621189238, 0.8862887294328449, 0.8650049084422652, 0.8352746883696114, 0.8503791456345158, 0.8553574812876501, 0.8612180486043108, 0.8479354172253677, 0.8149652861648418, 0.11210478792510314, 0.13928850025956419, 0.17624636539257355, 0.11287990441633666, 0.13375990191538079, 0.6198962075600648, 0.11544240221307556, 0.11188395107006888, 0.12476030860569787, 0.15671399474270042, 0.17276736318248387, 0.17571872590346105, 0.17541859084263667, 0.16745718101103335, 0.15318659044687355, 0.15378590275369552, 0.16667688702194006, 0.15619152924752833, 0.5337054134141381, 0.2591165588101543, 0.4912398693010157, 0.38028516782232524, 0.5496121659739521, 0.5260815788156215, 0.5425528132794697, 0.5247169900816401, 0.5527283373904102, 0.3577606630585769, 0.4482163023770982, 0.2769315551498789, 0.4304850756458227, 0.4597988385770604, 0.22792606712745633, 0.4399926462020177, 0.4607110243206415, 0.40092560336313987, 0.20364962946357623, 0.21901871485241076, 0.21444090505579683, 0.20808967107297405, 0.2311711044350896, 0.22700875143409283, 0.2109940696167254, 0.21215873283562492, 0.22218544514103522, 0.7752231738651534, 0.19360629726858702, 0.19383370412737289, 0.2113260993157272, 0.6331578597145906, 0.20948877543554778, 0.4253413283757822, 0.21906633979085455, 0.5693589010202258, 0.187386727486906, 0.18665743201132867, 0.18773962386555387, 0.11477231782896702, 0.17253040848298296, 0.72553632452241, 0.6862402109395569, 0.16867731308942535, 0.16832737026289346, 0.9234622664156911, 0.9406279713392632, 0.16839463367949303, 0.16657952797976072, 0.1671624665718, 0.2113595633589126, 0.5757019254184668, 0.09453998230244487, 0.16872650153558277, 0.19051316559348008, 0.18561965549241566, 0.17442518991068356, 0.18947685258643088, 0.1996670586222773, 0.18643920471992137, 0.18177298349136994, 0.1751182764894258, 0.18804769447642233, 0.08317127824412274, 0.09209654008488355, 0.09245736728103726, 0.08874409664837457, 0.1075220682442054, 0.08785491533904277, 0.08720858459560366, 0.09482066481497786, 0.09223501792191402]}, "mutation_prompt": null}
{"id": "ba05ba38-f6b0-48a6-9880-786f67cd07c0", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population_size = np.random.randint(self.population_size // 2, self.population_size * 2)  # Dynamic population size\n            new_population = np.random.multivariate_normal(center, covariance, size=new_population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(min(new_population_size, self.population_size)):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve exploration by dynamically adjusting the population size during optimization.", "configspace": "", "generation": 16, "fitness": 0.4471279716247158, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9310646345196272, 0.931664119139741, 0.9242714014934609, 0.9234733555878588, 0.9227978475193599, 0.9329172678367168, 0.932698811522439, 0.9269101137591451, 0.9289662963145361, 0.7701938676256534, 0.7794820350476177, 0.8220365759725796, 0.7877282661964482, 0.8099241211345264, 0.8033570523725607, 0.806080013498307, 0.8160408757959161, 0.8017518892374973, 0.13540234320667555, 0.1378718060745976, 0.13942359303433183, 0.16276030275914688, 0.14494087269698352, 0.14792359635034713, 0.13962849335757543, 0.13685033543118896, 0.13438793835533946, 0.13584897937207185, 0.12327490225631532, 0.10492505494109139, 0.12418039160131988, 0.10513874731946493, 0.11179961268379013, 0.14075194300713412, 0.10983072039857233, 0.11919445073991031, 0.9806612356674794, 0.9746479784809325, 0.9656050544304403, 0.9646728029331763, 0.9764899178799602, 0.9763985822576852, 0.9690825959676568, 0.9812659512746897, 0.9651877534191926, 0.7595015831903912, 0.7206409613576452, 0.7584937568878988, 0.6930766085356364, 0.6474799609604589, 0.8115626443239248, 0.7261459772461978, 0.7136859663038291, 0.7664894392723349, 0.25383342110554097, 0.2294887366900441, 0.9438169237036484, 0.960852621331403, 0.3887926174939136, 0.9604608402032478, 0.236431532821894, 0.9206007795134247, 0.38364715435172925, 0.7197257675547938, 0.6125063860381628, 0.7716060369574675, 0.5023252119398294, 0.1347387387594957, 0.13711704939931135, 0.7492475549903054, 0.13595555319444752, 0.6580855560689121, 0.5119328150444169, 0.6027142255965756, 0.6065945182091056, 0.6105031636322085, 0.6905545209828936, 0.4231635841827812, 0.7204644256862235, 0.6146366094047211, 0.1366349879406873, 0.4218929488997232, 0.6905156213711772, 0.17101094346312073, 0.4383408847392284, 0.40627481695094825, 0.31196896064417856, 0.5703098082415023, 0.5029769113032007, 0.5897261071801592, 0.45394067417977435, 0.631321503969021, 0.6194306416076899, 0.3328918404136413, 0.5815455389821174, 0.09098038863725866, 0.465767180242734, 0.5984019447515903, 0.5588891245162926, 0.12495645724992688, 0.32408988833188646, 0.1025440081368395, 0.23265669393304922, 0.2524483919656363, 0.4133335470724503, 0.18629211036118354, 0.33828498188355705, 0.12132817008840069, 0.4112737463858398, 0.4605039546351103, 0.388267643952214, 0.5003649860076698, 0.5270383452346323, 0.4912355064494368, 0.4775011987890032, 0.4435016062551923, 0.4710316353378554, 0.8434626533542063, 0.8624546241301866, 0.8776065460648323, 0.858660540660823, 0.8615247985136456, 0.8237047026182887, 0.8755644675552172, 0.8211077540931826, 0.8674926612976468, 0.1537615751274075, 0.12839552463773785, 0.12183746771985116, 0.13657148162719246, 0.13618682068832477, 0.1069734412440081, 0.09204119160258284, 0.11117877210145488, 0.11614775682149447, 0.17539347821162898, 0.1699526792178656, 0.16312735058502126, 0.20402742400981155, 0.17900413399081339, 0.15677018526051056, 0.23299350575463618, 0.22313422768291324, 0.1502664225788094, 0.5351834807814432, 0.5010916041972653, 0.5350269599989296, 0.5506888953520601, 0.5429215186711831, 0.495457349366926, 0.3380286011940825, 0.5251107245216418, 0.5505594148788164, 0.3113342799749045, 0.4904027264920714, 0.42961386244199384, 0.40934747838490493, 0.2094705099793306, 0.464604144059766, 0.24597215420722496, 0.2956226152284157, 0.3031363218690971, 0.23014059368620388, 0.21308011259199489, 0.21585677135532655, 0.2125143927176547, 0.23416545672457356, 0.2338088908274214, 0.19813571508135364, 0.22413213040519175, 0.2480857501928767, 0.6098502840249582, 0.3918562154658334, 0.20315057473771325, 0.20830158928730902, 0.2192371725344655, 0.4218667025849404, 0.24623920904512664, 0.2428115299337601, 0.21223150898049337, 0.16781541951151102, 0.18571398414957607, 0.901914471614642, 0.15642646529871895, 0.9550740752916625, 0.1646895632281381, 0.17742280260280474, 0.16648163390174087, 0.13143488046643959, 0.9394035311293809, 0.8050291685836933, 0.20972664197795632, 0.5584941983199798, 0.21146814404536196, 0.8081956177991021, 0.8886925384885715, 0.21279629752206608, 0.8691956325582383, 0.1786792144784196, 0.18807294008641662, 0.1913748691408177, 0.18615371997716534, 0.1879862217545445, 0.18249320394739543, 0.18377128236757112, 0.21844412476439568, 0.17510590897759792, 0.09371206529564369, 0.0842146703565424, 0.09390506062379134, 0.08915743022228673, 0.09978880372319887, 0.09754623690076647, 0.11614181877115937, 0.08493294320148015, 0.09395541742268576]}, "mutation_prompt": null}
{"id": "00fac354-bdb2-43a8-b041-1c0846c3c023", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n            self.population[np.argmax(self.fitness)] = elite  # Preserve the elite solution\n\n        return best_solution", "name": "HybridDEACME", "description": "Incorporate an elite preservation strategy to ensure the best solution is retained across generations.", "configspace": "", "generation": 17, "fitness": 0.4382450963975924, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9420915521170138, 0.908096025681957, 0.9344330786904546, 0.9279270450878656, 0.9292710045166294, 0.9430898562401011, 0.9436524906922727, 0.9204820251026267, 0.9472977238585144, 0.8339780681295393, 0.8014929567337599, 0.8365238293149051, 0.7851186807484987, 0.8446364521150393, 0.8308964072811261, 0.8304005743464614, 0.8431688492931659, 0.8174536495383194, 0.170999133006694, 0.17181578691014487, 0.6067326066384368, 0.16496280038768363, 0.18882083459298027, 0.21299141148078116, 0.6873530413924962, 0.169751350070934, 0.18313694893538546, 0.11919794991914168, 0.15634878713910405, 0.1607698687168322, 0.1114754720712463, 0.15402929597188886, 0.11269103119107782, 0.13983108650360687, 0.12213614799379324, 0.12333928582827813, 0.9504699866146316, 0.9497341301953164, 0.9850309176899615, 0.9638100538477605, 0.9867743205644686, 0.9579853956765462, 0.9593358005389794, 0.9878746463162302, 0.9346839462455823, 0.625108938626176, 0.8089218584693688, 0.8056340647959166, 0.775597728390715, 0.7555544490950898, 0.7932298132007151, 0.7471814130614431, 0.7941021428038736, 0.8054795201477641, 0.1410434847392089, 0.1720223743909619, 0.9471869394284789, 0.2850621436372761, 0.17038677359993237, 0.21508081519332845, 0.24366026741219415, 0.24353649135190758, 0.41217605501285115, 0.13767683618375448, 0.4240400661728916, 0.4606870753159311, 0.13737272570465264, 0.4134085085559712, 0.13689609108217116, 0.468962663233498, 0.4907154856639582, 0.5871166916520159, 0.6175833030574023, 0.6581643627265867, 0.5396301436140589, 0.507229372490694, 0.13775904996975408, 0.6463984762905404, 0.6959575038558843, 0.5858870427849217, 0.575153875201493, 0.582939378797662, 0.28348119016352424, 0.15212306778052076, 0.5967698471538123, 0.27671846213215456, 0.22370831102478117, 0.40014848216339216, 0.4151493946224609, 0.11588355624766589, 0.3074779677661186, 0.3638926366025017, 0.44012256962893903, 0.15133626407909995, 0.36018305303111076, 0.10541136056241163, 0.3838422601323149, 0.6170008985245821, 0.6690046582294646, 0.0686439876199414, 0.19183946743831748, 0.13352882713360104, 0.345474951895952, 0.2911659678502616, 0.2514023280403077, 0.14886923298637134, 0.16400601985536445, 0.22175896778868986, 0.29594563762624304, 0.4414046715237415, 0.4390606663906289, 0.42974377144299647, 0.4183972469760897, 0.49290901436007695, 0.4615596540802769, 0.4414891609030437, 0.43789059012903075, 0.8735458179753264, 0.7245183341226651, 0.8440425361498225, 0.6645873818925132, 0.7635485887557052, 0.8446040055698747, 0.7429515323665576, 0.8227126189464611, 0.8151550295678726, 0.16502428286099113, 0.1284895239357493, 0.12813399008377924, 0.08704293081772485, 0.07977344120175223, 0.14326082266653772, 0.12151153365555822, 0.7532531004972832, 0.13476658712174516, 0.24158524075236842, 0.17361054593811298, 0.3664017193340222, 0.8105085884040955, 0.36739719865577614, 0.7768027537628297, 0.5642601801749028, 0.5807868184268523, 0.2744667694631986, 0.5321244087822721, 0.5860845359552268, 0.6156841939655977, 0.6537750080027531, 0.3515305590029686, 0.6670605633503006, 0.5382863565418592, 0.6323780859752168, 0.6111833477557511, 0.22573363074806008, 0.2724672500017824, 0.2963811877991116, 0.4391051007918946, 0.2572626742305345, 0.26616967228960864, 0.1899982962231681, 0.2976745131407358, 0.45423484737366626, 0.2195367795203963, 0.195172903833287, 0.22020715334288166, 0.2072953534812012, 0.21074404302282468, 0.24131600688798005, 0.23026682606498616, 0.22356933357397224, 0.2407133609085459, 0.2560031391493036, 0.20115817305067762, 0.8130911250052213, 0.20152338504240197, 0.2500858183580298, 0.20998217212935, 0.2219225377053825, 0.19230510914325083, 0.19846403780282984, 0.18657669528546117, 0.18780385974377456, 0.16874906395996336, 0.148518858519624, 0.9507452783826824, 0.16562077317747959, 0.953810109020852, 0.9504653144978457, 0.9511296923410344, 0.5348811495459832, 0.12855452234075382, 0.8391443505304723, 0.16676940379758853, 0.21186184774437233, 0.2115556250896572, 0.944344023658521, 0.21015665664518424, 0.16908040973367156, 0.36193907390601265, 0.19105940929146648, 0.221127846265042, 0.19225657084930203, 0.18591359346030267, 0.19659287180991225, 0.20156351105330972, 0.22931904947301374, 0.17935152970525947, 0.09238244902433146, 0.08176900465910186, 0.09631431789073541, 0.09708320785915836, 0.11386145416749527, 0.09703662858349615, 0.12374219486998916, 0.0871839289176276, 0.0854628075013174]}, "mutation_prompt": null}
{"id": "256c0744-69b1-4269-9dd9-ab8714d5bb4c", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.7  # Adjusted CR initialization for better balance\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve convergence by fine-tuning the adaptive crossover rate initialization.", "configspace": "", "generation": 18, "fitness": 0.45924502936579653, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9269351805220212, 0.9228973734260824, 0.9293969182802839, 0.9248975561340582, 0.9344163788306996, 0.9326031205243148, 0.9328623558188918, 0.9284201600345972, 0.948894954846792, 0.80179840229158, 0.7636771397667138, 0.8003460505422093, 0.8087665692227741, 0.7764960752830198, 0.8002742269532381, 0.7642868567575126, 0.7590918840705936, 0.7898715823051761, 0.15244638018995593, 0.12357064154645125, 0.15233793682667307, 0.1392421677079394, 0.15927482220718125, 0.4809283479940504, 0.15019876124863762, 0.14313873481398953, 0.16540595754558785, 0.14895174915614717, 0.13187213654700658, 0.13212515018561843, 0.11541535715139073, 0.11607416057364461, 0.11290898053487963, 0.09563061498165859, 0.12403604636854904, 0.10715685640796979, 0.9559244203968447, 0.9625122569865813, 0.9769982607979554, 0.9500405889321645, 0.9565860353971944, 0.9729695763552338, 0.9628109475498007, 0.9680295343729446, 0.972533782156883, 0.7400447986731893, 0.7074340160965815, 0.7051009569097493, 0.742715716051662, 0.6948724994692959, 0.728962114152287, 0.7117507395918412, 0.7107712221426736, 0.6720373167769793, 0.22809080779633373, 0.3148922300888539, 0.23184014122507135, 0.3561154902666751, 0.933661077738466, 0.9088034306736139, 0.9367315956254898, 0.1820722359158402, 0.37047536489918453, 0.6276363598314753, 0.5403237008280697, 0.45230965121378364, 0.13562474496409793, 0.5274523206232133, 0.4912814802720834, 0.5816412008821614, 0.7010356691439985, 0.6059105312034997, 0.508037738566574, 0.5897968222891166, 0.599178931467414, 0.5510942109098146, 0.6870059457775994, 0.5394585511776, 0.6367925684240299, 0.6792648745170389, 0.6378101122660689, 0.08630808274801183, 0.4013923779875108, 0.39277299034654356, 0.6487965157035143, 0.6573642681153853, 0.39796472033603236, 0.45517708285700387, 0.6182493041955452, 0.6141881062940342, 0.2577853643028378, 0.6031089669904434, 0.5123656309976796, 0.5519106336435696, 0.09624000478737216, 0.28995974429644644, 0.6719237154314055, 0.6586222705225095, 0.3638614201301962, 0.3976314658446035, 0.15316267647328552, 0.34750875645754864, 0.5727755354081567, 0.33157071310608754, 0.4256724653584274, 0.4048770489477176, 0.24326082961472495, 0.37059925361150414, 0.516076174590552, 0.45610649486273847, 0.49538845890596916, 0.5460366374856552, 0.5253567278258997, 0.39154137288932467, 0.5183067360178394, 0.42155942534022683, 0.4326348374267066, 0.8163189855784587, 0.8244214792592389, 0.8791794338013932, 0.8474772626765912, 0.8185802564208524, 0.7467746733378677, 0.8405026018497473, 0.8219819363948013, 0.8335866960100928, 0.1143077186805409, 0.14819807973710863, 0.17373972734344478, 0.10648777806706655, 0.13219088981670646, 0.14294074520552003, 0.1351529093456848, 0.14024225973445392, 0.4003153748931618, 0.18480833589212697, 0.34169466374553303, 0.17253321686428047, 0.1840936021283116, 0.17726325680071187, 0.22344625386916472, 0.20476539572822616, 0.14996875939650867, 0.3632041277718264, 0.5422011802032716, 0.5215391178735187, 0.32981188903393155, 0.5257470108882677, 0.3899432037824454, 0.5325770944235039, 0.5396830781691764, 0.5618868390259032, 0.5497424561238378, 0.42352198239244887, 0.33343260931424246, 0.38538094081404317, 0.48454285685551124, 0.4332531554952501, 0.3979586111120743, 0.3645151859655079, 0.22855329192832674, 0.451608899378236, 0.22991067199045012, 0.2157020210047904, 0.2134857917462114, 0.23535881471305797, 0.23239118934768876, 0.218556982340804, 0.2384716339407229, 0.21819355515828043, 0.222851506770826, 0.8485110235891489, 0.2353149190165027, 0.7301604330396364, 0.20727669847251606, 0.24885730933633143, 0.2508472928302178, 0.21150839862615256, 0.24580588658439428, 0.2083001096446776, 0.18661180294794333, 0.9519743139880315, 0.1881525917917345, 0.20041917361249306, 0.8701765379571569, 0.14813144882528084, 0.9280034587359374, 0.7816569612774142, 0.9176217786059521, 0.9343376395772369, 0.770747795998347, 0.21158406024513132, 0.1671961720068592, 0.2096928291207676, 0.21018579682705818, 0.8070189664584362, 0.2099045286268585, 0.1689925138482753, 0.2055608514062217, 0.18759766070137962, 0.1915482216051031, 0.1972614042687748, 0.18773150603010347, 0.1698454820741685, 0.19442074407005416, 0.17959501160754332, 0.1839442694321256, 0.08079027330757393, 0.09516381380857852, 0.09266808061941123, 0.0958459066990417, 0.08887310989954256, 0.09347157944654849, 0.09811017585151782, 0.0962194794188519, 0.09315337218533137]}, "mutation_prompt": null}
{"id": "531760be-b160-40fa-be49-3c91f6721c67", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            self.population_size = max(4, 10 + int(self.dim ** 0.5 * (1 - self.evals / self.budget)))  # Dynamic population size\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce dynamic population size adjustment based on the evaluation budget to enhance exploration-exploitation balance.", "configspace": "", "generation": 19, "fitness": 0.4453164136317103, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9321543096914803, 0.926108656859706, 0.9331710812789283, 0.9167561107489555, 0.9382111556934443, 0.9312193864780036, 0.9302175946759396, 0.929644516644201, 0.9498666899745944, 0.7871901834748827, 0.793650674919972, 0.7792539719813033, 0.8203333395674741, 0.7845642533001574, 0.8224746633088742, 0.7583347390509093, 0.8119507940736093, 0.8131627192042354, 0.15152873259424104, 0.12591935757724326, 0.15407383707170152, 0.12713123090725453, 0.1496820963425789, 0.20127105939713086, 0.16202292094244108, 0.1516379292238702, 0.13297594678655245, 0.14489638365411284, 0.14450123912425805, 0.1292165788559314, 0.12367642334247408, 0.12048962649181016, 0.11032970791446606, 0.09859143355075661, 0.13894598856759255, 0.10291491714283241, 0.9559244203968447, 0.9625122569865813, 0.9769982607979554, 0.9500405889321645, 0.9565860353971944, 0.9729695763552338, 0.9628109475498007, 0.9680295343729446, 0.972533782156883, 0.7131112645715572, 0.577434360702652, 0.6963134938000912, 0.7497594099507123, 0.5964420341124895, 0.6598586061025894, 0.7357060922012477, 0.6883237928066663, 0.7248988678765185, 0.22809080779633373, 0.22335982713683422, 0.23184014122507135, 0.3458282835477947, 0.933661077738466, 0.9122405908108788, 0.9367315956254898, 0.1820720822184, 0.37047536489918453, 0.5955169427779277, 0.5140331256965456, 0.45368155659401543, 0.13570922409952602, 0.5485703920747996, 0.4044866232897594, 0.46755027316264874, 0.6710827183376314, 0.5781804552053016, 0.47331036737506016, 0.5494201122858866, 0.5642720821979818, 0.5319464132872812, 0.625854661386554, 0.5250033888489392, 0.6041420801669057, 0.5764689411597873, 0.45928200263955865, 0.06719393370947258, 0.21148960165038555, 0.4458701581149559, 0.6018346551574366, 0.37851883805404063, 0.39495577079591204, 0.3205646634685577, 0.3831074012719653, 0.5851474348825574, 0.2656996798360014, 0.614774723639941, 0.4100220741560403, 0.2948390225187568, 0.06314146201221027, 0.1372795598384069, 0.6281093538719242, 0.6821670107855735, 0.32631994603400705, 0.35692095113524624, 0.14982773012275197, 0.2712328061326076, 0.38210904101879273, 0.3043120642862681, 0.39062087195402806, 0.39662690815891866, 0.21216943493299678, 0.325506921196968, 0.3833234460309689, 0.4247941495014641, 0.5026523403807952, 0.5158394405657862, 0.4969695579091338, 0.39828236428496167, 0.44210966751564296, 0.39427991384419536, 0.44971961850731434, 0.7897989806205972, 0.8367750210381886, 0.8621630193199233, 0.8100082892775589, 0.7062173172544988, 0.819173295546668, 0.8546548737449734, 0.8301756396340377, 0.8386612700309088, 0.12035435253613247, 0.12824873968500428, 0.15240354470666861, 0.13095124466465058, 0.39479616753269275, 0.1543350612276032, 0.14581168511287756, 0.11926107563124255, 0.13506442517836126, 0.17952607567364498, 0.1766799293462855, 0.161130221895748, 0.19546015966283392, 0.1595964906779509, 0.17961336944995343, 0.18352145944787024, 0.18273866104762138, 0.19386121613695362, 0.5536743110933375, 0.5130856234378882, 0.36360466998118346, 0.6148440420938829, 0.39388960155553154, 0.5677032179353636, 0.5618015941092118, 0.5585008522870549, 0.6171584014640755, 0.3559734847412428, 0.4284306540559534, 0.4598192973082329, 0.5027025348072056, 0.43327148162954665, 0.4353547459906927, 0.3636925685743482, 0.22761757534478744, 0.5117303986168111, 0.19922689001906557, 0.21769820800703377, 0.227133947335306, 0.2397783656525636, 0.2313243477868796, 0.21266151842548575, 0.2384716339407229, 0.23187933704548414, 0.21109844595445615, 0.7910877365238238, 0.23199666616676917, 0.4923216811857647, 0.20705610712568612, 0.24098399110522506, 0.6511612663908839, 0.20430131579058286, 0.23862968400162554, 0.6727838103723593, 0.1866094952110139, 0.9519743139880315, 0.1881525898340869, 0.20041915863739335, 0.8572149971859526, 0.14813144865262362, 0.9280183888051354, 0.6825583568792679, 0.9158468874137868, 0.9344968148158972, 0.8509003595763328, 0.2115840580408309, 0.1671435711275111, 0.20963455636248562, 0.21018579367357193, 0.8413452163482446, 0.20990451089384543, 0.16899251481092925, 0.2055608514062217, 0.19567003510553216, 0.20082398552570935, 0.20041840916174392, 0.1807039065519208, 0.1756253007766736, 0.20923124569302998, 0.18610802110054914, 0.18579946191614727, 0.07993351223681033, 0.09165664915907201, 0.0956584535520606, 0.08332164606823389, 0.09394943354653784, 0.09393118684263502, 0.10699415642542331, 0.09442049031318545, 0.10252674852790156]}, "mutation_prompt": null}
{"id": "b936fd5e-e0de-4f19-a64f-90cfd8bffade", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        self.past_fitness = []\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2) \n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0)) \n            self.CR = 0.5 + 0.4 * (1 - diversity) \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                scale_factor = 0.5 + (0.7 * (1 - (self.fitness[i] / (max(self.past_fitness) if len(self.past_fitness) > 0 else 1))))\n                mutant = np.clip(a + f_scale * (b - c) + scale_factor * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n            self.past_fitness.append(np.min(self.fitness))\n\n        return best_solution", "name": "HybridDEACME", "description": "Refined exploration by introducing historical learning to guide mutation scale.", "configspace": "", "generation": 20, "fitness": 0.4058315796006747, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9175427534417318, 0.9147533363312631, 0.9257597745197511, 0.9241421671231048, 0.924007662183972, 0.9237096066006294, 0.9231716086979961, 0.9081612606453147, 0.9304856620468531, 0.4118736286731799, 0.4106481071080218, 0.4214547907067421, 0.4266477581952771, 0.44900231758092324, 0.4769924568365377, 0.47466028669158855, 0.406930664925481, 0.41654316309942796, 0.1381787566904763, 0.13194940346779882, 0.1386598429220992, 0.17854463049350255, 0.13870434121290476, 0.13681716432920787, 0.14726391256527693, 0.16030858847109852, 0.1336683049394395, 0.13678729687298619, 0.14829106087592003, 0.13457980949203086, 0.1397663883399658, 0.12174849043409908, 0.12108195397295218, 0.12203564337469108, 0.13698674164681945, 0.1347300899109548, 0.9828747026393928, 0.9713046056060239, 0.974500309921952, 0.9832446190963318, 0.9815745451672798, 0.9743868135468667, 0.9637179535399489, 0.9799346756915784, 0.9734748153317428, 0.598540780885158, 0.6186050120910749, 0.563946164935471, 0.5782331591788382, 0.6040158753649053, 0.5606876393023521, 0.5786373360424246, 0.5852759136566654, 0.5587756932772439, 0.24479401195115214, 0.9404775689843703, 0.9466253086081082, 0.2822358588209123, 0.21460276391689126, 0.9460929327573737, 0.9534130997279948, 0.9540153440572183, 0.23808056512386389, 0.4962154142047961, 0.5116639553187701, 0.5325305741102403, 0.1348368177976108, 0.554145692223112, 0.22609430800406893, 0.5002912290941117, 0.49329509226830626, 0.13518834219460696, 0.4913058401698198, 0.5181266801503572, 0.5053635326866788, 0.5363988116492298, 0.4915551453592344, 0.5515577961714581, 0.4556876642172165, 0.5390319817755715, 0.49000695861128907, 0.3892160415700474, 0.325723037581215, 0.3462948591631486, 0.3618777567406275, 0.3444785853762222, 0.3733779874495883, 0.3678323274301847, 0.3246594407182193, 0.333613962979052, 0.36012156121112415, 0.4322214097429301, 0.40437941340553574, 0.33670302693048304, 0.37991008750591426, 0.4098807436702985, 0.45502934624266655, 0.40216560423733627, 0.31880831970469725, 0.2253316877381244, 0.10002415881884574, 0.2476665902264652, 0.25536900052896094, 0.237043315614897, 0.20783820827997634, 0.2471034973686419, 0.23165489991790122, 0.23991672146151377, 0.28575646843986835, 0.28169459430644606, 0.2826140083647499, 0.3019544962310231, 0.2860996057060765, 0.28289258405761075, 0.2551920072255339, 0.27455393992516586, 0.2735789510774149, 0.8745367023437016, 0.822446970533016, 0.8406540428731774, 0.8614421386208352, 0.8354376995575588, 0.8584024950470462, 0.8308621139779298, 0.8325195334761455, 0.8270931364350842, 0.1322145511629257, 0.14208273856948594, 0.1312075761430368, 0.11346142072270782, 0.17549750006207632, 0.15436198680051727, 0.1486427510981141, 0.1442847805021813, 0.14709864003469753, 0.1617869685393778, 0.15996264134367133, 0.2404905144625381, 0.1559205277296969, 0.16766461451742676, 0.16476932551429058, 0.15693889328773425, 0.15087864918585203, 0.14745305813269682, 0.4804840060769767, 0.3803628756996724, 0.5368576829645393, 0.47787393977547543, 0.5050792186875823, 0.316817711240465, 0.5121057281428785, 0.5277978152671166, 0.5201547771095145, 0.31559427313702315, 0.37932726416390483, 0.22940393610333198, 0.38920343915444255, 0.3269336510540215, 0.4009662420951342, 0.47119822196334116, 0.44179956063797265, 0.429847320932071, 0.2258768272301772, 0.21931927259947748, 0.21238309673254496, 0.21768940362536737, 0.21057943638216525, 0.19954786718635464, 0.21492328179486253, 0.21468512577169663, 0.21801136576227742, 0.24035443278962776, 0.19446040808459086, 0.20086799348226647, 0.20853553012497217, 0.204848899453553, 0.2323402393003836, 0.2439424923589787, 0.43920876297280054, 0.19827473191220646, 0.18819056452158645, 0.18828524352665355, 0.1875792649732898, 0.9245909308014052, 0.9310232386601252, 0.16430216466051517, 0.589910695831683, 0.9099935522526712, 0.9179756935939974, 0.8448450534749439, 0.781792294206221, 0.16865792434260707, 0.21040248270248307, 0.9199846463747343, 0.16829814338901505, 0.16541474091080322, 0.7968461758881382, 0.20737087882945227, 0.18929232602547175, 0.17502238080919885, 0.17357183523013464, 0.18928704060870205, 0.19085865404500169, 0.17711002988382607, 0.1854594042850386, 0.19106457620750528, 0.18271417773489518, 0.11326029599722676, 0.08858645305841584, 0.09277738269056268, 0.09902778047533489, 0.08482253679265284, 0.09276299146424516, 0.10727675447571872, 0.07618790732288105, 0.08477459765717654]}, "mutation_prompt": null}
{"id": "8a795410-8358-4b92-8aa8-84215cdd718d", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n            self.F = 0.9 if best_fitness < np.min(self.fitness) else 0.8  # Adjust F based on fitness improvement\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by varying the scaling factor F dynamically based on fitness improvement.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "An exception occurred: IndentationError('unexpected indent', ('<string>', 66, 16, '                if self.evals >= self.budget:\\n')).", "error": "IndentationError('unexpected indent', ('<string>', 66, 16, '                if self.evals >= self.budget:\\n'))", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {}, "mutation_prompt": null}
{"id": "c8de2842-fbf2-4cf1-8f10-0d7d103eacf0", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.4 * (1 - diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                iteration_ratio = self.evals / self.budget  # New line\n                self.F = 0.8 + 0.2 * (1 - iteration_ratio)  # New line\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce dynamic scaling to mutation factor F based on iteration ratio to balance exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.42934648403294284, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9262451029316293, 0.9286278223005561, 0.9361172406964555, 0.9304358050448669, 0.9246030127563295, 0.9358478454202628, 0.9346502685235389, 0.9263310724548389, 0.9385055989049439, 0.8072892198847541, 0.756423172269947, 0.7964789475090672, 0.8087599624265732, 0.7851453498587935, 0.7816798636322717, 0.7618498567523738, 0.7880440606668071, 0.7804009045903069, 0.14133962921688148, 0.1393400167235772, 0.1585118938024962, 0.3657725964288575, 0.14686299858089624, 0.1474973163036961, 0.1307959670366703, 0.13693056328686248, 0.14266219820581572, 0.15737788685851972, 0.12219600115507057, 0.14634975928796923, 0.12648119785440182, 0.11063557479169028, 0.14008361526061475, 0.14290328353606763, 0.1246675413128171, 0.14813579381373165, 0.9806422791688473, 0.9709111911710248, 0.9796008328791499, 0.9760438059232164, 0.9833370723344763, 0.944929842006548, 0.9654813079374042, 0.9796280993009838, 0.9681189501173151, 0.7164917667932957, 0.6826529873542746, 0.6208417277737859, 0.7637099300721046, 0.6499803946681204, 0.7655584940905706, 0.705297678879824, 0.6759157421527224, 0.6929250205648809, 0.22717100837437243, 0.1410339893898408, 0.25736762649391887, 0.3928679377352067, 0.9478374097888491, 0.2828076841983863, 0.9320259623360975, 0.1619377812703, 0.4081108198466701, 0.6966021646223421, 0.5883710851864181, 0.13483843035166976, 0.13659053017958322, 0.13517599055971674, 0.7482461237491971, 0.744484971425863, 0.680989209373591, 0.13710842222809827, 0.659485121763729, 0.7218210425599778, 0.5262654181554505, 0.5373069716951652, 0.6004868398327499, 0.7041090729331165, 0.62113400331574, 0.5796585870885662, 0.7075166685372385, 0.29993128153332993, 0.5129579472497547, 0.21531223408802036, 0.4491017396288365, 0.49394908342560506, 0.5788700199715285, 0.4306985176431891, 0.6328323150867918, 0.588937258716703, 0.2126643950254361, 0.4434803819491785, 0.4029433431811975, 0.4529902069883339, 0.21449997861228498, 0.10647215869439064, 0.644862316167296, 0.6871512241391787, 0.6264721247701122, 0.3636592131077002, 0.3160385046658353, 0.43992225744441027, 0.43580281858488257, 0.2980757149285539, 0.42889251344547297, 0.2644599187440826, 0.3702061008208729, 0.23792471529682357, 0.44079584265941574, 0.43368177643224803, 0.47748418874842413, 0.5070931996455286, 0.49779299030382584, 0.4832923160914191, 0.40687803986890325, 0.4342848713296108, 0.5036216713435158, 0.8493553571187051, 0.7830843328275696, 0.8228925044107918, 0.8206981870447446, 0.8506560982912377, 0.841734414329347, 0.8447255939874266, 0.8011403869268057, 0.8583895255898075, 0.10659079919859982, 0.14637491454386908, 0.15398486142428758, 0.12740238477995913, 0.12993012122360392, 0.15478162664888218, 0.14013428559032726, 0.14445268396297595, 0.12120059916841341, 0.17325200749508463, 0.17722007394913164, 0.16518258999599345, 0.15972812552533344, 0.1577238928358189, 0.16229393587304553, 0.1728518738320618, 0.16044357914669072, 0.1549702448407323, 0.5558131046332245, 0.5024764193176156, 0.5231080567509514, 0.5373032563697558, 0.546409891932443, 0.3964409281229464, 0.5291643979487404, 0.24144183442291156, 0.5379275773815223, 0.18832999468638123, 0.47211093994345166, 0.4466969062088425, 0.44999710595326636, 0.42719209934311997, 0.42437465015313547, 0.2619570471563686, 0.2419999912767392, 0.4579358436350326, 0.23628475584991537, 0.22876242411407743, 0.22088821966313676, 0.21543356021827342, 0.23310269323062072, 0.21964752502425777, 0.21925971965873636, 0.2277893880603864, 0.23857861071763253, 0.2727071133413499, 0.2355197006985964, 0.2279477707773353, 0.22152856676378174, 0.21732821749437703, 0.23730283038248312, 0.225188329551821, 0.22357687440473184, 0.2771753561383783, 0.18680943641398629, 0.18745251525229, 0.18884235023382823, 0.14865043426501467, 0.8630215187999205, 0.19852157113863955, 0.8734105297333028, 0.44524452564319983, 0.16889602426458628, 0.2194983075938438, 0.8860092619234521, 0.0733101833120876, 0.20774544225877511, 0.21139329656409278, 0.21118793630839638, 0.7873381188471104, 0.21188643418213493, 0.1687659032382729, 0.17314914301116202, 0.18903044540215963, 0.18268898218954532, 0.1782387079516946, 0.17800109685402354, 0.199646567526798, 0.17752914593957392, 0.17845033167928936, 0.1846593568602306, 0.08906170362972043, 0.0873239165771671, 0.09453009667492274, 0.08838398327253272, 0.0940260713739759, 0.08423756061511212, 0.09253543246406737, 0.10025859479113808, 0.0857788058479757]}, "mutation_prompt": null}
{"id": "3ca1d4f9-3670-44aa-b699-cab90f79f98c", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                influence_scale = np.linalg.norm(elite - self.population[i]) / (10 * np.sqrt(self.dim))\n                mutant = np.clip(a + influence_scale * f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Incorporate elite influence in mutation by adjusting scale factor based on its proximity.", "configspace": "", "generation": 23, "fitness": 0.2974319333730914, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9153560000398591, 0.9563872480294746, 0.915478323956555, 0.9463252904909759, 0.9543098474809776, 0.9336043511437122, 0.9438221375774022, 0.944018938477347, 0.9048064757047198, 0.4572264824887782, 0.11784792612682127, 0.15591991598538424, 0.46925292522760365, 0.0952259051931531, 0.24295012583840359, 0.21651647553366904, 0.1733541088111562, 0.057286148300222384, 0.1858719121925364, 0.14295365524749482, 0.2911357016451387, 0.14926335539221147, 0.16499668797769917, 0.1607702062520746, 0.15389222674839798, 0.1246916846855578, 0.12658584784019133, 0.15487129657665177, 0.1305764840589525, 0.09241678558908095, 0.1248267825808329, 0.1530929965070298, 0.0953826455381388, 0.1377204166975733, 0.14380228289537866, 0.15683231903921768, 0.970732092804976, 0.5332812328711952, 0.9696663588033141, 0.15929933338196933, 0.9831167380667509, 0.9570009244747674, 0.952115638731226, 0.9759254795771161, 0.9830392481619702, 0.16684595493111343, 0.34728538048819346, 0.11639056649652635, 0.27316756436114986, 0.76168457422749, 0.3459910548012093, 0.1731400778807074, 0.26513215974777093, 0.1964173151775157, 0.15795447265168072, 0.3279536218934884, 0.231809247598304, 0.28174298928189234, 0.3131695903466394, 0.28447972289895984, 0.3699858805908248, 0.18505852915857024, 0.24879446675036632, 0.26081002998320113, 0.21999761314287924, 0.13678544952291816, 0.15614412180839843, 0.2117383212203363, 0.20285964003907142, 0.22768310371591227, 0.7662843776738681, 0.1349330275643561, 0.20068635480684094, 0.19856655764014763, 0.2157311223221583, 0.22641712689130367, 0.13814559676851856, 0.1623368471637675, 0.17140105770596414, 0.24166525404342998, 0.19006079342197435, 0.014455244415337853, 0.1591190482491176, 9.999999999998899e-05, 0.09075947776685933, 0.07199275160986196, 0.013310340669377752, 0.019462880562557627, 0.1995455792508154, 0.06857912015692491, 0.07405550381426818, 0.2614528594962786, 0.3639907005977837, 0.41451659327813795, 0.14914662058368833, 0.08613500386839967, 0.23535212452981868, 0.11148998650313768, 0.10791664921537014, 0.15941630063582457, 0.2572241759854069, 0.3948145494934894, 0.11283094030378504, 0.10598435907303538, 0.12976579324258053, 0.10449387926171128, 0.14548737336623963, 0.20412246765968123, 0.09809093282227788, 0.3478860404891647, 0.08019344079993185, 0.3023859824366758, 0.3189423328812867, 0.2138311849699499, 0.09258105651448278, 0.22743343329188548, 0.10714545207196347, 0.6418648977992755, 0.6045160972526661, 0.6382962096474876, 0.622551513872156, 0.5952412011557131, 0.5884011592551031, 0.5722971968883688, 0.6082124452627523, 0.591135280383624, 0.15626239281128096, 0.1309623433347884, 0.14794578768003352, 0.15880385145215736, 0.13126024914544254, 0.15226470425480843, 0.07022069326826696, 0.1254041949603637, 0.12098552104380833, 0.15457748325356968, 0.1641514535946602, 0.1509007717996954, 0.15458743865548208, 0.1621191116098495, 0.16086940332416633, 0.16361728759871408, 0.16098281736725462, 0.2948222342630351, 0.37601896131272394, 0.48073921441933176, 0.5365189996703882, 0.4292443787789869, 0.5302159465948844, 0.4021790688857714, 0.3510131366583912, 0.2670518927302762, 0.34234568643129426, 0.42341275805871514, 0.3572908694643464, 0.3077457536481556, 0.325702718830542, 0.22208628745534764, 0.2836699844368624, 0.36731283895722977, 0.23639457406413988, 0.27815179462404305, 0.21840219566925312, 0.21722348442409423, 0.25343883748358254, 0.23385227349573456, 0.23905543512241956, 0.22877640377837438, 0.22958991363503267, 0.2572837406434705, 0.21908466519494552, 0.20153672795234923, 0.20288131093836936, 0.5198827613488206, 0.19456300183991904, 0.2100781421949638, 0.19220137638583834, 0.20373420823368238, 0.18489433476386152, 0.2260230293394372, 0.9532655315663965, 0.18811277277837612, 0.1889645611105888, 0.14871029539794345, 0.8390053848135577, 0.18701250474024378, 0.43844201435522157, 0.159124254476794, 0.16452579733822836, 0.8514506366527028, 0.815733062301673, 0.6549912731953411, 0.21234171402326596, 0.21098662409164026, 0.21284784801081957, 0.5622436944043294, 0.2113279159487632, 0.15289583362039538, 0.1849128917214976, 0.19247603911791267, 0.17447769467474739, 0.19381622082095862, 0.19096009488408405, 0.1791852544991278, 0.18063513950624455, 0.18869847040630516, 0.19519766914951409, 0.09541712454566875, 0.10344287052841605, 0.10001258432301274, 0.10643562607743784, 0.09466040530949027, 0.09739804820399856, 0.1251363345949933, 0.0940920195401308, 0.09670224812959227]}, "mutation_prompt": null}
{"id": "cbdc613f-6560-4a69-b4be-06082c8be551", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2) * (1 - self.evals / self.budget)  # Adjust f_scale dynamically\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce a dynamic adjustment to the mutation scale factor for improved convergence.", "configspace": "", "generation": 24, "fitness": 0.4193636741359015, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9353674034543433, 0.9379808544768196, 0.9386642987369542, 0.9319502947454741, 0.9408856436027604, 0.9384713071433997, 0.9304100623490865, 0.9350290104400648, 0.9464701667403543, 0.8191086531642912, 0.8123583721083146, 0.840966262880861, 0.8242842444077192, 0.8158538778594546, 0.7896162612628059, 0.8130755461891048, 0.8147454520207046, 0.8376939492407298, 0.17610050980676484, 0.15005154665396947, 0.16037374640205926, 0.1431916539932574, 0.148234417780583, 0.16185917036022746, 0.21846056781923684, 0.6584925322301827, 0.12794456955991684, 0.13859127251150583, 0.15181663030181358, 0.14669582532439218, 0.14074421009794824, 0.11362803709786617, 0.08370562710722862, 0.14489077065502753, 0.1395933963242154, 0.13222014010795924, 0.9700361991134192, 0.9668034922848727, 0.9794453478695135, 0.937537946019858, 0.9864480734453587, 0.9809900860474957, 0.9753112572912924, 0.9566512427889166, 0.9807597591669913, 0.7526066195477625, 0.7596728254747671, 0.764395090300283, 0.7907622910795035, 0.7888700926746854, 0.7385803996153841, 0.7817806294987569, 0.7052723849357563, 0.7572014021240103, 0.11885831565579918, 0.1405931891658223, 0.23175829043258345, 0.9611041852860228, 0.9509988234120825, 0.9453270601705112, 0.23655341560497412, 0.22693430376182144, 0.36306187759054964, 0.552563664473161, 0.35519114828692677, 0.2651215548093856, 0.13649051372377308, 0.35812840821738656, 0.24879600054769335, 0.5532072191689436, 0.7443656970834873, 0.2681637089696761, 0.40031001401354416, 0.6896315383274271, 0.2937324639486647, 0.2981705324845605, 0.28433307466315105, 0.7570459433146133, 0.2641687235898228, 0.6528162399874132, 0.4680077004918629, 9.999999999998899e-05, 0.23185288015751293, 0.24792474012512133, 0.31853632833321244, 0.39265222557361035, 0.12287288403723995, 0.2548276521197279, 0.2005592770667859, 0.1311773121413944, 0.09104904154138005, 0.3718511957056002, 0.16067928863820002, 0.32882914685396125, 0.1315350278672136, 0.15979180226660006, 0.7862517394382, 0.18933739426953866, 0.5443220748323406, 0.2962689154302749, 0.12664155172011782, 0.2660720592751964, 0.4350750813569426, 0.19280069207572925, 0.28676284480594316, 0.21615307381000093, 0.18569264994365298, 0.1698763899185355, 0.4115396299493317, 0.33485334690977053, 0.41770413122758143, 0.45699240623194637, 0.43250581457111326, 0.5744981698628706, 0.4300842925661845, 0.542072598990404, 0.42459461586877556, 0.8128003085892408, 0.8242716928735255, 0.8066987098025653, 0.8485990136036821, 0.6820042936954543, 0.7366899061395611, 0.85549307568905, 0.784218818737022, 0.6961619325162027, 0.17367610264063138, 0.13946870970239633, 0.1106257135921902, 0.1477553667253445, 0.11774140228162266, 0.13780118960950494, 0.1146592253440174, 0.13969544292973546, 0.12305684382859816, 0.1663598822808532, 0.15225814543714367, 0.16925641328676155, 0.16531732998677307, 0.21855361036555654, 0.17036884115963336, 0.16050641209529004, 0.1663746956473927, 0.6418538482594328, 0.568980790770297, 0.5984895707168483, 0.6065201737275941, 0.6593938684239264, 0.576723958613062, 0.582808931554829, 0.6029750359345379, 0.7001066821082673, 0.5842472154873025, 0.46245634176728745, 0.45013356584428676, 0.521322742050682, 0.29651319429657397, 0.5707673069505456, 0.45746776647693377, 0.22522985547168128, 0.2399227235269602, 0.29970437758034885, 0.1885563742214007, 0.20301673278022003, 0.2002448407219949, 0.19568140435793824, 0.2316029766039649, 0.23448853730934704, 0.2825304036086803, 0.21792192666965615, 0.23434631407255713, 0.22327078785990762, 0.23407651114998484, 0.24992062368483325, 0.22095393767908356, 0.20385390785821056, 0.24870974307934524, 0.22159152838601304, 0.22698236639619562, 0.22413621894545266, 0.16481446360281482, 0.18734866161796648, 0.1880209544812319, 0.20079930422820635, 0.19946093445220558, 0.16629533111535255, 0.9413242636361108, 0.5778796860630497, 0.9420845452676548, 0.9333874371395345, 0.9045300120972528, 0.21117643765246563, 0.212021351960334, 0.1675764104690738, 0.16832190510158107, 0.4966401608682123, 0.7874695701579527, 0.16898513830196427, 0.1872393278296659, 0.1906453845904621, 0.18183742519110435, 0.17834015420566796, 0.20449782478514955, 0.2025018683604286, 0.17881659432153885, 0.18096375619185512, 0.18237336829412254, 0.08745006121687893, 0.08783341147263712, 0.08871489434774171, 0.09024581915328667, 0.09485637255932744, 0.08576807090280436, 0.11109268017195117, 0.09139296624111226, 0.08950759490038906]}, "mutation_prompt": null}
{"id": "db29b28c-2eab-4512-a2e2-5c221cdb90b2", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.2, 1.2)  # Changed lower bound of f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Adjust f_scale's lower bound to enhance mutation diversity.", "configspace": "", "generation": 25, "fitness": 0.42861780323836884, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9404515932229326, 0.933448938867085, 0.9352751454818928, 0.9370544399410192, 0.931148399132521, 0.9405652505094572, 0.9328114939336293, 0.9314572776059226, 0.9376633734592602, 0.8234572100085081, 0.8158728161494664, 0.8353570940760618, 0.8223132912042592, 0.8165693142512891, 0.8423769112851138, 0.836462108029045, 0.842654529953909, 0.8327594814585262, 0.18883598745183483, 0.11635734971251244, 0.16990707470580424, 0.17122766632793773, 0.13326423692528366, 0.14519194603394137, 0.13015771208816473, 0.1401935350701624, 0.17770383173165738, 0.09453907326507871, 0.13273990568938865, 0.15893338159599568, 0.14052944914559917, 0.14234065607592306, 0.11955955524623896, 0.12084316436143394, 0.12669304316708763, 0.11980304334041825, 0.9741448396354475, 0.9745803828618861, 0.9640366912681398, 0.9694343321205671, 0.9840861239810237, 0.9648159068920161, 0.9531515151799113, 0.9724780797185294, 0.982782417912417, 0.7141088362465977, 0.8080125481927934, 0.7741715128226685, 0.6996986796125929, 0.7562819916222993, 0.7212938232958016, 0.6692971717554608, 0.6628817953591281, 0.7671027323830116, 0.17061784810396674, 0.22719824192275873, 0.23122567973160424, 0.3134324147243778, 0.3900118924750745, 0.1944057141465826, 0.22351024538852182, 0.3683433336590993, 0.15486789295394132, 0.7079280707489191, 0.588387686005114, 0.6282211621737397, 0.5067939193391622, 0.5938948183423625, 0.5374258115171002, 0.642483375039067, 0.4235507304496128, 0.30696255832813557, 0.5682632387469835, 0.7254073646696387, 0.13713734192242644, 0.6192810755640563, 0.8060738125548711, 0.5283261217674979, 0.4507156935916926, 0.8207455030946615, 0.5056789700234321, 0.19306467426207552, 0.21323871171167652, 0.13203343443825888, 0.3333564311959515, 0.23254595363158048, 0.5096302098439531, 0.4833264970527932, 0.16217822856494624, 0.6559220023832868, 0.0914581772546722, 0.45632232220312485, 0.48606952645464063, 0.20473796161940017, 0.41315432933972174, 0.22113272434923203, 0.37599674584250975, 0.47749111992060256, 0.6080188650749727, 0.24955753741096864, 0.20126941988086333, 0.33945705648235225, 0.5402071461015415, 0.3321024130355641, 0.5059142446652154, 0.16117626643587424, 0.22086828642086465, 0.22965796842235564, 0.36096208031619126, 0.43820199615795585, 0.3451466331533892, 0.5294307059648915, 0.43257500851533215, 0.4356858053868353, 0.2803865646907545, 0.48670496109526373, 0.4593585424394391, 0.8462473528850549, 0.8019296991862263, 0.7417081717394711, 0.6922532957965903, 0.6749663011046194, 0.7230370829987728, 0.8498124983612094, 0.863286165428974, 0.8912928079458796, 0.5931895105358058, 0.11449038490216501, 0.12412088291188361, 0.15102517636219814, 0.3369429416681454, 0.18368029985629764, 0.13453204832324495, 0.13474760894072824, 0.1269401254957354, 0.16904823111058798, 0.18927901613485998, 0.16146345091663938, 0.16011519416855757, 0.155309210820744, 0.17810435596931384, 0.16819315632389897, 0.1519627714562639, 0.178207892922147, 0.5668580423187344, 0.5404194868028682, 0.6403686067301403, 0.5687638546264797, 0.6802365304396992, 0.5781781162158044, 0.41047068422750255, 0.5521112086216311, 0.650865905503913, 0.34868176128190775, 0.27117224528758377, 0.24398321894740949, 0.3091272506464131, 0.30103929569386045, 0.3843597713258803, 0.4652493171309461, 0.2552378121391794, 0.5400227862662683, 0.21111994833271197, 0.21707588022994484, 0.20327443522322108, 0.21607158261566417, 0.23231721455977727, 0.2547264168453931, 0.2186207891648979, 0.20768357555881334, 0.27405739967264486, 0.2239749683974086, 0.2306267212235854, 0.21620941815983474, 0.21463360410628352, 0.2080498527329614, 0.2101294813489063, 0.2208260183216879, 0.1969845869694895, 0.1877994054658907, 0.18712856954306567, 0.1862597773597734, 0.18817177026568765, 0.20039112583268792, 0.7090789494383949, 0.8799607770632101, 0.937341124231736, 0.1672422698113305, 0.9334701485434654, 0.8122190089005037, 0.12794075486653678, 0.1685734920430958, 0.1685016523479257, 0.8158493453970425, 0.16699790638306478, 0.8340852792247566, 0.7523875110028215, 0.1677910638602127, 0.18848852806702676, 0.19810986044564327, 0.17975988784752572, 0.19387853228494445, 0.18014159962121978, 0.20209121358523774, 0.18752353991215176, 0.18444484224249302, 0.18234720225301349, 0.09278835112858419, 0.08612545356909673, 0.09302284969674857, 0.08453994129818454, 0.09582133780284441, 0.09560757140580212, 0.11257294788921712, 0.08450356679989146, 0.09096519005327097]}, "mutation_prompt": null}
{"id": "e7e40391-d880-4404-806b-d42bd4cd006d", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.85, 0.95)  # Stochastic F with a slightly shifted range for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Fine-tune exploration balance by slightly adjusting the stochastic scaling factor F.", "configspace": "", "generation": 26, "fitness": 0.4371469881517502, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9351647746830021, 0.9239792767268952, 0.9342263176696577, 0.9305644634256643, 0.9269092749665042, 0.9350768759595838, 0.9191976198531971, 0.9209926771399399, 0.9399298864329719, 0.8058535492166148, 0.8037971964875824, 0.7684993368085926, 0.7785073386724205, 0.7909382386595072, 0.7717355388660458, 0.8089352126170974, 0.8091108242788279, 0.7791406077346483, 0.1699961043190812, 0.13187977040372678, 0.14982858512509412, 0.16253114530723145, 0.15129009007557792, 0.1346547717025005, 0.14021042688050223, 0.13541159691554527, 0.14997315946906165, 0.1245304695929601, 0.13507361437494603, 0.10396910628017253, 0.11981596988515797, 0.12041140212094925, 0.13206234004091544, 0.1317746624510161, 0.13966379789804506, 0.11640853936142304, 0.95379816718635, 0.9647492828476287, 0.9797269316599483, 0.9755119394595896, 0.9883431841574336, 0.9439800219121932, 0.9795970418606285, 0.963167374660423, 0.9757508038564235, 0.7116099539441203, 0.6705938997568182, 0.7294292557803972, 0.6904070910481561, 0.7435284078604683, 0.6253734646906618, 0.7000865679981678, 0.6018406120732791, 0.7524249448303015, 0.17138549890123156, 0.22360121299523494, 0.23195283493362062, 0.2832060965710559, 0.21347249025316706, 0.9532204539599881, 0.17862262492113457, 0.3395107700469402, 0.9460518752236787, 0.6797917814155316, 0.5548935557079087, 0.5598420772136372, 0.6220258876833884, 0.7460730426906923, 0.5390069833508642, 0.5594909066007641, 0.600851542381786, 0.548067479840815, 0.5830927852411191, 0.7416632297212696, 0.135491309574868, 0.5865105901179659, 0.5058949574709146, 0.665487222555222, 0.49521585700237947, 0.5975257012908464, 0.6547116232800823, 0.27520006443983136, 0.19945077343539352, 0.4483598967890047, 0.6170090522270193, 0.3629452265543237, 0.40101866684204746, 0.2214154156641417, 0.4658273689689775, 0.6279087481578258, 0.2801589967988156, 0.6154894617180341, 0.4317774253424008, 0.5032902535879054, 0.3857043162970235, 0.3235752737118369, 0.7145163104697898, 0.7003246175857492, 0.5926144097452135, 0.36455609200020656, 0.17237411045288498, 0.3453868601193689, 0.2510777254065122, 0.27329422034479767, 0.30575166619267713, 0.1969002775244295, 0.3626832039185818, 0.1926364162373576, 0.4815256234527475, 0.4820547520636099, 0.4517735424806245, 0.442563971371962, 0.48605747427054347, 0.5081933264061446, 0.40460958219168297, 0.48124685651119137, 0.3845875062887397, 0.8490564362839149, 0.8631581833962718, 0.8648875993504191, 0.8365953930762141, 0.8146830813970638, 0.8406512373584941, 0.760556608684047, 0.8328380172092464, 0.8342093344203565, 0.19122206159314048, 0.14300952096156272, 0.1266367521541144, 0.5648203079621614, 0.15433510927245098, 0.1706139302369103, 0.1245632623088393, 0.1588433108843068, 0.1485714395627179, 0.17448345251510056, 0.15651860150691155, 0.14494159296197118, 0.1979198303486428, 0.1693173541789612, 0.19023189089045967, 0.1442340504332582, 0.1568393217891233, 0.17128227711562616, 0.32893476581740866, 0.3304556960805596, 0.31757818603353294, 0.5245112441225199, 0.5216198594220312, 0.5038917729964573, 0.30449778658005755, 0.5421010271771822, 0.562479896719069, 0.2519524819270975, 0.24947785468791628, 0.3785589998365956, 0.4311780078648807, 0.23599893147151985, 0.33285313424392815, 0.4459424736254861, 0.20053888771203876, 0.36414800743344267, 0.21393611128303736, 0.2085475688620546, 0.20122733906079104, 0.19747121732996187, 0.2002103114897158, 0.2246124501979223, 0.22893218139728788, 0.21770117864769822, 0.23541120962881978, 0.21301904260477833, 0.24243182178223965, 0.2196846879522324, 0.2451893547320354, 0.19140329316447846, 0.7718169092768146, 0.24223106409684592, 0.2467817383134594, 0.22249420092909833, 0.18703404536145207, 0.9343917889719221, 0.18886284194062386, 0.9374379020308188, 0.9278653809611594, 0.19873574531767935, 0.17007062455340716, 0.1592807461954806, 0.919699178044643, 0.9280743640197706, 0.8778243134485311, 0.21200715553622718, 0.1527113186329303, 0.20400446365341074, 0.16834541552987758, 0.800405729105073, 0.10445937059118138, 0.16981909816544827, 0.18271963020987114, 0.17504174726862542, 0.1896149187284245, 0.17448144489107487, 0.1863596209516698, 0.17367811798326926, 0.19692617128146228, 0.18270385684611323, 0.17429796096666816, 0.09494548936725788, 0.10474402240479508, 0.08865996426337042, 0.09404017108478435, 0.09340248826423636, 0.09353373878182425, 0.1117750000300839, 0.09017549032930983, 0.08829608821112667]}, "mutation_prompt": null}
{"id": "a5ea49af-43e5-4c20-8248-4974efd14714", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = 0.5 + 0.7 * np.mean(np.std(self.population, axis=0))  # Dynamic f_scale based on diversity\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.4 * (1 - diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce dynamic adaptation of mutation factor based on population diversity to improve convergence.", "configspace": "", "generation": 27, "fitness": 0.4045639311124705, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9337851137007027, 0.9423944097319236, 0.9460200676683033, 0.9461779692558985, 0.943875410900926, 0.9442609830816183, 0.9421915958754544, 0.9399943153547894, 0.951361371454558, 0.853692756774647, 0.8690066065196975, 0.8769009663470798, 0.8530161797922815, 0.8653545644604264, 0.8823355696636109, 0.8598469481012139, 0.8686593013457242, 0.8642258093287699, 0.13263377823688094, 0.14556500375566572, 0.13740594583846721, 0.13498809185548222, 0.1312171447292041, 0.13338347686033591, 0.13806766809909765, 0.13049395334426028, 0.17602091411363474, 0.13454817499389482, 0.12228687600890376, 0.11829603854741177, 0.11424323736534203, 0.12722926451703365, 0.10477526574578788, 0.055588138181293156, 0.13017548091114328, 0.11554807813104695, 0.9852260780504787, 0.9813310964139345, 0.9654082210379012, 0.9750946169673324, 0.9827979402090007, 0.9778631994654929, 0.932520525493302, 0.9853304623730313, 0.9490994936188548, 0.8138223790864654, 0.765537046211742, 0.7255261655973448, 0.7920577616948834, 0.7026829970693138, 0.559157816021502, 0.634202137267919, 0.6599715547597694, 0.7889850148817932, 0.24443977740000578, 0.14184642531600478, 0.24040630460929302, 0.3891949281006202, 0.17393032525249197, 0.957881918761163, 0.9542788988137604, 0.23764356102924789, 0.9521756707381305, 0.2802277366817697, 0.2552275950719155, 0.2297173027610493, 0.21796052017302248, 0.2441757853770884, 0.4256685388224012, 0.4746321103869907, 0.24696648353609552, 0.3597511943592624, 0.7427115488700465, 0.7368039299848778, 0.312459684431164, 0.3069332711475944, 0.21251392194369567, 0.4310234443605364, 0.4205451969819666, 0.7997106797571306, 0.3642215030047229, 0.18471006819538882, 0.11111134969697722, 0.23475298924745291, 0.36241187476308356, 0.026695851019569283, 0.17670037732034338, 0.11582075978240514, 0.1486473145440126, 0.48691827341019, 0.14528767720283764, 0.368261788587686, 0.21952467509017837, 0.19680913507520248, 0.5772382256264781, 0.15618475740074445, 0.09994002007185276, 0.5559298876757479, 0.4321538554054608, 0.07699885934940687, 0.2704192586315357, 0.21491287520642477, 0.3930188089927843, 0.21797069695143745, 0.1802599883322309, 0.2881567912456853, 0.19181315740656268, 0.13189160431712366, 0.3649822989436562, 0.41675858191892967, 0.4509818371602198, 0.7360788245891223, 0.44617925773097955, 0.5245107876562105, 0.3790466313418146, 0.44556910504851144, 0.3284214211013802, 0.8925615015216044, 0.7829990261205895, 0.6291728744049373, 0.7726329048568576, 0.7040718363470764, 0.6398617538588887, 0.8396212239551394, 0.6379134862238263, 0.729014389214266, 0.13966047093548628, 0.10597569505437254, 0.11455193102604333, 0.15783418801480853, 0.13918814643908572, 0.10699610538196225, 0.2309773168458492, 0.13036515474448318, 0.11231753111724518, 0.13383187446097378, 0.1750554218827408, 0.14003285035027457, 0.1617158500621967, 0.15664178719516364, 0.16212866307507268, 0.2205412476672084, 0.17172496683026384, 0.16173712994858813, 0.4283736270245966, 0.6524788438668755, 0.6237033706958609, 0.5732652834907686, 0.6159263853099952, 0.712719162557315, 0.2950079113180232, 0.706438417832765, 0.6508092410144621, 0.3228364956069949, 0.2811737816548794, 0.30393017636600583, 0.5485022584843955, 0.5383199953609057, 0.5319804391891445, 0.5470776158554985, 0.22994488103520572, 0.5180218300608901, 0.21014495414538437, 0.218428423167924, 0.22580511971646056, 0.20365410864755784, 0.19537377041251558, 0.24106504514183402, 0.21750212366518207, 0.2188668753112153, 0.2120834651592407, 0.23722969606802546, 0.24153543024869184, 0.20534708341283847, 0.21437484350970848, 0.20567426909757125, 0.21671644851979655, 0.20336197358325192, 0.21379201792197122, 0.21225550017092532, 0.18557994829805524, 0.15193817084979888, 0.18806391827095126, 0.19759979354098967, 0.9188256155537651, 0.8639025964331952, 0.27974798302495374, 0.15922998603127603, 0.9319408882418242, 0.8139213148798972, 0.7725196529797618, 0.21292727262387845, 0.2085466835994274, 0.20238356851456374, 0.21179062351958022, 0.21186608738187773, 0.21362206288280838, 0.1042773640812491, 0.1723188246256152, 0.19037926250750048, 0.19067833199984907, 0.18380732972340164, 0.1849361965181574, 0.1793395150138447, 0.18083523778272714, 0.18895851876517777, 0.1823616810796418, 0.08891928797227122, 0.09005038199911108, 0.09616320285563451, 0.08731477488929085, 0.09779622057533377, 0.09489824722112461, 0.07845306431350985, 0.09510563183079934, 0.09966478722884808]}, "mutation_prompt": null}
{"id": "15f0c31c-f7b4-4fc9-ad43-8d6d73fad93f", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale_base = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            convergence = np.min(self.fitness) / np.mean(self.fitness)  # Population convergence indicator\n            f_scale = f_scale_base * (1 - convergence)  # Adaptive mutation scaling\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce adaptive mutation scaling based on population convergence to improve exploration-exploitation balance.", "configspace": "", "generation": 28, "fitness": 0.3103976142378906, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.949566650745653, 0.9522484073759107, 0.8140412443466251, 0.9065052652382606, 0.8835369119153025, 0.9285137314578857, 0.9421719385918886, 0.9363647131908541, 0.8765957690075636, 0.48504945152767276, 0.5958314978123344, 0.20310525318236683, 0.2904217275056401, 0.5017895866985792, 0.2989491630704444, 0.522525849611506, 0.27390284826878264, 0.6049412144793338, 0.21895562518591016, 0.09612110650536887, 0.14679769948796273, 0.12054478083734155, 0.19612219503156914, 0.2040826320469593, 0.0926554023177234, 0.16239497299110517, 0.21313166752611645, 0.1440440112728626, 0.13915458862975816, 0.0965024120096295, 0.11232909034266048, 0.12903418202359718, 0.11327566044521664, 0.12353114479822924, 0.15663999832330677, 0.1263475915895278, 0.972078436137065, 0.9451425022620412, 0.9689951207703776, 0.9619506868070997, 0.4558004118869794, 0.9575437436053184, 0.5389356954269939, 0.984573147896345, 0.9793306483012206, 0.21804316825934333, 0.18138754561141646, 0.3978149807543556, 0.5906062788937942, 0.3815962104283721, 0.3125335006178611, 0.37608033248337036, 0.654085633587147, 0.45051625160507625, 0.3922025205805748, 0.21560409438115857, 0.17235226357121503, 0.3118201978504733, 0.28141457470181963, 0.9635992894421693, 0.9674731283665012, 0.22777235523075923, 0.23866045161150873, 0.22353953396598758, 0.19573614983678156, 0.1996673832832453, 0.4276467837343886, 0.19868357128949787, 0.2351517642600366, 0.21428848569465175, 0.4057996257593405, 0.13666006337127368, 0.19873332869356586, 0.20703184966772392, 0.1352516469206526, 0.3486684696161677, 0.1587245292099818, 0.31371374859783496, 0.23816207614979834, 0.23947256452272558, 0.1759888083772725, 0.008322786878892319, 0.09132805572247549, 0.011780157505691613, 0.13912341162211128, 0.04654633213663384, 0.003753129991923898, 0.04939868614438603, 0.0029865760267379082, 0.19067010241885307, 0.10218055087020816, 0.11848850571855618, 0.06186750496117821, 0.14801881616153956, 0.17072077606524239, 0.09608777642735022, 0.30692003841475823, 0.20260820496137588, 0.125672331807135, 0.11343013865767315, 0.10913587562194205, 0.18372633995933907, 0.08676702111355694, 0.10492948492841858, 0.15652337484429213, 0.3227154936194906, 0.25841081824014345, 0.1563761368171599, 0.14101860731597482, 0.15638244571651416, 0.2443483498764134, 0.33395595029820246, 0.21795729311360024, 0.07145294949976178, 0.194877422613426, 0.17764893051203234, 0.16681317614636137, 0.6680454443061654, 0.6179552774154184, 0.6129882429633583, 0.5807370521137707, 0.6204190213133445, 0.6326459135127913, 0.6757027456659943, 0.6188758410285897, 0.6754000094568633, 0.14295230381754065, 0.10736173221740941, 0.13655605766975532, 0.13456175001957527, 0.1389458757666594, 0.14906763471950324, 0.16340576715809552, 0.13846207151811218, 0.15076384200793036, 0.16602868361670675, 0.19361998958723337, 0.1595108524346026, 0.16756659775179328, 0.1449141717589384, 0.3350801209642563, 0.14686859085086434, 0.14769337852960107, 0.5043371170557654, 0.4792543465721961, 0.3309610891688092, 0.4680029506393837, 0.3501156192860432, 0.3637736405457075, 0.6211763386837135, 0.29234730953756616, 0.5749283780312984, 0.48342572996804745, 0.46703426637428447, 0.3076334314803847, 0.3289820646785413, 0.2607089713826565, 0.2573414458186125, 0.25088450329947487, 0.5414875277542865, 0.32394545289654075, 0.28984736816030754, 0.2299385258630926, 0.24175697416529884, 0.23538984731533463, 0.22819379937517437, 0.23423631370907538, 0.23233938892564887, 0.19782757396029005, 0.2374474303247368, 0.29764477028667446, 0.3216810564616296, 0.2087507520121913, 0.20920513194822687, 0.24657394691649392, 0.2464178369006047, 0.23917692658489087, 0.17207621931079553, 0.25147291228189006, 0.20136841343239498, 0.1884230934776998, 0.18614158401801995, 0.18769212279289416, 0.20064322417237934, 0.8952298834414347, 0.821762657035632, 0.43533984155518035, 0.2673662680485178, 0.1644821749604486, 0.7376251083495741, 0.12809930911068657, 0.07329286429401838, 0.1530309757791929, 0.2097061267234952, 0.16799677199742824, 0.2132698553436284, 0.21266384843757424, 0.16744690214517377, 0.2061382540963178, 0.176794867471621, 0.18765323456968586, 0.16397007402195318, 0.1694046270891647, 0.1803520932101026, 0.1880323472791805, 0.18177099536338526, 0.19317242475871554, 0.09465350420703122, 0.0933784794481366, 0.08840015608996854, 0.09094688420191488, 0.09392031061606376, 0.09861192146091813, 0.11275314781868584, 0.09224623873948745, 0.08815507184403881]}, "mutation_prompt": null}
{"id": "1ec4fb96-ecf9-40f4-8036-c812a8989327", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.6, 1.2)  # Adjusted lower bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Fine-tune exploration by adjusting the scaling factor's lower bound for improved search efficiency.", "configspace": "", "generation": 29, "fitness": 0.4490425766342665, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9277265592296138, 0.9336332801008449, 0.9356211725804358, 0.9270583973746054, 0.9183845524020239, 0.9319316299307824, 0.9233618501049767, 0.9227815175553564, 0.9398115950419262, 0.7546136611170514, 0.762734262269259, 0.7754420417865857, 0.7641919339881462, 0.7152841520253608, 0.7555879383357519, 0.7724775137989512, 0.7842455462988456, 0.824335600830526, 0.14633378850829248, 0.13162786823915162, 0.1591676842339823, 0.13229346916298967, 0.13802534289000745, 0.13689384847087016, 0.13592993348131388, 0.14265046482321575, 0.13411305136279683, 0.12712961455853022, 0.12886849186904037, 0.12851095367192666, 0.12666965839718392, 0.11538688786319329, 0.10029894114418714, 0.13814836017818866, 0.09595782147596998, 0.11544743808249824, 0.9562726021797879, 0.9776861460834957, 0.9705194015269211, 0.9799827637361375, 0.9679233702312905, 0.9265736883515836, 0.955499344680811, 0.9724177256959841, 0.9701226392916125, 0.6970912440000654, 0.7260890859223741, 0.6871348419634853, 0.6601095055826658, 0.7554235420775292, 0.70571038827531, 0.6497085662108409, 0.6672297938588959, 0.7420257337124997, 0.21034274381456342, 0.19605431355208425, 0.23147877561634855, 0.9537810457593175, 0.9235791456769342, 0.2820093037162684, 0.36066156055376086, 0.2367364953073684, 0.8489819945180657, 0.5943234110746559, 0.5635303378810115, 0.6874401282766883, 0.6077995699620787, 0.5052316481318616, 0.13555587792302382, 0.5417412079451618, 0.6393036196294952, 0.4756953917111433, 0.5066913698551045, 0.584434916083602, 0.7632195540100054, 0.782249174530928, 0.6345754557897165, 0.6271417421325394, 0.8006669166685649, 0.7497492555982361, 0.613115754004704, 0.5055309561859314, 0.5470491727856116, 0.3047563181523556, 0.40356023221607384, 0.24128939999986276, 0.6021609265744445, 0.28992070164744355, 0.5458418373598435, 0.2925116794995838, 0.46272052727237567, 0.6989163649287813, 0.4904685078201223, 0.4576750501339516, 0.49839142138551995, 0.36036255226676317, 0.6522363604791368, 0.6776077673870428, 0.6502965818473334, 0.30878150967791573, 0.31757504106534185, 0.24696664845069982, 0.26949116097525216, 0.43531511523185296, 0.27332240219605775, 0.27704602557443936, 0.33415982631501706, 0.21944825687643332, 0.45214661263246625, 0.4277829389229941, 0.458831783620713, 0.3955882824967487, 0.43300623196809906, 0.40347228208900887, 0.425396228162951, 0.44586925158471613, 0.39926236241231683, 0.8397904042699303, 0.8490460231187127, 0.8618955848998536, 0.794422739950672, 0.8212127106527605, 0.8517846584216642, 0.8050874314610434, 0.8512560909788578, 0.8228029348245599, 0.09545821317220182, 0.15590261871455136, 0.1170114847439403, 0.1375889803938275, 0.15501157929728437, 0.15633989109838675, 0.1405440302082861, 0.36978101835418054, 0.12156262089894665, 0.201099520583079, 0.1430484028686354, 0.15288148206430452, 0.15594681146785372, 0.13890811947776305, 0.18146025307153035, 0.16316631415859195, 0.1629755505428293, 0.17833718761399364, 0.518165113468857, 0.4864738021338155, 0.3174798868136738, 0.49684555199594593, 0.46247676185831255, 0.5281124640982524, 0.534918505483035, 0.5461659322031469, 0.5400688960437348, 0.3161340015070093, 0.3138956792649843, 0.4402626726552893, 0.4123669209746442, 0.4512187613205296, 0.2707124129781836, 0.3996349122364693, 0.18917970949596508, 0.28548173517309183, 0.25201091789935104, 0.21251799364214152, 0.24342995452473593, 0.1924272238792868, 0.23084483590858995, 0.221167277608865, 0.25124117729830897, 0.22097354639332178, 0.2122360368754349, 0.6429649657420087, 0.20950175736698673, 0.2166588197992133, 0.20117721236384545, 0.24196561630594204, 0.21595850541571093, 0.220856037317277, 0.20668459792242744, 0.1984869505088609, 0.9541748315641595, 0.18889993972956176, 0.16907750507978903, 0.1672167179854941, 0.9438397630346895, 0.19739126266032958, 0.927918028883806, 0.816454693399315, 0.168626311164365, 0.7547482508663139, 0.9390153340100567, 0.1679865223961322, 0.7773424285628467, 0.6715096770240079, 0.8891235041179348, 0.21106870226772856, 0.21264887033098523, 0.16898518302904197, 0.188255494981322, 0.20296571185305168, 0.18701338406203616, 0.19822719308239167, 0.17617988433106835, 0.1883232374817836, 0.18260940712091966, 0.17528328144143102, 0.18367549882309153, 0.08136167579945741, 0.09418622944934874, 0.09761948320335889, 0.082079241048436, 0.09137899549537454, 0.09215830415889392, 0.10600942823517356, 0.0865472994137283, 0.09722923864455046]}, "mutation_prompt": null}
{"id": "11034983-28fc-4f60-abdc-f86c297ee6e7", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + self.F * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance elitism by increasing influence of the best solution in mutation.", "configspace": "", "generation": 30, "fitness": 0.41484668967018584, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.8965348940799641, 0.9155749827207467, 0.8979135106681055, 0.912894814645103, 0.88742672631787, 0.8955046391053583, 0.8976051939421437, 0.8959866547312357, 0.9142804922484123, 0.6010679035284312, 0.6043829527290769, 0.6521253229089206, 0.5915641726303678, 0.6320359269062921, 0.6264901801913665, 0.5956233706323725, 0.5963794804218425, 0.6056101709515254, 0.13654111940964153, 0.16654762208020224, 0.228156677598518, 0.1510096747417896, 0.1371156973470945, 0.13394563687067418, 0.131211879980067, 0.1446522336937902, 0.17415039243668073, 0.13956261807817993, 0.13758212558328797, 0.1072473110577401, 0.1406881152992473, 0.15452727829684332, 0.13169266731868223, 0.08904683045073547, 0.12365701348511282, 0.11428206746290726, 0.9708683698176238, 0.9728019408172881, 0.9687003620410745, 0.9724407971748711, 0.9738662701440977, 0.9772002081525594, 0.9491516922115266, 0.979496876922002, 0.9868578682305711, 0.5947644763706921, 0.6107325503899523, 0.629227779301871, 0.6438004230061183, 0.5893051694102565, 0.5807225211324929, 0.6221527336604475, 0.5777408622590303, 0.6285452809321801, 0.14077404412359318, 0.40157488131629304, 0.9520524418459426, 0.9572648829353054, 0.281970532844687, 0.9335706797359795, 0.4062487738823295, 0.9520457381499519, 0.2374717425170122, 0.4751748109226148, 0.6089694313588487, 0.5293343307190886, 0.535222772657638, 0.48338464274584325, 0.5697681311311965, 0.5161530859438592, 0.5540634366029171, 0.5164699222695901, 0.5729286234900639, 0.6200670166141682, 0.5462273471923063, 0.5381175520887072, 0.5155762772399087, 0.4853640672402133, 0.5425849038847109, 0.5386192063737771, 0.1370110081292365, 0.2987617607257471, 0.39361492915452667, 0.25145588072914893, 0.4231548079090598, 0.32690988588981085, 0.4028044372075632, 0.3870158573380226, 0.44245755818151133, 0.30446367145081676, 0.4172883936985987, 0.49937964893847775, 0.43795800773880245, 0.40343453272521734, 0.5402611026818629, 0.17674278926429055, 0.485752301691445, 0.439662931139955, 0.47239216468150347, 0.31151590627226666, 0.25643603330297415, 0.22646440686005642, 0.21083394854236326, 0.2790581978078711, 0.2496284554107, 0.23961593242405577, 0.20485561244304906, 0.1118333427915228, 0.3049263222195736, 0.32030532462848327, 0.3591225118141934, 0.3384685539921617, 0.33444548263955354, 0.3412550902512861, 0.3352128489607499, 0.3336715482146363, 0.31899123850951727, 0.7012484417321265, 0.7346556844262376, 0.7138128417269489, 0.7117063450574095, 0.7379187977283277, 0.6988425927434863, 0.7578514445764284, 0.7113909542367551, 0.7166650458941, 0.15089603264568197, 0.1068370800002012, 0.1327615551716229, 0.15293833946755042, 0.17900369706835484, 0.17893754535992323, 0.17804328638220301, 0.16161081459948434, 0.12755797515941636, 0.14765955549596166, 0.20084700785142695, 0.16974288202185184, 0.1461591553204762, 0.16317541061716312, 0.14376514424716424, 0.1346461262253652, 0.17367433379355812, 0.16930201396536793, 0.44734755324460107, 0.33907305419445377, 0.47115230553296994, 0.4524477049403861, 0.4540492538620944, 0.4717862983174982, 0.45114014737780783, 0.47901423363866946, 0.4866395283792184, 0.3277213144979556, 0.29261426774154475, 0.4158702997705769, 0.25531334992290344, 0.2650889077316032, 0.39991152538856056, 0.3983614310161687, 0.3641328251106636, 0.3395305011383918, 0.216777968252851, 0.2175927329924765, 0.21594964074846945, 0.21643169988595878, 0.2417314346386502, 0.20285661442771363, 0.21126983467918603, 0.2038987354448062, 0.19708690378740423, 0.6305884240283122, 0.1955561784960339, 0.24826810073568883, 0.20952003055000246, 0.2030508050449331, 0.20824043667027925, 0.20210428003946657, 0.2393919044134737, 0.7253699873495302, 0.9029366312764164, 0.18650014468074116, 0.18878895882767632, 0.907954788697065, 0.9021153172085479, 0.14504721732201464, 0.8712440631935792, 0.9152997928557629, 0.16942631976022837, 0.7529242516929482, 0.924015446938451, 0.16562263862125892, 0.4900773941770703, 0.5414283362076939, 0.21222950901452464, 0.21142945402203206, 0.10472018243895742, 0.16759824230976827, 0.1948629433187653, 0.19062032855770394, 0.18135515786774836, 0.1868115193097909, 0.18519947345388488, 0.18882403464311093, 0.19191800247628166, 0.192329670076278, 0.18261747510445758, 0.09362327130346715, 0.09693384462637245, 0.09130988991053635, 0.09839072954636685, 0.09259843890900687, 0.08597577162438064, 0.09748674360079257, 0.09964322508484691, 0.08133920788357096]}, "mutation_prompt": null}
{"id": "867704cc-6435-4fe0-834d-2ab224905125", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.4, 1.1)  # Reduced lower bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce a dynamic scaling factor adjustment during mutation to maintain balance between exploration and exploitation.", "configspace": "", "generation": 31, "fitness": 0.4397133638927559, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9317426233026884, 0.9343972237339873, 0.9433647631753637, 0.940245033781054, 0.9335950307554096, 0.9358574937791466, 0.9358416968237256, 0.9218717327723474, 0.9526123074090348, 0.838515579922086, 0.824575597579785, 0.8275309138143181, 0.7949939431127557, 0.8086791505808603, 0.8227943157018515, 0.8410385374031047, 0.8126648872394847, 0.8286463746491057, 0.14766464827181502, 0.1421894492114748, 0.14194670724125968, 0.15296455173620738, 0.14661376827389827, 0.14372907990484296, 0.14085266144684827, 0.26910132153585065, 0.18233730843215845, 0.12528475118617044, 0.13324716558746874, 0.13297473904467683, 0.12905024880963067, 0.13262759597552487, 0.12542670055757354, 0.11720493754011263, 0.11726863976763524, 0.09693613684515423, 0.9660408347859273, 0.972974889401843, 0.9613924032603623, 0.9773855343547525, 0.9881571920068449, 0.9852311471946185, 0.971424051015422, 0.9773647860705387, 0.9866792022373481, 0.75939082442144, 0.5836593487796495, 0.5884221839054353, 0.7245033958349203, 0.7367997832351156, 0.7349552876552847, 0.7551764684647523, 0.7423627388917817, 0.7038406062307698, 0.22938746184132497, 0.17057820663191525, 0.23091886593221622, 0.9433187309387493, 0.3861637310065892, 0.3900682347368931, 0.4099960546813871, 0.2426290546634967, 0.23817950408874866, 0.8392383853240906, 0.48100916331179155, 0.5334833796268711, 0.636143376994763, 0.8218184770971283, 0.5619950369815696, 0.7866532359248106, 0.41312362952452963, 0.5503960224543389, 0.6709695170365226, 0.6167391352459778, 0.6400051960148897, 0.6930378540898506, 0.7141842909086041, 0.7094277288170266, 0.7798902077564037, 0.6094941600864843, 0.6638925955820154, 0.39184561790227124, 0.2768435558046973, 0.5825417898968347, 0.5589112712308623, 0.4865358426945984, 0.5048020134615265, 0.5212473491318969, 0.5070124267189031, 0.5890453117997223, 0.180307494992898, 0.33542143807575264, 0.5074778912525935, 0.2959761674069744, 0.1802253055906181, 0.1798257865538293, 0.5450671515972021, 0.7308509251903719, 0.2339357170283095, 0.46556610070836946, 0.17309654924038476, 0.1615657401500452, 0.22167212952410165, 0.3482044696390286, 0.45398626106992046, 0.3758221472707408, 0.22772638330796424, 0.25192043563126165, 0.5438517897628725, 0.4054946715577131, 0.3101710820003898, 0.5842807160326954, 0.4506679817547835, 0.509151931564451, 0.4125206849608747, 0.5055692302575951, 0.35066096766783306, 0.8668897337650251, 0.7792997283892316, 0.805925016298141, 0.8225373418938133, 0.7675859968990077, 0.8312262202722246, 0.7747637081793457, 0.8773880770946589, 0.8425905060043862, 0.15518880601645502, 0.16096050226920866, 0.13864349815897126, 0.1625774674788043, 0.1449744469822224, 0.13917121885211492, 0.13999778380591255, 0.12271706867580578, 0.15789635816610847, 0.17986362208428164, 0.16587092942371529, 0.5173814346328636, 0.1767274536518546, 0.17390454008215783, 0.16775897519752847, 0.17660336151588796, 0.16814436010251788, 0.1751290672640744, 0.39265009231474046, 0.5160253965537902, 0.5531567045617019, 0.36266703079146545, 0.33058740584233615, 0.5432889028187078, 0.5591232967619404, 0.5288622918810805, 0.506482997343239, 0.5360275717332306, 0.16244606317408072, 0.48057613660519904, 0.30066982162928557, 0.2674587237231443, 0.338033282941435, 0.43966478442990775, 0.29594734820718327, 0.391375908906752, 0.2195466209875011, 0.23205917447619928, 0.22763230814801338, 0.2073525229103116, 0.23088628809909806, 0.22423887193561798, 0.21758234312986424, 0.23320296044721023, 0.2029351188096873, 0.2365106313569043, 0.2162873197238967, 0.26420447609923314, 0.777618868736854, 0.19233376720742323, 0.19403108184111628, 0.2401975148462281, 0.20017632461208856, 0.24188111761936792, 0.1879202260545576, 0.20722509606243877, 0.16858891443576451, 0.1683276437314265, 0.40586487179905795, 0.8856138544978008, 0.170723805191626, 0.8196891769194236, 0.2103371519038747, 0.8367673928899584, 0.8231604435952156, 0.2117636845712516, 0.2097139995447025, 0.21252593398895936, 0.16841041840609383, 0.8537655319526463, 0.21283340882920054, 0.16738547681037452, 0.18801303983162054, 0.18173817952523352, 0.17873999352601755, 0.1872665035509371, 0.17497295196815998, 0.18848365278721457, 0.18628295130555395, 0.18477995632227762, 0.1832510957488399, 0.08464364555399784, 0.09607598476773727, 0.09869768586554983, 0.09679751243629275, 0.1393529000292132, 0.08631531819604521, 0.12716386578727612, 0.089671044172837, 0.0850931335328482]}, "mutation_prompt": null}
{"id": "407642f2-39fd-4d4d-8832-99c1850e2e89", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.4, 1.1)  # Adjusted dynamic scaling factor range for better exploitation\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Adjust the dynamic scaling factor in mutation to enhance exploitative capacity.", "configspace": "", "generation": 32, "fitness": 0.4397133638927559, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9317426233026884, 0.9343972237339873, 0.9433647631753637, 0.940245033781054, 0.9335950307554096, 0.9358574937791466, 0.9358416968237256, 0.9218717327723474, 0.9526123074090348, 0.838515579922086, 0.824575597579785, 0.8275309138143181, 0.7949939431127557, 0.8086791505808603, 0.8227943157018515, 0.8410385374031047, 0.8126648872394847, 0.8286463746491057, 0.14766464827181502, 0.1421894492114748, 0.14194670724125968, 0.15296455173620738, 0.14661376827389827, 0.14372907990484296, 0.14085266144684827, 0.26910132153585065, 0.18233730843215845, 0.12528475118617044, 0.13324716558746874, 0.13297473904467683, 0.12905024880963067, 0.13262759597552487, 0.12542670055757354, 0.11720493754011263, 0.11726863976763524, 0.09693613684515423, 0.9660408347859273, 0.972974889401843, 0.9613924032603623, 0.9773855343547525, 0.9881571920068449, 0.9852311471946185, 0.971424051015422, 0.9773647860705387, 0.9866792022373481, 0.75939082442144, 0.5836593487796495, 0.5884221839054353, 0.7245033958349203, 0.7367997832351156, 0.7349552876552847, 0.7551764684647523, 0.7423627388917817, 0.7038406062307698, 0.22938746184132497, 0.17057820663191525, 0.23091886593221622, 0.9433187309387493, 0.3861637310065892, 0.3900682347368931, 0.4099960546813871, 0.2426290546634967, 0.23817950408874866, 0.8392383853240906, 0.48100916331179155, 0.5334833796268711, 0.636143376994763, 0.8218184770971283, 0.5619950369815696, 0.7866532359248106, 0.41312362952452963, 0.5503960224543389, 0.6709695170365226, 0.6167391352459778, 0.6400051960148897, 0.6930378540898506, 0.7141842909086041, 0.7094277288170266, 0.7798902077564037, 0.6094941600864843, 0.6638925955820154, 0.39184561790227124, 0.2768435558046973, 0.5825417898968347, 0.5589112712308623, 0.4865358426945984, 0.5048020134615265, 0.5212473491318969, 0.5070124267189031, 0.5890453117997223, 0.180307494992898, 0.33542143807575264, 0.5074778912525935, 0.2959761674069744, 0.1802253055906181, 0.1798257865538293, 0.5450671515972021, 0.7308509251903719, 0.2339357170283095, 0.46556610070836946, 0.17309654924038476, 0.1615657401500452, 0.22167212952410165, 0.3482044696390286, 0.45398626106992046, 0.3758221472707408, 0.22772638330796424, 0.25192043563126165, 0.5438517897628725, 0.4054946715577131, 0.3101710820003898, 0.5842807160326954, 0.4506679817547835, 0.509151931564451, 0.4125206849608747, 0.5055692302575951, 0.35066096766783306, 0.8668897337650251, 0.7792997283892316, 0.805925016298141, 0.8225373418938133, 0.7675859968990077, 0.8312262202722246, 0.7747637081793457, 0.8773880770946589, 0.8425905060043862, 0.15518880601645502, 0.16096050226920866, 0.13864349815897126, 0.1625774674788043, 0.1449744469822224, 0.13917121885211492, 0.13999778380591255, 0.12271706867580578, 0.15789635816610847, 0.17986362208428164, 0.16587092942371529, 0.5173814346328636, 0.1767274536518546, 0.17390454008215783, 0.16775897519752847, 0.17660336151588796, 0.16814436010251788, 0.1751290672640744, 0.39265009231474046, 0.5160253965537902, 0.5531567045617019, 0.36266703079146545, 0.33058740584233615, 0.5432889028187078, 0.5591232967619404, 0.5288622918810805, 0.506482997343239, 0.5360275717332306, 0.16244606317408072, 0.48057613660519904, 0.30066982162928557, 0.2674587237231443, 0.338033282941435, 0.43966478442990775, 0.29594734820718327, 0.391375908906752, 0.2195466209875011, 0.23205917447619928, 0.22763230814801338, 0.2073525229103116, 0.23088628809909806, 0.22423887193561798, 0.21758234312986424, 0.23320296044721023, 0.2029351188096873, 0.2365106313569043, 0.2162873197238967, 0.26420447609923314, 0.777618868736854, 0.19233376720742323, 0.19403108184111628, 0.2401975148462281, 0.20017632461208856, 0.24188111761936792, 0.1879202260545576, 0.20722509606243877, 0.16858891443576451, 0.1683276437314265, 0.40586487179905795, 0.8856138544978008, 0.170723805191626, 0.8196891769194236, 0.2103371519038747, 0.8367673928899584, 0.8231604435952156, 0.2117636845712516, 0.2097139995447025, 0.21252593398895936, 0.16841041840609383, 0.8537655319526463, 0.21283340882920054, 0.16738547681037452, 0.18801303983162054, 0.18173817952523352, 0.17873999352601755, 0.1872665035509371, 0.17497295196815998, 0.18848365278721457, 0.18628295130555395, 0.18477995632227762, 0.1832510957488399, 0.08464364555399784, 0.09607598476773727, 0.09869768586554983, 0.09679751243629275, 0.1393529000292132, 0.08631531819604521, 0.12716386578727612, 0.089671044172837, 0.0850931335328482]}, "mutation_prompt": null}
{"id": "1d07eafe-a447-428d-8b54-76f2788f2488", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + np.random.uniform(0.5, 1.2) * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by dynamically varying mutation strategies and crossover rates with increased stochasticity.", "configspace": "", "generation": 33, "fitness": 0.4316046077849614, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9172291580065302, 0.9212623778905807, 0.9337704058428242, 0.9303141764965877, 0.9347312935259124, 0.9247260513378598, 0.9036633286239072, 0.9342143479537304, 0.9390632939132304, 0.7708109121468856, 0.8075588276338505, 0.7683431809051864, 0.8253525167796042, 0.820077153510998, 0.7907437106061559, 0.7982954984422392, 0.782746060744892, 0.8038597323577533, 0.13103672644879039, 0.16197645911056502, 0.13254282356885194, 0.15399679843793124, 0.13510478026116524, 0.16117184717777489, 0.12386450397218907, 0.13207229627124073, 0.12870791843637053, 0.10575593861595312, 0.11441514260388808, 0.12048949116901664, 0.10087756410073556, 0.03999272094160211, 0.12651724083453064, 0.12732546748049622, 0.1222483235845031, 0.11976563427990172, 0.9578480195263526, 0.9817756155936529, 0.9673475567936831, 0.9744485456631404, 0.9743441183749791, 0.947780438111789, 0.9438644303893201, 0.9726782038062257, 0.9766116378550871, 0.7155844579150862, 0.6991304524379438, 0.7026743898377869, 0.6713446918013465, 0.7419229908138218, 0.766780187431453, 0.6522886624368189, 0.7546722154180208, 0.7610057379254493, 0.21530597192731038, 0.17187268060145322, 0.21733008934939146, 0.3917933825527038, 0.21365125283599318, 0.33624342602477075, 0.2045204906844974, 0.2353157976639676, 0.3696623139348696, 0.7396397618725992, 0.6631933668118923, 0.5860203963156043, 0.6032706740919992, 0.705923712538002, 0.7521788706741572, 0.673341235289604, 0.6124668550021428, 0.4564329570182193, 0.6225752436279518, 0.6144180558154838, 0.602048877060527, 0.6838331989210844, 0.6122820102306995, 0.7957191550157474, 0.5533954825243439, 0.13663560436347366, 0.7780387971135776, 0.2154066302488925, 0.6031329551280105, 0.3964503750588678, 0.507732019959318, 0.44287230377823106, 0.3783741036145719, 0.4244934457815346, 0.5639327179558895, 0.406449611237261, 0.23803781308466565, 0.7035955911090417, 0.3065173415135575, 0.6585270385002788, 0.1501605343934569, 0.325847817461535, 0.7253237476459844, 0.6433855619677135, 0.515982845597318, 0.14926723556514698, 0.42347384389127674, 0.4320450447608811, 0.6057859956621675, 0.528954182254553, 0.5419494510022818, 0.3215108633100384, 0.3898192455786781, 0.15062890859521427, 0.4329257993148037, 0.46342582775233754, 0.45968390662455727, 0.4560710027630137, 0.48031456225473446, 0.472569982734645, 0.46831088961155487, 0.43847116641917583, 0.4805245759490816, 0.8491154936488966, 0.8606497961521777, 0.8482270983247243, 0.7981002055863424, 0.681874978384624, 0.8393274520750365, 0.8563032865307596, 0.839534964992499, 0.8293130674047993, 0.12844028725958856, 0.2299864385914122, 0.12398056029602444, 0.13236852888235084, 0.12573349524891653, 0.18309604096007992, 0.12261241768148334, 0.10790196799931451, 0.15244510185856708, 0.1542264687328616, 0.1633799301211022, 0.18300465597097915, 0.1526273978540208, 0.4003963451230935, 0.18061477209918508, 0.16758933787606345, 0.14634173948844198, 0.15937845103522108, 0.5300412953968601, 0.4879984148739236, 0.5279626795125336, 0.5661715685040245, 0.5048778019524267, 0.5141758232372883, 0.6220882329153372, 0.514034557096007, 0.31205057728430374, 0.3007079288203347, 0.47640425649939677, 0.2965497429832722, 0.4182026005550378, 0.33682662474173797, 0.29598972608791674, 0.48038296704751293, 0.23942038712630298, 0.2424721438133326, 0.2079096538745383, 0.2278736447801819, 0.21701656745184172, 0.2744627477436967, 0.22529315690736462, 0.21619307805559806, 0.20826948018841462, 0.23337347360741467, 0.2390614593970205, 0.22633065987628964, 0.23255734228567926, 0.20480369404282428, 0.24524843897712612, 0.19792697622646171, 0.23367623270009297, 0.20961421462712215, 0.18714840601427263, 0.3080784620758077, 0.18770380482972693, 0.19976434588865521, 0.18742983060739848, 0.19464081322356908, 0.1985262270568926, 0.16430671001839003, 0.15417001923467688, 0.7657176035646459, 0.9499567649195554, 0.9164628391074987, 0.655130141175641, 0.167778424736864, 0.08252761585403934, 0.16808667468356475, 0.16898605231516195, 0.6469483462244996, 0.2109991782272208, 0.16937329011832158, 0.19160035335016978, 0.19698422799115256, 0.18530026496490126, 0.18802555822414613, 0.17644860141803131, 0.19340653982359335, 0.19051468376696967, 0.17809883103920743, 0.18413697512076077, 0.09098253044551641, 0.0855926227595839, 0.09245720677513614, 0.0878058624113417, 0.08727395046671116, 0.09104171591778121, 0.1028798449578604, 0.0906798769495687, 0.09130100183652046]}, "mutation_prompt": null}
{"id": "0cd444d0-ead5-424a-8206-f24dcf929ae9", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.6, 1.1)  # Modified upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.4 * (1 - diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant * (1 - (self.evals / self.budget)), self.population[i])  # Apply time-varying factor\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Further enhance exploration by incorporating a time-varying mutation factor and refining trial vector generation.", "configspace": "", "generation": 34, "fitness": 0.2454773717527225, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.713109129578033, 0.7479915800858965, 0.7131181791184211, 0.7181819568754673, 0.7386675454366698, 0.7541828608096084, 0.60203533580721, 0.7510224807763246, 0.7661588613576029, 0.2410304747052895, 0.20928555749907718, 0.1275613593460153, 0.29587292571415824, 9.999999999998899e-05, 0.17872852290210428, 0.20753612043988046, 0.08219503108252846, 0.15016523029228013, 0.15327071121065505, 0.11704587005128797, 0.12976663832812996, 0.13201933043569425, 0.13422575983652385, 0.13005362174730328, 0.17052555927465474, 0.1487207789274495, 0.1190591822389202, 0.10179632151272255, 0.10938362651710065, 0.10563832212902835, 0.08954650147425858, 0.10590563531058905, 0.10961770313902541, 0.12384131813649324, 0.11935664805043456, 0.09619583907640972, 0.6013045518527138, 0.241220720562336, 0.19470832699908625, 0.21063566950118495, 0.3789108640004156, 0.17383299848214773, 0.14225371182385826, 0.6675265967669126, 0.7075234189157313, 0.21080835399049358, 0.20997242263574967, 0.2111635406055702, 0.20759510090789635, 0.13123581704226095, 0.1407029938784763, 0.22883116537337356, 0.18480906470944047, 0.21176603649006343, 0.9430705408967408, 0.22942244872035533, 0.24820905115028558, 0.9554341840869622, 0.9076112887432259, 0.27396099733624135, 0.4098623589191409, 0.18119676915393979, 0.32479494610501736, 0.21466213158164593, 0.16848157076981496, 0.19871708169073976, 0.1764100598636953, 0.2734505674228652, 0.16382322773834257, 0.15016522574135693, 0.2179510212641803, 0.2690065041945324, 0.2037722022667131, 0.23473308463103504, 0.1678952361152466, 0.26440631743797427, 0.18066459059797746, 0.15357816434002614, 0.20327160357881713, 0.23841622170081056, 0.29040860930169043, 9.999999999998899e-05, 0.12502020968626004, 0.00022500113788648246, 0.061722899574705115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026353695000561506, 0.027426395783893942, 0.08168387415027079, 0.1614386289249523, 0.05904034857141793, 0.122467849549174, 0.06273025209358307, 0.057638961675689826, 0.17148263782870377, 0.2343413154618713, 0.15936369346115264, 0.22232124984786827, 0.20060863099393333, 0.17609448448073894, 0.10928442866621424, 0.11905752809674053, 0.16645453330910953, 0.15875988493436655, 0.13881196443899302, 0.19698674228428958, 0.1868508933709606, 0.17907753275463967, 0.2251530405544686, 0.16968914867846074, 0.0524125678687295, 0.1786528755029092, 0.15736211329742655, 0.1771348600402367, 0.22642688272201505, 0.5010184820356631, 0.5439406316283173, 0.5253927444411147, 0.5185873893384148, 0.5463120668813568, 0.5473959459805537, 0.5446990989034179, 0.5599231340848989, 0.5632746960589812, 0.11914524039510654, 0.16814814839327696, 0.14951884181529218, 0.12821627703897776, 0.11299172254338097, 0.11881191681962466, 0.15445844512866402, 0.1139011691089441, 0.18011703863355488, 0.16701663662771848, 0.1811888671614562, 0.17091195361185674, 0.14674731492798532, 0.18101350034718622, 0.14532276211922368, 0.18331241337670556, 0.15374310463871987, 0.17022993494669791, 0.27701594537028795, 0.1982120352847807, 0.3382879316251982, 0.27431559457551324, 0.42127855558802474, 0.35400744490619085, 0.4531256676315816, 0.25679153856712733, 0.3564586126321416, 0.274437317069138, 0.23472217306536647, 0.2865299470018675, 0.3348557342007571, 0.27046800065093957, 0.37053114653396346, 0.2095562165434368, 0.2543823682743821, 0.3381870609612364, 0.22404793099445264, 0.21660041258503127, 0.22999021575790546, 0.2346182706968004, 0.22565291838555646, 0.24496397776656553, 0.23101485142384814, 0.2073130228001906, 0.23253281799530778, 0.1949931792408124, 0.20146311555000918, 0.20251469757188734, 0.20027573188169567, 0.2027183413130602, 0.24561966481035402, 0.2139817282447053, 0.18773926460315649, 0.41016343511734676, 0.18653097866363866, 0.18652450233502493, 0.18803577100175717, 0.20006504352873167, 0.7847814502316288, 0.14748437745717025, 0.810218524388607, 0.308958256637651, 0.16949787816884143, 0.7419598442803657, 0.3862617614799704, 0.16823777724662647, 0.1690851136363437, 0.20740230243131963, 0.21054227990965835, 0.1689676811209343, 0.21211239549452499, 0.16955506096066542, 0.18948120904100618, 0.17980256584440724, 0.18551379280540703, 0.18541134275111304, 0.1845891129795295, 0.18860482330370887, 0.17620703440556607, 0.1828813166969132, 0.19691845894775395, 0.10119811197133344, 0.0883852925562324, 0.0906363372719996, 0.10028137488866073, 0.09865847001835049, 0.09597184266578573, 0.09426746058071289, 0.08798385385854002, 0.09182755096731599]}, "mutation_prompt": null}
{"id": "4e1b253d-935e-46bc-9e97-f34309dfd413", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                    # Adjust F based on improvement\n                    self.F = max(0.1, self.F * 0.9) \n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce adaptive mutation factor by reducing F dynamically based on fitness improvement.", "configspace": "", "generation": 35, "fitness": 0.4027846868571754, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9338373112883682, 0.9282751605117407, 0.9436977148508636, 0.940078205362027, 0.9431703880486976, 0.9362688970465843, 0.9445561097587332, 0.9391473132105131, 0.9449404921707562, 0.7879703678596477, 0.8235259200155749, 0.8172663736893704, 0.8202036076800557, 0.7752009576175484, 0.8240777988913947, 0.8084495029965123, 0.819642842297545, 0.8327862954675231, 0.12955602622541196, 0.6799123789714976, 0.6273242714356502, 0.49755071280170227, 0.5938165002486008, 0.4873067852181524, 0.5667805417625251, 0.5752264994115455, 0.5151307017081652, 0.12961456759259637, 0.1520197122516047, 0.15811195285035284, 0.1463817485996256, 0.1633979025111324, 0.12940044602146805, 0.16667499604249858, 0.14816299951248169, 0.1567431923659286, 0.9490798594007046, 0.9466770638942239, 0.9477537322801577, 0.9255719481280182, 0.9644576449552786, 0.9406493643964238, 0.9374533932294586, 0.9538233698746255, 0.9288759870084199, 0.5641180985901002, 0.7236254341174927, 0.5525177066798118, 0.6358979749323335, 0.6284018917380392, 0.7017485188923684, 0.7389187438590248, 0.6103217792974203, 0.6228026095166289, 0.8753656490156894, 0.14132963607473847, 0.23126148644899025, 0.28195320162521254, 0.28036674194647726, 0.363488650416374, 0.24822167460408895, 0.9600873227467094, 0.23871697030828443, 0.2369254010592765, 0.18797481757717227, 0.21344422971199206, 0.5069162480279812, 0.20049097597951937, 0.38942674917957465, 0.20887546195020645, 0.7690422800584912, 0.13552639789902732, 0.33749781328079054, 0.1909158885308747, 0.13724629788434883, 0.2502198186746679, 0.13632524794364964, 0.288779130247089, 0.5911661363667693, 0.27495713841935476, 0.5545444048827679, 0.0001536000488240319, 0.08929093810874966, 0.29381836940000283, 0.09884404851167106, 0.14557815891939296, 0.1412176312701966, 0.04222331180012351, 0.15349773183906634, 0.36978098284208993, 0.1741653313403574, 0.28624359159641155, 0.1319265655362558, 0.2672106168298646, 0.15201949031382778, 0.13479444975012733, 0.37556748440942445, 0.5969884192287545, 0.23120154710704788, 0.386612824398855, 0.24015635746422814, 0.10471549153021364, 0.12878287703163005, 0.377986263102857, 0.4338033081003041, 0.16158691781100964, 0.11277684604085536, 0.4462689926016661, 0.3855347946558749, 0.5041474032679684, 0.3804342803897791, 0.38363092493546924, 0.3720630877764337, 0.2784424931548761, 0.3601696016490259, 0.39888799027874433, 0.3449702778977036, 0.719228286804007, 0.6786801881484248, 0.6353294510834111, 0.6692609962683584, 0.7229285466198766, 0.6373663805195678, 0.7975177322617932, 0.626271309724321, 0.7221119044838246, 0.12783001329988142, 0.16052977870843899, 0.1404874282873385, 0.13447529308461548, 0.11877093214623458, 0.11870292817882977, 0.14377902701454426, 0.1872658271588964, 0.154627664713896, 0.18129429545605413, 0.17390897138564376, 0.18453563384131966, 0.16499881252890847, 0.18816135112993715, 0.14913108460980895, 0.1553715507224731, 0.16509029418483845, 0.19718113964587514, 0.3980741744132261, 0.3113620122226073, 0.5769874835154686, 0.6809201650402908, 0.3467542769526014, 0.3224196406085409, 0.3430648014704829, 0.6759057297466164, 0.41384679800091395, 0.34663689066585257, 0.4929348263407758, 0.3147510435465509, 0.2894536072044097, 0.42556736723890676, 0.36330712846866875, 0.24157834483951657, 0.25579085386922096, 0.39652003174599226, 0.20783602238992183, 0.2666407280405144, 0.21172638736070526, 0.21195274190778945, 0.21316863058758662, 0.22526130266858435, 0.22195565644002624, 0.23548832017253085, 0.2239631401570592, 0.24852878904567577, 0.625126182099228, 0.8023188456801914, 0.23566385014923608, 0.40593978398924524, 0.7597213910790626, 0.24500477838095724, 0.21578742287540176, 0.4999054045582627, 0.18786554461950444, 0.18732997964020037, 0.1885283827759796, 0.20075777166297204, 0.9318500784865833, 0.14780462557449225, 0.8990396824423923, 0.15820916501674964, 0.7813734788734109, 0.8395697311060903, 0.8798217984108169, 0.2125982311608352, 0.209052375436926, 0.26711804059482724, 0.2587859438685861, 0.21222648823410006, 0.6031367327175557, 0.1690515335623819, 0.18035484234439425, 0.18080158704428817, 0.20006302875158222, 0.1954650494275667, 0.17632712996031696, 0.17631136319458274, 0.17633301635719345, 0.17372895363715146, 0.19637146821077156, 0.08979851746540257, 0.1012392324851773, 0.09566290853897974, 0.12348204115760875, 0.11048759394320773, 0.10109318769345832, 0.11775647907118714, 0.09969536026265324, 0.09023855505149336]}, "mutation_prompt": null}
{"id": "48821bf1-2a80-4093-8dc2-59ffc6838534", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-6  # Reduced noise\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Optimize convergence by reducing covariance noise in covariance matrix adaptation.", "configspace": "", "generation": 36, "fitness": 0.4444710820861513, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9382051128965594, 0.9394896327962022, 0.9267492149974333, 0.9324160373734903, 0.9457519330575069, 0.9451419167706238, 0.9396739222179669, 0.941605639594675, 0.9544881467908303, 0.8008490708613338, 0.7890341425725547, 0.7767882091265342, 0.7940913398611686, 0.8088937245017225, 0.8414398206349046, 0.8184300529644524, 0.8158708735080539, 0.8280154167552518, 0.15202760778985047, 0.12353959624383914, 0.14098811901908426, 0.14656839622809514, 0.15277201062711554, 0.15181141200068982, 0.15020956715834366, 0.14315099167075573, 0.16535505971807563, 0.14892894927019462, 0.13981913105264832, 0.13010144230485676, 0.11533584385448792, 0.11613021392505507, 0.1163221088462858, 0.09562876360700501, 0.14116764702946216, 0.10608838395581643, 0.9356166796115275, 0.9669935495864999, 0.9769982253738916, 0.9406853012595479, 0.9651042758905397, 0.972969608097815, 0.962810767673398, 0.9580930186982207, 0.9725413244705562, 0.7025938898537197, 0.7664685151478738, 0.7263388913730012, 0.7757325762612697, 0.712808098084172, 0.7730978035683874, 0.7851365758742075, 0.68740699993879, 0.7727110711684728, 0.22809080779633373, 0.3331566331662138, 0.23184014122507135, 0.9162540395294969, 0.9472737500570176, 0.9175654930855998, 0.7719780957046539, 0.1820722359158402, 0.3866553767835096, 0.5743609192572605, 0.38763395946932955, 0.46458617763793675, 0.13505713717346335, 0.3302193645322331, 0.18837722465643658, 0.3303526688419457, 0.4492954911085826, 0.4574817994659248, 0.5045626803743756, 0.41453841102431843, 0.3645381897778588, 0.27138298511675985, 0.5665224719753569, 0.5330217368635296, 0.7141908014556777, 0.4494551879644889, 0.40966155656693204, 0.23561617857330397, 0.4788244387274586, 0.5365029533895631, 0.6232560258854144, 0.6669036931225469, 0.17501010518200422, 0.32592655262788084, 0.43418430404233, 0.6056158933967694, 0.11313129655554022, 0.7287546679933782, 0.26969811515808173, 0.23846682559089583, 0.16535017782959727, 0.19837234557498262, 0.5189368273633026, 0.7350757912281773, 0.3435544462412765, 0.3084341630627624, 0.20230157308968333, 0.39456790344198134, 0.5551016996317851, 0.4652569170405514, 0.46790058352126884, 0.5150239474330326, 0.2752827740453767, 0.344337569234485, 0.4799862405509955, 0.5315105827635187, 0.5325761001081294, 0.5914770228590736, 0.4992381634830062, 0.38300421682557995, 0.379623451992834, 0.46657481484289665, 0.4832810642973733, 0.8137485789825833, 0.8676323778090287, 0.8608476758107131, 0.8079838510043369, 0.8738278114094984, 0.8779280940804005, 0.8617801838270743, 0.8555601081122847, 0.841153762675804, 0.11610115848536229, 0.14824638065141027, 0.1739791903395146, 0.10649305762396866, 0.13225148131507447, 0.1247892065529349, 0.1271819710842056, 0.1397728960299437, 0.48988653393883563, 0.18483520280316024, 0.3440824845837659, 0.17484543694968702, 0.18408591246120687, 0.1772423980515747, 0.2043997837657755, 0.20487337746869372, 0.14996582487645393, 0.31704608342585083, 0.47705095534107655, 0.34374606540363895, 0.5278972235728787, 0.5751515121651436, 0.38859618543376395, 0.4155096637761818, 0.5251655305602025, 0.5915171735821991, 0.5766408784234323, 0.3144529197517648, 0.31953915529052546, 0.39333440948728526, 0.38321039622158193, 0.4731046992159721, 0.3285545736127087, 0.336399092247027, 0.21865164933535086, 0.3769334520338916, 0.21354313561196137, 0.20343360392713983, 0.22661103551423134, 0.22413037268370695, 0.21783403496219322, 0.2113678234811266, 0.23038279376000825, 0.22701723052555423, 0.21816196523083875, 0.8676301568146276, 0.23531869935230865, 0.22587178061918733, 0.2072731300139916, 0.24801941612193035, 0.25089677492258144, 0.2253125934699024, 0.24592973826260411, 0.20827159036526544, 0.18661057293579064, 0.951255527547904, 0.18815081270126843, 0.20042035405666414, 0.8666701951358945, 0.14813224296074645, 0.924553844689419, 0.7861087629432197, 0.9170220497351605, 0.9321232369534045, 0.7322073258894348, 0.2115789158458442, 0.1671977919524097, 0.20968903198858535, 0.21018585532440337, 0.7660517684559994, 0.20990115662197162, 0.1689914881499902, 0.20573962153086367, 0.18610011973620655, 0.1915454582382714, 0.19713191868066404, 0.17896549254258443, 0.1698349362364746, 0.19387456371897116, 0.17863656480465218, 0.18397131461554772, 0.082817546698427, 0.0953823454967796, 0.09366599798125885, 0.09524848326566993, 0.10063702585550505, 0.09339341706785176, 0.1217328117439076, 0.098564738532818, 0.09288681801339405]}, "mutation_prompt": null}
{"id": "35e40705-c2c0-4e93-b63d-d7c2545b55ad", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.0 + (self.evals / self.budget))  # Dynamic scaling factor adjustment\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce dynamic scaling factor adjustment for improved convergence.", "configspace": "", "generation": 37, "fitness": 0.44576748466848054, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9320434008614145, 0.9429527196359001, 0.938786060055007, 0.9350611011668779, 0.9295530902708614, 0.9309462452097093, 0.9242584329467594, 0.9212013052704328, 0.930564589379532, 0.802400145477105, 0.7808567615069975, 0.7643851683609031, 0.8036495126330604, 0.7630209975747315, 0.8135151579223361, 0.8041833996606742, 0.8195018646034816, 0.7687214317513453, 0.14631268292610233, 0.16090884293555974, 0.1679514727657554, 0.12704906597045773, 0.15738366151146088, 0.13036447295053044, 0.11565899045303063, 0.12203118425481008, 0.12444008828425324, 0.1420546800876591, 0.1333826037717898, 0.12916067785853613, 0.10634754529499169, 0.13640781990373163, 0.12387716871639665, 0.1331161582676017, 0.11976617940015988, 0.1137022463300329, 0.9638298557161047, 0.9585375406382503, 0.9716007823393611, 0.9521465104159513, 0.9882498363091584, 0.9625981977737064, 0.9456868841050615, 0.973547468551962, 0.9839298702751018, 0.7368472666678951, 0.7198653293419586, 0.7803469818777496, 0.6417072786947444, 0.7326463496698254, 0.6816783805696668, 0.7057188910160253, 0.7438395990025677, 0.6986942166718209, 0.9413028820305525, 0.17072195865041961, 0.3932772993691157, 0.9540554258862481, 0.24499369919479008, 0.4058699518165413, 0.23593818112079312, 0.3841256827161339, 0.3861569343825526, 0.4571377679774148, 0.44749015327591635, 0.49864939820916376, 0.672602589096484, 0.7591773178124376, 0.1360181487448031, 0.536163244608441, 0.1369129930443962, 0.13775388802067623, 0.6915647630802951, 0.5373871475156725, 0.5337321833758351, 0.7138712520406245, 0.5479471241768921, 0.5379131790646823, 0.5217536201844499, 0.5665978803864656, 0.49498675131739167, 0.2507706734964982, 0.473275243662, 0.19990513680072508, 0.5804589404240854, 0.34503901357259437, 0.38517564738369725, 0.33103723079988145, 0.6035229483544877, 0.3641521822436573, 0.391186590958408, 0.6621415296972464, 0.43583068162082883, 0.32830294745031785, 0.4014909954844996, 0.3534232388046783, 0.6809171317532343, 0.6503721023996456, 0.7529802102219036, 0.4623873959479179, 0.446710358053812, 0.4469873792393374, 0.28745870866014256, 0.2913014528305129, 0.3882563740358983, 0.11579329145269479, 0.2807423224254417, 0.2968111427505573, 0.4814528463026161, 0.44873507838937343, 0.4249901359705148, 0.44830582691296517, 0.48580853228475007, 0.4038974001184824, 0.42556803113191255, 0.4589018967146682, 0.40272697200938823, 0.8700231921823064, 0.8521684454469598, 0.8769097305739317, 0.7681951082002909, 0.8444535271303573, 0.79569367957749, 0.8709077215095627, 0.8428773231793183, 0.8555201454497716, 0.17165181180083022, 0.37517240727096746, 0.310367953954647, 0.16593934973127467, 0.16339526341245802, 0.14532969288290953, 0.148622856363541, 0.1458155622017986, 0.13063862316135832, 0.1708082613318309, 0.15854518396831385, 0.5519138310310061, 0.1480854010358602, 0.15079408723474552, 0.15544595161766772, 0.14852935687299873, 0.1658130012346163, 0.1489164711848947, 0.2829552588922457, 0.22832971974454264, 0.5261612860500187, 0.535336832138581, 0.5763895097352052, 0.5452044528381668, 0.5463262382780993, 0.5360937862797627, 0.5762668498922042, 0.45191828477714646, 0.24548352116944494, 0.31835062619820265, 0.23472128050559493, 0.47531470570807477, 0.3613837557587206, 0.42800608342222757, 0.45718536437857804, 0.4229195689023658, 0.23587792126740992, 0.2101421430715561, 0.21630158491066653, 0.2043281470581515, 0.18857532455890713, 0.2184078896073659, 0.21009858969184314, 0.1973584286814295, 0.2161040415672134, 0.20957984356366455, 0.20644094855457484, 0.21057768645192776, 0.22553528228835484, 0.19935229307297786, 0.5868043981587974, 0.24149592231742112, 0.22315306202251017, 0.23711990525723403, 0.18775488711143185, 0.15525494509092075, 0.9133831030865467, 0.20022804200031763, 0.9327330840663243, 0.13045283900131943, 0.9322210431775899, 0.6903131876885833, 0.16921213430958792, 0.7315113113304441, 0.9022833333770388, 0.2117084490170561, 0.2063063557627265, 0.16771155310593366, 0.8600981576757643, 0.8640638244966531, 0.8997786969356658, 0.1690340879899137, 0.18920344468595662, 0.17861301648614114, 0.18318592693880686, 0.18267362662248765, 0.20001277969125908, 0.20352164587457378, 0.1939844359039703, 0.197884013720515, 0.17912821939573986, 0.09687945439734036, 0.08937603764618907, 0.08886593136666765, 0.0857613556238177, 0.11778542904512401, 0.09051969069419352, 0.1168453414598627, 0.09139055867665269, 0.09005509556031943]}, "mutation_prompt": null}
{"id": "4b3f4ecc-68f2-43ae-887c-6d33ee38b587", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.6, 1.2)  # Increased lower bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce enhanced diversity by adjusting f_scale lower bound for more robust exploration.", "configspace": "", "generation": 38, "fitness": 0.4490425766342665, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9277265592296138, 0.9336332801008449, 0.9356211725804358, 0.9270583973746054, 0.9183845524020239, 0.9319316299307824, 0.9233618501049767, 0.9227815175553564, 0.9398115950419262, 0.7546136611170514, 0.762734262269259, 0.7754420417865857, 0.7641919339881462, 0.7152841520253608, 0.7555879383357519, 0.7724775137989512, 0.7842455462988456, 0.824335600830526, 0.14633378850829248, 0.13162786823915162, 0.1591676842339823, 0.13229346916298967, 0.13802534289000745, 0.13689384847087016, 0.13592993348131388, 0.14265046482321575, 0.13411305136279683, 0.12712961455853022, 0.12886849186904037, 0.12851095367192666, 0.12666965839718392, 0.11538688786319329, 0.10029894114418714, 0.13814836017818866, 0.09595782147596998, 0.11544743808249824, 0.9562726021797879, 0.9776861460834957, 0.9705194015269211, 0.9799827637361375, 0.9679233702312905, 0.9265736883515836, 0.955499344680811, 0.9724177256959841, 0.9701226392916125, 0.6970912440000654, 0.7260890859223741, 0.6871348419634853, 0.6601095055826658, 0.7554235420775292, 0.70571038827531, 0.6497085662108409, 0.6672297938588959, 0.7420257337124997, 0.21034274381456342, 0.19605431355208425, 0.23147877561634855, 0.9537810457593175, 0.9235791456769342, 0.2820093037162684, 0.36066156055376086, 0.2367364953073684, 0.8489819945180657, 0.5943234110746559, 0.5635303378810115, 0.6874401282766883, 0.6077995699620787, 0.5052316481318616, 0.13555587792302382, 0.5417412079451618, 0.6393036196294952, 0.4756953917111433, 0.5066913698551045, 0.584434916083602, 0.7632195540100054, 0.782249174530928, 0.6345754557897165, 0.6271417421325394, 0.8006669166685649, 0.7497492555982361, 0.613115754004704, 0.5055309561859314, 0.5470491727856116, 0.3047563181523556, 0.40356023221607384, 0.24128939999986276, 0.6021609265744445, 0.28992070164744355, 0.5458418373598435, 0.2925116794995838, 0.46272052727237567, 0.6989163649287813, 0.4904685078201223, 0.4576750501339516, 0.49839142138551995, 0.36036255226676317, 0.6522363604791368, 0.6776077673870428, 0.6502965818473334, 0.30878150967791573, 0.31757504106534185, 0.24696664845069982, 0.26949116097525216, 0.43531511523185296, 0.27332240219605775, 0.27704602557443936, 0.33415982631501706, 0.21944825687643332, 0.45214661263246625, 0.4277829389229941, 0.458831783620713, 0.3955882824967487, 0.43300623196809906, 0.40347228208900887, 0.425396228162951, 0.44586925158471613, 0.39926236241231683, 0.8397904042699303, 0.8490460231187127, 0.8618955848998536, 0.794422739950672, 0.8212127106527605, 0.8517846584216642, 0.8050874314610434, 0.8512560909788578, 0.8228029348245599, 0.09545821317220182, 0.15590261871455136, 0.1170114847439403, 0.1375889803938275, 0.15501157929728437, 0.15633989109838675, 0.1405440302082861, 0.36978101835418054, 0.12156262089894665, 0.201099520583079, 0.1430484028686354, 0.15288148206430452, 0.15594681146785372, 0.13890811947776305, 0.18146025307153035, 0.16316631415859195, 0.1629755505428293, 0.17833718761399364, 0.518165113468857, 0.4864738021338155, 0.3174798868136738, 0.49684555199594593, 0.46247676185831255, 0.5281124640982524, 0.534918505483035, 0.5461659322031469, 0.5400688960437348, 0.3161340015070093, 0.3138956792649843, 0.4402626726552893, 0.4123669209746442, 0.4512187613205296, 0.2707124129781836, 0.3996349122364693, 0.18917970949596508, 0.28548173517309183, 0.25201091789935104, 0.21251799364214152, 0.24342995452473593, 0.1924272238792868, 0.23084483590858995, 0.221167277608865, 0.25124117729830897, 0.22097354639332178, 0.2122360368754349, 0.6429649657420087, 0.20950175736698673, 0.2166588197992133, 0.20117721236384545, 0.24196561630594204, 0.21595850541571093, 0.220856037317277, 0.20668459792242744, 0.1984869505088609, 0.9541748315641595, 0.18889993972956176, 0.16907750507978903, 0.1672167179854941, 0.9438397630346895, 0.19739126266032958, 0.927918028883806, 0.816454693399315, 0.168626311164365, 0.7547482508663139, 0.9390153340100567, 0.1679865223961322, 0.7773424285628467, 0.6715096770240079, 0.8891235041179348, 0.21106870226772856, 0.21264887033098523, 0.16898518302904197, 0.188255494981322, 0.20296571185305168, 0.18701338406203616, 0.19822719308239167, 0.17617988433106835, 0.1883232374817836, 0.18260940712091966, 0.17528328144143102, 0.18367549882309153, 0.08136167579945741, 0.09418622944934874, 0.09761948320335889, 0.082079241048436, 0.09137899549537454, 0.09215830415889392, 0.10600942823517356, 0.0865472994137283, 0.09722923864455046]}, "mutation_prompt": null}
{"id": "17c71a26-1a8e-46f9-9a97-8b770017fef1", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.5)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by using a dynamic scaling factor for mutation vectors.", "configspace": "", "generation": 39, "fitness": 0.43831111896507413, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9190496758891505, 0.918854976832591, 0.9205813512426229, 0.9239364389013226, 0.9178935661689801, 0.913427871323801, 0.9183839727204108, 0.9148453017362226, 0.9204861047939484, 0.7648732970389088, 0.7663734326196137, 0.7620457962144023, 0.7676300944549352, 0.7482669700238156, 0.7258880716480038, 0.7554178760376522, 0.7661865123618069, 0.7788259304321925, 0.13923490188962473, 0.12417476407804295, 0.13870206327933343, 0.1272288156836785, 0.14290040074982024, 0.13512226923241966, 0.14565532106519152, 0.13756362490672003, 0.13227443820123264, 0.10970877335894114, 0.1256273613159158, 0.14258067098141403, 0.11883978050940347, 0.11327817343624735, 0.09168191561622241, 0.13855432076123253, 0.11979366126510871, 0.10993156591571407, 0.9626164944940108, 0.9811080650848161, 0.9776557129532683, 0.9280030458520129, 0.9710123091499379, 0.9524982559736364, 0.9744460629074516, 0.9655803729346832, 0.9837499769097066, 0.696682368207523, 0.7360321959127929, 0.6920532836338107, 0.6763987522272914, 0.6248527034988582, 0.7265432773896148, 0.7079367035802154, 0.6721502916357531, 0.6885860070781462, 0.17139791668122706, 0.24339225680281562, 0.794944439506201, 0.3927624600306189, 0.3666915892235184, 0.9211258370515905, 0.237174475456834, 0.7018323925692884, 0.4092833659695466, 0.525433401491955, 0.7270871266167478, 0.5619387016301273, 0.5900926246899951, 0.7656306996470549, 0.5168730851070987, 0.5660432537713741, 0.13600388868417523, 0.5517185554242939, 0.687280519959978, 0.6158191936740511, 0.5289036828581212, 0.6001561026761608, 0.48154810023321837, 0.6037403748174424, 0.630361448336391, 0.7000063299652951, 0.5416014576368284, 0.3365973040623573, 0.48709000905317945, 0.44784088291587365, 0.5394490595903065, 0.5809090620876187, 0.2843675681377986, 0.659321602995103, 0.4634858274060475, 0.46010872101269995, 0.5255451538040301, 0.6200998993379991, 0.6510735991105387, 0.6560527826342131, 0.20715327476205747, 0.3887120560601133, 0.517154585762365, 0.6846868673990638, 0.5339798050146035, 0.21846600921271675, 0.2987063755277831, 0.3611702605513668, 0.39971910472787175, 0.4281398634240128, 0.3791629919701447, 0.34788249629409373, 0.26835378140622357, 0.19986135073781885, 0.39478480651249115, 0.35526324492870254, 0.4205013660841529, 0.4395821419863529, 0.4591222310031826, 0.4582293756215754, 0.38402208500863155, 0.42424088784310066, 0.3701202229544982, 0.7983985086715724, 0.7993449265986682, 0.8505980625671419, 0.8268380363852961, 0.8264377824617435, 0.7781050398780939, 0.8293525922570335, 0.8420696919420847, 0.7581696339523354, 0.13310172861179048, 0.11284074202877115, 0.16603215062894228, 0.11637501257003224, 0.10247554542863413, 0.13582576192754592, 0.13189875802837236, 0.12981710147742376, 0.11926538419331267, 0.18843984089060983, 0.16985213277511935, 0.15969692026263582, 0.15581288265128002, 0.1567026549051247, 0.16865769556249544, 0.1581314361801771, 0.16554331605939643, 0.1665963654520095, 0.2591453053907907, 0.5178686193274178, 0.3582964447674788, 0.5199051712590506, 0.5286259860802733, 0.5342786675187139, 0.32151650530028864, 0.5021956314852253, 0.5255334218438177, 0.3654378874575649, 0.2455276599268611, 0.3411604314515746, 0.4483063364092934, 0.25314522349959, 0.2630981888351015, 0.24642749739574432, 0.23770549958052323, 0.2733201230639082, 0.20369742841289995, 0.2190028381796788, 0.22831131015363604, 0.23060417729902938, 0.20564097688498217, 0.23648821036394474, 0.2187403562331489, 0.2444196870301404, 0.24269841875857123, 0.5779000081697233, 0.24672709139234006, 0.19904762549354105, 0.38086215873105256, 0.2118852054425081, 0.24346595166132412, 0.24858756642265922, 0.21620513744456615, 0.24576424768371796, 0.9414861734781359, 0.18526917784391272, 0.18831800521606357, 0.19972157765786402, 0.881773638732748, 0.16349890217209428, 0.9088150836073947, 0.1610173561010172, 0.1698423332648925, 0.8813738446579128, 0.9157410225132954, 0.16805996651165966, 0.21116160635993309, 0.20776178488657915, 0.8724898892492513, 0.91019491218841, 0.21159216088571697, 0.16774585543440812, 0.188009272838359, 0.18989306804461725, 0.19985306697056382, 0.18686521112311105, 0.17578133252119077, 0.17509326551239668, 0.18052873732036512, 0.17775578949154336, 0.17651443110957332, 0.0878134086729504, 0.09339348035755812, 0.08064100629989102, 0.09384485869447201, 0.11011412447095759, 0.08924198854098053, 0.11839722889316473, 0.09367313679211953, 0.09047641777977355]}, "mutation_prompt": null}
{"id": "dde92da0-47cf-46ea-948c-8e505b1ed242", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]) + (self.F / 3) * (best_solution - a), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Adjust mutation formula to include best solution influence for enhanced convergence speed.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {}, "mutation_prompt": null}
{"id": "dbed0330-aba5-469c-af46-ea7524ef4575", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.45 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve exploration by slightly increasing the adaptive crossover rate's variability.", "configspace": "", "generation": 41, "fitness": 0.4553241912977398, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9260017072893487, 0.9361194317213049, 0.9266776293514793, 0.9313754583233956, 0.9362945979733082, 0.9336975899771511, 0.9322603448028541, 0.9292921149167818, 0.9251809243460527, 0.8028936926348058, 0.7799671496833658, 0.7801668061779037, 0.8055972798330161, 0.7582133236905644, 0.7782323085730458, 0.7970929304423758, 0.7832589997465994, 0.7957388613941034, 0.12704445522693042, 0.15053966709679467, 0.1472792399658447, 0.14259326934908456, 0.15064473000937617, 0.13712653587599766, 0.13492449175721577, 0.1524906379730916, 0.1412649526860763, 0.1438330811304841, 0.1613075425860956, 0.13089032453712224, 0.12005207809301066, 0.11157184154483002, 0.1123391417913836, 0.11995235410860627, 0.11516364486413055, 0.13779827668644629, 0.9435427447625246, 0.9743973974321212, 0.9854186523113283, 0.9345564051101035, 0.9840557019151549, 0.9734614388795825, 0.9520238996856143, 0.9830206248350292, 0.9772728573800359, 0.7384091594080957, 0.6615343874346538, 0.7530773663610633, 0.7643526968392853, 0.7182803711539287, 0.7054299766793355, 0.6995136655561643, 0.7423844855067865, 0.6977822281108361, 0.22833818758824898, 0.211616683348688, 0.6050747786138997, 0.9303563665402463, 0.19341479957558605, 0.38741213827423604, 0.182488182539426, 0.17937553301794618, 0.24655040768826042, 0.7138436732665112, 0.8321337217779518, 0.6026906228803569, 0.7691181335409587, 0.1360834095531389, 0.1342248453868098, 0.5291246192698309, 0.7621475593248025, 0.6521239826667753, 0.6883817958323006, 0.6724729550591706, 0.5542555701706058, 0.7003274324355435, 0.7028461067167613, 0.8012950097958988, 0.6524121778970403, 0.7168932133414476, 0.5198881751499838, 0.18730997915535164, 0.35602397757411985, 0.6658677469647206, 0.7029525391320174, 0.5333429299531733, 0.43596521978872527, 0.6766404721968216, 0.5247485405763658, 0.47336880282645954, 0.31848587961484165, 0.6205883266856689, 0.4192647246290241, 0.26180451652428616, 0.3368164414044734, 0.17364601524078427, 0.5226568788529806, 0.5516494792014114, 0.5252266600707767, 0.3492020744531972, 0.15744676881826458, 0.4703209737141487, 0.43598638800709755, 0.5851788120753931, 0.5685455715290446, 0.15466054896179737, 0.33242342471273245, 0.4288709782810691, 0.4952540522796278, 0.4816110537771441, 0.48707963718731595, 0.6306636041031108, 0.5289658093238758, 0.5531614866944772, 0.4854692566741483, 0.5426822788796954, 0.41390603568879103, 0.8490830528809665, 0.8830065446751092, 0.8881817910250724, 0.8652501656693302, 0.8773621580313684, 0.8393543812734962, 0.8528205156897888, 0.8684546227959131, 0.8209727819589506, 0.11063650398696645, 0.12779901267232197, 0.14703696145888057, 0.10288239304479319, 0.5862483873920646, 0.12506231710233628, 0.16683952901999033, 0.17323045727462305, 0.13981961070602722, 0.20913659940285956, 0.36775005288893203, 0.1555616673392738, 0.1603377637154879, 0.17915867339327052, 0.1550413553087563, 0.17937957260103632, 0.18762783354505186, 0.22949441108583413, 0.3250749865182492, 0.5572816482466896, 0.3183673053364364, 0.5529152186025679, 0.5404000518108887, 0.39727582757413826, 0.5209244309184002, 0.5030190684091349, 0.5611814623354072, 0.3677406668158083, 0.3236612834476712, 0.30931880108858445, 0.3847180957021512, 0.44576717264525323, 0.44613288524491, 0.2842185917095912, 0.31307520407600176, 0.2751284351852431, 0.20219695623898348, 0.22570356514624723, 0.22173358555391776, 0.23258061033083577, 0.23302414521177683, 0.21860941444480964, 0.20360570950035495, 0.2252083219799138, 0.21802496708050956, 0.4249473435174833, 0.24128359399092703, 0.5271658342029801, 0.7932088800496707, 0.20280033121743446, 0.22559629578327112, 0.18708760634716737, 0.2077107296237407, 0.5647532941126125, 0.16572795152616304, 0.6535471148012035, 0.18866242243835463, 0.888080161236718, 0.8687164725078768, 0.16749775509961196, 0.9253143457240824, 0.15627838988517218, 0.9329977479963687, 0.8931243308936205, 0.12791630321885206, 0.2101812898654949, 0.1526888998555942, 0.20594549054533462, 0.16709517469191304, 0.9136824630132595, 0.2126776806604681, 0.16883989029109348, 0.20797863317777077, 0.19886196161051284, 0.1915482216051031, 0.1803647970124732, 0.18976441131609245, 0.18808591330161328, 0.1932996696724414, 0.18806641116887035, 0.1839442694321256, 0.08569264895113449, 0.09399678070752582, 0.08758043379069458, 0.09644851871901139, 0.08295718754037551, 0.0969847878126342, 0.10177187433927559, 0.09199612653667066, 0.08666791110105043]}, "mutation_prompt": null}
{"id": "9d78dc91-cf43-4bb7-84a2-ad9ff94e688f", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 3) * (elite - self.population[i]), self.lower_bound, self.upper_bound)  # Adjusted elite influence\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve mutation strategy by adjusting elite influence for enhanced convergence precision.", "configspace": "", "generation": 42, "fitness": 0.42109926893008864, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9374677283372063, 0.9344803071069734, 0.9476174475514032, 0.932746754273908, 0.9317101185917631, 0.9337841149626903, 0.9328116191220437, 0.9376927835414952, 0.9445832971438177, 0.8277868439156142, 0.81545105709059, 0.8202596906016668, 0.7819056090310196, 0.8038129880215952, 0.8185618102882232, 0.8273927675100254, 0.7898498824930673, 0.8182583693659915, 0.16737199023930316, 0.16695775118297174, 0.1522301446777108, 0.1313151466903546, 0.12682202602072046, 0.14324059510367082, 0.1468645010306613, 0.14631057988337637, 0.1356597014433597, 0.11903542171998505, 0.11843721475189928, 0.12174824966110043, 0.11636087591319932, 0.12170170318489804, 0.12456806515395258, 0.11233833834286511, 0.14060447779395857, 0.12518126345284342, 0.942872474486379, 0.972633928865527, 0.9837778564855988, 0.9657410913573783, 0.9796024186194529, 0.9469986791982131, 0.958802263962452, 0.9755319951158217, 0.9800153661504393, 0.6803676824892066, 0.7220672625172206, 0.7715435213128137, 0.768441206391727, 0.7001944245585453, 0.7301467302802023, 0.5427090236293628, 0.7356254654481227, 0.7547777425798428, 0.21532913093209405, 0.17164092856534374, 0.2310919250018486, 0.28364976196267344, 0.3852989144040663, 0.2819299095921267, 0.9125608815346549, 0.9572744373692282, 0.34567662203814475, 0.6726572086457622, 0.8024092554647653, 0.2691479045248554, 0.1372546920777319, 0.434073798883562, 0.5034071745173263, 0.614302018335431, 0.36975591911996897, 0.41774306170434106, 0.626896414031008, 0.5287918702781549, 0.5091188943473517, 0.6857013195977217, 0.35677094661306663, 0.47888951029994475, 0.13616672913633066, 0.13622194258485565, 0.13623512855958686, 0.05792926731941628, 0.08331925450187483, 0.5176166207082487, 0.28664252382078426, 0.3678032273343763, 0.4686332054374386, 0.278725266877625, 0.5496501932120763, 0.3195702584085267, 0.2928525991488331, 0.5270643575519991, 0.20214830346298795, 0.4381506758344491, 0.5249395775175603, 0.17279306428579222, 0.5876261019481835, 0.48538080938280914, 0.6407431847530556, 0.2419418114877777, 0.22278840540443012, 0.5413780976045699, 0.18462464202113127, 0.33158361528208713, 0.1920416167760285, 0.12094102916827365, 0.15759698977792724, 0.41410874991454283, 0.5696498898480422, 0.462785528594159, 0.41901772054112185, 0.44521938591773036, 0.5237976363383836, 0.44158297857513484, 0.3726446115928713, 0.5083388350868042, 0.555912767975652, 0.8854990775368297, 0.713214121874755, 0.8530420447888696, 0.8687190179195649, 0.6899390290254612, 0.7630181660800682, 0.7187838352740925, 0.8486177289216653, 0.7599960157774996, 0.15035027719152316, 0.17091411448834715, 0.15832385205138233, 0.12588167452171606, 0.12392982721719092, 0.1555995048437282, 0.1527300676998521, 0.11205185928081496, 0.14156627641851083, 0.15625453731595373, 0.1576420654211833, 0.5765765832461767, 0.18318145953159748, 0.16480982425750101, 0.48087088980316817, 0.18771887856063973, 0.13717264087626158, 0.17467027439585325, 0.5220294569976112, 0.529415511503299, 0.34563523716080646, 0.6319158568006149, 0.5958994348976371, 0.3439655144524354, 0.6126448949451626, 0.5316772029432344, 0.6045988974859389, 0.2289151460322555, 0.4291045760215023, 0.31076652433134455, 0.39734664617747784, 0.3098654996404332, 0.4970537982264127, 0.28672337828324945, 0.2549811622941426, 0.31415690148981945, 0.20755467085240775, 0.20248602886508837, 0.22798855612609648, 0.22594225682122981, 0.20824210426316048, 0.2204261392538659, 0.28011091224678053, 0.19809250261640288, 0.23102951539950245, 0.19853586135354928, 0.2232912949024879, 0.24828998168903305, 0.7911531411997956, 0.24774004826245477, 0.20647422909194435, 0.22376158004658353, 0.23869788205903164, 0.2491743931864493, 0.18536557927041963, 0.936654950711077, 0.18778628646488982, 0.16688342166528525, 0.9443520573144014, 0.8675376754580286, 0.17478893537828388, 0.1573920069688831, 0.1689122224454872, 0.9061159315811018, 0.8997818714006415, 0.1687177824619157, 0.21092769053871918, 0.20904192630205942, 0.21264391636780178, 0.16852592718447357, 0.21252319553514998, 0.16909596764959, 0.18781371109701805, 0.17834495972092368, 0.1823940038902926, 0.21053807113586787, 0.18679024093511654, 0.21288147434793359, 0.18645797492210325, 0.1703398518759104, 0.21011379703593336, 0.09544013702190113, 0.12553798459289933, 0.09646165314303434, 0.09626153955090377, 0.1095581790930582, 0.09485167544705242, 0.11534292287619974, 0.08972350633001336, 0.10247320676645033]}, "mutation_prompt": null}
{"id": "9557ab75-aacd-4ba5-93ec-6f8f61bbd4b4", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                self.F = 0.8 + 0.2 * (1 - self.fitness[i] / best_fitness)  # Adjust F based on fitness\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce a dynamic adjustment of the scaling factor F based on the best fitness to enhance convergence.", "configspace": "", "generation": 43, "fitness": 0.4504649361071592, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9257530514663963, 0.9378347855780652, 0.912122035568693, 0.9305128776583308, 0.9201066389306826, 0.9366877179563984, 0.9225053064608685, 0.9340180637727651, 0.9433826701635504, 0.7916177592254706, 0.7659814442701111, 0.8153525783798982, 0.800733988918052, 0.7665827397088012, 0.7965721713004422, 0.7940141225853653, 0.779438399796513, 0.7689465871911957, 0.17027350902166216, 0.13259215478214015, 0.16110140432923958, 0.1791170632821395, 0.13187552826373794, 0.14520114866439637, 0.13788294730953898, 0.143909231031359, 0.16482653288491167, 0.12580984072251522, 0.1122675756680035, 0.15381489400422255, 0.1262392788209008, 0.12864212588966417, 0.11839033534772536, 0.11600990872020756, 0.10964764120495041, 0.1261185579063866, 0.9705645666808412, 0.9817966514168751, 0.955990480228922, 0.9476910319596097, 0.9883750768256807, 0.9583666670512611, 0.9667099704438454, 0.9848896484278761, 0.9619581820738672, 0.5928292181849566, 0.7747879194861251, 0.7042765082484694, 0.7704805688682761, 0.7869689340451558, 0.6897437158153882, 0.7127918765091243, 0.6697609250387011, 0.6724209099164843, 0.21613959550160622, 0.2145328110212984, 0.2299315694585503, 0.9567711530548969, 0.9364033025754764, 0.941760664027604, 0.8742466393387083, 0.9521882748428785, 0.412213564831738, 0.7007516150384944, 0.6254811031787458, 0.5839950581588162, 0.7903982218742287, 0.7024124359998307, 0.5244079751067056, 0.4997935755360914, 0.6443496052776809, 0.1369443886968913, 0.5181213174410975, 0.5153860235103038, 0.5889532897676795, 0.5984476949101252, 0.6566150603776664, 0.6998486109695684, 0.5822542330857852, 0.5724868154358689, 0.6364261853918423, 0.5807020112134991, 0.4631148326667227, 0.5552369259187322, 0.4460903946620438, 0.4415187468998998, 0.5745166828343549, 0.5548965433060922, 0.5091001550046224, 0.49987034326161905, 0.15088599841831707, 0.2546484845580598, 0.16887850997524034, 0.5185682004722973, 0.3056600888025556, 0.11485148791782829, 0.7665717524093189, 0.6955530810608812, 0.4242018355744923, 0.1576721173746941, 0.340731847773453, 0.12988412963911855, 0.32845227210551386, 0.4397204412659981, 0.35314990859587947, 0.14906061912581992, 0.2878564587857134, 0.1615788704084391, 0.44909279299958493, 0.3593759708397555, 0.46554009806366914, 0.5622076454683349, 0.4129920335473577, 0.4609836106184618, 0.4523449715087109, 0.4833825023046283, 0.35911676822309324, 0.8611605258857213, 0.8652711519319584, 0.8728188232066062, 0.7626909331503713, 0.7121742848452761, 0.722261949207152, 0.8577435382828092, 0.8538790142343161, 0.8441077744799634, 0.14865458749253957, 0.16635852463349965, 0.11720366308124863, 0.5528816674478834, 0.15632996253596443, 0.10936581751729824, 0.11978878180200281, 0.12039570644705377, 0.13644457533863474, 0.14676782887261308, 0.15738280206396704, 0.15100789248146174, 0.16044347957371718, 0.1899276691229118, 0.1519295995912886, 0.1683825107747181, 0.2091655403589393, 0.16188252902526035, 0.5454089540637956, 0.5634681316237643, 0.5610316214455986, 0.5665853316667426, 0.547675105245665, 0.5318443997038842, 0.5627371408377173, 0.5489500915196551, 0.27941191222942685, 0.469983113426067, 0.3117698774430021, 0.2584929626653806, 0.288777005009082, 0.19649108102503887, 0.4100497276441504, 0.21128439761077644, 0.46928117634269195, 0.36417548300684977, 0.22556955316199734, 0.21473862831188795, 0.22379760800128157, 0.19054568280116047, 0.20682179577197501, 0.22762407871667822, 0.2354441401129892, 0.2200340786216438, 0.29195813442608665, 0.23953697078647307, 0.23174891052523017, 0.21961059067936972, 0.28458907384253795, 0.20445174098832586, 0.25027311909843497, 0.2065688743706915, 0.206031426240326, 0.743089929226513, 0.18843422133669852, 0.8597511368866136, 0.9320379833374999, 0.1667482023124769, 0.8407166164600993, 0.1977671390160134, 0.7519202433644636, 0.8899819950934758, 0.1703599655914888, 0.9234508771839279, 0.20953920263600012, 0.21115517823143726, 0.20014474370075086, 0.20696237762036251, 0.8890870674009769, 0.21259942111410846, 0.2139509980185651, 0.1693756594805984, 0.18735407781421287, 0.18172469593833507, 0.19251780835926557, 0.18135651840630373, 0.19083325541335283, 0.19644986393451502, 0.18108978755541771, 0.18660393730938707, 0.19514798958634327, 0.09043167092910498, 0.09261903778203162, 0.09545817638926468, 0.09949097068390911, 0.11867720728680675, 0.09469857856280428, 0.10725916326153218, 0.09159646383287579, 0.09130559971555907]}, "mutation_prompt": null}
{"id": "ce545b9c-d9f8-463b-a86c-bf860232ede6", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population + np.random.normal(0, 0.1, new_population.shape), self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce diversity in the population update by incorporating a random perturbation term for better exploration.", "configspace": "", "generation": 44, "fitness": 0.3979239474609657, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.8889893452830934, 0.8673502652031624, 0.8813113485169798, 0.8812736011691167, 0.888306858194615, 0.8699785806077198, 0.8952911578483621, 0.89709374053212, 0.8655227795245648, 0.6865086620619912, 0.7091512516719535, 0.7054933419456888, 0.7406420472881146, 0.7292840117559172, 0.7533038278318668, 0.661720037123938, 0.7007830371504963, 0.6494885142107512, 0.14058308632582361, 0.12989387538024944, 0.13965541619188093, 0.13639036053182585, 0.14640438929549726, 0.14122187262256536, 0.14253037959151516, 0.13483872359888205, 0.1409043306708021, 0.11750307161465623, 0.12081230864830073, 0.1142953165094901, 0.14389906543629272, 0.107532568330166, 0.14684958273576432, 0.12401862498518512, 0.10294392385302054, 0.1449721281346985, 0.9750622137868992, 0.980114028291571, 0.9663637996849611, 0.9511605636105178, 0.9861034283236316, 0.9657626924249074, 0.9612605950822178, 0.9680999311440426, 0.961304079494811, 0.5596152727414215, 0.5498082085817082, 0.5550933335155863, 0.5352435233853621, 0.5465805610396222, 0.6122667729854685, 0.5636445577973243, 0.6089783707575372, 0.5321843528697292, 0.6888640225063518, 0.9217065757241547, 0.8054062350192047, 0.8635544698006761, 0.9198577763868366, 0.8889583132466672, 0.9202780053821993, 0.814735638867163, 0.9091641943163793, 0.1353273428009959, 0.528898142995738, 0.428604562427811, 0.45602610566029, 0.5050462520140409, 0.43645028276507924, 0.5544370536050631, 0.5474661613616917, 0.5719580210918667, 0.5370243740671061, 0.5898182090275896, 0.5976288306451736, 0.5968646341264767, 0.5516981041861053, 0.502242413891607, 0.5534975522299679, 0.5866463142923539, 0.4877813975829447, 0.2584254420343328, 0.22387852247057927, 0.20830363911730465, 0.30702843471614527, 0.2740767857585146, 0.08850234851839345, 0.10313573900099215, 0.13900964818107042, 0.3028970358557702, 0.27396000778032636, 0.33998484753959846, 0.2038880856076708, 0.42324279559822364, 0.17104341005045842, 0.14349608924845325, 0.29696586305555583, 0.38140142862810367, 0.26281344043095856, 0.12232946454479476, 0.18376441730168713, 0.11250417882588859, 0.20812741106212018, 0.22263781552051942, 0.14779782953308274, 0.1362907352354874, 0.27956616443787785, 0.09497600519085025, 0.33656749744644376, 0.32811207202711445, 0.3795101427834503, 0.38608998179340703, 0.38380333083090756, 0.2740893998316979, 0.31598316296268525, 0.33071796387505403, 0.30337306353789606, 0.7620769121557205, 0.7897918925958789, 0.746335288671768, 0.7933220852418561, 0.811382156869212, 0.7258736246065323, 0.7665301381062213, 0.7014002749043176, 0.7486405634074134, 0.10491000927040772, 0.09630812375479414, 0.11893994090428006, 0.136321456597975, 0.1516424288817747, 0.12645794860668613, 0.11835288705760594, 0.13999397438757621, 0.09276494241453381, 0.19876673756614982, 0.1307634634243302, 0.2035597548869288, 0.16568276440561658, 0.16467353061724466, 0.13326073752770096, 0.1383389152749127, 0.206280144410803, 0.17865424993920154, 0.44367223214223217, 0.3834170009481571, 0.4324607498179509, 0.43357857805901134, 0.39137432635439795, 0.39206674634921734, 0.43848651576137476, 0.4681316744659081, 0.4199594616758616, 0.2753522742246569, 0.3406058340617265, 0.32042933831151055, 0.30645547560334063, 0.32799617322190666, 0.346321449042186, 0.3310354723165404, 0.3301029057690458, 0.3359737684631796, 0.2293910868470328, 0.2258963883062236, 0.20557249259392107, 0.23364897986928135, 0.21124547102926527, 0.22994609774091268, 0.20931203259371167, 0.2042160449610395, 0.2118249582474675, 0.21910640957675154, 0.1887418856407609, 0.21991925596031914, 0.21099737936280805, 0.24099212143841986, 0.22512793075959836, 0.22113674408783213, 0.20864846109190416, 0.20451211457770802, 0.18836141006672658, 0.1855513347693295, 0.18777073496959584, 0.14853914409318314, 0.9173279639902974, 0.1477821212099839, 0.253333226363576, 0.15919825807727594, 0.16779336618497742, 0.8978968637595842, 0.15423742910232574, 0.8957966859873867, 0.15437106406243406, 0.799005842849813, 0.16646370304263514, 0.6197566374349972, 0.876316749198903, 0.15573866852580287, 0.17997826006872253, 0.20209156819219976, 0.17791367757262577, 0.1969145954214797, 0.1848564750819256, 0.17645892411791086, 0.19233217458037033, 0.17305402411679693, 0.2017607126359604, 0.08355912235837082, 0.08298890841204498, 0.1001943174847243, 0.09958133306186268, 0.10028227171138149, 0.08747462482905033, 0.11575360393982259, 0.09083727005099551, 0.08799590223356812]}, "mutation_prompt": null}
{"id": "690cda7b-c1fe-49d4-ab97-629584e30572", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                # Refine mutation strategy by modifying mutation equation\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 3) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            # Add local search with lower covariance scale\n            new_population = np.random.multivariate_normal(center, covariance * 0.5, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploitation with adaptive convergence through local search and mutation space refinement.", "configspace": "", "generation": 45, "fitness": 0.3469172805669822, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9383073692500361, 0.9519992220770619, 0.892926018195758, 0.8794723059228566, 0.8882044650873847, 0.8320827894480782, 0.9282433497653576, 0.7662675737314497, 0.9043056689623742, 0.835933699427994, 0.7299156325366791, 0.7427066264509906, 0.8382698140321013, 0.8140678279673872, 0.7839115814943467, 0.7465965632348537, 0.7270105920963742, 0.6058259799572622, 0.18904505492828116, 0.11855092907060172, 0.1305362047814177, 0.15279856158449534, 0.7444448239941815, 0.14912537210077825, 0.17334004123071756, 0.5757835757354093, 0.1842333235523742, 0.0931120323697684, 0.10689873875502631, 0.14619844693999806, 0.11892521362881037, 0.0626765698919246, 0.14446265163210792, 0.09351582324974406, 0.08002619440618619, 0.09785262303449926, 0.9589299053332598, 0.9326781787031821, 0.9273927615602606, 0.9704489735799915, 0.971665606043656, 0.9669673992632672, 0.9420714177759251, 0.9609833603271067, 0.9273737264523286, 0.451469906502874, 0.5983547494974815, 0.1334266770335607, 0.6813199037547673, 0.5758560941291009, 0.35503948705394917, 0.7068690248992304, 0.2891392708728324, 0.5286751950024182, 0.19215237890791736, 0.11904402672308056, 0.226311780801145, 0.9665953222969907, 0.20610915477391345, 0.28081229964714116, 0.17379345978808491, 0.18087828515766924, 0.24752126068641833, 0.061688336266273236, 0.20024201923517415, 0.13582301873834768, 0.13513844163804845, 0.5154061721891222, 0.14987133843730827, 0.6806805003962806, 0.2134135364556451, 0.1876123918343433, 0.1985534970443127, 0.2182063546902434, 0.18373130283207306, 0.7434260429836046, 0.18738318579414848, 0.2062959250990658, 0.4978437956276208, 0.20037202459784154, 0.1788841014374044, 0.15341533500914284, 0.13382699177506074, 0.0016736384418795103, 0.3401760537916403, 0.005969306356626625, 0.05125699631619629, 0.2822017953587801, 0.19331759111599922, 0.290520077076844, 0.177300180859297, 0.2896325477581566, 0.35051852874744527, 0.3044802448111549, 0.18662609911551842, 0.1582190150089684, 0.7803078934115475, 0.3162171054225875, 0.20075986417259106, 0.18872579736707895, 0.1139754599693984, 0.42409223773605864, 0.10222025762094145, 0.2868139020029309, 0.24417350141311356, 0.17461425563806265, 0.22997517041376792, 0.20459938381609177, 0.36566013989302815, 0.4025420457371399, 0.4342536563623577, 0.4173302362282465, 0.3719486605086205, 0.34079499025440985, 0.2563649917861023, 0.3251407332651718, 0.34652502095153126, 0.7964454823709317, 0.7751494310123408, 0.7208450773388628, 0.6151652125151965, 0.8064999751356797, 0.6070938877592378, 0.7404636711240542, 0.819087065447729, 0.7595391528759727, 0.13100706283361974, 0.1579383933113011, 0.11246599147034142, 0.14237501231119765, 0.1172747201992943, 0.14647626897275312, 0.1173396947392239, 0.18592866346583414, 0.10678666712256912, 0.13430762816002229, 0.20086009950581196, 0.2759233024058849, 0.13949169314072407, 0.2050216374200381, 0.15670302076081466, 0.160911400522598, 0.1529890987954139, 0.17633355178539134, 0.3009034331227737, 0.3166510355203842, 0.27118064130104647, 0.38486852337924016, 0.3343929580624455, 0.6349205041194689, 0.21645990458257636, 0.27600266164405507, 0.3069762882359439, 0.20110246987194824, 0.2662884494323926, 0.30334986643194684, 0.3156873366677957, 0.20379168382840662, 0.34937679476870165, 0.238853464317914, 0.17784580983103426, 0.21758304453723598, 0.2237539410298819, 0.22228631539084276, 0.23493249519509962, 0.23304580062632663, 0.21917471925817844, 0.24399367209487743, 0.221761255133192, 0.20878852549243587, 0.2198859398031927, 0.2002147975473051, 0.21612702898433522, 0.22019695999971722, 0.2424348945580208, 0.19051785196190807, 0.2511412854731174, 0.225311601349369, 0.2108851533295404, 0.22493572881837276, 0.188703339447033, 0.1729282661272027, 0.18918151161915353, 0.2004418165085058, 0.9127787994000012, 0.19838818918859324, 0.16652088706072132, 0.16625637892869694, 0.16774862867216978, 0.9170168224164129, 0.47214343291351757, 0.16913262319902, 0.2078780480106598, 0.20535846208450959, 0.21225516515821552, 0.3840584525264721, 0.5294358885067145, 0.17004088487003588, 0.1847647428998892, 0.18425918927612484, 0.1934243709839315, 0.19699566135270152, 0.17946390587975913, 0.18220364154872992, 0.17577916879264976, 0.18595679074882387, 0.1824255915736105, 0.08010021120951683, 0.09736735886374259, 0.09342078301893286, 0.0940528225315671, 0.10550905662782284, 0.09338380460428675, 0.11677752301168653, 0.10504088588165472, 0.08669924091865922]}, "mutation_prompt": null}
{"id": "1f5d9d10-6a9d-4d83-a619-9e7186d68120", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.3, 1.1)  # Changed dynamic range for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce dynamic adjustment to the mutation factor range to improve convergence.", "configspace": "", "generation": 46, "fitness": 0.4258572238867141, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.93820165048582, 0.9335228743043391, 0.9347707271759106, 0.9324869544327881, 0.9414890876886876, 0.9378899595346194, 0.9351794309637164, 0.9347285151356342, 0.9544807957206637, 0.8483984632822811, 0.8309158754049106, 0.8463952999129682, 0.8459703127347347, 0.8229638681913003, 0.8339398212115785, 0.8281831731979257, 0.8301930258887249, 0.8142076501241935, 0.1455242352044137, 0.1358689599590367, 0.14571725122216028, 0.09061922487780516, 0.1563145805751769, 0.14509829073885272, 0.13969876360935873, 0.14531043914102337, 0.13864885070015986, 0.1416197698838727, 0.1177364063882238, 0.13759597791116318, 0.14217599828281713, 0.10931378008829618, 0.13342170210118987, 0.13559279360129095, 0.1313364559609399, 0.13009218517484022, 0.9670395072943011, 0.9649705867571797, 0.9795699586225901, 0.950312801783897, 0.9787100538283988, 0.965937605364775, 0.9510063641520721, 0.965370158065408, 0.9827552220793808, 0.7587679666281252, 0.7200833896891369, 0.6292518579766252, 0.8214805510288494, 0.8014890870473733, 0.6548214396871714, 0.6354767170914992, 0.7290785534651572, 0.710264644665026, 0.21427463447603645, 0.23019052101312754, 0.24621859236036225, 0.28155442349709925, 0.21128663917887058, 0.2104653804623574, 0.9352545380901428, 0.18103903756842055, 0.41091981084164253, 0.42966711069107855, 0.49401887286456236, 0.6127745146391959, 0.573176872791865, 0.8082180081980457, 0.6308636061153859, 0.4520393890408164, 0.5003772073510477, 0.5778334203868072, 0.5204158457676491, 0.4119606365566245, 0.7174994350413508, 0.694842917840125, 0.41362335160299113, 0.5684601500913589, 0.5255950414986653, 0.6936445083180112, 0.5220434583623945, 0.723166680697121, 0.1534717152672319, 0.49012775524363783, 0.6231002918190216, 0.23904869018800468, 0.47061904305571445, 0.13866857447877412, 0.08581784954957694, 0.46441894614050616, 0.09573016564381909, 0.6680467998537638, 0.4003654254475435, 0.5255636474334908, 0.33363907917316404, 0.38405530844870117, 0.2406915422792244, 0.772771654221111, 0.5249519641632712, 0.1025462471102393, 0.12498599109613628, 0.15495721224551218, 0.40887765457851133, 0.3725816172822022, 0.4475616810645573, 0.32469076335815694, 0.20808746457025362, 0.4026801511583378, 0.34676649887706745, 0.41200855885829013, 0.38943399592438066, 0.4443821830500254, 0.5771973429018166, 0.44337357254927134, 0.3622540315070083, 0.37194736570085996, 0.4175882778986144, 0.8672858406935011, 0.7141427173306896, 0.8488152863181806, 0.7805031425844705, 0.6439235139981683, 0.8537889515787294, 0.7895352737310324, 0.8349562740588228, 0.7970816469286268, 0.1213723638809393, 0.11473477367972806, 0.15026768368429255, 0.12246289036464475, 0.1359423616188562, 0.13334837525221788, 0.12244215969086236, 0.1768867315848307, 0.1369137013187437, 0.15760530271956175, 0.15696120353099763, 0.16044944602760625, 0.14652261073040485, 0.1438332553401246, 0.1702273219323892, 0.16991950624938323, 0.18515763151896014, 0.1981738099762802, 0.5819496814616667, 0.5291754596102572, 0.642063487564486, 0.6769184906911859, 0.6225034028389009, 0.5255954679712811, 0.5996874752818556, 0.5753065200368597, 0.6078092992731274, 0.2726159468155067, 0.2435973037574809, 0.2947925410029639, 0.27634426004201573, 0.2375342847755284, 0.2302333447775945, 0.2553287804683402, 0.32150457954420153, 0.5168638429973704, 0.26550984068727634, 0.2154910020769759, 0.21251794878066776, 0.2237267091000127, 0.23226338003893432, 0.20791205954737757, 0.20881454864089888, 0.22113011600796795, 0.2176267860851394, 0.22518822004298367, 0.19680330684678438, 0.5555007009668831, 0.2075514203617138, 0.1961765783031335, 0.22439358937847032, 0.23698862417169386, 0.2186816274924276, 0.21523078776932625, 0.8923020308993279, 0.15876293247872686, 0.1886103042351639, 0.11510740343088455, 0.851047053535845, 0.14870068647477597, 0.16077079280480844, 0.9195715397470114, 0.8989586398115382, 0.9136285336696068, 0.1281890079352359, 0.2100078811336159, 0.21209007413413206, 0.6212056182877338, 0.1679111431801974, 0.16882430111668345, 0.21302383903152977, 0.16878308199441783, 0.191532916996341, 0.1885747190376561, 0.18382799814857786, 0.18385716815927555, 0.20752625747278164, 0.1832579480789044, 0.1813955268344153, 0.17929456556458134, 0.17779009349613628, 0.09144773322805855, 0.0953140220117793, 0.08908127193353188, 0.0785417667195637, 0.0862595759330248, 0.08961350193997664, 0.08605305203890945, 0.08620009041369958, 0.09708881257011304]}, "mutation_prompt": null}
{"id": "c2cbbebb-a576-4230-a6c7-c9a57b0696fc", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                # Changed line: Added stochasticity in scaling factor\n                mutant = np.clip(a + f_scale * (b - c) + np.random.uniform(0.3, 0.7) * (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce stochastic adaptive scaling to enhance convergence stability.", "configspace": "", "generation": 47, "fitness": 0.40190332563812914, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.938480992738824, 0.9490265072698145, 0.9356600216702443, 0.9330822324468786, 0.941384476037421, 0.9253095165087419, 0.8979247253789788, 0.9412491871233208, 0.9367713427684273, 0.8429963461188178, 0.8091112900552055, 0.7916640459438454, 0.8567362243407639, 0.8302721814953377, 0.8227785219736872, 0.8665900660083014, 0.8203036119539813, 0.7999220436310146, 0.12914405493156977, 0.13083851658357215, 0.1329081340813022, 0.1535599917176107, 0.14758830846165916, 0.16558680586463037, 0.14693779526573092, 0.15780193629791006, 0.1470081617920066, 0.117808850443469, 0.09380865877046685, 0.06856187479326181, 0.12665282302993364, 0.11698946061415827, 0.13711458149944356, 0.11015936480903965, 0.13194301142391174, 0.12836406727195482, 0.9765994361697579, 0.9848516142796947, 0.9623960499778399, 0.9508301154732562, 0.9619762330670146, 0.9613523881716579, 0.9461514260165335, 0.9786084634262238, 0.9731702516112216, 0.735052044595746, 0.7917448200012988, 0.7088830650271543, 0.645384696451982, 0.6807390351137179, 0.6503857361521517, 0.447021873249718, 0.5644277928397698, 0.6787632752914534, 0.2307208429011699, 0.4043621434889224, 0.3433390595187721, 0.9661682873729364, 0.28218221852852865, 0.35818951714415137, 0.181341940909433, 0.23894672780474813, 0.9573645243435849, 0.4214580357276255, 0.26173000718446116, 0.4432579468817508, 0.7406740643270806, 0.7975800677351381, 0.4505760466325339, 0.13655447266559584, 0.30240557658979117, 0.3511099251890548, 0.5000424387825868, 0.7080755237420298, 0.5414170012147999, 0.2818579143526707, 0.1368962089876723, 0.5972225659888521, 0.5852079531322705, 0.2833438765020363, 0.3941834756110112, 0.024712831959875614, 0.5693657759894972, 0.1162061983406113, 0.46237783332136373, 0.05619143514180214, 0.49462584003500565, 0.41637761758234715, 0.3122272312051141, 0.04209016878472882, 0.07774900103118432, 0.2972337070279496, 0.15050293554873384, 0.17054656028928983, 0.16505919889495357, 0.13729771674713176, 0.7614867595670176, 0.4046655978395115, 0.38877437187738306, 0.17073346842559967, 0.23851211694878627, 0.17725554383471576, 0.28136404345389543, 0.2707637247928435, 0.29337524229856604, 0.26265276889677835, 0.23488920616930986, 0.4096798754851204, 0.22857726648085175, 0.3047875421318609, 0.39326680747395093, 0.48019770790807503, 0.44062240779468465, 0.42501483531355366, 0.41566812016732557, 0.3417197920805487, 0.4045968001921667, 0.6684715507382523, 0.8473571024585684, 0.8210905962758608, 0.7851527536851561, 0.8618903833771147, 0.8926997545781462, 0.744702117725079, 0.8681241288712885, 0.7023674752401502, 0.1452167445096304, 0.1454525823059175, 0.12058581557330905, 0.6453185735571552, 0.12456595146712679, 0.11810752395623914, 0.12625781811932668, 0.12316259483799152, 0.15441626218251037, 0.1996945254809973, 0.18531559579008894, 0.16067667759331594, 0.15634196928587296, 0.25585551190648625, 0.1717917507443375, 0.13984370848158323, 0.17141092242776235, 0.1559435773004092, 0.5546953856415826, 0.5760276886816893, 0.34378638961848784, 0.3475983883761977, 0.6083295100188948, 0.27566997646702884, 0.5449795453421233, 0.6239170219774828, 0.6589758280726623, 0.49355124452651233, 0.4685430564243587, 0.2339072997751479, 0.4816491747082223, 0.2559666105782691, 0.3119319075130389, 0.2656685259088575, 0.14940176319793808, 0.2456962449785508, 0.2166015776952145, 0.20398649138440306, 0.2348130381913056, 0.211750637547242, 0.2375737045304962, 0.24302446363064945, 0.25332997127053536, 0.24812685327431394, 0.22059537251629313, 0.20362638396290145, 0.19219946200906857, 0.5116026584907445, 0.2109193092131868, 0.20174081958349155, 0.22812986862971385, 0.19555502240588118, 0.23974509140235023, 0.693557053390997, 0.18742684368118168, 0.18704301041091165, 0.18895072780380429, 0.1988382991355081, 0.7551465235511468, 0.47431423802306394, 0.16665152925288762, 0.8552620251828659, 0.16794094325038567, 0.7430986002831164, 0.1262142659558534, 0.9472712097762459, 0.20920783019746192, 0.21207072786116155, 0.21288326517284595, 0.1559553515566695, 0.2109766119455586, 0.16582632307793377, 0.17828833793443932, 0.18311759014838813, 0.18456327431856712, 0.19654926273080187, 0.17428429094845266, 0.1906893744802577, 0.17901763792635084, 0.19000434827889845, 0.1945005853316798, 0.08854524502641015, 0.0811096102856782, 0.08074056524638618, 0.09871821202597808, 0.08644802177303823, 0.09269685873609756, 0.10020665694333997, 0.08598835506064328, 0.08383001279359636]}, "mutation_prompt": null}
{"id": "986f25cc-f41f-4d45-a5c6-d79ce917d0d2", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                fitness_diff = np.std(self.fitness)\n                dynamic_F = self.F * (1 + (1 - fitness_diff))  # Dynamic adjustment\n                mutant = np.clip(a + f_scale * (b - c) + (dynamic_F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce early fitness convergence detection to adapt mutation intensity dynamically.", "configspace": "", "generation": 48, "fitness": 0.3616197835533845, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9124657452784503, 0.9030448992298673, 0.9039837011009277, 0.8988243377774813, 0.9001204325188875, 0.8958599045049305, 0.9108844192838449, 0.891188154568727, 0.9087927898932963, 0.393932412392594, 0.20992965597725088, 0.26437636738449544, 0.2410600328868273, 0.31362821047035794, 0.6214927097732844, 0.47455895059836595, 0.6028640840430404, 0.6255377366494888, 0.12360355510624943, 0.13061884306318694, 0.11440490382037571, 0.1315697035001786, 0.10948670508534286, 0.07981082160092356, 0.13650445338858985, 0.13722679911045088, 0.12196446320613819, 0.10700485300915041, 0.1268897035086466, 0.11245348580375614, 0.0464947432308187, 0.09598093910151984, 0.09338136091053784, 0.09509078340422983, 0.05704575421006797, 0.09177858780830594, 0.9463664180438781, 0.9479432612107612, 0.9445325382390884, 0.9459068751783869, 0.9568108884196865, 0.9496772798684587, 0.9471362230088641, 0.9623133713519607, 0.9658420784316077, 0.5997400930075577, 0.5648546401349592, 0.5562561377594146, 0.5783159968085756, 0.5849005364134197, 0.5022351314588261, 0.5959198822373095, 0.5976590694571309, 0.6138919552932895, 0.17061211793244146, 0.15823881649162974, 0.17216673209020572, 0.944832467149716, 0.9368687453666864, 0.28000154458520754, 0.4101391812388602, 0.882188760441854, 0.23743468252373057, 0.47304444708168925, 0.5862271164084719, 0.1283074513430854, 0.6645512067518677, 0.5483992557628529, 0.3032487317395024, 0.5649857954383536, 0.13584927054757467, 0.5350958724436521, 0.4898086880639321, 0.5427733745779251, 0.5335277006854502, 0.45217338017822784, 0.6215766475076181, 0.5438841568221662, 0.5509698796167334, 0.6197675505335587, 0.12750293713229, 0.1432820867327197, 0.05222699771547157, 9.999999999998899e-05, 0.3895746614106067, 9.999999999998899e-05, 0.22350742494790732, 0.2109692203063399, 0.16367854913226143, 0.0004521552587269939, 0.27939252926068525, 0.5256203772464668, 0.3724013685827021, 0.25459745538542056, 0.2247173203951346, 0.23919978447493728, 0.5020831112957485, 0.4972277547861992, 0.4764890999696061, 0.13843346945437074, 9.999999999998899e-05, 0.09433938244126128, 0.2057614914093766, 0.2712743033565115, 0.14791163913436944, 0.21535185993089045, 0.1531026741081727, 0.2872109577868317, 0.2763111479891308, 0.2983128845361157, 0.30293370920652785, 0.3109669702444212, 0.3223461555522078, 0.26848007948085173, 0.2976052951372834, 0.3213266159116209, 0.33936906604196115, 0.7404704239782367, 0.7277578073304725, 0.7251499048909269, 0.7306858519574628, 0.6956547545105491, 0.7320657769713707, 0.6819549351048729, 0.7320005963580947, 0.7245373409742983, 0.13638138893974006, 0.1534861773263152, 0.08935795428693649, 0.141484158600774, 0.10145557098521163, 0.140176684472476, 0.13577958295951298, 0.14772343097747853, 0.1201002893189087, 0.19687856242545765, 0.17640876635186054, 0.14759419263258844, 0.16842107852837562, 0.13940101701190155, 0.15103737459263866, 0.22324598288623543, 0.146952322999777, 0.1445604575540339, 0.4555167439191433, 0.4703582490021161, 0.27945542052016425, 0.32284513730934983, 0.4693286175941165, 0.4565513570486426, 0.47944882899756647, 0.4478664408269959, 0.470154903141474, 0.2962009661930459, 0.39041398758099455, 0.24659007487829598, 0.420084576282894, 0.26964996331616164, 0.24931068733309658, 0.337375266800619, 0.3822320486889299, 0.256570607363773, 0.2261174206707779, 0.20837686177857617, 0.20216798092976374, 0.20894290693096085, 0.23746111316980179, 0.21468190495372752, 0.22497088972017987, 0.19642897175808216, 0.23534340392999642, 0.22406092687367352, 0.20580556240320758, 0.2413430706266848, 0.650173387237191, 0.19280419696186246, 0.22994016461676758, 0.24281829346306272, 0.21856274864866687, 0.22932215881846163, 0.19962233853647326, 0.18718782456185912, 0.18750323233099309, 0.8804347675049313, 0.9310894377345768, 0.17015123348500638, 0.16851238915249978, 0.8644284032982563, 0.14085148339003395, 0.9370469793488634, 0.2566580816871077, 0.20875207095965342, 0.21011668857419152, 0.2069166919854848, 0.20971650207153592, 0.2129134147769931, 0.21098251049197492, 0.2069836129613829, 0.18872805818010918, 0.19330679465542167, 0.18859826949444047, 0.17865516200466114, 0.185496874763878, 0.17973640383687706, 0.1899179987784292, 0.19022014931306508, 0.18017980730077376, 0.09762292820134566, 0.08807576609715395, 0.09488723875870053, 0.08257856985129386, 0.10728248381751104, 0.09155023510154603, 0.11129271538180985, 0.09379343380374683, 0.0729929815212419]}, "mutation_prompt": null}
{"id": "214839a8-cc0c-4ecf-b7d3-d04bab1ed12f", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                self.F = self.F * np.exp(-0.01 * (self.fitness[i] - best_fitness))  # Adaptive F\n                mutant = np.clip(a + self.F * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce self-adaptive mutation factor and center-based crossover to enhance convergence.", "configspace": "", "generation": 49, "fitness": 0.19587492466030726, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.6480218196118093, 0.22519959516549792, 0.14879710964645543, 0.19018241258058277, 0.6129096364833038, 0.31078745831931986, 0.2552074383494227, 0.325455355552121, 0.3646708911676215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.01004901451305229, 0.12954936039971598, 0.0, 0.0, 0.11911696216827117, 0.1115029423460655, 0.18698756573764308, 0.12574669331243515, 0.10642831506495642, 0.05378419967227421, 0.1591364115053322, 0.12193536093996571, 0.1841384673541906, 0.11595246619736788, 0.05077947699136531, 0.05735805654627657, 0.0846463687818999, 0.032854474679243184, 0.07982885032098597, 0.04428554873815771, 0.047157240620430474, 0.060834344620845915, 0.9833412747591075, 0.9341319500533848, 0.9812576720829747, 0.8584403384947514, 0.9107191670998142, 0.9760260386804356, 0.8239400294627136, 0.6886889035105677, 0.8644970395155814, 0.06925690977862264, 0.07946321811121249, 0.14375430035769587, 0.08075436912199407, 0.04687622822524995, 0.009551872731839106, 0.03639346598499249, 0.2086115940107386, 0.06081246531121831, 0.37758685954663473, 0.0750019555227307, 0.28636440779992356, 0.18154460777959125, 0.1004197691690073, 0.187174673876769, 0.18273617914757956, 0.15520369537437795, 0.37815055219068017, 0.0, 0.1433355880813637, 0.0, 0.14637483218462988, 0.17278053496461088, 0.042485650019784216, 0.4542354841123716, 0.46345511477829004, 0.1089638142692827, 0.2660496934895221, 0.22376601812762476, 0.028504482884259774, 0.16965023648526167, 0.01704337368835951, 0.20887362924413677, 0.13565030527706456, 0.11399812888249583, 0.12599850956170144, 0.0, 0.0, 0.0, 0.05794465687289119, 0.0, 0.0, 0.0, 0.057240253283183495, 0.0, 0.16446331496175082, 0.10362688184973523, 0.12247337286172655, 0.1370669765347149, 0.11775072970443401, 0.05611472798188555, 0.18829943487621803, 0.11072877554725602, 0.07825752098538796, 0.024636397225620055, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.13083624939664829, 0.10250342320109818, 0.08361028822764782, 0.23342746618394583, 0.14472635087581454, 0.174239942654962, 0.16793801041613265, 0.04604374419844681, 0.06599465365606316, 0.56052033680276, 0.30150748005996364, 0.4969296436543593, 0.4115612727919603, 0.26215856535338244, 0.5297601048810368, 0.5536662269309068, 0.5338075147013472, 0.5010126859941215, 0.14470868944316517, 0.13413581854359435, 0.16092392784786047, 0.11882165383109955, 0.14490019425809553, 0.1601186244920194, 0.03700593673561092, 0.10537474649452183, 0.0703175509751558, 0.13992286059052728, 0.24018410530354117, 0.16432592262470447, 0.15617386628355512, 0.1685257938002127, 0.2250080491184805, 0.2872382693211585, 0.3362281692693033, 0.11351665417745604, 0.1805526683179105, 0.169829956715694, 0.19642894240120046, 0.27149024084881335, 0.20815240256565293, 0.2971966373521696, 0.24571626071542596, 0.2579885864288979, 0.21291430001332123, 0.17575721739279326, 0.18651617092741313, 0.1771094317388977, 0.16394000683130538, 0.29997154360044587, 0.19452829275866002, 0.2563835141977888, 0.16595239907121684, 0.22757411871406108, 0.24599536916111808, 0.24899585175923622, 0.22227893933741238, 0.22462695081892448, 0.2436580790300732, 0.21149700517063075, 0.2359420418669187, 0.2084451636411303, 0.19679531998473054, 0.18718665423394976, 0.18060147809690785, 0.17439941752614907, 0.17976836971823085, 0.17726931771441812, 0.1837729814071034, 0.21259449229537564, 0.17898312041665776, 0.1664381838016885, 0.18652659717269549, 0.16735764186993451, 0.18158229217611643, 0.19269787954323003, 0.34249560318116545, 0.1914938821924257, 0.15774361663700875, 0.44789168077228003, 0.20964554970081062, 0.6085927327194196, 0.14418384388843275, 0.16850779127258286, 0.1657521779347546, 0.13596502986161363, 0.21091324315756554, 0.40754902441185825, 0.21325117792069603, 0.21130627658025958, 0.16409731151592277, 0.20983278594895804, 0.18872655846376252, 0.18327067549068832, 0.17445743769167132, 0.18237822306363194, 0.18685323070339632, 0.20051728087819265, 0.18546514974866257, 0.09659048404081039, 0.08981768326235828, 0.08474666828235278, 0.10292123729116065, 0.09720140535337485, 0.0830234722210833, 0.09034496878786358, 0.09253328535022587, 0.09405179405405839]}, "mutation_prompt": null}
{"id": "18eace1f-da7b-465f-84ac-fff859be5756", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = np.random.uniform(0.5, 1.0)  # Stochastic CR for enhanced exploration\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n\n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.4 * (1 - diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce stochastic CR along with F to enhance exploration-exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.4495474241688637, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9283626232083486, 0.9296329862921701, 0.94908807234576, 0.920829743261028, 0.9256345908396534, 0.938753606857302, 0.9386113527734768, 0.925666380399751, 0.9230121652895141, 0.782660571823041, 0.7848990308894515, 0.7931643120826773, 0.7748656093239732, 0.7484497418374827, 0.796488853580669, 0.7843271674241195, 0.7987020110089632, 0.8156454335426699, 0.12652154576244834, 0.13850948606077618, 0.1774786054362152, 0.13848013901795597, 0.21720831689590547, 0.136923142804801, 0.152132248006279, 0.148030708990454, 0.14570814181873215, 0.1136212639381956, 0.1287791885615749, 0.10961634452016622, 0.1215580385058933, 0.131506611807354, 0.09757367238432302, 0.12153396359022028, 0.13988432902723547, 0.13097264870986458, 0.96860534843316, 0.9661516782458203, 0.9721702816817837, 0.9697967926208604, 0.9656477634283405, 0.9808907568784996, 0.9803949886697455, 0.95746878310135, 0.9811826207249127, 0.707427302433765, 0.7094255225225597, 0.7318476927712718, 0.7551761680128439, 0.7084667302634724, 0.7490851410469586, 0.666208435938714, 0.7530759469611706, 0.739899603246478, 0.22899824120052037, 0.2571269823064707, 0.17123508121735231, 0.9526184600907329, 0.21399155802956915, 0.2828989270974023, 0.9390144619109615, 0.9525821441821178, 0.9613768654753021, 0.5497099219605495, 0.44589662244042916, 0.5996739254937657, 0.6784880600146823, 0.13021043349056582, 0.68435207249452, 0.7354039848326708, 0.13549400500013054, 0.6511721427563771, 0.7579792627298656, 0.5405174008445661, 0.41718321594284136, 0.6918456411485479, 0.7497771067178955, 0.4198765759794584, 0.6167270834643959, 0.5321548400059994, 0.6057107725280325, 0.6090593030004341, 0.5603546167724862, 0.18284890439218715, 0.5025380067355629, 0.09880883914808802, 0.2665177894754547, 0.45718249954115386, 0.6726054498742877, 0.6747605419332534, 0.3956725509007224, 0.23246237933465486, 0.5541262885638383, 0.21744681915619846, 0.32109391976495927, 0.30018117793737387, 0.5995332936249786, 0.31208401091522986, 0.6342134499720201, 0.15722346606845894, 0.11736639780219793, 0.41545972499964845, 0.3008739910091808, 0.4411720841990475, 0.4424545283551735, 0.3941193191733481, 0.2920882180385237, 0.17952645600139916, 0.463464380173903, 0.46708726274951273, 0.3741107385293473, 0.5384488098707461, 0.42514057289393303, 0.5246803611201728, 0.42386619270904957, 0.34589091583851017, 0.47269264363749164, 0.8323412085869788, 0.8497166822731348, 0.8398821805290925, 0.8700133652659023, 0.8106139974348274, 0.852478434054881, 0.8407564159972617, 0.8536607648003232, 0.8652606146813118, 0.12745312123608799, 0.10175041281688335, 0.13400307291420466, 0.10880737506829519, 0.11405180498768042, 0.13764516375974456, 0.18366495971648678, 0.11515373750252567, 0.1416566373253072, 0.1736503025307764, 0.16075619937119667, 0.1703611914496116, 0.15799492194194353, 0.1772663593658761, 0.1563857325224024, 0.15664074028707342, 0.172009936016832, 0.23089051383518167, 0.5412897608238876, 0.5224222502774201, 0.2944722816540116, 0.5297994147996884, 0.5086287617766077, 0.5571912807563498, 0.2743720386874362, 0.5534117165546122, 0.4872675095434874, 0.46384802082824694, 0.2823137897510567, 0.25669850956875495, 0.3082185747835233, 0.3193952098774341, 0.2893743041414174, 0.2201825114890893, 0.41837852967030054, 0.49921041482993067, 0.2202163494479954, 0.2027168625867798, 0.20955872119291397, 0.21118451405213934, 0.19178621228364023, 0.21133250272361848, 0.23416326607928206, 0.21135688973914346, 0.20945511695796026, 0.22499830716057434, 0.20719903202071543, 0.2451587237159798, 0.28653249939418024, 0.22784521655109413, 0.7304997845460712, 0.2493933656476115, 0.21144723830592127, 0.19855545723285195, 0.9038285609601026, 0.18757824357918162, 0.18764154498073793, 0.9405993371967767, 0.9285203350181759, 0.9092308004960723, 0.2005072569729094, 0.1630186952654249, 0.167667179709158, 0.7868990586105961, 0.21160710789401882, 0.9025360966940204, 0.7062570866500144, 0.21302248606783214, 0.19322184998462288, 0.7748749087763229, 0.8101590651816847, 0.7817082855612216, 0.18533321769259348, 0.19956478063534544, 0.1759751876404041, 0.18146314710908862, 0.19996654195789865, 0.17846894983478667, 0.18683576616801745, 0.17816711457730494, 0.1830167065051106, 0.08755455155492942, 0.09321496908884452, 0.11344539684046462, 0.08951860260629585, 0.09240956438067804, 0.09393622777409694, 0.09073506159716838, 0.09109737802518025, 0.10099587199551041]}, "mutation_prompt": null}
{"id": "c42593fe-5d69-46aa-ab21-65881e4bad8c", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            # f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            f_scale = np.random.uniform(0.5, 1.2 * (1 - self.evals / self.budget))  # Dynamic mutation intensity\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve convergence by dynamically adjusting mutation intensity based on iteration progress.", "configspace": "", "generation": 51, "fitness": 0.4485708786565539, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9198803147879127, 0.92921836176083, 0.9360654732613264, 0.9347440638769078, 0.9309066350079357, 0.9333017809982321, 0.9347931608009157, 0.9355833214166339, 0.9549841748529354, 0.8071453870130878, 0.7981469284606828, 0.8003996395105681, 0.8212968479885036, 0.8075376149749656, 0.8265477808382706, 0.8014626364376687, 0.8031937398079417, 0.8123231093272736, 0.14217160878081936, 0.1288413509031383, 0.14668287152213366, 0.1457545103927692, 0.1452116683073369, 0.1720000717502298, 0.16138640292864603, 0.1461245704539189, 0.14409313976267135, 0.13792949908158791, 0.14445074336688357, 0.13178138412342488, 0.12393604297948202, 0.11106248172538324, 0.11127179966083567, 0.13033047269378295, 0.11564870284858786, 0.12043488452823892, 0.9758427447409718, 0.9673391426336811, 0.9794362293857132, 0.9455877603963343, 0.9864510384435693, 0.980993773582081, 0.9753156220454665, 0.9687846211770541, 0.9807601748460785, 0.6968404708068832, 0.7788581716804293, 0.6977375845269015, 0.7250130803811246, 0.7461115364476474, 0.7266234115185544, 0.8054522865800535, 0.6461137854768692, 0.7670044208130029, 0.1410103212791164, 0.22378586702654102, 0.23179126997729382, 0.9328826985902436, 0.959038778474318, 0.9557466578984215, 0.39055086730937505, 0.18061127542779631, 0.24983829080202968, 0.5935415164426556, 0.7174145415747523, 0.5329116925844618, 0.1360416203449839, 0.49665395650216115, 0.5073507472347529, 0.35264709102846004, 0.491088920522335, 0.6388270460914683, 0.6089847828548514, 0.7302371141210728, 0.5626059937669714, 0.45195438349574046, 0.27515045116736925, 0.6134407976840117, 0.6996593658913814, 0.588891790551923, 0.61445176176286, 0.3715761322774317, 0.3878478921644686, 0.3871935860872894, 0.19043760128504406, 0.5317214676059996, 0.2239723972120411, 0.5392561566634146, 0.6434372295616211, 0.04445641343838269, 0.18414886465663627, 0.6099317701932809, 0.23874900555596945, 0.6366929616030615, 0.40196200056838627, 0.18531152916146953, 0.7645071645941612, 0.5572081342535791, 0.2541076730758888, 0.21878906679001087, 0.10205673275843419, 0.2543607186399922, 0.5532996467376388, 0.37003653808438375, 0.3707723965678982, 0.22523507483158778, 0.15160509061640604, 0.43644520482442417, 0.5268714295269362, 0.5266061475912697, 0.42195024894440836, 0.47438267115786625, 0.3537751531516138, 0.3613006815243228, 0.4470271283493027, 0.5388298117103396, 0.47147235955268707, 0.8395494763822615, 0.7177429457982573, 0.8466591843403752, 0.8938373152520974, 0.7231816988623725, 0.8600520442215336, 0.7725537085266299, 0.8802405479972161, 0.8576083055955346, 0.15693427502756474, 0.5746058596021999, 0.15243329124283755, 0.13301129848728177, 0.11066455660927677, 0.12301990412638464, 0.1524623002737111, 0.13961386564695655, 0.1219297490625384, 0.16066331445524262, 0.17443482450819192, 0.23664574862208643, 0.23594370087635197, 0.14705545359850125, 0.2492379573564506, 0.16647095123130295, 0.20065073674714373, 0.21503854912201303, 0.5552738706464417, 0.571125709588334, 0.5793831987316107, 0.5877844842866311, 0.6142955992442259, 0.36053382676390855, 0.598374598141699, 0.6385069782902173, 0.5278520548996308, 0.5161687701395635, 0.27197475973975704, 0.5531823196601209, 0.25364085406988524, 0.47489331967072423, 0.4667952837401881, 0.4726358924395365, 0.2471313907220134, 0.5918303290959874, 0.2602689115105914, 0.2174553578781947, 0.2191018862368248, 0.2201285664579513, 0.22066272761107342, 0.22454664802646784, 0.2351092994945555, 0.20672401897949388, 0.232122733062455, 0.24093570920217744, 0.3491426391360002, 0.24234724595356028, 0.18891281469248766, 0.19507824974539278, 0.24923361469941396, 0.449033159280261, 0.26718641350108463, 0.20324345851206538, 0.1856034840998806, 0.9145701887368151, 0.18816773958972122, 0.20079605455975646, 0.1988442260574128, 0.14813610307081038, 0.894676926508922, 0.8166239322117734, 0.9458006458330303, 0.9218091689017074, 0.7946825946881121, 0.21190176320137266, 0.2117330654681705, 0.20941880001333157, 0.16771245026265857, 0.7981877334418628, 0.8804087837174488, 0.16898869837844033, 0.19962616577110304, 0.18809323332487193, 0.18746720206650247, 0.18252166848350326, 0.18789577277399516, 0.185992145428311, 0.17514441175061057, 0.1770085777293927, 0.21301465367990657, 0.09575971732704658, 0.08825162370554573, 0.09586050160402537, 0.08389032473924019, 0.10861713231576708, 0.08049358952770491, 0.11833500482997406, 0.0941746096605397, 0.09489012479364323]}, "mutation_prompt": null}
{"id": "170e5ca8-92c2-41f8-8322-bcdd1620d38e", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.3)  # Further increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by further increasing the mutation scaling factor's upper bound.", "configspace": "", "generation": 52, "fitness": 0.4433633438022777, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9241874874757517, 0.9170332422632106, 0.9225118004731477, 0.9268577505672323, 0.9285219404069447, 0.9358810684589705, 0.9377936623672207, 0.9261609826452627, 0.9354690961977895, 0.8026328553117285, 0.7735937868927625, 0.7804779128452057, 0.7751099466991522, 0.7920249628256923, 0.7705788071254338, 0.7635694728352139, 0.7922270776489024, 0.77199510993818, 0.17382971202799058, 0.1419618158801521, 0.13018384751854573, 0.13534285034245808, 0.15072461956114946, 0.12902789216004562, 0.13961837421878975, 0.1308155126627939, 0.139593694418915, 0.12313805438009262, 0.12434837388342368, 0.12082399855099135, 0.12110183728847446, 0.12103126362277727, 0.12472704526041567, 0.14103792095821777, 0.1196329426202919, 0.12474642087127319, 0.9637429609319575, 0.9641150340306679, 0.9657372677373522, 0.9666991240379876, 0.9770340924250648, 0.9565365083775904, 0.9731110364964789, 0.9857788427608658, 0.9749881510489343, 0.6989645294410822, 0.6667715660180071, 0.7493900473585777, 0.7071338257662045, 0.7033599538264208, 0.6679905255655656, 0.6071125302223178, 0.7409977836795851, 0.7248937548855858, 0.17157938663707095, 0.9476094280841445, 0.9521161103176947, 0.3784187926247994, 0.9475512332486834, 0.38366167470390045, 0.24094718499899437, 0.23786754631454976, 0.36957267783564807, 0.5048935486300674, 0.5623784780980826, 0.44813077360040243, 0.6031722816162577, 0.7512846571393144, 0.5411680180595435, 0.4488328716454052, 0.49058213400194917, 0.588165148299433, 0.5877568682423568, 0.5372306020356481, 0.5192206332177501, 0.6268895100980078, 0.6085993649466421, 0.6496666324272753, 0.6059625249861341, 0.50863834753694, 0.5698080385804681, 0.31434478315098024, 0.366945287756415, 0.2785651802221135, 0.5113416503036685, 0.5707279709732029, 0.33781501552939586, 0.21317309915708216, 0.46566950983688693, 0.4906998487886891, 0.14660798711208523, 0.31803401577262447, 0.5942968901845436, 0.22760311468911498, 0.2267903686840521, 0.2735316700154714, 0.40998652358856935, 0.6812134182474219, 0.6263129071308522, 0.15324099458190032, 0.27524316777568103, 0.11805054156326622, 0.3335933290195813, 0.33028751099415, 0.47033780956835525, 0.1886611860075461, 0.19792577449679194, 0.22064399280997327, 0.3884408855473831, 0.387048000890193, 0.4495580031790003, 0.49778121024465016, 0.3792369669758605, 0.490903251739205, 0.42792079587781906, 0.4222329729060037, 0.44989586927214753, 0.8153203880803948, 0.7774011141594349, 0.8115096849043641, 0.8332921958512313, 0.8438610873397808, 0.7945119566362115, 0.8716298442404973, 0.8408579171837395, 0.838606074941997, 0.14072449405808674, 0.14697772608144877, 0.1443553084650222, 0.12804058143132713, 0.14075237717675915, 0.17563165272535752, 0.1247911864125234, 0.10719863307388644, 0.12594745498084392, 0.15718689046818057, 0.17239707726064935, 0.17284377598292355, 0.17524079563373107, 0.16344481912624798, 0.15472325827568745, 0.1387284773065257, 0.13879431406228815, 0.19997623931688002, 0.5467900221160988, 0.5568933360672619, 0.4906035360778155, 0.524223508814963, 0.5399487510456299, 0.29106567433558683, 0.5781064515850495, 0.537541907561111, 0.39096027433101876, 0.29459340005162993, 0.13144713841630296, 0.3298650810238656, 0.37666316149261514, 0.25293385915258837, 0.35373445844056917, 0.29383079778622356, 0.2361806079063986, 0.4425126716074659, 0.19660261879116037, 0.21907819759616465, 0.2063459295974973, 0.21096655394227004, 0.21396659111551208, 0.2133939009686172, 0.1925736967766537, 0.2215162726637464, 0.198502189723337, 0.20331859741613412, 0.2366786863761784, 0.21889439456611037, 0.5926438666402105, 0.18663622321467532, 0.20538637369463209, 0.1880723628386528, 0.6252184105574445, 0.2248205639392149, 0.9307263758795774, 0.9249611045789924, 0.18871105538433797, 0.19847905566993485, 0.9390771380326239, 0.19765637144015602, 0.5650631671280275, 0.9015661134724943, 0.9197127665391082, 0.9260621694572239, 0.9219944357765598, 0.1551353333353056, 0.20755045289934182, 0.7700165206465276, 0.7329465847034746, 0.21211469289316154, 0.7079276187103976, 0.16912939504412805, 0.19658559403196274, 0.18325150895243114, 0.1874514344029784, 0.17625423573446952, 0.18761632293960961, 0.17517360319249242, 0.19726058483241582, 0.18677415831556077, 0.1944994832261504, 0.09604409890729326, 0.09562338373758661, 0.08723157278801041, 0.09868734950488456, 0.10033163608475293, 0.0975457167754068, 0.10559011508997851, 0.09946047330854069, 0.09597859813496867]}, "mutation_prompt": null}
{"id": "ba91ca03-4b46-45fa-b1f9-c4e7c90b0d8a", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population + np.random.normal(0, 0.01, new_population.shape), self.lower_bound, self.upper_bound)  # Gaussian perturbation\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce Gaussian perturbation to enhance exploration by slightly increasing population diversity.", "configspace": "", "generation": 53, "fitness": 0.4345060599972612, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9044023949932565, 0.9246483768038262, 0.9229264267849764, 0.9100465697552327, 0.9234009277454253, 0.9134184138969839, 0.9165712899197012, 0.910286812875981, 0.9149862720605838, 0.7623972427293725, 0.7830588749082706, 0.7713276408971665, 0.7768602088863098, 0.7635297525228737, 0.7466137978621394, 0.7430210440057381, 0.7717803736846728, 0.7294378458556117, 0.1466674043178653, 0.13184089501524432, 0.13286989294335094, 0.14285589171812574, 0.13276269134325935, 0.11658421301782107, 0.13593595476755183, 0.1484878319452151, 0.15880956151388215, 0.12235472293409533, 0.15213803041317464, 0.08622058245615316, 0.10016095676858183, 0.12458258587890692, 0.11820925226872991, 0.13737183284353027, 0.11781257701733017, 0.11710939277063914, 0.9691105856478203, 0.9911452937207601, 0.9834565359438363, 0.9683217823768868, 0.9878956751581367, 0.9580261759696165, 0.9587692076412373, 0.9765588336018755, 0.9867657066011302, 0.6610316528767515, 0.6599810981937028, 0.5592620883191874, 0.661038872780666, 0.7086590085030962, 0.687383860825281, 0.6439581469534481, 0.6463550720165079, 0.5883006276904302, 0.1585162412203177, 0.22672280677052292, 0.22270120971188312, 0.28476237507774027, 0.79947993459731, 0.3870154093112187, 0.40958469307956635, 0.23474260535346447, 0.23739610879565276, 0.6377620805329698, 0.6695103442267075, 0.13455190836629394, 0.7130953357128185, 0.6370431132498786, 0.6041766032743906, 0.715594097105398, 0.6302571316786878, 0.6235555830251278, 0.5595882484373065, 0.6988823138303053, 0.13749048839550193, 0.6575380223430634, 0.6593161633675018, 0.6972996751565286, 0.6455771786278326, 0.6824700464670632, 0.5577113451977629, 0.42071491960127694, 0.35385250201209595, 0.5642740468890892, 0.5184626486788793, 0.4298308272985365, 0.3174509593491214, 0.28407161445100126, 0.4146073791869376, 0.48248476818774166, 0.5080145040122308, 0.6738561418552513, 0.5396646921447064, 0.5706018399980778, 0.40330024398347886, 0.5593722799367956, 0.6607221748348842, 0.4715818248667888, 0.6346425395668485, 0.1789775452177237, 0.24910650786362132, 0.3010413242944403, 0.31455003318145724, 0.4312822290765995, 0.34499643594668694, 0.18144085502201968, 0.3651586349785684, 0.25888058082033405, 0.4345474481394659, 0.4427444055871108, 0.46686444595090804, 0.4326516947732, 0.47893775822178863, 0.4228018442325009, 0.4005517869670543, 0.5084137422885993, 0.39246743297021547, 0.8305780860483674, 0.8591221878646511, 0.7809657439961297, 0.840754351924431, 0.8059553392552137, 0.8156661295566702, 0.8090705076884929, 0.820703431091195, 0.8212681523485381, 0.13387758240084802, 0.12136917952932513, 0.15690473891500245, 0.1523620048634824, 0.11760433540773652, 0.15920039801884045, 0.13178248086719846, 0.111929459984341, 0.119752813952549, 0.17584223688427136, 0.15904939042107635, 0.19649237973506672, 0.18849183653794044, 0.16814040546629772, 0.17347544835091044, 0.18190552984823694, 0.15640850411433715, 0.16140643305186875, 0.44998964829484256, 0.5199765540432397, 0.5241333308015991, 0.47991323616943415, 0.5016495060265305, 0.5415668429391927, 0.56780782103636, 0.49702889407181994, 0.49530656010135077, 0.415830474362306, 0.3940206594673744, 0.43522587299457094, 0.4158491126482591, 0.41208302892030135, 0.37022381361594836, 0.2118027335753414, 0.4259201157797651, 0.461256858942682, 0.20940828469598827, 0.20985883778481018, 0.227552929837472, 0.22675311699936251, 0.23121637962808872, 0.21530464735383814, 0.22178124574482938, 0.20464024968830608, 0.2065121854932298, 0.24388445354981603, 0.19367645211819107, 0.2019864788213973, 0.2253494685689792, 0.20514224843435636, 0.22283732642412257, 0.2439849721398788, 0.21794113102558654, 0.2377974254372307, 0.18486854605193648, 0.18752449305099095, 0.18718173366291502, 0.14876032398671213, 0.9590262553561483, 0.1688217683495704, 0.16315885063475866, 0.7472382624882548, 0.17000471749834356, 0.9033405179476561, 0.8502575101747436, 0.16890535474116475, 0.21317425679985302, 0.20176922860417923, 0.20824260628685398, 0.8698885975251385, 0.8185820818361121, 0.900787646256697, 0.19212074338905616, 0.18482246279272885, 0.17661740491775724, 0.17555309317827794, 0.19241475225911842, 0.20129762833624687, 0.18232992215110755, 0.19789030755716075, 0.1857992696326477, 0.0853847114751205, 0.09204952292381352, 0.09997389373636889, 0.08965532312090052, 0.10388458061752137, 0.09481626050925063, 0.09996253378731035, 0.09832746996045061, 0.09081390591133653]}, "mutation_prompt": null}
{"id": "de1555ae-a3d4-473c-9e79-2a6b6bb3f479", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.3 + 0.6 * (1 - diversity)  # Adaptive crossover rate change\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                levy_step = np.random.standard_cauchy(self.dim)  # Lévy flight step\n                mutant = np.clip(a + f_scale * (b - c) + levy_step * (elite - self.population[i]), self.lower_bound, self.upper_bound)  # Apply Lévy flight\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce Lévy flight for enhanced exploration and update crossover adaptively based on exploration-exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.317226643326833, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.8616226613563571, 0.8719458274115781, 0.8513445471263449, 0.8516547027599837, 0.8652370283846945, 0.8307042415042392, 0.844329291646376, 0.887032348753348, 0.8519081843681066, 0.43493054787701524, 0.45309680608437053, 0.4145226150340021, 0.432029947341831, 0.43738727578444014, 0.41636411423298136, 0.47061821277051263, 0.45726746878364033, 0.41457841542582763, 0.14303456818329963, 0.15813484429212188, 0.15739485574527734, 0.13580698062597507, 0.13770508905186396, 0.1611242555691379, 0.15211914435142604, 0.1418994132502387, 0.13829605421426627, 0.1353397858110813, 0.13007867779800542, 0.12355045908270257, 0.13148828187918482, 0.1253567305946366, 0.1346279383872956, 0.12238162371889971, 0.13203922144167413, 0.1232007960644903, 0.9480408802791894, 0.9483344756492531, 0.9470848820688164, 0.9522068210849031, 0.9404498699016322, 0.9651425371306844, 0.9624610646862538, 0.9694284181480367, 0.9661533228758268, 0.5325477290037951, 0.5471836492157058, 0.5406540575481056, 0.5377763542968714, 0.5551840492019834, 0.5593026630917997, 0.5196070682158903, 0.5327490638509076, 0.5186156303700014, 0.1542904689596153, 0.20698991169337633, 0.24242988083452377, 0.39147692080440755, 0.9436784133166617, 0.9519853551214734, 0.23874718627277836, 0.9286499467246689, 0.33169281954757646, 0.1321077856569033, 0.19702151457319772, 0.17805213025145583, 0.13253908260942204, 0.20864495070883882, 0.20535607186997507, 0.2323627055848323, 0.21896857000256964, 0.1789684189999896, 0.21826709039479897, 0.22008912532241054, 0.2920352582175454, 0.21096824087820965, 0.13645557045285717, 0.230068850659504, 0.24942039019079543, 0.23105927795518888, 0.1325547243398052, 9.999999999998899e-05, 0.04481309025769764, 0.045088986755854266, 0.12209753918373012, 9.999999999998899e-05, 0.08317882359119211, 0.053855547963290284, 0.05900087991019776, 0.06327970805491423, 0.07828065117355654, 0.16239694626428558, 0.19099856553549976, 0.33447437858051643, 0.07917331473037226, 0.06930142080058632, 0.17868049794731722, 0.23859485431127525, 0.20135418425793083, 0.2049077050976703, 0.1373343022988367, 0.16939119285133475, 0.11634556585068678, 0.1072900407885441, 0.2409377322913705, 0.15953410916040944, 0.24398881040267584, 0.18868008845457906, 0.14170999125872152, 0.17368145623142206, 0.1707589711416918, 0.12504880791610007, 0.2081969746505553, 0.11439787181662664, 0.1252392015758882, 0.22877316274864368, 0.1744387390403701, 0.6126195749881672, 0.5458371201773669, 0.5728294495958398, 0.5659313739734357, 0.5721274289899704, 0.5902350962530596, 0.5880426285524362, 0.571958039160648, 0.6005896974640503, 0.14117020304058092, 0.13660987889260756, 0.1340509072113546, 0.13612431259758173, 0.1844749649077304, 0.11136641772987954, 0.12185979983119577, 0.14101009770542916, 0.32735567014336864, 0.1688023282148573, 0.16493131755279555, 0.15697689952364202, 0.16458280761217225, 0.1693689625934539, 0.1743931889572795, 0.15861899521887957, 0.18591873098743994, 0.17931271169188545, 0.3032901107012723, 0.43766376601097, 0.45247835386275614, 0.4521831892217265, 0.45865293519463635, 0.4593115827066555, 0.46532488420766227, 0.3329408433069255, 0.44598498121228425, 0.3103809092238321, 0.3708554690331404, 0.36714906483745247, 0.2999298174113807, 0.26314441601636696, 0.34699905853570867, 0.3671194663652998, 0.3622032427837628, 0.38669610771830887, 0.22462212186373742, 0.18781296795427238, 0.22031550418754875, 0.2130661842606857, 0.20369460298257502, 0.21411006994465487, 0.21248434525737925, 0.2256409241420979, 0.20595173135776346, 0.20393787718312728, 0.2152605917553534, 0.19450909949130568, 0.24907448652723596, 0.19895756745319926, 0.19935220245923913, 0.20838511270499604, 0.2369410085049124, 0.1970000806399168, 0.18811997825195892, 0.18459816565803444, 0.18887849331603423, 0.20076385483482584, 0.16191454396060012, 0.16566365667838456, 0.1702096756324416, 0.9070539286913909, 0.14533062114268924, 0.7714002829065318, 0.9174114094177539, 0.21064336566145814, 0.4955699118032836, 0.20487490141557207, 0.53783616822652, 0.6004396215020277, 0.2122234653500663, 0.2121067264850296, 0.18144970487260914, 0.1924033536828098, 0.1771014680465316, 0.1937883863253803, 0.1817625983530714, 0.18698075389114044, 0.2037773363628943, 0.20344355622654653, 0.18607896222555398, 0.11024766514024664, 0.09056355376936609, 0.09222909196288542, 0.09443494530394714, 0.085522373284041, 0.09601858647944339, 0.1182893008247714, 0.08912216820790797, 0.0887988339503043]}, "mutation_prompt": null}
{"id": "ce2083b6-7cad-44af-a3ca-9f3ff6a6e6a0", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def levy_flight(self, lam=1.5):\n        return np.random.standard_cauchy(size=self.dim) * 0.01\n\n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.5 * (1 - diversity)  # Changed scaling for CR adaptability\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial = np.clip(trial + self.levy_flight(), self.lower_bound, self.upper_bound)  # Added Lévy flight step\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improved exploration using Lévy flights and enhanced adaptive parameters adjustment.", "configspace": "", "generation": 55, "fitness": 0.3129666602252699, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.7577427741592178, 0.7425511784552388, 0.7659967913692038, 0.7381913907489602, 0.7485960109042546, 0.7416920647556839, 0.7333079456368574, 0.724757039782477, 0.7259918182205047, 0.35305772379321343, 0.1700206974046643, 0.21154995136884114, 0.14763599064370359, 0.3244577176502409, 0.3137759645312871, 0.34744197885185024, 0.346502503121885, 0.3448772171233151, 0.14389604710155057, 0.14458901036109106, 0.11844848141882991, 0.1469350393933, 0.12048856070051539, 0.1227884847109817, 0.1434446248718363, 0.11940389998811973, 0.13961984361972568, 0.12788314581222293, 0.09814520470671018, 0.1220422138692957, 0.11185234917871534, 0.11326862119946612, 0.0985012775590629, 0.11169409485689852, 0.12008233621901565, 0.12599696100245494, 0.9638174780573556, 0.9403235104200112, 0.9394711269970746, 0.9547484794087254, 0.9711694980445011, 0.9654184021692179, 0.9431015566348563, 0.9504769121525252, 0.9511099010033212, 0.5367157015040889, 0.5376294845791373, 0.5445658308598146, 0.5505337513086668, 0.5423531687985925, 0.5567126337989332, 0.544951489076041, 0.5377368608731758, 0.5421742655593669, 0.2205798273153028, 0.7782614048988734, 0.8208564368401807, 0.28438760886060843, 0.3954828784194069, 0.28248947497737675, 0.9558075624327881, 0.2495601421250322, 0.22352128060318666, 0.2383573472394228, 0.20802029447989556, 0.21807456868576125, 0.25051852069087177, 0.25109680202103, 0.2647782348004242, 0.23437287577742139, 0.22705089084395957, 0.2132405025839469, 0.2637349306648865, 0.22605396604416694, 0.22733087020750486, 0.24658489257462246, 0.23362380996313592, 0.22953492507811368, 0.24201628455768642, 0.2608146555563594, 0.228697423932251, 9.999999999998899e-05, 0.011076277032315396, 0.08419623504758167, 0.08352263979885122, 9.999999999998899e-05, 0.07500755669143022, 0.2398878913116428, 0.0960098100048814, 0.12595557160841275, 0.13696517648440698, 0.3491447860031017, 0.11621398938019478, 0.14626855912860026, 0.10803892560997141, 0.15773802060736508, 0.29034695979608083, 0.1384078776859995, 0.11478261573717596, 0.09198582341233508, 0.184188682749426, 0.1636873521358102, 0.1944543785949675, 0.17871762183322604, 0.08375728058027632, 0.16642541773958308, 0.07860420577322114, 0.17275463636172572, 0.2640756779308333, 0.27902977277093644, 0.23280843427609454, 0.28015654600590056, 0.2712524666440277, 0.26249633330270983, 0.21357435597480334, 0.20465878437394713, 0.26987253920161147, 0.6111368422422587, 0.5341851468334033, 0.5470245596538883, 0.5942289929534879, 0.6187671398440784, 0.5646307163547877, 0.6072831900616957, 0.579040321313087, 0.5585314157767964, 0.1806739724316312, 0.11973960703240505, 0.1414771976382192, 0.2288832379114698, 0.10403017753234567, 0.12390028092463179, 0.14864687295900259, 0.13484245200359068, 0.14468493819179784, 0.2218650031192151, 0.16825590537291502, 0.18647317568781352, 0.15933579170187662, 0.19913248860317212, 0.1791831447587574, 0.22384176537295564, 0.15732115462559393, 0.16224841332082873, 0.4224331642412972, 0.41121142210890826, 0.41952783308981223, 0.4505795741054688, 0.4334226127236177, 0.428447144615137, 0.4430005685107691, 0.4389869074832472, 0.3566402267748483, 0.2416761382783318, 0.2814771626545215, 0.38622976004961096, 0.3505026445648105, 0.2876899087477517, 0.24636010747962334, 0.29500332189998335, 0.2728326626173976, 0.27171955471737996, 0.2199689471194165, 0.2027107981177746, 0.22780003521859193, 0.2467778188924381, 0.23053643779286526, 0.22830995781719787, 0.2473770691335926, 0.2257945440339323, 0.2294487939419383, 0.2519914612399268, 0.25143461939567646, 0.2049988732608482, 0.24609015856425942, 0.2269400392029648, 0.43554755220890784, 0.3364424603770285, 0.30109242659392144, 0.22128674031156792, 0.18878459994077335, 0.2100700716713928, 0.9053360270795353, 0.19938240141386654, 0.8750243812176794, 0.20041904743311012, 0.1629649610703202, 0.16678029766770708, 0.16315551399870987, 0.6656002021966907, 0.15405829618947942, 0.16775574176695351, 0.21068925249729697, 0.16672251661421977, 0.16905514028154356, 0.9311335819070805, 0.20896727688860217, 0.7789766832170697, 0.19460640785680494, 0.17882741161336635, 0.17891412133071172, 0.2072096516158306, 0.18755372636900758, 0.19835311849565584, 0.1954906526105753, 0.22141433980151104, 0.20075855904325346, 0.10210342916637949, 0.09295789572916091, 0.08462926789763936, 0.08991055577194962, 0.08447282807117185, 0.09267465838027822, 0.09507497929425024, 0.0974143834576705, 0.12055465689373268]}, "mutation_prompt": null}
{"id": "c3271c96-de35-44c9-839b-88a18de19570", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            dynamic_population_size = max(4, int((1 - diversity) * self.population_size))  # Dynamic adjustment\n            for i in range(dynamic_population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve diversity by adjusting population size based on exploration-exploitation balance.", "configspace": "", "generation": 56, "fitness": 0.42911345170929377, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9131546492562219, 0.931411196098833, 0.9402012250113495, 0.9320140893541754, 0.9135965944181714, 0.9256192335910827, 0.9183200423384664, 0.9343522272731343, 0.9413284320693748, 0.734260004588325, 0.7699821493661193, 0.7816351435012427, 0.7704330985944347, 0.7500825038629867, 0.7393327236201923, 0.7544412613039299, 0.7760598768280687, 0.7231110229473473, 0.14724139734324215, 0.14488965670893883, 0.15161045920397487, 0.12906527671017953, 0.12080388963294209, 0.11215252123479202, 0.16429873652346338, 0.10582951210188019, 0.11050184681333508, 0.12438769615816159, 0.11269455894493752, 0.12768428716684088, 0.13098059697759923, 0.08660692868560982, 0.08258153370668553, 0.1362733319235807, 0.09978783524475277, 0.11783737086607837, 0.9519518645186907, 0.9794110740900591, 0.9653857403197117, 0.960440274683305, 0.959523475015817, 0.9359008162578747, 0.9406354097061523, 0.9775343406664496, 0.9373021528521732, 0.7245678517913026, 0.6559942664688005, 0.6253896433245707, 0.6915843347994042, 0.6696730461032518, 0.7096026220853959, 0.6606969879704723, 0.7134297333909779, 0.6386611772870612, 0.18799141008663534, 0.2293066522290148, 0.23180241393366896, 0.2859194021731616, 0.9544159967214549, 0.28324830206594187, 0.23945564722730373, 0.17071924190200805, 0.9614044348642194, 0.526179079237076, 0.658376177093912, 0.6193314838852437, 0.13613137102565853, 0.5688346392392835, 0.5171997842064833, 0.5126925690625521, 0.60505672828832, 0.4606466286765625, 0.5768347856940692, 0.5794052833991421, 0.44811468087446726, 0.5792942302433861, 0.6198929546660408, 0.6533673710032915, 0.686641579921407, 0.5141599982582346, 0.49432266540153047, 0.41426132160009055, 0.26589312842153945, 0.3622813499664962, 0.4464999991588323, 0.611479383604637, 0.4881156162614241, 0.34042680370346645, 0.4994566054534594, 0.2706123297573254, 0.12692369104305457, 0.48383204506483135, 0.26147020102226026, 0.5113128537274949, 0.318840772979579, 0.12715237390004552, 0.2673073688784853, 0.6987230286238963, 0.4159662070567499, 0.16940868650134855, 0.20033673589062495, 0.10813063906682074, 0.2644157133260209, 0.2571159109680098, 0.2712944978315618, 0.17835522122594105, 0.21384934424222823, 0.11667292172332744, 0.35529906415919355, 0.42684076850305597, 0.44838220388296235, 0.4519346709067157, 0.45415300559818295, 0.3690598241432502, 0.3289852303090953, 0.41072362575913013, 0.4420388451904623, 0.8591831541963675, 0.7597111903704336, 0.6632625081573682, 0.7953387782362573, 0.8401653897111747, 0.7616402705407959, 0.8012200070398936, 0.8254865551019498, 0.8283690221972804, 0.1584741747708951, 0.09128511435668529, 0.14074518713500928, 0.12767564628322947, 0.6608344262966941, 0.15131658774667578, 0.0954866820197613, 0.15255613641209387, 0.1109335293200796, 0.48817304250939353, 0.35468870418188925, 0.13840394772050113, 0.2309457830710956, 0.22051354775218646, 0.503823377495281, 0.15491710528969982, 0.2506012818222313, 0.14302496020136912, 0.3410065699931355, 0.35762596197448693, 0.31839472431556504, 0.5474773806627051, 0.47010880473374805, 0.5191988273196555, 0.3347879850735924, 0.5570275975647703, 0.516117011404672, 0.39472207915300905, 0.2711740027373293, 0.20973912251143134, 0.4460049148693035, 0.3603898073932301, 0.4389845230802365, 0.2675346199566777, 0.2690903562047169, 0.3197445925853989, 0.26187302413703517, 0.2521333789836908, 0.22117899401108576, 0.23722338506703755, 0.2243638378760473, 0.2707823917958234, 0.302669753115245, 0.22494006268315736, 0.20577229018708154, 0.24976625668894248, 0.6752337293194844, 0.226054978479861, 0.2064859707293324, 0.19999473856519467, 0.21625083131005707, 0.24202453096289078, 0.1900493887066248, 0.2502156440196901, 0.18866148755975864, 0.9370893558290794, 0.18904561121131713, 0.9440508193303268, 0.9391790515378078, 0.17314839819153038, 0.15768251698715918, 0.874216233570239, 0.13625884949020273, 0.9110013256822632, 0.9281147227346472, 0.21227096291519731, 0.8347097548985558, 0.16813930922292453, 0.7627390187753764, 0.15609491605569492, 0.7888001174757389, 0.1694356087766561, 0.191204682300252, 0.18739642789559074, 0.1842042607651403, 0.18245137823118762, 0.20680357014659012, 0.19952491635728598, 0.16872686874311182, 0.18976758141641203, 0.19160684950267592, 0.08713630039197628, 0.11281007349061378, 0.0946795613829341, 0.08982766993603031, 0.10878942044512951, 0.09121004566425728, 0.12493653218263423, 0.09592938419758235, 0.07539858567176105]}, "mutation_prompt": null}
{"id": "f644aaa3-4f0e-4d37-841d-68702997fa42", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2) * (1 - (best_fitness / (best_fitness + 1)))  # Adjust f_scale dynamically\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve convergence by dynamically adjusting the scaling factor based on the best fitness found.", "configspace": "", "generation": 57, "fitness": 0.31602774411636464, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.957470256428868, 0.8784907822928825, 0.8538367777591391, 0.7433770954748129, 0.9096147955871272, 0.9049623101713478, 0.9506944987984907, 0.8128187223070447, 0.9500140866933422, 0.3595606922050322, 0.1631843609843403, 0.8973542351903887, 0.8925642049132989, 0.10759977048366143, 0.22290638264350515, 0.08487339109901226, 0.5900470926376014, 0.2899431729424824, 0.2167907189719177, 0.37906560477505513, 0.1662950800614038, 0.12922909917774783, 0.1376191126686206, 0.13986927339980193, 0.14815402673620737, 0.16183543888580443, 0.19160479108224626, 0.11853856549362285, 0.1335599535330021, 0.1132514654948713, 0.07677797756089388, 0.0783070027765721, 0.11603386741987975, 0.16716857111723726, 0.10462168972643981, 0.1461393508603911, 0.9621519077058828, 0.9676496573081551, 0.9759941451770882, 0.9566047059528008, 0.9795536781304096, 0.1663508167244827, 0.9576209568627927, 0.9601689128502828, 0.9650215908475606, 0.4740195963333782, 0.8094710361345832, 0.10098980175659766, 0.48827244360221533, 0.4155530265229781, 0.1014472420175494, 0.7597454307981619, 0.5052379763651175, 0.5431138235314565, 0.14053954462226415, 0.15979997093564724, 0.23145795081993692, 0.391073538852737, 0.2805438637655624, 0.3890522266219828, 0.19839328194476902, 0.9576825823222246, 0.2230362104795106, 0.4019949301136838, 0.22765935384768776, 0.1357173046500053, 0.2304644938447864, 0.24443477087409637, 0.17388476124740315, 0.2025037461010737, 0.2484854555458753, 0.16052417218770754, 0.20516909235830694, 0.21367712332519884, 0.3891662141096055, 0.2765866431011865, 0.19433911084019984, 0.2124789223966761, 0.19075451911690844, 0.1358238946556688, 0.1926952538611546, 0.003496416726908702, 0.02017532219150564, 0.018345081847050304, 0.14169358954703515, 0.06017365659178775, 0.2901923936341988, 0.09832356899000694, 0.11826097594260487, 0.0631033887648802, 0.07078356077929526, 0.12648044132811842, 0.14565581635777003, 0.1286396199302079, 0.13790734898568846, 0.10874616201303033, 0.2912897549505502, 0.19841569048847052, 0.15100360350204645, 0.04875251220425858, 0.08915429108302908, 0.16868016238372197, 0.09471645985503763, 0.2160667971804694, 0.31590942284798595, 0.150949728854732, 0.1033314984183682, 0.28755826215262936, 0.0909130924556163, 0.1442588503212, 0.06589839429920352, 0.18380205081866996, 0.20355984347528633, 0.08759895487332958, 0.20792821225645453, 0.11946070430990785, 0.13955042429143272, 0.5979542029261475, 0.5629043011904384, 0.6366450060484601, 0.6237426925800296, 0.6242011842327906, 0.7405649778051575, 0.6187356015403083, 0.6197320943547718, 0.6016147047148932, 0.6263404692876388, 0.13152597810093325, 0.10936839164972256, 0.13411401013839808, 0.13501352457547733, 0.17277434095079003, 0.13413196143751138, 0.1802332179433821, 0.14070116051099868, 0.14873233803567876, 0.18745806491319794, 0.19758118090106602, 0.15093378266828716, 0.12712869442407004, 0.13094704623758224, 0.20403755701535142, 0.1878625981549643, 0.15016121788843173, 0.2919525839494399, 0.2543405071100465, 0.3524295882122843, 0.35446979484467833, 0.36781282070989496, 0.5536219340982996, 0.5447810535136902, 0.5701729579986122, 0.5167239742011815, 0.2865583315461564, 0.2414141455382084, 0.2863071258584392, 0.3421696747227696, 0.35748087618614577, 0.4583011344535761, 0.5068611730652557, 0.31704046575586564, 0.16996513539191205, 0.2227309849414213, 0.23011383188467305, 0.2502903747760722, 0.2120426349223763, 0.23402269300596035, 0.23093604319611172, 0.22701095540555616, 0.23216122445488863, 0.236763299798046, 0.19029954154789863, 0.2497130404149922, 0.17943330941383917, 0.19090846063873157, 0.2494270255570573, 0.2116774990727659, 0.20012823268791613, 0.6840213957458894, 0.2489652061997426, 0.2005229736738956, 0.18650294787550004, 0.8384289683057308, 0.14713124963644275, 0.8950822777988977, 0.19973388443872342, 0.17921942089901988, 0.7696953712822974, 0.25150820803648677, 0.4818592398155117, 0.7917156619055303, 0.1678057185578502, 0.1998560627366458, 0.7437721342480398, 0.21168232481622162, 0.566536524299204, 0.21282482298623018, 0.16565986548641576, 0.20727991296151016, 0.2163362756834425, 0.18946169580989858, 0.18520949970342415, 0.18660307134730791, 0.18113628925844782, 0.18589402000618294, 0.20362809144068328, 0.195749060268387, 0.09247303140626717, 0.08109106134695943, 0.09348526896416165, 0.11182621993902608, 0.09461365134215427, 0.094058576241704, 0.13752776414824253, 0.09385749740589655, 0.09217879984562638]}, "mutation_prompt": null}
{"id": "8398aff0-6095-438f-a047-64ec5f86b6ca", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.6, 1.0)  # Adjusted f_scale range for fine-tuning balance\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.6 + 0.3 * (1 - diversity)  # Tweaked adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Adaptively refine mutation and crossover by balancing exploration and exploitation strategies.", "configspace": "", "generation": 58, "fitness": 0.42200295514861996, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9190040744570604, 0.9242645612252507, 0.9446568831899598, 0.9290492324080034, 0.9364685818035982, 0.9350094623202014, 0.9218110830389941, 0.9346262402576498, 0.9179747164628037, 0.7906816073560834, 0.7850845408447633, 0.7950352325160811, 0.8044635060097368, 0.8158834361156427, 0.8057266880106054, 0.7887043844889716, 0.8062857301620395, 0.8053735186943594, 0.14995102298799434, 0.1345756021992327, 0.14009464529566262, 0.12592250649991454, 0.16165312753861238, 0.13843492871144358, 0.1405169849060649, 0.1271439289802354, 0.14547976620396808, 0.11698463684189486, 0.13199202362226037, 0.12192604497788873, 0.11523077605249932, 0.11284170154378659, 0.10380196316521628, 0.0979460900605853, 0.11705458371915667, 0.11126412825552301, 0.9690689228298961, 0.989098852245751, 0.9457005252320617, 0.9673386849333566, 0.9776520460679183, 0.9425853420621323, 0.9750162386517658, 0.9565115789388363, 0.9738800086294666, 0.7040049594653475, 0.7564148973002411, 0.698615835276575, 0.7514961454402698, 0.7401484640862999, 0.7023027499779516, 0.6292603829794057, 0.7080421718297123, 0.6699477946076078, 0.37860944514030226, 0.19468009595000302, 0.22906425897648852, 0.9674036611357802, 0.2806938926350838, 0.9314834790355845, 0.24898507698245997, 0.933479616039087, 0.9556781545965984, 0.7265203236871111, 0.5991024015941151, 0.5685744938041295, 0.7532652721321239, 0.6941589062658363, 0.509310669591862, 0.504291517595349, 0.4817255341054115, 0.13705141164125711, 0.4250031014679124, 0.5311781726482024, 0.576726652320678, 0.6278462900013944, 0.6367017348803827, 0.7459228002285807, 0.48336407977479845, 0.5566947385514444, 0.49492336164827777, 0.5854203497582255, 0.33853338350914997, 0.5662489986241377, 0.47859646319851856, 0.3692876945049012, 0.7034001068539946, 0.26729515818154337, 0.5698232326975434, 0.29208597573431627, 0.38828406159612483, 0.31773418455436286, 0.16254003497841119, 0.21591291051429595, 0.6390404657823755, 0.21507234194387848, 0.35319026629275097, 0.7634510411491672, 0.48696434074169614, 0.15095594828586123, 0.25725386865293054, 0.16192696987029054, 0.4686384318416884, 0.22985446795139952, 0.2872286673505601, 0.15272934504437885, 0.35227153021217195, 0.3545548130578604, 0.32912174771371916, 0.5222532388062566, 0.48784298044666907, 0.46088005238091523, 0.48244894317239695, 0.42762104488036534, 0.4655581160672173, 0.4867603022837502, 0.4081231181056444, 0.8742679470049182, 0.8123378431883672, 0.7878143704649951, 0.8166151942836819, 0.7312172124372331, 0.7836689433880608, 0.7980118181485553, 0.775658908264554, 0.6919209090792297, 0.11305150303762623, 0.12976778669230482, 0.10967266254445407, 0.15430595848866646, 0.11374777564248018, 0.09747878695466605, 0.08794907461939583, 0.11269754874877658, 0.1304134400605217, 0.22774773657544167, 0.15382803392193545, 0.15261385681304018, 0.16882889054084949, 0.15546556308258064, 0.13916857234022906, 0.1531652270401137, 0.17879903062834945, 0.1603990047438314, 0.5439073576829749, 0.566121500619159, 0.5682045517515987, 0.5331898070558392, 0.5611921995601739, 0.5258913947810975, 0.3122722314234845, 0.5338017274679452, 0.5649291567739966, 0.23746125902408233, 0.44508212199130737, 0.23174813463476562, 0.2403627545244288, 0.2640149797588195, 0.46280835413089993, 0.25718341895160135, 0.3448399038257244, 0.2324579454325979, 0.23780893657419577, 0.22133612272055136, 0.2194569257458947, 0.20945909033302568, 0.23377880832319553, 0.1919609601558776, 0.22255627113701526, 0.21478246122506273, 0.20905137672937357, 0.18333042965518653, 0.22646443254251025, 0.20055274713293592, 0.22341232426907576, 0.1987547828464966, 0.20436322444808452, 0.2011342275830571, 0.21643703559641625, 0.21348665133639866, 0.188388339971575, 0.18759579103140434, 0.18678534979337758, 0.1654227557054888, 0.8956258831630269, 0.1963053731873433, 0.1582025316082314, 0.8882547089883044, 0.17097977443524648, 0.21298994154072293, 0.8185703910276867, 0.16938498542757896, 0.21415146237194516, 0.1678418871532047, 0.21245797613147455, 0.21143104068595253, 0.21256821960236183, 0.21149534662152114, 0.17909512809699113, 0.17592152911353842, 0.19831069646449828, 0.2034691466133055, 0.18058977745149973, 0.2007559214838378, 0.1850392531027366, 0.19509584802495583, 0.1893671464817277, 0.0790902669668887, 0.08486990534353667, 0.0876266439277269, 0.09948020044978834, 0.08001774468817913, 0.09752833574295383, 0.12707085359253412, 0.08326558414754748, 0.09203608483546011]}, "mutation_prompt": null}
{"id": "933be1c3-f495-48f7-8acb-debecb6f89ce", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by adjusting mutation strategies with dynamic scaling factor and adaptive elitism.", "configspace": "", "generation": 59, "fitness": 0.45924502936579653, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9269351805220212, 0.9228973734260824, 0.9293969182802839, 0.9248975561340582, 0.9344163788306996, 0.9326031205243148, 0.9328623558188918, 0.9284201600345972, 0.948894954846792, 0.80179840229158, 0.7636771397667138, 0.8003460505422093, 0.8087665692227741, 0.7764960752830198, 0.8002742269532381, 0.7642868567575126, 0.7590918840705936, 0.7898715823051761, 0.15244638018995593, 0.12357064154645125, 0.15233793682667307, 0.1392421677079394, 0.15927482220718125, 0.4809283479940504, 0.15019876124863762, 0.14313873481398953, 0.16540595754558785, 0.14895174915614717, 0.13187213654700658, 0.13212515018561843, 0.11541535715139073, 0.11607416057364461, 0.11290898053487963, 0.09563061498165859, 0.12403604636854904, 0.10715685640796979, 0.9559244203968447, 0.9625122569865813, 0.9769982607979554, 0.9500405889321645, 0.9565860353971944, 0.9729695763552338, 0.9628109475498007, 0.9680295343729446, 0.972533782156883, 0.7400447986731893, 0.7074340160965815, 0.7051009569097493, 0.742715716051662, 0.6948724994692959, 0.728962114152287, 0.7117507395918412, 0.7107712221426736, 0.6720373167769793, 0.22809080779633373, 0.3148922300888539, 0.23184014122507135, 0.3561154902666751, 0.933661077738466, 0.9088034306736139, 0.9367315956254898, 0.1820722359158402, 0.37047536489918453, 0.6276363598314753, 0.5403237008280697, 0.45230965121378364, 0.13562474496409793, 0.5274523206232133, 0.4912814802720834, 0.5816412008821614, 0.7010356691439985, 0.6059105312034997, 0.508037738566574, 0.5897968222891166, 0.599178931467414, 0.5510942109098146, 0.6870059457775994, 0.5394585511776, 0.6367925684240299, 0.6792648745170389, 0.6378101122660689, 0.08630808274801183, 0.4013923779875108, 0.39277299034654356, 0.6487965157035143, 0.6573642681153853, 0.39796472033603236, 0.45517708285700387, 0.6182493041955452, 0.6141881062940342, 0.2577853643028378, 0.6031089669904434, 0.5123656309976796, 0.5519106336435696, 0.09624000478737216, 0.28995974429644644, 0.6719237154314055, 0.6586222705225095, 0.3638614201301962, 0.3976314658446035, 0.15316267647328552, 0.34750875645754864, 0.5727755354081567, 0.33157071310608754, 0.4256724653584274, 0.4048770489477176, 0.24326082961472495, 0.37059925361150414, 0.516076174590552, 0.45610649486273847, 0.49538845890596916, 0.5460366374856552, 0.5253567278258997, 0.39154137288932467, 0.5183067360178394, 0.42155942534022683, 0.4326348374267066, 0.8163189855784587, 0.8244214792592389, 0.8791794338013932, 0.8474772626765912, 0.8185802564208524, 0.7467746733378677, 0.8405026018497473, 0.8219819363948013, 0.8335866960100928, 0.1143077186805409, 0.14819807973710863, 0.17373972734344478, 0.10648777806706655, 0.13219088981670646, 0.14294074520552003, 0.1351529093456848, 0.14024225973445392, 0.4003153748931618, 0.18480833589212697, 0.34169466374553303, 0.17253321686428047, 0.1840936021283116, 0.17726325680071187, 0.22344625386916472, 0.20476539572822616, 0.14996875939650867, 0.3632041277718264, 0.5422011802032716, 0.5215391178735187, 0.32981188903393155, 0.5257470108882677, 0.3899432037824454, 0.5325770944235039, 0.5396830781691764, 0.5618868390259032, 0.5497424561238378, 0.42352198239244887, 0.33343260931424246, 0.38538094081404317, 0.48454285685551124, 0.4332531554952501, 0.3979586111120743, 0.3645151859655079, 0.22855329192832674, 0.451608899378236, 0.22991067199045012, 0.2157020210047904, 0.2134857917462114, 0.23535881471305797, 0.23239118934768876, 0.218556982340804, 0.2384716339407229, 0.21819355515828043, 0.222851506770826, 0.8485110235891489, 0.2353149190165027, 0.7301604330396364, 0.20727669847251606, 0.24885730933633143, 0.2508472928302178, 0.21150839862615256, 0.24580588658439428, 0.2083001096446776, 0.18661180294794333, 0.9519743139880315, 0.1881525917917345, 0.20041917361249306, 0.8701765379571569, 0.14813144882528084, 0.9280034587359374, 0.7816569612774142, 0.9176217786059521, 0.9343376395772369, 0.770747795998347, 0.21158406024513132, 0.1671961720068592, 0.2096928291207676, 0.21018579682705818, 0.8070189664584362, 0.2099045286268585, 0.1689925138482753, 0.2055608514062217, 0.18759766070137962, 0.1915482216051031, 0.1972614042687748, 0.18773150603010347, 0.1698454820741685, 0.19442074407005416, 0.17959501160754332, 0.1839442694321256, 0.08079027330757393, 0.09516381380857852, 0.09266808061941123, 0.0958459066990417, 0.08887310989954256, 0.09347157944654849, 0.09811017585151782, 0.0962194794188519, 0.09315337218533137]}, "mutation_prompt": null}
{"id": "c4cef125-b1b7-431e-839a-a65ac3ab22c2", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            progress = self.evals / self.budget  # Calculate progress\n            f_scale = np.random.uniform(0.5, 1.2 - 0.8 * progress)  # Adaptive f_scale based on progress\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve convergence by using adaptive mutation scale based on iteration progress.", "configspace": "", "generation": 60, "fitness": 0.45162588686539074, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9301032716786073, 0.930120685853044, 0.9320374256284158, 0.9154653348703108, 0.9323447078259939, 0.9328938035530266, 0.9301561070238956, 0.935400831514391, 0.9399494036139125, 0.8044585785385784, 0.7833350251398759, 0.8002635844890597, 0.8099933970794729, 0.8049116697859973, 0.8246188141019443, 0.8103375049194599, 0.7899063738528248, 0.8239529495224269, 0.16468407626924586, 0.1427392504118823, 0.13485147560582222, 0.16796320180584368, 0.16777188999618897, 0.1428952035779808, 0.13846631642349894, 0.13051349598634665, 0.14809626425316946, 0.1510388245795331, 0.1192295828936023, 0.08957890385789835, 0.12019399170864431, 0.113331716164074, 0.12023863230905096, 0.1350436497138353, 0.10850757203209704, 0.114077218795266, 0.9563280948067189, 0.9562345471194839, 0.9794311692985272, 0.9550771025797151, 0.9864513512765051, 0.980996542255692, 0.9452988909225306, 0.9597258567065329, 0.980759438929783, 0.7591207685581288, 0.7172533708378062, 0.7318471063847931, 0.7786082517561285, 0.7063061104786305, 0.7548212486234938, 0.7601530360293494, 0.6948657673936507, 0.7390587497604231, 0.17921572884542425, 0.22535837833609484, 0.2318681298031755, 0.9465154706086119, 0.959038778474318, 0.3900308624631327, 0.9359941126829323, 0.18645265655894083, 0.23833386680567914, 0.6807873402375133, 0.7145445659029261, 0.5367604052092461, 0.13589308178382686, 0.6104448597118256, 0.5833745686897935, 0.5345101483465382, 0.666740753364357, 0.7270387019684035, 0.6791211972089333, 0.5038343949222825, 0.47029273735958943, 0.5860825537477726, 0.5169658680250844, 0.5312578633032944, 0.7108106431432433, 0.7900504172709609, 0.434105650944679, 0.17001378683888302, 0.12172832392688893, 0.22675136805033524, 0.39537624480263434, 0.3990963731279993, 0.31562038643618684, 0.6570534128905196, 0.6767924260809965, 0.6813649274369644, 0.3196096277474706, 0.2990381347053852, 0.2015655514296656, 0.7347969655283992, 0.24353415546128432, 0.31434359229918396, 0.47493862096280814, 0.24096628872723536, 0.29119695348574703, 0.359442287684439, 0.12284085626252561, 0.37561916674204254, 0.42785464375022186, 0.3826061786393654, 0.4322481589564803, 0.12445452446785621, 0.18448412897229438, 0.2726114779072851, 0.5106683082391172, 0.615962280178294, 0.5078624757714392, 0.47830456738603, 0.43522867849915015, 0.48756464785678766, 0.36836687165589566, 0.31561781540475387, 0.36753996725759785, 0.8442688608171126, 0.824316437722606, 0.8578956635248266, 0.8541363865518246, 0.8055073895852485, 0.8336180094092008, 0.8915324522223615, 0.6447862372034271, 0.8905072012494131, 0.15453193547225252, 0.13010787570798799, 0.3799828360511268, 0.13421486963868445, 0.21424300169384836, 0.5051780771374816, 0.1446811226123258, 0.15757752805349023, 0.14017985715479553, 0.17459619844864394, 0.1789975686446451, 0.16603480639096013, 0.1588639811580932, 0.6406996456862488, 0.17598945823795098, 0.15868243146780792, 0.21591685231284918, 0.17478306003958455, 0.5836027316156638, 0.3559624901554772, 0.5973445179134307, 0.5351321378234912, 0.37989711579796237, 0.6262748712216655, 0.5488503142360339, 0.5406759124240922, 0.6034603123229544, 0.29632357471165105, 0.30677312572192106, 0.5160563244347445, 0.29193471206015276, 0.5264651816050814, 0.4822376705855652, 0.4211678729220726, 0.23585004554155442, 0.5574331564522842, 0.20082441081612667, 0.21228464411566061, 0.2211071018413746, 0.21523664514066465, 0.25014856131600516, 0.21023105758224447, 0.24067616922532087, 0.2208870563239721, 0.21632133931750042, 0.22614960351609847, 0.4656551228083443, 0.24170081941809896, 0.20725612869810994, 0.18525036101344805, 0.24831370096478644, 0.6014299891430375, 0.21239675617418363, 0.2062293183397692, 0.18634184767743733, 0.9276973111414031, 0.1881571461753323, 0.2006267087586373, 0.19903402584792984, 0.1481365903922096, 0.8733165514150785, 0.8122305301544898, 0.9094819150160802, 0.9333221754617786, 0.8745908616236012, 0.21153327606027372, 0.21171999067118408, 0.20944776284055844, 0.16764018440084472, 0.8407605058538521, 0.9112746753665053, 0.16898950296801196, 0.1727289675971453, 0.19132946682947394, 0.1837851299120591, 0.18695547980070126, 0.19299555541205848, 0.1923355560445038, 0.19894626905507207, 0.17776710857816636, 0.2045004319867103, 0.10110042166675226, 0.08687158152097141, 0.09150782507049149, 0.08487929031392016, 0.09685838453149731, 0.08156399016731997, 0.10532985260824101, 0.08486012175192703, 0.0829079203749905]}, "mutation_prompt": null}
{"id": "8f7b5fa4-a2d4-47b0-9ef7-9137cd1e287c", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - b), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Refined mutation strategy to enhance convergence by adjusting mutant calculation more adaptively.", "configspace": "", "generation": 61, "fitness": 0.4090864437855978, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9431442558690066, 0.9287648703597221, 0.9482597953941359, 0.9426024612686023, 0.9175112603353529, 0.9029096358789619, 0.9476207801537859, 0.945643447496275, 0.9233592954834502, 0.8461128163119449, 0.8191618945926427, 0.8552991580139099, 0.8497192934435767, 0.8511869336582877, 0.8419929584853222, 0.8589696419030761, 0.8158185205474056, 0.8315144882487195, 0.1822803764135208, 0.15886509759809564, 0.7781862474861303, 0.16154281676433424, 0.16971691961231572, 0.15965154113051072, 0.14045230264809838, 0.5671827468274617, 0.7399260168621328, 0.10382791595218555, 0.12113425765322139, 0.12763237044036524, 0.1498189808242496, 0.16735086552980027, 0.15592425642226204, 0.14857868978267685, 0.1112778571037496, 0.15286942163520612, 0.9693059891813496, 0.9537154827278385, 0.9566333796959249, 0.9167459072153048, 0.9569874237093158, 0.9734007077887861, 0.962338754736945, 0.9466030996071227, 0.9619311754030722, 0.5242951258956549, 0.840694498024872, 0.7315164184148677, 0.6695018022568175, 0.7897046598818641, 0.7584409746177961, 0.7009136524589337, 0.43891171197041656, 0.7649354927439201, 0.216737546138566, 0.22886069611636217, 0.2477741675779379, 0.9526343492467284, 0.9476101361851874, 0.2814350003201277, 0.23826085542077768, 0.7332533756704853, 0.3656432187912181, 0.13667404970005392, 0.6519444413836601, 0.574596985319912, 0.6968132742072313, 0.22896407972908384, 0.18574690912035396, 0.2900902561183465, 0.13655300270126192, 0.13678540906432646, 0.5038983358690555, 0.1369863907298401, 0.489337187301482, 0.5837315340505154, 0.31206232982948134, 0.24812045464359633, 0.514472057003414, 0.483950164544634, 0.6616938224513262, 0.3868976977169254, 0.04095426669744506, 0.06592574847079102, 0.43383595485867366, 0.22572622474306248, 0.1514331922566453, 0.19544720291215367, 0.07315801513034836, 0.29959782769627996, 0.3921163254307315, 0.19686378249096637, 0.12175029699622497, 0.4348310586912798, 0.1487127656584495, 0.2745770482940536, 0.37143931664310703, 0.190927279263707, 0.27738347390627105, 0.34347820704339105, 0.31083548157458174, 0.20486112500442488, 0.145513916409161, 0.22226493987885998, 0.13081418997356864, 0.14538560193720473, 0.13919146765239454, 0.2753242016661239, 0.5045282293417448, 0.3498609967284596, 0.3160543193568499, 0.5126366695260407, 0.41589934982015964, 0.39792967955434067, 0.3329450509155403, 0.3212622038220645, 0.34578732289782976, 0.6352608846229482, 0.7168061685915734, 0.6845417071917095, 0.7158527142671312, 0.663065422935524, 0.6841672832611299, 0.7440811861517561, 0.7468479613264838, 0.6183772799060477, 0.14281016452329243, 0.11265509756356729, 0.13893685220961438, 0.12326295392527209, 0.14113148296208256, 0.1701842300799542, 0.14007839607920947, 0.1341411621992753, 0.48855802805569204, 0.18350470377382488, 0.17025749349264319, 0.17310013491300213, 0.19078221587142408, 0.1425147954004733, 0.18363823378878308, 0.21170551854675057, 0.15024149361333583, 0.20185404919821626, 0.413441709984142, 0.6735994461388868, 0.7197368331438092, 0.6674826395656559, 0.5056426207389998, 0.33521960758939795, 0.507127152230847, 0.5388569346185679, 0.29519295483962493, 0.37904955847688304, 0.35736657747003076, 0.3591532542338799, 0.5538648095074172, 0.34659983624624235, 0.25797478278206887, 0.2865078496921629, 0.25171654939426935, 0.3227820451297123, 0.23546807323880703, 0.22128046532935974, 0.22226872297403377, 0.20459270141962982, 0.28357069611700914, 0.20042351884831155, 0.22688286061318608, 0.23798432242228984, 0.23090561229108064, 0.20080637083489505, 0.2541243444661202, 0.5415919474720986, 0.24895883706892274, 0.25284290300446477, 0.1965355615496447, 0.22689138857290914, 0.21266034868638295, 0.7911816698815193, 0.18797628908631003, 0.1867438392539983, 0.18790247004461402, 0.7876059269758631, 0.8752821266979527, 0.16516921388881733, 0.15872097522253548, 0.9052574539674176, 0.16962754564828642, 0.8378407172165308, 0.6876619055413115, 0.22517259794536082, 0.1685631776018348, 0.20562503446356284, 0.213434522842048, 0.8197022392511603, 0.1089671065387825, 0.8407503915869988, 0.2030310533676296, 0.1923880126678862, 0.1753245210657287, 0.19459144950032237, 0.17345976837054256, 0.17445400230440478, 0.1924477533538249, 0.1758544754514587, 0.18343858625224063, 0.08575356490272568, 0.09091925278461344, 0.09200818379749076, 0.08365795211573646, 0.11368560563326502, 0.0799734591085065, 0.11534446961890676, 0.08329745357555751, 0.08922873436479295]}, "mutation_prompt": null}
{"id": "e2f71f86-5b74-4797-9f6a-1a0756a3d735", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity) * (1 - (self.evals / self.budget))  # Adaptive crossover rate with time-varying factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Refine hybrid DE strategy by incorporating a time-varying factor for adaptive crossover.", "configspace": "", "generation": 62, "fitness": 0.40212080376024706, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9336110554963957, 0.930498211465747, 0.9393234173809818, 0.9347452942850096, 0.9387057746826734, 0.9329144698022984, 0.928042864446225, 0.924492243756954, 0.9409219985231705, 0.7895822100400824, 0.7959118281120219, 0.7932973645067578, 0.7925847607549091, 0.780243562683514, 0.7897514574317203, 0.7877659047890828, 0.8022467032580463, 0.7784105291261036, 0.14716514561366167, 0.1566425036887107, 0.19342493108654912, 0.15258529715502023, 0.1429957127505761, 0.16610278815900947, 0.1624087727157405, 0.17286359818981145, 0.13820326321420617, 0.14048686769500396, 0.12998192610844583, 0.0996499704822611, 0.12968262609817904, 0.12312675591412803, 0.12097979421286875, 0.1021330293333007, 0.1358537775755071, 0.1272061648638515, 0.959675285201256, 0.9648824091438982, 0.9769982607979554, 0.9613951029003821, 0.9725095604498166, 0.9480678929548139, 0.9577568319817691, 0.9598268126291359, 0.972533782156883, 0.7226070321870908, 0.5541143668265355, 0.6644874855692466, 0.7132484041023227, 0.7216477589515671, 0.6812771609068535, 0.681684612617415, 0.6895074130084511, 0.6642287611454774, 0.22809080779633373, 0.17853246112489707, 0.23184014122507135, 0.3670124585488628, 0.28199505210100073, 0.2807851497160375, 0.9413020137655457, 0.2236490534527198, 0.37047536489918453, 0.40307218644121745, 0.30095260884373043, 0.3768219889360527, 0.5798600742421176, 0.36527226933786994, 0.13569005685273094, 0.3889053797077401, 0.6981374784483025, 0.402649063909042, 0.4002420229988881, 0.3174753101034674, 0.13634004046236892, 0.3322677829640228, 0.4028700874903377, 0.5350266191049133, 0.4606660831283088, 0.5391083336258198, 0.3030003142041555, 0.01499535016098108, 0.1635720322540759, 0.34556662076134603, 0.17844710801646324, 0.2908497393878029, 0.16756032610204508, 0.3199364780726942, 0.43479455394280364, 0.25854382007515453, 0.1075383082582897, 0.38777560615691575, 0.29882757487175304, 0.23028426452975448, 0.12332711845047883, 0.13101301166267154, 0.41725206954305616, 0.4328491947917511, 0.22282391228543108, 0.15729504371733694, 0.1034797925673463, 0.31061520331933656, 0.22473275208719, 0.12987692085183244, 0.1267728879126373, 0.34762651906278064, 0.344963438433466, 0.23447346950811065, 0.3280122056208409, 0.3482582945096996, 0.3288827128451898, 0.3685395202828863, 0.3878607224314048, 0.37203374887547713, 0.35463365532496893, 0.35572521595257145, 0.2936725270049114, 0.7505362385725488, 0.7075329945416684, 0.7707800741364814, 0.7253549322948897, 0.7171866016829667, 0.6745122380436466, 0.7997024054023988, 0.7469501787666839, 0.690811725957358, 0.12377850061095919, 0.145254837652123, 0.1193680110675055, 0.14699649434173645, 0.7167931268730412, 0.16063549757460227, 0.1153961430171283, 0.12319222064957958, 0.152295981041069, 0.18319240510942236, 0.32921666820185447, 0.16389697531506042, 0.18499384943414554, 0.15662341831103788, 0.14831334994397205, 0.17043834892368193, 0.15407427667815066, 0.1924741692537978, 0.3887944467306954, 0.34143331515433684, 0.5062999884804313, 0.5322275989006897, 0.4893158466173385, 0.5234317053397475, 0.27715496657127203, 0.5733525412029084, 0.5125700062984648, 0.3375527138792067, 0.328132818154689, 0.28905727136347414, 0.31393913168372456, 0.3985204040862542, 0.394981177858469, 0.4012556958759549, 0.22574949508665665, 0.4090681084347709, 0.21495183540270768, 0.22056595371814602, 0.21415565805204495, 0.21593720798642801, 0.21582239486643917, 0.22505677096101617, 0.2384716339407229, 0.2310907249300601, 0.2305451124128861, 0.8368546421211993, 0.21711282423113676, 0.4038706316895957, 0.22220986145473498, 0.2478594073879412, 0.24998892624183933, 0.21350459431189495, 0.7834585895173094, 0.2262216712200038, 0.18601946064199326, 0.1874701017174929, 0.18745925804942432, 0.8907785630454881, 0.8170070742155119, 0.1480118753867541, 0.9478730725140329, 0.8429112374444531, 0.9490068899847112, 0.8201243977903072, 0.8222078706256162, 0.21136347440001868, 0.20025479571818572, 0.2070401692157252, 0.21004987680118403, 0.9247720984265413, 0.21001377721475423, 0.16883722261327694, 0.2055608514062217, 0.18723571669795114, 0.1915482216051031, 0.18804952529866892, 0.17756214882003152, 0.17750495075961426, 0.19207443919008815, 0.178544596349401, 0.20313107490681148, 0.09431781558313701, 0.10025125753915132, 0.0971911542096281, 0.09935599579645094, 0.09784087349593706, 0.08789597070739108, 0.10732274644796913, 0.08220584889729776, 0.09203844114275284]}, "mutation_prompt": null}
{"id": "9aec6dfb-0bb5-47d1-a654-8d52eb9e6730", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            self.population_size = max(4, int(self.population_size * (1 + 0.1 * (1 - diversity))))  # Dynamically adjust population size\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Further enhance exploration by introducing a dynamic population size adjustment based on diversity.", "configspace": "", "generation": 63, "fitness": 0.2742196985661601, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.27.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.941208996914066, 0.9310120169555612, 0.9430692687886117, 0.950560157891427, 0.9372925432190665, 0.9371614733381187, 0.9279070741724642, 0.9423524746973588, 0.9501599212317349, 0.8928929068661831, 0.883910863543905, 0.8682507620221802, 0.9022984526898261, 0.8946989351792932, 0.8819667509217703, 0.896889693887238, 0.8999075961747987, 0.8955536141642155, 0.2319387760660354, 0.23291570607941825, 0.3853567478408445, 0.17217079980377492, 0.1515281485217671, 0.15873497112362334, 0.16119744689671878, 0.16379907206340827, 0.28022444181838857, 0.145264276875955, 0.09010729226970582, 0.09635962115773378, 0.16159828968132328, 0.14734951303528743, 0.29493159152231363, 0.15788593092249759, 0.14435148473496506, 0.1345057936072499, 0.9872568442715467, 0.9822729807304211, 0.9841215028980316, 0.9856853678887049, 0.9856621104068596, 0.9859128252619163, 0.9766049452541181, 0.9855735462133858, 0.9793766199564465, 0.225563829066727, 0.2621060955288975, 0.20022037441118434, 0.3455675223575465, 0.31680773593041367, 0.17073627877862363, 0.17123718666073906, 0.2062129475268073, 0.21288510002131733, 0.15601713568974596, 0.15189819019143613, 0.2647586400284323, 0.21482894223408122, 0.2743004504619738, 0.2528598204835637, 0.1957079446908585, 0.23271810663945247, 0.23925895217055304, 0.20876219602808777, 0.15653645479981515, 0.17189444230489026, 0.30633438862332096, 0.18890950723248534, 0.17471314345681654, 0.17363905512257682, 0.19522321141980015, 0.19589281332857833, 0.14127275470872735, 0.135479937278565, 0.13040232069190638, 0.15857888019701438, 0.15545460591314908, 0.3024242627700533, 0.15436943487018562, 0.1396316834715693, 0.1295078769218988, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.072290008580848, 0.13318979634343453, 0.06928941678013378, 0.10134075802941367, 0.052863132595921125, 0.051784742365561076, 0.10395688681435677, 0.05447337265394725, 0.10284612276654315, 0.040240196985281584, 0.0025005454185899056, 0.028308402007794164, 0.08301003251344286, 9.999999999998899e-05, 0.08272569463336188, 9.999999999998899e-05, 9.999999999998899e-05, 0.014570430430104753, 0.08889522326840926, 0.10604559290274262, 0.12580718859765583, 0.06303951003745789, 0.08053353485245263, 0.0851078060063204, 0.06999011312950298, 0.08317831297555855, 0.13482967731830664, 0.48392388292466193, 0.4899827182319728, 0.43789721293950556, 0.4203939631625503, 0.3684337461321904, 0.39972356508969087, 0.48760819887402784, 0.5360434719891458, 0.38396673275841053, 0.07316989385882933, 0.07716978012734799, 0.10485581759216289, 0.11906911969083578, 0.07445991378049788, 0.10725077820844597, 0.11033164977914112, 0.13925947995836596, 0.06715097857212027, 0.18403845208190983, 0.15803782862474158, 0.13731707882690714, 0.14958210372031133, 0.15463726700417213, 0.17161980740157357, 0.15364428400860286, 0.13542270821512536, 0.1548174091412422, 0.24543856749019966, 0.2411256021935968, 0.25652929285174697, 0.29295748186554005, 0.24861430998770906, 0.25827455197983984, 0.29917553335654345, 0.23868433206496176, 0.27647858195325803, 0.20607405207728224, 0.15224533533797036, 0.15288055411744228, 0.2338668132171411, 0.18219492050627584, 0.18506691453359625, 0.1922553798245542, 0.190225353635183, 0.1744376369976013, 0.23091644726000538, 0.22253068293337142, 0.21693733207969645, 0.2101996218150214, 0.2460751748581086, 0.20151381552020364, 0.2042909223088818, 0.235383740817817, 0.21372899443325244, 0.21784440974611197, 0.24298103447820363, 0.2245699107427649, 0.19657075768868604, 0.27402763239678884, 0.20112106572131105, 0.29351436946220444, 0.20293294646650273, 0.22358614072802663, 0.18925337766410122, 0.18297433457853007, 0.2043906803493073, 0.34034494439352136, 0.19728938613448266, 0.3658356811851471, 0.43293170600778386, 0.24894911425601296, 0.22353106964172897, 0.3456310373394289, 0.2927890808028293, 0.1995371956264872, 0.20873867284163572, 0.32322873630858506, 0.16986106393545908, 0.20329968901050166, 0.19876754826237075, 0.2535416684070618, 0.21186983621763888, 0.19006315324252998, 0.17324775668606363, 0.185682239575526, 0.18310234167251016, 0.18387512840918452, 0.23388513299100755, 0.2124985929089246, 0.18809106374806017, 0.07272286476300782, 0.08852718656466385, 0.0891486470871865, 0.07852204426283482, 0.07470797797709694, 0.08638506906559906, 0.081970966229017, 0.09195191829152916, 0.07474105813212917]}, "mutation_prompt": null}
{"id": "9dc5a7bd-6369-45d6-bd79-4279cf0d6d21", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.6, 1.3)  # Adjusted for more balanced exploration\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Adjust exploration and exploitation by refining population mutation and selection strategy.", "configspace": "", "generation": 64, "fitness": 0.44788980281853835, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9209959386824164, 0.9258667447101953, 0.9260053496974867, 0.9318865292068427, 0.9232256332066822, 0.9185214007190724, 0.9272859655977966, 0.9185848447700676, 0.9391928049878774, 0.7342360834447721, 0.7814405345007801, 0.7799428264650268, 0.7781264604450131, 0.7629150120991526, 0.7506803757203298, 0.769948857934015, 0.7434468600448465, 0.7371467424430695, 0.14202711363212417, 0.12847240737532517, 0.1554384004064272, 0.19172265254916365, 0.1429584312954021, 0.14711575379677255, 0.12780663783466029, 0.12946407992832065, 0.16025847448923036, 0.1191083783275646, 0.1305126756826256, 0.12890156814194254, 0.1346705146535664, 0.12232252747254224, 0.11980537604491126, 0.15053375794099721, 0.1240111048020901, 0.115556723382497, 0.9593195930952679, 0.9574957847422273, 0.9678244130632047, 0.968832176987231, 0.9887679590979034, 0.943664631214988, 0.9667989363740065, 0.9603651554882675, 0.9759389329154875, 0.6514016923716801, 0.7290301017466931, 0.7389564068363668, 0.6739220390701373, 0.6462425441282531, 0.6652914020982175, 0.6934350560656668, 0.6772939605958217, 0.6639738599250444, 0.9374174866936159, 0.9421696264560668, 0.2314873472012391, 0.9550718519519372, 0.2145045936619746, 0.9396714817288814, 0.9467471487117329, 0.2352667691735556, 0.9599126795795405, 0.5992145059111583, 0.7920940633563329, 0.6317159199025493, 0.13580585339006845, 0.6641303210460594, 0.5653276974282012, 0.5600614794019627, 0.6438621891285956, 0.4926822448092648, 0.5387402839831421, 0.6373833000690459, 0.560226594911229, 0.5856177122825321, 0.6014777033038594, 0.5403727485747589, 0.5559980760637265, 0.546105555525676, 0.6439553132601017, 0.2252593238196936, 0.3688780712177474, 0.2931255748437417, 0.4717315980838622, 0.48944039944939055, 0.5438879335113554, 0.5653088325514117, 0.6440085713202197, 0.5048191422068766, 0.32633550445740445, 0.5024730063050704, 0.5615796258553456, 0.34119635031763385, 0.1385975956683002, 0.3644460950877806, 0.6639962665392384, 0.5644158401260316, 0.4968270454395851, 0.22992700886427497, 0.16479569682919226, 0.355412429425243, 0.3577385838070729, 0.40157872472899314, 0.3333567294688917, 0.40263056183071155, 0.28895991220632966, 0.3542267205584926, 0.46215854412164337, 0.3579871120793352, 0.39707620866115345, 0.44703417232419995, 0.4715768384966861, 0.3862511449372644, 0.45748365887246834, 0.4423521627354141, 0.4320377771784635, 0.7847761371792062, 0.7651716965058863, 0.7671039174318033, 0.8165146396668963, 0.8153875409348887, 0.7775909841709174, 0.8148555450488452, 0.801550678045812, 0.8222997781958007, 0.11622803312927354, 0.13957522170816916, 0.164196980159395, 0.12616581437747687, 0.15334664757788918, 0.11400068868655744, 0.138425485341228, 0.14104204303679513, 0.14026286048591408, 0.15381058534016956, 0.20518242309246426, 0.17064457999860427, 0.16992418976627666, 0.1511593495044975, 0.19507349387778672, 0.1949574840378112, 0.19376208283504948, 0.16238116945261882, 0.5452238547213084, 0.4791760257757697, 0.5215431044919576, 0.2801759747196495, 0.356013910104791, 0.4993255451011417, 0.5036975916116959, 0.5258874989529692, 0.4954771177567141, 0.3112267023439167, 0.39477199652465567, 0.45952686145488375, 0.3811281254932649, 0.24216566956881347, 0.440724156860546, 0.2648296968988402, 0.3090850135519462, 0.4356357113724325, 0.20539669464333243, 0.224054214317581, 0.21029987249809923, 0.24208788206533416, 0.21907611038025365, 0.2215124454172117, 0.2260643415932192, 0.2151716069565519, 0.2439137926879813, 0.22612765370211396, 0.22157811639920988, 0.22443411480803022, 0.22453798806053304, 0.19962238536802168, 0.21096980919373387, 0.2088239418293839, 0.20082973619866817, 0.2712615696145201, 0.9551318794789153, 0.18880986986328974, 0.18750855020144286, 0.14830506557387946, 0.8986306007535477, 0.20255083848934285, 0.8965009541443556, 0.15912239306488574, 0.8960336027289453, 0.9180019612784848, 0.8678623590626908, 0.16727333115406096, 0.16838704729962906, 0.8539062176097063, 0.16524312230318916, 0.819208446569437, 0.2102566329995308, 0.16922888309569895, 0.17963870515044367, 0.1866106252939297, 0.1945669832107917, 0.175838950939455, 0.1861234054691706, 0.17935912587483582, 0.17923744075216796, 0.1874934767988481, 0.198160791074934, 0.09376887063300765, 0.09068994705483269, 0.1012793149805371, 0.08362606857180432, 0.10347929762869612, 0.0901053100556104, 0.08521090404547338, 0.09973024917310813, 0.08592780411710121]}, "mutation_prompt": null}
{"id": "03baf775-3713-42b3-a1af-9628df0ae5ea", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            \n            # Modified line: Adding a random component to the adaptive crossover rate\n            self.CR = 0.5 + 0.4 * (1 - diversity) + 0.1 * np.random.rand()\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by incorporating a random component to the crossover rate adaptation formula.", "configspace": "", "generation": 65, "fitness": 0.44242414583521805, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9353303318280262, 0.9399913204193995, 0.939393056772555, 0.9367097713135156, 0.9424401858641382, 0.9380032253110863, 0.9336990792420781, 0.9295705685592164, 0.9283643327720955, 0.7825027514823775, 0.7765265533088291, 0.8049608464541465, 0.7782330274483298, 0.8006136042598312, 0.817383016224683, 0.7958442184390337, 0.7875471267547861, 0.7942023140791261, 0.12175323524344239, 0.13361876874306344, 0.1485238943633198, 0.11677258368408161, 0.1424584677441828, 0.12464324677172611, 0.15677005300277502, 0.09020853773690907, 0.14603070171339427, 0.1528525203390807, 0.12329548871340124, 0.11199522499616066, 0.13472428012696291, 0.1258465371372648, 0.10274544700153931, 0.13831921499258915, 0.1343511964324816, 0.1137913969515203, 0.9534508789103745, 0.9706832776556139, 0.9796246067410906, 0.9698962044744133, 0.9518635489190644, 0.9742756465686085, 0.9737711166945452, 0.9652762783084502, 0.9647427379700487, 0.5985827247896823, 0.747132574341604, 0.7462402625459081, 0.6764611972241934, 0.7479856306309427, 0.6664242825495095, 0.69060403043431, 0.6914234415513648, 0.6922411156426407, 0.16544766170731695, 0.9361892469972378, 0.9622994756823988, 0.9582414670907667, 0.3892328436089747, 0.21512626968712123, 0.9517881565666552, 0.22587097469038064, 0.2392860728718017, 0.7439460602579047, 0.7676991120490746, 0.6689629751417795, 0.6839319850162746, 0.4659024122931369, 0.8048273488176124, 0.6277670697215669, 0.6931528280277596, 0.529625068205867, 0.7286526328518454, 0.6198377255359113, 0.59599736669721, 0.6382809257794035, 0.5027966430910291, 0.6697584991128469, 0.13745254832579445, 0.6086788297763495, 0.6645976536120852, 0.3146038747834219, 0.5157367359713143, 0.5009608684234074, 0.29190093023318353, 0.2074698044602662, 0.26551305745153475, 0.4064186357710391, 0.7725338132819024, 0.6570882100743161, 0.6353500327577151, 0.45924059555551844, 0.3302137233504575, 0.8022435620874656, 0.2718638379935322, 0.21826745588353857, 0.74916031878581, 0.6054626200612764, 0.7625184078892021, 0.15095423440087818, 0.20529036725338767, 0.20027476241324071, 0.3268400803078221, 0.561244222487018, 0.6161480512616753, 0.21744103031550333, 0.24784836782510822, 0.26385178619582383, 0.5032217479373773, 0.491195104400318, 0.4921566779556247, 0.5921810720223992, 0.4593131351980596, 0.5965434307286615, 0.5404714017182708, 0.46758751951134925, 0.4927937980932918, 0.8944321612270529, 0.8794908372262134, 0.8708566552391331, 0.8839732507039059, 0.8782246486811442, 0.8615307661015593, 0.8473641259647173, 0.8572787198017195, 0.8496663468891995, 0.14544161246778953, 0.15091011579546032, 0.11177586635186532, 0.10859866053194855, 0.12670994203269215, 0.12999122813142439, 0.1324166378686885, 0.12325296373508732, 0.14711952905978998, 0.19029156717867868, 0.1528450556274491, 0.18955491433097382, 0.18270387210280314, 0.13913055008418107, 0.15766896412705322, 0.2012478161361798, 0.19303797298288805, 0.17222192020173666, 0.30796274828223513, 0.5560079445645522, 0.5206312467918266, 0.25985447071220236, 0.5514686984086774, 0.5605635802992077, 0.5657866300665495, 0.3062244736113572, 0.5364070012196032, 0.3728400971537782, 0.3167233557008169, 0.5231276201974635, 0.3010144403122297, 0.3480606673409823, 0.3152437206974782, 0.33968195929875544, 0.2373307341646268, 0.21952649664073653, 0.23413102518456264, 0.2341571886148286, 0.22710628581135028, 0.20605257005514388, 0.25086345232665475, 0.2136090498002653, 0.2272415448736107, 0.1877531196677381, 0.21496683064462108, 0.2243575535908564, 0.20353568957941448, 0.19833018143901504, 0.23785212706496117, 0.2377547832424307, 0.24102657530231764, 0.2376413504241608, 0.23201507502765084, 0.22475535303439598, 0.18760884797138322, 0.18606990039834015, 0.18791576602011306, 0.1486962082983091, 0.885270163858201, 0.16550474024891104, 0.15496755607617418, 0.9265219059749393, 0.8823088527507507, 0.9296764247529096, 0.127636171664549, 0.20841199359649376, 0.19389105225049375, 0.15556917824282246, 0.21089490889764584, 0.1554388820052025, 0.1277998644775138, 0.1689110547602508, 0.1852124552943445, 0.18840205114561026, 0.1896495128426161, 0.1871064395761196, 0.16941464023580843, 0.19554785204958147, 0.1879052675592996, 0.1967818058107592, 0.18374088502560149, 0.11716776218040759, 0.09344698214649039, 0.1013467468746796, 0.09048838620577082, 0.09087150631694507, 0.0851931642950533, 0.11498958397922088, 0.12138016275588948, 0.08458567190317934]}, "mutation_prompt": null}
{"id": "332f501b-fa39-4f88-a2e9-bc93714cd09e", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.4 * (1 - diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                step = self.F * np.random.standard_cauchy(self.dim)  # Lévy flight step\n                mutant = np.clip(a + step * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by introducing Lévy flights for mutation strategy adaptation.", "configspace": "", "generation": 66, "fitness": 0.3251655710781845, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.8821146851355518, 0.9111039155015621, 0.8939941751947525, 0.902455547377238, 0.9041051620746205, 0.9154882732432622, 0.9053019629594801, 0.9060607891083331, 0.9072093522672846, 0.628539411949719, 0.6417222973563086, 0.612072015144243, 0.6404737269505945, 0.6303539053594869, 0.6197867116192324, 0.6874603403799141, 0.6154300092187035, 0.6296062359981243, 0.16308499287359757, 0.15223465060418817, 0.16044570195195862, 0.1263429302307677, 0.136305188774276, 0.1402074656419542, 0.1465415183181945, 0.17693510019930214, 0.15150163024368757, 0.13402635332040258, 0.14072382752742763, 0.13299570496524826, 0.11390456942387517, 0.10653442358251453, 0.12393346381990156, 0.13110284576391695, 0.10987374688210261, 0.11844119690620136, 0.9805174790307162, 0.9663004448468592, 0.9787182407513845, 0.9708004536210553, 0.9681735477995457, 0.9732283049996393, 0.9642076898493, 0.98375171323608, 0.9831456111378635, 0.632646693589485, 0.60224427476758, 0.594151135824288, 0.6550441943657681, 0.5891195027027887, 0.5684529393647005, 0.6107732925635903, 0.6098695444356312, 0.5746722830175757, 0.3506744309922656, 0.2443608955436254, 0.22958561380553022, 0.38242429092140984, 0.8084302107397974, 0.2820007562639564, 0.4231299382658187, 0.9267142902821843, 0.2460463006840269, 0.2248194939123881, 0.2614535706588045, 0.2273219469866402, 0.2268310608774966, 0.2949648072628739, 0.1359812073993094, 0.20749808472102438, 0.24860031292096196, 0.22167105386696861, 0.21870481919804374, 0.29630758905186927, 0.2440439062359675, 0.13517224548060292, 0.21579225793847812, 0.1330598772427567, 0.22543550343700203, 0.2621979635250272, 0.24839881416529852, 0.09062546702119711, 0.15657008880567902, 0.0564732282464222, 0.14762355961708296, 0.03938447316130511, 0.004124703272028074, 0.004533727148323896, 9.999999999998899e-05, 0.05125741005149098, 0.09388271999235309, 0.17704805082839958, 0.13260815029211204, 0.12271705571517999, 0.0644375678263639, 0.16436892522091062, 0.10227755231675872, 0.10706697350679772, 0.17685899890881118, 0.17062753452732227, 0.15208087458394348, 0.06765336142137679, 0.08833769599939933, 0.16936023961368318, 0.15677982767143894, 0.09271066305611708, 0.20562995393243277, 0.09622001655327417, 0.16148397758867794, 0.16268843360145657, 0.11183632701692492, 0.17744628348128522, 0.2769898248737128, 0.27039227587388637, 0.2543765265952679, 0.10995694064431705, 0.15276536692154352, 0.5390687144531765, 0.562773966998392, 0.5770624101030748, 0.6246410054824645, 0.5937505254363247, 0.609498078827115, 0.6139086036831497, 0.5763589410470114, 0.5947305297645086, 0.09884838173336719, 0.12290304405332375, 0.11564720750208113, 0.17049045652792139, 0.11528191255037656, 0.10831397786063823, 0.1436242673593301, 0.09264503407765967, 0.11339487663634606, 0.17048722877844447, 0.15200283398666647, 0.14504047747279014, 0.16328226349035557, 0.1587320677379035, 0.14829313015176326, 0.17159623338970686, 0.16129944767411397, 0.1695490345655717, 0.45056764294466545, 0.4702503599491451, 0.47445305123008874, 0.46787508317289406, 0.4551884531175584, 0.47915161394580896, 0.5066128547619948, 0.4903666504044192, 0.5059855896534595, 0.34353756946444836, 0.270155971452559, 0.26587216452116813, 0.2902442414583617, 0.4085768213479898, 0.2836576860860801, 0.3060778096635435, 0.38732341897459976, 0.3187167091969585, 0.2614620114735481, 0.19557749893479381, 0.23724934185876512, 0.20227158278112856, 0.22459551094006625, 0.2066911539173989, 0.21258337040151487, 0.2550648942931393, 0.22001054245098084, 0.20604119723241687, 0.2142979891566994, 0.22335277331085635, 0.19479831869224418, 0.236402950476025, 0.6830296085167054, 0.2234592903229442, 0.19357155086753797, 0.23691149315350035, 0.18743511585124084, 0.18957815956633584, 0.18673877665387395, 0.16773823852031333, 0.1991538662850939, 0.8408387847255274, 0.156121700586921, 0.7745758536616258, 0.16257910704108003, 0.5479338144548668, 0.2091741749720949, 0.16921868142121, 0.20692885502066405, 0.20925633110061304, 0.6117388297555715, 0.10508598040456996, 0.09452329023123607, 0.21188789151504683, 0.19146007086918349, 0.18399518978356644, 0.17738916990477682, 0.1894927773196976, 0.1971733959081191, 0.18839322315396811, 0.18330707483483544, 0.18893174712087435, 0.17685562251580855, 0.14507672670528537, 0.09090476460325358, 0.09267368362593331, 0.09219015628265259, 0.13844615038162322, 0.09572571976353628, 0.0880067223603701, 0.08230273362394636, 0.09257435885377252]}, "mutation_prompt": null}
{"id": "e2452081-861d-40a4-906e-b6e9a6426a02", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.4 * (1 - diversity)\n            F_adaptive = self.F + 0.1 * (1 - diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + F_adaptive * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce adaptive mutation and incorporate best solution feedback to enhance convergence and exploitation.", "configspace": "", "generation": 67, "fitness": 0.40857993995193764, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9026802991177298, 0.8962919436713448, 0.9076426524358283, 0.8997104865293803, 0.8673585145057604, 0.8989294170191389, 0.9106040076257045, 0.8991610231046887, 0.9036784076779544, 0.5542493372964723, 0.5515780945911793, 0.53985577502857, 0.5411001746033306, 0.6038157243210258, 0.5854263362054933, 0.5753069924762559, 0.5854076560104513, 0.5544238642827595, 0.15558228484337555, 0.13943692772661886, 0.1261896998905122, 0.1320631671843443, 0.13021135865071787, 0.131296068673732, 0.1330948883043237, 0.14670040547256136, 0.12730028329276688, 0.12729704878123194, 0.13922222770006787, 0.12319759640085903, 0.11309063115042117, 0.11582855323242625, 0.1358343542188264, 0.13224887431324128, 0.11656059889093229, 0.13557439419188955, 0.9782961460312742, 0.9939727671878283, 0.9761781831827288, 0.9827893835973038, 0.9780205949810826, 0.9681169060257169, 0.9808348648591381, 0.9760383363332258, 0.9689786664160254, 0.601119807343389, 0.5945932291669263, 0.5876823935273163, 0.594804714003408, 0.5980200366454497, 0.5719377616811216, 0.6160802233250977, 0.5691537096557251, 0.6089085999284543, 0.39219346323463866, 0.21268522474338092, 0.9294442048154986, 0.9583115594655003, 0.2803819521490497, 0.9363348271698243, 0.9579443754892625, 0.2485019954756723, 0.2385388544047169, 0.5432251748677055, 0.5914583453664243, 0.5442533305325289, 0.5184327046749169, 0.5618553880369588, 0.5223299962176154, 0.516444111600191, 0.50613309015544, 0.5069039464279073, 0.5187791374347189, 0.1360256456080109, 0.5186132829215201, 0.13717623973011828, 0.5100350232282982, 0.49272258467305385, 0.546603942472412, 0.5098496604530076, 0.5341444441875474, 0.3039838239625623, 0.3693486826340485, 0.29982794505245003, 0.40247773529188935, 0.3666831507609689, 0.38959414896528566, 0.36954966261372746, 0.34699550900650133, 0.3621053350325668, 0.38810663935472234, 0.3833556350462556, 0.41950666557292016, 0.4480443836866769, 0.3793918856773153, 0.2531516758810629, 0.48597695633432436, 0.4974871783953697, 0.47852608370096394, 0.2739208776407631, 0.20280914082165213, 0.1640745419119798, 0.20431242208807388, 0.2739549823747879, 0.2749463055656257, 0.23185763580592356, 0.15831348013815483, 0.28010691827255707, 0.28664770311792176, 0.2974790856916617, 0.32977729627228813, 0.340585057427671, 0.3268326462372161, 0.31688757196415107, 0.32126973655086233, 0.30500668971505984, 0.31492566968880553, 0.6790305555483678, 0.7126799507600692, 0.6812545708189217, 0.6849204609795445, 0.7034867572191094, 0.7001878556270402, 0.6728804501721102, 0.6730636510492102, 0.7005044610080147, 0.14140513381473596, 0.10779967420499648, 0.10187009971083338, 0.11943179293254724, 0.1003114723480587, 0.11234808723968837, 0.11411071957234109, 0.1622355394504752, 0.13380889745025493, 0.17426752543871404, 0.14892077129701087, 0.20762012068036573, 0.19429887631277565, 0.16123502549668123, 0.14621480662186603, 0.18733709107450935, 0.15914254448938736, 0.2786705037251812, 0.47135815355710664, 0.4526668869425262, 0.4650811476520623, 0.4520898009271497, 0.4476341407246629, 0.4534057372638006, 0.4762027698538954, 0.4583160271493796, 0.44762075756430675, 0.3900960303770836, 0.30887230259509424, 0.3924887820414107, 0.3929052900395338, 0.4228474432138627, 0.25711330619695016, 0.27729588920789705, 0.21940126501446244, 0.362969610708202, 0.22800139375900652, 0.21453638264711972, 0.20970933942884762, 0.22543784766854524, 0.21871821483542486, 0.2095188062326203, 0.23700604985985252, 0.20256368575877337, 0.22363397094632498, 0.692013146644703, 0.20728962789937921, 0.2502096468166376, 0.23842755979981345, 0.19443902474570662, 0.5250935406294299, 0.643359016961304, 0.19314158684697336, 0.42322295156232725, 0.18696942770499259, 0.18802430077896193, 0.8976205339990797, 0.91096868346854, 0.1698324203956343, 0.198444359865956, 0.8361799031673127, 0.16027759855060408, 0.9117952697651832, 0.9080505405020316, 0.9185796738358619, 0.16831315526522705, 0.16951859641377887, 0.7402204480064407, 0.21192254637513597, 0.21334541723411593, 0.2117736460259152, 0.8902489106933036, 0.1901452823208063, 0.18029105845780946, 0.2063643907612277, 0.18719654788368056, 0.17231818233813478, 0.18424338833962428, 0.1983474253310361, 0.17963149335926176, 0.1879050645977205, 0.08891294238961778, 0.08924255621339583, 0.10338662573302171, 0.1031466419639332, 0.10747494792693468, 0.07672491730603448, 0.08388068222944, 0.09281918594303495, 0.08480597825693181]}, "mutation_prompt": null}
{"id": "e0b4d5ea-31ee-43e4-b497-3a4c7ef7d42e", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = 0.5 + 0.7 * (1 - self.evals/self.budget)  # Dynamic scaling based on convergence speed\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce a dynamic scaling mechanism for mutation factor `f_scale` based on convergence speed to improve adaptation.", "configspace": "", "generation": 68, "fitness": 0.43608089893221275, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9026699440617793, 0.9058119116870424, 0.9006426512705986, 0.9150017279255649, 0.8871861961498162, 0.897774898626183, 0.9048673718159372, 0.9101020774200665, 0.9066259037681549, 0.6858470349830805, 0.6993059407594646, 0.7448917313320831, 0.708737387228773, 0.6885945742431823, 0.7057751661581224, 0.6670656572354878, 0.6780266605847518, 0.730094680660804, 0.12969187433976026, 0.12105263385591147, 0.13531271341197992, 0.13753391712775942, 0.1404435727221589, 0.12957015442217723, 0.12669993389912904, 0.13403311830578912, 0.13366168007425638, 0.1212929521865479, 0.12405364641963934, 0.11822353475467284, 0.12088936421500363, 0.12141467314913568, 0.10238054622344883, 0.12429555137183379, 0.11413080419163413, 0.14512813391040946, 0.9530192497667336, 0.9512528323630102, 0.9631995595725844, 0.9502823365671588, 0.9446825307680645, 0.956212152579337, 0.9654866412280969, 0.9687843409233351, 0.9523731354795025, 0.7004246449639733, 0.7115092898758899, 0.6408407210573668, 0.6680236916092037, 0.7368892795202495, 0.7050219951332409, 0.676273626178151, 0.6735415940635413, 0.6766019604825994, 0.8891525262984492, 0.8568647386991514, 0.9692475415568064, 0.9459111700756726, 0.38164881421971153, 0.2816762706425221, 0.392909791813846, 0.9461962941980883, 0.25004940344859006, 0.5688866103464403, 0.6717674684345643, 0.6221515475180713, 0.5422314732756722, 0.53971864981937, 0.13493921168700362, 0.6029767229382328, 0.6430895346008976, 0.13517388058934598, 0.5956735982655802, 0.6726068709799649, 0.1362518363208255, 0.5857819836602318, 0.7570537596363625, 0.6465670496049962, 0.5823912207161954, 0.6317263289937286, 0.6410860449537401, 0.435244581205832, 0.4277496818315919, 0.423717907078473, 0.5217241610884282, 0.5258509889804794, 0.47339032129422776, 0.560114930665568, 0.37955633587080984, 0.4543744750008023, 0.48698269294751106, 0.6487579702795321, 0.46152279977364363, 0.4640073124588422, 0.17004277000880208, 0.19384467505523284, 0.6329018267057933, 0.5034878086779495, 0.5616259462477576, 0.16404911071974515, 0.21314244332594257, 0.15209858767842888, 0.3303370200869542, 0.39143573810589116, 0.3093646683693321, 0.3635691722337314, 0.3284648472912779, 0.16137174184109482, 0.4137590853850528, 0.4377520094288808, 0.43191560993787026, 0.4157286253385458, 0.3700676698463381, 0.3815585590165942, 0.4283822332335324, 0.40895157203929045, 0.4121757501370754, 0.803980261276195, 0.783657983659666, 0.8027818120569037, 0.8069025636125945, 0.7982056774833018, 0.8078306473533067, 0.806752922540476, 0.7814491785697807, 0.7977811127475782, 0.12152442722220225, 0.13186354883069762, 0.12736465726086865, 0.17015934067589444, 0.39728622027387395, 0.11203547941992675, 0.11761888159965705, 0.11204803003454311, 0.11668803093921143, 0.1575957313323173, 0.14198459783748607, 0.17802534413946103, 0.18724989685747795, 0.1637778847099084, 0.16792521866330568, 0.16869891107102197, 0.13843694904089865, 0.168735280190205, 0.27829980000119425, 0.5207592720098261, 0.35253919977601167, 0.5378363830302466, 0.508546788515998, 0.5077949653519958, 0.5319753875184374, 0.521568848825182, 0.5179394611860609, 0.3057940255334385, 0.41468552276820714, 0.432670488311515, 0.41978961243478796, 0.41892167722001006, 0.2694235451215027, 0.4597734175696576, 0.21794331902117658, 0.44435508654390743, 0.24076522187687466, 0.25143746596807715, 0.21078313958608663, 0.20326183052254776, 0.22877836293952214, 0.22056793097119876, 0.2067394909622875, 0.21625555689341813, 0.23814844764783372, 0.21386036994550017, 0.1887862078514937, 0.21266889100978204, 0.25443039996933914, 0.626904036221321, 0.2102284965861213, 0.20365797317963275, 0.2427617252192431, 0.22305135703629386, 0.18699002058547498, 0.19511017909864425, 0.18792465435741978, 0.8907140926866896, 0.9292644664400669, 0.19947157491001466, 0.16969126948896518, 0.157827959688006, 0.16875956684668103, 0.890642019137191, 0.9345768484816641, 0.209484129848577, 0.49001647651263425, 0.8605239225703044, 0.20615273386549415, 0.9132123083739423, 0.21219476503409196, 0.1674246068120765, 0.18743310642911182, 0.1912578921042476, 0.1893858217760196, 0.19255062615864504, 0.1788599802319384, 0.19858640264242244, 0.1793304169534502, 0.1806819809195186, 0.20029099965437036, 0.09356033900004057, 0.09912183045945167, 0.09309210335810092, 0.0896256125008742, 0.09871321184535697, 0.09204868932123611, 0.07676240217688135, 0.09339405337146944, 0.09073093608729943]}, "mutation_prompt": null}
{"id": "1f20bcf0-c888-4f04-8987-fb020beef1cb", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            self.population_size = max(4, int(self.population_size * 0.95))  # Dynamic population size\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce a dynamic population size adjustment to enhance convergence speed.", "configspace": "", "generation": 69, "fitness": 0.2808858608480026, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9414955412779079, 0.8328854012454441, 0.9453239452199143, 0.9454435914977377, 0.9535390326596961, 0.9450052076293931, 0.8964770862652194, 0.9493520544681037, 0.9386307769724016, 0.8816946618998012, 0.8998732717598241, 0.9069453408902285, 0.886346320242513, 0.8910866839110101, 0.8925269871808389, 0.869051505379318, 0.8746910253434099, 0.8943203354092444, 0.2258597104535527, 0.21842476319483517, 0.18099067078768172, 0.2437096801125226, 0.12986929945950998, 0.18677787328555007, 0.12568767011691395, 0.16391768827339015, 0.12033696711488662, 0.10520636205418976, 0.0948623856725117, 0.28880011874387757, 0.1348685446207608, 0.09642335174656924, 0.15593126199396867, 0.037646579432627725, 0.2048162607416497, 0.16578044314916063, 0.9866574437239056, 0.983902481835535, 0.9799101798478053, 0.9837124534114403, 0.9848019950633661, 0.9734321280061282, 0.9809913303880902, 0.9769876593654352, 0.9803161426430175, 0.3969996285515195, 0.32073616771565383, 0.19011630122133638, 0.4020847862781254, 0.3646186464762462, 0.2580865431797216, 0.2485660063707864, 0.19237903745630924, 0.3015734708579859, 0.21801929857906066, 0.20858603078583549, 0.37465178422720524, 0.3043326689664845, 0.24149329558896815, 0.2505404255964362, 0.2846695307465461, 0.17827404285656778, 0.2763344453361676, 0.15894535651785158, 0.19176178555954115, 0.1765433886885034, 0.18446393556482343, 0.22065538923017614, 0.15177539362503045, 0.14717310001250283, 0.16151116217280082, 0.3578607997134228, 0.1396484879145894, 0.20179440573640295, 0.13821618776211342, 0.17842927431900257, 0.16782079865841915, 0.18403079139706113, 0.20346453538940246, 0.13816494230225795, 0.1595496332596853, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00040914911935618914, 9.999999999998899e-05, 9.999999999998899e-05, 0.061716194118032086, 9.999999999998899e-05, 0.06591805576158727, 0.12471788692846164, 0.10060711162850877, 0.0860851125675055, 0.022408850140059777, 0.1327982966666168, 0.13285181543569902, 0.10988727556340672, 0.08361811436083133, 0.015866595775004266, 0.03207448800663404, 9.999999999998899e-05, 0.08261824381223759, 0.13742780094289264, 0.03524767301082665, 0.16877820076010608, 0.05145527549856965, 0.07781731027553429, 0.1322634119993088, 0.17648799004854665, 0.06194885877846157, 0.10374567341498608, 0.15418310337508934, 0.13006959887974157, 0.08546281464246874, 0.14107173281831276, 0.163504719944786, 0.49979107147899904, 0.44979930198137874, 0.4931202166259684, 0.4480200916454562, 0.48255897190923613, 0.3727643431623737, 0.45188655108811204, 0.5269486583799637, 0.44131198158262375, 0.1216750187208161, 0.0987065615077759, 0.09720472574328232, 0.10342638200896503, 0.10468070162508125, 0.08869630898092074, 0.1092468306014287, 0.13389102815970566, 0.09664978614091502, 0.15118168383882113, 0.1767672417641195, 0.17337928237575584, 0.13560811258570715, 0.14515004251298447, 0.16486391443101234, 0.16555404856526312, 0.16633688723851248, 0.15187402935443983, 0.18565594709561517, 0.20434103173215445, 0.2398779881742633, 0.30764868451955585, 0.24693722937243034, 0.23452624008827339, 0.38698128108462904, 0.27147207025031905, 0.21453327387390597, 0.2212619423994976, 0.17645686956683126, 0.1290600508874692, 0.3422277403768137, 0.16989349269130383, 0.23524997164557038, 0.25031402679821313, 0.1719028277638205, 0.2151188906944087, 0.19206565261571962, 0.20308424542499293, 0.2085274262435569, 0.21885795892847137, 0.2116792051592027, 0.22458600423900155, 0.1915359545266575, 0.20438627826581246, 0.20236364112228833, 0.24829934141343657, 0.20851228505594366, 0.18778314931859563, 0.1931684245120976, 0.19459408943656176, 0.19561033401979355, 0.2105780343249971, 0.23077212396417657, 0.25306340280771533, 0.1876320159987126, 0.19068655009962387, 0.17560685083899918, 0.15524778256044613, 0.37426609074796957, 0.1680355584759594, 0.754008173340017, 0.2553090808607966, 0.13029560960692455, 0.30536322673438576, 0.3914087471320923, 0.20966520494305374, 0.2074929075633316, 0.313497136356255, 0.16863878494102902, 0.25658049354379187, 0.30467994147938415, 0.15996852433584285, 0.17833268423009363, 0.17662177521715583, 0.20001274393959723, 0.17796960235947468, 0.1833426014959959, 0.20154933199473613, 0.18874343582640019, 0.19581166025264984, 0.1801181768750223, 0.07511115087854736, 0.07059691090110132, 0.07598842466890676, 0.09099290118327297, 0.12264225050757671, 0.06852659314341614, 0.08510833893863656, 0.08710910782595926, 0.06934164158868172]}, "mutation_prompt": null}
{"id": "65114b83-9b2d-4852-b50f-ba498a9a8a90", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.4 * (1 - diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n            best_index = np.argmin(self.fitness)\n            self.population[best_index] = best_solution  # Elitism: Keep the best solution\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve convergence speed by adding elitism to retain the best solution within the population.", "configspace": "", "generation": 70, "fitness": 0.45206776001342713, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9222344402531002, 0.9228973734260824, 0.9293969182802839, 0.9188774185830537, 0.9215821483612546, 0.9326031205243148, 0.9328623558188918, 0.9284201600345972, 0.948894954846792, 0.80179840229158, 0.7636771397667138, 0.8003460505422093, 0.8087665692227741, 0.7764960752830198, 0.8002742269532381, 0.7879668309401882, 0.7590918840705936, 0.7898715823051761, 0.15244638018995593, 0.12357064154645125, 0.15233793682667307, 0.1520640207229943, 0.15927482220718125, 0.4809283479940504, 0.12615333038802623, 0.14323531219350605, 0.16540595754558785, 0.14895174915614717, 0.13187213654700658, 0.13212515018561843, 0.11541535715139073, 0.11607416057364461, 0.11290898053487963, 0.09563061498165859, 0.12403604636854904, 0.10715685640796979, 0.9559244203968447, 0.9625122569865813, 0.9516375675456312, 0.9706839572186318, 0.9565860353971944, 0.9729695763552338, 0.9628109475498007, 0.9680295343729446, 0.972533782156883, 0.7400447986731893, 0.6753507232301813, 0.7051009569097493, 0.742715716051662, 0.6948724994692959, 0.7159745401839339, 0.7117507395918412, 0.7107712221426736, 0.6716450924327089, 0.16413487517368863, 0.19366670311989775, 0.23184014122507135, 0.9021054130663329, 0.19362235012738993, 0.9100941841233136, 0.9345922404973527, 0.18207077579015873, 0.22730280292496252, 0.6276363598314753, 0.5403237008280697, 0.45230965121378364, 0.13562474496409793, 0.5274523206232133, 0.6038115823202961, 0.5816412008821614, 0.7010356691439985, 0.6059105312034997, 0.508037738566574, 0.5897968222891166, 0.6685757453986347, 0.5510942109098146, 0.6870059457775994, 0.5394585511776, 0.6367925684240299, 0.6792648745170389, 0.6378101122660689, 0.08630808274801183, 0.4013923779875108, 0.39277299034654356, 0.6487965157035143, 0.6573642681153853, 0.4540665958274511, 0.45517708285700387, 0.6182493041955452, 0.6141881062940342, 0.2577853643028378, 0.41497506509323945, 0.5123656309976796, 0.5519106336435696, 0.09624000478737216, 0.49636847008256546, 0.6719237154314055, 0.6586222705225095, 0.3638614201301962, 0.3944494677458844, 0.15316267647328552, 0.2986940961576201, 0.5727755354081567, 0.33157071310608754, 0.4256724653584274, 0.17178731525405988, 0.24326082961472495, 0.37059925361150414, 0.516076174590552, 0.45610649486273847, 0.4954922622046606, 0.5460366374856552, 0.4971805702184774, 0.500556845314198, 0.5183067360178394, 0.42155942534022683, 0.4326348374267066, 0.8163189855784587, 0.8244214792592389, 0.8791794338013932, 0.8474772626765912, 0.8185802564208524, 0.8005395966313456, 0.8405026018497473, 0.8219819363948013, 0.8335866960100928, 0.14661845483441371, 0.14819807973710863, 0.17373972734344478, 0.14125566085857477, 0.13219088981670646, 0.12540187929395763, 0.1351529093456848, 0.14024225973445392, 0.29977524289957513, 0.18480833589212697, 0.34169466374553303, 0.17253321686428047, 0.1840936021283116, 0.17726325680071187, 0.22344625386916472, 0.20476539572822616, 0.1759468930402014, 0.21836661427424287, 0.5422011802032716, 0.5215391178735187, 0.32981188903393155, 0.5257470108882677, 0.3462022378252887, 0.5325770944235039, 0.5306109604771216, 0.30308632322331897, 0.5497424561238378, 0.42352198239244887, 0.33343260931424246, 0.38538094081404317, 0.48454285685551124, 0.44524428582559894, 0.46338925620649885, 0.37693690717093664, 0.22855329192832674, 0.451608899378236, 0.22991067199045012, 0.2157020210047904, 0.2134857917462114, 0.22356161129886765, 0.23239118934768876, 0.2312465734373984, 0.2384716339407229, 0.21819355515828043, 0.222851506770826, 0.24457883873213582, 0.2353149190165027, 0.7301604330396364, 0.20727669847251606, 0.20614060770239118, 0.2508472928302178, 0.21150839862615256, 0.2458058865843875, 0.2083001096446776, 0.18823229504223937, 0.9519743139880315, 0.1881525917917345, 0.20041917361249184, 0.8701765379571569, 0.14813144882528084, 0.9280034587359374, 0.7816569612774142, 0.9176217786059521, 0.9343376395772369, 0.770747795998347, 0.21158406024513132, 0.21101936732760984, 0.2096928291207676, 0.16838023273744873, 0.8070189664584362, 0.16759237111791248, 0.1689925138482753, 0.2055608514062217, 0.18759766070137962, 0.1915482216051031, 0.1972614042687748, 0.18773150603010347, 0.1919898403074093, 0.19442074407005416, 0.17959501160754332, 0.1880778278690325, 0.08079027330757393, 0.09516381380857852, 0.09266808061941123, 0.0958459066990417, 0.08887310989954256, 0.09347157944654849, 0.09050022075031539, 0.08183190658733552, 0.09315337218533137]}, "mutation_prompt": null}
{"id": "69e87340-a575-4cf7-a8ed-6d4d2f81ab1d", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 1.0)  # Adjusted F for better convergence\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance convergence by dynamically adjusting mutation factor F within a broader range.", "configspace": "", "generation": 71, "fitness": 0.4437498012337317, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9198853387242354, 0.9231890487881111, 0.9254205017301211, 0.9195776213431197, 0.9221397004024698, 0.9081739267316679, 0.915687380435008, 0.9202497070439175, 0.9356359867237908, 0.7896109439436778, 0.7626932147517395, 0.7945963974849665, 0.7693916608700193, 0.7822710210330763, 0.7378303130142666, 0.7987993873375853, 0.7739370704614363, 0.7723887279314419, 0.1748716772740465, 0.15281627348767302, 0.15680194408222448, 0.14410101025313726, 0.13002812687994414, 0.1311986738931279, 0.15225340943281296, 0.1326584494003299, 0.12409959844819529, 0.1065928057662564, 0.11525939926300999, 0.1216137458515626, 0.14855670187408454, 0.12111476115864117, 0.132447896495959, 0.1168661596369126, 0.12138570926878, 0.11381815331696654, 0.9720394403185068, 0.968187192656346, 0.9794992689186246, 0.9539410259792438, 0.9883394255844333, 0.9514216636189557, 0.9571396543239334, 0.9655210194603137, 0.9797727617072376, 0.7193135887420326, 0.7522312663239783, 0.715321994849252, 0.6915682130912332, 0.728192679229124, 0.711812504084929, 0.7295772329786276, 0.6709498645221005, 0.6295328932831287, 0.22999173701539333, 0.14002196685142643, 0.23112436689165938, 0.9502777986249739, 0.9603086207617154, 0.9138045425225697, 0.9319422070913598, 0.19748751893202465, 0.9379727262903518, 0.5319747111429332, 0.5144635760013047, 0.5733696274523236, 0.1352780802929494, 0.7779652117204908, 0.1362231673220189, 0.4572254333721131, 0.13589820724645196, 0.5858486220554152, 0.5309047714216764, 0.5855419494864258, 0.47108156810484114, 0.7163639122772161, 0.5460301620886716, 0.642467435508477, 0.6616700750148456, 0.6157395117216476, 0.6397782022878267, 0.6250900036384068, 0.1681571983971537, 0.579143681529776, 0.4920964604751654, 0.4814428952818609, 0.5224278502733862, 0.30122578638979103, 0.24457067759365358, 0.39278977766358747, 0.27048266935236287, 0.6894442865705546, 0.2249832172278361, 0.2330684964237847, 0.05876057700296278, 0.3838281685114763, 0.7104106068655112, 0.3067230302648224, 0.7001379586921446, 0.23993558257484282, 0.12273599774410793, 0.34269362969631956, 0.4162556210639159, 0.31806923699591705, 0.4876716854150682, 0.3823956049373348, 0.24179645654750404, 0.3788854419798583, 0.46830096398918086, 0.4930686758439511, 0.4440191139304913, 0.4697981887294701, 0.47783877429234767, 0.4239258190433075, 0.4437718456027774, 0.437114039509207, 0.5274516111594926, 0.8834269449115446, 0.8319176205711317, 0.844318791186143, 0.8535811937688778, 0.8597519905334772, 0.7861042071057872, 0.8137576050198284, 0.841058223723542, 0.8422445825292231, 0.16029215682931985, 0.12889731101656798, 0.13494903430535854, 0.1344922721180929, 0.150313984373048, 0.14649305455427397, 0.12392357691640554, 0.1081444209035779, 0.7511827622301063, 0.1849543189176327, 0.14522795995730375, 0.16380306928904043, 0.1540437404840963, 0.15730472036301602, 0.15900180387810614, 0.15610678132559097, 0.14970679952395516, 0.17174781012346962, 0.3327236660734759, 0.5684615912656762, 0.36128440089176317, 0.5122568124478273, 0.3437429795708269, 0.5469390330077977, 0.5760019424188716, 0.4998608045759333, 0.5329713199215943, 0.2519227756327934, 0.461357655201036, 0.432563994214222, 0.31294697102887203, 0.5006660692286447, 0.2549224545433523, 0.23374118817779277, 0.5376160268654007, 0.49109926846712015, 0.20552462871720067, 0.22596684086630403, 0.2878669628669416, 0.20721151773242497, 0.20407552046225663, 0.21089371903281218, 0.20972651500707906, 0.22640662193236505, 0.21895198966925045, 0.813410229836954, 0.2159956799359325, 0.3664388949450703, 0.22458744189922453, 0.21487849777831847, 0.2140256118276106, 0.22374190105941238, 0.21101780846724527, 0.213948056570487, 0.18761694295894926, 0.1873085978207264, 0.1886160736216299, 0.9334872933786212, 0.9151713955607343, 0.19881634819813143, 0.16525412118763239, 0.894810124475411, 0.9048176464508234, 0.9150117006343733, 0.7691235042642418, 0.2120154344370676, 0.15271300966184098, 0.2198845599057102, 0.16928854643641444, 0.8541550672845228, 0.10447110324868103, 0.16984242133030325, 0.18611696550556678, 0.17441156808001346, 0.178184749282723, 0.1813810463023987, 0.17015241862784536, 0.20595515205143988, 0.17605667681318626, 0.17487922639525955, 0.1877106153067164, 0.08652573575461897, 0.08883110371055303, 0.09147630692268227, 0.09433240938353993, 0.09488764443014785, 0.09067362331239781, 0.08039254078846336, 0.09151933241545773, 0.08798045703404678]}, "mutation_prompt": null}
{"id": "470051ba-3e32-40a1-9839-1cdd768c9c03", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n            self.population[np.argmax(self.fitness)] = best_solution  # Retain the best solution so far\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploitation by introducing elitism to retain the best solution found so far in the population.", "configspace": "", "generation": 72, "fitness": 0.4545899154484284, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9403246943164923, 0.9419174864005104, 0.9514024768295725, 0.9336601272296617, 0.9398946307824388, 0.9298577635379355, 0.9425007813633517, 0.9418767055865881, 0.9305649893609421, 0.8527557971306485, 0.8296954075996005, 0.8229217685548528, 0.8151964671060717, 0.847028704589058, 0.758521695743134, 0.8462958347663991, 0.8236617078958393, 0.8728557907683379, 0.17850533679242286, 0.16367339020854865, 0.18439319213312844, 0.1527621520894218, 0.15038374640529395, 0.4627088019036407, 0.32044467823483014, 0.15883966425405927, 0.17222187955141344, 0.1460779030950342, 0.14345822644326545, 0.12950721572683543, 0.15655706091949106, 0.15794242314893403, 0.1542229883032583, 0.100221028258076, 0.15520688079584632, 0.11847286198957974, 0.9801871109220534, 0.9607302918858587, 0.9631333939472597, 0.9491847852189812, 0.9918652441082538, 0.9614381859851825, 0.9706446443410941, 0.9681858977197338, 0.9680666723840003, 0.6720330642138861, 0.7966882875584306, 0.6805333926956574, 0.73316370463707, 0.6217618617892027, 0.7510726043035234, 0.7647880350543126, 0.6952843520588241, 0.8174134828479767, 0.36292825294953057, 0.9237224955623397, 0.4059728853367177, 0.9710686928982846, 0.28076799687777576, 0.16240491028861193, 0.9368913086167489, 0.12277490856211548, 0.23802460055550168, 0.5922844653486548, 0.5338393654470097, 0.5570461986189528, 0.7482638803662162, 0.8321715333666077, 0.13734549752957848, 0.8504946945786829, 0.4146427478314316, 0.1359950897113109, 0.5030646971620827, 0.5126120082141816, 0.5596284759759864, 0.5761984334725683, 0.755806658694825, 0.703850960734526, 0.5283555216975515, 0.5327589221069106, 0.578848209747312, 0.21295333458130128, 0.4402224423618408, 0.1352994478303341, 0.35856177336486017, 0.2675105228462056, 0.36665826438666405, 0.33472869620333445, 0.7145947076206247, 0.4510975468481493, 0.4153438336405064, 0.31858375427924635, 0.38675553696772225, 0.4099473161385869, 0.48038233996448854, 0.12013767660776087, 0.5502124531731354, 0.6924594739889677, 0.2720334414763783, 0.3397673696635817, 0.25855331780839685, 0.14015803503350088, 0.5362035960236666, 0.5313782800440959, 0.3081515165190235, 0.3701625595512943, 0.4375150352145565, 0.1673062834763085, 0.29489371368005823, 0.4170284742471905, 0.464194024155378, 0.4025264543881031, 0.5994331350624608, 0.45670594116317, 0.394139934760132, 0.3711225003817845, 0.5235415860474733, 0.7316278166274677, 0.763627481657086, 0.8521458303466052, 0.7735398752004873, 0.8252274748275842, 0.8793341075649024, 0.8474208166999239, 0.8150980705659755, 0.7686548394564808, 0.15285960657204412, 0.10465865753190151, 0.15668463721303505, 0.13515694323078764, 0.13816275362737052, 0.10993098853312189, 0.1419551110457512, 0.13292940882896886, 0.14884340097787685, 0.29336409034914124, 0.689963382603442, 0.22107566243410848, 0.22900326924337155, 0.27876066995429505, 0.2879225901240259, 0.19083746025263104, 0.34338779636922057, 0.1793662682145163, 0.3279569050885699, 0.5988192841073086, 0.5676869893944324, 0.3599071234342347, 0.3134302922319182, 0.5850175925683241, 0.6655530731586541, 0.2932483568752028, 0.2685388127821783, 0.27488881534782383, 0.3426513877763183, 0.36722157697768454, 0.14756843193435432, 0.40551688134285424, 0.23809953088210212, 0.2280805558911263, 0.2423220713548513, 0.3368235176267671, 0.20074990393970704, 0.2026989448126777, 0.22950091607111656, 0.22602788363099802, 0.20402218703650188, 0.21011698424528358, 0.22904744873418414, 0.25920685386998543, 0.21688914208192567, 0.2204039393449222, 0.8118770258385448, 0.22310988332026738, 0.7803464744392655, 0.6425835567049449, 0.20951397799484295, 0.20803700314129514, 0.7884224726096452, 0.21000888669299445, 0.8400950350763877, 0.18827309756667987, 0.18855855421095125, 0.14867690905110353, 0.9497443531651961, 0.1489097877752592, 0.9536142878940528, 0.16442430333700864, 0.9631187094962526, 0.9451460296170262, 0.128372009338795, 0.16830464264310885, 0.21245662236511942, 0.1679586806650536, 0.8844020243493869, 0.915583985480716, 0.21244178193623597, 0.16806441132587957, 0.21959034850707315, 0.20729494952986438, 0.22096873888634017, 0.3908685650752842, 0.21407631693997276, 0.2305501915141469, 0.23590877012214984, 0.4850105647981836, 0.18822132170338668, 0.07723709397852851, 0.09416868889524443, 0.0850034429697547, 0.08610677195318073, 0.10859394901172892, 0.08844676423796827, 0.12355051955812124, 0.09795734768939146, 0.09155346962197108]}, "mutation_prompt": null}
{"id": "4f2a6c87-91dd-409e-bc02-39db21b65356", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i] * 0.5), self.lower_bound, self.upper_bound)  # Adjusted elite influence\n\n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Adaptively refine mutation by incorporating elite influence for improved convergence.", "configspace": "", "generation": 73, "fitness": 0.25226448834086307, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.7060434948245637, 0.5052278080716825, 0.7456722496830291, 0.6373565069900258, 0.7620065060191972, 0.6423162156273295, 0.5700884469663487, 0.7550607571209538, 0.546551004194203, 0.058316240645722384, 0.07716518044201404, 0.09408636722199148, 0.09486318370776137, 9.999999999998899e-05, 0.2805179423442288, 0.08472890491784368, 9.999999999998899e-05, 0.08621279353070754, 0.13227237555043725, 0.14893018124528334, 0.11312439463433077, 0.09897472332897828, 0.121072252921546, 0.130867025114494, 0.11371652782419495, 0.09016786652633213, 0.1175297883492622, 0.1178465664434476, 0.1259691335850115, 0.1203201038419005, 0.10679819143331803, 0.129893730956248, 0.10702524733843621, 0.12504584230302884, 0.08615427005246656, 0.168003709108843, 0.9837910748961681, 0.9869530827509065, 0.980847162598022, 0.9709296435993302, 0.9863063819749839, 0.9805675798917104, 0.9768394349781352, 0.9870544576395583, 0.9826026367477576, 0.13052178263311598, 0.10833388092665575, 0.10508383836350255, 0.15000261272365956, 0.19322940859846927, 0.10952579352712799, 0.10773488853545299, 0.08903558889173091, 0.13650653603492724, 0.33660710305072794, 0.21505641819117272, 0.21901670215257896, 0.9528204810637584, 0.2843571978985606, 0.28253978597125284, 0.2396272766819324, 0.23375443417900044, 0.23844947234469893, 0.14341675418951072, 0.24335986751829553, 0.13118905059130193, 0.13159965389851058, 0.2917451539352952, 0.17443411085103633, 0.1417268836982425, 0.12990439793707464, 0.13521300803523606, 0.4363739542433943, 0.16346512848427885, 0.13980239227440439, 0.1654643715029004, 0.2801532842311856, 0.19335543732317584, 0.21487523344128745, 0.15270862135779117, 0.08468592215640125, 0.10585609298289378, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019743503798781425, 0.0684032595126659, 0.04495853782129566, 0.1404691244812455, 0.06698145877202333, 0.11821566334291833, 0.1056811136520186, 0.2738572637988643, 0.20244725189480062, 0.15962184215638464, 0.0626109679819743, 0.20681494393816047, 0.19539603441951592, 0.06041539243575478, 0.14576458759440536, 0.10840807755292914, 0.09659864131174234, 0.08977047677079808, 0.10105469971251968, 0.17681546405159676, 0.108741926805909, 0.1242364331614344, 0.18700033632368818, 0.09597821502131287, 0.2139373599818426, 0.0943969147487631, 0.06404614228628758, 0.229703384220449, 0.046741951694635464, 0.16292193493763374, 0.10152540458851622, 0.17900593384460572, 0.49652775492377865, 0.39752933443525973, 0.5469779560709005, 0.4862876150133709, 0.3823241604990092, 0.5285999890218753, 0.4489275679292005, 0.5422085511845331, 0.5068528155635014, 0.07943729720568404, 0.10786740602600586, 0.1435439772399344, 0.13076908403887888, 0.1445423123594919, 0.17585868584879116, 0.11018821273475299, 0.13428162548965283, 0.14406228616286476, 0.19538031627808738, 0.1493837147769762, 0.1597216276178084, 0.16651212656605474, 0.16156371210316323, 0.3059746905067242, 0.13705805967197282, 0.1840043230802687, 0.17122001326624814, 0.426853838255591, 0.2354256975084732, 0.30404283259642695, 0.32236054853832163, 0.26690675870066116, 0.203745840931425, 0.26452636379846217, 0.245716584028016, 0.31468108386265947, 0.32499439481822046, 0.32996126435593587, 0.2381425365887584, 0.28124765593402357, 0.22993501424443474, 0.2658993395271605, 0.21564359399397315, 0.37834738631640796, 0.20521025813143046, 0.20351605474013668, 0.20125139934418468, 0.22668392639091917, 0.20091154932160005, 0.2041389592414372, 0.22772869503174753, 0.21294260980619373, 0.20652048627037234, 0.22333678089969655, 0.22783787658048527, 0.22655550960532367, 0.22013176452982886, 0.21482121291341616, 0.222226682756417, 0.24891512339526667, 0.22253507003114414, 0.21726641612847353, 0.22020785615231198, 0.1860121323272248, 0.18761533766368776, 0.1686643256488105, 0.20050765271162707, 0.7386825386669098, 0.8289396343945943, 0.9099213108089085, 0.7503465886133063, 0.1672957102859013, 0.5260247552357664, 0.3061990820265138, 0.16878441474379924, 0.18627720935008651, 0.3139947522548475, 0.21209284468758338, 0.3723890664624555, 0.2035364220821282, 0.16919088521845482, 0.1803209519224641, 0.18142739233678562, 0.196909750398776, 0.1751424939231362, 0.19601811761248034, 0.1890404930672337, 0.18443065991219887, 0.18425115559849636, 0.17205194862041007, 0.09346847394862323, 0.0944868852906493, 0.09735971012215416, 0.09319630428520254, 0.08879906985136676, 0.09611117689608362, 0.11249541944821995, 0.0873528503911184, 0.08867318637543864]}, "mutation_prompt": null}
{"id": "355bf18e-125f-453c-8743-c972ef3a1cef", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            \n            # Change: Adjust scaling factor F dynamically based on current best fitness\n            self.F = 0.5 + 0.4 * (1 - (best_fitness / np.max(self.fitness))) \n            \n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce a dynamic adjustment to the scaling factor F for improved adaptability and performance.", "configspace": "", "generation": 74, "fitness": 0.42231960620629183, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9388835521778272, 0.9340770904346378, 0.9298032644562405, 0.9327348174959209, 0.9400939816171834, 0.9213037292758716, 0.9217637577685334, 0.9244749603028212, 0.8969134708228691, 0.7919393410870673, 0.796109964216001, 0.8069645955168693, 0.8297185487365825, 0.800545893090247, 0.7948822296680703, 0.8186610846116124, 0.7892671384504957, 0.820661189930028, 0.15457571942582726, 0.1610295146642271, 0.1459984717295585, 0.17369237282164596, 0.13034726934231022, 0.13772649431677142, 0.11877766305497572, 0.13574194093367875, 0.15670564514957497, 0.11067858944869569, 0.09721279873047095, 0.1475936683703345, 0.1363297204051238, 0.11369756213944726, 0.1087713661761549, 0.14656025212606383, 0.09170742064386161, 0.13090774779330094, 0.9531095636333632, 0.9659226961723173, 0.9531135308250777, 0.9811499641133525, 0.937761362850372, 0.9539847271189565, 0.970239829488514, 0.9847459032855661, 0.9825583779755012, 0.6981012666191775, 0.7194996994243574, 0.7557541870000748, 0.6289747010488344, 0.6985887014645047, 0.7019597363395175, 0.7928504683031219, 0.7719225799275767, 0.7392791117194564, 0.17109657372555098, 0.14098064838774316, 0.1635823268822424, 0.2830854356876292, 0.2766960248273024, 0.28110635603966183, 0.22593074089128984, 0.4123452758751679, 0.1785601307367135, 0.6985793754996172, 0.6518803491080147, 0.5707717269314256, 0.6372303332638414, 0.42248902391170595, 0.48697412542341434, 0.5451506250441231, 0.6219076227008069, 0.45411016644590174, 0.37200834729959575, 0.5406309281786854, 0.6101726455988437, 0.37108321835542624, 0.7872503962980104, 0.47669057095879375, 0.6754905164950125, 0.5768965283813099, 0.40198191536609396, 0.5279011434520948, 0.13575448791131528, 0.19936022618788385, 0.2396170904561289, 0.7014821737957739, 0.14397103354377305, 0.5075914104128146, 0.17056895725577392, 0.3137992891543019, 0.1831118451359961, 0.23175200594707224, 0.17486890616133588, 0.35178132176827437, 0.18199806881774694, 0.22258466581729575, 0.4326665517166217, 0.24984896541869472, 0.5479240684738479, 0.08814476375333236, 0.4454129037052855, 0.24008722719681108, 0.3422182843151279, 0.427742802595955, 0.19198164464913559, 0.25101810236868305, 0.19309326096461088, 0.3169024924066226, 0.44444006296885863, 0.36047810397485136, 0.30204735620199563, 0.4872330804230943, 0.40108149910134516, 0.38070760319865815, 0.33263968909634223, 0.3950744622426191, 0.44601386203296267, 0.8166766690291564, 0.8002550644552152, 0.8155209048922223, 0.737332172218776, 0.882353316900409, 0.7038816562933345, 0.8151932622288756, 0.640571839138093, 0.8603126469262208, 0.13860397883735498, 0.1282839768090187, 0.15708890278200505, 0.16550926315047854, 0.14187487223395323, 0.10094849408460138, 0.12974184076498751, 0.16562487405992, 0.1608549219762312, 0.14818520476364028, 0.1720774857286288, 0.15997920497862983, 0.16154143050524472, 0.17145638742138958, 0.17542545054984526, 0.14993297595216082, 0.19206237885307387, 0.19242267723400175, 0.36448352575873366, 0.5766596912657267, 0.5296978934995717, 0.5935275120851846, 0.6483305192155848, 0.5733979239481659, 0.5824841663823985, 0.5973925129933573, 0.26123447127403876, 0.27575356455830713, 0.45243337386514837, 0.2612252812969469, 0.3007843320479274, 0.2672720637079343, 0.4647605865613903, 0.5122885118030117, 0.2965400560277819, 0.23508719971990855, 0.2215443424691752, 0.21750036947518725, 0.21997160462064436, 0.20179553824081908, 0.24197179387350698, 0.2186581760702574, 0.2110672049261053, 0.22122243746272097, 0.203080554900277, 0.1864903735137421, 0.21593401670432777, 0.19028228208380338, 0.1920383714622026, 0.18959966036932918, 0.7107776226905587, 0.5816379757334043, 0.238599268904939, 0.5948266580223224, 0.18815927884048178, 0.1864148080441136, 0.9001305600922275, 0.1584796929239406, 0.9385281536702696, 0.8422934078322278, 0.8317479230544274, 0.8965033378302041, 0.9439617412673326, 0.20728555922783876, 0.9056878673349358, 0.21043197163914096, 0.21099868032314606, 0.20558927592520315, 0.1686771204600096, 0.7598682559384824, 0.49400374751016085, 0.16659411338644936, 0.1964856897451418, 0.18241809846858903, 0.17668264462554728, 0.17954599847879038, 0.190653423861892, 0.18113476098753667, 0.18668990338393854, 0.18153221766779482, 0.176381901965446, 0.08952405123515617, 0.09079176375495568, 0.08648569029326625, 0.08810444303811005, 0.10631668745175105, 0.08883750065723284, 0.10866617397353873, 0.09199583688526436, 0.09541879330508185]}, "mutation_prompt": null}
{"id": "72262c71-61b6-42e9-a6ab-23f59b0a2a39", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.6, 1.3)  # Slightly modified range for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Refine dynamic scaling factor range to enhance solution diversity and convergence.", "configspace": "", "generation": 75, "fitness": 0.44788980281853835, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9209959386824164, 0.9258667447101953, 0.9260053496974867, 0.9318865292068427, 0.9232256332066822, 0.9185214007190724, 0.9272859655977966, 0.9185848447700676, 0.9391928049878774, 0.7342360834447721, 0.7814405345007801, 0.7799428264650268, 0.7781264604450131, 0.7629150120991526, 0.7506803757203298, 0.769948857934015, 0.7434468600448465, 0.7371467424430695, 0.14202711363212417, 0.12847240737532517, 0.1554384004064272, 0.19172265254916365, 0.1429584312954021, 0.14711575379677255, 0.12780663783466029, 0.12946407992832065, 0.16025847448923036, 0.1191083783275646, 0.1305126756826256, 0.12890156814194254, 0.1346705146535664, 0.12232252747254224, 0.11980537604491126, 0.15053375794099721, 0.1240111048020901, 0.115556723382497, 0.9593195930952679, 0.9574957847422273, 0.9678244130632047, 0.968832176987231, 0.9887679590979034, 0.943664631214988, 0.9667989363740065, 0.9603651554882675, 0.9759389329154875, 0.6514016923716801, 0.7290301017466931, 0.7389564068363668, 0.6739220390701373, 0.6462425441282531, 0.6652914020982175, 0.6934350560656668, 0.6772939605958217, 0.6639738599250444, 0.9374174866936159, 0.9421696264560668, 0.2314873472012391, 0.9550718519519372, 0.2145045936619746, 0.9396714817288814, 0.9467471487117329, 0.2352667691735556, 0.9599126795795405, 0.5992145059111583, 0.7920940633563329, 0.6317159199025493, 0.13580585339006845, 0.6641303210460594, 0.5653276974282012, 0.5600614794019627, 0.6438621891285956, 0.4926822448092648, 0.5387402839831421, 0.6373833000690459, 0.560226594911229, 0.5856177122825321, 0.6014777033038594, 0.5403727485747589, 0.5559980760637265, 0.546105555525676, 0.6439553132601017, 0.2252593238196936, 0.3688780712177474, 0.2931255748437417, 0.4717315980838622, 0.48944039944939055, 0.5438879335113554, 0.5653088325514117, 0.6440085713202197, 0.5048191422068766, 0.32633550445740445, 0.5024730063050704, 0.5615796258553456, 0.34119635031763385, 0.1385975956683002, 0.3644460950877806, 0.6639962665392384, 0.5644158401260316, 0.4968270454395851, 0.22992700886427497, 0.16479569682919226, 0.355412429425243, 0.3577385838070729, 0.40157872472899314, 0.3333567294688917, 0.40263056183071155, 0.28895991220632966, 0.3542267205584926, 0.46215854412164337, 0.3579871120793352, 0.39707620866115345, 0.44703417232419995, 0.4715768384966861, 0.3862511449372644, 0.45748365887246834, 0.4423521627354141, 0.4320377771784635, 0.7847761371792062, 0.7651716965058863, 0.7671039174318033, 0.8165146396668963, 0.8153875409348887, 0.7775909841709174, 0.8148555450488452, 0.801550678045812, 0.8222997781958007, 0.11622803312927354, 0.13957522170816916, 0.164196980159395, 0.12616581437747687, 0.15334664757788918, 0.11400068868655744, 0.138425485341228, 0.14104204303679513, 0.14026286048591408, 0.15381058534016956, 0.20518242309246426, 0.17064457999860427, 0.16992418976627666, 0.1511593495044975, 0.19507349387778672, 0.1949574840378112, 0.19376208283504948, 0.16238116945261882, 0.5452238547213084, 0.4791760257757697, 0.5215431044919576, 0.2801759747196495, 0.356013910104791, 0.4993255451011417, 0.5036975916116959, 0.5258874989529692, 0.4954771177567141, 0.3112267023439167, 0.39477199652465567, 0.45952686145488375, 0.3811281254932649, 0.24216566956881347, 0.440724156860546, 0.2648296968988402, 0.3090850135519462, 0.4356357113724325, 0.20539669464333243, 0.224054214317581, 0.21029987249809923, 0.24208788206533416, 0.21907611038025365, 0.2215124454172117, 0.2260643415932192, 0.2151716069565519, 0.2439137926879813, 0.22612765370211396, 0.22157811639920988, 0.22443411480803022, 0.22453798806053304, 0.19962238536802168, 0.21096980919373387, 0.2088239418293839, 0.20082973619866817, 0.2712615696145201, 0.9551318794789153, 0.18880986986328974, 0.18750855020144286, 0.14830506557387946, 0.8986306007535477, 0.20255083848934285, 0.8965009541443556, 0.15912239306488574, 0.8960336027289453, 0.9180019612784848, 0.8678623590626908, 0.16727333115406096, 0.16838704729962906, 0.8539062176097063, 0.16524312230318916, 0.819208446569437, 0.2102566329995308, 0.16922888309569895, 0.17963870515044367, 0.1866106252939297, 0.1945669832107917, 0.175838950939455, 0.1861234054691706, 0.17935912587483582, 0.17923744075216796, 0.1874934767988481, 0.198160791074934, 0.09376887063300765, 0.09068994705483269, 0.1012793149805371, 0.08362606857180432, 0.10347929762869612, 0.0901053100556104, 0.08521090404547338, 0.09973024917310813, 0.08592780411710121]}, "mutation_prompt": null}
{"id": "6403d384-15a3-4735-a346-d5afebf0fe21", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n            self.population = np.array(sorted(self.population, key=lambda ind: func(ind)))[:self.population_size]  # Added selection pressure\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve convergence rate by increasing Selection Pressure on diverse solutions.", "configspace": "", "generation": 76, "fitness": 0.3009484373821728, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.8207279557026486, 0.831728440371617, 0.7459421712801851, 0.8226578239127154, 0.808115202537425, 0.816393666375955, 0.8316317243672845, 0.8267605898892713, 0.7972929449771025, 0.43431046083896474, 0.35920335324354213, 0.3607634022622206, 0.44199353292320587, 0.43380710422110247, 0.42718602336806333, 0.3757432878253225, 0.3684275692222623, 0.3350775444891485, 0.12382934228250964, 0.1238766065908663, 0.11575933130879879, 0.11632124504652586, 0.1203177782532312, 0.13999746059131046, 0.10878200887202294, 0.11928369083635915, 0.12672741979605728, 0.1159310135675885, 0.11791119316613807, 0.10574956187115092, 0.10911977072055523, 0.0960738998307239, 0.10918922047407864, 0.12238739333986681, 0.10874917852046184, 0.1077567684031957, 0.9625885039768959, 0.923500685896544, 0.8520585946954571, 0.9573311105527771, 0.9819302086253652, 0.9200953859644996, 0.9492981496760043, 0.9141022201384933, 0.9561865502823528, 0.4484305082111758, 0.4605929957321854, 0.3661314285804209, 0.49017032055214527, 0.4280305069927831, 0.45742876387623166, 0.3968083814972623, 0.4307972566413576, 0.4678253897518021, 0.139986711051046, 0.16907422669434147, 0.2262593239258579, 0.36440723681554654, 0.8876585896144141, 0.27122595397199845, 0.2339828637550393, 0.17754571389156426, 0.23108085910977283, 0.22941231672939488, 0.4012053128114361, 0.27656101933833466, 0.12997695741127646, 0.19333068261158382, 0.20823328614690417, 0.48144102780809195, 0.3729674692870313, 0.1323637575389761, 0.20438951206577527, 0.2701186732477957, 0.27200310468980604, 0.2607452219498647, 0.34998409984556944, 0.2604055791225627, 0.24659268245336086, 0.3139777671606394, 0.3127532468371381, 0.06373630405438979, 0.11406971417246548, 0.02982070611131382, 0.07691734104358405, 0.14046832311664892, 0.0820796845554016, 0.2877017782860396, 0.08141986176091864, 0.04323774475394926, 0.1335517457992732, 0.1729587252427165, 0.16228309989262757, 0.22065724606154447, 0.19517568392896767, 0.09630893188131762, 0.17562422519534315, 0.28217772320796286, 0.2744305136972385, 0.11958262192454294, 0.1564706089383301, 0.06722705010516605, 0.15483508976768134, 0.12387421230638596, 0.0908244619703541, 0.09679370929830433, 0.080147737255155, 0.10947186267899722, 0.21161832460554075, 0.2060265298021462, 0.16796850477306235, 0.28397774952533883, 0.2867342677010034, 0.24855238396294854, 0.2160409086326337, 0.26146366978632996, 0.2763327578104151, 0.6185724948619067, 0.570085766085542, 0.6209871877460804, 0.634999215260356, 0.6341357494710909, 0.5876097412881769, 0.5776206949981239, 0.5989848747896369, 0.6230758522312012, 0.13689091227799421, 0.12954223193395686, 0.1169766381655758, 0.10418141376226997, 0.10367009640490865, 0.1061223814750265, 0.09697932724124292, 0.15633838832467684, 0.1117857564448752, 0.1791107687918424, 0.1597069950304385, 0.156144840714732, 0.1450321519459401, 0.15412840889707424, 0.15878964681405083, 0.21684906665915527, 0.17967408753697, 0.1478638537702962, 0.4228676213591961, 0.3974163158592603, 0.4008399259227312, 0.4215446897860734, 0.41212379587881387, 0.3923963927077504, 0.4136732854722721, 0.36040119815340677, 0.43229688433468083, 0.3377359767183842, 0.3775277797509644, 0.3463789833818163, 0.28863954820957216, 0.3288420179503653, 0.32709778134307144, 0.3357090722796099, 0.20905566490214122, 0.3375829827658522, 0.20611578283766752, 0.22824793273781618, 0.18601027054873853, 0.19799612002230926, 0.2031124600563975, 0.21053610591285465, 0.20019542183314565, 0.21837360578907483, 0.20826106034093939, 0.19696612077916154, 0.19715712690632947, 0.18359670202765754, 0.19165041824181994, 0.2928247414454791, 0.20160555603197694, 0.20120945283915792, 0.18011369701588187, 0.1894299775589986, 0.1836245304762899, 0.1647433228135471, 0.18743282358577662, 0.19410375975635485, 0.8766804557116137, 0.590320444730241, 0.1513874817592279, 0.8340625207601321, 0.1701743587235678, 0.24745712212227677, 0.31600963068908106, 0.21057188143757544, 0.20166177690889342, 0.20662916033060985, 0.18774601118150946, 0.2660023695543272, 0.21057796734026002, 0.37352531044066706, 0.18848075566339928, 0.19325724248026221, 0.16792897001669083, 0.18261401249435272, 0.18757638974121438, 0.21800376798854926, 0.18611744940624697, 0.1858689313840397, 0.16923880285085502, 0.08750493678745663, 0.09294871681999206, 0.09650187543181421, 0.08728934621546725, 0.09328406633082709, 0.08417167051575236, 0.08060185834461242, 0.09024198863823585, 0.08205211007869129]}, "mutation_prompt": null}
{"id": "7887b2ae-6533-49e7-9bc8-d302e052ab86", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 15 + int(self.dim ** 0.5))  # Increase initial population size\n        self.CR = 0.9\n        self.F = np.random.uniform(0.7, 0.9)  # Slightly widen F range for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.4, 1.1)  # Adjust f_scale range\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.4 + 0.5 * (1 - diversity)  # Change adaptive crossover rate calculation\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 3) * (elite - self.population[i]), self.lower_bound, self.upper_bound)  # Adjust elitism impact\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                neighborhood = new_population[j] + np.random.uniform(-0.1, 0.1, self.dim)  # Explore neighborhood\n                new_fitness = func(neighborhood)\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = neighborhood\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = neighborhood\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce adaptive elitism and neighborhood exploration to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 77, "fitness": 0.3935537790100436, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.8694838454901599, 0.8759190693751471, 0.8836880070500366, 0.8866742982899959, 0.8576817952632698, 0.8628795215680706, 0.8944192794200077, 0.87398230316069, 0.8868120095921173, 0.6735193925087497, 0.7023490046961745, 0.6714749624822032, 0.6824510312982521, 0.6992930129721918, 0.7325679887300561, 0.6908876084624826, 0.6726000549311073, 0.6887269506418237, 0.141782848687675, 0.1657087743980401, 0.1291991629561724, 0.15014920502991935, 0.12552313631078227, 0.14696317353112098, 0.13257981599683755, 0.14993198834264132, 0.15697917615471035, 0.12600712186363128, 0.12605759970644304, 0.13263440031224694, 0.11003941964065833, 0.12486588791974973, 0.129649197411002, 0.1332747312693664, 0.1308901193088956, 0.10683048993065691, 0.9590045278184391, 0.9521527029301433, 0.9435690116348628, 0.9458093306594347, 0.9563013322408968, 0.9404741486014329, 0.9378953995587749, 0.9733498176246307, 0.9585790487511853, 0.6240959751701801, 0.6531647470769768, 0.6239331187397594, 0.5972532175874814, 0.5392645274010592, 0.6409255965627838, 0.6160453029233759, 0.6688810541676498, 0.6552453486427511, 0.8532000922731692, 0.8078414551684601, 0.8721278670639903, 0.89762578029314, 0.920380758341307, 0.8793704882867989, 0.8323797990940113, 0.9013380951485142, 0.9055194588359928, 0.5156184484111392, 0.4793536809250559, 0.4657218143826187, 0.6214327197029332, 0.45146651469694865, 0.4935976824559555, 0.4735840718275153, 0.6252239726507132, 0.13392889492593474, 0.48383265114883434, 0.5064813323304362, 0.5138750204584284, 0.39656293440152945, 0.5175252428734975, 0.5279704793734328, 0.5540004846117912, 0.5831738011313023, 0.5730771226409002, 0.2872064535250507, 0.25799663682166485, 0.2192147942186643, 0.1503357312919965, 0.10752349706094844, 0.27472331262120653, 0.11247044597111255, 0.24735209290521243, 0.30639836986897384, 0.06509510335962909, 0.2550861152323154, 0.20834903311883146, 0.17138678398376384, 0.20283092083640253, 0.12261150138775645, 0.28837320284479573, 0.217171630514856, 0.30391683850164863, 0.12056197498305665, 0.060904616421722846, 0.04105590953619598, 0.11867754396279828, 0.12235157798220353, 0.1609814933517839, 0.13772255247700738, 0.08075123265644302, 0.21069065298974976, 0.3713571318747949, 0.3296113805880767, 0.3444285663720549, 0.3791780755347606, 0.36382372103564375, 0.36811092075209917, 0.3589859833173863, 0.3455057869831373, 0.3858838859172359, 0.8052975904476446, 0.7785038797924293, 0.8055412822372974, 0.7526158029683537, 0.7812391601649478, 0.7631464404059917, 0.7346587915351827, 0.7771289711531287, 0.7962287417059795, 0.1246340432219798, 0.10553196601196557, 0.14050503664849545, 0.10184667261199953, 0.11535759089995445, 0.10892233411512953, 0.11999961761036393, 0.10651752973881845, 0.22520346172959893, 0.15106580272717274, 0.1868118784642382, 0.1439146965483573, 0.1512005812918411, 0.17949022707498297, 0.16389006492636837, 0.16672860433972148, 0.1889394702973043, 0.14434412236072336, 0.4816141135327342, 0.45057982305908495, 0.5231195025619033, 0.4639905901065333, 0.45182113558238546, 0.4735385186361798, 0.45252945090517027, 0.4175301403988053, 0.4933065166300523, 0.3530265160331786, 0.3775346810110213, 0.3477951008087905, 0.34820263077022295, 0.3702741094066129, 0.35842933576855973, 0.3685566090273926, 0.3546566783611207, 0.23248129884660762, 0.22245882284802787, 0.2202197445550138, 0.21817816257736944, 0.22017711199389178, 0.2175745420271391, 0.22993855264910024, 0.22329790493152013, 0.21777400483482945, 0.21541358514338116, 0.22165856803072692, 0.2084033893176942, 0.2086292292684644, 0.22594855285676207, 0.21241093439134917, 0.22897585187605063, 0.2195466148973485, 0.2290397278041123, 0.21059323956297915, 0.18275075912537775, 0.18694580548860806, 0.1880026679768444, 0.16477085022859206, 0.871236647827446, 0.7693256885386146, 0.16370670328412218, 0.8084177019116084, 0.6398541295818148, 0.1682863240648096, 0.202100679956969, 0.46863767348933716, 0.20798766366315447, 0.20234218987880603, 0.20847532188088969, 0.21065513608909792, 0.20987958647926575, 0.10357112836474935, 0.19357196980583957, 0.18643132956669461, 0.17622264014062772, 0.19863299365638365, 0.17926346542188532, 0.187626402017265, 0.19391352421693642, 0.2217345628024492, 0.18431431601539539, 0.0877450966002743, 0.09518429097813863, 0.11235268930937181, 0.09243433141404911, 0.08867732506300441, 0.09300152448486154, 0.08382941735228122, 0.10397368582426514, 0.08801366457727511]}, "mutation_prompt": null}
{"id": "c5c798cc-06cd-4f88-b681-5afb42573379", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.6, 1.5)  # Increased scaling to promote diversity\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.3 * (1 - diversity)  # Adjust CR to be more dynamic\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve convergence by increasing diversity through adaptive mutation and crossover adjustments.", "configspace": "", "generation": 78, "fitness": 0.3920509351435236, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9181641297532805, 0.9174174674062597, 0.9242326862143311, 0.9108285601655266, 0.9166630086113121, 0.9284637324975387, 0.9241633108223632, 0.9211828619055225, 0.9241860711738343, 0.7629631991498985, 0.7550561624358266, 0.7266052135906034, 0.7511376859346334, 0.7350945527945305, 0.7732045211112114, 0.7429345478038099, 0.7369785850398178, 0.7170879883095003, 0.18504114819746165, 0.13871658803473141, 0.13627016672564474, 0.12707263890028264, 0.14960339950314883, 0.13566650981342732, 0.13641020754401378, 0.18962199243956623, 0.16348773376491443, 0.12142675140892079, 0.12405613216402833, 0.11484049052885947, 0.13424631899577777, 0.11576421558493222, 0.1175336354286377, 0.11287357631165218, 0.1169770485411018, 0.13634552880372552, 0.9711466746414431, 0.962887771683445, 0.9708931157365237, 0.9699580080345431, 0.9861354569535266, 0.9624543724919512, 0.9691803922389152, 0.9855748908694268, 0.9622755092265025, 0.6744357114826757, 0.5920019473877449, 0.6802374592153926, 0.6976373551638846, 0.6661050003184383, 0.7016366406764181, 0.6785896241040505, 0.6253566027312867, 0.6733742706460257, 0.1409569894981494, 0.33231758887427454, 0.3906970075739653, 0.741867604341294, 0.2826244219784223, 0.9461456400277385, 0.23850829462413792, 0.2375828864268137, 0.9534823055435967, 0.40847875615616924, 0.4561483239682447, 0.13638031577299392, 0.5842079510137768, 0.47884814274355336, 0.3470965519436564, 0.561617227390081, 0.4417875017507644, 0.41468501825543824, 0.543419851332601, 0.44350229733685076, 0.4046869133963247, 0.5120125997384026, 0.40963376374675864, 0.571004357373331, 0.5325172724641118, 0.48525578148602666, 0.3948097118535828, 0.10124606946041037, 0.18578731284214567, 0.05254047422391739, 0.22254986788880282, 0.06404048349950375, 0.3948123529509354, 0.2888234047498156, 0.15073087945448804, 0.2942587064696732, 0.28578111754641, 0.1431325738914344, 0.23352705561228992, 0.42217313504970666, 0.275537554609946, 0.09793421975864836, 0.4894831685271188, 0.5293145503028599, 0.32965108710341673, 0.12646090753068817, 0.12938026446146866, 0.14201626833687409, 0.26199609339409635, 0.3410305267843762, 0.22334842508292796, 0.1288567528909833, 0.2138800515557221, 0.18275058640318043, 0.2900971114296773, 0.26918502810810674, 0.27287450655749024, 0.32361598705560823, 0.3395682785862164, 0.3411495480020248, 0.29310621877340537, 0.34392340546575983, 0.3281155375257384, 0.7274379026128888, 0.709007628305699, 0.7575906446012215, 0.731737624072939, 0.6915725790535956, 0.7234503280280988, 0.7131044038055632, 0.7241390784518649, 0.6824347188631869, 0.13516022661379268, 0.13712737219991245, 0.12268125367237448, 0.17748395233403402, 0.13478589694899323, 0.13589357111576517, 0.1601049836340913, 0.15486160546579053, 0.1784270418561006, 0.18942580656946262, 0.17884204802584247, 0.1432127283405079, 0.15855042853368628, 0.15152535431523806, 0.1783541542311865, 0.15860637592457605, 0.21239591322315443, 0.15871665853431038, 0.3620615589442965, 0.49458183666362376, 0.432422460753323, 0.5273837014026788, 0.4888722460816759, 0.4960046011560264, 0.5037886961014514, 0.516699814411928, 0.5087177134941291, 0.2481847196027972, 0.18933685135927325, 0.26543971087516327, 0.3460440041965981, 0.21598282665295643, 0.4208104501405058, 0.18638904156456804, 0.20406364407940747, 0.29318136284605056, 0.21766360201676438, 0.2210298690451833, 0.23055085937513564, 0.20346051941848298, 0.2394491733160089, 0.22945080452122113, 0.24363113718739904, 0.22261093569873736, 0.2186478250078242, 0.5430614766072697, 0.21896037109605848, 0.23113143325929064, 0.21486457644277268, 0.2407002596032044, 0.20629917802639353, 0.22601730480922577, 0.19435750420007636, 0.19562647710068226, 0.18735365376639934, 0.18621388400128214, 0.9361623715340328, 0.2000079482787469, 0.18694538032457175, 0.1467291459910568, 0.8637178789424093, 0.9044162287145459, 0.9307668083559235, 0.8167392525214947, 0.9007265828286944, 0.16889549262564074, 0.21355533435700613, 0.20976904575533895, 0.16858346346600062, 0.21075659159573845, 0.7395129131856618, 0.16925301837282403, 0.19146665004530206, 0.18843287516579132, 0.18059941672999869, 0.17975036929214783, 0.19523358240701305, 0.18613643578849393, 0.176152848282649, 0.19037164953226837, 0.20519511288760905, 0.08707866737899417, 0.09010786270908433, 0.08977536445103218, 0.08140936022464196, 0.09817809942382771, 0.09518264443099578, 0.12570407733106637, 0.09431894712442557, 0.08854044727658583]}, "mutation_prompt": null}
{"id": "e1a537ee-2ef8-41be-b7e6-b265cfdbff88", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance exploration by adjusting mutation strategies with dynamic scaling factor and adaptive crossover rate.", "configspace": "", "generation": 79, "fitness": 0.45924502936579653, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9269351805220212, 0.9228973734260824, 0.9293969182802839, 0.9248975561340582, 0.9344163788306996, 0.9326031205243148, 0.9328623558188918, 0.9284201600345972, 0.948894954846792, 0.80179840229158, 0.7636771397667138, 0.8003460505422093, 0.8087665692227741, 0.7764960752830198, 0.8002742269532381, 0.7642868567575126, 0.7590918840705936, 0.7898715823051761, 0.15244638018995593, 0.12357064154645125, 0.15233793682667307, 0.1392421677079394, 0.15927482220718125, 0.4809283479940504, 0.15019876124863762, 0.14313873481398953, 0.16540595754558785, 0.14895174915614717, 0.13187213654700658, 0.13212515018561843, 0.11541535715139073, 0.11607416057364461, 0.11290898053487963, 0.09563061498165859, 0.12403604636854904, 0.10715685640796979, 0.9559244203968447, 0.9625122569865813, 0.9769982607979554, 0.9500405889321645, 0.9565860353971944, 0.9729695763552338, 0.9628109475498007, 0.9680295343729446, 0.972533782156883, 0.7400447986731893, 0.7074340160965815, 0.7051009569097493, 0.742715716051662, 0.6948724994692959, 0.728962114152287, 0.7117507395918412, 0.7107712221426736, 0.6720373167769793, 0.22809080779633373, 0.3148922300888539, 0.23184014122507135, 0.3561154902666751, 0.933661077738466, 0.9088034306736139, 0.9367315956254898, 0.1820722359158402, 0.37047536489918453, 0.6276363598314753, 0.5403237008280697, 0.45230965121378364, 0.13562474496409793, 0.5274523206232133, 0.4912814802720834, 0.5816412008821614, 0.7010356691439985, 0.6059105312034997, 0.508037738566574, 0.5897968222891166, 0.599178931467414, 0.5510942109098146, 0.6870059457775994, 0.5394585511776, 0.6367925684240299, 0.6792648745170389, 0.6378101122660689, 0.08630808274801183, 0.4013923779875108, 0.39277299034654356, 0.6487965157035143, 0.6573642681153853, 0.39796472033603236, 0.45517708285700387, 0.6182493041955452, 0.6141881062940342, 0.2577853643028378, 0.6031089669904434, 0.5123656309976796, 0.5519106336435696, 0.09624000478737216, 0.28995974429644644, 0.6719237154314055, 0.6586222705225095, 0.3638614201301962, 0.3976314658446035, 0.15316267647328552, 0.34750875645754864, 0.5727755354081567, 0.33157071310608754, 0.4256724653584274, 0.4048770489477176, 0.24326082961472495, 0.37059925361150414, 0.516076174590552, 0.45610649486273847, 0.49538845890596916, 0.5460366374856552, 0.5253567278258997, 0.39154137288932467, 0.5183067360178394, 0.42155942534022683, 0.4326348374267066, 0.8163189855784587, 0.8244214792592389, 0.8791794338013932, 0.8474772626765912, 0.8185802564208524, 0.7467746733378677, 0.8405026018497473, 0.8219819363948013, 0.8335866960100928, 0.1143077186805409, 0.14819807973710863, 0.17373972734344478, 0.10648777806706655, 0.13219088981670646, 0.14294074520552003, 0.1351529093456848, 0.14024225973445392, 0.4003153748931618, 0.18480833589212697, 0.34169466374553303, 0.17253321686428047, 0.1840936021283116, 0.17726325680071187, 0.22344625386916472, 0.20476539572822616, 0.14996875939650867, 0.3632041277718264, 0.5422011802032716, 0.5215391178735187, 0.32981188903393155, 0.5257470108882677, 0.3899432037824454, 0.5325770944235039, 0.5396830781691764, 0.5618868390259032, 0.5497424561238378, 0.42352198239244887, 0.33343260931424246, 0.38538094081404317, 0.48454285685551124, 0.4332531554952501, 0.3979586111120743, 0.3645151859655079, 0.22855329192832674, 0.451608899378236, 0.22991067199045012, 0.2157020210047904, 0.2134857917462114, 0.23535881471305797, 0.23239118934768876, 0.218556982340804, 0.2384716339407229, 0.21819355515828043, 0.222851506770826, 0.8485110235891489, 0.2353149190165027, 0.7301604330396364, 0.20727669847251606, 0.24885730933633143, 0.2508472928302178, 0.21150839862615256, 0.24580588658439428, 0.2083001096446776, 0.18661180294794333, 0.9519743139880315, 0.1881525917917345, 0.20041917361249306, 0.8701765379571569, 0.14813144882528084, 0.9280034587359374, 0.7816569612774142, 0.9176217786059521, 0.9343376395772369, 0.770747795998347, 0.21158406024513132, 0.1671961720068592, 0.2096928291207676, 0.21018579682705818, 0.8070189664584362, 0.2099045286268585, 0.1689925138482753, 0.2055608514062217, 0.18759766070137962, 0.1915482216051031, 0.1972614042687748, 0.18773150603010347, 0.1698454820741685, 0.19442074407005416, 0.17959501160754332, 0.1839442694321256, 0.08079027330757393, 0.09516381380857852, 0.09266808061941123, 0.0958459066990417, 0.08887310989954256, 0.09347157944654849, 0.09811017585151782, 0.0962194794188519, 0.09315337218533137]}, "mutation_prompt": null}
{"id": "42176ebd-86f6-45bf-a132-bb1c50456bd8", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.5, 0.9)  # Adjusted F for enhanced adaptability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))\n            self.CR = 0.5 + 0.4 * (1 - diversity)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve exploration by adjusting F to a wider stochastic range for better adaptability.", "configspace": "", "generation": 80, "fitness": 0.44701341337004297, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.941514608709834, 0.9332906025133695, 0.9315382057695527, 0.9353415327463037, 0.9246932121852011, 0.9431276794025544, 0.9293076124594667, 0.9343637245570571, 0.9460022900206769, 0.805236018369514, 0.7934970026885911, 0.8084988657436372, 0.8095108271294341, 0.7735275679535532, 0.7879043647966275, 0.8254057641889012, 0.8035863560070003, 0.810277246933414, 0.14859138329651345, 0.14294975345387917, 0.14073344339590854, 0.1641684678205575, 0.12289300521231761, 0.15271478972756536, 0.13189928581038113, 0.12339712549669546, 0.15251904619554646, 0.11659528935558827, 0.15332748288194675, 0.1234562787853436, 0.15170251791102696, 0.1350769047498539, 0.11288216177977539, 0.1315487228483585, 0.13302370420334975, 0.11961418709468741, 0.9574269447746484, 0.9570215554221739, 0.9851797788518734, 0.951655141173393, 0.9715389533056448, 0.9487298446612649, 0.9512031681754268, 0.9779054315286784, 0.9792024700967197, 0.7475709163100982, 0.7141453156184431, 0.7334013177857762, 0.7284129243833062, 0.7068083283723814, 0.7200462980577533, 0.7389451076561084, 0.7379213150469497, 0.7279393246640616, 0.18632687676148119, 0.22816534722766868, 0.348737912420251, 0.3909783603876972, 0.9553714748101909, 0.9537971176617581, 0.39632975216230293, 0.246118950940041, 0.8113818578102562, 0.5819036896241825, 0.38320067509225486, 0.6382002197621771, 0.5822046648770012, 0.7262667240090558, 0.13704130264947156, 0.5558958221686323, 0.8222757548612151, 0.13720158869453392, 0.6830206188995981, 0.45777234829528146, 0.6489072460071603, 0.6729997959085976, 0.5438860379604912, 0.5164036695907106, 0.5585425440277914, 0.6021238909202102, 0.41877705550033506, 0.5001271908709755, 0.17983172894788513, 0.18554653102511043, 0.32666648944630294, 0.07909770358951373, 0.4605968338526505, 0.6630015522311921, 0.5330764350009165, 0.35800466673056686, 0.16263554521156964, 0.6928410460859702, 0.4648384855797383, 0.2734934519366842, 0.6194418623519038, 0.24926148412222926, 0.6974679409515714, 0.7306151388301517, 0.41386886793171496, 0.13606724113233049, 0.359737718082381, 0.22264422428905806, 0.4095611874065149, 0.3314506754041239, 0.4136262328002477, 0.3075440717983904, 0.35569275997562555, 0.22393643979517464, 0.5377906287405105, 0.5516766452457742, 0.44503839969444603, 0.571016368456628, 0.4962450234333984, 0.47340709563168804, 0.28659265479901197, 0.43970437351128944, 0.45837583271864646, 0.843919082289472, 0.8695370004645542, 0.8139468007200923, 0.8471823945382696, 0.6720386523132531, 0.7467270934817372, 0.8236950136248681, 0.7585543218825548, 0.7523555874032243, 0.13785579931235825, 0.12037812756474064, 0.13427961304808633, 0.15440741226739851, 0.14769647531125552, 0.13293920876911292, 0.148416152581196, 0.24578046952869803, 0.11855198712772852, 0.21173802165307087, 0.1615577063997029, 0.21154351279665307, 0.1626273085191582, 0.15022814750895463, 0.15832486384307154, 0.1649415841860804, 0.17472490054032042, 0.19825906691992157, 0.3417145494777344, 0.5482461528184637, 0.5705197863645921, 0.5802337523759136, 0.5790772731641669, 0.5595504663829862, 0.564276713792269, 0.5222423400695553, 0.605078369599227, 0.4937343532267594, 0.2771723861246592, 0.3673563103001154, 0.25766732186490704, 0.41696415299309364, 0.47750967305975756, 0.3331862668928657, 0.31161413394883397, 0.37159353193692457, 0.21413010760704632, 0.2555932469264811, 0.21724145929100935, 0.23289926372653447, 0.20896348218136584, 0.244641918772601, 0.20378639345245309, 0.20861492749469812, 0.2044054777444697, 0.5746847226813296, 0.22180471065330154, 0.6837850572072657, 0.43877730871894416, 0.21028868632544495, 0.20721391744886464, 0.2501822126029628, 0.2190644385890781, 0.21247245996457198, 0.1862481124531018, 0.9149485245161597, 0.18823260603051806, 0.14831880031842648, 0.9292553484649198, 0.38023097879240764, 0.8826408665568197, 0.9080958620825201, 0.16995382913876533, 0.7830267718444561, 0.6602853871421714, 0.5845669842504766, 0.2081229192980807, 0.16818338513546804, 0.21202407103319765, 0.8670458574586206, 0.21293545155076243, 0.16895467646968387, 0.2222214279532041, 0.1861887028419421, 0.1662782894619893, 0.19205704255873024, 0.20170200644147174, 0.18901192781213827, 0.19477098714750474, 0.17958523834493767, 0.20826429464767848, 0.09247198783755906, 0.10264424064054367, 0.0918741322440545, 0.08947078586581869, 0.09297466786120145, 0.09417258390128336, 0.11698844107715345, 0.09778527456078823, 0.09174819909701959]}, "mutation_prompt": null}
{"id": "a0730769-f7b5-4167-8057-50eab707ad21", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + self.F * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve convergence by adjusting elite influence in the mutation strategy.", "configspace": "", "generation": 81, "fitness": 0.41484668967018584, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.8965348940799641, 0.9155749827207467, 0.8979135106681055, 0.912894814645103, 0.88742672631787, 0.8955046391053583, 0.8976051939421437, 0.8959866547312357, 0.9142804922484123, 0.6010679035284312, 0.6043829527290769, 0.6521253229089206, 0.5915641726303678, 0.6320359269062921, 0.6264901801913665, 0.5956233706323725, 0.5963794804218425, 0.6056101709515254, 0.13654111940964153, 0.16654762208020224, 0.228156677598518, 0.1510096747417896, 0.1371156973470945, 0.13394563687067418, 0.131211879980067, 0.1446522336937902, 0.17415039243668073, 0.13956261807817993, 0.13758212558328797, 0.1072473110577401, 0.1406881152992473, 0.15452727829684332, 0.13169266731868223, 0.08904683045073547, 0.12365701348511282, 0.11428206746290726, 0.9708683698176238, 0.9728019408172881, 0.9687003620410745, 0.9724407971748711, 0.9738662701440977, 0.9772002081525594, 0.9491516922115266, 0.979496876922002, 0.9868578682305711, 0.5947644763706921, 0.6107325503899523, 0.629227779301871, 0.6438004230061183, 0.5893051694102565, 0.5807225211324929, 0.6221527336604475, 0.5777408622590303, 0.6285452809321801, 0.14077404412359318, 0.40157488131629304, 0.9520524418459426, 0.9572648829353054, 0.281970532844687, 0.9335706797359795, 0.4062487738823295, 0.9520457381499519, 0.2374717425170122, 0.4751748109226148, 0.6089694313588487, 0.5293343307190886, 0.535222772657638, 0.48338464274584325, 0.5697681311311965, 0.5161530859438592, 0.5540634366029171, 0.5164699222695901, 0.5729286234900639, 0.6200670166141682, 0.5462273471923063, 0.5381175520887072, 0.5155762772399087, 0.4853640672402133, 0.5425849038847109, 0.5386192063737771, 0.1370110081292365, 0.2987617607257471, 0.39361492915452667, 0.25145588072914893, 0.4231548079090598, 0.32690988588981085, 0.4028044372075632, 0.3870158573380226, 0.44245755818151133, 0.30446367145081676, 0.4172883936985987, 0.49937964893847775, 0.43795800773880245, 0.40343453272521734, 0.5402611026818629, 0.17674278926429055, 0.485752301691445, 0.439662931139955, 0.47239216468150347, 0.31151590627226666, 0.25643603330297415, 0.22646440686005642, 0.21083394854236326, 0.2790581978078711, 0.2496284554107, 0.23961593242405577, 0.20485561244304906, 0.1118333427915228, 0.3049263222195736, 0.32030532462848327, 0.3591225118141934, 0.3384685539921617, 0.33444548263955354, 0.3412550902512861, 0.3352128489607499, 0.3336715482146363, 0.31899123850951727, 0.7012484417321265, 0.7346556844262376, 0.7138128417269489, 0.7117063450574095, 0.7379187977283277, 0.6988425927434863, 0.7578514445764284, 0.7113909542367551, 0.7166650458941, 0.15089603264568197, 0.1068370800002012, 0.1327615551716229, 0.15293833946755042, 0.17900369706835484, 0.17893754535992323, 0.17804328638220301, 0.16161081459948434, 0.12755797515941636, 0.14765955549596166, 0.20084700785142695, 0.16974288202185184, 0.1461591553204762, 0.16317541061716312, 0.14376514424716424, 0.1346461262253652, 0.17367433379355812, 0.16930201396536793, 0.44734755324460107, 0.33907305419445377, 0.47115230553296994, 0.4524477049403861, 0.4540492538620944, 0.4717862983174982, 0.45114014737780783, 0.47901423363866946, 0.4866395283792184, 0.3277213144979556, 0.29261426774154475, 0.4158702997705769, 0.25531334992290344, 0.2650889077316032, 0.39991152538856056, 0.3983614310161687, 0.3641328251106636, 0.3395305011383918, 0.216777968252851, 0.2175927329924765, 0.21594964074846945, 0.21643169988595878, 0.2417314346386502, 0.20285661442771363, 0.21126983467918603, 0.2038987354448062, 0.19708690378740423, 0.6305884240283122, 0.1955561784960339, 0.24826810073568883, 0.20952003055000246, 0.2030508050449331, 0.20824043667027925, 0.20210428003946657, 0.2393919044134737, 0.7253699873495302, 0.9029366312764164, 0.18650014468074116, 0.18878895882767632, 0.907954788697065, 0.9021153172085479, 0.14504721732201464, 0.8712440631935792, 0.9152997928557629, 0.16942631976022837, 0.7529242516929482, 0.924015446938451, 0.16562263862125892, 0.4900773941770703, 0.5414283362076939, 0.21222950901452464, 0.21142945402203206, 0.10472018243895742, 0.16759824230976827, 0.1948629433187653, 0.19062032855770394, 0.18135515786774836, 0.1868115193097909, 0.18519947345388488, 0.18882403464311093, 0.19191800247628166, 0.192329670076278, 0.18261747510445758, 0.09362327130346715, 0.09693384462637245, 0.09130988991053635, 0.09839072954636685, 0.09259843890900687, 0.08597577162438064, 0.09748674360079257, 0.09964322508484691, 0.08133920788357096]}, "mutation_prompt": null}
{"id": "c6ba6ac9-1499-4834-a31e-4f244cb2b0f2", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n\n        while self.evals < self.budget:\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            f_scale = np.random.uniform(0.5, 1.2 - diversity * 0.5)  # Adaptive f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce adaptive scaling for exploration by updating the mutation factor range in response to diversity.", "configspace": "", "generation": 82, "fitness": 0.4340542429390294, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9364601783396675, 0.9194447070195627, 0.9398523984518438, 0.9295707285774758, 0.9288421672748841, 0.9370304642764854, 0.9282521280948828, 0.9271277755754141, 0.9336359796593692, 0.7942195649141724, 0.8158501824609705, 0.7785339785002492, 0.8112721487856422, 0.7943879370808018, 0.7810785254601607, 0.7922047385783708, 0.7932716241119745, 0.7395951343443015, 0.16945606070770536, 0.18002047541696897, 0.15421039973297412, 0.11833985539973912, 0.13505780761044606, 0.14354765680882375, 0.38510590083953944, 0.14127085781905768, 0.15959954690761202, 0.13226459086538978, 0.13452056640658372, 0.13208438114634136, 0.11871263066062276, 0.1432421955076565, 0.14651936694164303, 0.1494806656211335, 0.12633446128204595, 0.11512294914571264, 0.9575265656260044, 0.9665308559529544, 0.9667652464235913, 0.9580882100906856, 0.9759059944568279, 0.9828021958881055, 0.9623111025712813, 0.9504220841775185, 0.9720647579755081, 0.7146046800598208, 0.6729164651727256, 0.6808351129787582, 0.7488429174695547, 0.7345293148278063, 0.7405572132583443, 0.7227981623529265, 0.716817374334263, 0.715888895290721, 0.21638228650259184, 0.16103318300580682, 0.23162947073203977, 0.22246353620346326, 0.28269043036116304, 0.21552827925818585, 0.412697115579598, 0.33891205091409815, 0.23882697553116683, 0.4666101982857431, 0.612144039491939, 0.6266554111960354, 0.6395755931312659, 0.5311925960242966, 0.5526846758065977, 0.6192623473115757, 0.6682598589352013, 0.1382877113744373, 0.5807402021945127, 0.5003905245870247, 0.4812133999653183, 0.639202173998038, 0.31265338399423803, 0.7219405480438854, 0.1364937482697458, 0.1348593906139267, 0.5788306384853542, 0.18994412679467298, 0.6226473689954541, 0.4209441372661812, 0.6383084514536298, 0.3571723319188477, 0.5884384396521006, 0.40285865821285993, 0.5733237459901777, 0.4553119077100778, 0.4877499811328897, 0.35493926233766837, 0.2974761561874113, 0.5786827274814714, 0.2838253963667423, 0.3100982347157637, 0.7296349058622938, 0.40221222665534595, 0.523138943050059, 0.19861350766569408, 0.27045577293538503, 0.3405324255425307, 0.5154327018983246, 0.4708947292149286, 0.11348400017345106, 0.32357843598621805, 0.279796298196874, 0.12522690647265844, 0.5038121046872786, 0.44690359139100677, 0.4591176174127706, 0.39203210871069216, 0.47217985078537106, 0.4848925272210367, 0.42388319086527915, 0.4731826246160654, 0.4631130404584003, 0.8737797518215744, 0.8585408246625643, 0.8358700080090059, 0.8442210505390206, 0.8544562944987389, 0.8284663148120183, 0.8009147698284642, 0.8302386187959828, 0.8059651889027721, 0.11800496374023894, 0.14535928229603923, 0.13358912096809672, 0.12852006387906534, 0.3350456160893147, 0.14827048383513608, 0.114562240929735, 0.18913005495034618, 0.15430943366418903, 0.31406042107231913, 0.1628115621707058, 0.138101181929702, 0.1676602059018234, 0.14356035283975654, 0.17536918267814416, 0.14866901962141077, 0.1378544731925555, 0.14829685952360028, 0.3767056328269831, 0.42113290295959116, 0.5162345593221236, 0.6082070486438145, 0.5437219452327102, 0.5174433577825113, 0.5888687502863799, 0.26923544058759696, 0.5711540968376219, 0.2951488975194948, 0.43136063143312586, 0.3210867096418395, 0.4683173647166412, 0.4730519594137661, 0.4554386933031861, 0.2908918337669908, 0.2851093266707979, 0.2543221321006879, 0.2346164391433362, 0.23270543891365592, 0.21754949726568507, 0.2135603707413405, 0.2521556778581414, 0.22606885366614682, 0.21565220267344754, 0.20337134809509472, 0.2529596327382103, 0.19946655426595938, 0.27279345895788765, 0.6550164634530745, 0.23083606336346618, 0.2225265480994344, 0.24580844019702908, 0.45605626476888106, 0.21692903645702843, 0.21252074306692526, 0.16745792182028907, 0.9461580872358736, 0.9488451568732748, 0.20028712122462444, 0.9440151459097491, 0.1590810103668413, 0.20493853071488344, 0.8789188132950064, 0.1662674976469518, 0.8333655646830487, 0.9354628666206831, 0.16811424116310913, 0.21301065970309652, 0.20364432951766398, 0.2099321261321847, 0.7749937432794418, 0.3836293167981871, 0.1684220425912778, 0.1901412990708813, 0.2040609162154664, 0.19573718844121202, 0.18883854298719804, 0.21552820134392037, 0.18858263426178679, 0.178801081937082, 0.18164407325169063, 0.19609312420522595, 0.09049330552235679, 0.09403428468862818, 0.09944113530972098, 0.0939951927221726, 0.11881645136124097, 0.08723561912652, 0.11896350956127155, 0.095140827308422, 0.08724716896795304]}, "mutation_prompt": null}
{"id": "29ea374a-3598-4914-b6e4-5d4e259a768f", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.75, 0.9)  # Slightly lower initial F for enhanced exploration-exploitation balance\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Refine exploration by slightly lowering the initial F scale to better balance exploration and exploitation.", "configspace": "", "generation": 83, "fitness": 0.43054956687171925, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9324552050051278, 0.9265455601380838, 0.9332761625289854, 0.9297485530347874, 0.9298036855679934, 0.911458484712492, 0.9303962006204259, 0.9241736211940953, 0.9427171233048874, 0.7995598552797918, 0.775660821023016, 0.7825129949383391, 0.7988581420965224, 0.783341222677735, 0.7910940981866148, 0.8093391755830102, 0.7667391402743151, 0.7916301040738438, 0.13176227977127508, 0.1441497700589054, 0.15755518679132186, 0.1456088021943559, 0.15160989551470216, 0.1414232609234467, 0.1462171604823821, 0.1441141761701974, 0.1522566224928229, 0.11834934368617156, 0.12106206747142134, 0.12660456015981814, 0.14558471944813878, 0.12591913729431103, 0.0867785969311744, 0.13027912124821706, 0.1286582164559137, 0.12301863315668815, 0.9775489523481743, 0.9806157323176722, 0.9782692327926643, 0.9582071038504135, 0.9883506463332415, 0.9676269107840662, 0.9570942917057532, 0.9672231500304066, 0.9497457811711759, 0.6929375204715345, 0.7094967413673794, 0.7227241971953984, 0.732166864541669, 0.7867601208614363, 0.7302849856312957, 0.6473915808886005, 0.7521912341797846, 0.7508850532345566, 0.17116531496320275, 0.2285194317033613, 0.21772296033901062, 0.3494563856827304, 0.901400886686123, 0.8934645567930821, 0.36421521187729033, 0.22462945493974573, 0.9392856901127562, 0.5187988425549688, 0.5518769364583582, 0.6897409611753691, 0.5575670988210714, 0.7561460428835988, 0.6235909718620829, 0.5647151286608207, 0.633873328871143, 0.7197173746422233, 0.5660479629021031, 0.37543616306361516, 0.13642565036889243, 0.5479310563520319, 0.6484918765036947, 0.4504384216327334, 0.6510557097234801, 0.49417025177668483, 0.4882708936021718, 0.06234560340721895, 0.25148047365673265, 0.10328168703253793, 0.5842525799678939, 0.5033983893400049, 0.43160784026850685, 0.45741626378782907, 0.41749363367307035, 0.38727502824901894, 0.1480936324912262, 0.7159701462492705, 0.18031964353590246, 0.2245565424339654, 0.1979726531367728, 0.3784489994787871, 0.5368039715526095, 0.5590369442737708, 0.6455033766754921, 0.3218413762424933, 0.2822632402932349, 0.3984676051475181, 0.44277177692979064, 0.38312053330540286, 0.3798328286334933, 0.25727995738140763, 0.21368287121338236, 0.2841218718655295, 0.40109559560563124, 0.3975562771219844, 0.5542996389570646, 0.4755136321695973, 0.5060052639494412, 0.4972845996272034, 0.4789006055396652, 0.4632511828463496, 0.3973312843981651, 0.8544406778507734, 0.8299522187467974, 0.8650444541048112, 0.8590080057604267, 0.8476149171562497, 0.8539810163561956, 0.8618460331141484, 0.821847864843847, 0.8375526639537889, 0.1301757890241645, 0.10663397530501095, 0.12391151033770298, 0.11927508734341463, 0.24572503366701315, 0.1070601083734839, 0.12826286136201348, 0.12580227461415439, 0.1689580607479636, 0.16898094994592117, 0.1598005138261922, 0.17416072639842262, 0.15782286979327875, 0.16042876668921835, 0.16968615601150738, 0.1745653277981868, 0.13689600672017155, 0.16404208543914356, 0.3176070609318917, 0.5490500199017785, 0.5243584350391837, 0.4747915897465891, 0.5540123602021034, 0.5304248030674368, 0.48633606286981024, 0.25164760182442447, 0.5581144155639655, 0.3074247631325877, 0.27870654689891006, 0.30721930867407676, 0.28524455294083884, 0.2492037314946438, 0.2778526148073911, 0.28169480108298384, 0.295074958244789, 0.4494208303325352, 0.20411760678951374, 0.23661289821419373, 0.23353738600849716, 0.199070054990082, 0.21678673618916788, 0.22291966452362655, 0.21862774228135873, 0.2108452557548458, 0.2066854006316371, 0.21805457029754738, 0.2455357488657668, 0.630319872755857, 0.2383975795550619, 0.20681460960614695, 0.2372420711882146, 0.21861260272550553, 0.20243818691122417, 0.21601317191780567, 0.1866992762186832, 0.18803907689570365, 0.18877556423365438, 0.14812133602334576, 0.9443098094745014, 0.1481276882728032, 0.16574015807567755, 0.1667787513079656, 0.9211561316928247, 0.9248506743365011, 0.8719818331778761, 0.2118247009709211, 0.20835448432970083, 0.7426276919652262, 0.12809488276989178, 0.21165069257178437, 0.9359834508345084, 0.16956905519278098, 0.18632932717805029, 0.17946080123906527, 0.18197294257605112, 0.17735464103358933, 0.19654473909620396, 0.19408034627204007, 0.2010045675598945, 0.1772581435926699, 0.20199588514828026, 0.09065089853836494, 0.09157020985605757, 0.09667034941643926, 0.08134358546117093, 0.08745391319617957, 0.09602213180976304, 0.10104200716419653, 0.09698490479669164, 0.09017630517945019]}, "mutation_prompt": null}
{"id": "3d2c5220-3f1d-4cd4-83bf-691c0efe8468", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (np.random.uniform(0.7, 0.9) / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)  # Updated F\n\n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Refine exploration by adding stochasticity to the mutation factor F for increased adaptability.", "configspace": "", "generation": 84, "fitness": 0.4443230680898975, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9364084347879856, 0.9379592069477766, 0.9430556321718649, 0.927177491239675, 0.9285695351860508, 0.9324903310543092, 0.9381393864462675, 0.9295566002542376, 0.9087404856520263, 0.7905851844041512, 0.7983894069312516, 0.7782592861374618, 0.7883851553974318, 0.7807446903001958, 0.7909199337569776, 0.8219441272394026, 0.7671008643913393, 0.7871395053126555, 0.14410049825088445, 0.12452303094254535, 0.16827598287974055, 0.15375275288752022, 0.13913241218861894, 0.14111784589544007, 0.14787274129522443, 0.14283426004644406, 0.12816039680119085, 0.12066325690775759, 0.1421051714672953, 0.11023755790541567, 0.1106683490849738, 0.12579450362708888, 0.1324546811175762, 0.09629780804823207, 0.11100613454795516, 0.11001610928681438, 0.9828761512960548, 0.954496093745772, 0.9801794563528707, 0.9671719803970479, 0.9776608888768596, 0.978735977774473, 0.9547014995454516, 0.9560653091135958, 0.972390575872504, 0.714434153353116, 0.7199489199402257, 0.7579365903011, 0.7269861044263284, 0.7539994886192962, 0.7024587626566408, 0.65484533508524, 0.6966233423182933, 0.7020354558641964, 0.22833931931772156, 0.959792645475304, 0.34183772030392434, 0.9618394049401817, 0.2825413915157271, 0.21111443252382955, 0.1815493668493635, 0.13857354388759757, 0.3227893031630821, 0.49490855136397827, 0.7430229019308465, 0.5939415287047294, 0.7779622941023319, 0.5492558745813412, 0.788822034601921, 0.6344052093584489, 0.6684332336488312, 0.6230619353015252, 0.7345845334675736, 0.5558558291095623, 0.5340272831134218, 0.8379130664441137, 0.6574711213972553, 0.7111519857587327, 0.4453858513269836, 0.6156434677504459, 0.6571710848199924, 0.18487504878243377, 0.17334227606222052, 0.3364561499450872, 0.5180971173549764, 0.5771554672133254, 0.4966348279700947, 0.4802329347548162, 0.6213693968650583, 0.1513185074971356, 0.5577466374253753, 0.792971084088207, 0.41195672381889004, 0.5172162519290757, 0.266759842727335, 0.1679596279680622, 0.4970075021896978, 0.49159717363680533, 0.5078379573605655, 0.1285142675600186, 0.41654546952161875, 0.15914460478772818, 0.3181723341536855, 0.40789663305336477, 0.30583576479402763, 0.42000621868712684, 0.25469006908817227, 0.17663978768690636, 0.39530200338515176, 0.3725264887270566, 0.44117846900194446, 0.4950586455775511, 0.523983017429424, 0.4457357070230954, 0.4375155804789923, 0.3917092334807354, 0.4397515675615469, 0.8445211252525301, 0.8696987726410159, 0.8228861499581938, 0.8620011178780325, 0.7691985786126015, 0.8699246195514153, 0.8793318792552065, 0.8385254518058955, 0.8839134844667158, 0.13605777147454223, 0.1423423630541727, 0.14796350383271017, 0.12956314223515797, 0.120051781286302, 0.1557846105846753, 0.11289639076288294, 0.1291961230335017, 0.14305521394024712, 0.20798748757600427, 0.14357572168803867, 0.21677359711172894, 0.18590211232954146, 0.16331604924677978, 0.158677622057543, 0.15615413838108905, 0.15321430050538343, 0.19188508292833617, 0.5202784617133717, 0.5791234061872252, 0.3429026115282767, 0.5389009725110737, 0.5762993962182307, 0.28454714635415534, 0.5241857217242832, 0.5512055039362196, 0.5347241943771057, 0.3454463056676679, 0.2922412195915901, 0.30930694330598285, 0.2972499313696392, 0.3790271243301243, 0.3214818603591141, 0.47404638672185617, 0.4417283466755946, 0.41488028925935583, 0.21049529839227565, 0.20153007646533805, 0.23629496705025277, 0.22385884575045445, 0.23040533774942773, 0.2454585274589398, 0.20989256959148495, 0.21212795581529142, 0.21471656926270255, 0.20591850046339955, 0.20884879499525777, 0.7032155321247253, 0.24011667783767543, 0.19846543688065044, 0.515782946179774, 0.18719159684982478, 0.21041091695923897, 0.21501973550888787, 0.8891499353238808, 0.8222460328439167, 0.18946587889490663, 0.8502752958975843, 0.8608348811832542, 0.15760975312393188, 0.16521652396200492, 0.9516574047275865, 0.9239055787507879, 0.9499273941849907, 0.1268230208321267, 0.16825923509117113, 0.20544005729949244, 0.1666337218589624, 0.1690360762773484, 0.15464699121707037, 0.15488477102970188, 0.16822944455211508, 0.18432327570810847, 0.17827911422939036, 0.18055848319513113, 0.19558254523054597, 0.1778335603910869, 0.1840674610865708, 0.18639371955233186, 0.17879507018002783, 0.22819238507390815, 0.10311509737886426, 0.09491126128218019, 0.09613958334890371, 0.08517734186719916, 0.08264800490197977, 0.10041064858274817, 0.11363219359315735, 0.0850045973635486, 0.0924919281077271]}, "mutation_prompt": null}
{"id": "4c1a095e-ec51-44be-ac3d-65b3bfb728e2", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                elite_scale = np.random.uniform(0.1, 0.3)  # New scaling factor\n                mutant = np.clip(a + f_scale * (b - c) + (elite_scale * self.F) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce elite-guided mutation scaling to further exploit promising regions.", "configspace": "", "generation": 85, "fitness": 0.38905354133833675, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9402262204754678, 0.9433837515102976, 0.9201088254412995, 0.9268490423434876, 0.9248366621494776, 0.9241590188484475, 0.9378200503384606, 0.931494392847581, 0.9441268725282812, 0.7994029935305383, 0.8181129874709551, 0.8336104138555087, 0.7785818256855128, 0.8212077575433512, 0.7746689234838622, 0.8432406137772599, 0.8318405706047081, 0.8170929578016278, 0.6081537202365978, 0.14146544747963596, 0.16595869788116346, 0.14780075341140486, 0.14580967209987916, 0.1465982314724843, 0.13505596980285262, 0.17579246006383542, 0.3094898247826935, 0.1211564426673385, 0.16162815621184823, 0.12192567235561369, 0.12065017581962079, 0.1687354609902021, 0.11223360535075166, 0.12517772536464655, 0.13782464263666483, 0.1228680624311339, 0.9388332113134072, 0.9406453254970182, 0.972022127647923, 0.9380643026964878, 0.9630407879773673, 0.9416486297247089, 0.9255667840236658, 0.9562671042686267, 0.9626120980010846, 0.7424011994799955, 0.611396949361541, 0.6566428452809971, 0.5902710431480798, 0.7618780600429899, 0.7379456061744285, 0.5205508261975682, 0.7766509859817652, 0.6854633614502806, 0.17214978152378735, 0.37734194579875524, 0.17254945653482645, 0.2841991703921918, 0.2823160200249216, 0.21472122108291836, 0.18176673507366403, 0.950115046946521, 0.17937623303019423, 0.29945190777962605, 0.137512219176249, 0.5188985484695321, 0.40715347722128226, 0.8441447065157324, 0.2701206751399319, 0.5609748599731419, 0.38451841489016414, 0.28860720098137393, 0.39600423623441205, 0.13590250022982886, 0.3479678107781473, 0.6275960537565285, 0.5538458887288439, 0.4368804910235935, 0.40721775794558235, 0.44800057722871667, 0.7122528359069935, 0.2007068606699305, 0.17093437950505708, 0.13716847145013178, 0.295898099138895, 0.006295240555045489, 0.2267526186026968, 0.12737292204247974, 0.18248517314644053, 0.2813623355755931, 0.29115910353112817, 0.3046620210883316, 0.2510976975913598, 0.32772798095820677, 0.0660790539385514, 0.16922943362684506, 0.2996815960047431, 0.3102121456743593, 0.6427410247835359, 0.12427623132668741, 0.06750015445422253, 0.2656497872156002, 0.22773503605381806, 0.17452288134268223, 0.22050064670321767, 0.35255022370916367, 0.2655969616577789, 0.1687189709216389, 0.31207439640221724, 0.39623278258932904, 0.3891861160061617, 0.4700846446100937, 0.5173854626067098, 0.5332630631777148, 0.3965463987353244, 0.3808978404821012, 0.35010410597515584, 0.8464338535581332, 0.7077328803863809, 0.8429103839855833, 0.6596066489563356, 0.6785270442925311, 0.8617884923033461, 0.7868154224453153, 0.7324643772099817, 0.6508941056125626, 0.12980873838299556, 0.1094962949982703, 0.13564821948380412, 0.11395977151785752, 0.17092672174335133, 0.15807109843732892, 0.11877146774171798, 0.13409101622911224, 0.4084700192101425, 0.1687323166113074, 0.2628101827686169, 0.18470646809417224, 0.3649834968185661, 0.1891955043115814, 0.15001798484037177, 0.19167749921622257, 0.13929042952536363, 0.19575016529029188, 0.5465060509679953, 0.605303481678259, 0.6010582651584245, 0.26644330871234034, 0.5961199562725021, 0.3110508331107126, 0.34786829001798036, 0.610816792051847, 0.5659832450117114, 0.2720615037024233, 0.26112735883257154, 0.2225148463808725, 0.45730512563938, 0.2350467319591354, 0.29474586472508524, 0.25421497950932226, 0.48852251136021263, 0.22678937636387664, 0.24335395557276274, 0.20927596085349198, 0.23446189564329445, 0.20261056224736562, 0.2290515889623299, 0.22909824844665816, 0.22885011729779503, 0.21618949148415667, 0.21957726260206978, 0.24726862731902355, 0.20982929424880237, 0.21338011972479787, 0.2387115465035725, 0.671486968419358, 0.20912448183275867, 0.20400656298467268, 0.19369562410960584, 0.21044108611057744, 0.1890446265357597, 0.18704034320270158, 0.18933219892291064, 0.16441966312750644, 0.1895366492017111, 0.16610179759016808, 0.16646776362033888, 0.925666674960725, 0.9439866614331637, 0.7282178343480756, 0.591729250666556, 0.1536743191318235, 0.21054640930905066, 0.21248022239357545, 0.21278608597471305, 0.1564994982778407, 0.16605833210560828, 0.16740145660149774, 0.2048394816061917, 0.1825268444571656, 0.1951272324976142, 0.18332145188669646, 0.18694508930432863, 0.19109039940400374, 0.1941448156030935, 0.20465657694807704, 0.1964162566284232, 0.11092179206298203, 0.1194787088238991, 0.09498182223760598, 0.09042100593742575, 0.09700406900930925, 0.09348452109041461, 0.10727025233438581, 0.09826326810607733, 0.09924155014748925]}, "mutation_prompt": null}
{"id": "ec5287b8-2ff2-4206-8a68-5633e9baf102", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            convergence = np.abs(np.std(self.fitness) / np.mean(self.fitness))  # Convergence rate\n            self.population_size = max(4, int(self.population_size * (1 + 0.5 * (1 - convergence))))\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce dynamic population size adjustment based on convergence rate to balance exploration and exploitation.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 12 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 12 is out of bounds for axis 0 with size 12')", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {}, "mutation_prompt": null}
{"id": "8c55f56b-fab6-4261-8538-8cf6a19969d2", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n            self.F = 0.8 + 0.2 * (best_fitness / np.min(self.fitness))  # Dynamic F adjustment\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce a dynamic scaling factor adjustment influenced by best fitness improvement rate.", "configspace": "", "generation": 87, "fitness": 0.45703893317361705, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9222917553173033, 0.9273713819285805, 0.930813120689065, 0.9263529734663327, 0.9238780243006446, 0.9295570273239453, 0.9210926900323002, 0.9302800792752189, 0.9305324104261825, 0.7833093842944316, 0.7592883109806772, 0.7921565313894335, 0.7803625782930727, 0.7470373933177578, 0.7875821104636355, 0.7496425578720849, 0.7553510047728939, 0.7317133944147068, 0.1310768829356277, 0.1545051644812656, 0.13280684738317305, 0.1376915738846588, 0.14604827838883216, 0.15255546573331247, 0.15773757975279223, 0.14733865769533228, 0.14291106128713216, 0.11018898053069193, 0.12800371050254467, 0.11351301162511429, 0.11052175425339061, 0.15335616322069434, 0.11398857382810224, 0.14159144234424825, 0.11466690133752422, 0.12128242494878427, 0.9591036490791759, 0.9750522533510915, 0.9834180597350922, 0.9603618131798431, 0.9882143557264055, 0.9667919782729889, 0.951370273564952, 0.9784486627297337, 0.9795387570274443, 0.7185257396767569, 0.7366231119069895, 0.7041567208739545, 0.6898945834275971, 0.7296044173858902, 0.7180784609340274, 0.6751994477750151, 0.6683226072790516, 0.7132855501197879, 0.17214747253024287, 0.9478630592198252, 0.351623935581424, 0.9604479424374068, 0.20838913076731758, 0.21465462127492807, 0.17930976656039477, 0.23806205195333863, 0.8868515614131963, 0.5989475608323216, 0.635748540783214, 0.5505572972748803, 0.6899668129236793, 0.7820747949125137, 0.6324632382389301, 0.5861911868426664, 0.6794086600120328, 0.6491494088597535, 0.6360449650480138, 0.5906132817210337, 0.13489920263056487, 0.6187350163312286, 0.6914598486409003, 0.7977158308479193, 0.1364540111428001, 0.5356474967231108, 0.6843850551305504, 0.37690771787038235, 0.5247293635055265, 0.24710875946222766, 0.29176842962106453, 0.47511480864210753, 0.4642684983154487, 0.5671654428090908, 0.537697285889923, 0.2599679021152984, 0.4655239926521002, 0.2917778653967802, 0.2156970313896952, 0.4795760303225852, 0.40241989440884207, 0.34715214881802137, 0.4864798763339392, 0.7494803951065518, 0.5420435665008437, 0.14549022622872143, 0.19102708360131426, 0.3923396914786823, 0.3826435870954754, 0.5269695074932079, 0.29519531411233624, 0.29056414132785846, 0.22822148989422708, 0.26232725913621957, 0.466470423164005, 0.3941184348034722, 0.4534178441604808, 0.5391666152758525, 0.4462882203407841, 0.43617583213939537, 0.4869838408036483, 0.47902367369289534, 0.388605695511982, 0.8688903756891866, 0.847016331464631, 0.8567591254993665, 0.8423865973681891, 0.8431107965399948, 0.8489399863522199, 0.8492020606226998, 0.8486262930679696, 0.8348854707301802, 0.1362966743068993, 0.136511677840765, 0.11636741572027609, 0.1020123222410273, 0.13895755141160804, 0.1291786927223617, 0.09910294146455412, 0.11675068524589693, 0.47848850939345944, 0.18884089390632786, 0.16502018016948894, 0.15308085549777584, 0.21103531815072052, 0.1898566035118341, 0.166997208718629, 0.1880296603654309, 0.15603746036257182, 0.1478254514448032, 0.5430341968118368, 0.47073504791569787, 0.5019427252158446, 0.5509984922377751, 0.5454377644348503, 0.5226601346469105, 0.5280957991735564, 0.5285721894821431, 0.5337931577484283, 0.3131458252018773, 0.4600461834475341, 0.4616460951189201, 0.4783051777408608, 0.3850053453831248, 0.24548474937926712, 0.4258714607631966, 0.4323901725062447, 0.24800380954725054, 0.2120230130886297, 0.2532747762152445, 0.20353799592174604, 0.20398990181315968, 0.22718404151465998, 0.21690386516218085, 0.2237425777695381, 0.2362309503603236, 0.2208737151391137, 0.20817983812740037, 0.22514421725855627, 0.20029881386730963, 0.2204565857184999, 0.7097910791235216, 0.6817863633664198, 0.21224440222217134, 0.2225756674667858, 0.46819680024663, 0.18646353677214011, 0.9055216957720327, 0.18796274378953826, 0.8334591633686129, 0.9218758103011315, 0.19878035698758445, 0.916292511273261, 0.7905991207086254, 0.9206301262429569, 0.9110579878037233, 0.9112115894062217, 0.21222570168591992, 0.20641048041828092, 0.7656518934884224, 0.7958553810257105, 0.21131474265384842, 0.09440602679514265, 0.16904662446784247, 0.1985287232767493, 0.18561727737713285, 0.18609182087429788, 0.18952541513026366, 0.1812100881035844, 0.18821281576273619, 0.19478496221477148, 0.19348734378893118, 0.18096450485923565, 0.08449144821046428, 0.08279791342818121, 0.09470525834235577, 0.08827114170859118, 0.10658434783157444, 0.09818952068805087, 0.11662023249475573, 0.09005779598692354, 0.08558610672315103]}, "mutation_prompt": null}
{"id": "90168423-4fe6-4b6d-8b58-3edd6ba04e6d", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                improvement_factor = (self.fitness[i] - best_fitness) / abs(self.fitness[i] - best_fitness) if self.fitness[i] != best_fitness else 0\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * improvement_factor * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Refine mutation strategy by introducing elite influence based on fitness improvement.", "configspace": "", "generation": 88, "fitness": 0.45170749462559323, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9372981864344215, 0.9186872146344127, 0.9289078349039269, 0.9255431644972127, 0.9292960774989553, 0.9289447024415118, 0.9319119331275335, 0.9126052156293729, 0.918922353894986, 0.7983029486163203, 0.7813035134547686, 0.8028016269488665, 0.7896075065031705, 0.7620502508227314, 0.7627693408036114, 0.7589925269484904, 0.7708592678383797, 0.8031873329029364, 0.13275437520387423, 0.1721453708870586, 0.14209046272676096, 0.13817940530866202, 0.15004576218930288, 0.14151856366464455, 0.1312778331102159, 0.15637575016829763, 0.16782580971928307, 0.12487603050186502, 0.11357868890096923, 0.12961677411583372, 0.11375523738134785, 0.11759524917721609, 0.12871428594099543, 0.07130264577336909, 0.12005230237352738, 0.10572898580543011, 0.9753942193798438, 0.961584152117967, 0.9628704863689708, 0.9713640660763185, 0.9624883509267251, 0.9690560288741349, 0.9799099528433521, 0.9733483824124668, 0.9806591203997732, 0.7704000517511578, 0.6903845606259614, 0.6096331984779793, 0.7541487024470759, 0.743120732026308, 0.723400680066348, 0.5807693035894783, 0.6916868289879192, 0.7672090716568483, 0.772131751784471, 0.14353440890632863, 0.23049206342145012, 0.28236195436969835, 0.28351399504061314, 0.28355103994554565, 0.32106399722541334, 0.9428885011989108, 0.9455636264918909, 0.5231007482757764, 0.7025863209761927, 0.4281390003972152, 0.7169137468330431, 0.6695936218892086, 0.5654587471431296, 0.6699238439186836, 0.651375013079075, 0.5073849161183621, 0.5898341164207563, 0.43543643852787395, 0.5157294886407947, 0.6208869057202905, 0.7898175135354911, 0.6886158749093261, 0.7222983801503269, 0.7857362315778988, 0.6059573117275342, 0.4376444733628727, 0.31524379146074755, 0.509165396986954, 0.5624713555951069, 0.4244348471464847, 0.5380945962112924, 0.32148278048048384, 0.6387423079147261, 0.30452180880214696, 0.13371026531835828, 0.6539995713943383, 0.24375890544107015, 0.1704437702305972, 0.6480297907765455, 0.24292329195359386, 0.6927287866773579, 0.755538571716245, 0.5359839468779481, 0.10448618911547569, 0.28001731308835953, 0.1173070999612097, 0.3261462624487188, 0.4234314177314137, 0.5041537222000574, 0.14385452268118437, 0.37154884866397064, 0.341271802313281, 0.4044842467474561, 0.42310730350680625, 0.3482664019178312, 0.5201880043341206, 0.48119222941887674, 0.4536696123388043, 0.4835358252390267, 0.41115072455276147, 0.44739641075633096, 0.8714914045769043, 0.8629811527862381, 0.8416772344646528, 0.8743904998920801, 0.8246833923981991, 0.8395980650598978, 0.8598445600309343, 0.8075318501220118, 0.8670332224955473, 0.13545726877172093, 0.10597528024035308, 0.1053082588743135, 0.13113325689484334, 0.1300710159717815, 0.14768163275038404, 0.11377023113736817, 0.150309539957302, 0.13034299427868423, 0.16609016006468136, 0.1920303357680052, 0.17977164794022338, 0.1420141191855644, 0.17465872618182965, 0.24808887752358444, 0.21179017959198332, 0.14373229585448355, 0.18609964668322998, 0.534456733205874, 0.5439075027833105, 0.5230419005687066, 0.41547484344531826, 0.5336235985051818, 0.3101896271951923, 0.5230122227041667, 0.572517276371759, 0.49936278719373073, 0.4368783959171174, 0.31719067787115296, 0.42454771847392114, 0.4600440259493166, 0.4866318598343786, 0.4541734478760344, 0.4905881585625679, 0.4266520916169616, 0.4598929440119659, 0.23374433853984722, 0.2329236403849756, 0.21799631964900434, 0.2169159600086895, 0.21299332776181656, 0.25429314416298676, 0.21596665800537784, 0.23199968315586206, 0.23381348394275048, 0.7880404817090132, 0.1973607071556518, 0.19015503873353756, 0.6348739588218059, 0.24820540396631885, 0.5641355166834953, 0.20587660449361078, 0.193344323133408, 0.23576773910620152, 0.1882561831385282, 0.1878543545320367, 0.1891003055422953, 0.20004911699966277, 0.9228128308373484, 0.1692362822934672, 0.17760212473622383, 0.8700950255454889, 0.69329915673161, 0.7268572649596569, 0.9221675815787156, 0.2124132577701695, 0.1579475721909508, 0.8869253068954992, 0.16831982073702223, 0.886111339598807, 0.2122447972774415, 0.20894953853710918, 0.1922172799505194, 0.17956293347099728, 0.17903150157163583, 0.1864470913200179, 0.17908593266072548, 0.18738765951114078, 0.22073055100219474, 0.18772108997125903, 0.17373956688875258, 0.09595186439830738, 0.09874584184767099, 0.0898247524262824, 0.08503823879145234, 0.10481097242280868, 0.08714149354320455, 0.09302840384303412, 0.08782637898070056, 0.1012682621608395]}, "mutation_prompt": null}
{"id": "7f83aab8-d9da-4f2a-93dc-7d78ce880911", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.4, 1.0)  # Reduced range for f_scale to refine exploration\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve exploitation through elite mutation and adaptive mutation scaling based on progress.", "configspace": "", "generation": 89, "fitness": 0.4571767137583636, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9365039370320474, 0.9415215604138427, 0.9372704929662812, 0.932677021331257, 0.9317984797477972, 0.9506112030572977, 0.9425421131807292, 0.933592610685398, 0.9189054032274938, 0.8393190680771356, 0.8269114339748764, 0.8359504333295589, 0.831368827203971, 0.8054001484571678, 0.832112360308212, 0.8422776935781175, 0.8071233282282149, 0.8085084956229, 0.16960625694438836, 0.3129550623541856, 0.15292284692922475, 0.11499163063212159, 0.13264506427461698, 0.12574661690212197, 0.15569731749604598, 0.15117462404695348, 0.13274542344203144, 0.13533733104837142, 0.15626243970699327, 0.13385448638145814, 0.13049144735027185, 0.1176475645077717, 0.11692261495959588, 0.13045919012563822, 0.12947106748132464, 0.11275851001269221, 0.9744478644597503, 0.9521882999689292, 0.9705228405310257, 0.9606754505160994, 0.9817212615290944, 0.9571511336833036, 0.9434597283586803, 0.9766137730328049, 0.977095540931063, 0.7540441032160072, 0.758678828136077, 0.7369233661047961, 0.7369709197907383, 0.754585628279532, 0.7511743078576104, 0.7042622112491688, 0.670302661726566, 0.789073590004241, 0.9326681870970086, 0.14081168990389614, 0.230307493082464, 0.3901652194703922, 0.9476685492792607, 0.9433022100973696, 0.23693561324396206, 0.35384581951925975, 0.3704085751986069, 0.7872085915618051, 0.6011786921848817, 0.4964429764086815, 0.1363617059881197, 0.6833821332182808, 0.8415763000098285, 0.6265420196322922, 0.6683272070261056, 0.5098991159835292, 0.5195967315086729, 0.7267383765882642, 0.6235360070962375, 0.4004266927595108, 0.7230915537716738, 0.7485861007921946, 0.6037839191115627, 0.5709642807135282, 0.6637900901997242, 0.3748615920462057, 0.17994351096365535, 0.31493263899618984, 0.48276654811129704, 0.20787042189743876, 0.47318985370219824, 0.6460699932762994, 0.44971337895516694, 0.2928310465877406, 0.40432942683268425, 0.323232644336892, 0.2134712005693663, 0.3553299901495618, 0.3767531718739625, 0.3914390968180974, 0.5617756915112178, 0.756052362300076, 0.47240888793806035, 0.17342172436579162, 0.23477542450218047, 0.24952487122957878, 0.391935439508874, 0.27262772821495995, 0.558777898162979, 0.4328579567511548, 0.3827513968418651, 0.1627761562903679, 0.40536436310921564, 0.5312237833227496, 0.36618976310183626, 0.539073092509709, 0.5205812461434162, 0.6135147939227756, 0.3130511510220597, 0.34878196752455815, 0.4974008806308209, 0.8859661309535954, 0.8724994255720023, 0.8310485564272106, 0.8811058027132128, 0.8596142471667549, 0.619064328840817, 0.6676410024482922, 0.8652677206307626, 0.8606749637650993, 0.14497098719238277, 0.17076815419221325, 0.12160113071471701, 0.11707233084975865, 0.12272256220812283, 0.11762959760072389, 0.10981935442117952, 0.1457652706402447, 0.5948716632782588, 0.20009901196549396, 0.13934197541010873, 0.2784583253667293, 0.19614832719851483, 0.176090358037449, 0.15605576851316894, 0.1928394272359214, 0.15653313952455006, 0.17969020523925228, 0.6194524755193224, 0.5963015238866514, 0.590035067670022, 0.5488553340304911, 0.39548832281842294, 0.5706289135329548, 0.5799828024668253, 0.5927150206309493, 0.5616436919833756, 0.35394215936241613, 0.49197078497480784, 0.2429898117959447, 0.4619168469988233, 0.43744759171525927, 0.49351243726946337, 0.5592087960451422, 0.2425845105688681, 0.2452232147663712, 0.24952917029320976, 0.24454033042258838, 0.23632948078588345, 0.23128375583699634, 0.24118023945051603, 0.20987383067944687, 0.2126631649685965, 0.21460543569859825, 0.2260982656352608, 0.2500798269175064, 0.1912486606466438, 0.24134032149362006, 0.20041828256216332, 0.2206071577433455, 0.7846206987795274, 0.23112673746898627, 0.2334847078993555, 0.24133493116062088, 0.9342001151643033, 0.1610542002141907, 0.8912574761181205, 0.14870941105745605, 0.1674821411236751, 0.14827205907500285, 0.9413531101739273, 0.8274856043249595, 0.8341393282689528, 0.9224190056315622, 0.7983922108681896, 0.1676147473580084, 0.21239147774807077, 0.21045811436999207, 0.16943756147410516, 0.8089053894505525, 0.21262053482218768, 0.1688677398756796, 0.18800481635281685, 0.18800088032858808, 0.20292655562612794, 0.21304995124358928, 0.18805456035731039, 0.17490418068947688, 0.18094266015100036, 0.19734792799572998, 0.19880715920131786, 0.1073346109274047, 0.09681252472551727, 0.09341454076161548, 0.09101176984798198, 0.08087457224054506, 0.08731705162655723, 0.08632371102079028, 0.09742899654012016, 0.07980684260390458]}, "mutation_prompt": null}
{"id": "49f098e8-7e74-4427-915e-cda72356bdc0", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5)) + (self.dim // 5)  # Dynamically adjust population size\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance adaptability by dynamically adjusting the initial population size based on dimensionality.", "configspace": "", "generation": 90, "fitness": 0.44310908694695994, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9268458679004773, 0.9242483472845283, 0.9201991516389292, 0.9306447116217221, 0.9239984184329746, 0.9134004430874986, 0.9199404533876568, 0.9327147562341576, 0.9337690430300476, 0.8034300565367388, 0.7864524385705066, 0.7486576434505012, 0.7786460371883651, 0.7585207189233104, 0.7962123307416963, 0.7604253311754579, 0.7687377080491375, 0.7590097779087273, 0.14655860491743733, 0.14436629969527126, 0.13317612864285144, 0.15108428994243828, 0.14549260893853078, 0.15265072809082725, 0.12812291427932943, 0.12423063977699567, 0.12740481659033298, 0.1439246540591943, 0.10932713937341032, 0.1165831515779453, 0.1374244290548715, 0.13177418385401785, 0.12669568023644717, 0.11444347885481387, 0.11788254031192702, 0.11797354789406433, 0.9627747800350657, 0.9830634060460137, 0.9653004370572789, 0.9549927903355099, 0.9559314057019634, 0.9836974224168362, 0.9822822878294561, 0.9639244786753125, 0.9756523655253857, 0.7451964573229215, 0.7078247887946487, 0.6933316731918068, 0.7103562081539494, 0.7034125494817668, 0.6800454680180026, 0.6918150112557333, 0.7186607997161851, 0.678941439740488, 0.09796315762308383, 0.9538860803328435, 0.9396368920462943, 0.38925750427354655, 0.9341194447108774, 0.28256462706471175, 0.7657492733436778, 0.23798524549495892, 0.9284537199581364, 0.5917122599715812, 0.1353754664611484, 0.4788791422693698, 0.6669114422721174, 0.63192016358855, 0.46448518821859075, 0.5230492250045046, 0.13628461463992803, 0.5888456757548013, 0.5956538286458277, 0.635930213837709, 0.6461347423133044, 0.556876165451856, 0.575287921196523, 0.5940907301859499, 0.5399542601771146, 0.5964193129706592, 0.5350223029190599, 0.5536251376138601, 0.5240346576192263, 0.25966245197292326, 0.4107860984451219, 0.2367131641618474, 0.3067884693693972, 0.46182662560924825, 0.689443270230292, 0.44221342821607157, 0.19961578251383627, 0.6357579438834906, 0.174942242816561, 0.43924632885313153, 0.1356782365058452, 0.3669278477136211, 0.5900989221720516, 0.7052355297588316, 0.7108803582524578, 0.11533975667648189, 0.2031533076362031, 0.26517603809431756, 0.4228744266642942, 0.3743590715030909, 0.16203446508322483, 0.18354204420310005, 0.2477132114806352, 0.2469390490756126, 0.42554195592117194, 0.44646624584267247, 0.44026184463093043, 0.4636681713348726, 0.4694883050145784, 0.48127674935857445, 0.4344524725350919, 0.4179877227150779, 0.4098309121834436, 0.8326549182142773, 0.8345706331635023, 0.8388026028655086, 0.8439688372707527, 0.8657616991800197, 0.834684258611315, 0.8238789243476281, 0.8474092232034525, 0.8585426890138632, 0.09825504857912803, 0.10324184689001048, 0.11178258165706378, 0.2919598684915654, 0.11964998318787146, 0.1432874308187131, 0.10536688147160933, 0.13198023468703146, 0.09700192278069375, 0.135568656032794, 0.1515348442226867, 0.14151360099608756, 0.15275199822539798, 0.17303681882891886, 0.1564584479813691, 0.1525074879286924, 0.1497613119170237, 0.16669929907554493, 0.5074106671668112, 0.5202321783264262, 0.32428151233666935, 0.5283022311576286, 0.5505402027920177, 0.5311604643319361, 0.5280877502695405, 0.2777140968414328, 0.5521016800975361, 0.2842169902006446, 0.41953056701463076, 0.4080775421707685, 0.4020461087671512, 0.4467697154368814, 0.4536856107534589, 0.28151457584706363, 0.2817677097907143, 0.3150601002746136, 0.20610335393229784, 0.2019590163997994, 0.20879630468160382, 0.21203537689466634, 0.2225522111469751, 0.21870824141521839, 0.216519835389692, 0.22689348047256586, 0.2217059922755268, 0.20586409131169137, 0.2416501423541464, 0.24484846960134343, 0.21890556995622668, 0.738429234656535, 0.46417993492654386, 0.19843812259997773, 0.7321869603319062, 0.2366042341419804, 0.8577661386323421, 0.9577407517371922, 0.892804816680085, 0.20097671053392407, 0.19753411609106697, 0.19535647942675438, 0.808389614851208, 0.939566660128372, 0.931037637380092, 0.20968710698034387, 0.21004128633393915, 0.0734223750291072, 0.16672762663960017, 0.21151242515816193, 0.21248275335189215, 0.8893626864486983, 0.2127512665891963, 0.16681446067992234, 0.1849548735990273, 0.2147060314862791, 0.19259960013248212, 0.19930934912372866, 0.19370521117953254, 0.17821751052064483, 0.18385970297012766, 0.21982263261383728, 0.18958905463924147, 0.09067376192672238, 0.10181726826052107, 0.08733239052006392, 0.09204725656519497, 0.08683708902380627, 0.08548945154229481, 0.11028992860809195, 0.10130014311219859, 0.08532059940114012]}, "mutation_prompt": null}
{"id": "cd225c85-a02b-46c8-9afc-6d03f9d5525f", "solution": "import numpy as np\n\nclass HybridDEACMEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.5, 1.0)  # Adaptive F for enhanced balance\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.6, 1.1)  # Narrowed f_scale for stability\n            elite = self.population[np.argmin(self.fitness)]\n            avg_fitness = np.mean(self.fitness)\n            adaptive_F = self.F * (1 - np.std(self.fitness) / avg_fitness)  # Adaptive F adjustment\n            \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (adaptive_F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACMEPlus", "description": "Improved exploration and exploitation by integrating adaptive F and CR, with enhanced population updating mechanism using Covariance Matrix Adaptation.", "configspace": "", "generation": 91, "fitness": 0.4383122603353944, "feedback": "The algorithm HybridDEACMEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9244247356907357, 0.9295097087268506, 0.923425159765284, 0.9246230863579012, 0.9427026301050184, 0.9257914918017095, 0.9336265236233154, 0.9300817761729461, 0.9205094973062158, 0.8036780899979916, 0.7933578798494774, 0.7715343731313927, 0.8082456082874655, 0.7714740261076589, 0.8155276899728744, 0.7905896713883246, 0.7849039104814567, 0.7581094218948061, 0.15251522762328207, 0.12212977713086692, 0.1311087301167967, 0.13586544872845274, 0.11229467827275752, 0.12015894362129365, 0.12459664986703833, 0.11555429117369764, 0.11390407508595601, 0.10715577640891372, 0.11864753210266699, 0.13691858279942393, 0.09772834043912149, 0.10438430807230725, 0.09520603322992771, 0.09751559028078027, 0.06310085315929392, 0.12153153295132302, 0.9753681758107882, 0.9739301207522207, 0.9716294807029369, 0.9683662029377373, 0.9856523882063272, 0.961021580453278, 0.9807238743487059, 0.9683663852680622, 0.9800422104618074, 0.7597168025023262, 0.7067965762880126, 0.7673708254592835, 0.7100417794437697, 0.7440561959944694, 0.7226621957686887, 0.7683128276221455, 0.7130800551803456, 0.746555406479007, 0.915441823008013, 0.3810862680078547, 0.3274909748339332, 0.39406629968026563, 0.9272854764167028, 0.3113629220384937, 0.3720484865490291, 0.3829562666207179, 0.9205820732589358, 0.7423376627977845, 0.42917718337999566, 0.7273568248475504, 0.13387700032486516, 0.4755192895127126, 0.5352110659498082, 0.46671977401248066, 0.8016253040097775, 0.1368739140456069, 0.5848170063437541, 0.5855634622367947, 0.3643381243843892, 0.7279064975510479, 0.8006758197273883, 0.8080696543870175, 0.4921142217039449, 0.13408755872215772, 0.6038547500106195, 0.6210518806897563, 0.23457162586290392, 0.42439956525480593, 0.4761162575658121, 0.6026243322053224, 0.2807191256752899, 0.4121725732816679, 0.5752713823672073, 0.19277031274459977, 0.3155092568525196, 0.7616257169738604, 0.36323061505548015, 0.7110868186725703, 0.5789172941292513, 0.22912436226651023, 0.709526478499381, 0.6370933365833067, 0.49603071046229885, 0.3440411168679456, 0.21365778044568473, 0.38377668594694003, 0.5823878793986366, 0.12551133804353343, 0.30455826529773977, 0.12451039263750097, 0.25258616381787646, 0.27353019400938583, 0.48249209074823396, 0.42020476565650455, 0.33224754845464854, 0.5025881538496026, 0.5047371221877541, 0.4705337777964853, 0.4274180725500687, 0.4567835002833798, 0.43418869268506033, 0.875032158172136, 0.8608721395283552, 0.8694750366347387, 0.7812076750741845, 0.8205066519400342, 0.8606374096406416, 0.8693193364795269, 0.8216283884430591, 0.8817675984739444, 0.10962066697213957, 0.14333372022138502, 0.17199634334123237, 0.11044856797318447, 0.1392626232636479, 0.1579074386313849, 0.13913420717015101, 0.13685008972427348, 0.11865601980209561, 0.21108750575221036, 0.158217976770043, 0.18005773321159302, 0.20497385274519708, 0.15469218788702221, 0.13943318737779375, 0.1708102243877605, 0.13910478482908162, 0.12560658275319692, 0.28666622066319536, 0.5183385722626983, 0.4949161741091894, 0.39917241478580223, 0.5273234249919578, 0.5277779642015467, 0.5776583341436514, 0.5353717556862089, 0.5420860625500632, 0.18625622492457838, 0.46373647825767406, 0.4526086167679486, 0.29570253571825156, 0.4642650585976028, 0.22024388597327882, 0.22398510746998213, 0.22780368726133415, 0.29773507345207273, 0.20447625009812864, 0.2206951489168577, 0.21771738602832225, 0.2247376848070568, 0.26217882627430555, 0.2004858793712132, 0.19227773879596788, 0.20157351576748417, 0.2319556651702661, 0.22792183924833997, 0.2068410502399417, 0.1991839731989128, 0.24676518177917206, 0.2115612255416378, 0.2527177687411448, 0.21671280956845762, 0.20180743932159362, 0.20156884105368666, 0.12190497587763294, 0.1102639776358586, 0.187478317107183, 0.9555156985761017, 0.9124727946529072, 0.9211337011889291, 0.1526763499586612, 0.8420106843697808, 0.17204749591873192, 0.16976845569718624, 0.8687153902080189, 0.7818129969124539, 0.16922717460450876, 0.16853510789143633, 0.7675198872887647, 0.2132087980689561, 0.21341554624055947, 0.21350590221855226, 0.19947092658435217, 0.18564021417858256, 0.19053349007322362, 0.18004012055333118, 0.20676344888854636, 0.18339752828357425, 0.18410649276626068, 0.18421594244732897, 0.19439466987819032, 0.10022483764530676, 0.09729425564463978, 0.09071555931228537, 0.09387659764439327, 0.09501685077690014, 0.08377742689802214, 0.10126387007063731, 0.08836687951066124, 0.09450431834679562]}, "mutation_prompt": null}
{"id": "05b39168-13cd-4d83-9e1f-f8bab2b94d90", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                crossover[np.random.choice(range(self.dim), int(0.1 * self.dim), replace=False)] = True  # Adjusted crossover strategy\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Refine exploration by adjusting crossover strategy to further enhance adaptability.", "configspace": "", "generation": 92, "fitness": 0.4273127999528456, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.903224074454528, 0.9360897747533545, 0.9183738590216483, 0.9253507488514832, 0.9319461963353621, 0.9190684194721993, 0.9215353890695681, 0.9373510860250952, 0.9377722501301644, 0.7552131419403991, 0.7703580130940597, 0.7951017982639731, 0.8042829741817218, 0.7846149478365141, 0.7797307161391234, 0.7291224785506218, 0.7727311806151081, 0.7795004076203635, 0.1355138879638782, 0.13315479110777617, 0.14604014479315397, 0.1469660998004485, 0.13302247420635427, 0.13186232846798174, 0.13069544504692354, 0.12684233992759197, 0.15626086757343727, 0.10891647520121062, 0.10711227244830912, 0.11323098030663836, 0.11784728844129255, 0.13049343496007404, 0.13632057233821948, 0.10282069310535791, 0.13268702528191478, 0.11883642719271759, 0.9433879667080866, 0.9734858258806709, 0.9633832414254074, 0.9615397149865571, 0.9667368696843556, 0.9555876758939029, 0.9522593554036305, 0.9778844050954747, 0.9679669886086041, 0.7008626114339146, 0.6422843649487225, 0.7075563465946406, 0.7124613256501342, 0.750856259689216, 0.682693357019325, 0.6712220792808966, 0.7471173782156824, 0.7160118536263582, 0.367916893148422, 0.246534562021679, 0.2179212529882868, 0.9589691507908378, 0.3905867942174962, 0.21465383555297035, 0.244292258827579, 0.23756822661141574, 0.2383147149836342, 0.4859602978382407, 0.6894329733114348, 0.4595661855155566, 0.6531153844024202, 0.7712549127647991, 0.5877552206618115, 0.6276028990273556, 0.6056662861538882, 0.5223423118528217, 0.5087997811886338, 0.6377391779412609, 0.7766626904395304, 0.6766626025530553, 0.5796002258511888, 0.724792314917402, 0.6718571295003003, 0.629599283293923, 0.6773172451483853, 0.15133777406440363, 0.35730443940138856, 0.41340592708688917, 0.6307622613671058, 0.44453483303699237, 0.45860728079485835, 0.42349328373432626, 0.5098957174096729, 0.28027720398398404, 0.28675026395528036, 0.5560868528510482, 0.22686955349950844, 0.39630094416457806, 0.46284253925282526, 0.42674432450153654, 0.7310871623903658, 0.22556001597471453, 0.7451717168508263, 0.10674001514657627, 0.17484939125846488, 0.1466730653876286, 0.4403002275275639, 0.2534239742524501, 0.38754714985271166, 0.155455348056444, 0.41909105785988876, 0.3899356357003906, 0.41076181428814285, 0.4489855051081364, 0.4200179002287069, 0.4447976994694872, 0.4589503587435212, 0.47613213976201874, 0.36486421624148246, 0.3609383644389018, 0.46585033004088316, 0.8399145286032097, 0.8451841667282578, 0.8165068701029403, 0.7604739611379872, 0.820188001587923, 0.8064625088798172, 0.8647361860813264, 0.8162690823062039, 0.8773796128710382, 0.1410874856814166, 0.10257065025610013, 0.14592355632746945, 0.11188376655558552, 0.11679503865969731, 0.15007460808557282, 0.14208255680224136, 0.16418155179190652, 0.1460497152941731, 0.2851857940557143, 0.1600115534279246, 0.2387559713066475, 0.23972452998825666, 0.2935103535005693, 0.14607389478615274, 0.16345286142547355, 0.13176597988155847, 0.16743755184382103, 0.48913297360633323, 0.30673478028422274, 0.3738610375094261, 0.5082113390665619, 0.5512259679625512, 0.5059960650830505, 0.5231737201906514, 0.541663620055423, 0.2852060000412231, 0.4580311155462138, 0.44894546408983216, 0.3163306593273125, 0.2967888952664465, 0.284863547242448, 0.22024683218122287, 0.43669245123576494, 0.18713295370160665, 0.25210805355329036, 0.21961654619216986, 0.2597174828711444, 0.2183851528002525, 0.22910956902653168, 0.2316336740938706, 0.2245957430458938, 0.21035705653355596, 0.22531297720098742, 0.210389911307998, 0.49255930428329586, 0.2023050667753752, 0.20221745835207217, 0.19681069737599088, 0.24296330057264837, 0.20374837970714166, 0.2174646314145281, 0.2515825435483311, 0.19547556067704186, 0.1884032663230627, 0.9116310364090807, 0.18532379022151135, 0.16901208808461599, 0.951231999774422, 0.1718746961756097, 0.16581516239591387, 0.49100731119263175, 0.16690853421660212, 0.8720729660133706, 0.21151223524455476, 0.21344199591898794, 0.15446066305728146, 0.7328384866834737, 0.21247796392001717, 0.1557386390157568, 0.8042497660168219, 0.16933250087347407, 0.17996513203582376, 0.1870494885994447, 0.19146768207453857, 0.18279787785464818, 0.18568716985287348, 0.1878008722770964, 0.1843177476565998, 0.18319999673372367, 0.18852910933797395, 0.11704246167206145, 0.10361714215163187, 0.07984280926485188, 0.09250086090318377, 0.12039029070995544, 0.08547685381706993, 0.12392104115875557, 0.08862504840396523, 0.1176077102296873]}, "mutation_prompt": null}
{"id": "02ad5856-f335-4f35-913f-ad2823ec0f26", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F_base = np.random.uniform(0.5, 0.8)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = self.F_base + np.random.uniform(0.2, 0.6)  # Narrower range for f_scale adaptive\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F_base / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            if self.evals < self.budget:\n                center = np.mean(self.population, axis=0)\n                covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n                new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n                new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n                \n                for j in range(self.population_size):\n                    new_fitness = func(new_population[j])\n                    self.evals += 1\n                    if new_fitness < self.fitness[j]:\n                        self.population[j] = new_population[j]\n                        self.fitness[j] = new_fitness\n                        if new_fitness < best_fitness:\n                            best_solution = new_population[j]\n                            best_fitness = new_fitness\n\n                    if self.evals >= self.budget:\n                        break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce adaptive mutation strategies and elite-guided exploitation for improved convergence in Differential Evolution.", "configspace": "", "generation": 93, "fitness": 0.4078362531497105, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9029801529876453, 0.9302933035646238, 0.9156702893972137, 0.9122314140909293, 0.9085311684596263, 0.9179092396756648, 0.9160332965603214, 0.9187807763987962, 0.9304785428792066, 0.6139096883613323, 0.7210656695932214, 0.7163542767522413, 0.6745566266054059, 0.7003355654305357, 0.7274903420854505, 0.6986914839114557, 0.7396386028642532, 0.6949716189427824, 0.14314954312400385, 0.14151955628221657, 0.19686441756543904, 0.12039423049085884, 0.13532338857735016, 0.14516325958793275, 0.1660567110215817, 0.13377006643541767, 0.14207991844605672, 0.12664963156934794, 0.13797049996723876, 0.11142388295613814, 0.1136571578594312, 0.13056751921042575, 0.1111017027359259, 0.1377440088990326, 0.12087073060864773, 0.12563643786956513, 0.9826452063246964, 0.9739902950215127, 0.957675553279789, 0.9389030427330171, 0.9793230499207114, 0.9695566520509006, 0.9657034832471652, 0.9656778626851322, 0.9535150902221643, 0.6884745412970816, 0.6977880725849415, 0.7095013410433761, 0.7429167778283154, 0.7246829622804687, 0.6535977091964702, 0.7006403182625763, 0.684225815515715, 0.7212880414313629, 0.2290131833126322, 0.8359684164147267, 0.23095481858241373, 0.40562013667958885, 0.2126469922753198, 0.21386680188849239, 0.9580732150586532, 0.23826401177091072, 0.9116803423813192, 0.5155646968525616, 0.5636880347467972, 0.677058760777437, 0.6737233320959257, 0.7053671958135412, 0.5101749985595116, 0.4455452108382666, 0.5327534238193845, 0.4963476601549306, 0.6259595513978469, 0.5084388637349753, 0.650058377197167, 0.5554312045454035, 0.39274650119961774, 0.626802749736622, 0.48519703821794025, 0.13518252821839594, 0.5553763957603645, 0.4923012574522472, 0.4208029726660566, 0.4184990431337966, 0.34944010574250084, 0.24303760059419932, 0.26747684371053737, 0.4027860347475597, 0.5734206210523829, 0.4597373895420823, 0.11229633567505948, 0.323829997889271, 0.5679869496858154, 0.5697180204332795, 0.21860234003238876, 0.08052680934006673, 0.4837331310522075, 0.6562219014130293, 0.6170037733085723, 0.29161288660465534, 0.22648248647657487, 0.2572682856360441, 0.307800815431183, 0.40070575502108297, 0.16817147953030798, 0.35656287808990483, 0.26923750291283766, 0.27585866369890566, 0.3402336353857358, 0.3876546572772248, 0.3674184531307314, 0.3824976050236494, 0.38758815765526333, 0.4039261443675709, 0.3990591361531066, 0.399057871341989, 0.3859201258612631, 0.8234031833068526, 0.8120909384009236, 0.784754440833336, 0.7482973553246547, 0.783281826609001, 0.7925675757452076, 0.7718186799860801, 0.8096919140387917, 0.792853291593425, 0.15947274018458157, 0.10218263725115462, 0.11236540101350911, 0.13027349507724906, 0.11710737923813686, 0.1384111541145301, 0.12624465568544496, 0.1334757804659823, 0.1466005474831118, 0.141026852900194, 0.16129068488121445, 0.14953305858978072, 0.16388434620664105, 0.16511398344436168, 0.15208292189081218, 0.1657148343728111, 0.17270852953605242, 0.19078529928078614, 0.2821091289804103, 0.3684914391955141, 0.4782711302802878, 0.5065523527245914, 0.35718621684883434, 0.3405232405088825, 0.49318373100345536, 0.26423947656021407, 0.2368034951976712, 0.3050923196618519, 0.3125646836793676, 0.32470085337170096, 0.3164934206710778, 0.3279565978521758, 0.25868669040314207, 0.43618487946587226, 0.2294735489598544, 0.25259352389265377, 0.20936554465105583, 0.24636008490875105, 0.2062815106966106, 0.24823490825828465, 0.2157410614062094, 0.21411007145504923, 0.235178470270612, 0.21696081857453287, 0.22897173518918212, 0.19530669064428308, 0.20239723617007144, 0.7783195045928816, 0.2294545512392938, 0.22899818334967192, 0.23143159172968208, 0.2142393875956079, 0.21819226426406113, 0.19934892767738388, 0.1879806541616571, 0.1826601290124381, 0.18834416026733247, 0.19972070865278424, 0.19993616464696284, 0.1971316515428091, 0.9270907290748412, 0.9175048686542033, 0.16879247060659963, 0.9305057232531044, 0.12748384749017028, 0.21244202207386254, 0.1692874116759514, 0.8217297103754524, 0.1671893457656326, 0.2085145484831047, 0.12650853919767302, 0.16803416545130134, 0.19394436655144864, 0.17086802971540838, 0.1872592745222762, 0.17458376895576477, 0.17532467066918, 0.17080909924150744, 0.18987203844239975, 0.17020073780568912, 0.17748332131845834, 0.08726958675220342, 0.11112486324491988, 0.09155735426388578, 0.11211132955587688, 0.12504499558586635, 0.08387237498359812, 0.09752121458196839, 0.08504040000760449, 0.08490097857557721]}, "mutation_prompt": null}
{"id": "ae2876dd-ebf3-4efd-b237-3b025425d541", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                angle = np.random.uniform(-np.pi, np.pi)  # New line for rotational perturbation\n                rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)], [np.sin(angle), np.cos(angle)]])\n                mutant = np.clip(a + f_scale * np.dot(rotation_matrix, (b - c)) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Improve exploration by introducing rotational perturbation in mutation strategy.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('shapes (2,2) and (5,) not aligned: 2 (dim 1) != 5 (dim 0)').", "error": "ValueError('shapes (2,2) and (5,) not aligned: 2 (dim 1) != 5 (dim 0)')", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {}, "mutation_prompt": null}
{"id": "745c98a2-60a7-4a46-8411-2cb91f73fcdc", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = -np.sum(np.var(self.population, axis=0) * np.log(np.var(self.population, axis=0) + 1e-5))\n            self.CR = 0.5 + 0.4 * (1 - np.tanh(diversity))  \n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "HybridDEACME with enhanced adaptive control of crossover and mutation parameters using entropy-based diversity measure.", "configspace": "", "generation": 95, "fitness": 0.4194849541649831, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9354470735161736, 0.9295775268810633, 0.9186920188165691, 0.9310940632195349, 0.9320497084936651, 0.9376944354914207, 0.9359446765729373, 0.9199040431068515, 0.9298674724573004, 0.7709586943979021, 0.7520193908926971, 0.77070517009146, 0.7745528111709986, 0.7498514542839222, 0.8240345592346667, 0.7842141407676808, 0.7585085170465019, 0.7388365724104999, 0.18555606366873367, 0.15719165630720433, 0.17610718054565333, 0.18022747261689287, 0.15051547097042894, 0.15263527474159544, 0.18725954209780116, 0.1806170044166796, 0.14360725430770804, 0.1507901251691135, 0.11745982981814884, 0.1354500952575849, 0.14696307679436904, 0.15307097990489982, 0.15622089571176145, 0.12384344264630764, 0.15150539220626413, 0.14276098722250008, 0.971228412842149, 0.9628937879591558, 0.9977836614996912, 0.992231050005117, 0.9657382620650258, 0.9173615184039836, 0.9557359364353708, 0.9981943293314975, 0.9465956865087445, 0.7006791901017879, 0.775244427270449, 0.7226004243637307, 0.6038571404387856, 0.767890510828116, 0.6843358546706528, 0.5396796889748877, 0.6964754227698908, 0.6823520704747761, 0.23017536420679752, 0.9623633562883598, 0.36583994275272613, 0.9638466782533137, 0.3906382799029018, 0.9449536774249647, 0.2516105431280954, 0.9544043457849564, 0.23894685203838784, 0.5513981117014389, 0.5967103324050202, 0.6076867668734494, 0.5986624225288931, 0.6911026553825346, 0.6146177577507927, 0.6792873347998644, 0.641905564871457, 0.6012779827811581, 0.4283799406048491, 0.49517872031849863, 0.5276257559626013, 0.6796954072717931, 0.5778776514722106, 0.4993013502833563, 0.6681122927062906, 0.5772829554515073, 0.6741111007742298, 0.44626192773788, 0.3475958853260346, 0.41320400061642415, 0.42693450327101046, 0.5651875382669085, 0.33024815888338266, 0.2060790861648688, 0.2517337684309252, 0.4719643426513871, 0.0618020556128166, 0.2573832220674973, 0.13819391903779943, 0.5574466703715119, 0.5080467322942656, 0.20652340853276308, 0.5935793406550887, 0.3876967073051354, 0.44863295753399723, 0.2092171496367078, 0.22609371274404877, 0.10403083406646474, 0.3401140788595961, 0.20995822344911275, 0.2832119958679641, 0.16609442527913199, 0.19035942245349602, 0.27367774266284695, 0.5011734435012951, 0.5064264457117915, 0.40609656602580924, 0.5016724574670763, 0.509756843495801, 0.33003073051701315, 0.39945732979883775, 0.46198473910160676, 0.4007153315746419, 0.7607582123104256, 0.8565704369996139, 0.8519228186546404, 0.8304853048560744, 0.8638621508236749, 0.8057101653880522, 0.8808324887710893, 0.8265044259487362, 0.8241617641918115, 0.2937802367874529, 0.0944963828178339, 0.09684133379752946, 0.11637101821549733, 0.1499052756469348, 0.11541266680223183, 0.14022046395890198, 0.15833067337046325, 0.12311409811598639, 0.24052088996898802, 0.1670388865382998, 0.14487447669008036, 0.14678387772060064, 0.15927025525101146, 0.17863781667758016, 0.24769593794060607, 0.15528126918057183, 0.14520929968465301, 0.3758458787984379, 0.2877916702952841, 0.5381849528634778, 0.2960233462540529, 0.502481624829638, 0.23414897206405072, 0.5440715314479238, 0.25162381493706276, 0.21378871684610545, 0.26707209256061926, 0.1977852535363418, 0.28568207916127664, 0.27082723826974076, 0.2192601399211207, 0.40037916751947233, 0.2783199438246011, 0.25558609839388735, 0.2506657131848813, 0.21907072285956752, 0.2002591576187891, 0.2540545089443479, 0.19988963787744374, 0.22712997799319468, 0.2280917527649643, 0.23447343201018844, 0.21928538893070548, 0.23256631805246153, 0.23320500773061603, 0.21604925091468574, 0.22424362196756087, 0.7562005949729911, 0.24728809687742237, 0.223673099679646, 0.21079544660995586, 0.21627187970540485, 0.21694256779198218, 0.18819749712206113, 0.11067225679318493, 0.14909435106451896, 0.201036949278796, 0.9393800835776775, 0.17034949363814922, 0.17185155710657196, 0.17191343474955922, 0.8950466215647772, 0.8917644802656702, 0.12779795652064152, 0.15758389946040952, 0.15703406366432315, 0.7349191078726218, 0.1688749331338486, 0.21358485480162015, 0.21423635169692978, 0.214357570352944, 0.18524021637372812, 0.17137413010846703, 0.19498718091749911, 0.1729803897369322, 0.2033233220347932, 0.1732945748319451, 0.17465858662923728, 0.1995555071922579, 0.1845626791706615, 0.09629777250151605, 0.09481598371133981, 0.08661151753748986, 0.08891056476689496, 0.09010457207139955, 0.08806868315882421, 0.11703472076540622, 0.09657049716109034, 0.09085212429063083]}, "mutation_prompt": null}
{"id": "093b2fc6-cb87-4596-9a89-20320d3d0f7c", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2) * (1 - 0.5 * (best_fitness / np.max(self.fitness)))  # Dynamic scaling factor\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce a dynamic scaling factor for mutation strategies based on current best fitness.", "configspace": "", "generation": 96, "fitness": 0.38405325791373834, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.945749402396388, 0.9522458355242003, 0.9486639410375352, 0.9472747765797185, 0.9526608530037136, 0.9525720107081768, 0.9448394041235322, 0.9442572228387482, 0.9458503152578759, 0.8773742096949904, 0.8628454142791835, 0.8621468063955134, 0.8622194728837793, 0.8676761447818556, 0.863970948781321, 0.8716751161939912, 0.8623902730863872, 0.861327282723321, 0.1530481580884323, 0.23053724946642706, 0.11696430845510897, 0.1401661150243585, 0.18075281654489594, 0.2001004167123318, 0.18478266656818942, 0.18431280055995125, 0.18207172589940557, 0.12005900951877335, 0.0904823214700371, 0.18178269034057826, 0.11489101993520712, 0.13375416660595785, 0.14026354467825153, 0.14853818460765578, 0.13082243751586264, 0.14269709629938665, 0.962578842134445, 0.9651117966360532, 0.9563175107121138, 0.9577919474728631, 0.9808127053721785, 0.971231505773741, 0.9689691892579242, 0.9588077098394038, 0.9757588155855726, 0.4639278030799544, 0.7931233180927885, 0.7190404601979625, 0.7057500978550213, 0.6172218915455646, 0.4989216277354963, 0.4599089544106243, 0.8187639751088069, 0.6041187448822278, 0.9594785581962539, 0.13142435708200428, 0.23252404953520334, 0.9569501924303178, 0.2826852480944291, 0.22254992338549429, 0.9664883710049071, 0.9527247170908395, 0.959745190638809, 0.31498308431492283, 0.584960393394677, 0.13423380522955564, 0.136730507252403, 0.3699167902406775, 0.13413003337399243, 0.28142992208283435, 0.8073801008150171, 0.13731001895487538, 0.3040675396925092, 0.1357382628517647, 0.2575735465836052, 0.44901358093536814, 0.811433694953031, 0.2776931642257213, 0.3095062695321521, 0.13678929801131512, 0.3379301777137155, 0.22137926606712532, 0.20868091466745775, 0.10412540287358496, 0.30539119972893913, 0.021091747265288396, 0.16624266606868698, 0.02875393560190731, 0.0557650164710376, 0.2271050869434028, 0.07191193939861296, 0.338165513170005, 0.2939312823215543, 0.3120448463245782, 0.27950981908841355, 0.11234007919976252, 0.35133940985567313, 0.30440015014936594, 0.170071645963489, 0.18108745544205795, 0.2188289241407274, 0.14326560946764644, 0.23705978997056176, 0.3568557644504331, 0.30329558621235486, 0.21558127099726498, 0.37063410263610275, 0.18715451860221044, 0.256875589253982, 0.30820022286901216, 0.29676816795281935, 0.3101649358570372, 0.4953090649147225, 0.26304194297955574, 0.2865355755582162, 0.22561490569486697, 0.3967473902141885, 0.6242739574831774, 0.5999327838170294, 0.6366202618807695, 0.662748777172787, 0.616261527495851, 0.7084818958807312, 0.661921309676871, 0.689800775910088, 0.7774385657009467, 0.13853684956020296, 0.0888819955627852, 0.12997183565613046, 0.15952928578602454, 0.11552878920721155, 0.1435289648719772, 0.1604219596435823, 0.15185615081244774, 0.11395205672878561, 0.15713217470254892, 0.155203555728476, 0.15980722667009273, 0.15694954907024516, 0.16087496529448586, 0.18577925315504085, 0.1526753502282625, 0.1792898459896355, 0.18751761966788738, 0.64833338626533, 0.3067557968371172, 0.3876574250841044, 0.591096146674589, 0.3636223034133559, 0.6386935960255307, 0.5767339553154122, 0.29454263869313724, 0.6389065245305456, 0.3122120788634255, 0.2700696245274803, 0.2901477214220034, 0.280761476007065, 0.3544247762821032, 0.24441614656474575, 0.28493688504228865, 0.2455188201087145, 0.5350634027766605, 0.2281733105185353, 0.23345946538323492, 0.23210108720453637, 0.21222507515158207, 0.20961766243416657, 0.21907844544660193, 0.24144141408457365, 0.23374555945395814, 0.2357147035955668, 0.2277906008037951, 0.2115606544996509, 0.24564067414001511, 0.21587675552050545, 0.20932915922602446, 0.24343208100691016, 0.23509206933233107, 0.1942790300404562, 0.24992929068389702, 0.1994900286203085, 0.2003815151357009, 0.9515099932036436, 0.16558452793417, 0.9110488987857654, 0.16681722836948443, 0.16645547268179484, 0.7574552753365541, 0.13012169233949467, 0.5457388760740851, 0.5556113944658783, 0.1700320894220274, 0.1556550599784816, 0.8512692065592791, 0.169832123221887, 0.2127834648002388, 0.21435260728859706, 0.2106685466683359, 0.18267988002067526, 0.17384846222765105, 0.1963539075302292, 0.18267102782200384, 0.18617885680936352, 0.18253258740905554, 0.17438703364548547, 0.2018679993934318, 0.1847547565681349, 0.09418457682365367, 0.09873830480522716, 0.10718668220356176, 0.08304444922868337, 0.10435280693776294, 0.09751578327291466, 0.08630940157130718, 0.0850655246951959, 0.0911420509405656]}, "mutation_prompt": null}
{"id": "5fc372b8-bd46-4728-9dc1-35f191a20bad", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            self.F = 0.5 + 0.4 * diversity  # Dynamic scaling factor F based on diversity\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce dynamic scaling factor F adjustment based on population convergence to improve exploration-exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.42713260102760914, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9293393939627458, 0.9306429739779076, 0.9289637549082207, 0.9321591078585105, 0.9372068407090322, 0.9477380749670797, 0.931327857377356, 0.9253864099014483, 0.9391606784186886, 0.7724471408796589, 0.8024212130886885, 0.808501865834709, 0.8048444726465875, 0.8132714192320514, 0.8255080255496539, 0.8074315917895273, 0.8137654989895178, 0.820582012902144, 0.155293783030524, 0.1495566773023087, 0.17501548892408514, 0.12033836516759688, 0.151984763030395, 0.13440763707984316, 0.13204897332332333, 0.14704403970745794, 0.14750487929991907, 0.11327889754077769, 0.1255332791034598, 0.12678024354122686, 0.13859474564640606, 0.10893255359016896, 0.11490088800884912, 0.16124832209261386, 0.1292542518832126, 0.12211333933711199, 0.9850502677805735, 0.9863467924807348, 0.9760309464769293, 0.9473716975186979, 0.9821784283620427, 0.9440009093346818, 0.9805343360977898, 0.9585913546418466, 0.9669956639875193, 0.7290485028770064, 0.7045768966904489, 0.7581874257469522, 0.78794386485944, 0.7208528752595456, 0.7901914177471817, 0.7444288537241153, 0.6268792867010604, 0.6568920536298324, 0.2532857071556148, 0.2030751587231927, 0.23143919668601198, 0.2847836110849803, 0.9461368855584928, 0.9514305105207183, 0.9435853817728181, 0.2383532561200583, 0.9533922104980311, 0.3341269886505621, 0.2967657251577953, 0.13577048953851767, 0.41222837206089824, 0.738188832756203, 0.3567109289177426, 0.6256810582901967, 0.38089670225570393, 0.38655829300756506, 0.44092598454926957, 0.5731803049483655, 0.6839232257102408, 0.4888556306166826, 0.46450183136984347, 0.3854565152271767, 0.34616773724980876, 0.4655976005513094, 0.522245147327631, 0.24939658963941524, 0.5942040301855367, 0.00413059323063969, 0.7290112014768197, 0.25082963262099234, 0.3941261293206877, 0.3548428883368109, 0.3489278169738119, 0.5687936872212764, 0.2636794831554463, 0.18004834241588852, 0.28424135209702805, 0.5593614902151858, 0.7955597178917515, 0.23218622515016463, 0.27714760385117365, 0.7248463073216967, 0.497590518071088, 0.15858508805516158, 0.21962248808520135, 0.12547335577121044, 0.3260912044166492, 0.16705767957091489, 0.3770745297987238, 0.16634135904533764, 0.24155205432564408, 0.20923298984619232, 0.3587570897567376, 0.420202872401395, 0.5277753824090441, 0.5572641110832885, 0.495074593820101, 0.45489408672768983, 0.37558565721697046, 0.3723037876709071, 0.39997068631054034, 0.876175692699937, 0.8197382433261541, 0.8678848498209858, 0.8667758027603646, 0.8583008641260412, 0.75390006736195, 0.8775554303048115, 0.8848824355890225, 0.8082255376301557, 0.15336542206188242, 0.15307314750449474, 0.12758190438833605, 0.11559263045112478, 0.12489890784489022, 0.21488877907576331, 0.10326387058690123, 0.12210934360410808, 0.12692335755027484, 0.16737710301803932, 0.16418645845288593, 0.25392386308969694, 0.20743205263987397, 0.17409348795695767, 0.14968424755113685, 0.15066371719823424, 0.19318702456652237, 0.15951867867894476, 0.569670129280041, 0.3031816181040742, 0.34848765201700393, 0.5857612651109582, 0.626925720540106, 0.2945528886935772, 0.5564281996435883, 0.6560891009534485, 0.5396468486110595, 0.3210643771771602, 0.4875923746680414, 0.48177217871454514, 0.41063546700988085, 0.2597949760281514, 0.2963614596013552, 0.2647527098483473, 0.2866849161024321, 0.2648149939457928, 0.21136454871619348, 0.2323842686601858, 0.25520164332667217, 0.25638590351070767, 0.23513861117860535, 0.23625481286704308, 0.2306109752918506, 0.20568202826000737, 0.2490453206397144, 0.236273100042808, 0.4757440711327233, 0.22150809906879942, 0.4865466739772384, 0.22365995433504537, 0.22651707556155398, 0.21188978445893303, 0.22087167021523857, 0.19636188178136316, 0.9305516897095765, 0.18490452503959443, 0.1884304525745243, 0.1690713681695435, 0.9369252186270477, 0.8790803722037095, 0.19939908482483015, 0.15764458217943722, 0.16834704841404513, 0.9180968865201917, 0.6060467575539908, 0.2106074296271827, 0.1685245318388987, 0.20869311237518395, 0.20889676684952774, 0.867590358166711, 0.2122040433516127, 0.1686642735511107, 0.2160297123152929, 0.19860477257036202, 0.18386306885837822, 0.18373383890006623, 0.18933754368932465, 0.19041430365698309, 0.19452126320960317, 0.18067787245442324, 0.18036722624066492, 0.08822887466449503, 0.09159469361068351, 0.09367684419557276, 0.09063265523206554, 0.1030778384689005, 0.09453296817507184, 0.09382480237327906, 0.08604746453678003, 0.10126041200942815]}, "mutation_prompt": null}
{"id": "4e328859-c193-420a-a487-451f77cc9085", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            self.F = 0.8 + 0.2 * (self.evals / self.budget)  # Time-varying mutation factor\n\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Introduce a time-varying F parameter to enhance convergence by adapting the mutation factor over iterations.", "configspace": "", "generation": 98, "fitness": 0.4341035507669493, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9324179582217389, 0.93639843115054, 0.9421652149439097, 0.9304369505552649, 0.9365840087927616, 0.9355969715377246, 0.9372538703703829, 0.9210183288770455, 0.9312571239669583, 0.7772251644699852, 0.7776130804267074, 0.7827916500689716, 0.7922260720782889, 0.8101402454063825, 0.7900722807345554, 0.7964184041804455, 0.7996753072964069, 0.8081086826923412, 0.14463534924134824, 0.125052883695422, 0.13325483483972, 0.12801569373317412, 0.1522750864385023, 0.13962896110077472, 0.1619289863690616, 0.1447084171414319, 0.20387282109505922, 0.1401985172154362, 0.12114439352750672, 0.16537006593054226, 0.15322702390185627, 0.12371510460023383, 0.13030191011745285, 0.12340137119127703, 0.1411710452137409, 0.11725858356140562, 0.9489180361216689, 0.9780853095025631, 0.9522886541471643, 0.9519440330335933, 0.9883587465546516, 0.9565212510569536, 0.9693830472647502, 0.9619723421677158, 0.9792787661587531, 0.72288592707988, 0.7292337187752442, 0.690297556938992, 0.7310584094059938, 0.6455289779653142, 0.6815041834207745, 0.688030773114837, 0.6647053506130032, 0.6158065461144082, 0.14125750254083835, 0.22680951343869915, 0.36830439060526277, 0.3633367977456221, 0.9265710413614577, 0.2134371586635151, 0.23869176370368939, 0.14835248658424294, 0.40837190319273897, 0.5833090356178174, 0.5055126147382429, 0.49694487129369036, 0.5148135861274554, 0.13507169319651768, 0.5168772231652801, 0.13616417536918524, 0.7421480797724344, 0.6808011821850137, 0.4997499806520075, 0.5759111874437604, 0.6833942615258868, 0.5868883238716248, 0.6816816286735644, 0.6689135611538677, 0.2515715016623268, 0.5598594908532081, 0.394557141063517, 0.4381755232562774, 0.502818537748974, 0.29066605269665513, 0.6242920651539658, 0.5589960813349979, 0.5331803078177073, 0.39695656767311016, 0.5990595061801601, 0.38356080811168214, 0.219839508019106, 0.7521470067032835, 0.5506024567371532, 0.5916633150197739, 0.3083422731459169, 0.5886808881273145, 0.6271836125240077, 0.6559747854435296, 0.33665180640092085, 0.36836814749586466, 0.28248151229623164, 0.10847702299171091, 0.33062322672100797, 0.21761562992557737, 0.35501197653794103, 0.3513131947355813, 0.39096049993494997, 0.27820854663445016, 0.46907609235393444, 0.45203987866589335, 0.4212292162039135, 0.41158382083069833, 0.48375616129036536, 0.45786739140671373, 0.39314816514381445, 0.47864876036114723, 0.4477953866201375, 0.8080028723693568, 0.7493873462497762, 0.8106108386423683, 0.8212209831045147, 0.8863578077183489, 0.8662268419319622, 0.7822071756119989, 0.8311931844565745, 0.8297066447559968, 0.12565389985834408, 0.12091810619654753, 0.15143257710621583, 0.10470109987888032, 0.14694858668216182, 0.1509345046441244, 0.13099001710310643, 0.12122093913604481, 0.15953159752921497, 0.17388427579381516, 0.14797241405356543, 0.1448094503871794, 0.161226794236497, 0.1752261327136967, 0.1928024528214357, 0.16382074059356766, 0.16661532247952016, 0.5702058680793607, 0.30412687003773076, 0.32681028444662175, 0.5763933638294707, 0.5253398083295742, 0.5502892105549684, 0.3892122884733873, 0.588231503256629, 0.5567713369783874, 0.5067136020004674, 0.3058121028882068, 0.2820313409292535, 0.4221885121762151, 0.46582292635499356, 0.4167519034043974, 0.44992550017774147, 0.47466747057306624, 0.2303540263219368, 0.5264299538116324, 0.22380688898725665, 0.21908908158467577, 0.21192796326089502, 0.21509424619787343, 0.21324271885361756, 0.2159106018046869, 0.23785595266625081, 0.21933786295030477, 0.20733988012417448, 0.24877986795162566, 0.2167474993659424, 0.23601187560731773, 0.21419235992405428, 0.19801480023195062, 0.7909018362670676, 0.5678518351596683, 0.19784488562675362, 0.3999995618349579, 0.18728177548040714, 0.18803679866880962, 0.187843296945719, 0.8980361686645385, 0.9288864371705141, 0.19990572297346443, 0.16743744783008718, 0.9013009311580213, 0.16951192732600373, 0.9339583562653624, 0.16873617057619972, 0.2116889996848058, 0.16343075778226335, 0.20669408733246086, 0.12764028329449828, 0.9227224893292001, 0.21210693822428894, 0.1695612842270131, 0.18234509545772803, 0.1953761657240065, 0.18654542897120596, 0.1816091657741239, 0.18638290724855922, 0.19551920089357777, 0.19062806134152666, 0.1917978074636567, 0.18813292220744793, 0.10715506093263771, 0.08758936280305207, 0.08538938683011998, 0.08910829385948016, 0.09731827106946278, 0.09431302950301301, 0.10819239813862236, 0.0947750340313398, 0.0851190508333437]}, "mutation_prompt": null}
{"id": "5da656b8-a23d-4874-ba67-fbdf71870e4a", "solution": "import numpy as np\n\nclass HybridDEACME:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4, 10 + int(self.dim ** 0.5))\n        self.CR = 0.9\n        self.F = np.random.uniform(0.8, 0.9)  # Stochastic F for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evals = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n        \n        self.fitness = np.array([func(ind) for ind in self.population])\n        self.evals += self.population_size\n        \n        while self.evals < self.budget:\n            f_scale = np.random.uniform(0.5, 1.2) + 0.1 * (np.min(self.fitness) < best_fitness)  # Increased upper bound for f_scale\n            elite = self.population[np.argmin(self.fitness)]\n            diversity = np.mean(np.std(self.population, axis=0))  # Population diversity\n            self.CR = 0.5 + 0.4 * (1 - diversity)  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + f_scale * (b - c) + (self.F / 2) * (elite - self.population[i]), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evals += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            center = np.mean(self.population, axis=0)\n            covariance = np.cov(self.population, rowvar=False) + np.eye(self.dim) * 1e-5\n            new_population = np.random.multivariate_normal(center, covariance, size=self.population_size)\n            new_population = np.clip(new_population, self.lower_bound, self.upper_bound)\n            \n            for j in range(self.population_size):\n                new_fitness = func(new_population[j])\n                self.evals += 1\n                if new_fitness < self.fitness[j]:\n                    self.population[j] = new_population[j]\n                    self.fitness[j] = new_fitness\n                    if new_fitness < best_fitness:\n                        best_solution = new_population[j]\n                        best_fitness = new_fitness\n\n                if self.evals >= self.budget:\n                    break\n\n        return best_solution", "name": "HybridDEACME", "description": "Enhance convergence by dynamically adjusting the scaling factor based on previous best fitness improvements.", "configspace": "", "generation": 99, "fitness": 0.4596599006428864, "feedback": "The algorithm HybridDEACME got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "21b448cd-7387-4799-b900-315d9ce8f671", "metadata": {"aucs": [0.9300735223614562, 0.9260151402113758, 0.9331772861913362, 0.909556374047492, 0.9258246078266325, 0.9301011877221084, 0.919693826080383, 0.915120742118243, 0.9069232914707738, 0.8032284446601949, 0.7690258103929314, 0.790068152716716, 0.7878852977027698, 0.7788494157151912, 0.795582915803646, 0.7983606630809061, 0.7712578027545003, 0.7763562842716697, 0.12723951639970654, 0.1225552666381815, 0.16573139823757432, 0.13016608371297422, 0.1723096728880129, 0.14852532577368494, 0.1416032968307983, 0.1707383768863996, 0.1401507667720352, 0.11959192172100064, 0.12152226365494789, 0.11215530960631914, 0.11437520988843952, 0.11362713334755914, 0.12552509401774148, 0.11405312019484459, 0.1337557556450658, 0.11793394197959284, 0.9485342582553058, 0.9783856648780614, 0.9813688005387856, 0.9521614713601625, 0.9883494637198986, 0.9754241472893435, 0.9825307012649356, 0.9815823323396651, 0.9631230250187475, 0.7284008649787408, 0.7491361340554472, 0.7161758188585283, 0.6228570323641469, 0.6893225499412949, 0.7875048866586168, 0.6797486692226716, 0.6987104008885381, 0.6912614471027463, 0.220048917852942, 0.2296974826409086, 0.25757102932675446, 0.9581826571413906, 0.9383202657501876, 0.946568319579094, 0.24991955353840023, 0.24795497506372322, 0.9563586546676612, 0.5818685816123035, 0.5555998156449794, 0.6238513568391019, 0.6144925327627695, 0.6045398840479166, 0.5288706225872177, 0.436929257659871, 0.3774381344745751, 0.7247410015336728, 0.4921832800167292, 0.6156013680375336, 0.6695046712389034, 0.6168786346167974, 0.7001947206495105, 0.5051151577811931, 0.5808899735954214, 0.6367588386256343, 0.49257060016738674, 0.28098142202883536, 0.45835682585302495, 0.5248856425603031, 0.6358025908722967, 0.4245690321133113, 0.6277638227815718, 0.6510812043198078, 0.6451597978497841, 0.6355920355594027, 0.4950337202148052, 0.22671933213676554, 0.543193709781645, 0.4647430452046769, 0.12221479657145462, 0.23839441316971843, 0.6628433833712953, 0.5253850023650941, 0.4608699642872539, 0.38762452637603106, 0.3207809203870772, 0.4328072791965968, 0.20891425358730864, 0.260167900774796, 0.45662197248956204, 0.3152356954867974, 0.39163104969546225, 0.1893601464924648, 0.4621925289734331, 0.4857104623879068, 0.4161605309491586, 0.43882748588684195, 0.5410502123640379, 0.4947658502145521, 0.4177561269733765, 0.43890075370295123, 0.4748326824813687, 0.8554074395342695, 0.8591369633493962, 0.8479348359085759, 0.8433931203730665, 0.848288489997309, 0.8053533023566214, 0.8656884836595795, 0.748055211749345, 0.8543960561662518, 0.1315517272582385, 0.14292465857918546, 0.10458013643530617, 0.1161571811595391, 0.09975511405967752, 0.1261533068062648, 0.13327909556905615, 0.10917506468839422, 0.14462925005322924, 0.15082357114832923, 0.16109733474862042, 0.138542744729373, 0.1655119297569294, 0.1793035583782535, 0.14523640655617187, 0.16064555016407034, 0.1688099994005312, 0.15178932773562115, 0.5496461429921008, 0.5282345978081535, 0.34839914566726016, 0.49413097377501314, 0.5633843659162332, 0.5320066910270174, 0.2571843442597216, 0.5165540475555452, 0.5495955792187622, 0.45537835237286184, 0.25310117384732034, 0.4680572953449683, 0.2797947700690534, 0.4688184173696489, 0.39070774784936024, 0.31710161198289577, 0.22784162462409885, 0.4328569089540377, 0.2291177668151385, 0.21438557279618575, 0.22625008587993156, 0.23732238668494943, 0.21618952576873585, 0.2095368546961428, 0.2101404486464723, 0.19942116278816047, 0.21157403176681122, 0.8313878683079978, 0.21575648155510352, 0.1952909713532377, 0.732848146878629, 0.24089345425315534, 0.2214376113308606, 0.22793288958014546, 0.6503344114957005, 0.22179736121181692, 0.9427427230562103, 0.8137402252707878, 0.18814449582646964, 0.9166962087332404, 0.8957003678547338, 0.16568111019205845, 0.1666180574073105, 0.16739136899982843, 0.8845519362627061, 0.8618057042515315, 0.8454610293613946, 0.16799638232993963, 0.15480098224992822, 0.21196727400867854, 0.9096270173797526, 0.8638249256812502, 0.21111512674992072, 0.16917142371212135, 0.18389303608918295, 0.19342543714930993, 0.1870403485458353, 0.1954913898428493, 0.2074855491298785, 0.20369867997015056, 0.19322574755761113, 0.1769394621188174, 0.18487108572376554, 0.09343906242365652, 0.11863501371706353, 0.09322190775329076, 0.09488957414443377, 0.09663192164477752, 0.09177314691699923, 0.08129671263072413, 0.09151394048043227, 0.08718118596019286]}, "mutation_prompt": null}
