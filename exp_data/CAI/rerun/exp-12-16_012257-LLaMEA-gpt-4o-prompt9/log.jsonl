{"id": "25b1e6bc-779f-423a-a7d4-1cb577f0e5ed", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "A gradient-free multi-population adaptive differential evolution algorithm leveraging both local and global search strategies for efficient exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.26095968571785094, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6253955283615455, 0.6121485694431124, 0.6199747970140959, 0.618523037725484, 0.6207190505552774, 0.6467080607584235, 0.6731039754124094, 0.6142579760453131, 0.6406716378236997, 0.3034042980262093, 0.39365885672701384, 0.38359196694151687, 0.40505404091116637, 0.37754174524994766, 0.41437649795421694, 0.35133420298575957, 0.37066557506839126, 0.3861352839027118, 0.09428238226346097, 0.10101800572040409, 0.11838528789427838, 0.0798891760134367, 0.09360407850095576, 0.10913253418140612, 0.10596720549226524, 0.10307152379447126, 0.10168658434687428, 0.07948550566224877, 0.09143770793164674, 0.07833067617341771, 0.08288142743476723, 0.07957231841309531, 0.10005229462334098, 0.08642815095903045, 0.09583642459209785, 0.09257695250745168, 0.7291025799424824, 0.8411869784696984, 0.7934101797464383, 0.8939707149679191, 0.7779002435448163, 0.7683786156409972, 0.7012694855367358, 0.7062766283040485, 0.9292497932532895, 0.26525805878990627, 0.2506476570627232, 0.25329709353103813, 0.25147164322200866, 0.21796242880349936, 0.26239823124519246, 0.2530727541883634, 0.29882643963823896, 0.3222469647521933, 0.5095002273129434, 0.5853024642091245, 0.5590430317572641, 0.5946174880003208, 0.6485840650337519, 0.514348655742108, 0.6178228114590884, 0.6620155772967609, 0.5592424887563259, 0.19575690217997477, 0.1567830009800666, 0.15138233955490576, 0.16330631521240435, 0.15313509056867025, 0.17590073006258666, 0.17901201525622457, 0.1788032707011169, 0.17585216444512752, 0.15574179242317332, 0.21479846531302726, 0.19788655699369506, 0.15754197587274688, 0.13512641149404958, 0.18000095972745545, 0.19661733797856862, 0.20894997178707675, 0.1526430630526322, 0.16407668445877754, 0.16370059065567588, 0.14814843142481227, 0.16571066013882196, 0.15176011364047715, 0.151474571026607, 0.1570442255742126, 0.14162299091418484, 0.17710698891253474, 0.27047322376773786, 0.2982177215591132, 0.2600182844253198, 0.3008698176368326, 0.2540807340369865, 0.28606693347951495, 0.30057672453821416, 0.3703140952531181, 0.2671391644504051, 0.05827044031799977, 0.027857050950978568, 0.033864213641984886, 0.07185758573137013, 0.04531137989728884, 0.05868542961737799, 0.06495223322340804, 0.05108755916925167, 0.059486439772049926, 0.16777581967908395, 0.161930131551838, 0.1514672458454588, 0.17350583941691278, 0.18221053261625497, 0.17854231329218107, 0.15291928676019595, 0.19523816441955144, 0.16150996034644882, 0.4939986536825073, 0.5182710432818176, 0.5344506156926108, 0.5046087426700006, 0.5026567568261078, 0.5384882257613341, 0.49785647796390475, 0.49181793328872336, 0.5173616211610648, 0.08470519589670367, 0.0971566375759545, 0.08511253708499811, 0.07526756122151312, 0.09173961978371825, 0.10007089702367977, 0.09845417135260959, 0.08630305397315696, 0.09890174120213191, 0.14807779068912297, 0.125946904590026, 0.14240610668343978, 0.1500217764270534, 0.15153758182605725, 0.13882055215933375, 0.1589822113053193, 0.12368886564357195, 0.12905132435693434, 0.29650215787346534, 0.30137142570318876, 0.32393465195904825, 0.26162182145943824, 0.29454403606974267, 0.3041320936667433, 0.29856802584068487, 0.32796498761947845, 0.3306558439245586, 0.23457474769119357, 0.22380792266416139, 0.22784682525654265, 0.23433020908255098, 0.20416516158602493, 0.23404555355146617, 0.23002376087637655, 0.23419223956054713, 0.22726184528757054, 0.18960087664733916, 0.20329737938798476, 0.18405173666368801, 0.1745490158151295, 0.203667291097548, 0.1819755838098005, 0.19238598487124658, 0.200340591326999, 0.19015958384262222, 0.1856384690982541, 0.18147474368843552, 0.17840113413417036, 0.17541604750152384, 0.1781236925607378, 0.16957779319721245, 0.16776305746216003, 0.18307856899340225, 0.17772229931153383, 0.35569393299387786, 0.1813266561275495, 0.18306357573366583, 0.25783785318879415, 0.4557695332568601, 0.1678995652086489, 0.19341179931660768, 0.1526797709407629, 0.1728052424154921, 0.3831637233492169, 0.21547378868022282, 0.4301910521100195, 0.18148714482365458, 0.1882187112832826, 0.4261948182996316, 0.29880970262773066, 0.14367321848389658, 0.20656587114830083, 0.18226058338144857, 0.1824659096911837, 0.20241472365446422, 0.18046779872236862, 0.18380649040234176, 0.1643123388413884, 0.18846634383105898, 0.18436890743572298, 0.17839142747975534, 0.06854762004905768, 0.08095185459707865, 0.07527391001020567, 0.06591078494512026, 0.07560817701337197, 0.07713493798381554, 0.07639766195629638, 0.06947947438827828, 0.07282686911396086]}, "mutation_prompt": null}
{"id": "f0870e8d-0cb8-49be-b36b-1d71f03784ee", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def adapt_parameters(self, evals):\n        # Dynamically adjust control parameters\n        adapt_rate = evals / self.budget\n        self.F = 0.4 + 0.1 * np.sin(adapt_rate * np.pi)\n        self.CR = 0.9 - 0.5 * adapt_rate\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n                self.adapt_parameters(evals)  # Adapt parameters during evaluation\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced adaptive differential evolution algorithm that adjusts control parameters dynamically based on convergence progress to improve exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": 0.25052743432480656, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "25b1e6bc-779f-423a-a7d4-1cb577f0e5ed", "metadata": {"aucs": [0.6777456898920008, 0.6657795110042852, 0.6567458870897154, 0.6649311068045349, 0.6521774728787633, 0.6402391233079926, 0.669914287139078, 0.6882435415587795, 0.6665213296007542, 0.432344694173769, 0.37172867822967925, 0.4029910909846358, 0.3911533073876563, 0.38807818926473503, 0.3387501793614327, 0.4123456223135168, 0.3996461150364482, 0.39140399800783676, 0.10053839190209568, 0.10162353606016972, 0.11213401945248513, 0.10524378254606981, 0.10695339194607789, 0.11507342514171692, 0.1106970422648641, 0.11389350077772198, 0.10718591968396196, 0.08936078021817451, 0.09438741086259472, 0.10081046445252972, 0.09130753796605495, 0.09762613383633723, 0.09097764717119461, 0.09638679561771601, 0.08959300953393212, 0.10537591207886632, 0.6979499975307735, 0.705110827596318, 0.908068836520701, 0.7868863839433529, 0.8144082261792878, 0.8487146506790688, 0.7975568651425373, 0.8566679109552993, 0.850106967886902, 0.26941348827376865, 0.2560328442169706, 0.2690791176705266, 0.2257391960977021, 0.26988629166929257, 0.24772772727162773, 0.26446977131472327, 0.2833376824885797, 0.27477604084703555, 0.4292144503108182, 0.6004523051526967, 0.6377741389487928, 0.5820585262701342, 0.20652226418182507, 0.6195009426530602, 0.5299616376731515, 0.5907672273276986, 0.381653497668647, 0.1571679267314725, 0.13483578622871029, 0.15513576062711487, 0.16717158580617064, 0.1389809531244497, 0.18308992021019022, 0.1376438625310149, 0.13858068636433962, 0.16534042848371433, 0.13438680305980233, 0.1855958455971557, 0.15487789992205725, 0.13215833609807126, 0.1519023500105282, 0.1954958944606381, 0.15497578750934504, 0.1351242205366483, 0.1473136942239751, 0.04956699250892305, 0.08967372790605221, 0.0913953807124186, 0.05539145251258648, 0.07966685917974992, 0.06327328180384173, 0.05890721375969765, 0.0830472826951304, 0.10928686312206393, 0.1944996946647961, 0.21848662621590842, 0.2332914884793187, 0.18793944924317285, 0.17370815229345116, 0.1716541717082506, 0.16711887441404905, 0.23416725400310712, 0.255282047079436, 0.018666318176287278, 0.016230557458915773, 0.06478118339039063, 0.019969470110836274, 0.015741859323692764, 0.02987423160485958, 0.03450024945797214, 0.023955776080178293, 0.022641307230058527, 0.1520083807222845, 0.14406250380031538, 0.14004454371417963, 0.1571826611443481, 0.1413167469133979, 0.15771673461189528, 0.12387983902816757, 0.12730045089029463, 0.14544862379692236, 0.46849916304983197, 0.5029160445341943, 0.4823951889013456, 0.47138999756783073, 0.4489831076631292, 0.48430332221070005, 0.47876963629402003, 0.4762920228550872, 0.506880083230608, 0.09458860811305436, 0.08617461536225679, 0.08644754801584442, 0.09583162517592259, 0.07935095684106563, 0.0844439823362727, 0.08694625132396283, 0.08672432433708965, 0.07646905548106753, 0.13383756575642258, 0.1449002382486182, 0.15199071110967632, 0.155789560664509, 0.1500866569725856, 0.13307771256303969, 0.14698593027011597, 0.12762919772319514, 0.13194409083092506, 0.32106543923517106, 0.3134068434739855, 0.29224868577609364, 0.2847005951626844, 0.29436827950944244, 0.30625750774141447, 0.3294544482650593, 0.33105229730432717, 0.3407507624125058, 0.22801980216969742, 0.2294690814254604, 0.23721835362348398, 0.22114941895839135, 0.20500644525605372, 0.2231436912033241, 0.23746951051159948, 0.23172269141463786, 0.23146378586555816, 0.20549380195381506, 0.19734831024040822, 0.1719375789560339, 0.19679028904777207, 0.2102452452223076, 0.18004363908966192, 0.19049372880568605, 0.1865975509496931, 0.21036458721060391, 0.19009874120766523, 0.19460661529744905, 0.1816974167112595, 0.19171896225456253, 0.18214891221248786, 0.19145386285210209, 0.18678785668685205, 0.18525012980236322, 0.19611560044863152, 0.5901411615451111, 0.16497674951310548, 0.3472834772572928, 0.1798504613683184, 0.3011150018574098, 0.2972368875503856, 0.1689683131524614, 0.15792219288764386, 0.3682960491797268, 0.30438987140982243, 0.20908956120722966, 0.1844547107910024, 0.25558490087196983, 0.16985153823251387, 0.3803615213312628, 0.3726803181260273, 0.15430241365984187, 0.2049610671672112, 0.17379656726199577, 0.17617028160076265, 0.18689562903425927, 0.17129320337221998, 0.1696226113208772, 0.17961479476696784, 0.16658781194568906, 0.18575343341109596, 0.17966960499685625, 0.0708927772381932, 0.0683662009127205, 0.07839737320303097, 0.0674977764053567, 0.08522085460990658, 0.0720830839582477, 0.07625634933188341, 0.07685871763346563, 0.07147254705391293]}, "mutation_prompt": null}
{"id": "a563236c-ceeb-46bf-acb1-8be4dcf1e65b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F_min, self.F_max = 0.4, 0.9  # Adaptive F range\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def adaptive_F(self):\n        # Adaptive control of F using a linear schedule based on evaluations\n        return self.F_min + (self.F_max - self.F_min) * np.random.rand()\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        F_dynamic = self.adaptive_F()\n        mutant = self.population[r1] + F_dynamic * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def local_exploitation(self, x):\n        # Simple local search for exploiting best solutions\n        perturbation = np.random.normal(0, 0.1, x.shape)\n        return np.clip(x + perturbation, self.lb, self.ub)\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                trial = self.local_exploitation(trial)  # Apply local exploitation\n                self.select(idx, trial, func)\n                evals += 1\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Hybridized differential evolution with adaptive parameter control and local exploitation to improve convergence speed.", "configspace": "", "generation": 2, "fitness": 0.17635886426701394, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "25b1e6bc-779f-423a-a7d4-1cb577f0e5ed", "metadata": {"aucs": [0.3739442837220732, 0.3836447761598807, 0.3641638735616296, 0.3734858347604094, 0.37875913022155017, 0.39665478547418964, 0.40473637853952327, 0.3708673061533053, 0.395629113120041, 0.012888637846600437, 0.007062632685940318, 0.01309196624254838, 0.0015125060122845868, 0.00933631454462125, 0.01612598156714229, 0.023754323634666452, 0.016381864542568514, 0.07792808495700643, 0.07406273146130915, 0.08449442486928349, 0.07592644594293019, 0.0875993624756336, 0.0788605444326742, 0.08172127954579833, 0.08701196595654437, 0.09035259207465896, 0.08659163810201576, 0.07627177530929452, 0.06282415192943702, 0.0670329576427845, 0.06997926643415031, 0.06589492299447464, 0.07258323057073335, 0.07687029615502505, 0.08772426263606758, 0.07039431337240554, 0.8908991981499511, 0.7813743236741657, 0.7516831150774654, 0.807109893658784, 0.8334903035919883, 0.8406608245891525, 0.8025841839769683, 0.8531768135458191, 0.821940464050746, 0.19347149708030242, 0.2113044986795526, 0.196241525066279, 0.18338248876770213, 0.17652518900395775, 0.1995758025647515, 0.19529234713351562, 0.20118492841493407, 0.2028351988517999, 0.2691233198046812, 0.24310134869375843, 0.2672521684754724, 0.26650610438563627, 0.26753056637471884, 0.2755167975807614, 0.2667433745068414, 0.26084824014936037, 0.24563159125659717, 0.11955380135452942, 0.1211450522707701, 0.10479890077270082, 0.12254950585624991, 0.1031163182100836, 0.09947156002220436, 0.1296125210917629, 0.11104549203004122, 0.12815667994096802, 0.10223637826083154, 0.13405412644599546, 0.12024957049062068, 0.10979005853161383, 0.11098834859100826, 0.12077287778246659, 0.10890510837052092, 0.1170832047207816, 0.11723041035042203, 0.034825346379242395, 0.014661657168306697, 0.0034751351756396875, 0.006261107595837867, 0.00015719385295742683, 0.010190182937967585, 9.999999999998899e-05, 0.0001779487699997695, 0.003726203117342064, 0.10810586268218414, 0.06591166595731845, 0.09004477978219383, 0.08238023685270579, 0.07118620875969806, 0.07404966169565885, 0.06420622307117285, 0.08995611568916062, 0.0951477673593718, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06983129675628497, 0.0760365963557117, 0.059155502448583475, 0.07555142598478848, 0.07384436047732124, 0.08674132004902935, 0.0839478041647943, 0.10179289401875646, 0.07502568180302283, 0.34191219130175465, 0.3235327831630638, 0.36926349227822, 0.3604020957918007, 0.3454017081126922, 0.36874358224329873, 0.35484236396592683, 0.3758954618829654, 0.37458250961907, 0.08477082029344163, 0.07435104449501229, 0.07598790345447981, 0.08452479280354364, 0.08204293931400608, 0.083429026492844, 0.08943523701060307, 0.08177410795833417, 0.0743603658932871, 0.1471419648284502, 0.1288510623410879, 0.18435729167123405, 0.15484410481402722, 0.12063120564827823, 0.12268481016174593, 0.13152503343396804, 0.1780472487058571, 0.13412879345359374, 0.24371245159878363, 0.24449280836181264, 0.24570123964241086, 0.24214810701935952, 0.25286009251669883, 0.23953728601238722, 0.24105947874410927, 0.25237693587136123, 0.24671175527695577, 0.16860662956637684, 0.16932620091902884, 0.1779247530388065, 0.17542936109717555, 0.17955896366447632, 0.17208810538641373, 0.19078154190164864, 0.20444387200306324, 0.17533416513268563, 0.1764172705569106, 0.19283713821246473, 0.1869145436846903, 0.17789147141542871, 0.17266259566819897, 0.1732840263020804, 0.1822807588070786, 0.1813950395106786, 0.17354107528727913, 0.17747661241479273, 0.1711284809022089, 0.16660863536973103, 0.17146952937070414, 0.17145864850024428, 0.17469478405350292, 0.17023113755928987, 0.18676057947762448, 0.1661100297159277, 0.30290160557290735, 0.3507247121537458, 0.18002919488723057, 0.20690062696253309, 0.17798984336456547, 0.16300899949415848, 0.17007633424163882, 0.17960332445481275, 0.1913334637766252, 0.1767530457656623, 0.18895612321860888, 0.15763383256707897, 0.179409980858794, 0.2377567255293911, 0.17556781101590746, 0.1373884793940473, 0.20028598339304693, 0.13566032760384128, 0.2036229010169831, 0.1683348974773362, 0.1784178747531494, 0.1891140926139162, 0.1668034227570011, 0.17960488495756521, 0.17251118190057335, 0.1871006028167581, 0.16488875892846377, 0.06912502060091352, 0.05902304160380467, 0.07745795682813206, 0.06964314269692928, 0.06551610609077851, 0.06811477180294767, 0.06379259505975843, 0.06888882798556373, 0.06755398507937749]}, "mutation_prompt": null}
{"id": "357bc2a5-078c-43f7-9141-0480e181ef32", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.initial_F = 0.5\n        self.initial_CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def adjust_parameters(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        self.F = self.initial_F * (1 + diversity)\n        self.CR = self.initial_CR * (1 - diversity)\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        self.adjust_parameters()\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introduced adaptive mutation and crossover strategies, leveraging diversity feedback to enhance convergence speed.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'AdaptiveDifferentialEvolution' object has no attribute 'F'\").", "error": "AttributeError(\"'AdaptiveDifferentialEvolution' object has no attribute 'F'\")", "parent_id": "25b1e6bc-779f-423a-a7d4-1cb577f0e5ed", "metadata": {}, "mutation_prompt": null}
{"id": "ca7f11fb-da0d-457e-9fbc-1dc09c980f13", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F = np.random.uniform(0.4, 0.9)\n        self.CR = np.random.uniform(0.8, 1.0)\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.evaluate_population()\n    \n    def evaluate_population(self):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        best_idx = np.argmin(fitness)\n        self.best_value = fitness[best_idx]\n        self.best_individual = self.population[best_idx]\n        \n    def mutate(self, idx):\n        indices = np.delete(np.arange(self.population_size), idx)\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def adaptive_parameters(self, iteration, max_iterations):\n        self.F = 0.5 + 0.5 * (1 - iteration / max_iterations)\n        self.CR = 0.9 - 0.5 * (iteration / max_iterations)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        iteration = 0\n        max_iterations = self.budget // self.population_size\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                self.adaptive_parameters(iteration, max_iterations)\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            iteration += 1\n        return self.best_individual, self.best_value", "name": "EnhancedDifferentialEvolution", "description": "An enhanced differential evolution algorithm integrating adaptive parameter control and elitism to improve convergence speed and solution quality.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "25b1e6bc-779f-423a-a7d4-1cb577f0e5ed", "metadata": {}, "mutation_prompt": null}
{"id": "7e70c034-3183-4845-b4ff-04d122bde5e5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.init_local_search()\n\n    def init_local_search(self):\n        self.local_search_prob = 0.1  # Probability to perform local search\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < self.local_search_prob:\n            mutant += 0.1 * np.random.normal(size=self.dim)  # Intensification with local search\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def adjust_parameters(self, evals_ratio):\n        self.F = 0.5 + 0.3 * (1 - evals_ratio)  # Adaptive F\n        self.CR = 0.9 - 0.4 * evals_ratio       # Adaptive CR\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            evals_ratio = evals / self.budget\n            self.adjust_parameters(evals_ratio)\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced adaptive differential evolution algorithm incorporating dynamic parameter tuning and local search intensification for accelerated convergence.", "configspace": "", "generation": 5, "fitness": 0.18057363476014157, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "25b1e6bc-779f-423a-a7d4-1cb577f0e5ed", "metadata": {"aucs": [0.4326751585118014, 0.4006052318382871, 0.4191275749205503, 0.46324001427357187, 0.4311779069960301, 0.44704692763676435, 0.4215461620238964, 0.44671064381823966, 0.40994451019208367, 0.18078407569139576, 0.14845480925532573, 0.1727013304015409, 0.14964816349080678, 0.19276140894827254, 0.173302449832493, 0.17036312251805152, 0.1483784221682779, 0.1928014065614886, 0.08423085559960941, 0.08566601623635484, 0.09556809876209771, 0.09342587476395325, 0.06770053622804573, 0.0921562376482572, 0.07459038787811711, 0.08879406268256917, 0.08759636196656173, 0.08203741775510864, 0.07162023068575418, 0.07777985688152711, 0.07038285429748126, 0.07537889599152914, 0.08139925583980623, 0.07867858455317889, 0.06588314514929372, 0.0724036249729123, 0.9373943502306101, 0.8923963760599298, 0.8713502280546137, 0.8860653320218898, 0.9272442404451381, 0.9343262305254976, 0.8819453776994288, 0.8739290047280134, 0.9907191082618333, 0.17395193474944404, 0.1846506305423884, 0.18896576341799454, 0.18997898789143008, 0.1552605329082809, 0.19597555658344723, 0.18515871873438594, 0.1920263342941827, 0.187913825904642, 0.20984756434045204, 0.2377600928389988, 0.2268106395485775, 0.22185471028068138, 0.2198331579654419, 0.193150750187143, 0.24076005434224013, 0.22000829096601193, 0.23452576060936314, 0.10822352158133586, 0.0968909334194088, 0.10024473656724009, 0.0822198133254276, 0.12754259851840832, 0.10112959705844082, 0.11459312257799814, 0.12894514111029554, 0.11197114105866735, 0.09910947024972205, 0.1308209323470303, 0.10790643751581808, 0.079563935927903, 0.09848102478739296, 0.09723002482052545, 0.08615340324432397, 0.0922924129903464, 0.1053900692964862, 0.016764680633840734, 0.0064933919940302065, 9.999999999998899e-05, 0.0011973137725379557, 0.02177701405475474, 0.004475038668049658, 0.007139129521281595, 0.007933487097898095, 0.008562676221247068, 0.08611677701859266, 0.08913171233283557, 0.11860163819802183, 0.06916923304011746, 0.08018244646350958, 0.06623455656797939, 0.1030871941471565, 0.11468333818124832, 0.11047555462098513, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06654565392072198, 0.046096038956830454, 0.05333212725643954, 0.07557056280577035, 0.06428550214267414, 0.07760008451021017, 0.07091993440974131, 0.0667768218379422, 0.09135711285055481, 0.34730752698385436, 0.33720915856450684, 0.35056241155595125, 0.3606871956919907, 0.3645238686329775, 0.36261256405683995, 0.35580395166151735, 0.33668680973279674, 0.3383246360393719, 0.08280282357884605, 0.06826694449507198, 0.08157114447004954, 0.07487397750914593, 0.07495997412328548, 0.07387879953991328, 0.07192493345958284, 0.0710961289131854, 0.07662184538798045, 0.12282552809858993, 0.13195087305587927, 0.16956754264165919, 0.12272315653770183, 0.11842979896680039, 0.13125049372671838, 0.1528465276965688, 0.14453529485353733, 0.13548436014786636, 0.21104426290259648, 0.2232024469888848, 0.2508956671337459, 0.22385676884754535, 0.20112874638661493, 0.2148608089173999, 0.22955457295255488, 0.23152547304544024, 0.2395400942101784, 0.16551726070586226, 0.14592671214509245, 0.16740151041775064, 0.13965221539070083, 0.1545516124456885, 0.154225033676905, 0.15635662866643485, 0.17519193457043314, 0.16248890560091644, 0.1610025887136024, 0.2036299534340812, 0.1814407572294504, 0.16886200805333806, 0.16536017900197753, 0.15749491922561298, 0.1623775689471828, 0.18466370146662925, 0.20071058549309795, 0.156921284031052, 0.1632153992531692, 0.1628582409339473, 0.16421190701475463, 0.172237608417798, 0.17690980141681978, 0.1650064650219336, 0.17163783903017116, 0.16803563411055455, 0.15294409039578494, 0.1423665958329806, 0.16692748276036506, 0.2779469079338539, 0.16113372186854935, 0.1700858050413473, 0.1918169685401323, 0.1976667382641365, 0.16518581031968804, 0.16636001795386712, 0.17715725436382568, 0.15404167473908215, 0.14071824735939387, 0.1500555523787087, 0.1447983783599206, 0.18054337702695178, 0.1995569257146571, 0.19754666643982255, 0.16678960639886975, 0.18002452163956473, 0.1782764420616344, 0.20152026616194996, 0.1810929644739786, 0.17846360071872636, 0.17235282193999724, 0.18486037004987832, 0.1863970738935592, 0.06081758831650719, 0.06919466864784374, 0.06295693952462422, 0.05707902218547023, 0.05632001555464761, 0.05999742408478381, 0.055395133940356, 0.06759964721156808, 0.060506911446612355]}, "mutation_prompt": null}
{"id": "f9b8a5e7-09f5-4fec-b787-5d50e069e19e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.history = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        mutant = self.population[r1] + self.F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, individual, func):\n        step_size = 0.1\n        for _ in range(5):  # Perform a few local search steps\n            candidate = individual + np.random.uniform(-step_size, step_size, self.dim)\n            candidate = np.clip(candidate, self.lb, self.ub)\n            if func(candidate) < func(individual):\n                individual = candidate\n        return individual\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def adaptive_parameters(self):\n        self.F = np.random.uniform(0.4, 0.9)\n        self.CR = np.random.uniform(0.7, 1.0)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            self.adaptive_parameters()  # Adjust parameters adaptively\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)  # Apply local search\n                self.select(idx, trial, func)\n                evals += 1\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "A modified adaptive differential evolution algorithm incorporating adaptive parameter control and a local search mechanism for enhanced convergence speed.", "configspace": "", "generation": 6, "fitness": 0.10719791679860508, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.11.", "error": "", "parent_id": "25b1e6bc-779f-423a-a7d4-1cb577f0e5ed", "metadata": {"aucs": [0.22467636708013738, 0.16026363172257607, 0.20627187296384297, 0.208771366294917, 0.22712605060571545, 0.19956558816401926, 0.23333998506217335, 0.21186716855828347, 0.1860206539987479, 0.0050635432448083995, 0.004316033007887188, 9.999999999998899e-05, 0.0006231249499538682, 0.0010679332370333583, 0.0013309275091595296, 0.004586471345120247, 0.001661757630076366, 0.006382442096196761, 0.05300485309873859, 0.050493398199485506, 0.04368606426273669, 0.06696433232532728, 0.06894531738409115, 0.057810265621826895, 0.06574384472981032, 0.05301687947715694, 0.06198596986492633, 0.04185316215215751, 0.05538669220962311, 0.04409091326684811, 0.04994553463708995, 0.03426572102067871, 0.03699018560073797, 0.042578209996428584, 0.03835192224127981, 0.03562275322899311, 0.4150347123069986, 0.585177314953983, 0.6777758799634184, 0.2344819669252457, 0.4434327080054744, 0.5897114923950604, 0.2625290742999793, 0.3194353338662047, 0.7034103414033293, 0.07405254433241992, 0.05647125596454183, 0.04892488980758314, 0.072690361778318, 0.058778763669268486, 0.08744639342353588, 0.0829761691946882, 0.06666087600736648, 0.09781697501303421, 0.1560479808077334, 0.1250793392298668, 0.1444099264270874, 0.12820796298624249, 0.135322073212225, 0.11777662188719695, 0.1547060272270453, 0.10780846113844766, 0.12158730196907674, 0.012195289130114695, 0.008700427806511812, 0.016988751793299395, 0.020240826386082378, 0.027611807934760146, 0.013966060621314669, 0.049776089382943645, 0.03850057133272189, 0.025238009563197328, 0.047371879923316595, 0.04256545942226786, 0.013636903268599787, 0.0319957355773719, 0.0001053061830520452, 0.04362829521883338, 0.01563500230995052, 0.00846697674660335, 0.010251994842740308, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004047253567915132, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0865430289313468, 0.06179200183878475, 0.07152643690001403, 0.06967142989003716, 0.0327574732023872, 0.03890796473951774, 0.0842743085582508, 0.09418868907941835, 0.06483576826072968, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008477799995126767, 0.002091797011365859, 0.009080759220315482, 0.003742020884902608, 0.005156364280990755, 0.011511773963891248, 0.012472958525612032, 0.00568612947073821, 0.005811539153220635, 0.2314427508964082, 0.17912393113117664, 0.2402923340062938, 0.214138170574244, 0.20522111599698667, 0.1974697946382472, 0.2277069282969194, 0.17281750264125184, 0.1889934627201163, 0.0652600707878781, 0.07256354134533816, 0.048775519793997635, 0.06508502204094635, 0.05036104427885124, 0.05225293687235366, 0.05724189795957102, 0.054809831704618395, 0.047358640214856806, 0.15337005479121257, 0.12260750696408362, 0.1208431045734869, 0.11452789254620399, 0.1605841462249551, 0.12730164343762773, 0.13002223550615366, 0.10772509465855395, 0.13820347078820483, 0.16429796603828017, 0.14936841916796462, 0.17144893575068276, 0.18884776426247485, 0.16653047748166938, 0.16345229282735652, 0.1689409783599244, 0.18528997430067196, 0.17705003642678951, 0.10659845275087498, 0.09188141765512559, 0.12895706597940737, 0.1302074225683355, 0.09188040169829204, 0.11152093866616086, 0.11310842253277864, 0.11843649678615842, 0.11770295187252355, 0.1744914298773308, 0.18755907015735296, 0.16041662890493735, 0.17884334175720484, 0.165056082895084, 0.15848323741586334, 0.18881617071079004, 0.1526767969809365, 0.15096338215595329, 0.13507355075822558, 0.12050430745286644, 0.13593923783613537, 0.120362078917856, 0.1375063675424697, 0.15236272929756178, 0.13845969638785427, 0.10819581542883139, 0.14091190755274074, 0.13764770984745123, 0.136480770855413, 0.16529731014199167, 0.15027840141545334, 0.1223893540559271, 0.12130756931086817, 0.12756575273484994, 0.12634182218636747, 0.12092339818021958, 0.1191876017284973, 0.12130699559791502, 0.13916801848635463, 0.11688089135346513, 0.08605444914522253, 0.08964285455035192, 0.13336648650814387, 0.12256120099641543, 0.11680724151075428, 0.1964113781959269, 0.17720011992195084, 0.19215913090044479, 0.17019813800929318, 0.17670062154174304, 0.17208279652061753, 0.19045245868591998, 0.16703547837766042, 0.19371286233334362, 0.05807924737603842, 0.053639932782892696, 0.05888147563326851, 0.05663885255963508, 0.05559279142466289, 0.06157351151420354, 0.05639475178188513, 0.055554667071541886, 0.05831752281379776]}, "mutation_prompt": null}
{"id": "634fd626-1283-48e5-ac48-ff2569dba598", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5  # New parameter for adaptive F\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1  # Adaptive F\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "A multi-population adaptive differential evolution with an adaptive mutation factor for enhanced convergence.", "configspace": "", "generation": 7, "fitness": 0.26778261172908924, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "25b1e6bc-779f-423a-a7d4-1cb577f0e5ed", "metadata": {"aucs": [0.6468851459759917, 0.5972886005539266, 0.648560977714476, 0.6524536707207848, 0.660354021284816, 0.6951423109019916, 0.615726469354176, 0.6815622961474401, 0.6572925188298431, 0.3296858066124685, 0.4009209786936433, 0.3893112585951396, 0.3905722874416949, 0.39188141690474354, 0.34569545716457173, 0.3612200485011796, 0.37986143346346657, 0.3591120893723333, 0.09174855251144676, 0.09964451683948705, 0.08995281402799737, 0.10982817222403352, 0.10336137810445711, 0.09437990660522233, 0.11067433525840809, 0.0931687325899142, 0.09383419409340199, 0.08005868237514902, 0.08486624457306025, 0.08218258890199104, 0.08929326177857877, 0.09799104876346787, 0.08722329352433411, 0.08367619854945774, 0.08840371958423765, 0.09062069745284829, 0.8443316867760391, 0.8145085886866539, 0.8472755801271198, 0.9058928775586587, 0.8697632310458416, 0.9332481252005598, 0.7652215271094518, 0.8093986781840011, 0.7861980400585966, 0.26736176519643773, 0.2572877935832122, 0.2641553311483815, 0.24363303974553097, 0.24199919841392303, 0.25559286272972115, 0.31500296560158536, 0.25713599931902875, 0.2592842940873554, 0.630610954818698, 0.5506508704503632, 0.5667213543825332, 0.5842032176337266, 0.6742292929784145, 0.6396967763683636, 0.5480896175224201, 0.5496327821788842, 0.546162171337185, 0.1507967135376479, 0.16607951381978547, 0.14636566912241433, 0.16940874627666092, 0.18224546887834625, 0.14636894385021426, 0.1510540682274728, 0.15553677397000631, 0.20544648081115058, 0.15885399196361905, 0.11328010895510521, 0.16771338742722253, 0.1490540085591351, 0.19002986322536686, 0.1738682460573402, 0.20716692079490895, 0.14714353350120368, 0.18501760634792241, 0.1813714441018991, 0.14069371971268252, 0.1458129380563905, 0.1404326745446124, 0.18265566272379297, 0.191975827874314, 0.15725896432130104, 0.17498473619276977, 0.1400661164715482, 0.30118331306999524, 0.3287089862453091, 0.31649311388615964, 0.27361893080178, 0.3056687010013591, 0.21247441519471422, 0.2717881201679213, 0.2804056895713245, 0.2968606566011648, 0.04624554275253645, 0.07944263718050648, 0.05628466948590771, 0.07945238108667185, 0.052865561793875915, 0.06447277179851696, 0.04605127676917686, 0.06694888276689759, 0.041478714299400976, 0.15396619053451066, 0.1678567067854998, 0.1842265416031219, 0.1642765858220373, 0.1783745183483737, 0.1938527889446724, 0.16911795942630614, 0.16054645930211553, 0.17530254202729556, 0.5159975544643229, 0.49952784966012653, 0.5074194385725906, 0.4760530911414147, 0.5284778672550955, 0.5117666166901335, 0.5169413846491804, 0.5125648435613852, 0.5227303616383063, 0.08822743743387274, 0.08382109875746369, 0.07908662629910501, 0.07917209978971784, 0.08545451097492329, 0.08741126632997076, 0.10349737019931449, 0.08375918858480857, 0.08003377539484935, 0.13104905985361215, 0.1540883331846291, 0.13699585634452882, 0.12807310721528664, 0.14715769730056383, 0.1269692289784422, 0.1327247361748881, 0.12680560146998854, 0.12090822291216141, 0.29227029096714985, 0.31029588186086643, 0.3012368128080035, 0.27622317144777575, 0.2753104138545933, 0.2969243869227932, 0.3022833646966603, 0.3053831644120033, 0.3402845411323929, 0.21197717889028977, 0.22599064686904635, 0.2445761074727727, 0.21708009074675438, 0.2205640214317386, 0.23505640978761755, 0.22141202466811094, 0.24426739445287127, 0.24265538801112263, 0.2148972202110183, 0.17749004116219091, 0.1882377145840063, 0.21048843732707634, 0.19303216456745964, 0.1887765706449407, 0.1830135447879606, 0.16909027141117638, 0.1732296068853717, 0.17598578674407217, 0.18319271434947293, 0.17727999911573245, 0.17047118635091052, 0.1818856464145805, 0.18141516286062154, 0.18922209918966937, 0.17551080201113622, 0.18192511800000577, 0.3947489637057372, 0.15527383445346188, 0.1743555180566687, 0.5781267325587836, 0.5231615297362728, 0.3810409377471544, 0.17197633346731545, 0.17320400841813155, 0.4519934944537475, 0.4483206506592289, 0.5194622325727171, 0.20291251158170776, 0.15260160809955992, 0.20862852262455156, 0.19174342728568128, 0.2756766846758404, 0.49403298228113657, 0.207823251557127, 0.17929187413520886, 0.18899097445096336, 0.18232421406538935, 0.19806382714402904, 0.1741423673903899, 0.18431991280031512, 0.18886615859118605, 0.1820203830065269, 0.18283027470483426, 0.06283130076266896, 0.0807228776989134, 0.06878560099367403, 0.07355418694985927, 0.07068398373041396, 0.07293714748676572, 0.06822095683914009, 0.0740928929156135, 0.06726183917705808]}, "mutation_prompt": null}
{"id": "1cc05e13-fe7d-4d9d-9a80-edaef2132e74", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.learning_rate = 0.1  # New parameter for adaptive learning\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + np.random.normal(0, self.learning_rate)  # Adaptive F with normal noise\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        adaptive_CR = 0.8 + np.random.normal(0, self.learning_rate)  # Self-adaptive CR\n        adaptive_CR = np.clip(adaptive_CR, 0, 1)\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "A multi-population adaptive differential evolution with self-adaptive mutation and crossover strategies for robust performance.", "configspace": "", "generation": 8, "fitness": 0.2414201648005605, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "634fd626-1283-48e5-ac48-ff2569dba598", "metadata": {"aucs": [0.6288565459257032, 0.6103373969435966, 0.6029907903968434, 0.6531052270650448, 0.6528514746882355, 0.6113391051935435, 0.61728078079115, 0.6149558933358024, 0.6168906633247362, 0.317793297648719, 0.3740553811055134, 0.3462016636984143, 0.3949133559877813, 0.3208812753090762, 0.33339710315646176, 0.38560381686914535, 0.3595703492795995, 0.36559479658113303, 0.1072429546698026, 0.10578552354192539, 0.10681068461915089, 0.101466458187354, 0.09813023901413631, 0.09822187966959095, 0.11314185518188147, 0.1057138098526168, 0.10249780701356392, 0.08442138994008563, 0.09306182136951247, 0.09115466071683676, 0.09562009238585378, 0.08518285976996809, 0.08886361521759101, 0.09140158265135545, 0.09741559796577148, 0.09364393455248776, 0.8955662982182288, 0.8870470669246108, 0.8393973757064996, 0.8735458890957071, 0.9325946698611316, 0.9086954727415625, 0.8331170141630634, 0.9020482952331382, 0.9682021922646417, 0.25388196169204125, 0.23207285562379565, 0.24855260245590993, 0.25676274669785293, 0.24593640140665662, 0.2698796328274087, 0.2557122162257581, 0.2922514007423922, 0.23801761712272795, 0.46723960558727906, 0.5236265213720053, 0.519092160992177, 0.5061504599146073, 0.470731732790295, 0.4815295260931003, 0.4964767431657249, 0.4219263069315894, 0.4873274135827498, 0.15213644947580507, 0.13323541564149455, 0.14790517724525687, 0.14613302469695078, 0.153176117474909, 0.175276930558662, 0.1291559242463578, 0.13796121806119677, 0.1323722499932043, 0.13267128954688345, 0.1713250598005801, 0.10645622880741301, 0.14859035882896332, 0.14322152953759637, 0.14728791121661466, 0.17914934765735036, 0.15341932793762425, 0.14344101789019292, 0.10751184041950201, 0.050246836473507805, 0.07210190977307196, 0.048314329706651726, 0.06678676634748504, 0.06608825626224002, 0.07179068177619996, 0.0386007359776811, 0.060906393546587556, 0.15352743601147145, 0.1746710751515761, 0.16225782100516095, 0.21668395639535487, 0.1676484986976089, 0.2013067204805601, 0.19690937582771662, 0.2136428880636131, 0.19536208812042044, 0.023829188472083818, 0.006356393141520478, 0.04338769744157367, 0.042840598933036156, 0.024602187229436967, 0.013758662464487648, 0.025320392939646608, 0.02683728735873847, 0.03488786532508947, 0.12957096008565772, 0.1264838220063138, 0.1381148806546345, 0.1434785659417106, 0.11987027831028185, 0.12476860593353545, 0.11531012985164857, 0.11004777078381356, 0.1255335380633591, 0.48467757545715273, 0.47389376764127156, 0.49240665594276845, 0.47184285018475003, 0.4456604390339993, 0.47818570486063494, 0.4676018118250356, 0.4526923448759692, 0.48077659708501597, 0.07698470482065078, 0.08319787650247412, 0.08856675846351336, 0.07715169113058074, 0.08486094068423167, 0.08214392499447298, 0.0782366675591567, 0.08409977363280763, 0.08534921252086802, 0.11905386178784738, 0.12855266258798714, 0.13373177054625085, 0.12321560656053021, 0.13312562054990174, 0.12131377634990803, 0.1353769313849087, 0.14017434517316196, 0.13020585519576977, 0.28421488955277596, 0.2709486182773426, 0.2948955738581355, 0.2684760927751134, 0.287199924857397, 0.26154044266168053, 0.30344353378529143, 0.30808705955670457, 0.3028581754833928, 0.19883871410770626, 0.1954003735263513, 0.2132075021827623, 0.2207746147403793, 0.18834812102310483, 0.21084258022483748, 0.2049512839964276, 0.22377552025855207, 0.21841238950579323, 0.1799201917401111, 0.18266755652614508, 0.17603616843640935, 0.20283473949469777, 0.19059961536565173, 0.17941637730122018, 0.1852318812570508, 0.20393615641634055, 0.17502988752618787, 0.17696545886418846, 0.1742498474012817, 0.17785291134371983, 0.17507062358298442, 0.18889556799418405, 0.1721477733420257, 0.18676885535993604, 0.17779625669731502, 0.1782943838989307, 0.3393090562997878, 0.2651289923375757, 0.24998835667819108, 0.31465342411889463, 0.38395788246862206, 0.39165766273061264, 0.16963410411199786, 0.1743682369637758, 0.18792970860585745, 0.19625100168970122, 0.3057928008932618, 0.19356543476741328, 0.19379931530249817, 0.14449758682698266, 0.19371435442301477, 0.3181751598032797, 0.19483991537479928, 0.20447558787791498, 0.190245523986454, 0.18387766326158794, 0.18110131271178298, 0.18487328787719048, 0.16398546151534743, 0.18287633484725851, 0.18282473018264922, 0.17413720568845614, 0.17902003257678645, 0.07821186098485955, 0.07447727690468364, 0.07603069769256054, 0.07427158155079783, 0.06913433003939551, 0.073591178778177, 0.07337613906378315, 0.06903066875877661, 0.07489346230991634]}, "mutation_prompt": null}
{"id": "e5c8ce58-9a55-4259-b95b-3ff82cc519e9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5  # New parameter for adaptive F\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1  # Adaptive F\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def adaptive_crossover_rate(self):\n        diversity = np.mean(np.std(self.population, axis=0))\n        return max(0.3, min(1.0, 1.0 - diversity))  # Adaptive CR based on diversity\n    \n    def crossover(self, target, mutant):\n        self.CR = self.adaptive_crossover_rate()  # Update CR dynamically\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introducing adaptive crossover rate adjustment based on population diversity to improve convergence speed.", "configspace": "", "generation": 9, "fitness": 0.1983900425182716, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "634fd626-1283-48e5-ac48-ff2569dba598", "metadata": {"aucs": [0.6012119577854327, 0.5959884597921677, 0.5919457688278943, 0.5664733610629961, 0.6216665784324483, 0.603652336049564, 0.6200564678335727, 0.6139416022965982, 0.575658620645429, 0.28612707884712996, 0.22734977011521829, 0.26086514471781297, 0.3199416263774174, 0.2726029323515994, 0.279553045887859, 0.2619087339500994, 0.2929275866260136, 0.29152094774469994, 0.12654581478342353, 0.13460828636179833, 0.14011884397929475, 0.17925298528119926, 0.1312923115867397, 0.1265623797803357, 0.1369948459767153, 0.12169920886956276, 0.1314712035861243, 0.11286879336893285, 0.11312169757331592, 0.10702133646429424, 0.11221705939862636, 0.11039735433718068, 0.11811539053955655, 0.11450987507505428, 0.1192705907915701, 0.10236876128866856, 0.8888998922765451, 0.9220901150601788, 0.9055657700694367, 0.8586057615517323, 0.9000549729850844, 0.8802412421816583, 0.9144083296438416, 0.897772437367205, 0.8702071158654422, 0.1443203158538796, 0.1285012848394228, 0.14879427459537797, 0.1289387958196757, 0.10552128846002162, 0.17023074085972434, 0.15306230767147444, 0.13916108107723324, 0.16092455442395093, 0.20282152717876145, 0.18031460766327168, 0.1603133542866777, 0.22483504208278693, 0.1762787811376606, 0.22348999508635292, 0.1670882047954123, 0.1997612756928966, 0.19462886017996983, 0.12344737145770068, 0.11421640530806454, 0.10362802503648838, 0.10620167431562022, 0.12093001499760836, 0.09853456620482393, 0.10530774950740229, 0.12310149766107492, 0.11585922948285843, 0.11835178225287324, 0.07632455610447852, 0.08492662135169904, 0.11501665494107527, 0.09698963950579487, 0.11756639538314739, 0.10142232365126058, 0.0939397514274517, 0.12673770841442744, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06804041270917094, 0.056588855686155126, 0.04076931182865373, 0.035112560252688496, 0.058079311270720746, 0.07048327182640945, 0.06269579149393989, 0.05089320368705552, 0.07020818921155936, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052654937285008585, 0.04061247219951236, 0.03951693375580834, 0.05918132047619551, 0.04914748516303191, 0.07416480130273195, 0.053895740428243744, 0.05311140113671209, 0.06686553849138177, 0.4619952078846564, 0.4464574956895394, 0.4919802510755542, 0.49265703580965614, 0.4488850520152058, 0.4425420491687001, 0.4425699466036359, 0.4388394845935455, 0.4518051266304517, 0.10073265384739005, 0.10074252139070139, 0.08216590279023206, 0.0720353927179147, 0.07237445330655623, 0.06801970038190341, 0.0820143010799026, 0.07451380488124981, 0.08084162155556096, 0.1263183025032084, 0.1151872374734112, 0.1634605095388426, 0.12599666667480958, 0.16832417916859244, 0.14641648697104714, 0.14861320685094326, 0.13187382374534284, 0.14167407969156065, 0.19798066197886677, 0.21045266075856872, 0.20150525063196834, 0.2042519802054925, 0.20808595594576695, 0.21575210281663526, 0.24723552833878715, 0.22363970661234966, 0.21285954145697095, 0.15698017686998178, 0.13938777622422693, 0.142652855152142, 0.1354916571617929, 0.13550236247251357, 0.13748964061798508, 0.15145178562588302, 0.15996253484342438, 0.15290076259501562, 0.19173415498752555, 0.18382869776156963, 0.1774441219505144, 0.18120060819628547, 0.1778510836480529, 0.1934704188418116, 0.1774449752874756, 0.18339502060071322, 0.2294945358960594, 0.17967576167352617, 0.19958979609330108, 0.18710746142294443, 0.18733647448347002, 0.18539996515784474, 0.18925864965772332, 0.19250319510756986, 0.18188577707539666, 0.19426609700192776, 0.16645748286166528, 0.16793387446384933, 0.18341759855947137, 0.2707335375338723, 0.2535220682087228, 0.1950661224511604, 0.2214702615877575, 0.37105935747787266, 0.36017816656180857, 0.22263038740001717, 0.17437989493955552, 0.18740769220702969, 0.1710234058472777, 0.14964828011720144, 0.2128539104530549, 0.14812862682525973, 0.13558508796731006, 0.1974945851260429, 0.17338185192341604, 0.18101766390047558, 0.18003556571681345, 0.18651967030151062, 0.17320700264136135, 0.17668029492537174, 0.18548489160402026, 0.17385485157276204, 0.1925130518166448, 0.06793084005510042, 0.05742449900019131, 0.06462484087496145, 0.0633276480161683, 0.057615503117592226, 0.06091635624503611, 0.07993626149022948, 0.06178687387798787, 0.06651075478505375]}, "mutation_prompt": null}
{"id": "02f22eab-dc5f-48e4-8d4e-61a2cf32856c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5  # New parameter for adaptive F\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def levy_flight(self, idx):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return self.population[idx] + 0.01 * step * (self.population[idx] - self.best_individual)\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1  # Adaptive F\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        levy_component = self.levy_flight(idx)\n        combined_mutant = mutant + levy_component  # Levy flight-inspired mutation\n        return np.clip(combined_mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introduced Levy flight-inspired mutation to enhance exploration capabilities and convergence speed in the differential evolution algorithm.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'float' and 'NoneType'\")", "parent_id": "634fd626-1283-48e5-ac48-ff2569dba598", "metadata": {}, "mutation_prompt": null}
{"id": "068e6446-d398-45b7-a9ea-74fcc5323dba", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced differential evolution with population size adaptation and mutation factor tuning for faster convergence.", "configspace": "", "generation": 11, "fitness": 0.32182619882609803, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "634fd626-1283-48e5-ac48-ff2569dba598", "metadata": {"aucs": [0.799871650802349, 0.8323787170514377, 0.8515001182929318, 0.8326381895880417, 0.8606324241139697, 0.8163957979845385, 0.8206384570859572, 0.8520970834621805, 0.8640174373959196, 0.7818410572352834, 0.7383345845790104, 0.6886672226578288, 0.7119919278987763, 0.17547863230619354, 0.7301484622368388, 0.7181161036647232, 0.703462646471789, 9.999999999998899e-05, 0.12175079764625041, 0.13273940565494735, 0.12698888402089614, 0.1212159924889018, 0.1758550658469168, 0.16319188665548046, 0.12800434528877835, 0.12409944345196378, 0.12168389253045608, 0.11365080148299489, 0.10187735883805582, 0.11498120471566176, 0.14803431943606116, 0.13134056454298682, 0.08650004312923887, 0.11391825549091772, 0.10828128595984676, 0.10244237238537424, 0.8901228887741124, 0.9044140646344532, 0.9398813156020943, 0.9709076459517898, 0.8165120303249505, 0.9089014027517887, 0.8951279839763354, 0.9035611251155462, 0.8677327028709035, 0.19794945661898067, 0.4752289732509034, 0.5210354599537435, 0.29065409204360526, 0.22170248861205977, 0.37277191911108254, 0.17129839777680922, 0.19679879236692865, 0.38343309962436645, 0.220302554911599, 0.6557203596394798, 0.6330415878009334, 0.7004358796591095, 0.6274296301326105, 0.8670673406140892, 0.625000037042154, 0.6251440279417959, 0.3930314572193476, 0.1222310019406041, 0.15808683191476247, 0.36566557905547126, 0.16424677986784242, 0.27100533228786894, 0.13322419875590097, 0.16104266629587705, 0.21330986204894675, 0.27168859635938303, 0.16714850052454, 0.14352059875069811, 0.13071993472788257, 0.2071504560452786, 0.2106356802329734, 0.3658527587617365, 0.38931495507375125, 0.32615279069636993, 0.2213628495798835, 9.999999999998899e-05, 0.21348639753080212, 0.2749341478291931, 0.2311601656717871, 0.17528187140191698, 0.022327373180802135, 0.2655924703825119, 9.999999999998899e-05, 0.11303634091992498, 0.5224258113557512, 0.3793688428655575, 0.2988927627457387, 0.39629137179154506, 0.4175107717100307, 0.06544044781248026, 0.37477491973872423, 0.2900160185127729, 0.10443306652296558, 0.09321171741336132, 0.23185533010680315, 0.235035306433093, 0.11244475239150598, 0.20067646204435874, 0.3798474082675146, 0.21931047033421203, 0.15194720766756475, 0.10697677746378098, 0.19595785167940927, 0.23333892883500063, 0.21751145774637626, 0.2676657404414208, 0.32004951975519924, 0.06406842872171814, 0.18674111164748064, 0.25411719136211386, 0.28858738940373263, 0.6801215356060908, 0.7934822525045121, 0.7512064730187251, 0.5309355704194726, 0.6262198997247092, 0.5126215203364555, 0.6581837523392522, 0.6201386864422704, 0.7810431626218913, 0.10119493686824843, 0.09457411458134557, 0.11937569835702433, 0.09572350575585864, 0.09269473617966573, 0.08069499593883389, 0.10313947809509794, 0.0949951785739751, 0.09986085800628475, 0.1370241139335665, 0.16794780403711307, 0.14274904015823375, 0.1327949355237713, 0.1833770988195843, 0.12868716616258902, 0.14275814245799134, 0.21785103169635334, 0.17452470240175044, 0.3661489689825592, 0.4153088143942911, 0.36464737765425215, 0.4018758944606471, 0.3467183163644352, 0.44797350036317773, 0.37644431122684185, 0.412562931574161, 0.4069824818769716, 0.2599699654343751, 0.2829307182170002, 0.2006102590411628, 0.2835801318909211, 0.26445648532597665, 0.2582241933791397, 0.31712083602397656, 0.27741995215255355, 0.28278426923652, 0.17077803641621125, 0.178255616035359, 0.15873153421357378, 0.19167598283674347, 0.18797936573366636, 0.1660701663365286, 0.21447613050150371, 0.17645407757243314, 0.17884188448047567, 0.2006215466955379, 0.18781821510611252, 0.21507067874578, 0.1976677958727514, 0.18005720965648564, 0.28115609995572144, 0.25190286242420057, 0.182955280282183, 0.17864861906683727, 0.6554202775016656, 0.625187174842009, 0.15201022507432194, 0.7120808356073726, 0.8044130159278764, 0.18541761400300594, 0.14671535127281332, 0.20112164055598192, 0.1713967324610176, 0.7783681508483873, 0.20541391120104546, 0.15284005256791366, 0.18848882956370516, 0.5026550372995537, 0.20133935574671247, 0.18058657157816072, 0.20867159262529222, 0.16567947326474264, 0.18825937720294228, 0.17424644438087178, 0.19067090713428725, 0.18228195806180625, 0.17787396642140285, 0.1684388147055783, 0.1777994874291331, 0.1674384243516268, 0.19423046939311717, 0.07105472835184412, 0.07225293584523518, 0.08598663571234078, 0.08299934341549176, 0.09010518045934368, 0.07259946135661344, 0.07992429360724984, 0.08240132193379746, 0.07230010331917924]}, "mutation_prompt": null}
{"id": "f31325ef-0bd8-4946-8212-2d8daeecff57", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        pop_diversity = np.std(self.population)  # Added line\n        adaptive_CR = min(1.0, max(0.1, self.CR * (1 + (pop_diversity / 10))))  # Adjust crossover rate\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover rate adjustment based on population diversity to enhance convergence.", "configspace": "", "generation": 12, "fitness": 0.1895564962470574, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "068e6446-d398-45b7-a9ea-74fcc5323dba", "metadata": {"aucs": [0.27299174438082985, 0.3737122460964827, 0.3324171491215179, 0.2227450734663875, 0.24564880066689976, 0.24463128230724418, 0.19619223468759528, 0.2974839641271274, 0.23793823225333555, 0.03623222294063688, 0.04243010435384509, 9.999999999998899e-05, 9.999999999998899e-05, 0.09657298444986284, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003303282044796796, 0.10023428178713878, 0.09894039214323946, 0.12039569774315229, 0.12816953338975068, 0.15171029959259763, 0.10326132381793629, 0.07900068921869663, 0.10694494443049174, 0.13899649562657979, 0.07987884838991244, 0.1176186711972379, 0.06383472743349938, 0.1181601228193595, 0.0889133161363338, 0.0721141060940097, 0.09332933775135044, 0.0800669441280426, 0.044618250172091756, 0.9544462793086016, 0.05608034047811927, 0.07979645566244276, 0.08970965487620941, 0.1197646045838564, 0.09589068162418002, 0.14752780854214942, 0.10958202276238693, 0.10086269503543221, 0.08766248150544675, 0.058036463498041146, 0.31873405912038266, 0.11160261320319864, 0.17419990513470163, 0.042894154603118295, 0.19462059744564641, 0.15892029044547284, 0.053680046227054135, 0.8258551615395073, 0.6658807140333719, 0.13606890274741923, 0.23282764522629995, 0.267521155817923, 0.8657986733822894, 0.8966239479367549, 0.3554162198621238, 0.9095454943495336, 9.999999999998899e-05, 0.12796319922820798, 0.1990161173733226, 0.010825470405144033, 0.0957672125847846, 0.15314104487826352, 0.06992426432696497, 0.16807036353858407, 0.23536222288449193, 0.13757756911483432, 0.17713112662530894, 0.13058026838713344, 0.21835234332749276, 0.1765032199710702, 0.1330211351020325, 0.1153911603430764, 0.3548479761366111, 0.1291373407044044, 9.999999999998899e-05, 0.0736522659322496, 0.008604604789538617, 0.21902082072827234, 9.999999999998899e-05, 0.15046076315918377, 0.11248669066777217, 0.629413578703368, 9.999999999998899e-05, 0.17822047839262434, 0.0938766095259913, 0.1556634599453922, 0.06862697263411699, 0.09226699412339445, 0.02887347281860586, 0.17151458599136515, 0.0835280135243529, 0.12600279247781376, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2393444009774316, 0.10726340165452763, 0.07265987168409571, 0.10197002006089206, 0.002004550900420732, 0.0275052099965144, 9.999999999998899e-05, 0.025585190726237328, 9.999999999998899e-05, 0.15755621955310561, 0.067703226904688, 0.10032209705614148, 0.39436644879191163, 0.7470007821529687, 0.3690809456402989, 0.2677278195919043, 0.2178268591996646, 0.14070715485237761, 0.626822133893649, 0.21909964403469562, 0.28282919095340964, 0.04209084364984139, 0.05256472215076502, 0.08533678861341054, 0.16076777877005333, 0.12442044256010776, 0.23546345707557492, 0.10695632914428643, 0.11849533064121953, 0.10406223497087341, 0.16609963132569971, 0.20149851046999068, 0.1824039119794445, 0.13826555858065293, 0.42492229385793856, 0.13274526696402955, 0.2157391226655173, 0.20753996130106944, 0.14590533528250982, 0.2798227323488386, 0.35199632880648246, 0.22696792196559512, 0.3774830728661964, 0.295012288066992, 0.41690582756972616, 0.28823607899959347, 0.4112190185729043, 0.2493198857098593, 0.19435395170469105, 0.3371069503419545, 0.23922933140305958, 0.21109566370797195, 0.25828514256472257, 0.21656849628972408, 0.16372195739282325, 0.25279320176559217, 0.21142066591322473, 0.22168106660436737, 0.22240245171553163, 0.17435433900910735, 0.2022135950454279, 0.20343457906713147, 0.20306814737509404, 0.19201553742117772, 0.18081971978245026, 0.16814976837616236, 0.1857617677061637, 0.20784308666280904, 0.19208811981855234, 0.23139069173204718, 0.20656077876607892, 0.23072506396885917, 0.2118445738820256, 0.18677257986745022, 0.1882170750533334, 0.9047348796715131, 0.10879085422299473, 0.1659074721458872, 0.16769834876644196, 0.18743553157941073, 0.17635842508816546, 0.541611118108678, 0.7199134014511984, 0.16657683706902682, 0.15340414699369087, 0.16924651201676566, 0.12017473949150703, 0.7210117182057814, 0.20399501485613458, 0.7853868753618742, 0.20439781824496228, 0.10277328969291388, 0.16724216417762838, 0.1644876473286334, 0.19726581114030262, 0.17663288803184607, 0.18184328692237994, 0.17265859660462468, 0.1709116836213339, 0.1727310120220874, 0.17417733329438345, 0.1660087513257157, 0.054250335583294285, 0.07193647780186707, 0.08173473543969689, 0.07456484843631828, 0.08021994432558643, 0.0780034836355109, 0.06809715360205826, 0.08054322894146337, 0.08338216762566208]}, "mutation_prompt": null}
{"id": "848c75f8-67f8-4000-bae6-56b7ce6d1348", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.92  # Slight increase in crossover rate\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "AdaptiveDifferentialEvolution with slight increase in crossover rate to enhance exploration.", "configspace": "", "generation": 13, "fitness": 0.31345192671794364, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "068e6446-d398-45b7-a9ea-74fcc5323dba", "metadata": {"aucs": [0.8334164304078597, 0.7774182726412764, 0.8629720110044112, 0.785486911413265, 0.8552803337654207, 0.6556330777041144, 0.830178879759026, 0.8088154745052922, 0.8164414392833422, 0.7387110418915583, 0.04242418449175367, 0.7123629262404254, 0.6850391169003825, 0.7523443937085565, 0.6415637787901711, 0.4099549133903244, 0.4584042370359669, 0.3475888589268388, 0.09023468419571512, 0.12193204352540454, 0.09912029890001628, 0.14843271993028628, 0.12039071726132311, 0.11316613861649671, 0.13211896078444585, 0.13558120809017105, 0.14204980431561232, 0.10858647130249777, 0.10863971122345661, 0.12207305357531006, 0.11555660258885814, 0.13164875647876484, 0.0807176559992615, 0.10902964143275973, 0.12466726593324406, 0.09809363434478213, 0.9094276080848853, 0.8812943883657649, 0.7256807640940138, 0.9148584475687812, 0.6848396980763124, 0.9165250185811271, 0.8947788317649461, 0.9208538662125147, 0.8823255841448093, 0.11126365170278973, 0.4650110930410052, 0.17670050023898443, 0.36270952252393274, 0.39194476143401324, 0.23252556723769213, 0.2858164232850222, 0.3126365859136544, 0.12022973309733642, 0.3836003486296031, 0.7734450534813846, 0.4801165663502933, 0.7483794970524487, 0.8473976533729355, 0.2106898669581535, 0.7490412460749947, 0.23450938419432832, 0.3719492036832258, 0.12981304188486031, 0.16061777345543016, 0.20118561900168574, 0.22561538883514853, 0.5370835483408479, 0.3835499273549693, 0.1280355730564421, 0.26100935668850356, 0.16740632056038318, 0.14844568239492184, 0.2714018433574795, 0.1310699143282138, 0.32996598509506136, 0.1436946146953847, 0.2927448294307463, 0.15718150239799267, 0.13653466566582262, 0.21643150794878097, 0.3568349522224812, 0.3508508345439115, 0.007545139369664722, 0.40884324896927227, 0.28119576021744697, 0.2728479783061739, 0.2127239122444906, 0.11231976908566943, 0.29442512940375276, 0.3842954200225476, 0.11035326088723851, 0.1358407092836602, 0.1315945019169179, 0.06554958779586306, 0.39592234001344995, 0.39820697486166723, 0.5524291373479879, 0.11746886248476862, 0.07920680641277289, 0.1343743172746994, 0.15020732333077047, 0.08280027713202653, 0.07602893372314079, 0.36075607812405985, 0.12514874520987795, 0.13629065326063117, 0.09500301413090562, 0.26826607606473907, 0.366813206589261, 0.2600065246770529, 0.18558747893447303, 0.23878138871056576, 0.3337377121616636, 0.311410585701707, 0.27363765389425876, 0.3256278906285064, 0.7045676530105176, 0.5832503490124419, 0.7027966845222189, 0.718938324848462, 0.43691085323727474, 0.6081617822666656, 0.6847514278070216, 0.7111527331011205, 0.6085958191601042, 0.1012648082570311, 0.08182608929433177, 0.09924543329174307, 0.08964376184046774, 0.0905870338215311, 0.108405874332685, 0.11606463027499958, 0.11170272046780738, 0.14446846525439327, 0.1364655750079311, 0.14023326242052736, 0.13571176681866803, 0.14831971063596738, 0.13679475559429688, 0.16466580039081524, 0.1582061856572975, 0.14298434090033318, 0.16259472583060064, 0.4002781909804013, 0.435814400725525, 0.34141721352546384, 0.4109218290612515, 0.4455560264131523, 0.3235087838171349, 0.3197168475776888, 0.42177484950923083, 0.2996631270370105, 0.298489140649568, 0.27951073658134196, 0.20853376465290718, 0.3492131297828528, 0.25338953335993497, 0.3187836693442966, 0.29057979345046425, 0.3010246446497047, 0.3087509674796559, 0.20029902592618587, 0.195096575957168, 0.18387201692253863, 0.17955144203835627, 0.18733836733792164, 0.18188822069939736, 0.18196733373493656, 0.18409864164584255, 0.1857295168887344, 0.2671694674727101, 0.2005188740973668, 0.24707686285091646, 0.1942644392054219, 0.18159663114565738, 0.20153443321723719, 0.20787507795795823, 0.29834033464790977, 0.20313936075294436, 0.5801927748459041, 0.6049524164888141, 0.15179467225949372, 0.6778939742498238, 0.18715929818137134, 0.17838429841862946, 0.15651287564661254, 0.7322654375966349, 0.16137476873044088, 0.7431046633398932, 0.20921144903900868, 0.20232734569262534, 0.2039308314486108, 0.209611786410821, 0.7344841604193768, 0.1654017410075156, 0.15383676349526088, 0.16090322827368964, 0.16769000236116605, 0.17767497800737053, 0.18398117839418138, 0.16779472297970166, 0.1716835331027069, 0.17274956089877302, 0.17205512326038186, 0.1749946915311612, 0.20483875360511228, 0.06363297561916059, 0.06984315908263705, 0.07419081907145442, 0.07991752018566256, 0.07723791564435634, 0.0710544560813674, 0.07221794340642995, 0.0762701180982569, 0.07850660109330077]}, "mutation_prompt": null}
{"id": "ab55850d-c992-4d11-b824-2a2aec0e8faf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.CR = max(0.1, self.CR - 0.1)  # New: Dynamic crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Crossover Control to improve exploration-exploitation balance.", "configspace": "", "generation": 14, "fitness": 0.29117747757698814, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "068e6446-d398-45b7-a9ea-74fcc5323dba", "metadata": {"aucs": [0.8236625262175822, 0.8221085243957824, 0.8598446691463327, 0.8326381895880417, 0.8606324241139697, 0.8163957979845385, 0.8215895428281665, 0.8520970834621805, 0.8640174373959196, 0.7691893124619715, 0.7383345845790104, 0.6886672226578288, 0.7119919278987763, 0.17547863230619354, 0.7301484622368388, 0.7270576032308141, 0.6663323191147771, 9.999999999998899e-05, 0.4490022747469754, 0.5001122248590324, 0.42368174451143403, 0.4535977204818238, 0.4887784614345203, 0.5420736906628509, 0.4015682581775837, 0.4707189005290846, 0.4678026506633164, 0.15687608713869106, 0.1559695408845233, 0.4415928087989378, 0.43070489930413314, 0.38043132540221103, 0.09255032525154272, 0.3933022042982547, 0.3936437315996809, 0.3457149659747667, 0.8901228887741124, 0.9044140646344532, 0.9398813156020943, 0.9709076459517898, 0.8165120303249505, 0.9089014027517887, 0.8951279839763354, 0.9035611251155462, 0.8677327028709035, 0.19869644112074702, 0.3475813885824246, 0.5210354599537435, 0.346580302223662, 0.22170248861205977, 0.37277191911108254, 0.17129839777680922, 0.19679879236692865, 0.3988995458529684, 0.2207137356667782, 0.7072476077326046, 0.2879328824904971, 0.25062413714719756, 0.2763970325080106, 0.8670673406140892, 0.23229415092652728, 0.23401701652965945, 0.3055762003848137, 0.12226154588708937, 0.15808683191476247, 0.19551703138842536, 0.1557676735082667, 0.17122097925396507, 0.13322419875590097, 0.17334567714039917, 0.1752914895335389, 0.23376060839110402, 0.16714850052454, 0.14352059875069811, 0.13071993472788257, 0.24026060237789792, 0.2106356802329734, 0.19850079475336624, 0.17060522843181347, 0.18004835990157475, 0.1584153912659021, 9.999999999998899e-05, 9.999999999998899e-05, 0.012805101312668543, 9.999999999998899e-05, 9.999999999998899e-05, 0.022327373180802135, 0.02238462817029252, 9.999999999998899e-05, 0.11303634091992498, 0.18819278853414712, 0.09928772600527169, 0.05795167006961888, 0.1912967457133351, 0.04466107695205135, 0.06544044781248026, 0.12331574871050655, 0.1404586220337316, 0.10443306652296558, 0.03385742659391566, 0.129357143014611, 0.15621063234924182, 0.11137536908976509, 0.03265305498232007, 0.30866774136022457, 0.08679898632677718, 0.1307795022086975, 9.999999999998899e-05, 0.1939007420626644, 0.14529309383317923, 0.21687280663284259, 0.11694516546850986, 0.2116664992548981, 0.06406842872171814, 0.18638392163511808, 0.10547802279761653, 0.15905134357930473, 0.5415884827547244, 0.7294009062540953, 0.4550613775275958, 0.5362826175499743, 0.4923683084927092, 0.5126215203364555, 0.6489354022582552, 0.5198695138020666, 0.5773781899008661, 0.0911827195262842, 0.10291511426183264, 0.11889231741285544, 0.11478901897540073, 0.10302318397117838, 0.10263727228679254, 0.12094961822780748, 0.10760006492408225, 0.09124646520601432, 0.13069102357511597, 0.1641617949648786, 0.1236047157806397, 0.13474554564833174, 0.15312230877470678, 0.16974063882292123, 0.145574017091464, 0.1438284229731096, 0.15229894373320296, 0.30739382654608705, 0.3015505038176669, 0.31543753048636214, 0.30737062551221983, 0.260667400581995, 0.40852718288326884, 0.3354103871027647, 0.31322196175325756, 0.30936095163828226, 0.22370199954343561, 0.22739641134081745, 0.16898576504078033, 0.20506024360040642, 0.16349748983757495, 0.17959228576540065, 0.3444883207053705, 0.23341127833821618, 0.2049947702059579, 0.18158664717892647, 0.20338833293331482, 0.16535467530986392, 0.19443592426824263, 0.1887537981505022, 0.18381330577655064, 0.17867005861214313, 0.19409145536501715, 0.18615534638979414, 0.18914819344862766, 0.2231776125809406, 0.2419198337349342, 0.21736874769423187, 0.2181559800044044, 0.20264462631851654, 0.23996549189482275, 0.20141517285173227, 0.21202616091562232, 0.3054778657972167, 0.33281016245287265, 0.22743256350924634, 0.2979915975032641, 0.43430552398361766, 0.1830381608634526, 0.1577871098624688, 0.18507252545305353, 0.1713967324610176, 0.4272988649596897, 0.20589525520166663, 0.15284005256791366, 0.17296824661213883, 0.19322786698062222, 0.19493554070337615, 0.17167285297438517, 0.20867159262494672, 0.16538391973186717, 0.18887384740155666, 0.15719875095849134, 0.18668001344834706, 0.17526521167864995, 0.16917122670043916, 0.19202474577108875, 0.1831334044791011, 0.1733026128237376, 0.19232900471047898, 0.0834338026705369, 0.06767946594057628, 0.07091199690160688, 0.08062828098813457, 0.07262031153717763, 0.07586455065969133, 0.060619537620914876, 0.09040560807542752, 0.07265013032928491]}, "mutation_prompt": null}
{"id": "9e6eaced-e9b7-45fb-ba90-a8b5fa2e2029", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2  # Adjusted for dynamic exploration\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant, fitness_value):\n        adaptive_CR = self.CR * (1 - fitness_value / (abs(self.best_value) + 1e-8))  # Fitness-based adaptive CR\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                target_value = func(target)\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant, target_value)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Integrate a fitness-based adaptive crossover rate and dynamic mutation factor adjustment to enhance exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.20744043111317367, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "068e6446-d398-45b7-a9ea-74fcc5323dba", "metadata": {"aucs": [0.7029148940825068, 0.7345746784462346, 0.7490331087373612, 0.6828763796717685, 0.6916356307198439, 0.7151726993941734, 0.18847481831565216, 0.3215603079614764, 0.27106565156228046, 0.2688894214855807, 0.22717818589242522, 0.197482342310346, 0.35479149005007116, 0.32799491512295587, 0.35891249461356367, 0.2820338728266517, 0.32769488085684173, 0.3184636721968195, 0.06501819402165487, 0.08460993354785584, 0.09513447975225353, 0.279837693451115, 0.2890965974185532, 0.32041452718632024, 0.40379666207272846, 0.3199403714350092, 0.33728372100574244, 0.06568680244325698, 0.041093885851192, 0.05305379100177665, 0.24774754275859756, 0.25168012792039884, 0.16573326402673516, 0.26399896219540997, 0.15597676182912823, 0.29560729035852606, 0.9056800043440896, 0.9070722910140274, 0.9213045058421873, 0.9066970185417864, 0.9056894619177194, 0.8929908473399839, 0.90417065634703, 0.9030857890601549, 0.9052027702914276, 0.11561488660191954, 0.07847219405749506, 0.15532895580934014, 0.10931258138407507, 0.08248859264983699, 0.12466949127007787, 0.13290947387099528, 0.1784876252689248, 0.26999314049438217, 0.13927417628845284, 0.13731879860125318, 0.15409372244238095, 0.17741596944892424, 0.17220477219291475, 0.17498431925917557, 0.1400260210106541, 0.1569133699985723, 0.2137586437274126, 0.15318836665499425, 0.17653409179737245, 0.12555096748355066, 0.2031825140636685, 0.09370175848429407, 0.1428395416837569, 0.14593685680260737, 0.10897011921125266, 0.13547460598820416, 0.0943240846237432, 0.09088737000243041, 0.09513663070262757, 0.11223271206417318, 0.10880228185980378, 0.127711515174456, 0.11605998807587203, 0.12340354035118084, 0.10419699297358598, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045088381564495794, 0.06540705261727109, 0.08092243907719587, 0.04867020595654448, 0.06565418824472713, 0.040161384044689274, 0.03589648696945258, 0.0417153849794919, 0.082768775813992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0367225297645859, 0.03221760488214809, 0.031419395280859685, 0.05153309848485865, 0.07480887617169174, 0.0350981007048593, 0.2659199402450352, 0.18446358281875974, 0.20540375031288116, 0.4074058047788043, 0.35839675065189835, 0.5310179113866068, 0.20055979376157362, 0.565907211336178, 0.29822626405996566, 0.36658867509692705, 0.35662057748771225, 0.3598757376525378, 0.09664220414030156, 0.07164122249202942, 0.06333250114250533, 0.0727065532157205, 0.06825637639030879, 0.07311052206255231, 0.08853858130088355, 0.0720525301044932, 0.060021860657474835, 0.13327327995417693, 0.14516897550258712, 0.1508227997775764, 0.16711284102085988, 0.16585817567887484, 0.1535648670198092, 0.1438786717192324, 0.1393987709162139, 0.12493594324783841, 0.20551097477927893, 0.279441846489372, 0.27153188179411725, 0.21328356480138833, 0.1767096769606915, 0.1930050475232561, 0.1890417499501157, 0.2067904615210453, 0.19808877980828443, 0.10769030555704062, 0.11596272373212102, 0.09589181695542082, 0.1368725762880969, 0.1542530061645473, 0.12012632632089026, 0.14089476516154587, 0.16542111647124025, 0.13286031340097948, 0.18979237557424822, 0.19862660170277235, 0.20242743636221772, 0.1675792108032783, 0.18999851494531017, 0.1757146500168748, 0.16480515286591613, 0.17404456122441847, 0.22463357883340518, 0.18660295150263695, 0.1861527721354227, 0.1660744172050378, 0.19216677996168952, 0.1898833539565571, 0.18533932382919238, 0.199569349635893, 0.18904131228152732, 0.19312292132413722, 0.23888388617913836, 0.19383274986312382, 0.19243755218118808, 0.23161151630187615, 0.17886968611123344, 0.210093340599399, 0.15186046001849207, 0.48771469519835986, 0.16462180785672986, 0.5534363392276683, 0.1974768055289513, 0.11770120696134068, 0.14796246128220958, 0.14155618812624782, 0.14941236440166883, 0.5488257183999445, 0.6030511961395005, 0.19133723833712268, 0.16980242364112308, 0.18465065495858934, 0.1842353585231432, 0.1854731058788328, 0.16336786096125666, 0.15716968123268216, 0.18964251906358864, 0.16803776849263452, 0.173988584706264, 0.07651119939101048, 0.06893849788874595, 0.06413866202296326, 0.05672014873152398, 0.06170243791516383, 0.07363926913641228, 0.08049843049727912, 0.05996433271611712, 0.06867412404925999]}, "mutation_prompt": null}
{"id": "04ee1a3b-dcef-4d48-bbb1-0d14369c3050", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.CR = max(0.5, self.CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic crossover rate adjustment based on stagnation to improve convergence speed.", "configspace": "", "generation": 16, "fitness": 0.2926124285648706, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "068e6446-d398-45b7-a9ea-74fcc5323dba", "metadata": {"aucs": [0.8049524794308147, 0.7858962920223789, 0.863580096461397, 0.8326381895880417, 0.8606324241139697, 0.8163957979845385, 0.8428240068991393, 0.8520970834621805, 0.8640174373959196, 0.7502313376298568, 0.7383345845790104, 0.6886672226578288, 0.7119919278987763, 0.17547863230619354, 0.7301484622368388, 0.7201271145066441, 0.5878778574732961, 9.999999999998899e-05, 0.313245384674826, 0.26329269370021835, 0.33272601302769167, 0.34299277732867717, 0.30291749359035025, 0.31525255255443185, 0.2689149538270592, 0.44934762198096245, 0.3244690983879648, 0.15242805853082175, 0.24276048963568997, 0.14354186001426772, 0.15668885087428386, 0.2502974034950304, 0.08997746185767841, 0.21508954810559444, 0.21772235219227598, 0.2706969443930085, 0.8901228887741124, 0.9044140646344532, 0.9398813156020943, 0.9709076459517898, 0.8165120303249505, 0.9089014027517887, 0.8951279839763354, 0.9035611251155462, 0.8677327028709035, 0.18926723791452593, 0.3818099189142149, 0.5210354599537435, 0.24171195368875364, 0.22170248861205977, 0.37277191911108254, 0.17129839777680922, 0.19679879236692865, 0.3673429524151617, 0.2362604652308966, 0.6193877842544036, 0.2862934785638158, 0.280877083224228, 0.41371222058201895, 0.8670673406140892, 0.35065324904978634, 0.3211391020473746, 0.7176124968416114, 0.12224065764698244, 0.15808683191476247, 0.19224777872776788, 0.19660608529958568, 0.1771914175968866, 0.13322419875590097, 0.16157544789415246, 0.23519372596306032, 0.17622704128298683, 0.16714850052454, 0.14352059875069811, 0.13071993472788257, 0.27413397524904204, 0.2106356802329734, 0.23993107652051804, 0.23113062365868764, 0.2709923483673632, 0.2185924114896608, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017223542559075766, 0.0007550234801606548, 0.022327373180802135, 0.05944116275198852, 9.999999999998899e-05, 0.11303634091992498, 0.2635989166516115, 0.1489719977657109, 0.13104097506290457, 0.17923462782247446, 0.16359333635670958, 0.06544044781248026, 0.24273208161516935, 0.23869156462112862, 0.10443306652296558, 0.0546618663460271, 0.13828932308067376, 0.168034811387754, 0.11423529704466562, 0.1011141620977054, 0.31010812643982966, 0.10580994613916972, 0.14002100572258114, 0.00037011812206311223, 0.1950323316756224, 0.16978700879336062, 0.21658619290987724, 0.18122256265334002, 0.203962877751923, 0.06406842872171814, 0.18668707183552102, 0.10725890397312254, 0.22606914837588055, 0.5592561332509257, 0.7090033012364088, 0.5102211146169424, 0.5206066373985883, 0.49534464857409344, 0.5126215203364555, 0.6517794498141882, 0.5426740022394522, 0.5919185349387573, 0.0852493607407212, 0.08325326023127033, 0.10246291895819282, 0.10026319664680738, 0.08510151151695078, 0.08152975326330902, 0.0940162943089905, 0.1036738653705932, 0.08515380071866696, 0.13148122105891258, 0.13507079479724415, 0.14553664958130996, 0.13605867372592784, 0.16113750069851918, 0.1445065818748903, 0.15262272034634028, 0.15408856044645747, 0.15229894373320296, 0.3180726274251825, 0.36115420984942015, 0.30688310694033316, 0.32434444701692555, 0.29841609983643025, 0.41365183799301086, 0.394623169865429, 0.3629230386952087, 0.36292620734685777, 0.2300089243353194, 0.23855746035262804, 0.1688458795946901, 0.2093427119092388, 0.19066097902421386, 0.22330621020968455, 0.30606830084557346, 0.26027180602658273, 0.1983870219902597, 0.19846278073550339, 0.1730745693060879, 0.19436525668732108, 0.18753247215639224, 0.1755196081702597, 0.19988849513876017, 0.1773235672997071, 0.17415286791661855, 0.1743701513871211, 0.18340460103680234, 0.1975137542115578, 0.2720932538671146, 0.19847152232492848, 0.19147429829707785, 0.18162123925865026, 0.26081362611633496, 0.18188351301496497, 0.1939097446420448, 0.1648005937046524, 0.2865877451767037, 0.7149914577094844, 0.5253554029944434, 0.5581501502715402, 0.18335713851865998, 0.15461424033454696, 0.19010175502513715, 0.1713967324610176, 0.520639736883485, 0.20671269510873735, 0.15284005256791366, 0.16458432885707786, 0.18775982333523333, 0.19906767647472867, 0.20344390940568047, 0.2086715926273861, 0.16588276426141724, 0.18868338345891944, 0.1816090786469946, 0.18365781929693226, 0.18161200917370124, 0.19308716965771577, 0.17000244279070686, 0.1632002182925929, 0.18288530847770268, 0.19232900471047898, 0.08245263826092819, 0.06443636123873808, 0.0796136268524037, 0.07712550395090989, 0.07337340787947155, 0.07767372250123539, 0.0721701473151154, 0.08240132193379746, 0.08186931782896045]}, "mutation_prompt": null}
{"id": "574ec436-c0e8-4cbc-9b1f-21d8da8711e2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9  # Initial crossover rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.base_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation and crossover rates if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.6, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced adaptive differential evolution with a dynamically adjusted crossover rate for improved exploration and convergence.", "configspace": "", "generation": 17, "fitness": 0.29250518133320685, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "068e6446-d398-45b7-a9ea-74fcc5323dba", "metadata": {"aucs": [0.8049524794308147, 0.7858962920223789, 0.863580096461397, 0.8326381895880417, 0.8606324241139697, 0.8163957979845385, 0.8428240068991393, 0.8520970834621805, 0.8640174373959196, 0.7490021186486986, 0.7383345845790104, 0.6886672226578288, 0.7119919278987763, 0.17547863230619354, 0.7301484622368388, 0.7201271145066441, 0.5882458488718624, 9.999999999998899e-05, 0.29158413277380657, 0.2228089894919706, 0.22315519231036118, 0.27385385289049446, 0.26365999750014335, 0.24767589515055644, 0.29861336685220674, 0.36292804191690387, 0.24219348030903975, 0.15392804398281745, 0.21570772047945053, 0.14361379883882242, 0.15609228028905842, 0.14892542173239287, 0.08930341379464313, 0.210163729216567, 0.1731909171711039, 0.2473051062662639, 0.8901228887741124, 0.9044140646344532, 0.9398813156020943, 0.9709076459517898, 0.8165120303249505, 0.9089014027517887, 0.8951279839763354, 0.9035611251155462, 0.8677327028709035, 0.18926723791452593, 0.39164006935160245, 0.5210354599537435, 0.24171195368875364, 0.22170248861205977, 0.37277191911108254, 0.17129839777680922, 0.19679879236692865, 0.37787352202935165, 0.22230045202612214, 0.640495605485593, 0.29881610845532325, 0.3741221307947501, 0.5342099044076588, 0.8670673406140892, 0.29599126071412074, 0.38063484902752487, 0.7176124968416114, 0.12224869289355689, 0.15808683191476247, 0.20587564559805838, 0.19643065479306976, 0.1771914175968866, 0.13322419875590097, 0.16157544789415246, 0.23519372596306032, 0.19288242795237454, 0.16714850052454, 0.14352059875069811, 0.13071993472788257, 0.27413397524904204, 0.2106356802329734, 0.24639215513404533, 0.25234393338805206, 0.2709923483673632, 0.2201105056080198, 9.999999999998899e-05, 9.999999999998899e-05, 0.014243300814524407, 0.03562278962801191, 0.005132307833251248, 0.022327373180802135, 0.06128232471985362, 9.999999999998899e-05, 0.11303634091992498, 0.2721643480250713, 0.1489719977657109, 0.14253226329578883, 0.18379538097268766, 0.16337168114811906, 0.06544044781248026, 0.2584314120929371, 0.25081876512866497, 0.10443306652296558, 0.05784711521726149, 0.12353251083550965, 0.16771945844682123, 0.11423529704466562, 0.10488362647896443, 0.3095648684673884, 0.10514990889970754, 0.14060541200037313, 0.0010413760408326533, 0.19504296898105788, 0.1770481624899154, 0.21658619290987724, 0.19568814705504767, 0.21108992091459378, 0.06406842872171814, 0.18668707183552102, 0.11672835529694203, 0.2277625106126946, 0.560606513298165, 0.7098629369902398, 0.5302266170402598, 0.517820025643432, 0.4858118239119622, 0.5126215203364555, 0.6522580574672058, 0.5467081755637511, 0.6146476623461752, 0.08511416826197638, 0.09880859554986454, 0.10058034167851526, 0.10143345396174319, 0.0837034139021896, 0.08622814275470647, 0.10228619702003194, 0.08644645851108124, 0.07575129016776172, 0.1311900987275798, 0.13496810036560403, 0.125052525048582, 0.14134090014037903, 0.13223834890875097, 0.1316931078939464, 0.16305132765553354, 0.15618759155443496, 0.15229894373320296, 0.33708559248544956, 0.3743776628995371, 0.30860368885177214, 0.32556824459630485, 0.3016223967734999, 0.4138805483388144, 0.3923691085044697, 0.3694865721465681, 0.3713226804752269, 0.23194594345404007, 0.2375431233866896, 0.18101604741620336, 0.20566908376821202, 0.16845872283226582, 0.22340812274199884, 0.3109550302186307, 0.2600808381859634, 0.2091275932746567, 0.18893534905924558, 0.18802577488218009, 0.19436525668732108, 0.18753247215639224, 0.16402071528380624, 0.19990476227560772, 0.17699100961962355, 0.1696818787232507, 0.1865769689340102, 0.18644842455926225, 0.21006574229932706, 0.2167400579563774, 0.19208151238776472, 0.19700336191523904, 0.18466612464463128, 0.3018185049148536, 0.17406448903316019, 0.20232580309149595, 0.16882806532921002, 0.33111230705640804, 0.7149914577094844, 0.5329057439813212, 0.6296484970169792, 0.1833563246451152, 0.1546559188974166, 0.1901348001990869, 0.1713967324610176, 0.5676126639959538, 0.20671269516518842, 0.15284005256791366, 0.16458387078083725, 0.1789720136548214, 0.19913480832106, 0.20344391119505179, 0.2086715926273861, 0.16588276426140636, 0.1929746750803114, 0.17307795609298426, 0.18365781929693226, 0.18702804721032618, 0.17625663580075035, 0.17982034560838334, 0.1739015324203279, 0.17852247196533277, 0.19232900471047898, 0.07469643464990638, 0.06939042417316832, 0.07920016015763376, 0.07935538505775208, 0.07992937807077216, 0.08115663918638583, 0.07171200143141143, 0.08240132193379746, 0.0798831113943883]}, "mutation_prompt": null}
{"id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced differential evolution with adaptive crossover probability and mutation factor tuning for faster convergence.", "configspace": "", "generation": 18, "fitness": 0.336185085959783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "068e6446-d398-45b7-a9ea-74fcc5323dba", "metadata": {"aucs": [0.8558067534710863, 0.7120653562976866, 0.835672017635771, 0.8425818862114427, 0.8564035034879076, 0.8218556617277377, 0.8789689009743785, 0.861097555285652, 0.8436811054665991, 0.7370748549103296, 0.6764201053837433, 0.24344332960417014, 0.7565863650529556, 0.708029862881711, 0.7397705776235737, 0.7359702932913363, 0.7150400155809271, 0.017417907966684076, 0.18122792320995074, 0.12641278833400083, 0.11543636802268242, 0.14991191168456297, 0.15013482915834575, 0.11622982942630133, 0.1324443239578622, 0.11873315546305763, 0.13940471548010114, 0.10871947975316876, 0.11821784773048971, 0.14274304522590286, 0.10473429577877269, 0.10021028371296126, 0.11830639113858199, 0.1110314542490729, 0.10392901411871458, 0.11070141773652908, 0.8798791112697484, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.8858604558230023, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.37178708934968396, 0.18783352566599343, 0.2858988673785914, 0.4069972714192467, 0.16035997870998997, 0.3593953806238199, 0.8468334574599534, 0.7768475333130712, 0.6285445350285669, 0.6645412793090701, 0.8319850544678028, 0.7347459926936938, 0.8771454346934292, 0.8414628059036096, 0.7367032514386522, 0.15706054111730738, 0.16197857112410496, 0.12364927714049789, 0.26683293429395527, 0.28033237120723964, 0.3081518650306323, 0.16029071752978763, 0.23992256772361475, 0.17462797812751452, 0.19516394017586103, 0.22359926902688054, 0.1406801924588823, 0.21723867809396913, 0.17598077795579048, 0.12980441364801276, 0.12783242606600143, 0.26924477967967764, 0.3052404582107897, 0.2920201048574803, 0.13269882400444966, 0.12250646229714635, 0.025412445280017515, 0.290193448981371, 0.01015506712917813, 0.08852249147025837, 0.3327016211471332, 0.27626592026787755, 0.4041687152028831, 0.3389759188964425, 0.3384934640253118, 0.12483916317504173, 0.3511515961677857, 0.3401261396199553, 0.1524582748914749, 0.4238889560505885, 0.366181132501176, 0.05220620836060441, 0.12539542502127277, 0.2130993110130407, 0.07408232064815967, 0.21770137756842467, 0.3333143221270528, 0.14977804325225896, 0.2930250074724067, 0.09041150879066806, 0.11871316333810444, 0.1436668176253756, 0.28108792209873346, 0.27071923924101926, 0.2241709163335418, 0.3251671251270186, 0.2146127313272861, 0.24684614955821482, 0.2793957292397907, 0.7288237737384289, 0.5450905925966292, 0.5520746918120754, 0.7775759108539199, 0.6561405404510117, 0.8087139535449772, 0.5119943519169622, 0.6285172705927664, 0.5685607316864372, 0.14056380451002337, 0.09051126264590914, 0.12456490372253426, 0.09706401924562846, 0.13193675058028498, 0.09496867093337136, 0.1210714860388058, 0.08439474336838648, 0.10427537153115063, 0.1472971256939607, 0.12598542058784845, 0.12054533364004727, 0.1520236024329954, 0.18692937878632065, 0.3151379770729772, 0.16025638304468537, 0.2410336204265322, 0.16521591796394985, 0.4364139068086559, 0.5131543720641202, 0.31187036021139636, 0.3641168627400251, 0.3488372538202489, 0.3118947617690837, 0.4277536609546889, 0.44043723463450624, 0.318912033794469, 0.3224190047504061, 0.33764752944103016, 0.3027403218767232, 0.26247736039171665, 0.24785705152166349, 0.23474848037828255, 0.2769175113514032, 0.272806793717303, 0.09473939548414823, 0.1862709506810165, 0.1634302535012494, 0.16342054362485614, 0.1765504840142086, 0.19113565935496057, 0.1800917274961592, 0.18712576595158936, 0.19258630247369857, 0.18809843960033246, 0.29048333727859166, 0.20227047563903888, 0.17771362783729183, 0.26440549536691227, 0.18088606690102949, 0.1849484853535599, 0.3923404862756611, 0.19427925857917006, 0.23291773952522432, 0.16347379650822402, 0.6975795417348972, 0.15050497149040076, 0.8310587346403054, 0.6508206830345746, 0.6469838004405642, 0.7388861417085049, 0.16531908563810904, 0.5080257753951918, 0.6905895069042383, 0.20379648690133378, 0.2025180555693411, 0.20476198117433175, 0.1626544630805149, 0.16712206248163763, 0.20581989383244925, 0.7251714655982322, 0.7595098341857599, 0.1869256281308358, 0.17503591029887944, 0.19545032166751375, 0.1717670201118664, 0.18851341926651488, 0.1685417980988324, 0.1837593802188653, 0.17950431590217375, 0.17133525782643722, 0.07150261680261571, 0.07331750333132336, 0.06548682990713606, 0.06857905748607773, 0.06807612216352665, 0.07488369463184441, 0.07584546347791388, 0.08497975999196972, 0.07539119643308478]}, "mutation_prompt": null}
{"id": "912aabc6-8aac-4eb6-aa73-d8cd3e550428", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2  # Increased range for better exploration\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.1  # Slightly increased range\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Dynamic adjustment strategy\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 4:  # Adjust parameters more frequently\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.7, self.base_CR - 0.05)  # Slightly lower CR bound\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced differential evolution using adaptive strategies and dynamic parameter tuning for improved convergence speed.", "configspace": "", "generation": 19, "fitness": 0.29390908937847054, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8473626957845036, 0.8451630028726865, 0.8622944930135666, 0.8669582021056521, 0.8616243150915378, 0.8020508106055455, 0.881491610524731, 0.8210324173052218, 0.35040212658114955, 0.757356927160941, 0.648312917006277, 0.5463625226623293, 0.653002326437983, 0.269323956625681, 0.5522709160391797, 0.739714094326954, 0.6117599287866748, 0.6921607929788886, 0.15049952903188513, 0.15533504349504745, 0.13883784914427966, 0.27741666396019826, 0.17217311775845612, 0.2997517198768309, 0.21627869738372174, 0.27368221191645403, 0.18000627327504137, 0.17107216953845406, 0.14017915512729429, 0.14089899599302502, 0.16322698603412955, 0.13639686049331923, 0.16757061419663155, 0.15112002956776138, 0.14389000532444574, 0.1321796754462079, 0.8876304986558959, 0.9309323195314946, 0.9052190650017683, 0.8987726008677938, 0.9295457862733401, 0.8407651979031532, 0.933650986093192, 0.9015200598543444, 0.8600326553513056, 0.3937844855602173, 0.4495259952656625, 0.10398663260339203, 0.28387947372446853, 0.4495041916505452, 0.165574131522642, 0.41520746841397727, 0.200816929654284, 0.3493352001681548, 0.4934470611805487, 0.5602685255940346, 0.8632223607131629, 0.6224025257354618, 0.1912781835109365, 0.783907123057781, 0.6466052946186331, 0.4169206562181298, 0.7579715204769045, 0.1649861256362487, 0.216972236980439, 0.17215787653471504, 0.2640456711016368, 0.172988477929792, 0.12864302345177547, 0.19001280855136649, 0.2434425289466583, 0.14879415270674723, 0.15267869872642836, 0.14683309516203713, 0.17989507792204262, 0.15225726085822167, 0.22138969207178572, 0.2003690123532833, 0.26255820535884034, 0.1477601044466439, 0.1308331357187721, 0.04441430261487167, 0.027264034594514097, 0.05472176208368296, 0.16805054111130135, 0.18173526866751255, 0.10829257999964159, 0.07707211600126462, 0.08810566040905088, 0.026240652900192618, 0.21317897269509845, 0.27137878511771374, 0.13401655316472427, 0.18653140289592218, 0.2361311070907245, 0.14496119713540012, 0.16729979323063449, 0.2104408316110331, 0.1915787101608084, 0.14231086067952348, 0.01473552168905512, 0.002992004039338858, 0.044091943840714354, 0.010411418640148051, 0.09206649765027541, 0.013863999669481708, 0.08923755390626342, 0.02432513919145063, 0.20283007858825852, 0.30806398591911566, 0.1855379899994376, 0.19275468033831333, 0.23558218921471574, 0.20588945383519552, 0.21087956911336125, 0.1934810424171327, 0.13134012908188086, 0.43969410883458204, 0.6970314241427544, 0.6226720698999354, 0.5992413065688534, 0.49985895151406945, 0.6485501076743252, 0.5971101242569561, 0.4953692516954098, 0.5406353830549646, 0.08997806361591554, 0.10873374147607462, 0.09046833496652107, 0.07426538506734359, 0.11091480645389762, 0.09682144112460189, 0.10141623060560612, 0.08652996799712431, 0.08474658968171245, 0.16087235707171055, 0.12955291131642643, 0.1392710125431298, 0.14233712688305677, 0.1138582943316816, 0.14386630722640725, 0.1432228421093259, 0.13276178812286688, 0.12852224170027782, 0.26781392168603846, 0.3247360016602514, 0.3101232143990573, 0.32271060504743454, 0.2554536401702391, 0.315047077933277, 0.3447683228389987, 0.30590763080865746, 0.3047570499678913, 0.20277018937533464, 0.21313500950834818, 0.17189668069492603, 0.19322729737277766, 0.2439121534869172, 0.23276667217887503, 0.19482001339636612, 0.28133045202106, 0.1973152349034979, 0.1628245158600361, 0.18953545715605113, 0.16874012484379708, 0.18460848812856334, 0.17298632462910224, 0.17541143938490655, 0.1886821763067662, 0.17453389192597824, 0.17290966846657174, 0.18374857188819238, 0.18025702975146707, 0.23163206656444524, 0.2088132086110147, 0.19466649956416104, 0.1831032056798445, 0.18592547021282413, 0.19143676318064284, 0.2001991175904938, 0.16733564240372667, 0.573158137786584, 0.15095229980399294, 0.32112667234329195, 0.8072507916410613, 0.5287499936156161, 0.8563870731749108, 0.16630520684351724, 0.3236403535621254, 0.1532877936655368, 0.3622067261715567, 0.16139954455856464, 0.20793996959522132, 0.1651887474226894, 0.1643924357267701, 0.16213119716415691, 0.4404828178377833, 0.1107531227311721, 0.16793873654601776, 0.16869115413487712, 0.1800949560230365, 0.1695861335284159, 0.18949904274049556, 0.1687193319089504, 0.1695868993171381, 0.19614176726922172, 0.18100027270489172, 0.08073563680967977, 0.062069449200581994, 0.0674778097347315, 0.07915171466501436, 0.06388013424342931, 0.07161712566980427, 0.07036589072023436, 0.06933467945885041, 0.07168459146655581]}, "mutation_prompt": null}
{"id": "d2e29a88-3dd5-463e-903a-fcd5dca48916", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        dynamic_F = self.base_F * (1 + np.random.rand() * 0.1)  # Modified mutation factor adjustment\n        mutant = self.population[r1] + dynamic_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        dynamic_CR = self.base_CR * (1 - np.random.rand() * 0.05)  # Modified crossover rate adjustment\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        convergence_threshold = 1e-5  # Convergence condition adjustment\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adjust mutation factor and crossover rate dynamically\n            if abs(self.best_value - prev_best_value) < convergence_threshold:\n                self.base_F = max(0.4, self.base_F * 0.9)\n                self.base_CR = min(1.0, self.base_CR * 1.1)\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced adaptive differential evolution with dynamic adjustment of mutation factor and crossover rate based on convergence speed.", "configspace": "", "generation": 20, "fitness": 0.18237426739565693, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.14.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.25870283582668885, 0.410077267039762, 0.4029817666073212, 0.2641464021445947, 0.21954105507112676, 0.3965730775628221, 0.4580672526571712, 0.25599613851345504, 0.3332055093649535, 0.15324620264236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05821019602667188, 0.11709130886490815, 0.20660004065926618, 0.06049963206685627, 0.14429119771031562, 0.1186132261086914, 0.10988469989511485, 0.13540731795480987, 0.16566784608088858, 0.1128897922598533, 0.15855951440747007, 0.09890292541694179, 0.12341726524685548, 0.07557882460608811, 0.12068751315188653, 0.07398927602116745, 0.10962155474357782, 0.09041108523046859, 0.10464837874972288, 0.0882406111550108, 0.10687991459685076, 0.06616880119689506, 0.2994352955412717, 0.09426183689608825, 0.9509850468438541, 0.15601845738373654, 0.1391610082754462, 0.3993946259177077, 0.07867624200303636, 0.08462519879994179, 0.15983881293835134, 0.09590092850727794, 0.08222966239773666, 0.11078987342764579, 0.0661084747187044, 0.0998848182620522, 0.1430186837595676, 0.08836676221108386, 0.061726208734470656, 0.2373170630241762, 0.21156805934046274, 0.24196268610841654, 0.151840872235526, 0.8920627999523283, 0.19017332679309396, 0.799473349663834, 0.23478734284001757, 0.23200330407108527, 0.23374706746137996, 0.10648013354766805, 0.10772095121238912, 0.1431624681282272, 0.13636734620812918, 0.12215222535463799, 0.33999507178338706, 0.18059777284177947, 0.14625678737978198, 0.20051047226143592, 0.3459827631826058, 0.12452905025590166, 0.12450891056366431, 0.007834267967506636, 0.14459909741154775, 0.090162776069312, 0.1589072235305239, 0.1331649814958975, 0.1331577711136852, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.2169725684591558, 0.057530411958402916, 0.0072727445011671055, 9.999999999998899e-05, 0.04471128219685927, 0.0031129494135945235, 0.1737180795670803, 0.14513685729635095, 0.31400535600116886, 0.21216534385212849, 0.021849162544748113, 0.2055533345935564, 0.09331946541400249, 0.14630085429269657, 0.16638373942993456, 9.999999999998899e-05, 9.999999999998899e-05, 0.15930807027542782, 9.999999999998899e-05, 0.27018012368404065, 0.15273130936151813, 9.999999999998899e-05, 0.05657680764323303, 0.12176044863607638, 0.01287923092950094, 0.0641628829725932, 0.13478083584576728, 0.04078371678181825, 0.08035642953351685, 0.049571481384653615, 0.17699440798532484, 0.08906307490232135, 0.009902607547099929, 0.39062310997555183, 0.38658057521648514, 0.48270586628674284, 0.3044600581937701, 0.22696738740499756, 0.43369649637338736, 0.42178347153212425, 0.3731409997297447, 0.34272645867650176, 0.11707965570700885, 0.11751827413309635, 0.10457013856665143, 0.16004212287497632, 0.11087252051318719, 0.11294521743411623, 0.12397614121490419, 0.1497653567688867, 0.13157576759725975, 0.19850049058170394, 0.13313878344760888, 0.21225678163181916, 0.1873432128447894, 0.24066930357581895, 0.17825500548526452, 0.20554705065034218, 0.1313479823065551, 0.18216216134193974, 0.2712625708024674, 0.4680404968038361, 0.29659841478629456, 0.31880808252964954, 0.2046371967523487, 0.23385993833630814, 0.23065300309002046, 0.5638259030010295, 0.22191841579404026, 0.3371678045233749, 0.2494143286628684, 0.26369234954906184, 0.2730808343609542, 0.2141418113336112, 0.15700151108711702, 0.13491249127454008, 0.2915700812789942, 0.24908002132305895, 0.21254938308922078, 0.18477340506072892, 0.22147236751949062, 0.18504636910754202, 0.1911544906916195, 0.22342938767110376, 0.21841432169574226, 0.20000627893202394, 0.2030045795734562, 0.19389855916781729, 0.2080845403211572, 0.18308606451906118, 0.21622253732948815, 0.19170638274155072, 0.3850787963013177, 0.20766096519328725, 0.20604739200218203, 0.2844394177715207, 0.1674627589058344, 0.20772098866388267, 0.15181365773579492, 0.2560665512477227, 0.5027511908167972, 0.35625610036388633, 0.1462988189869171, 0.1648637453573807, 0.2026174080805373, 0.1811694662514255, 0.1636883445664158, 0.0826414584625722, 0.4009210451585653, 0.18007188627112514, 0.16467972267753828, 0.16497580514800614, 0.10808290693740796, 0.21947212537041094, 0.1705315282409936, 0.17167680022974963, 0.18235250221750243, 0.18348067826236736, 0.18487582123450907, 0.1796634149684715, 0.20484542452389576, 0.1892967194346461, 0.17499066614107783, 0.08497956034358323, 0.08661817385620829, 0.08476720617676314, 0.07916436432517826, 0.08109971126657367, 0.08809740922783404, 0.09603665285335661, 0.08414437964873012, 0.08014599446443715]}, "mutation_prompt": null}
{"id": "45860090-e2a1-4ba5-9591-1e353968f5bb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        dimension_scaling = np.var(self.population, axis=0)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3]) * dimension_scaling\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introduced adaptive scaling for each dimension based on variance to enhance exploration and convergence efficiency.", "configspace": "", "generation": 21, "fitness": 0.11217949499753167, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.19.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.13927257754688294, 0.12927571736363475, 0.19674993042682698, 0.3049625814457144, 0.20960509723124687, 0.15396566718687732, 0.17327831365809165, 0.16691230740215157, 0.2917277267708964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06074888561979641, 0.06348276485395454, 0.08960251653142881, 0.057173343681206634, 0.10670086307142423, 0.11373393667020659, 0.10244686916833923, 0.026603626013714354, 0.08526278957974465, 0.02969305377803555, 0.06698080888877866, 0.08918015959300396, 0.035075668434926044, 0.12269814312504856, 0.043541334510559526, 0.059756747247288855, 0.05659625099479493, 0.09731100381269775, 0.9910186282584804, 0.9846925441710672, 0.9819371046403109, 0.9800096957423977, 0.9899911558829764, 0.9941438266197431, 0.8913332943703807, 0.9911420973237139, 0.9765966505307725, 0.04488081973082714, 9.999999999998899e-05, 0.013445628059391312, 0.02778056736003054, 0.06837558400892485, 0.09225061195285689, 9.999999999998899e-05, 0.045848673591841194, 0.011027475235183881, 0.16443522320624793, 0.09321174347605043, 0.030887590440769053, 0.10612406384883122, 0.09270272379178746, 0.12522747154337177, 0.06345351587605397, 0.05939861054600637, 0.07000648748224847, 9.999999999998899e-05, 0.03927204129121287, 9.999999999998899e-05, 0.056246404651008164, 9.999999999998899e-05, 9.999999999998899e-05, 0.030636099403771877, 9.999999999998899e-05, 9.999999999998899e-05, 0.009153655602261113, 0.009091098913099227, 0.007594030877531077, 0.01741484496470458, 0.01412804097648901, 9.999999999998899e-05, 0.015571937746513553, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0040150884252380115, 0.026931292962935727, 9.999999999998899e-05, 0.05638577431974956, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010937013014110875, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024414240920832553, 9.999999999998899e-05, 9.999999999998899e-05, 0.26852710009803793, 0.16613222674434824, 0.1717609100038373, 0.15363025359629956, 0.17503896519133544, 0.17402153985216973, 0.1894900636936322, 0.14308865205655763, 0.14729489941064944, 0.04360853645643059, 0.0828593296439536, 0.02659625993457926, 0.03481797897087713, 0.05052535673576275, 0.056039820955862574, 0.04086611059145784, 0.04439456550122556, 0.04419601428497644, 0.10147665463318867, 0.09297316041446213, 0.09633299910315085, 0.1035931680325195, 0.10849205547331875, 0.12120354564808145, 0.15429918479829052, 0.11483457869263125, 0.1129914180044983, 0.11854421995621833, 0.11599742160624005, 0.11453583567954917, 0.16560545007920213, 0.09571629951417349, 0.14282850448670303, 0.11939209272724072, 0.2207087017642856, 0.1322439038465496, 0.10985328373638115, 0.1150434979767464, 0.07093972713143959, 0.06431920698582072, 0.0813945887158507, 0.05485289100430435, 0.08808778254104, 0.13179664172988848, 0.06482665993420911, 0.1362835375602921, 0.13372878619073014, 0.13338922036563594, 0.1524694383470051, 0.13806222489666065, 0.1522014799768029, 0.15315586843885698, 0.1450707133297161, 0.12703096762622756, 0.15976825674155082, 0.13087316336552668, 0.11954665095012074, 0.017793697468224456, 0.14502036131368656, 0.11429786325428792, 0.1582823928756374, 9.999999999998899e-05, 9.999999999998899e-05, 0.07621467193228604, 0.07961217989928371, 0.11045012704539314, 0.12029605194283943, 0.1504005250828292, 0.11110986955253521, 0.11546896645114413, 0.09887089067360522, 0.10754196528660032, 0.0835243658960928, 0.16780606051155278, 0.14372552979535447, 0.17053490652289272, 0.056505941576633245, 0.10071125476222242, 0.10257839305129435, 0.16801190081229156, 0.1775581696422327, 0.14477529031467862, 0.15384788743388012, 0.15270414354601491, 0.1500574262132024, 0.1528349741625078, 0.15113127494626455, 0.13666245743423766, 0.15603179969744285, 0.15208467698071804, 0.03148305394449469, 0.05144087380222995, 0.048838819165562763, 0.04396730547449279, 0.03365970314075617, 0.024647052964286376, 0.026015501349043513, 0.02207363025436737, 0.025494561199643773]}, "mutation_prompt": null}
{"id": "b830703c-87c6-4623-abb3-bc37e08a3fc2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 3)  # Slight adjustment in population size\n        self.F = 0.6  # Updated base mutation factor\n        self.CR = 0.85  # Slightly adjusted crossover probability\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.6  # Updated base_F to reflect the mutation factor change\n        self.base_CR = 0.85  # Updated base_CR to reflect the crossover rate change\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.15  # Increased perturbation range\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.04  # Slightly reduced perturbation range\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 4:  # Slightly faster adjustment\n                    self.base_F = min(0.9, self.base_F + 0.08)  # Adjust mutation factor\n                    self.base_CR = max(0.8, self.base_CR - 0.03)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "A slightly improved adaptive differential evolution leveraging enhanced mutation factor adjustments and dynamic population sizing for better convergence.", "configspace": "", "generation": 22, "fitness": 0.28586327004578654, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8331380101457116, 0.7996222657441111, 0.7533269862146028, 0.8422171257051757, 0.7399321165564386, 0.7888646301583114, 0.809689039786582, 0.8425224711939177, 0.7864622626077636, 0.5712890212273902, 0.5996773938819814, 0.5617904727887557, 0.5345116008427536, 0.5512193715398905, 0.6888471228488703, 0.5946878084150553, 0.6426694822420398, 0.6833887111592214, 0.16796872789812878, 0.12167962202251437, 0.13959619124635192, 0.167512599968081, 0.15168304998016957, 0.12546214693360602, 0.2338237481041907, 0.12769336325598035, 0.13280535672842486, 0.12731441319118297, 0.1356354273556013, 0.12015766544506146, 0.12360827511475614, 0.12751904940939895, 0.1478312986164343, 0.13649660179546863, 0.1064347178049111, 0.11867155360690618, 0.9247520668027098, 0.957127780915157, 0.8251842859528179, 0.9452113093802574, 0.8934378141348646, 0.9280901470896692, 0.9786899097820776, 0.9405658106651766, 0.9309768489380214, 0.282921818593987, 0.29548526662693286, 0.34738570047027484, 0.2612451053836802, 0.4000391354072934, 0.47450198638762764, 0.3103781568760322, 0.42992060219228057, 0.36643508289956483, 0.41225569073805934, 0.5230332430910846, 0.31527641866602485, 0.4456428606446806, 0.482645530236275, 0.6646457624301045, 0.4032289505252713, 0.7038235978399576, 0.5423695230998204, 0.15396089032569493, 0.1901892789129188, 0.22844181274539932, 0.20181291147224867, 0.20467921302301106, 0.2157555385401524, 0.24200055190628422, 0.16733557788985653, 0.24626739087634075, 0.19827004648385327, 0.19892167595693422, 0.050956254859972794, 0.23954917825270983, 0.2533901468541673, 0.21579704598226523, 0.19515222750634642, 0.22135090363957677, 0.20153744404663199, 0.09814133916032008, 0.08742142841489364, 0.020877775388650432, 0.10078260880659495, 0.041247168132456324, 0.03151237686369135, 0.05867431054585848, 0.09716586935639848, 0.06606839837819256, 0.21897046525650754, 0.2507408309957009, 0.12456520841983088, 0.2821417419296929, 0.15213687292957423, 0.1280355439523264, 0.21227236495898605, 0.18753811136365817, 0.22418615239338324, 0.001168678306842641, 0.001217520840455344, 0.04007742449859797, 0.026553806690884807, 0.005700646117586472, 0.03168626880449665, 0.02933493401247711, 0.05376491001674277, 0.08585560167727724, 0.14822187693306554, 0.1451266841494092, 0.18795289316298391, 0.1825143218842059, 0.1689522346941671, 0.151867332423387, 0.16177937725812186, 0.17066214343707908, 0.12349789673032885, 0.5159135767002472, 0.5380519328951727, 0.5239926000795845, 0.5014235170922607, 0.5589718380698558, 0.49469747234011263, 0.5183606247471457, 0.4833506971177648, 0.5234008291452521, 0.09864892511554413, 0.08382206089036559, 0.09716283215076127, 0.07946309211267266, 0.10004185862588855, 0.08448358884031637, 0.08583218503597667, 0.0968469354820074, 0.09820099871347443, 0.12746286475017554, 0.1527178330825767, 0.13456251598644775, 0.13986159806133458, 0.13592840846148502, 0.13624152709240112, 0.1768699524673042, 0.16136076492401696, 0.12336677504428883, 0.3052095048826797, 0.27148739888271634, 0.26197495040147, 0.2702480395716278, 0.2458800696283312, 0.24998605397084517, 0.3019194913820894, 0.3283163112149715, 0.32834090985253184, 0.21050847965467523, 0.22835283141671836, 0.19136022199558356, 0.20721759830557773, 0.1883755487256048, 0.16666830511059594, 0.22701609837123204, 0.22252039953662872, 0.1885291775306036, 0.21034961325887203, 0.16815224141032636, 0.17744048913366073, 0.17572657968510796, 0.16767760250631003, 0.16948687342651414, 0.1738727851574291, 0.17571295436953782, 0.1678606680839675, 0.21474590658163317, 0.18080492688417993, 0.19122035066343668, 0.27307018649959514, 0.18786184209994872, 0.19266344333956065, 0.20217453491865545, 0.1826741644928348, 0.1795887053618469, 0.6842958282260005, 0.6285599607186347, 0.16387879330486688, 0.5396319207892667, 0.3174879533588669, 0.5622310688295183, 0.18191251874976422, 0.1683429701896726, 0.16519514414604675, 0.511343391449177, 0.16621201209861047, 0.14959723206860687, 0.1971459556909938, 0.42092582907811904, 0.3173552107809907, 0.1538055623281558, 0.5545876882211986, 0.20916536299405764, 0.18113086507734744, 0.18390385579507784, 0.17538745096568997, 0.2002202839201801, 0.17932103659976184, 0.16644359296686484, 0.18373200699105807, 0.19155319332257725, 0.16843625046675137, 0.07342102084165458, 0.0627907159846629, 0.06456499844428398, 0.0702369627401267, 0.06906997150399308, 0.07078640213382548, 0.07515532643101064, 0.06480740619312597, 0.07299620769238868]}, "mutation_prompt": null}
{"id": "00ac02d8-9be2-40e6-aa1b-249f37e02193", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2) \n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + np.random.uniform(-0.3, 0.3)  # Widened adaptation range\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.3) * 0.05  # Increased range\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            new_population = np.copy(self.population) # For elitism\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n                new_population[idx] = trial if func(trial) < func(target) else target  # Elitism\n            \n            self.population = new_population\n\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced differential evolution with self-adapting parameters and elitism strategy for improved convergence speed.", "configspace": "", "generation": 23, "fitness": 0.23135909560519521, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.4622496221659753, 0.6308349737821326, 0.6886814888113804, 0.6167436341319372, 0.7481639379668042, 0.3612151077190576, 0.726323927853976, 0.7448569705316206, 0.19798082372367842, 0.16568799180119653, 0.07114171777431799, 0.45150451444573103, 0.5125081343632505, 0.42302928327403666, 0.11749325423344614, 0.3055778530496114, 0.5236600073796274, 0.4982739545057272, 0.08672607668057208, 0.08029374889653951, 0.0912293623224627, 0.080155117777027, 0.09308310450485446, 0.08658425784464585, 0.08497929965009587, 0.08627316682437924, 0.07552865559231436, 0.08382753587603964, 0.08392583039794066, 0.08184040029331385, 0.07534844038625776, 0.09651826654782958, 0.09221534215299709, 0.10047688350748507, 0.09396875149243444, 0.0836404113176501, 0.8991571783304979, 0.8809313488286197, 0.8393018291555587, 0.8613662045018204, 0.6817154487945496, 0.5909701483647285, 0.6884393099898523, 0.8161266112171554, 0.6338068716675157, 0.1089965262696505, 0.3223770084199902, 0.19542994850177775, 0.26355892749449694, 0.20528152117516152, 0.22033421522849095, 0.1388845930097401, 0.14193783808521798, 0.1811302673594054, 0.6131212269647383, 0.6655995446683325, 0.21693874926218115, 0.6645672470443165, 0.7425205930206249, 0.745293237445163, 0.16877231009061455, 0.2979544032872262, 0.6491464234130035, 0.24139661124618783, 0.12412110607930094, 0.11990410077034541, 0.14049020334427875, 0.11941637635460578, 0.14948822264252026, 0.14303147093078095, 0.1833197335096205, 0.15168055755926013, 0.21664732406671006, 0.12279531429655344, 0.20558297269549153, 0.12350724111755573, 0.23674187872293717, 0.12856773586601178, 0.14940578188345877, 0.15002609504027753, 0.12940105655923395, 0.002249494299921384, 9.999999999998899e-05, 0.07403330739623126, 0.19508259147314988, 0.01274886589479407, 9.999999999998899e-05, 0.0031330056535889828, 0.02758915492838132, 0.22614845023935415, 0.235996366660018, 0.22670386678392973, 0.2195671517326011, 0.12010247990110334, 0.0898802959381676, 0.07365469723042384, 0.20356117640069737, 0.2006794824005721, 0.16777168609664972, 0.03526506755278447, 0.1102228460684862, 0.06671341494001226, 0.11507161632570229, 0.06192561812613262, 0.06314771480945824, 0.17151808756971298, 0.11452976950366522, 0.08132060135001251, 0.12269070907540769, 0.1568318936326839, 0.17243308673630742, 0.2539332424525159, 0.09907922895320465, 0.19641115621156324, 0.16287560729914863, 0.2055499205454313, 0.18139188971280806, 0.45879481604470207, 0.46029965776555803, 0.5430595192957733, 0.42035338312915715, 0.4269210891579266, 0.48693621806488796, 0.4066929289602651, 0.46174789573984987, 0.4738029016244021, 0.08297312023548908, 0.08964214541241855, 0.07787317126115956, 0.09222632080669135, 0.05964892554303547, 0.09247889396178832, 0.09099470758082295, 0.07935094071797288, 0.08414140666947512, 0.15226047465930803, 0.13748304882306062, 0.11608723805680532, 0.1401823586554639, 0.13214599515819592, 0.12865029627600122, 0.15023302269938743, 0.14701261512244768, 0.1349786916429646, 0.2678614734747994, 0.24497799221732908, 0.24307067840190233, 0.25863345260826076, 0.22478126476195126, 0.26233676939505324, 0.31623280000640563, 0.2754184867727296, 0.2835851492585133, 0.2710234000786328, 0.2362142150085006, 0.26329940920699946, 0.3141543577475392, 0.20261779883421582, 0.17255540905564026, 0.18872484552063318, 0.25000028639198413, 0.17227868842283678, 0.16361011258861524, 0.17731763626622654, 0.17422038410043983, 0.19920203759813926, 0.1639983511174552, 0.1708769863887184, 0.17566568471289723, 0.17416956345466716, 0.19094680288841948, 0.1718202026865927, 0.1867385741410439, 0.174264548156296, 0.17532557798199178, 0.16656010463723414, 0.177816948308968, 0.1761733609659497, 0.1885405319450002, 0.16954192612205898, 0.1562119267980443, 0.15093514018112997, 0.14505000786954547, 0.16837228099453627, 0.19317811456979272, 0.1598090321902318, 0.17099768093763945, 0.18524571280375934, 0.15755301496254726, 0.15404019273789948, 0.1651266259842843, 0.3746537589172634, 0.415858729059574, 0.14564546735721995, 0.15384512240682358, 0.2026296759790588, 0.1988583715346034, 0.1952988759190365, 0.16996306556866114, 0.17698847564159714, 0.20003440195333355, 0.1673285438081803, 0.19469823190790647, 0.1760889706644495, 0.17053445672770684, 0.17425704775450135, 0.164791983951886, 0.07058087958677406, 0.07252191391427554, 0.07131626420587878, 0.0666071969138089, 0.05616924440154181, 0.06310930756581223, 0.07483015507536461, 0.07347949584820357, 0.0636889819911135]}, "mutation_prompt": null}
{"id": "dc657960-8df1-4c12-8b23-078ddb723b66", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n                    # Dynamic population resizing\n                    if self.population_size > 20:\n                        self.population_size = max(20, self.population_size // 2)\n                        self.initialize_population()\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Modified Adaptive Differential Evolution with dynamic population resizing to enhance convergence speed and robustness.", "configspace": "", "generation": 24, "fitness": 0.336185085959783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8558067534710863, 0.7120653562976866, 0.835672017635771, 0.8425818862114427, 0.8564035034879076, 0.8218556617277377, 0.8789689009743785, 0.861097555285652, 0.8436811054665991, 0.7370748549103296, 0.6764201053837433, 0.24344332960417014, 0.7565863650529556, 0.708029862881711, 0.7397705776235737, 0.7359702932913363, 0.7150400155809271, 0.017417907966684076, 0.18122792320995074, 0.12641278833400083, 0.11543636802268242, 0.14991191168456297, 0.15013482915834575, 0.11622982942630133, 0.1324443239578622, 0.11873315546305763, 0.13940471548010114, 0.10871947975316876, 0.11821784773048971, 0.14274304522590286, 0.10473429577877269, 0.10021028371296126, 0.11830639113858199, 0.1110314542490729, 0.10392901411871458, 0.11070141773652908, 0.8798791112697484, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.8858604558230023, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.37178708934968396, 0.18783352566599343, 0.2858988673785914, 0.4069972714192467, 0.16035997870998997, 0.3593953806238199, 0.8468334574599534, 0.7768475333130712, 0.6285445350285669, 0.6645412793090701, 0.8319850544678028, 0.7347459926936938, 0.8771454346934292, 0.8414628059036096, 0.7367032514386522, 0.15706054111730738, 0.16197857112410496, 0.12364927714049789, 0.26683293429395527, 0.28033237120723964, 0.3081518650306323, 0.16029071752978763, 0.23992256772361475, 0.17462797812751452, 0.19516394017586103, 0.22359926902688054, 0.1406801924588823, 0.21723867809396913, 0.17598077795579048, 0.12980441364801276, 0.12783242606600143, 0.26924477967967764, 0.3052404582107897, 0.2920201048574803, 0.13269882400444966, 0.12250646229714635, 0.025412445280017515, 0.290193448981371, 0.01015506712917813, 0.08852249147025837, 0.3327016211471332, 0.27626592026787755, 0.4041687152028831, 0.3389759188964425, 0.3384934640253118, 0.12483916317504173, 0.3511515961677857, 0.3401261396199553, 0.1524582748914749, 0.4238889560505885, 0.366181132501176, 0.05220620836060441, 0.12539542502127277, 0.2130993110130407, 0.07408232064815967, 0.21770137756842467, 0.3333143221270528, 0.14977804325225896, 0.2930250074724067, 0.09041150879066806, 0.11871316333810444, 0.1436668176253756, 0.28108792209873346, 0.27071923924101926, 0.2241709163335418, 0.3251671251270186, 0.2146127313272861, 0.24684614955821482, 0.2793957292397907, 0.7288237737384289, 0.5450905925966292, 0.5520746918120754, 0.7775759108539199, 0.6561405404510117, 0.8087139535449772, 0.5119943519169622, 0.6285172705927664, 0.5685607316864372, 0.14056380451002337, 0.09051126264590914, 0.12456490372253426, 0.09706401924562846, 0.13193675058028498, 0.09496867093337136, 0.1210714860388058, 0.08439474336838648, 0.10427537153115063, 0.1472971256939607, 0.12598542058784845, 0.12054533364004727, 0.1520236024329954, 0.18692937878632065, 0.3151379770729772, 0.16025638304468537, 0.2410336204265322, 0.16521591796394985, 0.4364139068086559, 0.5131543720641202, 0.31187036021139636, 0.3641168627400251, 0.3488372538202489, 0.3118947617690837, 0.4277536609546889, 0.44043723463450624, 0.318912033794469, 0.3224190047504061, 0.33764752944103016, 0.3027403218767232, 0.26247736039171665, 0.24785705152166349, 0.23474848037828255, 0.2769175113514032, 0.272806793717303, 0.09473939548414823, 0.1862709506810165, 0.1634302535012494, 0.16342054362485614, 0.1765504840142086, 0.19113565935496057, 0.1800917274961592, 0.18712576595158936, 0.19258630247369857, 0.18809843960033246, 0.29048333727859166, 0.20227047563903888, 0.17771362783729183, 0.26440549536691227, 0.18088606690102949, 0.1849484853535599, 0.3923404862756611, 0.19427925857917006, 0.23291773952522432, 0.16347379650822402, 0.6975795417348972, 0.15050497149040076, 0.8310587346403054, 0.6508206830345746, 0.6469838004405642, 0.7388861417085049, 0.16531908563810904, 0.5080257753951918, 0.6905895069042383, 0.20379648690133378, 0.2025180555693411, 0.20476198117433175, 0.1626544630805149, 0.16712206248163763, 0.20581989383244925, 0.7251714655982322, 0.7595098341857599, 0.1869256281308358, 0.17503591029887944, 0.19545032166751375, 0.1717670201118664, 0.18851341926651488, 0.1685417980988324, 0.1837593802188653, 0.17950431590217375, 0.17133525782643722, 0.07150261680261571, 0.07331750333132336, 0.06548682990713606, 0.06857905748607773, 0.06807612216352665, 0.07488369463184441, 0.07584546347791388, 0.08497975999196972, 0.07539119643308478]}, "mutation_prompt": null}
{"id": "183d7051-382f-48c9-afb2-a0f2f5fe2420", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def local_search(self, individual, func):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbor = np.clip(individual + np.random.uniform(-step_size, step_size, self.dim), self.lb, self.ub)\n        if func(neighbor) < func(individual):\n            return neighbor\n        return individual\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                trial = self.local_search(trial, func)  # Added local search\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedDifferentialEvolution", "description": "Incorporating local search with adaptive parameters to enhance the exploitation phase in differential evolution for faster convergence.", "configspace": "", "generation": 25, "fitness": 0.2795393998067264, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.7141472651059619, 0.7078173854114895, 0.7595175855718298, 0.7499287636717795, 0.6819317102070086, 0.7304317922711681, 0.7303861432128622, 0.7037176894474011, 0.7473710030464373, 0.3624760411376937, 0.4904384930340755, 0.5500995308019717, 0.40191425746642995, 0.5373591353895057, 0.4967044840638779, 0.22643979023349792, 0.5493687370255274, 0.10984407659101725, 0.09120836088592299, 0.11604868515135369, 0.10526896837068689, 0.09265358473757568, 0.10163902257268254, 0.11226668884541668, 0.09874723392341112, 0.09421802384204403, 0.08843273283623332, 0.08789369999859298, 0.1020771563306474, 0.07280520366020826, 0.09135814828544297, 0.0857642846173563, 0.08531581158741497, 0.09828671512141296, 0.09235729277563498, 0.07717565795173575, 0.8832512419139417, 0.8982283058225187, 0.92270680079847, 0.922624507360704, 0.905475985973902, 0.8929614967032086, 0.9005971990948825, 0.8968028800846817, 0.9063599251590321, 0.29461502009486684, 0.22684878704732347, 0.29183441850205905, 0.28268231789907927, 0.3264032470069749, 0.3186057403069481, 0.3056218885930282, 0.30667372704663054, 0.24005899492458294, 0.6843093113906257, 0.3219164187078103, 0.6848663097831342, 0.6868347608380855, 0.5998633488871356, 0.5140899595668844, 0.6130343923147517, 0.6751590715785407, 0.6868595781050573, 0.18220601785297197, 0.1567274638015449, 0.1545602033112926, 0.18756584466034143, 0.14101824944965535, 0.17486252525742962, 0.20225299693502952, 0.18742200922838692, 0.2089164949242479, 0.13404415498676336, 0.13288741864464404, 0.2031501624103026, 0.13266556049458433, 0.17737812208279757, 0.23868743134057246, 0.16620186501358625, 0.15932860438155416, 0.14990659199977596, 0.06720819625375207, 0.17718829070397313, 0.054269265838572944, 0.05856037999148378, 0.14491614805159914, 0.007033547266520723, 0.04981823561488685, 0.005297672553849386, 0.1711716876430459, 0.2577216175093907, 0.05920339846530387, 0.2296836118579333, 0.3146964176450048, 0.1230457266547641, 0.2822400820407295, 0.3700651646711881, 0.27451378454377595, 0.1966782205382397, 0.12372003388549802, 0.15495384603666917, 0.05525500459822874, 0.1038656667624156, 0.08718487508587913, 0.10758039646360962, 0.10871793202294289, 0.05254581040038142, 0.08490524034753599, 0.1703726617043254, 0.1351876112782684, 0.22025255954486123, 0.17928324639662607, 0.2190904689093962, 0.1827461352288362, 0.20648244699021412, 0.12717761184871956, 0.15154956509345574, 0.5060024775219654, 0.5649393087033241, 0.6198078293027741, 0.5315439080265296, 0.49863413843960136, 0.48883035543668973, 0.4994613241022019, 0.5886015112291755, 0.565844511014548, 0.10024668154064986, 0.0946861431226873, 0.0788724116098094, 0.08278570743078417, 0.08521249573271394, 0.09192836034525065, 0.08358303091756059, 0.07506318958422142, 0.09277921883160745, 0.12267162184750291, 0.15785372160272204, 0.12750968649400818, 0.1229403811839126, 0.13741674755567967, 0.13977514641521416, 0.12561935012432546, 0.13433110438646867, 0.12841808197675786, 0.32039601236425974, 0.3557729612064676, 0.2909475496451023, 0.3498906994083828, 0.3162812626336726, 0.33871996477838007, 0.3012282998090614, 0.3864010930861196, 0.3116910264538143, 0.20873555855683157, 0.23952629849703422, 0.20617512772924862, 0.23164658772610824, 0.20535014940546648, 0.23363934711631107, 0.21662149659790397, 0.22268438252874256, 0.2454295364461615, 0.17527402280730242, 0.1815163073305528, 0.1775805688803297, 0.21240785864875156, 0.1803996022603478, 0.17190672347661506, 0.1775808777033595, 0.1990427753645415, 0.18164428939566468, 0.18744842119382243, 0.17551499251279112, 0.1738235936572735, 0.19873648229077945, 0.17672854397743654, 0.1725527919100014, 0.18155292375228815, 0.18166414330437697, 0.1844044104864997, 0.18573661008038744, 0.3767601585847058, 0.14581109683446103, 0.6187034430495606, 0.1754908108817297, 0.7558904350226643, 0.4029554713793265, 0.27080093361472, 0.28254955689454764, 0.3576964279845207, 0.29881813397860546, 0.7105467769780511, 0.35848837674412803, 0.5790699309320424, 0.15447442345063533, 0.1650448394962204, 0.15250493767467577, 0.4827822650638818, 0.17577822269976928, 0.17010973064935064, 0.1789839974999573, 0.17841528946841956, 0.17509809317179426, 0.17120762310855497, 0.21130460391216166, 0.17402473364643078, 0.17731725681302835, 0.07184473461838659, 0.07954307873924882, 0.0665213022754626, 0.06849351871305587, 0.0673329021053074, 0.07070196913508753, 0.07089709452529136, 0.07547334796353877, 0.07040203523715804]}, "mutation_prompt": null}
{"id": "0eb16651-aa70-483b-86d8-21f89de5d1e7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.05)  # Increase mutation scaling slightly\n                    self.base_CR = max(0.85, self.base_CR - 0.05)  # Slightly reduce crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution with dynamic mutation scaling and selection pressure adjustment for improved convergence.", "configspace": "", "generation": 26, "fitness": 0.3308106689316809, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8556440140308044, 0.7120653562976866, 0.8545918830422932, 0.8425818862114427, 0.8564035034879076, 0.8369696687794136, 0.8789689009743785, 0.861097555285652, 0.8462054324638797, 0.7751050156631348, 0.6764201053837433, 0.24344332960417014, 0.7673002775350446, 0.708029862881711, 0.7385015920623637, 0.7359702932913363, 0.7174975201418103, 0.017417907966684076, 0.16118900862254648, 0.12396325121783158, 0.16249849670874827, 0.11005708523364943, 0.11773979083029606, 0.1443082847888254, 0.1411359538160023, 0.12897526247632018, 0.134955125469308, 0.11374496975056536, 0.11941748249978479, 0.13971500197309994, 0.14405704287402987, 0.11885310930453763, 0.11314463198932556, 0.12372500014315957, 0.11125275272662127, 0.12834159035511516, 0.8572593692089246, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.9361646247167348, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.49274735170681205, 0.18783352566599343, 0.2858988673785914, 0.3021979013915861, 0.16035997870998997, 0.43217447517663443, 0.8468334574599534, 0.6109386937006035, 0.5258550311346903, 0.4393634877796275, 0.8439556869607705, 0.757175753561773, 0.8771454346934292, 0.6389646160877515, 0.7100449310216576, 0.14766377261888775, 0.16231766886940657, 0.12364927714049789, 0.16815553179559195, 0.42083831909823277, 0.4929718073157111, 0.16029071752978763, 0.38757154351351475, 0.19999032588136745, 0.16296952676386156, 0.15466265227476927, 0.1406801924588823, 0.2950018329068602, 0.17598077795579048, 0.15780069149892428, 0.12788001782021197, 0.1542411587247987, 0.17065821379521895, 0.20658870270927665, 0.1334672730570723, 0.09667142898104741, 0.025412445280017515, 0.33349513667931585, 0.03461574669181866, 0.08729089565825521, 0.19598365543329466, 0.21208880648170358, 0.262198044070277, 0.28994616162250064, 0.3369131921952815, 0.14685980000675902, 0.265447235218212, 0.2997822592072359, 0.15871102909808998, 0.3571038815313755, 0.3817633900603299, 0.07022646972886926, 0.12401807772140216, 0.20480904205198114, 0.07408232064815967, 0.27538296193650835, 0.2824136434064892, 0.1557832411554576, 0.18993435580001805, 0.09065603195902461, 0.11871316333810444, 0.12837178938455696, 0.3140199498038745, 0.27071820445398986, 0.2929964151859281, 0.31975624999997143, 0.21461262054943742, 0.23026528232639498, 0.29026190728557544, 0.711546415125881, 0.5450905925966292, 0.5520746918120754, 0.6917221875698409, 0.6381830411474225, 0.791485968177333, 0.5119943519169622, 0.7092324461015207, 0.6841114529216097, 0.11921377192475069, 0.08354858995688719, 0.11006842643787496, 0.10916990231022228, 0.09214465174722353, 0.08343419133793506, 0.11145039788982736, 0.09628769557157335, 0.11603589967525063, 0.1302183829108664, 0.13561665037998938, 0.18289917465891303, 0.2333225078420842, 0.2294384145351256, 0.22960911538693374, 0.1233615504186355, 0.24090038508386613, 0.1677287937126326, 0.4714258922783374, 0.5400398535692712, 0.3891808759091383, 0.39685330696258414, 0.37755551073023075, 0.29595776824599873, 0.4098897124416049, 0.5152814272862107, 0.3430315908977465, 0.304759036574627, 0.3097194337336867, 0.31285706379439904, 0.2741002484386903, 0.22096697581944202, 0.2839178414448228, 0.26271174303784617, 0.29912245918939784, 0.0929283835510103, 0.21655626867887823, 0.174722873726726, 0.1742557156350385, 0.18149095432205342, 0.17539443567138913, 0.1908559322393909, 0.19707529682762426, 0.20749298798576943, 0.1775590066959598, 0.19153416894736675, 0.280954033000529, 0.20394970053045525, 0.26721933609363246, 0.2998969070754063, 0.19305568915847227, 0.21758231591142874, 0.1889108687542146, 0.240524046123341, 0.16347379650822402, 0.7766990627135207, 0.1513913237218194, 0.8552877005433351, 0.8064889143804507, 0.44745433481998487, 0.2014357940522855, 0.16535030948688767, 0.15961811071150933, 0.6815711754155878, 0.20379648690133378, 0.5429213743529278, 0.2043113116509947, 0.5965547173654634, 0.16712206248161676, 0.18943849874435026, 0.11518693290153237, 0.7909506704958702, 0.17859744693160118, 0.16597948016488406, 0.18331461484876221, 0.1691882029453443, 0.16911873020099122, 0.18716511590662332, 0.18387186087131113, 0.17887819694792584, 0.17420633664620766, 0.07768844167859812, 0.07276787246761651, 0.07604819350588188, 0.07867812142631703, 0.07334602925630662, 0.07437285079176836, 0.08011822379974565, 0.06210973070531001, 0.07899774918659919]}, "mutation_prompt": null}
{"id": "fab6a572-2679-4b2f-8eae-2db229c570cd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def dynamic_population_resize(self, evals):\n        # Reduce population size as budget diminishes for faster convergence\n        if self.budget - evals < self.population_size:\n            self.population_size = max(20, self.population_size // 2)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            self.dynamic_population_resize(evals)\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "A modified differential evolution incorporating dynamic population resizing for better adaptability and convergence.", "configspace": "", "generation": 27, "fitness": 0.336185085959783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8558067534710863, 0.7120653562976866, 0.835672017635771, 0.8425818862114427, 0.8564035034879076, 0.8218556617277377, 0.8789689009743785, 0.861097555285652, 0.8436811054665991, 0.7370748549103296, 0.6764201053837433, 0.24344332960417014, 0.7565863650529556, 0.708029862881711, 0.7397705776235737, 0.7359702932913363, 0.7150400155809271, 0.017417907966684076, 0.18122792320995074, 0.12641278833400083, 0.11543636802268242, 0.14991191168456297, 0.15013482915834575, 0.11622982942630133, 0.1324443239578622, 0.11873315546305763, 0.13940471548010114, 0.10871947975316876, 0.11821784773048971, 0.14274304522590286, 0.10473429577877269, 0.10021028371296126, 0.11830639113858199, 0.1110314542490729, 0.10392901411871458, 0.11070141773652908, 0.8798791112697484, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.8858604558230023, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.37178708934968396, 0.18783352566599343, 0.2858988673785914, 0.4069972714192467, 0.16035997870998997, 0.3593953806238199, 0.8468334574599534, 0.7768475333130712, 0.6285445350285669, 0.6645412793090701, 0.8319850544678028, 0.7347459926936938, 0.8771454346934292, 0.8414628059036096, 0.7367032514386522, 0.15706054111730738, 0.16197857112410496, 0.12364927714049789, 0.26683293429395527, 0.28033237120723964, 0.3081518650306323, 0.16029071752978763, 0.23992256772361475, 0.17462797812751452, 0.19516394017586103, 0.22359926902688054, 0.1406801924588823, 0.21723867809396913, 0.17598077795579048, 0.12980441364801276, 0.12783242606600143, 0.26924477967967764, 0.3052404582107897, 0.2920201048574803, 0.13269882400444966, 0.12250646229714635, 0.025412445280017515, 0.290193448981371, 0.01015506712917813, 0.08852249147025837, 0.3327016211471332, 0.27626592026787755, 0.4041687152028831, 0.3389759188964425, 0.3384934640253118, 0.12483916317504173, 0.3511515961677857, 0.3401261396199553, 0.1524582748914749, 0.4238889560505885, 0.366181132501176, 0.05220620836060441, 0.12539542502127277, 0.2130993110130407, 0.07408232064815967, 0.21770137756842467, 0.3333143221270528, 0.14977804325225896, 0.2930250074724067, 0.09041150879066806, 0.11871316333810444, 0.1436668176253756, 0.28108792209873346, 0.27071923924101926, 0.2241709163335418, 0.3251671251270186, 0.2146127313272861, 0.24684614955821482, 0.2793957292397907, 0.7288237737384289, 0.5450905925966292, 0.5520746918120754, 0.7775759108539199, 0.6561405404510117, 0.8087139535449772, 0.5119943519169622, 0.6285172705927664, 0.5685607316864372, 0.14056380451002337, 0.09051126264590914, 0.12456490372253426, 0.09706401924562846, 0.13193675058028498, 0.09496867093337136, 0.1210714860388058, 0.08439474336838648, 0.10427537153115063, 0.1472971256939607, 0.12598542058784845, 0.12054533364004727, 0.1520236024329954, 0.18692937878632065, 0.3151379770729772, 0.16025638304468537, 0.2410336204265322, 0.16521591796394985, 0.4364139068086559, 0.5131543720641202, 0.31187036021139636, 0.3641168627400251, 0.3488372538202489, 0.3118947617690837, 0.4277536609546889, 0.44043723463450624, 0.318912033794469, 0.3224190047504061, 0.33764752944103016, 0.3027403218767232, 0.26247736039171665, 0.24785705152166349, 0.23474848037828255, 0.2769175113514032, 0.272806793717303, 0.09473939548414823, 0.1862709506810165, 0.1634302535012494, 0.16342054362485614, 0.1765504840142086, 0.19113565935496057, 0.1800917274961592, 0.18712576595158936, 0.19258630247369857, 0.18809843960033246, 0.29048333727859166, 0.20227047563903888, 0.17771362783729183, 0.26440549536691227, 0.18088606690102949, 0.1849484853535599, 0.3923404862756611, 0.19427925857917006, 0.23291773952522432, 0.16347379650822402, 0.6975795417348972, 0.15050497149040076, 0.8310587346403054, 0.6508206830345746, 0.6469838004405642, 0.7388861417085049, 0.16531908563810904, 0.5080257753951918, 0.6905895069042383, 0.20379648690133378, 0.2025180555693411, 0.20476198117433175, 0.1626544630805149, 0.16712206248163763, 0.20581989383244925, 0.7251714655982322, 0.7595098341857599, 0.1869256281308358, 0.17503591029887944, 0.19545032166751375, 0.1717670201118664, 0.18851341926651488, 0.1685417980988324, 0.1837593802188653, 0.17950431590217375, 0.17133525782643722, 0.07150261680261571, 0.07331750333132336, 0.06548682990713606, 0.06857905748607773, 0.06807612216352665, 0.07488369463184441, 0.07584546347791388, 0.08497975999196972, 0.07539119643308478]}, "mutation_prompt": null}
{"id": "c1fc178a-24d2-4bd2-b7b0-576da1a8e171", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.success_history = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def adaptive_weight(self, trial_value, target_value):\n        weight = 1 if trial_value < target_value else np.random.rand() * 0.5\n        return self.base_F * weight\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n            self.success_history.append(True)\n        else:\n            self.success_history.append(False)\n        target_value = func(self.population[target_idx])\n        weight = self.adaptive_weight(trial_value, target_value)\n        if trial_value < target_value:\n            self.population[target_idx] = trial\n        else:\n            self.base_F *= weight\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introducing adaptive weighting based on success history to enhance exploration and convergence balance in differential evolution.", "configspace": "", "generation": 28, "fitness": 0.07182865206262098, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.07.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.16651021868956573, 0.10333466877527608, 0.1633142186421226, 0.10678188633859975, 0.08416643289547177, 0.17169776307108098, 0.13042000452066238, 0.11799316586673614, 0.07768351420286368, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0775430298309584, 0.036899238552166924, 0.08655192775552678, 0.04507512036629979, 0.01756200187801582, 0.055292485373532485, 0.036653575351910495, 0.04236576468736786, 0.06276990572056618, 0.017282383102536047, 0.03222954942715206, 0.02059286285601014, 0.0421679512715909, 0.0262483711168785, 0.008765164378796375, 9.999999999998899e-05, 0.010855041696789303, 0.031512314004714104, 0.06972814742406586, 0.05850764473620074, 0.05157962764925306, 0.09834106810616561, 0.08018620493835171, 0.0713684124634889, 0.09467383677657326, 0.0792609644950224, 0.08954595362630369, 0.0047898762920906, 9.999999999998899e-05, 0.020440503173198565, 0.0012493382627483118, 0.010110828371182823, 0.03096703802780809, 0.0716203856832548, 0.015303294645028886, 9.999999999998899e-05, 0.15416957843175694, 0.04985185459135788, 0.04945819149601538, 0.07945824725633444, 0.05001089276648141, 0.04531621435290056, 0.06168490294534745, 0.0919474501352241, 0.12327581416584232, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0024322976187292067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03402836933509412, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.057549144501955585, 0.025069930035245713, 0.06302671338267452, 0.06476788399148847, 0.0394845365632438, 9.999999999998899e-05, 9.999999999998899e-05, 0.02738244350757235, 0.07354329483388888, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15558682832330473, 0.1713677266182767, 0.15992971301016656, 0.24536778998000652, 0.13947857424229915, 0.1508098564624767, 0.15189156708135165, 0.11568706066860068, 0.16592119134646277, 0.020971621306809518, 0.010411132826103286, 0.0009959094238026767, 0.05845683492356091, 0.03023062939685406, 0.06495947950030057, 0.03694963293108544, 0.05995199751281455, 0.07062557956443982, 0.11903026597875177, 0.12747684669979586, 0.0970214897816204, 0.17049135379246094, 0.1210550359113699, 0.13263079483087603, 0.1723974302454504, 0.09525196012176818, 0.15359683311748884, 0.17349048658456523, 0.14472176610103105, 0.16499516782534485, 0.15807562748666237, 0.12054328008545867, 0.1515054598470852, 0.13147377983263608, 0.22779378905655434, 0.10715097772797999, 0.1318004007833259, 0.09687034587021648, 0.113368666121336, 0.06947991490373606, 0.0689003996385893, 0.10172610780669677, 0.10032081890220634, 0.1301125862731275, 0.05017014214810189, 0.17678223575005036, 0.20947872583648297, 0.18339032699999613, 0.21047142904702487, 0.17691938908179672, 0.19009099585370337, 0.16911738946459287, 0.20143046278363275, 0.18254143106702092, 9.999999999998899e-05, 9.999999999998899e-05, 0.1397110084179003, 0.17993797185910443, 9.999999999998899e-05, 0.06919043986158102, 0.14172740441938636, 0.12842678010377162, 9.999999999998899e-05, 0.12150983855669528, 0.11423103706874338, 0.1214300349874764, 0.09545236314505923, 0.14381451110989762, 0.14320515217009, 0.08144735939822545, 0.164928127367164, 0.12244401828024543, 0.0539522273208447, 0.09173452641851887, 0.0664103308058227, 0.0865905413785909, 0.09656353875019907, 0.14148307697787676, 0.07816933204396415, 0.1662034670481196, 0.08139793550525087, 0.18402494583691142, 0.1920930270989185, 0.2156943885130187, 0.21570344550056475, 0.19286328193865188, 0.1724750632791311, 0.19195380895037084, 0.2096945408319908, 0.18187905806874538, 0.047337332221022765, 0.0443655538529798, 0.057043668303249584, 0.05850325041707605, 0.06272422237517117, 0.0491497354937348, 0.04296461359877035, 0.05114615072944306, 0.05564505208951975]}, "mutation_prompt": null}
{"id": "5dbbb82a-450a-4523-8715-1cd439823338", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.memory_F = []\n        self.memory_CR = []\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        memory_F_avg = np.mean(self.memory_F) if self.memory_F else 0.5\n        adaptive_F = np.clip(self.base_F + memory_F_avg * (np.random.rand() - 0.5), 0.1, 0.9)\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        memory_CR_avg = np.mean(self.memory_CR) if self.memory_CR else 0.9\n        adaptive_CR = np.clip(self.base_CR + memory_CR_avg * (np.random.rand() - 0.5), 0.1, 0.9)\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n            self.memory_F.append(self.F)  # Update memory for F\n            self.memory_CR.append(self.CR)  # Update memory for CR\n            if len(self.memory_F) > 5:  # Limit memory size\n                self.memory_F.pop(0)\n                self.memory_CR.pop(0)\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced differential evolution with adaptive strategies and memory to improve mutation factor and crossover rate for faster convergence.", "configspace": "", "generation": 29, "fitness": 0.3287993353397083, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.838503304294042, 0.8633794955255252, 0.8535192186640191, 0.7991630457543575, 0.8240167225710789, 0.8511196068234022, 0.8236004168657325, 0.8516655419172274, 0.8695724909119504, 0.699256959259039, 0.688635162559301, 0.6760180702924478, 0.72422548769539, 0.6868723440705924, 0.7418884604393168, 0.7391337026566944, 0.7433987605514242, 0.7318337214681738, 0.13157386385171554, 0.13334774196327803, 0.17400711323964957, 0.1301824856532645, 0.187567992751694, 0.19047421085558303, 0.177573050678276, 0.14158935110234872, 0.1440954978817114, 0.10078378736188043, 0.14263869330652268, 0.12186302396977367, 0.09906266774315042, 0.1048694744134091, 0.11575342746915407, 0.128564608671357, 0.19249388336626538, 0.12638811454929688, 0.9020393550821498, 0.9510145053245013, 0.9526064605867927, 0.9239958802925412, 0.9421539353881144, 0.9036434688022303, 0.9085275741027234, 0.9249110998991659, 0.943619763221909, 0.5055531589680118, 0.22676376832612155, 0.4384808372166511, 0.31379228728308994, 0.4190642687176823, 0.27309490215882304, 0.3638907573424859, 0.1850801632801905, 0.3559937375903265, 0.5964123246531003, 0.21967710158204212, 0.7570293329343731, 0.6057955416362728, 0.7150337287719037, 0.726613181805091, 0.7536106677237339, 0.6929038148675742, 0.7749437463013367, 0.1988488270411296, 0.294886400934369, 0.30494509919358825, 0.19652591910459316, 0.2438285205544264, 0.12602745705633878, 0.29063264867846517, 0.15776142704302476, 0.15537853423651649, 0.23432588650946684, 0.2432871663220436, 0.22235493743669532, 0.27882727964988807, 0.22707283743949702, 0.23712215924050228, 0.12029658893080208, 0.1959421509447794, 0.15061642503224504, 0.11209767675962357, 0.040873336288722584, 0.1522165530565267, 0.2068617103546332, 0.15399911595285576, 0.138095110145674, 0.12901985944999428, 0.10772224397804042, 0.30800975677693254, 0.28019009583604204, 0.23681769428889066, 0.21873904031270686, 0.2397761683210876, 0.2137623327607775, 0.29339750514980933, 0.3090104730899086, 0.26945721401313705, 0.2720895410013211, 0.15557523253657457, 0.11159841688968886, 0.05472083228571323, 0.15440980508587032, 0.12345612814422802, 0.14847180247559466, 0.13226659087557235, 0.10494504467739885, 0.1539358360406301, 0.22933265590321839, 0.204082272374707, 0.17954948748194943, 0.203015522218574, 0.3135295757437213, 0.17263495613826474, 0.3063485221076411, 0.17422804752913112, 0.25978804615475715, 0.600531517941058, 0.5684999906708068, 0.6970465516291837, 0.6473572693938479, 0.625133707242941, 0.6194560136619633, 0.5999885171191759, 0.5933692322219228, 0.5501777941102416, 0.08595664026489558, 0.08445756447098152, 0.08092780650970055, 0.08946998405850848, 0.09434849240976217, 0.11806719748981653, 0.09439830702752383, 0.11471388242289482, 0.09296345991305466, 0.14409481776816957, 0.16002684510624843, 0.14001392653955214, 0.1388265867509635, 0.15208003382302104, 0.13652736823947254, 0.12237895918465602, 0.15401789409142586, 0.12548090745759344, 0.32626877805721544, 0.3235520602792883, 0.3010957626632449, 0.36376450939860505, 0.3206704141752942, 0.3184717584406691, 0.33545280441773717, 0.35469704480145337, 0.5158826919192407, 0.2209675711972261, 0.24587559873049236, 0.2365032434293466, 0.24019609417634402, 0.1826252306372469, 0.18858128960009934, 0.24462530489705292, 0.2761194175819738, 0.27857301557455827, 0.17803111350790646, 0.1726922687483653, 0.17151906690578034, 0.1736134596972665, 0.2003825363196584, 0.1870310163222032, 0.1879626646039907, 0.1782052701888881, 0.20324005392259314, 0.28844780025397887, 0.18525562468719958, 0.23124001320208054, 0.2818708346755622, 0.21669013575719287, 0.1790589809702844, 0.20607758555270206, 0.20293212621008128, 0.19781441690344237, 0.6777953655639355, 0.6730247094278541, 0.20392698390298014, 0.6411360302337032, 0.5189639604210434, 0.6519416156649532, 0.186221975280205, 0.5511433408048049, 0.6074498012140133, 0.19321420936889588, 0.20416609753302128, 0.6044588699465726, 0.44499998845472577, 0.19370541771463057, 0.4652871771380439, 0.4402917818169858, 0.2060750257568552, 0.20203108945278325, 0.1801222466367015, 0.16508444436656722, 0.1685087177794532, 0.16999143217647084, 0.1741630522733476, 0.20308023323116764, 0.17481678855165594, 0.17202925575708417, 0.17788737244772423, 0.06923208211000043, 0.07489218809967058, 0.07735399096541629, 0.0716229937556514, 0.07332827507689021, 0.06746739748560304, 0.061938066439377826, 0.07674799591404569, 0.08267630213322752]}, "mutation_prompt": null}
{"id": "3e2438b7-71af-4a9c-a34a-4c8786d789c4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.performance_history = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def adjust_population(self):\n        if len(self.performance_history) >= 5:\n            last_values = self.performance_history[-5:]\n            if all(x >= y for x, y in zip(last_values, last_values[1:])):\n                self.population_size = max(20, int(self.population_size * 0.9))\n                self.initialize_population()\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            self.performance_history.append(self.best_value)\n            self.adjust_population()\n\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "AdaptiveDifferentialEvolution with dynamic population resizing based on historical performance for improved convergence.", "configspace": "", "generation": 30, "fitness": 0.09653404990090506, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.08.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.19079180183168032, 0.15941393632581402, 0.19938181615212647, 0.17841018738845937, 0.1805764560229609, 0.200240512498446, 0.18142008108532803, 0.184007128033576, 0.15725910241015517, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052456872503991114, 0.03946895454681176, 0.04284664832719265, 0.05315306950753895, 0.03910232663477786, 0.04164871987265506, 0.04315407405484217, 0.05954323790126259, 0.049631997097323244, 0.02510195592534381, 0.03398831225132326, 0.037870403678019304, 0.03734185072100482, 0.0418457348279353, 0.06173513118634599, 0.04282941295129872, 0.042628366498093095, 0.03097862466333101, 0.13000487985306186, 0.1451444182630357, 0.1330302520920421, 0.48037737789580015, 0.1688504920791738, 0.1633221542143991, 0.20906668517220228, 0.1275903709115246, 0.5495167950248333, 0.07088141952207772, 0.09271976427312534, 0.07065361121506153, 0.08341739727836306, 0.07972961640992726, 0.05543107378084655, 0.04986790005982278, 0.07813671266539934, 0.08373375124627513, 0.11816659681958641, 0.13609714589269695, 0.10858654903068943, 0.11963086393570044, 0.11619926774983125, 0.11273667704162782, 0.14894791593020584, 0.11112928476392758, 0.1533846628738873, 9.999999999998899e-05, 0.010368006550226738, 9.999999999998899e-05, 9.999999999998899e-05, 0.062163701569143304, 0.0010973612457452209, 0.0008146643001165632, 0.021013431197026478, 0.009706656532801006, 0.003645753367575333, 0.005666223374627188, 0.003239520918016603, 0.004832028736083016, 0.013465619933791473, 0.0021600859589547827, 0.00511523860392904, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060636591300137654, 0.05503348404814479, 0.04139144299527764, 0.040200785859598964, 0.10267473001192196, 0.07609895996649707, 0.04271519062568119, 0.08800239447038294, 0.052984621676334664, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019608157562778228, 0.18147122183612585, 0.17428171218986122, 0.1938453180303239, 0.20356256986097054, 0.18244192775908996, 0.18676918149708321, 0.1795744309765498, 0.19211120653805291, 0.19564479078857266, 0.046629050634960145, 0.037216155813931784, 0.041957142574344686, 0.037868677139637485, 0.050041295733142754, 0.05343286112478329, 0.03994591131511993, 0.0450930496294768, 0.048648680808845546, 0.12407365026949413, 0.14940819961663643, 0.12417342766317763, 0.17225673146261977, 0.13654885204734513, 0.15763542649604767, 0.12146875516517353, 0.16516020819154398, 0.1403527336468796, 0.18358149460803197, 0.18258190821926779, 0.17704728697522265, 0.1640620729128488, 0.1547479084658091, 0.17099331543402463, 0.15683087405152696, 0.17366431494391765, 0.1602974924946955, 0.11069397661207203, 0.13136581521732182, 0.11986185025344043, 0.11383089219786358, 0.09930139731345133, 0.11265508889871145, 0.12569676704801425, 0.09499715122311703, 0.10713616959610406, 0.14677634790228622, 0.15156070624373263, 0.1686306818878054, 0.1581553265571587, 0.14607679277078134, 0.16629684892318986, 0.16766688479042446, 0.14434442351029597, 0.16861049433939657, 0.15512257816406727, 0.15644813780714795, 0.14685317798688924, 0.1526026942262897, 0.13591120958890535, 0.14306207903170365, 0.15880952578097618, 0.1547632941536523, 0.1514899605957265, 0.16848458897570584, 0.15792504895477466, 0.1546814977149441, 0.15191951162763817, 0.16384898280634264, 0.16719868479121192, 0.1724066714205763, 0.2188482698675468, 0.15856159344794374, 0.2043252677075046, 0.14902929768618467, 0.1516875464712497, 0.19014153817180757, 0.18019686388212142, 0.12992400721718145, 0.13827730354713896, 0.15504841959098536, 0.1537818803330312, 0.19100842927936257, 0.18167221206393835, 0.1856630400476199, 0.1839005925226288, 0.18887222732956543, 0.19812413316521393, 0.17553553066597416, 0.213045434609616, 0.19483630805896002, 0.0461852507205287, 0.05909688647329436, 0.04995765433586763, 0.054082713491024115, 0.049714312246596615, 0.047589181167904115, 0.050032600788332826, 0.050034464369626996, 0.061173797799484286]}, "mutation_prompt": null}
{"id": "e8cd2748-eb5b-40e6-a40c-11cb14bb906c", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def adapt_mutation_factor(self):\n        diversity = np.std(self.population, axis=0).mean()\n        if diversity < 1e-5:\n            self.base_F = max(0.4, self.base_F - 0.05)\n        else:\n            self.base_F = min(0.9, self.base_F + 0.05)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n            # Dynamic mutation factor adaptation based on population diversity\n            self.adapt_mutation_factor()\n\n        return self.best_individual, self.best_value", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "An improved adaptive differential evolution with dynamic mutation factor adaptation based on population diversity for enhanced convergence speed.", "configspace": "", "generation": 31, "fitness": 0.2735455611573927, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.6338957240896899, 0.636468594082557, 0.6055110240921108, 0.707452039398141, 0.6259445176399147, 0.7061580352828298, 0.649457928736721, 0.6394086772960024, 0.656980328920098, 0.39601394052897965, 0.40665249982599627, 0.38605798621435883, 0.39899769673016816, 0.4211846084714097, 0.3666842032470431, 0.34218936598941807, 0.3889223026296884, 0.4337748821247116, 0.13101148737672463, 0.10560504802071213, 0.09386785069582781, 0.10249663274881127, 0.11097236915109132, 0.10292590800247858, 0.11589203130320058, 0.09731059705329059, 0.10498385192820292, 0.10277069763547697, 0.10330689817208927, 0.10182217402949667, 0.09603454189082694, 0.08808750206036198, 0.08801109797227713, 0.08862753823812597, 0.1253344353835455, 0.11274125745397157, 0.9610636387790217, 0.9226398418295755, 0.9570902253809996, 0.9214455821707772, 0.9579441465971982, 0.9700129085145142, 0.9362639419510649, 0.9576653295747051, 0.9599241345780284, 0.27934634619896426, 0.2703939352894613, 0.31825151827206377, 0.3061737621069385, 0.31607053985897293, 0.2786742185170711, 0.2913221559387422, 0.3081512630443368, 0.3032819999096992, 0.6730219822364362, 0.27904203765170155, 0.6076038947096098, 0.6329177724997147, 0.5224617721307729, 0.6556854669521783, 0.5679904811058782, 0.5588418252339254, 0.6064687456458846, 0.2514684573246754, 0.21389867429362353, 0.23387242020082388, 0.18565416342878804, 0.19854591513970143, 0.13306759673993407, 0.20960545760164473, 0.23152757940094015, 0.20377149324991806, 0.22685767857040673, 0.050704040649813376, 0.21337306341290507, 0.1635680732867706, 0.26110538204218936, 0.2507985078398932, 0.1460293944417863, 0.2187253110265981, 0.2509783546838864, 0.14066704475916958, 0.11988901552675468, 0.14128669625513524, 0.1746795312480406, 0.12739424861710646, 0.11446021429115039, 0.18572653760447455, 0.13438946420929765, 0.1515464993568203, 0.2391086945434262, 0.2783398173789958, 0.2858670716393562, 0.27021857767300295, 0.3025528951794433, 0.261037627784546, 0.31265053841217405, 0.2937309421980019, 0.274544183384525, 0.04963001596478367, 0.05892109566836112, 0.02348563053326702, 0.0636726779277138, 0.024978468388420327, 0.06313006494951823, 0.08898058068501691, 0.058282559152979974, 0.050822285050862726, 0.15483483900736805, 0.180096933212896, 0.1471015265380713, 0.21233707468414753, 0.19798348526205944, 0.18645839369003414, 0.13641620777121022, 0.16335599593673056, 0.1947129269349397, 0.5226144765391977, 0.49090434839236063, 0.49709863776210383, 0.5349765607361165, 0.512022749479377, 0.5149289792609122, 0.510957371974633, 0.4508790142013387, 0.5100712475272212, 0.08778927769659928, 0.0764996977486051, 0.08588655604753381, 0.0859718855847117, 0.10465833684264103, 0.09482738734090068, 0.08369279603389113, 0.08445885619512683, 0.07146484657277707, 0.12590861778103513, 0.14716555067753723, 0.14541805903652294, 0.16258625635142, 0.13873855395048063, 0.07611046449600622, 0.1915687459623372, 0.12581774838698312, 0.16837712482954703, 0.28627403558499753, 0.2731107531387521, 0.26837423759343015, 0.29287201309749855, 0.259062909851949, 0.24373992321285542, 0.2814280864687343, 0.27871335296246935, 0.2979610802024687, 0.1969222156474587, 0.22800345776101316, 0.21526560549304763, 0.20538711229326168, 0.20704198020026576, 0.16746143546139425, 0.2065366139770185, 0.23488372704444038, 0.22377889193662148, 0.17571266332513114, 0.1805177249819706, 0.16866455271387226, 0.20851188201814697, 0.19006479412375343, 0.17425175731310705, 0.18985595840456482, 0.16673383576110823, 0.17745148443823122, 0.28808096538056593, 0.1692553286917482, 0.18042752006708196, 0.1682460365675803, 0.22290076954538252, 0.18015785877705115, 0.18309292166376678, 0.18705835725498388, 0.17089879172268796, 0.1717472615246437, 0.19772809357227894, 0.14645449345038686, 0.17494514839136177, 0.5514746371588628, 0.6998128359557843, 0.13378817805614684, 0.19390302526638048, 0.18805518801538068, 0.16618795933555253, 0.1871296929597961, 0.5732663532570731, 0.19449275528209276, 0.15493418713749196, 0.20169921909373234, 0.15144336169915462, 0.6402282955095044, 0.679340520281888, 0.18004347776004037, 0.17022660700820447, 0.20263066500397175, 0.18308529849995736, 0.18122261698381004, 0.16760675133667446, 0.1823645041017372, 0.1845835841055833, 0.18013799606032355, 0.06745180266046558, 0.06690194462892174, 0.063654058762451, 0.06479715898562843, 0.06605303445245003, 0.07269589020736311, 0.0673894095163039, 0.06132629396243405, 0.06679646207798473]}, "mutation_prompt": null}
{"id": "359eee00-8d29-40f5-b6e0-55841707afb1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.dynamic_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.dynamic_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def dynamic_population_resize(self, evals):\n        if evals > self.budget * 0.5 and self.population_size > 20:\n            self.population_size -= 1\n            self.population = self.population[:self.population_size]\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.dynamic_F = min(0.9, self.dynamic_F + 0.1)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            \n            prev_best_value = self.best_value\n            self.dynamic_population_resize(evals)\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced differential evolution with adaptive population resizing and dynamic scaling factor adjustment for accelerated convergence.", "configspace": "", "generation": 32, "fitness": 0.336185085959783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8558067534710863, 0.7120653562976866, 0.835672017635771, 0.8425818862114427, 0.8564035034879076, 0.8218556617277377, 0.8789689009743785, 0.861097555285652, 0.8436811054665991, 0.7370748549103296, 0.6764201053837433, 0.24344332960417014, 0.7565863650529556, 0.708029862881711, 0.7397705776235737, 0.7359702932913363, 0.7150400155809271, 0.017417907966684076, 0.18122792320995074, 0.12641278833400083, 0.11543636802268242, 0.14991191168456297, 0.15013482915834575, 0.11622982942630133, 0.1324443239578622, 0.11873315546305763, 0.13940471548010114, 0.10871947975316876, 0.11821784773048971, 0.14274304522590286, 0.10473429577877269, 0.10021028371296126, 0.11830639113858199, 0.1110314542490729, 0.10392901411871458, 0.11070141773652908, 0.8798791112697484, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.8858604558230023, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.37178708934968396, 0.18783352566599343, 0.2858988673785914, 0.4069972714192467, 0.16035997870998997, 0.3593953806238199, 0.8468334574599534, 0.7768475333130712, 0.6285445350285669, 0.6645412793090701, 0.8319850544678028, 0.7347459926936938, 0.8771454346934292, 0.8414628059036096, 0.7367032514386522, 0.15706054111730738, 0.16197857112410496, 0.12364927714049789, 0.26683293429395527, 0.28033237120723964, 0.3081518650306323, 0.16029071752978763, 0.23992256772361475, 0.17462797812751452, 0.19516394017586103, 0.22359926902688054, 0.1406801924588823, 0.21723867809396913, 0.17598077795579048, 0.12980441364801276, 0.12783242606600143, 0.26924477967967764, 0.3052404582107897, 0.2920201048574803, 0.13269882400444966, 0.12250646229714635, 0.025412445280017515, 0.290193448981371, 0.01015506712917813, 0.08852249147025837, 0.3327016211471332, 0.27626592026787755, 0.4041687152028831, 0.3389759188964425, 0.3384934640253118, 0.12483916317504173, 0.3511515961677857, 0.3401261396199553, 0.1524582748914749, 0.4238889560505885, 0.366181132501176, 0.05220620836060441, 0.12539542502127277, 0.2130993110130407, 0.07408232064815967, 0.21770137756842467, 0.3333143221270528, 0.14977804325225896, 0.2930250074724067, 0.09041150879066806, 0.11871316333810444, 0.1436668176253756, 0.28108792209873346, 0.27071923924101926, 0.2241709163335418, 0.3251671251270186, 0.2146127313272861, 0.24684614955821482, 0.2793957292397907, 0.7288237737384289, 0.5450905925966292, 0.5520746918120754, 0.7775759108539199, 0.6561405404510117, 0.8087139535449772, 0.5119943519169622, 0.6285172705927664, 0.5685607316864372, 0.14056380451002337, 0.09051126264590914, 0.12456490372253426, 0.09706401924562846, 0.13193675058028498, 0.09496867093337136, 0.1210714860388058, 0.08439474336838648, 0.10427537153115063, 0.1472971256939607, 0.12598542058784845, 0.12054533364004727, 0.1520236024329954, 0.18692937878632065, 0.3151379770729772, 0.16025638304468537, 0.2410336204265322, 0.16521591796394985, 0.4364139068086559, 0.5131543720641202, 0.31187036021139636, 0.3641168627400251, 0.3488372538202489, 0.3118947617690837, 0.4277536609546889, 0.44043723463450624, 0.318912033794469, 0.3224190047504061, 0.33764752944103016, 0.3027403218767232, 0.26247736039171665, 0.24785705152166349, 0.23474848037828255, 0.2769175113514032, 0.272806793717303, 0.09473939548414823, 0.1862709506810165, 0.1634302535012494, 0.16342054362485614, 0.1765504840142086, 0.19113565935496057, 0.1800917274961592, 0.18712576595158936, 0.19258630247369857, 0.18809843960033246, 0.29048333727859166, 0.20227047563903888, 0.17771362783729183, 0.26440549536691227, 0.18088606690102949, 0.1849484853535599, 0.3923404862756611, 0.19427925857917006, 0.23291773952522432, 0.16347379650822402, 0.6975795417348972, 0.15050497149040076, 0.8310587346403054, 0.6508206830345746, 0.6469838004405642, 0.7388861417085049, 0.16531908563810904, 0.5080257753951918, 0.6905895069042383, 0.20379648690133378, 0.2025180555693411, 0.20476198117433175, 0.1626544630805149, 0.16712206248163763, 0.20581989383244925, 0.7251714655982322, 0.7595098341857599, 0.1869256281308358, 0.17503591029887944, 0.19545032166751375, 0.1717670201118664, 0.18851341926651488, 0.1685417980988324, 0.1837593802188653, 0.17950431590217375, 0.17133525782643722, 0.07150261680261571, 0.07331750333132336, 0.06548682990713606, 0.06857905748607773, 0.06807612216352665, 0.07488369463184441, 0.07584546347791388, 0.08497975999196972, 0.07539119643308478]}, "mutation_prompt": null}
{"id": "d1d0a2be-cb90-40a2-b21a-0a9f82d476d5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        dynamic_F = self.base_F + (np.random.rand() - 0.5) * 0.2  # Adjusted mutation scaling\n        mutant = self.population[r1] + dynamic_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.05)  # Adjusted increase rate\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n                    self.population_size = min(self.population_size + 1, self.budget // 4)  # Dynamic population size\n                    self.initialize_population()\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "A refined adaptive differential evolution with dynamic population size adjustment and adaptive mutation scaling for enhanced convergence.", "configspace": "", "generation": 33, "fitness": 0.21423865619413876, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8766453043238474, 0.516219835231526, 0.5082930897511395, 0.7294925734992163, 0.3959958657819921, 0.270675281598475, 0.8706084966649323, 0.43695761429373836, 0.6316476190359186, 0.654788004185376, 0.7102362200143505, 0.689245696692938, 0.07086529775097317, 0.7546581538681121, 0.2122689950039518, 9.999999999998899e-05, 0.7273520131566316, 0.3651544787150417, 0.0693626052772306, 0.0580815587928073, 0.06594897948420153, 0.08084865562856025, 0.0576872297026072, 0.07023248682419214, 0.06290928168054255, 0.05477589880309075, 0.06347897835176941, 0.05080667401740868, 0.05106122313105299, 0.038468187101575624, 0.04351455117480996, 0.04513221755085506, 0.06046392805772449, 0.06761231696543746, 0.06186419373014618, 0.03239320509782373, 0.8378050400973618, 0.892338321265064, 0.7616612955034748, 0.8795383135413788, 0.9570545949236309, 0.9545615934854307, 0.42340546763683584, 0.3833485793996986, 0.8165310547662141, 0.45887446849733793, 0.19477769034192205, 0.2704537751740922, 0.24426716669080484, 0.11662394872380122, 0.15205425935172445, 0.13486986686155145, 0.33809597371016276, 0.3255331424588517, 0.22673316409020972, 0.2072470725474902, 0.20388645512179882, 0.17563514491788934, 0.2777390990683709, 0.34435031400431193, 0.34466016808909206, 0.27275836304780454, 0.2344244133847384, 0.14640971097573652, 0.15606685339718274, 0.13738099576931018, 0.017768112918358003, 0.13647797405781914, 0.027042165654613926, 0.16471603298028314, 0.14372656961831676, 0.09552939859276777, 0.16242253578379218, 0.14718359064186393, 0.010453442071273855, 0.30190807167576217, 0.13804832916277465, 0.1615513000322395, 0.14791630271045964, 0.13738169543560597, 0.15518867423428295, 0.14488264127067307, 9.999999999998899e-05, 9.999999999998899e-05, 0.11763846983300297, 0.09299756834096584, 0.18458291624546186, 9.999999999998899e-05, 0.036888225019457654, 9.999999999998899e-05, 0.053170072984632166, 0.0456816007058356, 0.39053437286774384, 0.08130756018754859, 0.043693055293150374, 0.06853975221145847, 0.23147362410914862, 0.04199278376613824, 0.21675939296907587, 9.999999999998899e-05, 9.999999999998899e-05, 0.048824390871071266, 9.999999999998899e-05, 0.1990252373793262, 0.23411198965792068, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18991107581470157, 0.07822289650996139, 0.20536666465679343, 0.13452969880886745, 0.09548266808277783, 0.07293434087326389, 0.20080805740047858, 0.08076559133928063, 0.06061805888071137, 0.7351777476188606, 0.5387601028917937, 0.4638007583340049, 0.5403481617779271, 0.4862162383174974, 0.48382822304421946, 0.684432950438332, 0.2774589527082618, 0.4652394037191855, 0.07761389782570238, 0.0570973579087265, 0.13338864397414907, 0.05879822201738061, 0.06358605936034767, 0.05100421191494531, 0.053358755483022824, 0.07340259734470911, 0.07194616703299017, 0.1296530675251446, 0.13013052002323677, 0.11573257543169513, 0.12989716164143406, 0.1247285493802931, 0.12936740747430253, 0.11871948326552961, 0.15188438957348294, 0.14009419347231156, 0.15095891575681675, 0.21083836851343118, 0.27243544733989233, 0.2927534415109604, 0.18893238701918913, 0.1702692977828305, 0.24362240105433153, 0.2983766368448796, 0.3304808949808695, 0.24056205513473372, 0.1796080570969263, 0.17976087984540068, 0.2796479927832861, 0.20419093019215184, 0.1246404880692622, 0.21226855491702734, 0.24504561297703198, 0.10480028699153954, 0.17345241270388945, 0.1657977763561277, 0.2146078602295325, 0.1676518655378968, 0.15933500013146473, 0.17806325668285683, 0.17643104664021525, 0.1615687071698061, 0.14420389043813775, 0.16680353211646892, 0.16060319088418962, 0.18381768219104555, 0.18368481635070166, 0.15953745444624257, 0.17628075610599103, 0.17788703966263442, 0.16152297085808276, 0.17792415075013124, 0.1663632464224869, 0.15880521705335926, 0.17410709998892415, 0.1591147165477116, 0.13188968770355192, 0.1632427881914429, 0.1767016607744919, 0.16853662867896035, 0.14443470641702938, 0.15137491585930707, 0.1595734093642952, 0.1586882524456732, 0.20651810472604026, 0.13962478637064013, 0.15384495513019425, 0.14472816192868143, 0.20883546066107994, 0.20794563423718526, 0.18326775211808477, 0.16830970096613396, 0.2108970287670905, 0.17136284066006569, 0.19057730685145247, 0.1809584627167019, 0.1766906066317968, 0.17673308757319506, 0.17833697312325913, 0.07618269641819897, 0.056208694639193535, 0.05068399590504702, 0.05058467984482484, 0.05018190887955809, 0.05676245506019639, 0.058969017441706684, 0.06633826606757998, 0.07015305477043365]}, "mutation_prompt": null}
{"id": "ead2bb04-d380-4089-b3b4-ecbc45036653", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(20, self.population_size - 1)  # Reduce size\n                    if self.population_size < len(self.population):\n                        self.population = self.population[:self.population_size]  # Trim population\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Population Resizing for Efficient Resource Utilization.", "configspace": "", "generation": 34, "fitness": 0.336185085959783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8558067534710863, 0.7120653562976866, 0.835672017635771, 0.8425818862114427, 0.8564035034879076, 0.8218556617277377, 0.8789689009743785, 0.861097555285652, 0.8436811054665991, 0.7370748549103296, 0.6764201053837433, 0.24344332960417014, 0.7565863650529556, 0.708029862881711, 0.7397705776235737, 0.7359702932913363, 0.7150400155809271, 0.017417907966684076, 0.18122792320995074, 0.12641278833400083, 0.11543636802268242, 0.14991191168456297, 0.15013482915834575, 0.11622982942630133, 0.1324443239578622, 0.11873315546305763, 0.13940471548010114, 0.10871947975316876, 0.11821784773048971, 0.14274304522590286, 0.10473429577877269, 0.10021028371296126, 0.11830639113858199, 0.1110314542490729, 0.10392901411871458, 0.11070141773652908, 0.8798791112697484, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.8858604558230023, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.37178708934968396, 0.18783352566599343, 0.2858988673785914, 0.4069972714192467, 0.16035997870998997, 0.3593953806238199, 0.8468334574599534, 0.7768475333130712, 0.6285445350285669, 0.6645412793090701, 0.8319850544678028, 0.7347459926936938, 0.8771454346934292, 0.8414628059036096, 0.7367032514386522, 0.15706054111730738, 0.16197857112410496, 0.12364927714049789, 0.26683293429395527, 0.28033237120723964, 0.3081518650306323, 0.16029071752978763, 0.23992256772361475, 0.17462797812751452, 0.19516394017586103, 0.22359926902688054, 0.1406801924588823, 0.21723867809396913, 0.17598077795579048, 0.12980441364801276, 0.12783242606600143, 0.26924477967967764, 0.3052404582107897, 0.2920201048574803, 0.13269882400444966, 0.12250646229714635, 0.025412445280017515, 0.290193448981371, 0.01015506712917813, 0.08852249147025837, 0.3327016211471332, 0.27626592026787755, 0.4041687152028831, 0.3389759188964425, 0.3384934640253118, 0.12483916317504173, 0.3511515961677857, 0.3401261396199553, 0.1524582748914749, 0.4238889560505885, 0.366181132501176, 0.05220620836060441, 0.12539542502127277, 0.2130993110130407, 0.07408232064815967, 0.21770137756842467, 0.3333143221270528, 0.14977804325225896, 0.2930250074724067, 0.09041150879066806, 0.11871316333810444, 0.1436668176253756, 0.28108792209873346, 0.27071923924101926, 0.2241709163335418, 0.3251671251270186, 0.2146127313272861, 0.24684614955821482, 0.2793957292397907, 0.7288237737384289, 0.5450905925966292, 0.5520746918120754, 0.7775759108539199, 0.6561405404510117, 0.8087139535449772, 0.5119943519169622, 0.6285172705927664, 0.5685607316864372, 0.14056380451002337, 0.09051126264590914, 0.12456490372253426, 0.09706401924562846, 0.13193675058028498, 0.09496867093337136, 0.1210714860388058, 0.08439474336838648, 0.10427537153115063, 0.1472971256939607, 0.12598542058784845, 0.12054533364004727, 0.1520236024329954, 0.18692937878632065, 0.3151379770729772, 0.16025638304468537, 0.2410336204265322, 0.16521591796394985, 0.4364139068086559, 0.5131543720641202, 0.31187036021139636, 0.3641168627400251, 0.3488372538202489, 0.3118947617690837, 0.4277536609546889, 0.44043723463450624, 0.318912033794469, 0.3224190047504061, 0.33764752944103016, 0.3027403218767232, 0.26247736039171665, 0.24785705152166349, 0.23474848037828255, 0.2769175113514032, 0.272806793717303, 0.09473939548414823, 0.1862709506810165, 0.1634302535012494, 0.16342054362485614, 0.1765504840142086, 0.19113565935496057, 0.1800917274961592, 0.18712576595158936, 0.19258630247369857, 0.18809843960033246, 0.29048333727859166, 0.20227047563903888, 0.17771362783729183, 0.26440549536691227, 0.18088606690102949, 0.1849484853535599, 0.3923404862756611, 0.19427925857917006, 0.23291773952522432, 0.16347379650822402, 0.6975795417348972, 0.15050497149040076, 0.8310587346403054, 0.6508206830345746, 0.6469838004405642, 0.7388861417085049, 0.16531908563810904, 0.5080257753951918, 0.6905895069042383, 0.20379648690133378, 0.2025180555693411, 0.20476198117433175, 0.1626544630805149, 0.16712206248163763, 0.20581989383244925, 0.7251714655982322, 0.7595098341857599, 0.1869256281308358, 0.17503591029887944, 0.19545032166751375, 0.1717670201118664, 0.18851341926651488, 0.1685417980988324, 0.1837593802188653, 0.17950431590217375, 0.17133525782643722, 0.07150261680261571, 0.07331750333132336, 0.06548682990713606, 0.06857905748607773, 0.06807612216352665, 0.07488369463184441, 0.07584546347791388, 0.08497975999196972, 0.07539119643308478]}, "mutation_prompt": null}
{"id": "6755b163-920c-451c-913f-7259513ff787", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.local_search_prob = 0.1  # probability for local search\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def local_search(self, individual):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        candidate = np.clip(individual + perturbation, self.lb, self.ub)\n        return candidate\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                \n                # Intermittent local search\n                if np.random.rand() < self.local_search_prob:\n                    trial = self.local_search(trial)\n\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n                    # Adaptive population resizing\n                    self.population_size = max(20, self.population_size - 1)\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Incorporates adaptive population resizing and intermittent local search to enhance convergence speed of differential evolution.", "configspace": "", "generation": 35, "fitness": 0.3310498594077661, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8424064003056886, 0.8527619479017281, 0.8268305677648635, 0.8444802480034038, 0.8337465722485353, 0.8658953702957866, 0.8393533802113735, 0.8146520818376786, 0.8281754266123564, 0.49321563007696445, 0.7262601969238491, 0.19092004675828933, 0.6889841665602312, 0.43909260959404306, 0.7025800556312681, 0.6489635572676459, 0.7320086775225725, 0.7401441939805294, 0.15011173640454778, 0.1340158208266936, 0.09270975654062585, 0.146888058300774, 0.12035346389523893, 0.11830741899468322, 0.12346951096403813, 0.14042084535885335, 0.12526752528737883, 0.1128540091233321, 0.09027201964787968, 0.10408662698316273, 0.10675228244844426, 0.18255690859577, 0.1055431365660695, 0.10915557342290083, 0.10597825072045286, 0.10588991689656557, 0.9133789710776614, 0.9209540678769167, 0.8626942432815091, 0.8463451709630792, 0.9139911734352524, 0.8193587966865801, 0.9166960977303384, 0.8137383826399026, 0.8904760487468802, 0.28443963269249894, 0.301823410153944, 0.4801036229537087, 0.39492996054704876, 0.3182480461217557, 0.4148233968252444, 0.3570532623135195, 0.4318749475224155, 0.47263643024209834, 0.5854772802415149, 0.7745822867728199, 0.15923628474534357, 0.8030181825834954, 0.7521953298174395, 0.6337035470197826, 0.6325124851262247, 0.7489517043329077, 0.5325878217299365, 0.306891387117305, 0.19879368798558805, 0.2529819127964523, 0.39223737229759625, 0.16218721431902106, 0.21062337559587374, 0.22852098199970838, 0.14155617448193802, 0.36219060975937, 0.3368352670797352, 0.197921088254714, 0.1704479618516792, 0.18719822227033867, 0.33885732419709413, 0.15309799814108516, 0.21056733812157058, 0.12573163183481395, 0.150206945663932, 0.19334512761989942, 0.024741597060909948, 0.2061032710877867, 0.2477725480206896, 0.31657586879026367, 0.016952430355260173, 0.03547598071711944, 0.0423498795692232, 0.15618389675166855, 0.34048453443667115, 0.3371435405667904, 0.1505011788382995, 0.43612549308008464, 0.2902587359248452, 0.3819580740133365, 0.339005329465649, 0.3483086146200042, 0.3255170898361559, 0.051802826450263795, 0.08844809496638395, 0.06954751200914322, 0.23589714429350084, 0.2916671507990545, 0.18466094121690324, 0.13631902689336917, 0.13116420219348202, 0.07712384822629792, 0.23970666250684214, 0.26090965346394734, 0.3299893380750174, 0.16416344292049345, 0.31715654150536154, 0.25346385807035854, 0.2209065376402587, 0.11390894659006445, 0.3696636226806227, 0.7443168980620734, 0.69888973860996, 0.6777437225975853, 0.6376503744690005, 0.7259992197339058, 0.48788120540967916, 0.5931542316462619, 0.7381377918791796, 0.7343685992486775, 0.1106513586732164, 0.08849790905684218, 0.10729544083552278, 0.13605978542420094, 0.10452793526571746, 0.10550411625538525, 0.08894152467576166, 0.08096077030809734, 0.09932546210986604, 0.16011167846522567, 0.13429294716096152, 0.16356153220753944, 0.15001580140223647, 0.13570092290501956, 0.14455533427676215, 0.12893884832330982, 0.28093894438548417, 0.1258543287678855, 0.3500177447784164, 0.30329633228683517, 0.4102989586385394, 0.35048121407541244, 0.37579464457555345, 0.3750963704047724, 0.33576796908895945, 0.3293577489387314, 0.31137710881002045, 0.24018629243925416, 0.22456092776703596, 0.24373170868847793, 0.2428778483619145, 0.22422688140258007, 0.3086290720931242, 0.209420048601342, 0.30032960504970174, 0.31430213459216316, 0.16608369951777602, 0.1972511409889528, 0.17682037744211665, 0.19020422904098988, 0.18669079110498632, 0.20706686937228247, 0.17443698860883905, 0.17384572183492308, 0.1831609791987603, 0.21992860978747253, 0.2064254055275434, 0.17304933267889078, 0.20352442057661613, 0.22819036527413916, 0.22174932150954108, 0.20091583595781903, 0.2811904744167517, 0.19624882627912232, 0.6475829658535027, 0.7732839780281264, 0.8351134735970576, 0.7811978358146308, 0.1916581577385239, 0.6630050493724986, 0.6863428103127225, 0.15490609518276122, 0.16937974526605626, 0.6874138882918484, 0.20995454740715147, 0.5516302779378912, 0.20423652241446233, 0.1659466045957272, 0.2046216443232779, 0.21020202997094695, 0.6021288675493567, 0.15470823388770327, 0.181764164168415, 0.18647439649117137, 0.1791649814259263, 0.1724775414382197, 0.16983540798618035, 0.16855168882915328, 0.1785282424072555, 0.2089736891425773, 0.1646790147550864, 0.07692219973887726, 0.0704769937250872, 0.07412370068518304, 0.07286869597521295, 0.07372119434344437, 0.07289803362463021, 0.0895378548645045, 0.07200067285302414, 0.06696240053568958]}, "mutation_prompt": null}
{"id": "8b5d0c8f-ec08-4468-89c3-a550f1c58dba", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        diversity = np.std(self.population, axis=0).mean()  # Calculate population diversity\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1 * (1 + diversity)  # Dynamically scale F\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic scaling of mutation factor based on population diversity to enhance exploration.", "configspace": "", "generation": 36, "fitness": 0.33068759082541027, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8675712793902275, 0.8690766652305355, 0.8534221730585172, 0.7730676906914018, 0.8768817533846684, 0.6031632051395053, 0.8580676113162261, 0.8815476078036253, 0.8448774490971092, 0.7886050339363498, 0.7381823901295914, 0.5907508810210844, 0.19954129483424177, 0.7597174989201732, 9.999999999998899e-05, 0.7382052793187244, 0.764699038915585, 0.10726786238710428, 0.1465407434552526, 0.12378705984982885, 0.16366192448626227, 0.11588624754226673, 0.11422518160508133, 0.19199256409754584, 0.10635414329921644, 0.1597280018322479, 0.10328627359666098, 0.12532655044220042, 0.12848978316789395, 0.12663784941409684, 0.13963805119549055, 0.1447978667147226, 0.14373751850829553, 0.10880406913661156, 0.11419848041052916, 0.10545511962529619, 0.9205455155161749, 0.9254882912051917, 0.8913726246962992, 0.8754374431995281, 0.9201075800561423, 0.9252826998807413, 0.7821103594245509, 0.8943595108421306, 0.8697988864051749, 0.49765099937982915, 0.4193083494571982, 0.16769007787552836, 0.2945680941574039, 0.15581905906987226, 0.3265381487944302, 0.17081712001705074, 0.22663500016746152, 0.2765221907636173, 0.6682347279559516, 0.7063590427576734, 0.7837884804480445, 0.2677285275682689, 0.702322106425467, 0.8574367771679003, 0.4819227262936516, 0.7280822244768899, 0.627119586141893, 0.31528000462475203, 0.13834929378202998, 0.2836397796755805, 0.3719656928821089, 0.16678654870153986, 0.1286756239522714, 0.19866365084909154, 0.12826472228418295, 0.16688555081841683, 0.10996770543668777, 0.1812333750661027, 0.25839701539383386, 0.347175254083133, 0.46376320126299597, 0.19957686011717823, 0.12592749434937578, 0.1964406359520786, 0.16746760651245862, 0.13449101906526306, 0.27512169562441235, 0.2925905590995084, 0.3085442189912463, 0.3413051119669188, 0.02577992303118759, 0.29991443692969444, 0.07381147255526344, 0.42604245196088464, 0.07606507580592692, 0.3407360643597859, 0.4516660001499273, 0.23164981748106273, 0.34059486824123464, 0.32674016396081174, 0.5491061733927557, 0.4340402737767628, 0.5325062711787454, 0.11772201321706743, 0.17854600735450654, 0.3179030993518761, 0.10278023259267177, 0.1279153891042506, 0.17167355317410526, 0.10627572197014301, 0.22833703634536107, 0.08766965408242244, 0.3701181229765521, 0.3160865858780654, 0.25649355896339154, 0.3397420083509073, 0.34017427748868545, 0.4618252638284145, 0.2672988406866518, 0.39178351750654106, 0.16689538640790047, 0.759923994196547, 0.684508642030355, 0.6309835755165327, 0.8265956669767708, 0.6403766185636204, 0.6547181067210692, 0.6967051102933661, 0.6539070704187538, 0.7385579467307791, 0.09806523950316348, 0.09333213541087693, 0.11753321810921302, 0.10877541816951286, 0.0849000264196822, 0.11428593877902005, 0.1276657328046773, 0.12550687642755243, 0.1115466168804975, 0.15296119821510834, 0.14594457500012326, 0.12551883304091538, 0.206278058497253, 0.13557834265559654, 0.2027414625498405, 0.16979227573885403, 0.1919969036476823, 0.14216919889736912, 0.3760276256495475, 0.4083896788960979, 0.4025215927424193, 0.35319237744486964, 0.38027369455899995, 0.317340866132255, 0.35819743142332416, 0.375103284363963, 0.34151406497101144, 0.2803121532619922, 0.3029312053572554, 0.26645657710186565, 0.24077610681731088, 0.2656683475891358, 0.2187581905782512, 0.26671833028037695, 0.3422834276858163, 0.18796209577896383, 0.20294545570678246, 0.18787795281937625, 0.17432559000535397, 0.16981722040657132, 0.17401415835367118, 0.19653461904478864, 0.19935271163846568, 0.17825286003461227, 0.1813313220521794, 0.21278189688231963, 0.1821105002190807, 0.22153152768033957, 0.4927910204436049, 0.2064656307209134, 0.17371281424162188, 0.21264286869605342, 0.18995365293201327, 0.20469618363664832, 0.7206034347189987, 0.18500408191409057, 0.17041617067331172, 0.7050006529794208, 0.19178925202921504, 0.16785797668872515, 0.6732570366367044, 0.19316236013290167, 0.19685505656314328, 0.8105694951035733, 0.16845647878875958, 0.7240324164482029, 0.1991452346992605, 0.16612745640865434, 0.6330157595608772, 0.1038188080352358, 0.14831989191793238, 0.1510920744160057, 0.20770866506288543, 0.18666021492408358, 0.19081762628156795, 0.17987919121569973, 0.17887471683219724, 0.17677522551589753, 0.17653172358017966, 0.18452398896260025, 0.19471539015782324, 0.08140881757969742, 0.08315337851554738, 0.05963986113276065, 0.07781761954738653, 0.062298951482024134, 0.06819519667146956, 0.07906096556531572, 0.07941034951076176, 0.06734610400016883]}, "mutation_prompt": null}
{"id": "8edf1321-dc71-4563-9544-9c276e6f2089", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.elite_fraction = 0.1  # New parameter for elite selection\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def calculate_diversity(self):\n        return np.mean(np.std(self.population, axis=0))  # Measures diversity of the population\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        elite_size = max(1, int(self.elite_fraction * self.population_size))\n        \n        while evals < self.budget:\n            population_values = np.array([func(ind) for ind in self.population])\n            elite_indices = np.argsort(population_values)[:elite_size]\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                if idx in elite_indices:  # Skip elite individuals\n                    continue\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt parameters dynamically based on diversity\n            diversity = self.calculate_diversity()\n            if diversity < 0.1:  # Adjust based on population diversity\n                self.base_F = min(0.9, self.base_F + 0.05)\n                self.base_CR = max(0.7, self.base_CR - 0.02)\n            else:\n                self.base_F = max(0.4, self.base_F - 0.05)\n                self.base_CR = min(0.9, self.base_CR + 0.02)\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.05)\n                    self.base_CR = max(0.8, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "A modified adaptive differential evolution algorithm with dynamic parameter adaptation based on population diversity and elite selection to enhance convergence speed.", "configspace": "", "generation": 37, "fitness": 0.25128792271843287, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.6565475019480451, 0.6743973023206337, 0.7112820087873641, 0.6271497218451123, 0.5075186288949771, 0.6672588278445739, 0.6954743496717513, 0.63318380584742, 0.565620147213903, 0.4567892205991648, 0.1739661521143575, 0.2545110380557638, 0.3859202195472542, 0.35740823052284343, 0.4365114361062452, 0.4284522891357967, 0.44774698721529427, 0.400651427129294, 0.12306731792959757, 0.13149418926864653, 0.12896085137134683, 0.13620880307924932, 0.15424247435904292, 0.13218992568368326, 0.11416822344465838, 0.1084783722141619, 0.13366398347245378, 0.1086009982593269, 0.08088758573962129, 0.10689608428829, 0.10966399939662297, 0.09285824844138657, 0.11774168909789129, 0.11716438292068432, 0.12616238292174164, 0.10284615769428673, 0.9228812948062131, 0.7399858525918251, 0.8652866870838436, 0.7975287058123779, 0.8885679882046507, 0.8583363545817395, 0.8297882443696474, 0.7328216429244664, 0.8087576618650122, 0.3173982500574434, 0.06727936829466197, 0.28465794352861207, 0.19245073078028496, 0.15795054296612887, 0.2401205329523871, 0.3561564210813052, 0.2763771541174447, 0.2961331268691949, 0.21464017660537815, 0.153960785165125, 0.15449301481301336, 0.210176871747753, 0.27443934695381855, 0.21031705945937607, 0.22524604752248967, 0.7670764019410482, 0.24359025921339628, 0.372531056602901, 0.1638632535043194, 0.12242628832758073, 0.1917855365485014, 0.2552088146002094, 0.1506706221856522, 0.18210756996810207, 0.1453833606176138, 0.14817183280748836, 0.1779783201380083, 0.09841955845811368, 0.15261862423730277, 0.09996802092160395, 0.2206649320268581, 0.17158423664755573, 0.23413137424274677, 0.1983229343765589, 0.17963829324756697, 0.015020564824150595, 9.999999999998899e-05, 0.19469572107527355, 0.008704798032658223, 0.008810618176675944, 0.010829328997638332, 0.011447765627220163, 0.19669081120102105, 0.09040861605201922, 0.08382152724289482, 0.06636548629052119, 0.28127146305689243, 0.049124456202149114, 0.20354536430284553, 0.0780968200819614, 0.17541647029705143, 0.35140624736830595, 0.06960645450602965, 0.09428322133199085, 0.09959168342977132, 0.13092157670436422, 0.09607781613604616, 0.07576876479533423, 0.11893677433806438, 0.08845585167295045, 0.14498325711501203, 0.007783761844206483, 0.1679791334528301, 0.16269748179571053, 0.117105261187884, 0.18471287687231563, 0.1546842237934214, 0.17546578720501715, 0.19517642730352114, 0.06920058724980171, 0.150673396100113, 0.4594161611674672, 0.5043480538928908, 0.4622947696314106, 0.5069324581589415, 0.4797542827836615, 0.4518341688628297, 0.46077046737978056, 0.5007496346014175, 0.4967804955841558, 0.10973736659750244, 0.10133088822756453, 0.11620321916075049, 0.0909117775023498, 0.0935896545967706, 0.08978421473514919, 0.11422629411609708, 0.10896231997727812, 0.06755089735152309, 0.18515751764190225, 0.14188192895434748, 0.12857508188123068, 0.14106231178398754, 0.12190341862467524, 0.15050736157112266, 0.15894297277580594, 0.12510630496898756, 0.18631795672553997, 0.29042369260727197, 0.33174205897996467, 0.30698094025046496, 0.3154074654376674, 0.3043908538585198, 0.3209443636849416, 0.3144063654926631, 0.36422174068120916, 0.15495770444019508, 0.17745131055236196, 0.2641707464051122, 0.2223087450179123, 0.23564232814044261, 0.25814103560846224, 0.2773198701631223, 0.19778451303652445, 0.2728234140398693, 0.24685367819811843, 0.21763141003801234, 0.19513003569770437, 0.19181755354941632, 0.19202782277123143, 0.1713744539480131, 0.1917176987408139, 0.20496108078617925, 0.19735321110592174, 0.18381794130279072, 0.2054944114511168, 0.2222197229303824, 0.2049489391327527, 0.2308223932494856, 0.38541114283607736, 0.1701056892701721, 0.19509586225272635, 0.21342911805049325, 0.33464174916255784, 0.18300103190188333, 0.18049424116700596, 0.15020778230458232, 0.17045845083899036, 0.19674342846988635, 0.716760395879919, 0.8651381952329047, 0.16325733857369484, 0.16518175813240632, 0.419978466084429, 0.49888280844345767, 0.6021724966023155, 0.4965092045297781, 0.16688885075013082, 0.1910523794095662, 0.1428743482386451, 0.5468156164700615, 0.15129255190904423, 0.1831041776270821, 0.17101749073196626, 0.17616110237298033, 0.15854799079410697, 0.1778961626294291, 0.18197719031530235, 0.1744315062599655, 0.1785828032979775, 0.16122248521201565, 0.07459230614649115, 0.07745558299307231, 0.07662312401681426, 0.08295645426096909, 0.07672846161955182, 0.08088434787587484, 0.07554797861278062, 0.07400195538309595, 0.08270934415404119]}, "mutation_prompt": null}
{"id": "41bf99d3-937a-45c6-917f-0ba083b57a8c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.85, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced dynamic parameter adaptation in differential evolution to balance exploration and exploitation more effectively.", "configspace": "", "generation": 38, "fitness": 0.3236287370043868, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8534374751734822, 0.7120653562976866, 0.802106830014705, 0.8425818862114427, 0.8564035034879076, 0.8407449215372341, 0.8789689009743785, 0.861097555285652, 0.8404636662173366, 0.6851846802093738, 0.6764201053837433, 0.24344332960417014, 0.7640786364082689, 0.708029862881711, 0.7398981008887544, 0.7359702932913363, 0.7060181030043245, 0.017417907966684076, 0.12342187821464035, 0.11710786571461118, 0.1373765049163771, 0.19929786622423762, 0.13894583039268837, 0.11725287139831775, 0.12940132706436902, 0.10639655788825053, 0.1833683668827012, 0.12016280928770406, 0.11840375958747995, 0.12748422615030763, 0.13269031105106766, 0.11135849021880062, 0.1270696086254809, 0.13174325288819377, 0.11488773304180855, 0.12719405538625084, 0.8857330753336975, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.9361577407894169, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.47573281494257114, 0.18783352566599343, 0.2858988673785914, 0.4335771870124401, 0.16035997870998997, 0.43128679422170135, 0.8468334574599534, 0.5741987575033263, 0.5917855463997778, 0.6984298366023614, 0.8302408312010595, 0.6099322185760084, 0.8771454346934292, 0.5487920838027258, 0.5650002556563103, 0.17198475419994097, 0.2391839206653662, 0.12364927714049789, 0.17283916993413384, 0.4173155501968956, 0.43675725727071324, 0.16029071752978763, 0.2602496119433063, 0.3398534576832529, 0.19820452045814085, 0.24272163111892764, 0.1406801924588823, 0.338243984188643, 0.17598077795579048, 0.189898871753171, 0.1278511825704992, 0.20455735279162357, 0.17890175029728694, 0.1508300915862365, 0.13312637395581683, 0.0726802319740324, 0.025412445280017515, 0.2741214369318761, 0.051953558710761905, 0.16048841710990036, 0.22997250471720365, 0.2666046136406338, 0.2852265247485739, 0.29142745807937176, 0.33845577255069903, 0.18816575883586928, 0.2139809318259117, 0.23388648173764848, 0.16971838542889595, 0.3092257447482536, 0.25743558544174316, 0.035123704786897414, 0.10081612733838696, 0.202713617700647, 0.07408232064815967, 0.16104059797124426, 0.29875671149104865, 0.14403474987213594, 0.2223926096697264, 0.0903213993594072, 0.11871316333810444, 0.17547987401463017, 0.2553456819747736, 0.27071812636793746, 0.19869320153084047, 0.31901947839346734, 0.214612769947084, 0.24268413832874003, 0.3012444554209682, 0.6904601511040245, 0.5450905925966292, 0.5520746918120754, 0.6632335641739449, 0.5635673897371662, 0.7730363377407606, 0.5119943519169622, 0.5559561208037116, 0.6934400129197005, 0.11606590279101836, 0.08493366141258862, 0.11268674161573544, 0.09661168991570979, 0.08694512984917968, 0.10787420310699558, 0.11099838556745967, 0.10938532298073156, 0.09250329930125278, 0.13559350029843065, 0.13617043277313423, 0.13938484647721128, 0.16493562369084724, 0.13413411454849755, 0.21927933715918746, 0.17283734322063882, 0.24281054361042942, 0.16249170940028523, 0.42837198337737414, 0.46381063307458903, 0.32579860957816564, 0.3503584147616321, 0.34815565473882715, 0.2810364262105689, 0.4138909122783784, 0.40791543953650766, 0.3175669751637068, 0.2818657206797074, 0.23719433845060856, 0.29845362402929, 0.2600845438604453, 0.19779045174335674, 0.2480102870852443, 0.2492461120497047, 0.2499393522782103, 0.09425259946112163, 0.17578284111120812, 0.19532961128691206, 0.17044724247094256, 0.17893903813749312, 0.17744983090344246, 0.17505988826125063, 0.16571645271562407, 0.19179361737980238, 0.17584080343629338, 0.2841166585862833, 0.1996583193252408, 0.17660196629686342, 0.29527954450122706, 0.18136611327169616, 0.19597134852828957, 0.22456607852243893, 0.24128789190962419, 0.23138376942121686, 0.16347379650822402, 0.673040790824581, 0.1506889972827148, 0.7850147500938063, 0.7408045382188535, 0.5893450740692088, 0.19352765219693524, 0.16510307630335952, 0.157917188241533, 0.6182350023171999, 0.20379648690133378, 0.4982757492965876, 0.20433697077052315, 0.18599136934081395, 0.16712206248158168, 0.2012331180638539, 0.7592652920264737, 0.6520152335802603, 0.17521482698422441, 0.1911169649809905, 0.18528334583898276, 0.17784141247451446, 0.1649663274418628, 0.17491012929695549, 0.169038423600263, 0.16905663237664414, 0.17748623991237, 0.07654010180718251, 0.06877444945171263, 0.07711728008517404, 0.06951961858205502, 0.07444653669138246, 0.08928570166581429, 0.06329398607630976, 0.06358687689613596, 0.07631180162187534]}, "mutation_prompt": null}
{"id": "0c3109d9-becf-41f8-884c-ef5da9f20a87", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 3)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.adaptation_rate = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * self.adaptation_rate\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.05)\n                    self.adaptation_rate = min(0.15, self.adaptation_rate + 0.02)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedDifferentialEvolution", "description": "An enhanced differential evolution with adaptive population and dynamic mutation/crossover adjustments for improved convergence.", "configspace": "", "generation": 39, "fitness": 0.33071702913934686, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8541945174881429, 0.7120653562976866, 0.8523433855359048, 0.8425818862114427, 0.8564035034879076, 0.8267357899762463, 0.8789689009743785, 0.861097555285652, 0.8478425804724679, 0.7653050481773831, 0.6764201053837433, 0.24344332960417014, 0.7654907082954177, 0.708029862881711, 0.7410862266456948, 0.7359702932913363, 0.7263096602597043, 0.017417907966684076, 0.11959589746734933, 0.11379529415346656, 0.11737715088675471, 0.1026243072157269, 0.10119440084726417, 0.12765723769355353, 0.1229248331913606, 0.10184865179641656, 0.2637899126724075, 0.11325814571794923, 0.10595719291473593, 0.13208966415459233, 0.112302623670263, 0.120716479039506, 0.10827608347386941, 0.13545063207133334, 0.11825624536678825, 0.09885330613151166, 0.774130431422223, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.8434555724568442, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.3011835093407772, 0.18783352566599343, 0.2858988673785914, 0.4903212356760708, 0.16035997870998997, 0.35403244746198403, 0.8468334574599534, 0.7947141248541265, 0.35300265795051533, 0.2632038164719499, 0.8184421107977456, 0.26802796369137627, 0.8771454346934292, 0.8332160204044483, 0.7432326936082032, 0.15659464877290397, 0.16398496919214645, 0.12364927714049789, 0.17849857071469155, 0.4550219343944474, 0.5373227309139643, 0.16029071752978763, 0.3225310345125445, 0.2125832537744342, 0.15764274055293426, 0.12781106898679484, 0.1406801924588823, 0.1767497499461791, 0.17598077795579048, 0.4278848111209388, 0.12787491131905915, 0.27714593919378006, 0.1600461239605373, 0.21552254079470234, 0.13301468562158258, 0.13233660583042506, 0.025412445280017515, 0.41693032349649106, 0.00865548283386175, 0.0899740010790856, 0.32566837284634553, 0.20853308811782434, 0.24397494385140006, 0.2538112052933268, 0.3381697095328966, 0.15429385734647627, 0.20992027919636713, 0.18846174769366053, 0.1621293017687534, 0.17282426355851443, 0.19179353428991486, 0.051923909354120945, 0.14325962449920138, 0.2968859107226415, 0.07408232064815967, 0.14179154851191067, 0.3303804987322868, 0.1499791089292446, 0.21639055199652746, 0.09036820099165543, 0.11871316333810444, 0.13049719841315377, 0.3180227758520704, 0.27071922790840086, 0.2549916221284988, 0.31783308579160885, 0.21461263402143804, 0.26661554090995443, 0.2854975155951943, 0.7538066404266079, 0.5450905925966292, 0.5520746918120754, 0.7162343323340528, 0.6807968027204494, 0.8079901069894853, 0.5119943519169622, 0.657084161485284, 0.5657984755740777, 0.11773790981057719, 0.10223516511184338, 0.08672533560537576, 0.12409639255100302, 0.12263453927685308, 0.08962473196492338, 0.12545839379902102, 0.10913243738997191, 0.112770143991897, 0.15780190686798468, 0.1295491706140245, 0.14351947358567962, 0.1514049432234741, 0.14466424341706519, 0.16360334537643617, 0.15872032261706792, 0.24284508357410617, 0.1342072188354101, 0.45362160402795204, 0.4948334049437988, 0.3772516185112085, 0.41955428477650236, 0.3656256982110411, 0.29908607392169606, 0.4890654627031217, 0.45639383568071, 0.3274754511787308, 0.30316809325359073, 0.28768321158643606, 0.35170336245271405, 0.2963581408544055, 0.2342289907684617, 0.25212722330319415, 0.27636532171710493, 0.30744738819382933, 0.09477522486561996, 0.18603787697898966, 0.16591757660157525, 0.18752444297247828, 0.19876489560405397, 0.18321989425709384, 0.19895112712786467, 0.22451811451541415, 0.19199476561228168, 0.19079606064690058, 0.2157191866402839, 0.18080627913382363, 0.18176027775801318, 0.474430595255958, 0.26873455129136403, 0.22572846628853238, 0.488520888435963, 0.22135937712110854, 0.2371551897022719, 0.16347379650822402, 0.7006463862544839, 0.15080395305945293, 0.8195338838833457, 0.8109540731837883, 0.6304212225754614, 0.20611028587969338, 0.16452791263322175, 0.1608373680872479, 0.730419779220072, 0.20379648690133378, 0.7312748750162028, 0.2051938166960009, 0.6681868789075952, 0.1671220624816515, 0.20630949455455883, 0.3377945790731034, 0.7803018340530435, 0.17297521652990622, 0.1812060800942591, 0.1844196425293756, 0.19463071549886712, 0.16427103487303607, 0.16905442909103408, 0.1717212144921959, 0.1904498755216527, 0.1854637564545113, 0.06877429102642618, 0.0839719399936083, 0.07992488646300477, 0.08656806215913371, 0.08878514908479207, 0.07264013029776129, 0.06744289354702637, 0.07222291438650519, 0.0758502664017302]}, "mutation_prompt": null}
{"id": "dbf8ddfd-3ae6-4e35-b2d5-82635f78f488", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.initial_population_size = min(max(4 * dim, 20), budget // 2)\n        self.population_size = self.initial_population_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n                if evals > self.budget // 2:\n                    self.population_size = max(4, int(self.initial_population_size * 0.8))\n                \n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introduces adaptive population size reduction and dynamic mutation scaling to balance exploration and exploitation for improved convergence speed.", "configspace": "", "generation": 40, "fitness": 0.336185085959783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8558067534710863, 0.7120653562976866, 0.835672017635771, 0.8425818862114427, 0.8564035034879076, 0.8218556617277377, 0.8789689009743785, 0.861097555285652, 0.8436811054665991, 0.7370748549103296, 0.6764201053837433, 0.24344332960417014, 0.7565863650529556, 0.708029862881711, 0.7397705776235737, 0.7359702932913363, 0.7150400155809271, 0.017417907966684076, 0.18122792320995074, 0.12641278833400083, 0.11543636802268242, 0.14991191168456297, 0.15013482915834575, 0.11622982942630133, 0.1324443239578622, 0.11873315546305763, 0.13940471548010114, 0.10871947975316876, 0.11821784773048971, 0.14274304522590286, 0.10473429577877269, 0.10021028371296126, 0.11830639113858199, 0.1110314542490729, 0.10392901411871458, 0.11070141773652908, 0.8798791112697484, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.8858604558230023, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.37178708934968396, 0.18783352566599343, 0.2858988673785914, 0.4069972714192467, 0.16035997870998997, 0.3593953806238199, 0.8468334574599534, 0.7768475333130712, 0.6285445350285669, 0.6645412793090701, 0.8319850544678028, 0.7347459926936938, 0.8771454346934292, 0.8414628059036096, 0.7367032514386522, 0.15706054111730738, 0.16197857112410496, 0.12364927714049789, 0.26683293429395527, 0.28033237120723964, 0.3081518650306323, 0.16029071752978763, 0.23992256772361475, 0.17462797812751452, 0.19516394017586103, 0.22359926902688054, 0.1406801924588823, 0.21723867809396913, 0.17598077795579048, 0.12980441364801276, 0.12783242606600143, 0.26924477967967764, 0.3052404582107897, 0.2920201048574803, 0.13269882400444966, 0.12250646229714635, 0.025412445280017515, 0.290193448981371, 0.01015506712917813, 0.08852249147025837, 0.3327016211471332, 0.27626592026787755, 0.4041687152028831, 0.3389759188964425, 0.3384934640253118, 0.12483916317504173, 0.3511515961677857, 0.3401261396199553, 0.1524582748914749, 0.4238889560505885, 0.366181132501176, 0.05220620836060441, 0.12539542502127277, 0.2130993110130407, 0.07408232064815967, 0.21770137756842467, 0.3333143221270528, 0.14977804325225896, 0.2930250074724067, 0.09041150879066806, 0.11871316333810444, 0.1436668176253756, 0.28108792209873346, 0.27071923924101926, 0.2241709163335418, 0.3251671251270186, 0.2146127313272861, 0.24684614955821482, 0.2793957292397907, 0.7288237737384289, 0.5450905925966292, 0.5520746918120754, 0.7775759108539199, 0.6561405404510117, 0.8087139535449772, 0.5119943519169622, 0.6285172705927664, 0.5685607316864372, 0.14056380451002337, 0.09051126264590914, 0.12456490372253426, 0.09706401924562846, 0.13193675058028498, 0.09496867093337136, 0.1210714860388058, 0.08439474336838648, 0.10427537153115063, 0.1472971256939607, 0.12598542058784845, 0.12054533364004727, 0.1520236024329954, 0.18692937878632065, 0.3151379770729772, 0.16025638304468537, 0.2410336204265322, 0.16521591796394985, 0.4364139068086559, 0.5131543720641202, 0.31187036021139636, 0.3641168627400251, 0.3488372538202489, 0.3118947617690837, 0.4277536609546889, 0.44043723463450624, 0.318912033794469, 0.3224190047504061, 0.33764752944103016, 0.3027403218767232, 0.26247736039171665, 0.24785705152166349, 0.23474848037828255, 0.2769175113514032, 0.272806793717303, 0.09473939548414823, 0.1862709506810165, 0.1634302535012494, 0.16342054362485614, 0.1765504840142086, 0.19113565935496057, 0.1800917274961592, 0.18712576595158936, 0.19258630247369857, 0.18809843960033246, 0.29048333727859166, 0.20227047563903888, 0.17771362783729183, 0.26440549536691227, 0.18088606690102949, 0.1849484853535599, 0.3923404862756611, 0.19427925857917006, 0.23291773952522432, 0.16347379650822402, 0.6975795417348972, 0.15050497149040076, 0.8310587346403054, 0.6508206830345746, 0.6469838004405642, 0.7388861417085049, 0.16531908563810904, 0.5080257753951918, 0.6905895069042383, 0.20379648690133378, 0.2025180555693411, 0.20476198117433175, 0.1626544630805149, 0.16712206248163763, 0.20581989383244925, 0.7251714655982322, 0.7595098341857599, 0.1869256281308358, 0.17503591029887944, 0.19545032166751375, 0.1717670201118664, 0.18851341926651488, 0.1685417980988324, 0.1837593802188653, 0.17950431590217375, 0.17133525782643722, 0.07150261680261571, 0.07331750333132336, 0.06548682990713606, 0.06857905748607773, 0.06807612216352665, 0.07488369463184441, 0.07584546347791388, 0.08497975999196972, 0.07539119643308478]}, "mutation_prompt": null}
{"id": "dd715d64-103f-40a4-a6d8-b86072203714", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        if np.random.rand() < 0.1:\n            adaptive_F = np.random.uniform(0.4, 0.9)  # Adaptive strategy change\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.8, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedDifferentialEvolution", "description": "A refined differential evolution with adaptive learning strategies and dynamic parameter adjustments to improve convergence speed and search efficiency.", "configspace": "", "generation": 41, "fitness": 0.30980960917157413, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8539153729907802, 0.8474100916000966, 0.8589300027641599, 0.8494075368123196, 0.8256348611735183, 0.8527870976446319, 0.8725662924734521, 0.8652178506857918, 0.8443148455705303, 0.619891237474133, 0.706988803128227, 0.5577074996847596, 0.718084256630017, 0.49353828688132995, 0.7339859926837379, 0.7631499551659158, 0.7187097846583334, 0.7350269934449842, 0.13622287258841248, 0.2336184601104997, 0.13319805541488094, 0.1756609881882112, 0.15234477894503473, 0.15185511900524984, 0.1397007605384597, 0.1320768566827113, 0.14542749260905252, 0.14240996806330786, 0.11978872407054308, 0.14162585304825626, 0.1554015298090612, 0.12726949809436605, 0.13623199710066458, 0.11532317987379681, 0.1449571813640056, 0.10828532641344424, 0.8839189136398043, 0.7794107412167804, 0.9747050566094627, 0.906088608098762, 0.9491702282167996, 0.9386925013645445, 0.9287321325396132, 0.9361652846455719, 0.9308517018775453, 0.2638846122842151, 0.11323292937322926, 0.1803068691184453, 0.323257658426074, 0.12464575597139771, 0.20716802983002014, 0.43196502509428636, 0.3298392449412264, 0.3886758079106558, 0.722404588760204, 0.6249841046170262, 0.8056381120990167, 0.6892783779772327, 0.8373614594837092, 0.778693802111081, 0.6019046546427854, 0.7181057074625282, 0.5095662039481952, 0.23066716144165722, 0.12592060368174862, 0.17851317152365287, 0.12899203106187984, 0.23291353830166195, 0.12761030930021244, 0.15545453170868984, 0.21795025011819502, 0.2191493776186294, 0.21472625289477143, 0.2448555718644344, 0.1302724980481742, 0.2785515502543443, 0.17829673625051234, 0.15271460857522667, 0.23182892686345935, 0.1337983381311122, 0.22540984541509956, 0.14208564809157775, 9.999999999998899e-05, 0.17101747362888187, 0.18872715360102543, 0.08654027336408743, 0.12622275740534372, 0.14079974417719454, 0.1586008348599871, 0.26089683222405546, 0.20810588752951897, 0.30181124153484384, 0.18468598810118575, 0.2676849541083729, 0.3479331508368487, 0.14020616427055432, 0.18301211377597026, 0.31443440520950094, 0.278120185393135, 0.04441489552546807, 0.05369008592042934, 0.1045279364081576, 0.20440564126690608, 0.09193720098864433, 0.10364665053342559, 0.2275126193584841, 0.06682853863961113, 0.08001665642430522, 0.11504378426459294, 0.22791228079857684, 0.21689286988554424, 0.09135732436373545, 0.23763862561937088, 0.3844455554272045, 0.20352576953859214, 0.17371568055620823, 0.18295106002203287, 0.5330385547659566, 0.5112791352898136, 0.6265950367462805, 0.5727877762457096, 0.6281357684173194, 0.6628700876640531, 0.7190128141960243, 0.7042134739250018, 0.5728160047009823, 0.09047249198068075, 0.11132508433195931, 0.1022762475154334, 0.09514109237483825, 0.0885849152354724, 0.0917235611046332, 0.08330509948740272, 0.08909754278061388, 0.09816132495138286, 0.11060155815313322, 0.1616102837374951, 0.13287782968254302, 0.13865681806506813, 0.16383908334919184, 0.1364507450443091, 0.2013663232715649, 0.1295448140187072, 0.11833639081931213, 0.34373953915760336, 0.2790476322782821, 0.30758219517349084, 0.3268613994968722, 0.39783131393150695, 0.2852223287647103, 0.34707504823674795, 0.3542158612102707, 0.34045040733351184, 0.261102038613626, 0.2798236677808583, 0.20844141917299952, 0.22731459556151679, 0.2427250807487532, 0.23613449908652095, 0.2847736067126956, 0.30938924579252824, 0.21323352337949375, 0.18562369046545124, 0.19861111065908987, 0.20018098267924433, 0.18174150118296484, 0.21306492677171485, 0.2175981085046237, 0.19082326295701268, 0.17223847089803168, 0.1806595136685919, 0.18260532517469186, 0.21546461346576629, 0.37465410293076773, 0.25474660786606873, 0.1876170353264177, 0.17302005064391213, 0.17858982337466367, 0.21708471512213678, 0.20436728510172697, 0.3907397106178876, 0.16141118358651074, 0.6084746340693608, 0.162256075949041, 0.18419883801775028, 0.1662442362057165, 0.7284777535972946, 0.16428551438731842, 0.16565532587379317, 0.16157170659930375, 0.16641621020640418, 0.4282034798073996, 0.20826183152451994, 0.19803746898142027, 0.16545181183074942, 0.20912604917197752, 0.5968114938102095, 0.2100734371009405, 0.18770952757107362, 0.1765725475511405, 0.18846844616554992, 0.19309920754921062, 0.18172680907237715, 0.1748762675627844, 0.18763165482066402, 0.16886603734937944, 0.1735981456097505, 0.06676423248868757, 0.07382750543414474, 0.06432584423080878, 0.07524847983687921, 0.0792265012030452, 0.07449588117407424, 0.07008595411202989, 0.08042557475942214, 0.0720690137979132]}, "mutation_prompt": null}
{"id": "0581a62c-e303-4795-a0bb-e41060d4cc82", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def fitness_diversity(self):\n        fitness_values = np.array([func(ind) for ind in self.population])\n        return np.std(fitness_values)\n\n    def mutate(self, idx, func):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        diversity = self.fitness_diversity()\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1 * (1 + diversity)\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx, func)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Introducing an adaptive scaling factor to dynamically adjust mutation strength based on fitness diversity for enhanced convergence.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {}, "mutation_prompt": null}
{"id": "1f5385ac-3c3b-43f0-bfc9-7ffb5771cc36", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.initial_population_size = min(max(4 * dim, 20), budget // 2)\n        self.population_size = self.initial_population_size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.evals = 0\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        self.evals += 1\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def dynamic_population_resize(self):\n        if self.evals > self.budget / 2 and self.population_size > 10:\n            self.population_size = max(10, self.population_size // 2)\n            self.population = self.population[:self.population_size]\n    \n    def __call__(self, func):\n        self.initialize_population()\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while self.evals < self.budget:\n            for idx in range(self.population_size):\n                if self.evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n            \n            self.dynamic_population_resize()\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "A modified Adaptive Differential Evolution algorithm incorporating dynamic population resizing and adaptive learning rate for improved convergence.", "configspace": "", "generation": 43, "fitness": 0.336185085959783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8558067534710863, 0.7120653562976866, 0.835672017635771, 0.8425818862114427, 0.8564035034879076, 0.8218556617277377, 0.8789689009743785, 0.861097555285652, 0.8436811054665991, 0.7370748549103296, 0.6764201053837433, 0.24344332960417014, 0.7565863650529556, 0.708029862881711, 0.7397705776235737, 0.7359702932913363, 0.7150400155809271, 0.017417907966684076, 0.18122792320995074, 0.12641278833400083, 0.11543636802268242, 0.14991191168456297, 0.15013482915834575, 0.11622982942630133, 0.1324443239578622, 0.11873315546305763, 0.13940471548010114, 0.10871947975316876, 0.11821784773048971, 0.14274304522590286, 0.10473429577877269, 0.10021028371296126, 0.11830639113858199, 0.1110314542490729, 0.10392901411871458, 0.11070141773652908, 0.8798791112697484, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.8858604558230023, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.37178708934968396, 0.18783352566599343, 0.2858988673785914, 0.4069972714192467, 0.16035997870998997, 0.3593953806238199, 0.8468334574599534, 0.7768475333130712, 0.6285445350285669, 0.6645412793090701, 0.8319850544678028, 0.7347459926936938, 0.8771454346934292, 0.8414628059036096, 0.7367032514386522, 0.15706054111730738, 0.16197857112410496, 0.12364927714049789, 0.26683293429395527, 0.28033237120723964, 0.3081518650306323, 0.16029071752978763, 0.23992256772361475, 0.17462797812751452, 0.19516394017586103, 0.22359926902688054, 0.1406801924588823, 0.21723867809396913, 0.17598077795579048, 0.12980441364801276, 0.12783242606600143, 0.26924477967967764, 0.3052404582107897, 0.2920201048574803, 0.13269882400444966, 0.12250646229714635, 0.025412445280017515, 0.290193448981371, 0.01015506712917813, 0.08852249147025837, 0.3327016211471332, 0.27626592026787755, 0.4041687152028831, 0.3389759188964425, 0.3384934640253118, 0.12483916317504173, 0.3511515961677857, 0.3401261396199553, 0.1524582748914749, 0.4238889560505885, 0.366181132501176, 0.05220620836060441, 0.12539542502127277, 0.2130993110130407, 0.07408232064815967, 0.21770137756842467, 0.3333143221270528, 0.14977804325225896, 0.2930250074724067, 0.09041150879066806, 0.11871316333810444, 0.1436668176253756, 0.28108792209873346, 0.27071923924101926, 0.2241709163335418, 0.3251671251270186, 0.2146127313272861, 0.24684614955821482, 0.2793957292397907, 0.7288237737384289, 0.5450905925966292, 0.5520746918120754, 0.7775759108539199, 0.6561405404510117, 0.8087139535449772, 0.5119943519169622, 0.6285172705927664, 0.5685607316864372, 0.14056380451002337, 0.09051126264590914, 0.12456490372253426, 0.09706401924562846, 0.13193675058028498, 0.09496867093337136, 0.1210714860388058, 0.08439474336838648, 0.10427537153115063, 0.1472971256939607, 0.12598542058784845, 0.12054533364004727, 0.1520236024329954, 0.18692937878632065, 0.3151379770729772, 0.16025638304468537, 0.2410336204265322, 0.16521591796394985, 0.4364139068086559, 0.5131543720641202, 0.31187036021139636, 0.3641168627400251, 0.3488372538202489, 0.3118947617690837, 0.4277536609546889, 0.44043723463450624, 0.318912033794469, 0.3224190047504061, 0.33764752944103016, 0.3027403218767232, 0.26247736039171665, 0.24785705152166349, 0.23474848037828255, 0.2769175113514032, 0.272806793717303, 0.09473939548414823, 0.1862709506810165, 0.1634302535012494, 0.16342054362485614, 0.1765504840142086, 0.19113565935496057, 0.1800917274961592, 0.18712576595158936, 0.19258630247369857, 0.18809843960033246, 0.29048333727859166, 0.20227047563903888, 0.17771362783729183, 0.26440549536691227, 0.18088606690102949, 0.1849484853535599, 0.3923404862756611, 0.19427925857917006, 0.23291773952522432, 0.16347379650822402, 0.6975795417348972, 0.15050497149040076, 0.8310587346403054, 0.6508206830345746, 0.6469838004405642, 0.7388861417085049, 0.16531908563810904, 0.5080257753951918, 0.6905895069042383, 0.20379648690133378, 0.2025180555693411, 0.20476198117433175, 0.1626544630805149, 0.16712206248163763, 0.20581989383244925, 0.7251714655982322, 0.7595098341857599, 0.1869256281308358, 0.17503591029887944, 0.19545032166751375, 0.1717670201118664, 0.18851341926651488, 0.1685417980988324, 0.1837593802188653, 0.17950431590217375, 0.17133525782643722, 0.07150261680261571, 0.07331750333132336, 0.06548682990713606, 0.06857905748607773, 0.06807612216352665, 0.07488369463184441, 0.07584546347791388, 0.08497975999196972, 0.07539119643308478]}, "mutation_prompt": null}
{"id": "7c3ece38-3169-41f2-9d13-2edba3b3f0d9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.adaptation_interval = 100  # New parameter for adaptation interval\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        # Introducing a dynamic scaling factor to mutation\n        dynamic_F = self.base_F * (1 + np.random.uniform(-0.2, 0.2))\n        mutant = self.population[r1] + dynamic_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n            # Periodic scaling adjustment\n            if evals % self.adaptation_interval == 0:  # New condition for interval-based adaptation\n                self.base_F = self.base_F * (1 - 0.1 * np.random.rand())  # Slight decrease\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "A partially modified differential evolution introducing a scaling adaptation for more dynamic search space exploration.", "configspace": "", "generation": 44, "fitness": 0.2540017463178805, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.7208322189643057, 0.4798367998748021, 0.6067830931225904, 0.32906798384813196, 0.7728004826092278, 0.30371262502736385, 0.549712278331371, 0.40634752837461974, 0.48927121500481485, 0.5104742241168427, 0.2484872665639477, 0.10243586777967284, 0.2003590441747768, 0.3340033487157136, 0.09003831695728781, 0.054322776663992545, 0.13328571607443118, 0.14308054908878276, 0.1548997007946753, 0.21797347483510476, 0.16386047820874305, 0.15949283714414453, 0.11438486105079282, 0.07378525736921515, 0.10888720509815086, 0.15852830285450215, 0.3753455767186963, 0.14355430167884164, 0.134104800848726, 0.15172050615535593, 0.11631847214065405, 0.12489914820834858, 0.11580606557094031, 0.11107489929088066, 0.10333561241264144, 0.10415234951240215, 0.8123894638460751, 0.5272849270090874, 0.9607698843960869, 0.9081992622977547, 0.9288816226156598, 0.9328761409636356, 0.22530330234683948, 0.9058005916463119, 0.9134607320254726, 0.1286439855705508, 0.08672110884918416, 0.08522587289521322, 0.1072610970846315, 0.17193812383009988, 0.17572373440873323, 0.06240070283135701, 0.1486773885141549, 0.15589463124949365, 0.8242851367940806, 0.36438575302615717, 0.16817726838854252, 0.3744161872284627, 0.5106056224944442, 0.3608850487347134, 0.3556453959511904, 0.3903737511247365, 0.8926418911689271, 0.1528932539082709, 0.17844602114025765, 0.13821822612094659, 0.2614439907405094, 0.16867784163510713, 0.13008631164730755, 0.12617952077790673, 0.1300782588131678, 0.13132642042735787, 0.14456299298543496, 0.09375246586323116, 0.09755572975733917, 0.15293005374737256, 0.1434418624028576, 0.13739071189930985, 0.1283673579892648, 0.09937225989387266, 0.1696119936353272, 0.11863887421857922, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014545027813949174, 9.999999999998899e-05, 9.999999999998899e-05, 0.01911193188179272, 0.01919803591970992, 0.23482110273938117, 0.20591396795123773, 0.13926932353639787, 0.09921395199244543, 0.1332726365989172, 0.052666127711543, 0.05133307772813711, 0.25818230968084777, 0.10791759302479498, 0.21311098563940722, 0.10127467321118, 0.10377284828319011, 0.048640998831877, 0.2193105414891301, 0.15135533528178124, 0.2499667241283472, 0.1400207547875154, 0.18649767487346158, 0.09118868398564994, 0.07109174056228718, 0.26411838532199494, 0.11718053868171008, 0.1483397295095762, 0.23001488744491516, 0.166182147644084, 0.39264058040424477, 0.14416858291998547, 0.20616561625417407, 0.5060694497960947, 0.43465711256371087, 0.504093120806834, 0.5725781850679887, 0.3322393500867993, 0.4833396528867929, 0.5573301206500214, 0.4740699380339868, 0.5038201295662793, 0.09725514635797283, 0.09821070144672084, 0.09507772523081126, 0.14079582517083689, 0.09252759900916518, 0.08902477365518369, 0.08232468728921483, 0.10003121993053443, 0.09623557483835143, 0.15663833739013222, 0.17926369375978024, 0.17358958283690917, 0.14505408445577728, 0.1853048803273658, 0.15589755878757683, 0.15028656853215894, 0.23468635816194428, 0.1869157828515975, 0.5922016842974596, 0.37844628034755134, 0.4518003921685271, 0.3752793210267833, 0.43769277010549545, 0.306470594899654, 0.44445138257395234, 0.3902494708091325, 0.4712695155182062, 0.3239210166425255, 0.3867983865484531, 0.19882102835353332, 0.27494078721051074, 0.27671154480308524, 0.24419700896512564, 0.49101009916631333, 0.2838635076757724, 0.2413174699469488, 0.18581738537662496, 0.17555588793921983, 0.1968593503334486, 0.1877349136597497, 0.1797500301048649, 0.18146763786650466, 0.18896282039424595, 0.19185240467880604, 0.18526533631208053, 0.2116263111842741, 0.20648286046932995, 0.4306809755256501, 0.23602798762261623, 0.19317133021795885, 0.20252130805987112, 0.20873589342250254, 0.3128741504347723, 0.5196998662740632, 0.16133867177374628, 0.855582038296645, 0.11544100316288275, 0.6726970790791964, 0.18852678414249768, 0.1900447515182051, 0.7800534470840962, 0.1657311416590863, 0.4883250617324778, 0.6669571585150681, 0.4484365636854435, 0.11306678335151432, 0.20069384538110868, 0.1644799518578135, 0.16647795004080057, 0.2066291742022539, 0.3123355819509738, 0.20694905431994803, 0.1920381691758586, 0.17319233703836567, 0.1739460266079863, 0.19785704740643584, 0.18397974971400077, 0.1807702107740663, 0.17099131193089834, 0.16287468216377687, 0.18976985673367686, 0.06786129591342671, 0.08008909530726982, 0.08260139236141983, 0.09272092057821668, 0.07352632801137093, 0.06780596223172597, 0.07445417678968647, 0.07411064874541007, 0.07356213011706092]}, "mutation_prompt": null}
{"id": "b449dfdc-f435-4d3c-bac7-f3f68bf066fa", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_population = True  # Flag for dynamic population resizing\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n            if self.dynamic_population and self.population_size > 10:\n                self.population_size -= 1  # Reduce population size upon improvement\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "An improved adaptive differential evolution using dynamic population resizing and adaptive selection pressure to enhance convergence speed.", "configspace": "", "generation": 45, "fitness": 0.1975678853887075, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.25916407257185725, 0.4459791699001987, 0.3035846804336416, 0.19925790159959056, 0.3651971925288514, 0.3714766502379222, 0.4291705896969654, 0.38125047039422677, 0.3715976667707186, 0.06013307618469099, 0.058506515248035296, 0.0650469884373106, 9.999999999998899e-05, 0.05277372196977992, 9.999999999998899e-05, 0.0552197490796581, 0.010068923044010636, 0.31569523568443525, 0.17026424519836802, 0.12096611076894892, 0.09140621713362018, 0.16139996094699305, 0.09611570334100561, 0.613319232276851, 0.15676793473960882, 0.1517030002327403, 0.1636902840050316, 0.11405837221240067, 0.15058817643171418, 0.08615997275710285, 0.1510033552825285, 0.10756891126593726, 0.07779555629922741, 0.09609097945969458, 0.0829371784748979, 0.13438910333879683, 0.3153437163859384, 0.12459836057481899, 0.11336989229781735, 0.9361864912714599, 0.08231571499333046, 0.9635341385080893, 0.16651909488330907, 0.11046697224156232, 0.9801062788795593, 0.17592976776785307, 9.999999999998899e-05, 0.17623792161509788, 0.20506854192254564, 0.05517077200063958, 0.7119843112577058, 0.2033173779300037, 0.11052123164209893, 0.008955961547916003, 0.8815390237462883, 0.21708456532398845, 0.9211453190374623, 0.1926275007564855, 0.1916976142088862, 0.35886855590923816, 0.37649740372196083, 0.1776842840075593, 0.12532504013285362, 0.15980937239399196, 0.1504304948735431, 0.18215194543611635, 0.19491856910521566, 0.12490561357300578, 0.14959170329095528, 0.14649329280183787, 0.13156325830622717, 0.12199063444341518, 0.12194605160182859, 0.010021246093846692, 0.12757239420933952, 0.15499150225780467, 0.18258607124855186, 0.13347414825319115, 0.30385425835825886, 0.15345423602011432, 0.13635944345003936, 0.07714320331719304, 0.08804878280629413, 9.999999999998899e-05, 0.041630642711978694, 0.10259945884549981, 0.10254271612748722, 9.999999999998899e-05, 9.999999999998899e-05, 0.10224713070518665, 0.056726619578126525, 0.07491500957776953, 0.050275202228208804, 0.1630011829739726, 0.022418232269063254, 0.11167903995356243, 0.2436225492493742, 0.08239395430632213, 0.1488275474915688, 9.999999999998899e-05, 9.999999999998899e-05, 0.010135835990740638, 9.999999999998899e-05, 0.000655337654585364, 0.10596132231720656, 9.999999999998899e-05, 0.08622432683038384, 9.999999999998899e-05, 9.999999999998899e-05, 0.06944140413422484, 0.0184047933353777, 0.19032581835222973, 9.999999999998899e-05, 0.06150879626910699, 0.13876812628838342, 0.0668871272805609, 9.999999999998899e-05, 0.5235577236954891, 0.32930110572458937, 0.2026095106654059, 0.29519328572572034, 0.2259020547699604, 0.40921277561504366, 0.23026473667126213, 0.38066571975321006, 0.5154090353076304, 0.055673404225514256, 0.0710296285159433, 0.10344116616572918, 0.16887948841218736, 0.09138481547544686, 0.12231116636043737, 0.11580552556931967, 0.1347594580774465, 0.10789043746762728, 0.15176119776897545, 0.19782758293288172, 0.16493715996683644, 0.146747243149417, 0.13206593217675966, 0.3220797921036035, 0.14827387001481607, 0.23088938297860873, 0.15950188240885532, 0.39039506378585986, 0.28399399117112945, 0.4201925569583814, 0.31864067532812357, 0.2564840320610845, 0.3563777847484866, 0.40245429340372574, 0.46068105154042827, 0.3352955862354049, 0.2535705801921392, 0.22778798697887592, 0.3544418086827633, 0.2233430610284659, 0.21123880797481276, 0.269585472278819, 0.14751496025897526, 0.24347863204702602, 0.10878961620794703, 0.1589251404257611, 0.18339577042367183, 0.17682180542364856, 0.17660089952116176, 0.2214064478411809, 0.18742137987360408, 0.20557400824322491, 0.2037048298594336, 0.16357203367242057, 0.18610930866625686, 0.14019448384816535, 0.2304035020572074, 0.6277514072768977, 0.22482428194252102, 0.5672476630519634, 0.1940472910405049, 0.18589857982261015, 0.18348026259265104, 0.18313383161025, 0.20679258195876593, 0.16675324038948258, 0.19464115828192352, 0.19642080639841808, 0.9086980783827756, 0.8136127976334836, 0.1613581097393666, 0.16790791810759198, 0.20851201756017246, 0.20072819547279808, 0.16454899592341843, 0.20771230561188858, 0.1651544062364555, 0.2015421166339043, 0.21030966888714575, 0.16602193188814274, 0.3126217151363587, 0.17023939351545525, 0.18441637037620984, 0.1960870559408936, 0.19173038734131465, 0.16972250941143252, 0.18273486794328708, 0.15917966663635086, 0.18492366278707384, 0.17852112263045306, 0.10198414352101715, 0.09299782947523016, 0.0792831289592586, 0.07071335764299147, 0.0712091160927002, 0.07261024372266511, 0.08771845931404876, 0.087084154914293, 0.0816766128962334]}, "mutation_prompt": null}
{"id": "08426cbb-b014-4425-995b-2465781d8b49", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)  # Adapt population size\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def periodic_reinitialization(self):\n        if np.random.rand() < 0.1:\n            self.initialize_population()\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adapt mutation factor if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:  # Adjust mutation factor\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)  # Adjust crossover rate\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n            \n            self.periodic_reinitialization()  # New reinitialization strategy\n\n        return self.best_individual, self.best_value", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with periodic population reinitialization to escape local optima.", "configspace": "", "generation": 46, "fitness": 0.14416827075009675, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.16.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.256461453845801, 0.3566263692801812, 0.2758627778243783, 0.22663629964596743, 0.2653823818124077, 0.2753853858591163, 0.25734637952634964, 0.3390651483980345, 0.24155256880965892, 0.04957169749215773, 0.08169005149886777, 9.999999999998899e-05, 9.999999999998899e-05, 0.015207369869542742, 0.020019770383048363, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05669901124295451, 0.09033597558603179, 0.04893960226844951, 0.06851371346834911, 0.06812679114158704, 0.056766596679441284, 0.07193172126312197, 0.07272723640821332, 0.07517134332794284, 0.04858516181235373, 0.07985446145784336, 0.050929303742072274, 0.05177076850408846, 0.06615626075961756, 0.058311271137367116, 0.05869285808628755, 0.053237249342199755, 0.05435476151401131, 0.8988257621771651, 0.7254721498338081, 0.8098293704415468, 0.8271827206077822, 0.8154945861605201, 0.7759628383259296, 0.8234399636851462, 0.8347224948815143, 0.8839095547899346, 0.08760724787088692, 0.10322718617910176, 0.10510664136760783, 0.06254983501630063, 0.08610911740678551, 0.11015041556031535, 0.07658864572431068, 0.0894086026098243, 0.1083010566638326, 0.20324167032133544, 0.2209401006923476, 0.1676646663177911, 0.15727606463238042, 0.1659532180599379, 0.16942507809155027, 0.14750369964685106, 0.232056915365634, 0.16534363826057363, 0.09498691573095897, 0.08719146330581584, 0.04640210676423506, 0.02728728773611433, 0.06913631098249984, 0.0458381764025918, 0.058631758485584995, 0.11958099882406892, 0.0277404447879408, 0.06301769014996894, 0.06391602080207281, 0.0879970857637058, 0.10065530820773105, 0.05140394309491636, 0.010776556360551304, 0.06614416310308824, 0.07890504394287667, 0.03284017352471058, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10730831490131243, 0.08154371825913587, 0.06661302147851089, 0.10366513058637061, 0.12779193488625884, 0.036847593106639764, 0.10881824740176038, 0.1507369587000914, 0.04884952696444744, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026127506583453752, 0.06702159370764293, 9.999999999998899e-05, 0.0004724111778720008, 0.04799391976558487, 0.01054370441220398, 0.0026880391534553905, 0.04004661822697819, 0.020801730899372872, 0.26144242316696875, 0.24150873507412562, 0.22684371034723483, 0.29261125402668897, 0.25267776977507106, 0.23443607914697917, 0.2704989632306257, 0.3461679278567322, 0.2578604577836272, 0.06562514245048245, 0.06263830357696554, 0.09526079318392944, 0.05467364457941093, 0.07675157856772696, 0.08632924061252956, 0.07060794274870563, 0.058670396374477796, 0.08581484449369203, 0.13057742219142765, 0.1383261142691986, 0.1196235602496174, 0.13125998098308156, 0.13367399959910375, 0.14469674666309817, 0.12376091503807651, 0.1575242039979725, 0.15260265949193674, 0.18790595913200514, 0.1720441634234834, 0.16688826209433427, 0.18529667377594616, 0.18190077100175983, 0.16536829507909678, 0.2051331287878344, 0.19956905499959698, 0.18098609786470055, 0.1296460570879231, 0.1916350023660789, 0.1196581942372339, 0.16259484554190518, 0.12856887632691671, 0.13360167751152985, 0.1319293754308477, 0.1254914177344939, 0.1250606763530131, 0.17170342299547114, 0.17352778755107645, 0.16503301737676468, 0.17184798434160697, 0.17761423236887275, 0.16891588044987516, 0.15777238015678163, 0.16930713164485645, 0.1755129167937759, 0.16858106661539163, 0.15936660337321296, 0.16010548378739708, 0.16442745401357028, 0.16389603991077006, 0.15746579192691712, 0.16606774030224847, 0.15994426807810924, 0.16733116808866322, 0.15762271176048448, 0.21679621832243334, 0.1412237101806555, 0.1470794639013755, 0.1384449718535843, 0.1285030483108498, 0.16126817785441272, 0.16657663559235258, 0.16457954993581903, 0.17314006911317048, 0.18873559187571798, 0.15171814199523037, 0.16667276199722603, 0.20150742704458136, 0.14026288736300374, 0.18868382724287258, 0.18393033259260827, 0.14651623853958007, 0.17752602818362462, 0.183900875259576, 0.18331461484876221, 0.16839296249297608, 0.18781318676833658, 0.1756355521721602, 0.19332253518449372, 0.19049300652307288, 0.1885714064481333, 0.063933635849448, 0.05354821911135843, 0.050826249553905245, 0.0625386765797109, 0.06556746062230046, 0.0569090851176145, 0.05959346453825676, 0.061463018676365166, 0.0616446297526112]}, "mutation_prompt": null}
{"id": "a1946ce4-14d8-43a4-9848-1cf6e8efb554", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95  # New parameter for dynamic population adjustment\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adjust mutation factor and population size if no improvement\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))  # Dynamic population size adjustment\n                    self.population = self.population[:self.population_size]  # Trim population\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution incorporating a dynamic population strategy and early convergence detection.", "configspace": "", "generation": 47, "fitness": 0.35554185386094755, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "6b0741bb-f107-4297-a137-5140f9a7abf5", "metadata": {"aucs": [0.8566719375492663, 0.7120653562976866, 0.8382016229741264, 0.8425818862114427, 0.8564035034879076, 0.8349111039234651, 0.8789689009743785, 0.861097555285652, 0.8461401239717713, 0.736317215943677, 0.6764201053837433, 0.24344332960417014, 0.7564231710250706, 0.708029862881711, 0.7395737053452384, 0.7359702932913363, 0.6888748431129932, 0.017417907966684076, 0.1554954906045325, 0.15180594326353858, 0.14203730129237502, 0.14028651515571433, 0.1420982454120041, 0.1271579091659154, 0.14070904866968614, 0.14006282271129, 0.5096930316794268, 0.12373350599941735, 0.12204464951134342, 0.24890129151344687, 0.12141953318173948, 0.14085415467877715, 0.10726554775329256, 0.13026739706410517, 0.1320535638010184, 0.12411123520027145, 0.8757578770374052, 0.8592383490543841, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8861591396122206, 0.9228013366856397, 0.24107616367029028, 0.420218807503725, 0.21478675889037246, 0.4637370201098141, 0.18783352566599343, 0.2858988673785914, 0.4941696222451061, 0.16035997870998997, 0.3576669736997935, 0.8468334574599534, 0.7267591685524462, 0.5877054698496471, 0.26951369125307445, 0.8520734966558955, 0.7945330345118742, 0.8430731277400995, 0.7583600080739137, 0.7593519594129887, 0.1632429330326597, 0.16273935773164683, 0.12364927714049789, 0.4174969012526001, 0.30676089122553996, 0.610751063914946, 0.16029071752978763, 0.4567008525030998, 0.394947790742603, 0.2852856505245315, 0.10860018512970471, 0.1406801924588823, 0.3993996667121502, 0.17598077795579048, 0.4700604260134378, 0.12787723206110135, 0.1902256905609775, 0.30190373248011204, 0.3030863452466981, 0.13282830857944705, 0.13324213942061347, 0.025412445280017515, 0.2546562193414469, 0.00910843717268528, 0.11139778417536506, 0.3234726102208928, 0.32517567378768275, 0.3577154380619093, 0.336149412733347, 0.3373157639498724, 0.12856790017196618, 0.3161110888852817, 0.3661860480967585, 0.1585416729470116, 0.4262590651763212, 0.3921168360334626, 0.14546452703628965, 0.13527672043896255, 0.1938436927463585, 0.07408232064815967, 0.2760695297250597, 0.22767288401267505, 0.15015351241563402, 0.2805161669582964, 0.09092281056240681, 0.11871316333810444, 0.2028413225337763, 0.3391605976212221, 0.27071809089259846, 0.3644685013654041, 0.32106883646743023, 0.21461242085289534, 0.3038305288803287, 0.363261748279867, 0.6734557426557255, 0.5450905925966292, 0.5520746918120754, 0.7044168366559105, 0.5467091982929202, 0.7471101372566492, 0.5119943519169622, 0.6200579212273916, 0.5881316715364904, 0.12303297471638819, 0.09855885373342532, 0.1511940123867913, 0.11167992075561073, 0.07728914007704424, 0.10926534057999637, 0.1337826498157768, 0.15380483051204807, 0.1336150807850981, 0.1511683774580015, 0.11899894299168245, 0.12271619984113602, 0.17112082544646656, 0.5227659941938054, 0.17790692888549764, 0.12792197384476478, 0.23839003595302077, 0.16237291722732183, 0.4355740755975669, 0.4816231318819696, 0.343722311719607, 0.3782694418795677, 0.3729396248967676, 0.3811661260652207, 0.5281463718564465, 0.4546186755136792, 0.3287450686279362, 0.3588377269612453, 0.2809890803459554, 0.37104383210871306, 0.30355005663557677, 0.23321038245484782, 0.29526723987348946, 0.2705161155047724, 0.340096960889133, 0.09475231422624819, 0.1913526497004806, 0.1641949197470456, 0.19824994121842954, 0.17897929058012718, 0.179986100136598, 0.18515824774421896, 0.21267424228702214, 0.20716639092293565, 0.178667046404259, 0.19705321500251816, 0.2215053864277554, 0.17864052784198647, 0.5755405797145005, 0.549416058181992, 0.5174512224918544, 0.23150739897410666, 0.19683671308269257, 0.22695480524742961, 0.16347379650822402, 0.8425112605947649, 0.18245530159907597, 0.8446929316697314, 0.7982331389140837, 0.7253397826061688, 0.19823560292523545, 0.1648589715078559, 0.16217967769098307, 0.7850251029545545, 0.20379648690133378, 0.7284985836298639, 0.2060827015986989, 0.68791394553798, 0.16712206248161332, 0.2023591016973716, 0.8122974266127231, 0.7742632531892056, 0.18492884955138755, 0.17791850403827847, 0.18331461484876221, 0.18071919243593715, 0.18384117036840464, 0.17217585789231504, 0.17293854228854966, 0.17939352214428894, 0.17887639547003642, 0.08600579870750602, 0.08448261995747086, 0.07997470159302833, 0.0588853779406141, 0.07421031164711689, 0.07621632364424602, 0.08219607184586131, 0.05653935086898343, 0.07200312188401092]}, "mutation_prompt": null}
{"id": "4a25de14-f40f-4aee-990e-bf5f206bb906", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.55  # Recalibrated base mutation factor\n        self.CR = 0.85  # Recalibrated base crossover rate\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.55\n        self.base_CR = 0.85\n        self.dynamic_shrink_factor = 0.93  # Adjusted dynamic shrink factor\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.8, self.base_CR - 0.05)  # More aggressive adjustment\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Enhanced adaptive differential evolution with recalibrated dynamic factor adjustments for improved convergence.", "configspace": "", "generation": 48, "fitness": 0.3452009415976977, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "a1946ce4-14d8-43a4-9848-1cf6e8efb554", "metadata": {"aucs": [0.8088170433042794, 0.8465682721584888, 0.8199619421128955, 0.8462613121559264, 0.7911055443189727, 0.8355513266140726, 0.8317465548049263, 0.8213625896437267, 0.8229850086536085, 0.7058991475937142, 0.6635929976401973, 0.6585472605247824, 0.7101782455001687, 0.6816432010893736, 0.6746530061348018, 0.7090263675270749, 0.7113322129477035, 0.7067465210176693, 0.49945305646891824, 0.16040049693705238, 0.15952787767059284, 0.529323556984958, 0.42379576495347415, 0.1577416566682861, 0.16442599887142784, 0.15512701623249814, 0.3160798485319185, 0.1466684058509352, 0.1293278906277887, 0.142246184100135, 0.11707262483496084, 0.1403469597759589, 0.15192273739852458, 0.11444468570358202, 0.143810649634454, 0.16151190892834544, 0.9603999431617356, 0.8630229062005794, 0.9379873379018844, 0.8686917940818368, 0.9552889150029127, 0.9384641610365605, 0.9150521203449002, 0.9271474183981797, 0.9513635209815575, 0.5244058499182997, 0.317523732484535, 0.4944101506943388, 0.5452415381715164, 0.4882399364961326, 0.5005806957795118, 0.4896719830605254, 0.47513065356729367, 0.4113745742321, 0.775468127871335, 0.7683823190168361, 0.32617303134329856, 0.6944021090687367, 0.8045847237832324, 0.7516767043732393, 0.38176400930248333, 0.33108506947810634, 0.6973551038138381, 0.14964683757632136, 0.2967892398769689, 0.16345947482008272, 0.3737524312190371, 0.21934690087335718, 0.15617013170644745, 0.15442959593489125, 0.4216042902174989, 0.3306318725835614, 0.2558521355602851, 0.05785508649642923, 0.23082693263049736, 0.34003276505796165, 0.14674896134755977, 0.33151577257866616, 0.16542634365547115, 0.16707825274583954, 0.3207336735788239, 0.06143897464669257, 0.07915955503621064, 0.09968135346252982, 0.10076017710322172, 0.18307951195456484, 0.07797345805664502, 0.1251704568766452, 0.042996134465102864, 0.22838234386959655, 0.33466263742252245, 0.16907240880183527, 0.14878300549107393, 0.2699280838684984, 0.1540660271440436, 0.2506950586838571, 0.34040542066919166, 0.2984565715162443, 0.24156038987485284, 0.18792691582926369, 0.15541073887036505, 0.12150925194260398, 0.17562755084426296, 0.17442123372311757, 0.15695160535507935, 0.10146129336878351, 0.12810711917941664, 0.1326363733738175, 0.22397898585895082, 0.25861522171079154, 0.2050463274319736, 0.3014683274425507, 0.2713888069198249, 0.26382300543713444, 0.1836798931290149, 0.2503736450900971, 0.21848456013606432, 0.6045489591070412, 0.6302352676039442, 0.6318303875491953, 0.5772174138140208, 0.6149634436233047, 0.6256940516484022, 0.58833258617663, 0.6276216647958524, 0.6275267789963397, 0.08922197504099927, 0.09941699601667098, 0.1552941562285205, 0.10802044421545431, 0.1342877468950654, 0.11800109951121163, 0.13905958466710433, 0.10168858394675062, 0.13009656169791384, 0.11304068174463133, 0.14688674844003557, 0.17632970806475767, 0.1696816957324898, 0.13876294622500207, 0.16073358052586684, 0.24983861608697422, 0.1362389223075826, 0.15347849643382838, 0.5157377661414144, 0.3672049553556631, 0.3755944502983497, 0.33462727925602476, 0.39776874975333665, 0.4218020368143012, 0.402484745627107, 0.5051871974798814, 0.4262583575617346, 0.24162046816320926, 0.27746550726130004, 0.2675593011284516, 0.24679211148629066, 0.2756721428911546, 0.250871507127326, 0.2817097904746767, 0.31192704363390533, 0.3236150717602011, 0.20842666566622448, 0.21312374534368717, 0.17846120474215788, 0.19176469895042925, 0.16487043382762767, 0.17074906755605812, 0.22394768456860126, 0.19836932750475378, 0.1830803545024865, 0.21570811946253465, 0.49868373223578333, 0.2202818503920384, 0.5511659256442816, 0.21336493509775, 0.20697138633699474, 0.19841049336114525, 0.20768763312235183, 0.6377456724109081, 0.17017827395703267, 0.2217841251014615, 0.7569113680567169, 0.7956190591745796, 0.17181906217722953, 0.7389008642785757, 0.18874151048048482, 0.7554591917895532, 0.14473546562136363, 0.1536326986649521, 0.20605658586847198, 0.1535965145526319, 0.3959397428375794, 0.1966406693531595, 0.6620611961139454, 0.1613326793362061, 0.7052217670644245, 0.20807032207793075, 0.17668340442860775, 0.18673315844952132, 0.17370647703006947, 0.17108575183246977, 0.17011478408134773, 0.18216226756824516, 0.1695178257828327, 0.19360818883776487, 0.1731009322371645, 0.06840766804762588, 0.0602713617492876, 0.07621995221460676, 0.07931888230928397, 0.08019668307276828, 0.07817718306887511, 0.07485590626117844, 0.07950228897228862, 0.0751016360888791]}, "mutation_prompt": null}
{"id": "e441531f-e038-47f3-bd4c-d19b96f0afa5", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        # Use population diversity to influence mutation scaling\n        diversity_factor = np.std(self.population, axis=0).mean()\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1 + 0.1 * diversity_factor\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution incorporating adaptive mutation scaling influenced by population diversity for improved convergence speed.", "configspace": "", "generation": 49, "fitness": 0.32647643885950317, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "a1946ce4-14d8-43a4-9848-1cf6e8efb554", "metadata": {"aucs": [0.7860090502667318, 0.8151779115672528, 0.8418507543814506, 0.8722345419498038, 0.8379159827500947, 0.8127150028716037, 0.8698100325015453, 0.840489063631791, 0.7653312950985398, 0.7323448714773535, 0.7149492330543008, 0.7076760807937987, 0.6825853053896835, 0.6592144549468302, 0.6869573646858206, 0.12830953940956424, 0.38080408260357435, 0.6872714833114395, 0.10659332040739011, 0.13456855773445875, 0.14924273401824717, 0.13617416307761865, 0.5092245732243086, 0.1398471192676216, 0.17045507382556857, 0.16176808417429334, 0.15903442213751784, 0.1362452632693718, 0.11303842549363563, 0.12002754423838646, 0.12786362743887292, 0.13086248607515516, 0.1276006759487598, 0.1372557336248077, 0.12105190697352086, 0.13485267419485736, 0.9369914222770943, 0.9553353890479441, 0.9780977154029747, 0.8433545085403772, 0.9241587298619391, 0.9830959707210369, 0.9284158928089341, 0.9489794937038172, 0.8685860962760135, 0.47542077787078174, 0.5726892236303504, 0.22044078330694505, 0.377868575787632, 0.5343142775421269, 0.23938343391026673, 0.38289680695209116, 0.17555332650444666, 0.1934925493354549, 0.7261278054340821, 0.30687500029299686, 0.273827750159097, 0.7981458203572039, 0.7179370905950582, 0.6656364079437773, 0.820982083950554, 0.7137597728919831, 0.8118855456287472, 0.14325445941557535, 0.1961345768810021, 0.5330985711239964, 0.14187450595173268, 0.1792933710762754, 0.14577172670199978, 0.40131355797561596, 0.1729323678309993, 0.46200947105882695, 0.13533521465923382, 0.009730025816213628, 0.1440061331860587, 0.3090548775170723, 0.2841450099898022, 0.5186592658888888, 0.2956202754436136, 0.24927187579268018, 0.4461972120874248, 0.39793737368137494, 9.999999999998899e-05, 0.11097213722688726, 0.2269367812691988, 0.05662279342094356, 0.09436381219995782, 0.09799537325977148, 0.1566251942509278, 0.1023636945052433, 0.10281312505359652, 0.18482229105637027, 0.20362769477665454, 0.3164417556095289, 0.08184284424332855, 0.12133154474096541, 0.22118050460919048, 0.3010787145844045, 0.16701360271939192, 0.2002473901476921, 0.08644390205073837, 0.17042487003157114, 0.1993526456929141, 0.25735372786102784, 0.07088398898970172, 0.09646261022231051, 0.20069004233525434, 0.344189621847397, 0.24303371369475557, 0.21716511116287118, 0.26775700355759724, 0.3500527557791362, 0.42931610434588907, 0.2978382381421434, 0.20742944355216963, 0.31066634051812403, 0.2700470887847688, 0.7200071190012081, 0.6903236742883765, 0.6542203116054408, 0.521655328154839, 0.6240832293863261, 0.57263512505883, 0.669988623532758, 0.7362581025847474, 0.6079153194677467, 0.10109639527593428, 0.12267965188232721, 0.11446500409522053, 0.07404792719628672, 0.12906481494625477, 0.11236588693554372, 0.11064146710735401, 0.11067604094774053, 0.46490181759048976, 0.13265715915607723, 0.19167367780852385, 0.11712131015834315, 0.11989537808986295, 0.12406716785004068, 0.12611874571442183, 0.13891388368425173, 0.1257999198939831, 0.1318396628895564, 0.3456869416233861, 0.34251695052901643, 0.38799403042317326, 0.2876282735239102, 0.31102534285460437, 0.3222087032480926, 0.31090586064843384, 0.38546059694129065, 0.3706658636732454, 0.26675076214836335, 0.35904600011098087, 0.2527764064670106, 0.23504731105479837, 0.28957824512676233, 0.1764070528498214, 0.26119961727341146, 0.37931568751792366, 0.19835075816859526, 0.19323345846943663, 0.16821395437151532, 0.16924246129715426, 0.17989759531759775, 0.15058171399805942, 0.16681194556303092, 0.17371543198858685, 0.17319343516692043, 0.18314230114691432, 0.21976729802099249, 0.23402194656619446, 0.18540829166216155, 0.22124828822388565, 0.22194927928303498, 0.19384375000377463, 0.19515471573667442, 0.5813953614995524, 0.18372575266967994, 0.1758325730132757, 0.7666403703684366, 0.15125092995162281, 0.17180845016347868, 0.18411945248938066, 0.700739372213077, 0.17652942140680183, 0.18496990196967633, 0.16879453359976326, 0.18701837387404563, 0.16019777613624886, 0.7008321231216665, 0.5189518835708782, 0.6900077005832127, 0.1895697743065733, 0.20319539923441787, 0.18400203927425962, 0.2037156169416603, 0.17390583336930376, 0.17476895512744506, 0.18781036339545132, 0.17653477953653363, 0.16238481253204606, 0.17641154467506026, 0.16980133371419104, 0.16971370907727001, 0.1756126322749353, 0.07801935299223439, 0.08336878325519825, 0.09222528789705542, 0.08066753650073166, 0.07613418614458844, 0.05671725297637864, 0.06236394845400173, 0.06123519931221599, 0.07810443985898641]}, "mutation_prompt": null}
{"id": "43282fe5-1e59-4555-b766-165c07362fbb", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.1\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    if self.population_size > 20: \n                        self.population_size = max(20, int(self.population_size * self.dynamic_shrink_factor))\n                        self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution with enhanced crossover strategy and selective dynamic population adjustment.", "configspace": "", "generation": 50, "fitness": 0.31659624497939237, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "a1946ce4-14d8-43a4-9848-1cf6e8efb554", "metadata": {"aucs": [0.8660750724560293, 0.8632803052967717, 0.8361332357774266, 0.855227691099165, 0.8376328306148563, 0.3809915669392069, 0.8720552481409318, 0.8582037551663788, 0.23608839406466298, 0.7524906434956145, 0.6774383756213513, 0.15315490970861123, 0.14384202159379056, 0.7510378396927897, 0.1951944884450697, 0.07372805188459608, 0.7103451538551628, 0.7338094247903573, 0.14406795817271034, 0.14939201738483043, 0.11283889480413978, 0.1417765912977118, 0.11039099450187517, 0.10959297584132532, 0.12559809575886172, 0.13561275932342964, 0.2134029815915517, 0.10391391896953484, 0.10582471202229948, 0.11787354856222498, 0.11250404554107174, 0.10708746430998106, 0.12629592763925068, 0.11521673761794116, 0.11793604468826668, 0.12901221528553763, 0.884377774010509, 0.8954502593257395, 0.9114023538165077, 0.7903457411481154, 0.9351578069593428, 0.8829695690774697, 0.950322526004586, 0.9410456651659111, 0.8210954209074186, 0.4925155931594982, 0.29702742965640894, 0.4101623970400937, 0.4116104581402812, 0.2473767699716628, 0.15303386147887887, 0.3902239350380097, 0.08725168632093061, 0.19835678524840883, 0.8969171532903885, 0.2229819478267815, 0.7841687552870577, 0.25621086211390265, 0.7231093965486286, 0.7558445112534072, 0.8347040882953252, 0.2304614900630203, 0.7307103117918612, 0.4070682094533016, 0.3869008341536331, 0.2671564742960171, 0.15802095053845622, 0.12638270900159476, 0.16751345510939175, 0.12946565381825348, 0.1509921283279404, 0.14661897870018015, 0.23940804827919526, 0.2591165408138001, 0.1667197039681756, 0.1654839320016689, 0.1927664624139216, 0.22545586143988627, 0.16439929619410454, 0.19436240989715414, 0.0977425510531541, 0.25030741047169935, 0.3657042126153517, 0.30392493406756815, 0.03264109609571775, 0.28382749099272586, 0.0006868705938851694, 0.13604389048307441, 0.1956391697178902, 0.38379153299011537, 0.41435021181483767, 0.3848115617679386, 0.44436873078118455, 0.27628145983948715, 0.15065870106263368, 0.18583315401207678, 0.37238739279484556, 0.4282186505645734, 0.38353855815496385, 0.274873544910613, 0.12925579501784723, 0.15388322504125096, 0.08519798960862068, 0.3110053167761043, 0.26924155309940123, 0.14603272094589215, 0.225675528806227, 0.1914925212343005, 0.36569256918263904, 0.24281904795312503, 0.13372789663418916, 0.22616723472603184, 0.2514275978563788, 0.2680741567272854, 0.3382958455335091, 0.28870816081499906, 0.19719619234607488, 0.6219864815200145, 0.642602736031252, 0.7640821573089145, 0.7734103813032331, 0.4986969050270963, 0.6250643277117238, 0.7404289412507145, 0.6579829128750552, 0.7603437982897576, 0.09897896548451701, 0.12600296071606953, 0.1089189539608999, 0.09885775210577996, 0.12465947788838672, 0.15170554870138842, 0.09563646147523319, 0.09362876353158867, 0.10102384705529543, 0.13643782628348056, 0.1460042304202952, 0.14414287835089945, 0.1879412100628013, 0.20360798307480588, 0.15057532416365316, 0.25689323606954817, 0.2500752075764867, 0.19333387756598708, 0.3560904385971627, 0.35540851770332704, 0.3046319185647759, 0.4411038845018903, 0.32764003915146267, 0.3575750814051195, 0.3181705365551255, 0.4176937099975182, 0.3841028232280398, 0.33700772428087444, 0.27518229269445327, 0.24387384841357884, 0.2756469162869575, 0.3433445560381415, 0.28767048806037754, 0.297770547094358, 0.33471839619632415, 0.09352033952885563, 0.17008213305298592, 0.16728604853521867, 0.17118541513576124, 0.2037794637385547, 0.16942975684262096, 0.19709095601734727, 0.1719921978316863, 0.17362286909086266, 0.187286759788867, 0.3339829270068172, 0.19606346982173817, 0.20249783444944114, 0.24976921482463088, 0.19575902960742997, 0.2917547197488315, 0.1942340055261781, 0.1803504197117125, 0.19855541941007737, 0.1792214851207211, 0.18134943128602976, 0.14652304908587088, 0.16910602172758105, 0.7225665087224502, 0.174691990678287, 0.5102180504434024, 0.19105764092813704, 0.6641259402584339, 0.5579164740293745, 0.5960574819521184, 0.15014569765980412, 0.19532627566867966, 0.3261216009997141, 0.1642579061113303, 0.15350086334974533, 0.20781197229126624, 0.6451776808783624, 0.16794549572049366, 0.1840955794792999, 0.18448591690016425, 0.17872432717894704, 0.18343944490744202, 0.18840097043070259, 0.189812481338539, 0.1858501603405317, 0.1791672731466466, 0.06970300128589302, 0.07343716295830294, 0.08590743067268336, 0.07555718386377286, 0.08310521698785067, 0.07429108969425413, 0.07963885166298901, 0.08719053176186731, 0.07270531539273961]}, "mutation_prompt": null}
{"id": "cb14a117-8a0d-49a7-aa2d-3179ab82a70e", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2  # Increased adaptation range\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.1  # Increased adaptation range\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.05)  # More conservative increase\n                    self.base_CR = max(0.6, self.base_CR - 0.1)  # Adjusted for potentially faster mixing\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution with a self-adaptive mutation factor and dynamic crossover probability for fast convergence.", "configspace": "", "generation": 51, "fitness": 0.31715550810828563, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "a1946ce4-14d8-43a4-9848-1cf6e8efb554", "metadata": {"aucs": [0.8485539231282636, 0.8608060252326939, 0.8622944930135666, 0.8839807155905333, 0.8616243150915378, 0.8581710322809492, 0.881491610524731, 0.8444476383799272, 0.35040212658114955, 0.757356927160941, 0.6651950452531804, 0.7320036214179344, 0.699366966567788, 0.269323956625681, 0.7107962836252384, 0.739714094326954, 0.07333955629021693, 0.6872000641518405, 0.16498602808616214, 0.48503276683207086, 0.17106312467747697, 0.5043537655844201, 0.16253519459913146, 0.14815100159003503, 0.5365599513972474, 0.1583115217349046, 0.5745809389831349, 0.4574460766521533, 0.47882671225945395, 0.15405769321407004, 0.16142082983034234, 0.14212457207695317, 0.15510407015384986, 0.46353609193867606, 0.3945968839662378, 0.15222629600721083, 0.9059862097295491, 0.9309323195314946, 0.9052190650017683, 0.8086691766265637, 0.9295457862733401, 0.8407651979031532, 0.8273830321452671, 0.8814180919313053, 0.8600326553513056, 0.46263123658041005, 0.38878493496644917, 0.10398663260339203, 0.4389546750605281, 0.3555740254494162, 0.165574131522642, 0.5013530258174124, 0.09715488118297377, 0.3671225175047278, 0.23835778194743173, 0.3742967444912293, 0.3792915718350044, 0.6226547319551099, 0.21045009180235508, 0.7716494547339621, 0.5473018793364648, 0.8172919934887526, 0.776872559428579, 0.12790060426393668, 0.17483948904136304, 0.15749298499081432, 0.2438497248407463, 0.20491017660056432, 0.12882983933810577, 0.20722455479683, 0.2753666883868213, 0.14879415270674723, 0.15267869872642836, 0.24575284118929075, 0.2213501632793391, 0.15225726085822167, 0.29211529810337855, 0.2329655740511316, 0.15653731125993853, 0.1477601044466439, 0.13094021140231105, 0.0040035071062849426, 0.023957902393307418, 0.09285874484998691, 0.13216857364490375, 0.08893732884713623, 0.03599896438591821, 0.03523328969382622, 0.041802718331068744, 0.06843624051942332, 0.13074653725175212, 0.20855589993030665, 0.1359486902912873, 0.18384904567339933, 0.13206503446265994, 0.06081601035452133, 0.19511816700721296, 0.2085275327453936, 0.18891795241898868, 0.1424733960104131, 0.02743293096160304, 0.08586210686723339, 0.06625142403867945, 0.0747380380661733, 0.09091264177673697, 0.13008936626214052, 0.09919077706464863, 0.08036899693688304, 0.2027944567796479, 0.29827085919544993, 0.22482405861373944, 0.0994264093390762, 0.21510904977148815, 0.26265544154215614, 0.23731284773183015, 0.15207893790742855, 0.10942270226884598, 0.43969410883458204, 0.7448566558229187, 0.5892870726514294, 0.571007988848742, 0.549970529235178, 0.6143062767071403, 0.5971101242569561, 0.42527735944599476, 0.500338324166901, 0.10460344802626986, 0.09922816294126457, 0.08018717705677358, 0.07914132131324836, 0.08643354396495795, 0.0884282384040096, 0.11761705537699274, 0.09034785752909646, 0.08267544396764992, 0.2535652702462502, 0.12534715893823045, 0.12387687223738886, 0.16520347851178996, 0.12202901140539124, 0.110216504714578, 0.1303393926941413, 0.11881193202129126, 0.15477368893625498, 0.40397901089156985, 0.32804760043513703, 0.44379894640045303, 0.3582063588191381, 0.2504710304115634, 0.43508302986707925, 0.44202164929106125, 0.4359188067002536, 0.43737123137932954, 0.19125820863684295, 0.2215416867283052, 0.1803237929688989, 0.23654851995656545, 0.24175677447923027, 0.25345285139502227, 0.22962254213389965, 0.34148834010986917, 0.25531697807953513, 0.16799560424163407, 0.2066959970931388, 0.17762390083976642, 0.20110008248387434, 0.188074816029147, 0.18211187724021793, 0.19264719506048844, 0.2210535509548942, 0.21273564574258974, 0.20783899830821506, 0.5247104920838712, 0.3552288309246646, 0.26120976152853836, 0.18994769894787056, 0.20317112209618937, 0.20897353336374225, 0.20477135512686206, 0.2038702918614015, 0.16110782824780456, 0.6497281795837985, 0.15095229980399294, 0.5728051276814479, 0.849642460120572, 0.754438803607377, 0.828958755563994, 0.16008060511809452, 0.3333587748114213, 0.15431863638940724, 0.4295933549001757, 0.16354197615283905, 0.2079399745798337, 0.6235357485347566, 0.1624189507948668, 0.4173154260756773, 0.6430202901062225, 0.4663439385244613, 0.16989261403755918, 0.1973172154535956, 0.18508481372423768, 0.17955209361929647, 0.17442716983994255, 0.17024426532793602, 0.1759224907605863, 0.17286896199576607, 0.18608382854211492, 0.07146214048953736, 0.06570621638264962, 0.0801266664898963, 0.07952035347567721, 0.06377521871445002, 0.07487435200086257, 0.07493908292559404, 0.0896575401639802, 0.07543290763156096]}, "mutation_prompt": null}
{"id": "ba6849f3-b16b-49c7-b8a2-caae709bc666", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.memory = []  # Adaptive memory of successful trials\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2  # Slightly increased variation\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.1  # Slightly increased variation\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n            self.memory.append(trial)  # Add successful trial to memory\n            if len(self.memory) > 10:  # Limit memory size\n                self.memory.pop(0)\n    \n    def stochastic_ranking(self, func):\n        scores = [func(individual) for individual in self.population]\n        ranked_population = [x for _, x in sorted(zip(scores, self.population))]\n        self.population = np.array(ranked_population[:self.population_size])\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if np.random.rand() < 0.2 and len(self.memory) > 1:  # Use memory-based crossover occasionally\n                mem_idx = np.random.randint(len(self.memory))\n                trial = self.crossover(self.best_individual, self.memory[mem_idx])\n                self.select(0, trial, func)\n                evals += 1\n\n            if evals % 10 == 0:  # Apply stochastic ranking every 10 evaluations\n                self.stochastic_ranking(func)\n\n            if self.best_value >= prev_best_value:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Integrated stochastic ranking and adaptive memory in a hybrid adaptive differential evolution to balance exploration and exploitation for faster convergence.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_id": "a1946ce4-14d8-43a4-9848-1cf6e8efb554", "metadata": {}, "mutation_prompt": null}
{"id": "00d26213-6840-4d8d-a551-02086b1eb8f7", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01  # New parameter for adaptive adjustment\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adjust mutation factor and population size if no improvement\n            if self.best_value >= prev_best_value - self.progress_threshold:  # Use new progress threshold\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution incorporating a dynamic population strategy, early convergence detection, and adaptive adjustment based on evaluation progress.", "configspace": "", "generation": 53, "fitness": 0.3636242031367512, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "a1946ce4-14d8-43a4-9848-1cf6e8efb554", "metadata": {"aucs": [0.8399878755655278, 0.8247269071254835, 0.826514206387365, 0.8355169580312071, 0.8444080154974477, 0.8359168614834974, 0.8656807140522851, 0.8379468694196854, 0.8249616323763395, 0.7423338334840223, 0.6843102075706482, 0.5844711127255233, 0.7351945148286634, 0.6719137082756372, 0.7168518300521458, 0.7153255041937041, 0.6979871366832346, 0.023521044600215424, 0.1554954906045325, 0.15180594326353858, 0.14203730129237502, 0.14028651515571433, 0.1420982454120041, 0.1271579091659154, 0.14070904866968614, 0.14006282271129, 0.5096930316794268, 0.12373350599941735, 0.12204464951134342, 0.24890129151344687, 0.12141953318173948, 0.14085415467877715, 0.10726554775329256, 0.13026739706410517, 0.1320535638010184, 0.12411123520027145, 0.8757578770374052, 0.8646505470106288, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.854674540605229, 0.9228013366856397, 0.38138918855514514, 0.46663374751456577, 0.3784463756421007, 0.4943306927243072, 0.3281554330530907, 0.43036670787478926, 0.5757979378636371, 0.23338630433720953, 0.4402546169318029, 0.845101833792653, 0.7267591685524462, 0.5877054698496471, 0.26941991282841393, 0.8520734966558955, 0.7945330345118742, 0.8496517631192497, 0.7681493601880338, 0.7593519594129887, 0.17984820144123437, 0.2465569308615556, 0.16056948696871354, 0.21497642013911067, 0.3959904899759885, 0.658400287377664, 0.24476078231026444, 0.35821860373175063, 0.3867341081242379, 0.24495584895520883, 0.10860018512970471, 0.17170848992565824, 0.26496626097782794, 0.22965613054185463, 0.4700604260134378, 0.12787982664468822, 0.2375011738517241, 0.31842363922439043, 0.3030863452466981, 0.15844088363776831, 0.13643660181934958, 0.025870550994590458, 0.2546562193414469, 0.00910843717268528, 0.10994495025144202, 0.2591644153144821, 0.3492124930480711, 0.35199867711719, 0.3956394577688621, 0.43284985605405624, 0.1294689703893056, 0.3161110888852817, 0.354081537044193, 0.18348654949506848, 0.3538401588596577, 0.4276755687985948, 0.14546452703628965, 0.14494196167427786, 0.1802004311377976, 0.07408225604840812, 0.2760695297250597, 0.22956753434710897, 0.15972954404084716, 0.2805161669582964, 0.09029384991482314, 0.13341613408004527, 0.20913299303594324, 0.3454822315543721, 0.3309820538381154, 0.3644685013654041, 0.41837742731134453, 0.307724012730916, 0.3038305288803287, 0.39026487736623927, 0.6376552018805657, 0.6533809518813054, 0.680065585361048, 0.6961877842970001, 0.5638188465023924, 0.6108616337500096, 0.6698198357569763, 0.541878043606906, 0.5794727448682201, 0.12303297471638819, 0.09855885373342532, 0.1511940123867913, 0.11167992075561073, 0.07728914007704424, 0.10926534057999637, 0.1337826498157768, 0.15380483051204807, 0.1336150807850981, 0.1511683774580015, 0.11899894299168245, 0.12271619984113602, 0.17112082544646656, 0.5227659941938054, 0.17790692888549764, 0.12792197384476478, 0.23793429712695624, 0.16237291722732183, 0.4562551748768754, 0.45057315007698806, 0.4445005459056828, 0.41243442109616335, 0.4115686862097728, 0.3249439044146447, 0.43689284788052496, 0.5051848003961947, 0.3287450686279362, 0.40200838073709433, 0.2774416397125975, 0.37104383210871306, 0.30355005663557677, 0.2403299876982603, 0.2783502894893848, 0.2705161155047724, 0.3252124497911214, 0.09483360319026202, 0.1913526497004806, 0.1641949197470456, 0.19824994121842954, 0.17897929058012718, 0.179986100136598, 0.18515824774421896, 0.21267424228702214, 0.20716639092293565, 0.178667046404259, 0.19705321500251816, 0.2215053864277554, 0.17864052784198647, 0.5755405797145005, 0.549416058181992, 0.5174512224918544, 0.23150739897410666, 0.21047605208582532, 0.22695480524742961, 0.16355223063664415, 0.8514753726994657, 0.18246198790000334, 0.8232381036739109, 0.8074414749013417, 0.7253397826061688, 0.19823560292523545, 0.1648583152883475, 0.1621784257795763, 0.7514049949732409, 0.20532761895775287, 0.6574163297708278, 0.20605235488742624, 0.6812642392383292, 0.16712161551432658, 0.20235942604783308, 0.817400809404921, 0.7710476959942457, 0.18492884955138755, 0.17791850403827847, 0.18331461484876221, 0.18071919243593715, 0.18384117036840464, 0.17217585789231504, 0.17293854228854966, 0.17939352214428894, 0.17887639547003642, 0.08600579870750602, 0.08448261995747086, 0.07997470159302833, 0.0588853779406141, 0.07421031164711689, 0.07621632364424602, 0.08219607184586131, 0.05653935086898343, 0.07200312188401092]}, "mutation_prompt": null}
{"id": "8c5057cd-cf69-47cb-8804-e34778065c35", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.cooling_factor = 0.99  # New parameter for mutation cooling\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adjust mutation factor and population size if no improvement\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * self.cooling_factor)  # Apply cooling\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Enhanced adaptive differential evolution with an added mutation cooling schedule for improved convergence.", "configspace": "", "generation": 54, "fitness": 0.28960074996069984, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "00d26213-6840-4d8d-a551-02086b1eb8f7", "metadata": {"aucs": [0.6135700232131649, 0.5707903923520049, 0.8519534253423672, 0.8596761437235129, 0.8248261991109781, 0.6805981037517311, 0.8868636946238464, 0.63181558558366, 0.49889644764141083, 0.5708982152189154, 0.4779786852855967, 0.22626507523652795, 0.58134540473314, 0.7164830873742063, 0.7466154914310513, 0.6560693449466635, 0.3121816384151255, 0.017487807975292036, 0.14288261623173804, 0.12266527441902741, 0.15623251659396553, 0.09853576147348209, 0.1114288675116264, 0.09560963227037589, 0.13187800558220042, 0.107395061690012, 0.14135551417517578, 0.12321095038874952, 0.1420860265419609, 0.11274859260400005, 0.14798093105213905, 0.13281518785086066, 0.11755107950072885, 0.10838633745668302, 0.10285281784057587, 0.11588064537359843, 0.6199833051839924, 0.8646127778238456, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8209856605277087, 0.930570674542506, 0.23181371365181713, 0.29996921225725925, 0.21578483424606743, 0.23128269795776202, 0.18915441545657863, 0.2722281452709434, 0.22921887104057426, 0.16265218040097718, 0.22396329049721775, 0.8380478444248274, 0.8204005818734141, 0.20502897871580572, 0.19331948549483657, 0.8455561705641723, 0.3047331908524942, 0.8730443481029149, 0.8360156454318172, 0.23222849346082575, 0.1438185260770175, 0.1529246663589232, 0.1227611121363672, 0.16196338178211322, 0.23666246636763755, 0.3052996447580123, 0.15891625963279, 0.15511377416391792, 0.18282184512594057, 0.15158333637314514, 0.14104876570867186, 0.1397603883051941, 0.17819884839108868, 0.17649440892018697, 0.14566692050261032, 0.1274899665654904, 0.12400984934270998, 0.14608974648041972, 0.07831111413714065, 0.1292808592258854, 0.047414760731907646, 0.025080451755233657, 0.14066443848361565, 9.999999999998899e-05, 0.08698770643570819, 0.22401775010124214, 0.214546772099096, 0.12276771811486165, 0.18483773407676385, 0.32904218730094825, 0.11740757890701947, 0.04836314557488863, 0.16960347428560507, 0.19875207776536985, 0.10042485147574043, 0.250749971865043, 0.052284092451672204, 0.1221738548774125, 0.2663968756979319, 0.07408238763322283, 0.09633659765919089, 0.23652684771827526, 0.13352439767723923, 0.2858526162607593, 0.09214881471037062, 0.11807390495259984, 0.12181447460395645, 0.2800995626294458, 0.2745887000777275, 0.23587378240779233, 0.3168722633671669, 0.21195406517822646, 0.27195714075385435, 0.2635997737321254, 0.5839445204496818, 0.5452468279492844, 0.5811189943292456, 0.5316881625095531, 0.4375680505249826, 0.4864244145089601, 0.48236417527371767, 0.5882150347316953, 0.5136478473773376, 0.0890599646147846, 0.10973257845965423, 0.13146016110422076, 0.10254211946874636, 0.10332342437934927, 0.10858806764588425, 0.17095869324974322, 0.1187104398417701, 0.11747640109624968, 0.15713207347329228, 0.17240689582359647, 0.25661903411247267, 0.26291212347862103, 0.1649143695866322, 0.1648519309808698, 0.15180420142695095, 0.19177126448129966, 0.1918167144577918, 0.4840515165658943, 0.49953819372758257, 0.44621460269249924, 0.4399756306274668, 0.49116043376525687, 0.41790536698598235, 0.4332019551756331, 0.49378408378295846, 0.44463017305619623, 0.2528493505305517, 0.2538572059934223, 0.4258265138631877, 0.37575443871383596, 0.2434373284439425, 0.31129989108829437, 0.25150795814559135, 0.3724369451584334, 0.09596422721587328, 0.1957012867941027, 0.18830637515286797, 0.19080430878420107, 0.19300823954058, 0.2064509762241461, 0.2031344443120966, 0.21101041747785643, 0.22021299019025964, 0.18742896662689068, 0.20399359039602272, 0.2186906934689261, 0.20320771249806246, 0.21675950519031517, 0.20380833086184968, 0.19932688658376008, 0.2448833624956318, 0.2502621321185252, 0.2343184873648413, 0.1633696472436521, 0.8865003858717001, 0.1433014967359897, 0.4321714014908752, 0.42973719997349036, 0.1688910358648451, 0.419911726726638, 0.15917991978397295, 0.1968642273249287, 0.4496195026843357, 0.2037299192276032, 0.2077977857155887, 0.20625397885163743, 0.22033064364734578, 0.16712213704117407, 0.11129942562041395, 0.45402964838010973, 0.2755301433926338, 0.17451992015334672, 0.18304966908045484, 0.18422747179007026, 0.17604195673741307, 0.19508146390948156, 0.1796984041291778, 0.21111309340008833, 0.17780572572357323, 0.16416005292397184, 0.07406887912593196, 0.07503729454622154, 0.07813301504744485, 0.09034205718611499, 0.07838563479110927, 0.08601526786348601, 0.0874105179507284, 0.07967267772880438, 0.09279368925383003]}, "mutation_prompt": null}
{"id": "cd0b6dd1-bb94-469e-b753-da036576cad2", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01  # New parameter for adaptive adjustment\n        self.improvement_rate = 0.0  # Track improvement rate\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        prev_best_value = self.best_value\n        stagnation_counter = 0\n\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            # Determine improvement rate and adjust mutation factor dynamically\n            improvement = prev_best_value - self.best_value\n            self.improvement_rate = improvement / (prev_best_value + 1e-8)\n            if self.improvement_rate < 0.001:\n                self.base_F = min(0.9, self.base_F + 0.05)\n                self.base_CR = max(0.9, self.base_CR - 0.05)\n                self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                self.population = self.population[:self.population_size]\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Integrate dynamic scaling of mutation factor based on improvement rate to accelerate convergence.", "configspace": "", "generation": 55, "fitness": 0.3178137038451941, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "00d26213-6840-4d8d-a551-02086b1eb8f7", "metadata": {"aucs": [0.8499772757044839, 0.8107469377995795, 0.810754177629697, 0.8209591932556791, 0.8500501919222319, 0.19097545542464378, 0.8234250305415379, 0.8337935020075113, 0.8348078373265468, 0.738667519402116, 0.041780297753045814, 0.7471106362102147, 0.7397831848655891, 0.7314811050187364, 0.7191602370654175, 0.72103882898139, 0.7270711955502396, 0.6190022721753146, 0.1516889475432709, 0.17760086912891582, 0.5448603475782203, 0.16146840444775756, 0.10488982012514902, 0.10626361844359367, 0.1326518403827187, 0.14106621893359717, 0.0761177012886759, 0.14071581472174344, 0.11010583255341466, 0.13433498677047484, 0.10889656920023805, 0.11706156168029225, 0.09927709958540987, 0.1741767153975039, 0.12756802319852245, 0.1599932365857094, 0.9551188962997958, 0.9560038216213104, 0.940383838116417, 0.9554420724592901, 0.966360308260267, 0.938598835338023, 0.943784203928939, 0.9387238163565202, 0.938082001647963, 0.5782993931286886, 0.61309206662189, 0.5138426524408217, 0.5865898345481553, 0.14998180882620638, 0.41409769803505747, 0.5259044325308705, 0.12567800656046713, 0.08694598922004626, 0.36588710115161416, 0.3531488724916453, 0.20434307500094917, 0.8809125594707137, 0.20655627778385688, 0.3704865243278378, 0.2281546312422712, 0.7721044007140097, 0.2292169532161682, 0.3003511913535698, 0.20741520876051545, 0.24258181312496951, 0.23217431490538087, 0.1295443789404942, 0.4836560586615021, 0.24191068595947218, 0.6162905545633588, 0.2296151661298883, 0.26770539041934194, 0.21346701031442517, 0.1762914892092935, 0.5600970638410273, 0.4273845060539696, 0.49002287279225387, 0.2690453842701992, 0.3423988219321824, 0.13132897673989974, 0.18057403107331904, 0.013893828871913816, 0.15264516468238276, 0.10042456113123865, 0.06399266660416647, 0.03562265161811806, 0.47088446774371595, 0.06665727982339942, 0.0910683862654651, 0.10523457174411666, 0.14292111854095169, 0.20371748566215908, 0.14503270011764158, 0.04312682228419307, 0.14217325766498323, 0.24088163701152177, 0.11342554123064397, 0.17876110848658122, 0.16362845440803153, 0.12107248198345277, 0.10384676118867431, 0.393901844106742, 0.2602927780171619, 0.273011484388477, 0.09667705847718533, 0.16033590167852085, 0.13968222887849147, 0.2470637799551303, 0.34067429659204584, 0.3794959778861129, 0.3898227801806968, 0.2179995027103998, 0.37277038090486736, 0.24229972749792827, 0.25904750185282843, 0.25276784636661787, 0.6259136651656563, 0.546704191791773, 0.6736442590183394, 0.5018355904129359, 0.5876486143660407, 0.5569966894414399, 0.5481196710707544, 0.6166060021664642, 0.6362364541184096, 0.13753475726994568, 0.1417717606911465, 0.0974886570860104, 0.1493664965528253, 0.08960197164985184, 0.16564812449717847, 0.10346985893661709, 0.12222190833159818, 0.15884284994046816, 0.1779186483230184, 0.3087012787730078, 0.18729416986244596, 0.15237998044269774, 0.16246086783286906, 0.1517154585513919, 0.31583169687687884, 0.17702730628937602, 0.6635869806563204, 0.4166210695147643, 0.3435961723403754, 0.2569276795022979, 0.41521080819551615, 0.2763656494601271, 0.37168199123052925, 0.42918737818718433, 0.42707140861597326, 0.3548093757344265, 0.2746617399371549, 0.11433694892211166, 0.288174722228416, 0.3043093160450292, 0.3193733334673011, 0.1253662822199031, 0.2301154650388575, 0.271262561358921, 0.21972423255072793, 0.188897210145898, 0.18397677978696814, 0.17458532086382406, 0.17637266104726113, 0.18455801833736984, 0.17743820698050183, 0.19530122025137264, 0.1898104542569773, 0.18997807430482205, 0.18599990628297314, 0.17791295966428877, 0.19351664347817388, 0.19744007482598624, 0.19542463366955765, 0.23647121926200254, 0.2001804897533761, 0.24743265153428506, 0.21928484878679244, 0.17901113006675495, 0.20513637206268864, 0.17866121152761238, 0.8779301873270574, 0.8729837253353072, 0.16615069887475076, 0.1405147294034157, 0.16050671230520874, 0.13712421522727414, 0.7199583929007438, 0.12559143662438021, 0.1709648947928828, 0.16195140511710293, 0.16551043486905004, 0.16521198782160573, 0.1953482079006973, 0.20402287775705163, 0.2085966852530282, 0.18415559351898192, 0.1750745677974619, 0.18331461484876221, 0.17112685254199755, 0.18852716959733984, 0.16237341702063424, 0.186345035636858, 0.1709346400556182, 0.1686365897032771, 0.07190103355789157, 0.0796373046845984, 0.10208764763523182, 0.09347944661508678, 0.07192728893082423, 0.08164278105088962, 0.08607775763067471, 0.07853911845891304, 0.063086935072165]}, "mutation_prompt": null}
{"id": "6ef66ace-c84d-42a1-a749-2a8de040259d", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + np.sin(self.best_value) * 0.1  # Modified mutation factor adaptation\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with progressive mutation rate adaptation for improved convergence speed.", "configspace": "", "generation": 56, "fitness": 0.03611882118920238, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.04.", "error": "", "parent_id": "00d26213-6840-4d8d-a551-02086b1eb8f7", "metadata": {"aucs": [0.07181397830146763, 0.06432772651221763, 0.09169502728636048, 0.08952233024927114, 0.062138895920524906, 0.07709668639236078, 0.07795415841203734, 0.07431300570909605, 0.06711154613058024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 9.999999999998899e-05, 0.010643411704069683, 0.0012186513362246743, 0.006669962766643223, 0.018248263482334326, 9.999999999998899e-05, 0.010674738340807233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.033667547960281485, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.03775594762470191, 0.006487473152022916, 0.004562218041036625, 0.02725496812965944, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.11141543037622592, 0.14838054695461433, 0.09425923977458062, 0.09708865527373767, 0.09580441870675127, 0.1240568991094797, 0.09716408355800721, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006101769545772684, 9.999999999998899e-05, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.07037543064596374, 0.06735693451091307, 0.059328965068867756, 0.09855305120349966, 0.10852972522114013, 0.05643121168494414, 0.08808199726801991, 0.04855804829477728, 0.07726393575557644, 0.09606267484187503, 0.0962505644704219, 0.10359778603806002, 0.10847166301008526, 0.09261918780562917, 0.09312026747420621, 0.11420206329748472, 0.17377774300845283, 0.07784834048331069, 0.033318937593247444, 0.034008147686441226, 0.03781410669519025, 0.044650675553987496, 0.06406947898089654, 0.046310246556478196, 0.05648699256316181, 0.09386031173166853, 0.034573241697105184, 0.0916346253723066, 0.06586919676070013, 0.13345086981233123, 0.10289055837941885, 0.07855245954393053, 0.08853961034790592, 0.12245976138762271, 0.06494044806858634, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05568623559107733, 0.07466602457976645, 0.08167024703901915, 0.06718871428537254, 0.1207914665021157, 0.06661401029160186, 0.07245568600050101, 0.09643604708838482, 0.053674301379695866, 0.03824121102611444, 0.06533509616680999, 0.020525977089280056, 0.0506857903344724, 0.03738259240699027, 0.045511073114331335, 0.04690376827171172, 0.02860841408687753, 0.04143420019681854, 0.13480174570059533, 0.128372137474824, 0.14763022729669195, 0.11599487746987158, 0.11402400224796383, 0.12465113207635137, 0.12850576028924698, 0.10862764757569365, 0.14689007985489466, 9.999999999998899e-05, 0.01347814618054688, 0.031393493129599714, 0.027015293023570086, 0.018487330591705486, 0.00826091239954263, 0.011149453589241465, 9.999999999998899e-05, 0.01745630416284416]}, "mutation_prompt": null}
{"id": "3c2796b7-47f2-4f33-9a17-e9b459858250", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant, diversity_factor):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05 * diversity_factor\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def calculate_diversity(self):\n        pop_mean = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - pop_mean, axis=1))\n        normalized_diversity = diversity / (self.ub - self.lb)\n        return normalized_diversity\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            diversity_factor = self.calculate_diversity()  # Calculate diversity factor\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant, diversity_factor)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Incorporating an adaptive crossover probability based on population diversity to enhance exploration.", "configspace": "", "generation": 57, "fitness": 0.3557098012130345, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "00d26213-6840-4d8d-a551-02086b1eb8f7", "metadata": {"aucs": [0.8405041706443701, 0.8284300767493304, 0.8393459025086778, 0.766731716455321, 0.798297079216226, 0.8030609317772379, 0.7869706342005082, 0.8490029044014458, 0.6165329357333809, 0.7029885137889949, 0.6893725866658559, 0.6708669303321309, 0.7055670264975442, 0.05069982449605159, 0.3940857643842033, 0.20888164849887536, 0.6852061451504685, 0.6945553715751724, 0.6008093455129416, 0.12597319733212897, 0.12572125801215916, 0.3157330185972731, 0.4171035202419676, 0.5250411279368796, 0.4578246333713123, 0.5479768759160121, 0.5133789698591348, 0.3792478130783201, 0.158236660382142, 0.12706965381511748, 0.12003350337639718, 0.1289288300413205, 0.1464208154215818, 0.10617619296034009, 0.26576244213179645, 0.08011346815632969, 0.8971211296167297, 0.9201519325651548, 0.9227633332142846, 0.9128143938078908, 0.8790378053142303, 0.9676129886312196, 0.8923148288096457, 0.9231535059187208, 0.9689725636543443, 0.18003801454515667, 0.5849883494087191, 0.25093229693926955, 0.4455810028175198, 0.41020696390410827, 0.38205228645908373, 0.2061958671377273, 0.20212512483956402, 0.4566820053066557, 0.7513780926353485, 0.2131169600920848, 0.7455815243384871, 0.8781442177795548, 0.8716067921350528, 0.7267211367353777, 0.8826094666854952, 0.816574030422567, 0.8366746562316227, 0.25282949647356223, 0.12881099545462216, 0.22993892028086071, 0.4147789085351037, 0.13002430305342716, 0.1248380060486104, 0.15385707612522803, 0.13064688665995272, 0.1853792142788805, 0.39363849360179093, 0.12645915288878518, 0.1290681958341413, 0.27067064717788325, 0.5828359636248361, 0.5392591671768057, 0.45094554026406586, 0.21727723916523345, 0.3974640890938491, 0.19411458615226596, 0.2090656351854253, 9.999999999998899e-05, 0.41318791903110363, 0.21360493553935866, 0.16792652971948396, 0.20086866173945472, 0.3242873145684312, 0.27099160843513226, 0.2816353043155354, 0.29916263127310805, 0.25714156454243553, 0.21158116045109143, 0.23712378008093715, 0.28875805688871325, 0.34550423916043804, 0.3553670455352764, 0.3936603278729178, 0.09333429162784268, 0.15354427518003866, 0.10944744875408541, 0.14930717428708262, 0.09461464873266345, 0.1721483636723502, 0.0712926903696558, 0.184358494851952, 0.07558868308412148, 0.345229715622951, 0.29413588017031345, 0.2078951840630927, 0.2938162467195913, 0.35953894041140233, 0.32070000472950544, 0.29147141577180924, 0.3807768466926952, 0.36244801451928554, 0.5604417902928014, 0.5815512933300588, 0.55122180395467, 0.5532668209828584, 0.5308889377992174, 0.5638968460960648, 0.5424195908648184, 0.5010356536038975, 0.5953379137141721, 0.10740394971113876, 0.1288862959660444, 0.08584539582912509, 0.10317483775075176, 0.0991758293713847, 0.10833156634563945, 0.11826961984573758, 0.1374195112872012, 0.12887653551123834, 0.24665149603367387, 0.1326168274996593, 0.12271619984113602, 0.24373602914703185, 0.2360182595704704, 0.19947765769838954, 0.1849905786072985, 0.2577934151258052, 0.1389656638659259, 0.4402531290380465, 0.3998060816503246, 0.4220266583071456, 0.3693394763809187, 0.4631721085243691, 0.3911557492848048, 0.4782915954892515, 0.4647507303383095, 0.40743211494964027, 0.32522702669368997, 0.32671186486366743, 0.3176679492601464, 0.37216826653137036, 0.231560693219651, 0.3105404989947522, 0.26406567629038624, 0.37242042747547477, 0.37055363898736593, 0.17851703162147436, 0.18776955283756547, 0.18090680133068415, 0.18915514100507302, 0.19273649466816734, 0.19106504933029256, 0.17855252255872545, 0.1792969373027148, 0.16717585660143908, 0.24176165617803458, 0.1937428061552452, 0.31427888125758974, 0.6093017642648367, 0.19306206041002238, 0.20709080237579114, 0.216153344226513, 0.20703373816764492, 0.2038502133889447, 0.17882816276865054, 0.8468252389262851, 0.18191025447968945, 0.698841729126432, 0.2024744585950422, 0.17370404597599431, 0.20504158372624837, 0.15504261349533677, 0.16514336983941735, 0.7214223828859756, 0.20852343887741331, 0.7653901612086368, 0.2064314609709632, 0.6288419186077994, 0.16728483145459483, 0.1938314632661342, 0.8077125482692781, 0.7858878337920147, 0.16499857515936567, 0.17490473141080587, 0.19119441184681163, 0.18413813194552708, 0.20093176592591, 0.18213496766209514, 0.1606029158781348, 0.1539862483634672, 0.1733800711519904, 0.08417714777292218, 0.09392053317874083, 0.07032098629636008, 0.07931121422722953, 0.09247460962398169, 0.07761580396771928, 0.06983700489815015, 0.08190308280645897, 0.10508802937384298]}, "mutation_prompt": null}
{"id": "07e2e4db-3f0a-4c29-a408-e8180beed160", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01  # New parameter for adaptive adjustment\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            # Adjust mutation factor and population size if no improvement\n            if self.best_value >= prev_best_value - self.progress_threshold:  \n                stagnation_counter += 1\n                if stagnation_counter > 4:  # Slight adjustment here\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Enhanced adaptive control strategy for mutation factor dynamics in hybrid adaptive differential evolution.", "configspace": "", "generation": 58, "fitness": 0.36234434671567817, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "00d26213-6840-4d8d-a551-02086b1eb8f7", "metadata": {"aucs": [0.8242942359643345, 0.8264756696613365, 0.8369848876320792, 0.8221250759459997, 0.8208345450803025, 0.8179359990675407, 0.8553888036923605, 0.8434904851849003, 0.8266809763176264, 0.7525834230471591, 0.6635826522869295, 0.5760165781315244, 0.7258141630291357, 0.6831702274609054, 0.714293865829546, 0.6328361434508539, 0.6984877460009045, 0.017380058960578704, 0.123498576175057, 0.15683778853239305, 0.14430531074569664, 0.107312052071588, 0.150495022723924, 0.10443626961960983, 0.1436889907460276, 0.16209610227506477, 0.16542478687135076, 0.128672569034761, 0.29015671782989194, 0.22430375129640057, 0.5547825004832803, 0.12577243250969694, 0.14459186924296152, 0.13706646347471252, 0.14806252476378035, 0.1594219995250249, 0.895733595908829, 0.8536970022611989, 0.9382351941098915, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8860253193201121, 0.9127401959610998, 0.5579663385809526, 0.5141907252824895, 0.38635028730681154, 0.5815187278162537, 0.3691093678757644, 0.5140005910828074, 0.5360245127158874, 0.2195813264859453, 0.5611404434123568, 0.837498515353231, 0.24728919365658963, 0.7208546020176017, 0.1754022641888089, 0.7647827774094439, 0.7426035482786324, 0.8419250795387824, 0.35361814753284193, 0.7463975598659365, 0.20940261926887915, 0.2220994505225884, 0.15354419490187288, 0.21188149294659175, 0.5873579678560207, 0.35252939167103325, 0.1827436080847984, 0.35963382679336153, 0.4097175279355718, 0.3827573773168038, 0.05164282480129656, 0.21544418159792134, 0.37621974566001803, 0.4291862623972882, 0.3014239443497264, 0.12788385132740676, 0.39461853941159586, 0.2878632504619102, 0.25131871745027623, 0.16929613732446158, 0.20594530269177558, 0.19545420063353247, 0.23429916851502985, 0.003540779327063648, 0.10315501084777956, 0.2963630063699898, 0.3312278734459142, 0.2268982993892078, 0.19513438339237887, 0.2539776146217815, 0.23409664502925676, 0.12096557664568952, 0.3619630207655854, 0.5634059802669601, 0.1257377545869124, 0.40149362801713817, 0.07793527128806876, 0.13204109226822602, 0.15736908958692708, 0.07408222495137995, 0.2637763221536731, 0.39982101581725493, 0.1766383968412012, 0.11161172103268291, 0.1752071411529048, 0.29225385749556365, 0.2938424502979845, 0.3025504382014048, 0.323815119933313, 0.31001584905391344, 0.3148372160186348, 0.2965241599145164, 0.22906092419192603, 0.31767245163621494, 0.5756394158282195, 0.6084926074206577, 0.6402801762310515, 0.5760294676764579, 0.6114281944525919, 0.5763245074674996, 0.6312437928377668, 0.5637659013538739, 0.6814761596302525, 0.10977578731160031, 0.10352547058018668, 0.15727622310549083, 0.12995224696923446, 0.09391757787254995, 0.1095300789940189, 0.11415261157337608, 0.11669842293185428, 0.09985618981070132, 0.13702313703637903, 0.12290946853056262, 0.16498797200128723, 0.19498588977118025, 0.14095292503211532, 0.27783744892027484, 0.18556727115502214, 0.24258972480767682, 0.23831805766123926, 0.36891121269895943, 0.4358680287949307, 0.35276890945329165, 0.321954829148305, 0.24720324831078522, 0.36074670022265465, 0.40002080579685206, 0.4513401468825423, 0.3494409331274041, 0.390782300510614, 0.29175471127560426, 0.32367192992758265, 0.24117679349944598, 0.27543319136796585, 0.3048464003945026, 0.26290970653788703, 0.3017545044640769, 0.09346406410295771, 0.17949743415677566, 0.1922373273962914, 0.18991095877586417, 0.19173919971782205, 0.1967065975491017, 0.18759837639737043, 0.19572671272755338, 0.18036992149336362, 0.24001154347172893, 0.2330230319174178, 0.18975633297003847, 0.1856153762326358, 0.5607370594598571, 0.18861669375295964, 0.19754266800551779, 0.21488037641026436, 0.6112137139058106, 0.23451966820016967, 0.16354874823921906, 0.8375758881733675, 0.11383836436113393, 0.853480064289571, 0.791913813047943, 0.7716879168788344, 0.7939175485687274, 0.16388739515748496, 0.7488949118205417, 0.7684002533164149, 0.20559663710623277, 0.8010652639467479, 0.20522790113644018, 0.7200219474182015, 0.16700372289659915, 0.1918177477798767, 0.7712389654747951, 0.833903789027682, 0.1797457161009114, 0.20230908511371626, 0.18331461484876221, 0.16996510275467158, 0.16391209388824624, 0.1691878392950581, 0.19327599357863934, 0.18242066958617387, 0.18553252148764332, 0.08345468850331039, 0.07223651974985801, 0.07138368982569576, 0.07161802709171494, 0.0790896334981187, 0.08830704250720789, 0.07655074547550289, 0.06475538438820605, 0.07450884599426988]}, "mutation_prompt": null}
{"id": "43272148-d005-47cd-903c-8c1283050573", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.memory = []\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n            self.memory.append((self.base_F, self.base_CR))  # Record successful parameters\n\n    def update_parameters(self):\n        if self.memory:\n            successful_F, successful_CR = zip(*self.memory)\n            self.base_F = np.mean(successful_F)\n            self.base_CR = np.mean(successful_CR)\n        self.memory = []\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            self.update_parameters()  # Update parameters from memory\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Introduced a memory-based adaptation of the mutation factor and crossover rate based on the historical success of trials, aiming to improve convergence speed.", "configspace": "", "generation": 59, "fitness": 0.36362420301606585, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "00d26213-6840-4d8d-a551-02086b1eb8f7", "metadata": {"aucs": [0.8399878755654415, 0.8247269071254741, 0.826514206387374, 0.8355169580312071, 0.8444080154974876, 0.8359168614687661, 0.8656807140523314, 0.8379468694196723, 0.8249616323762972, 0.7423338334840168, 0.6843102075706324, 0.5844711127317909, 0.7351945148286634, 0.671913708275615, 0.7168518300521625, 0.7153255041936883, 0.6979871366858461, 0.023521044600223306, 0.1554954906045325, 0.15180594326353858, 0.14203730129237502, 0.14028651515571433, 0.1420982454120041, 0.1271579091659154, 0.14070904866968614, 0.14006282271129167, 0.5096930316794268, 0.12373350599941735, 0.12204464951134342, 0.24890129150831963, 0.12141953318173948, 0.14085415467877715, 0.10726554775329256, 0.13026739706410517, 0.1320535638010184, 0.12411123520027145, 0.8757578770374052, 0.8646505470106288, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.854674540605229, 0.9228013366856397, 0.3813891885555185, 0.4666337480801549, 0.37844637560793537, 0.49433069218590175, 0.3281554328119035, 0.43036670787434983, 0.5757979378692427, 0.23338630433720353, 0.4402546169386372, 0.845101833792653, 0.7267591685524462, 0.5877054698496471, 0.26941991282841393, 0.8520734966558955, 0.7945330345118742, 0.8496517631192497, 0.7681493601880338, 0.7593519594129887, 0.1798482014375613, 0.2465569308519977, 0.1605694869682981, 0.21497642014013574, 0.3959904902271918, 0.6584002873771555, 0.24476078231028509, 0.35821860371864467, 0.386734082185762, 0.2449558489548579, 0.10860018512970471, 0.17170848991907295, 0.2649662609771021, 0.22965613054092127, 0.47006042601569575, 0.12787982664468822, 0.23750117385253522, 0.31842363922376316, 0.3030863452475251, 0.1584408836380835, 0.13643660181917372, 0.025870550994590458, 0.2546562193409385, 0.009108437172688943, 0.10994495025141782, 0.2591644153143865, 0.3492124930481463, 0.35199867711731203, 0.3956394577683191, 0.4328498560552969, 0.12946897038936334, 0.3161110888843768, 0.35408153704401013, 0.18348654949512921, 0.3538401588593909, 0.4276755687978543, 0.145464527039737, 0.14494196167426932, 0.18020043113771367, 0.07408225604840812, 0.2760695297244684, 0.22956753434709787, 0.1597295440411981, 0.28051616695859327, 0.09029384991482314, 0.13341613408004616, 0.20913299302740052, 0.34548223156753066, 0.33098205380192536, 0.3644685013720056, 0.4183774274038645, 0.30772401273234884, 0.3038305291408606, 0.3902648773574985, 0.6376552018805657, 0.6533809518923387, 0.6800655856423916, 0.6961877842970001, 0.5638188465028886, 0.6108616337500575, 0.6698198356852598, 0.5418780436064314, 0.5794727448654151, 0.12303297471638819, 0.09855885373342532, 0.1511940123867913, 0.11167992075561073, 0.07728914007704424, 0.10926534057999637, 0.1337826498157768, 0.15380483051204807, 0.1336150807850981, 0.1511683774580015, 0.11899894299168245, 0.12271619984113602, 0.171120825446478, 0.5227659941938054, 0.17790692888549764, 0.12792197384476478, 0.23793429712695624, 0.16237291722732183, 0.45625517449623787, 0.45057315007698806, 0.44450054590468957, 0.41243442107836537, 0.4115686862104634, 0.324943904434731, 0.43689284788052496, 0.5051848003626427, 0.3287450686279362, 0.40200838054143717, 0.2774416397125742, 0.371043832108667, 0.30355005663554024, 0.240329987698357, 0.278350289489527, 0.27051611550468, 0.3252124497911214, 0.09483360319026202, 0.1913526497004806, 0.1641949197470456, 0.19824994121842954, 0.17897929058012718, 0.179986100136598, 0.18515824774445766, 0.21267424228702214, 0.20716639092293565, 0.1786670464042589, 0.19705321500251816, 0.2215053864277554, 0.17864052784198647, 0.5755405797145005, 0.5494160581467429, 0.5174512224918544, 0.23150739897410666, 0.21047605208582532, 0.22695480524742961, 0.16355223063664415, 0.8514753726994657, 0.18246198790000334, 0.8232381036739109, 0.8074414749013417, 0.7253397826060798, 0.19823560292523545, 0.1648583152883475, 0.1621784257795763, 0.7514049949732409, 0.20532761895775287, 0.6574163297708278, 0.20605235488742624, 0.681264239238352, 0.16712161551432658, 0.20235942604783308, 0.817400809404921, 0.7710476959942447, 0.18492884955138755, 0.17791850403827847, 0.18331461484876221, 0.18071919243593715, 0.18384117036840464, 0.17217585789231504, 0.17293854228854966, 0.17939352214428894, 0.17887639547003886, 0.08600579870750602, 0.08448261995747086, 0.07997470159302833, 0.0588853779406141, 0.07421031164711689, 0.07621632364424602, 0.08219607184586131, 0.05653935086898343, 0.07200312188401092]}, "mutation_prompt": null}
{"id": "76f46fea-4aeb-4bb9-b92e-af14d9168e33", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.05  # Reduced range for F\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n            \n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F + 0.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "An enhanced hybrid adaptive differential evolution algorithm incorporating a dynamic mutation factor within a narrower range for adaptive exploration and faster convergence.", "configspace": "", "generation": 60, "fitness": 0.34146613859805097, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "00d26213-6840-4d8d-a551-02086b1eb8f7", "metadata": {"aucs": [0.8665481199359495, 0.8458039970272269, 0.8132114551296318, 0.8488843365549149, 0.8309044541746615, 0.6482706669119744, 0.7869342114693881, 0.838253058179607, 0.8143747073322286, 0.6764615732867307, 0.7068037952316946, 0.6564649680923292, 0.6970389272243707, 0.7283757868628062, 0.7106250277336992, 0.750380925766087, 0.700909492043281, 0.42792455529190465, 0.16767476495442135, 0.34916484127245373, 0.11459556869108545, 0.1636481956893353, 0.15000889846201826, 0.1387251864592972, 0.14725821668482608, 0.13612531373610814, 0.15590671547352541, 0.12820612956347233, 0.16267473570698854, 0.10468544801900426, 0.1444115797707045, 0.13819783066095237, 0.12409499945421087, 0.2417921551439972, 0.15498062717058292, 0.12947816584033767, 0.8852364737805181, 0.8846740828648677, 0.9366800449736004, 0.8613742050451294, 0.9735999060966645, 0.9601536613005746, 0.8245343541042631, 0.9058188658685109, 0.8812649055644107, 0.4386731425309621, 0.14862494230632206, 0.2595782129266747, 0.4115847201676317, 0.5003986226710236, 0.565989374234265, 0.4177687493704667, 0.4213946446161092, 0.5941119145157372, 0.7587120196640701, 0.8380566015922797, 0.766089219795758, 0.8109629845346057, 0.7869342255104725, 0.8353545088852706, 0.8193505031950563, 0.843043564555046, 0.7373070208317309, 0.2389822456438716, 0.22129793193937553, 0.17255691347743574, 0.12861592679796963, 0.1596059240965182, 0.12813241916106655, 0.13056208086158128, 0.16492641795704144, 0.22855017074764605, 0.2611251777248581, 0.1588242072296191, 0.12800790789090477, 0.2230005032466943, 0.1282804441358838, 0.18885617013117695, 0.3436675259071601, 0.23895508092075846, 0.16427542742674683, 0.09748543555259748, 0.06638788388560335, 0.1698004661250756, 0.06448393129768104, 0.37079419042915296, 0.1769515413138748, 0.2930506212766719, 0.025160084379590608, 0.060761398482168216, 0.19290889007065537, 0.33426649414192255, 0.3646549477226355, 0.10997897826640635, 0.30779755167035083, 0.1103193243030588, 0.3884938738057774, 0.4391316117803087, 0.2858361990297047, 0.04168487747254335, 0.07168526309095191, 0.11334007264146662, 0.1589163107030085, 0.18288348883032235, 0.10690732821183369, 0.28186846911790475, 0.24792111354320834, 0.19769551700386656, 0.05543279197752349, 0.15889618087607227, 0.33149606723489167, 0.35015762918371196, 0.2986422169833035, 0.2699435581995765, 0.3124274552250287, 0.3268605112346058, 0.3651759823676982, 0.632346441244773, 0.6249408285942986, 0.6025968633667149, 0.548011375389694, 0.6447531873751521, 0.5900701866937264, 0.5002066138348156, 0.5931431085568983, 0.5990647034223697, 0.1040519954883794, 0.12040026516406865, 0.1529065576916393, 0.14899389629503856, 0.1287399890664639, 0.10913876527418231, 0.13787704029839443, 0.14393517281017, 0.09438549119927198, 0.11257418168035349, 0.15455223692917675, 0.1878950980982509, 0.27891554065869417, 0.14646724017286994, 0.15853502442473977, 0.1749986939581617, 0.14067964929158772, 0.3529966241580248, 0.41704180720766915, 0.33463184561469117, 0.36009200906424244, 0.4010750566479401, 0.4023037630521744, 0.37697868324546135, 0.4385034344731066, 0.38858410280775646, 0.332869457241318, 0.2714795619918843, 0.32007283671518616, 0.2853812492889186, 0.32249858400565623, 0.31619576746108147, 0.2484361732082211, 0.3480651224213962, 0.28730166767395826, 0.2992711830844671, 0.1923643102518161, 0.21890545807986794, 0.18986976199751382, 0.20899857311043601, 0.19805958968127413, 0.22078867556464943, 0.20384327856912643, 0.18408697289090148, 0.18985765345549432, 0.18647199999526753, 0.22827345002427435, 0.180417984579621, 0.670303385165672, 0.18662948138079527, 0.19425225726915674, 0.504019869976561, 0.3358778286391555, 0.22148380875217322, 0.16409487854098748, 0.8113228518306164, 0.16837656009360358, 0.1921263235073971, 0.19221702749670289, 0.16039678487935038, 0.7319583408889191, 0.1670191247210221, 0.1508160031007275, 0.20845966707681374, 0.20562483784951968, 0.7151603691623627, 0.20647718388716685, 0.7134530003400852, 0.16616973943020819, 0.15817992370195266, 0.8095844596577443, 0.2038176775766668, 0.16946536138498935, 0.19321959390324572, 0.16614797073029353, 0.19100259809201436, 0.1794924653874992, 0.18125055834648574, 0.18450530894153871, 0.1677895410979754, 0.18940830935814468, 0.0897042310860987, 0.08124359306162954, 0.056996012076164004, 0.08129680042655674, 0.07540292245232227, 0.08467791767195743, 0.09428840592906251, 0.09301766185047766, 0.09856688068302011]}, "mutation_prompt": null}
{"id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)  # Modified line\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Adaptive Scaling Factor incorporating stagnant iteration scaling for improved convergence.", "configspace": "", "generation": 61, "fitness": 0.36699900617273123, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "00d26213-6840-4d8d-a551-02086b1eb8f7", "metadata": {"aucs": [0.8337518052670936, 0.8372600601791689, 0.8174870901061655, 0.8302286362511363, 0.8605074518230019, 0.8389236097724041, 0.876574326177882, 0.8380095657711378, 0.8205793136037387, 0.7572380145473548, 0.6696505690489949, 0.5594685661044521, 0.7544757919638274, 0.6862206508028433, 0.7227237041365342, 0.747944968924104, 0.721780411190158, 0.06340703972109751, 0.13715904704418957, 0.11511220111523401, 0.44642048805860546, 0.3973432759304405, 0.14299113300510302, 0.457709931002912, 0.15460948625489856, 0.15671423425513387, 0.13847810865388055, 0.13310125663296513, 0.12038162891487048, 0.12491921392041017, 0.14471127665458772, 0.1444449752634881, 0.1355224198552587, 0.12325370305553696, 0.1223358698728072, 0.13437460444979132, 0.8970450036014254, 0.864653402159098, 0.9417830304811162, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8393012380221995, 0.9240633858557354, 0.40686156469271884, 0.49736553229504166, 0.3927151662741418, 0.5124852143051701, 0.37516507606111893, 0.4250484761760811, 0.5337471846598327, 0.18780554147504025, 0.4877637748535685, 0.8432202816534189, 0.8322937821717414, 0.21517040572476964, 0.7592558194620657, 0.8111885456291892, 0.7925629308755312, 0.841562477511025, 0.8121746496637205, 0.8261627381301171, 0.18763790614407272, 0.2065578510604129, 0.14151872540705568, 0.5077749730950412, 0.48914120734613553, 0.5953603291743599, 0.20802992801384246, 0.2911841673657235, 0.3287011496010861, 0.2101386620005652, 0.0811051070659421, 0.1681128703304885, 0.22410649019805018, 0.1969267840061958, 0.22760472937638065, 0.12786264673177106, 0.22961156844592734, 0.2358789361857655, 0.09385004713701206, 0.1492890277877934, 0.10890983366600393, 0.026103327984812297, 0.26898226351853916, 9.999999999998899e-05, 0.09388244619053987, 0.4974182235971961, 0.23798181431606835, 0.22609660801501508, 0.49524151119048965, 0.4358134157933685, 0.1364459901146523, 0.2130302607030038, 0.3772975884428903, 0.28328096548163784, 0.11691003798014332, 0.25726366438880743, 0.06389221841115544, 0.10218018300558629, 0.19863749519645124, 0.07408232389696912, 0.3130884546118531, 0.28203884303057936, 0.14615651990913325, 0.21147020201965472, 0.09201118259745023, 0.12498086562296284, 0.16997838332084103, 0.417604467939622, 0.35730953943862254, 0.31594166447713246, 0.42359262036219203, 0.25102698574596294, 0.29519761791616905, 0.35171305892358984, 0.6971966204553564, 0.5578070875411715, 0.6230617746412336, 0.6413498808770757, 0.4993423655442698, 0.6217160785455675, 0.6148126266598095, 0.6090923364444287, 0.6602536067328322, 0.11168259681817694, 0.12041194824329926, 0.12574202679499646, 0.09794531766749859, 0.1265883283831145, 0.10882364448301252, 0.5168840216280909, 0.11340759929722921, 0.09393974862663723, 0.19139599300229593, 0.1621181072295772, 0.15161507066504853, 0.1616376587286915, 0.20345653002242914, 0.23052348283801072, 0.25022637524659697, 0.24413355979146334, 0.1787480005334251, 0.4545349911422799, 0.43041199093437876, 0.42795662783194777, 0.42575293606304676, 0.3698435053373137, 0.46233391389490164, 0.4947789213110505, 0.4242919169820686, 0.3623157493203505, 0.3932871403761593, 0.21774413471211784, 0.395656025259842, 0.324635439152555, 0.2432895440146634, 0.3091172487241648, 0.32103120715028666, 0.32674110937341094, 0.09522304887312472, 0.19061763130892173, 0.1719850762517764, 0.1747415931871501, 0.1680167232687625, 0.18620673566127166, 0.17898114277381483, 0.1985938668834516, 0.17721857614536407, 0.17201938018797047, 0.23844289257799045, 0.5786534473424401, 0.5873202959479328, 0.6333729671557657, 0.5333655980558365, 0.6218607177185167, 0.24011761791302444, 0.2397406765782495, 0.24317429652163103, 0.1635418196677485, 0.84986852089281, 0.16836585942446436, 0.8030863996588725, 0.7954679062640564, 0.6887870984415333, 0.2028072220647097, 0.16504225492756375, 0.19847034137284814, 0.776503798091342, 0.2052138137875651, 0.20635958805023702, 0.2059101842955844, 0.5807747771233163, 0.16712168366670666, 0.20257686149979015, 0.8040734775055011, 0.819502621093323, 0.17904024523540707, 0.1855088846805958, 0.18331461484876221, 0.17741082854070467, 0.19041398348589667, 0.20646114301277863, 0.1808748336395447, 0.17906808487037762, 0.18368221090826842, 0.07481956252790445, 0.08779724606277595, 0.0975141060633703, 0.0911325220248389, 0.1040783684246841, 0.07767079840165847, 0.08852726379493103, 0.06568591735214091, 0.07852289973445681]}, "mutation_prompt": null}
{"id": "e980b472-3cea-4774-869a-0e5d1bf1f38b", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx, stagnation_counter):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        \n        # Adjust F based on stagnation_counter\n        if stagnation_counter > 3:\n            adaptive_F = min(0.9, adaptive_F * 1.2)\n        \n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx, stagnation_counter)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with dynamic mutation factor adaptive to stagnation to improve convergence speed.", "configspace": "", "generation": 62, "fitness": 0.36318812427326785, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.8428016787214145, 0.8240230673094033, 0.8421273610029221, 0.8395123025291804, 0.8331917347221732, 0.8043584718693628, 0.8645524143293982, 0.8393658064655194, 0.8305917897982558, 0.7594251700572379, 0.45839134668259995, 0.5423519985261651, 0.7072558339729929, 0.6884405745838195, 0.7165787461629867, 0.6459117017729271, 0.7544813167836312, 0.25232822176591363, 0.12995787622450605, 0.11366303221241958, 0.16326551107714293, 0.15675852246433186, 0.11804222004708864, 0.1294838387725833, 0.49151062049175254, 0.5099760559443121, 0.14661658109042186, 0.11121391095896616, 0.42933433514452823, 0.12865091579021137, 0.1366335564536948, 0.11426819078702044, 0.10771514274688221, 0.13859947405910666, 0.126672639824163, 0.13031429238097536, 0.8338910028397795, 0.8505772690563707, 0.9417830304811162, 0.8599023487870181, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.84904447661332, 0.9258100624054034, 0.48974137112033345, 0.5538476077317833, 0.630199782716103, 0.5565439911144692, 0.45942588951609764, 0.3106092489312968, 0.37353350826492726, 0.19660805779787072, 0.5246199743167483, 0.8433313189617778, 0.23334209949471119, 0.7982536524843142, 0.6867108944142772, 0.8157791379019944, 0.7742320164645986, 0.8763262282085146, 0.7374853403814801, 0.7794171723842109, 0.20980469424557413, 0.2791389056932245, 0.13853936842863457, 0.2648500500123171, 0.6347455099338692, 0.1739823838405118, 0.18898661093534252, 0.24827581092153306, 0.2532667886229427, 0.23664096957910408, 0.05158700810043171, 0.2217141512233336, 0.17679604339229393, 0.22220080068434778, 0.3521543228564119, 0.1278638145772324, 0.41477134649170455, 0.18863151112961019, 0.09151584951408498, 0.3552215390146509, 0.232179154376838, 0.14527448216114447, 0.12508260154446849, 0.1306449121603106, 0.27295219006420934, 0.21475855290405432, 0.25336198416807776, 0.38234594462016935, 0.36174417764554634, 0.3725767105265425, 0.26055959538652174, 0.2999739831235523, 0.4197459909631849, 0.20604761781935177, 0.15858375860808005, 0.13547282915900483, 0.30457422612057494, 0.15319858549573673, 0.10995641796150779, 0.0724614574279101, 0.13359699176988726, 0.41836242041914606, 0.32741818985105564, 0.17926836528072942, 0.16205201188077478, 0.31340502834386696, 0.32848075256838805, 0.3549323761800608, 0.3218890682932549, 0.31925038456191435, 0.340867215829464, 0.3209952510698134, 0.28865968665645614, 0.3347418394790791, 0.6394721129331711, 0.5917868599307509, 0.6947027491988529, 0.5828135034123132, 0.6061449628546846, 0.5942815174187939, 0.5850679281174989, 0.5827051954080054, 0.7197121307354126, 0.10848977605117327, 0.5307153611366295, 0.13697259051682853, 0.11466375136419882, 0.09319552010220233, 0.10062742140644554, 0.12311930557769679, 0.15419587504871302, 0.11405322634700932, 0.18344731091070376, 0.15717085070412562, 0.156773443780991, 0.11442006698158225, 0.1783927309150558, 0.16313867568513374, 0.18281936426486423, 0.2437725102549475, 0.17879978042346722, 0.3779581413512202, 0.393015671125557, 0.38224924632631174, 0.4409270168451259, 0.3766244973952898, 0.31335942217972446, 0.486296275486258, 0.6080721871012045, 0.4515628605911366, 0.29135514596241097, 0.2879248580219619, 0.32179137525507406, 0.2783553925804979, 0.2916916190222776, 0.2863485715395464, 0.3583287002240041, 0.2972147978190405, 0.09286693615115438, 0.21437985073293297, 0.19487078235856525, 0.18069450084071592, 0.18761099647260115, 0.1919081075537209, 0.19286196149258616, 0.18163449774649765, 0.18065480534172473, 0.18642068088374397, 0.6291731444518984, 0.609292682128484, 0.21717478524874279, 0.6314456174888216, 0.19074114029813505, 0.2254264703925808, 0.21710819531831727, 0.6006953675072886, 0.23711221186190068, 0.16354495762661114, 0.8214033131532806, 0.15054781388072092, 0.8061407998279044, 0.7328629274193095, 0.17125119331229688, 0.20127001870172256, 0.16491411772022657, 0.19551809069659354, 0.612161524887526, 0.1659468979820462, 0.7152314382532943, 0.2045398444814427, 0.1631610905712505, 0.16700179987681152, 0.15134408475779093, 0.806573854513599, 0.8353652678483727, 0.18553978533206705, 0.18626400678182986, 0.18332683110815018, 0.17376791906766265, 0.22035859115783096, 0.17392423613805275, 0.1752566614595613, 0.17510309093175258, 0.17951400637390014, 0.09442075392194671, 0.06766185197890551, 0.07136106635460326, 0.06107144054671498, 0.06467842283105696, 0.07609540712712148, 0.08254997662864205, 0.07098702772958787, 0.09620244678901713]}, "mutation_prompt": null}
{"id": "f0484717-dcea-4f9b-9f54-804a7efb982c", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(5 * dim, 30), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.93\n        self.progress_threshold = 0.01\n        self.diversity_threshold = 0.1\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def compute_diversity(self):\n        centroid = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - centroid, axis=1))\n        return diversity\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n                \n            current_diversity = self.compute_diversity()\n            if self.best_value >= prev_best_value - self.progress_threshold or current_diversity < self.diversity_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.2)\n                    self.base_CR = max(0.7, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedDifferentialEvolution", "description": "An enhanced Differential Evolution algorithm with dynamic adaptation of mutation and crossover rates based on diversity measures and stagnation, aiming to improve convergence speed and robustness.", "configspace": "", "generation": 63, "fitness": 0.3182833892833937, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.7574645038137751, 0.7435678983910233, 0.7732960902248391, 0.7421254386225566, 0.756466725545976, 0.7564976516997719, 0.7740672667770272, 0.7525012958334917, 0.7642326218600988, 0.6148817933925612, 0.5548368601330198, 0.6238334892423627, 0.5913450363160728, 0.5232275834371671, 0.6015132527092464, 0.5510908918692657, 0.5681945512899298, 0.5923752707525665, 0.14680173728115442, 0.4158664167961498, 0.14346016323389887, 0.47954134407763516, 0.47635826835569384, 0.314198623388512, 0.328130350341469, 0.41828111712528493, 0.5144913083606937, 0.13838625422138862, 0.13247515515880348, 0.24348042701021444, 0.12215331206215219, 0.24699254163184337, 0.1322629556937489, 0.13249699302132922, 0.1407864245349152, 0.10548452209495285, 0.8149586079803086, 0.8013716108836932, 0.8399858775587425, 0.8665037422484524, 0.8671421473683194, 0.8474729686653473, 0.8674929096195221, 0.8689967747356169, 0.8802145060438811, 0.3541775560409416, 0.44604001159782036, 0.43703655395003604, 0.34933420534589044, 0.42830005241394076, 0.4189397517451563, 0.36142620881056553, 0.39083340018584345, 0.41763867125010323, 0.5945271281269647, 0.7953450821037872, 0.8132191809049995, 0.6734593658364483, 0.5055743944854267, 0.7180552200641059, 0.610675065068368, 0.6275463380181037, 0.6506542331454976, 0.19807713557443285, 0.2504419367173125, 0.20058004693264508, 0.24245807317680823, 0.18569374701501407, 0.29232934336183236, 0.23378884821781032, 0.2878276291436962, 0.12961877362771845, 0.19749112371508137, 0.21927825297472836, 0.18763174826753204, 0.15283419049186175, 0.2935706310883991, 0.27734234236411204, 0.24113476377081555, 0.20398274179455478, 0.253981853237475, 0.07791398457518839, 0.02385517616741395, 0.0575308598149612, 0.10629688482134847, 0.2017362004829797, 0.12714373156317083, 0.29499969540908055, 0.07201254370345833, 0.11276748035175221, 0.4106971358043897, 0.1459563161466616, 0.20409915042633264, 0.36302680488577177, 0.18888809646118376, 0.21229171881084874, 0.19118388393500085, 0.3056038979930228, 0.1615266213467338, 0.040918145439710285, 0.044961632494212034, 0.040747539591791115, 0.06429600530570989, 0.035876199884681936, 0.07593791117603887, 0.03378611144923649, 0.05572925128810979, 0.06107333251447922, 0.21414885956715157, 0.1523390189416477, 0.20775525325671085, 0.2433620100590187, 0.14650636250081206, 0.17890466899560675, 0.16723974311577172, 0.21947296873193012, 0.16455880087153196, 0.5389287117167874, 0.520458081390279, 0.5325708374297367, 0.5234346254535297, 0.5051400290314958, 0.5293251365688504, 0.5257443518592038, 0.5257817095310848, 0.5409389273441165, 0.11472988426787212, 0.09033416119978188, 0.10422934409414397, 0.08916569046052447, 0.09289316617463794, 0.09228882786260251, 0.10477264239318029, 0.09221535580733797, 0.10102295535316896, 0.12166170618054561, 0.11921743329773382, 0.13771411002279588, 0.13293678453966462, 0.17404304143580973, 0.13616670318005686, 0.18651708099034603, 0.12297452623715965, 0.1527443687427582, 0.3058046587016885, 0.3257107803880296, 0.29361529070534065, 0.3228703980853741, 0.29916177867026494, 0.3760247438030684, 0.34861433783371154, 0.33962078302980936, 0.3339759650664701, 0.20149856747753225, 0.21100292956976185, 0.25038952885166876, 0.2687265565229259, 0.23515121397778105, 0.2048197306084345, 0.2806352292702943, 0.2558886081390811, 0.21106185237965014, 0.2036867738561764, 0.16186641617773945, 0.18049706658890174, 0.17922000298331242, 0.1755301981254459, 0.1777176302964314, 0.208656066921316, 0.17814369529867324, 0.1693628082219426, 0.23840785545850984, 0.1949817493281074, 0.19203182538738361, 0.19317555118102614, 0.18440046861429726, 0.4360510745649778, 0.38700132798666587, 0.1868775759575344, 0.39707115291224027, 0.16637347614871545, 0.17185744302803563, 0.19172437528731545, 0.6874104194730675, 0.19083739269304256, 0.6306087949124275, 0.5907631689618438, 0.5662997569421706, 0.6025362717975404, 0.6524307818476969, 0.4309423145570387, 0.16576614929156241, 0.2040663883296534, 0.6238383499114202, 0.1708526064843392, 0.19598863514879217, 0.12556943457927316, 0.7168077170626639, 0.17544395256916545, 0.18065737111658875, 0.19149782082689493, 0.17381365249312697, 0.17388017011141788, 0.19614172116623252, 0.18842111141410955, 0.17074359716521126, 0.18830952192017392, 0.05992082959009315, 0.08114187126288852, 0.07023909947131435, 0.06863241773913564, 0.07023471134544557, 0.06163975980445813, 0.05942414269880625, 0.08018109932665973, 0.08371849337419557]}, "mutation_prompt": null}
{"id": "c162715b-78f5-46e6-835c-db079b79fb43", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.resizing_factor = 1.1  # New line\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n                self.population_size = min(self.budget // 2, int(self.population_size * self.resizing_factor))  # Modified line\n                self.initialize_population()  # New line ensuring diversity\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Improved Hybrid Adaptive Differential Evolution by incorporating adaptive population resizing and trial vector diversity enhancement for faster convergence.", "configspace": "", "generation": 64, "fitness": 0.14147404453861234, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.14.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.2593703091735212, 0.2419416553250675, 0.5150066787552039, 0.23761200144962524, 0.31696702999266346, 0.2656241759332598, 0.264190450035967, 0.2950595202636781, 0.3682634425175937, 0.014067539835639908, 9.999999999998899e-05, 0.012936839855399729, 0.0010726830927666464, 0.014671476023403685, 9.999999999998899e-05, 0.022215470021164085, 0.006995643731863899, 9.999999999998899e-05, 0.08041983256082474, 0.061736601236556776, 0.06604872844896836, 0.06329625927280436, 0.08282314660967005, 0.07509116906648883, 0.0768026214357258, 0.05964068969358882, 0.06622023608468786, 0.04057596380390027, 0.05436456914578469, 0.04498149818985819, 0.07103123195480077, 0.051926225953252136, 0.06008311957428436, 0.05400155629332315, 0.06409940325024532, 0.07136492602728106, 0.465575964504952, 0.5703186957897828, 0.8575064464774318, 0.7110998617353138, 0.6121177230387682, 0.708633248820532, 0.7544857847724166, 0.8576453745103565, 0.7173516030768436, 0.10108200521871624, 0.11376753675897855, 0.0990189023970397, 0.11910853065741178, 0.0795232236747121, 0.11696719552862178, 0.10094038817796214, 0.09606456676437902, 0.12215208929226207, 0.15362412243434975, 0.17768607025671612, 0.15699832376780143, 0.18923925065517155, 0.20059224507470363, 0.17885206689360822, 0.1668909127927627, 0.16160808387390113, 0.18777914319390288, 0.06468418101491313, 0.055896246131334704, 0.09075561498850726, 0.09435292552771135, 0.044560887490159296, 0.046771996445574726, 0.05981166191810938, 0.05718156613165992, 0.13727039861828094, 0.05746093129381846, 0.027247431189359128, 0.048944602608295695, 0.06459944863162037, 0.07812975295622038, 0.052199545771873135, 0.040250349230033344, 0.056219894555187055, 0.07160662196471224, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001657180767284272, 9.999999999998899e-05, 9.999999999998899e-05, 0.0946642538407988, 0.10410079212539858, 0.09223822973036055, 0.0639547909192899, 0.106615912310153, 0.06351655840203219, 0.11827656701869438, 0.08363221575758994, 0.12604600559818957, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027269086827936162, 0.020567460767197177, 0.03323607075695001, 0.06044902022961707, 0.016657224532966808, 0.008929650762661945, 0.023858370812531393, 0.012613677180865701, 0.03726072703115002, 0.31337685657636716, 0.2758800204953459, 0.2524727046149441, 0.3195159992542014, 0.2670881285916483, 0.26741703088314994, 0.2482660487926659, 0.24936240642362573, 0.261301260383637, 0.05935405982328834, 0.06861621289930608, 0.06005627767700117, 0.0628797273728342, 0.05959142724216049, 0.09198725544011688, 0.060835216652244006, 0.061195897809684485, 0.06913271739077531, 0.12601673107169353, 0.14852988526725608, 0.1315261036112122, 0.14247791817634936, 0.12465955876580959, 0.13140803594075345, 0.12996393093255498, 0.13535331536903683, 0.13078625360583718, 0.19214808353743884, 0.18370177765433104, 0.20730122098564396, 0.2045061858596524, 0.20176024152018657, 0.19180604082185904, 0.182702138946938, 0.21710600673534108, 0.1810421686692567, 0.14447060176684312, 0.16330727916702603, 0.13317418513456247, 0.13684873916339602, 0.13606221032355792, 0.12969606905464548, 0.14744754660292836, 0.1405103439268911, 0.14060485865102113, 0.156721740435947, 0.18606550256590149, 0.18226117617189164, 0.16173250561566366, 0.18063719810927725, 0.17364560673180496, 0.1665698818349831, 0.19667793106513332, 0.16724375157689297, 0.16414366213722353, 0.17974882703465012, 0.15824920506243667, 0.1680504516064213, 0.15848514347056641, 0.16608638932485487, 0.17549303941757566, 0.16473499370317446, 0.1780839716832474, 0.1581135604767786, 0.15173018264586224, 0.1417055253979682, 0.12895545767418748, 0.1700748065739801, 0.15219027580206024, 0.21250515825375416, 0.14163252584438446, 0.15288194085449014, 0.21160807309667984, 0.18237749443912332, 0.15965524427084055, 0.15326772290802948, 0.14333545377307533, 0.22715257654578414, 0.19587563360275984, 0.116463411196989, 0.14909517413549833, 0.18926896129319948, 0.20220919115335045, 0.17115316383258905, 0.1763961179804272, 0.17839235233514505, 0.1771126890722109, 0.1749318961814681, 0.18778987215895226, 0.19246907684008185, 0.06459203695560067, 0.06889991038086796, 0.0653147584660565, 0.051217927113010764, 0.06089831407393398, 0.06597707055136104, 0.07272170449615512, 0.07579188128527492, 0.06413891495837454]}, "mutation_prompt": null}
{"id": "3bcb7049-5e32-4277-a78f-cc4b34a7e995", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        # Adjusted F to adapt more dynamically during mutations\n        adaptive_F = self.base_F * (1 + 0.3 * np.random.rand())  # Modified line\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Slightly adjusted mutation strategy by introducing a dynamic adaptation of the scaling factor to enhance convergence speed.", "configspace": "", "generation": 65, "fitness": 0.36039325815868317, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.8053236300615675, 0.7827916032843909, 0.7978656441613096, 0.7907336428004359, 0.7904449452144271, 0.8258108869838757, 0.823874391332037, 0.7803828273353706, 0.7996272871483474, 0.6389935056297436, 0.663089165183941, 0.6540428886265977, 0.660724172457277, 0.6738502883305775, 0.697721286085581, 0.6924214975851553, 0.5260644893641241, 0.6654622986875651, 0.15437752640679625, 0.34918995880406856, 0.14674318709884593, 0.12779006337361265, 0.44294666961203155, 0.14253138456266023, 0.148337425864427, 0.3447481063047999, 0.14014698294343486, 0.11506691733993235, 0.13288897917532683, 0.09827891375039488, 0.1316491025171168, 0.3218440947285821, 0.12696607404253535, 0.10053341256560966, 0.12023541010314698, 0.11801079768256073, 0.9666866545516758, 0.8548976492489474, 0.9316564821162107, 0.9245852613993522, 0.8940190298081503, 0.9605698145252918, 0.9243358561378869, 0.8621667578008037, 0.9615968977841274, 0.528503371328795, 0.34169839067524654, 0.5216214141483522, 0.5123068123488996, 0.48382727588143803, 0.5665135683257843, 0.32042440226616997, 0.43597986024949564, 0.3543022730875358, 0.7498831758546111, 0.7507909134123136, 0.7771672890547372, 0.7843888636528651, 0.84491702901998, 0.2073007999145703, 0.736983721501141, 0.7921923221708012, 0.8049256693133315, 0.3097191558439043, 0.24750841707860993, 0.27704708408106715, 0.2916113322869055, 0.2109324426159933, 0.39602306974561896, 0.12836804013819525, 0.20398510459594343, 0.4539785634359288, 0.2605328057489278, 0.41345516489817014, 0.25988761393757753, 0.32584101460575765, 0.2764993967077317, 0.21855797928538256, 0.2341957390673055, 0.22759890065970423, 0.3019443647229284, 0.385706176739931, 0.18778227197652642, 0.14773241103826984, 0.24606801037745418, 0.14727192376009024, 0.13740404172573162, 0.27641864504612423, 0.044261462141674035, 0.34056305511264595, 0.37503828071475975, 0.23024420789513356, 0.3356617315365569, 0.4084146333155835, 0.3220110207481214, 0.11375735102395224, 0.5792285631562517, 0.41455293865323295, 0.4433420179640202, 0.11282559612433685, 0.08722810574881112, 0.20282290092141453, 0.24092939079448383, 0.21897481470432978, 0.11132032780162993, 0.1579614564398647, 0.1437401210305741, 0.16210298647679777, 0.23985855630399422, 0.32097958428945883, 0.2720234912650451, 0.3386746666825665, 0.29044189788943164, 0.3284781462265638, 0.24404587312408532, 0.2721376628585339, 0.26458743430892995, 0.7212819645259445, 0.5893765344260633, 0.6199060409005606, 0.5753252022453718, 0.6691384352246316, 0.5728966656869927, 0.576787253213354, 0.5935471084412454, 0.5472256317373854, 0.12045657390042108, 0.0817805937289422, 0.12377004005764014, 0.0993471464367438, 0.09903139064698585, 0.11404488128696011, 0.1249429164490381, 0.12667427385950736, 0.10969205213531297, 0.1302736778163639, 0.1806661061896483, 0.19958201963918332, 0.12484827344684857, 0.14201592167212274, 0.15128326583286944, 0.1651234948314484, 0.16745895146576006, 0.20589325286743032, 0.2611503297139173, 0.40374649888930003, 0.3866650950626439, 0.40143359420120983, 0.42426069375990705, 0.36407729788986587, 0.3281964205694713, 0.39843500855602965, 0.33923540940357344, 0.2653575166362714, 0.3295198241418541, 0.2889528859632905, 0.29946122029653766, 0.2236409571847866, 0.3287226678273403, 0.25801968647824713, 0.32311922802420234, 0.3325680934656221, 0.19233342866493985, 0.1870510323828255, 0.1595808563040293, 0.16736905544776037, 0.16243583980823206, 0.1856887160990941, 0.1645250133572146, 0.16944331939854762, 0.16748683057269775, 0.46854235543579126, 0.19324918656580836, 0.22564034148078838, 0.19452613004034836, 0.2008840548605002, 0.20228219488721488, 0.19239297787057508, 0.2252810331110492, 0.2213855113061446, 0.7395124499534985, 0.8271459312253792, 0.17994439814773866, 0.18867870718551927, 0.7240803152415034, 0.7727044000566484, 0.8006294772328129, 0.16022916255883424, 0.18958236471903434, 0.8324020342139771, 0.7846616592612314, 0.15225640559275766, 0.20487587251763084, 0.20107540953436076, 0.19979206795645987, 0.20328956699986778, 0.7720176756879571, 0.7244653941066013, 0.19104548859239434, 0.1733714681359645, 0.19450167479297786, 0.18763589332250363, 0.16881182801948802, 0.18881280469254613, 0.17474208264505853, 0.1713245924998169, 0.17739966840502042, 0.08330770036443158, 0.07884926241236512, 0.08247633479924898, 0.06961251755062914, 0.08361427768761387, 0.059368213792199254, 0.07488510523342307, 0.07075545773185765, 0.08002716698451462]}, "mutation_prompt": null}
{"id": "e77bbb16-ca64-43d2-91ef-8c067c31125f", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 4:  # Reduced stagnation threshold\n                    self.base_F = min(0.9, self.base_F * 1.1)  # Modified line\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with dynamic parameter adjustments for improved convergence.", "configspace": "", "generation": 66, "fitness": 0.3525825457545102, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.8375361926494933, 0.8419092799572385, 0.85863155773971, 0.8462694232637018, 0.8491997696978664, 0.8395667956373299, 0.8683991754144256, 0.8437287632342724, 0.8279218277430058, 0.7712388709680411, 0.6653033844298579, 0.6011778696224227, 0.756799541314433, 0.6987503797271162, 0.7199664672318563, 0.7506476910289297, 0.7228453815755876, 0.01906311651719661, 0.14497962439297485, 0.11583712370944099, 0.5199038813570678, 0.13725865609292054, 0.1440198449581992, 0.40503038328370533, 0.1688626138172291, 0.1369583490085482, 0.14494762966522645, 0.10362542434485333, 0.16188594477602114, 0.13648582056531322, 0.15530379636720448, 0.14193143443596623, 0.11035809421425202, 0.16469476846697306, 0.4507735377143929, 0.12056689504004336, 0.8752059620563447, 0.8613992116407604, 0.9382534782389563, 0.9285519020042245, 0.9484635249261704, 0.8951386221066019, 0.8860831341132134, 0.8593552568964561, 0.8984351208549652, 0.5627299258465961, 0.4394432983852403, 0.43318804358378904, 0.5139986004869243, 0.38591627744635415, 0.36861931357890265, 0.5588658064729465, 0.2226776904243395, 0.6090022833738771, 0.82423302213515, 0.6920868215288873, 0.7585478569164287, 0.17542262511437023, 0.7828360528126953, 0.32378457723874166, 0.8592936460053078, 0.600424299567009, 0.8354367810163063, 0.1900543626698582, 0.21770530439556124, 0.16662739261536608, 0.18826468375659822, 0.5622130531750813, 0.18868135552108944, 0.22118266514575646, 0.5013021049890755, 0.46614910492594597, 0.19473401246306765, 0.12507585160554313, 0.2333452776901771, 0.37843428317545535, 0.33719255944150084, 0.33086138294634804, 0.1278417437356416, 0.23943254577163475, 0.23841836058263577, 0.08428519107547727, 0.18833901373148731, 0.15297742854921148, 0.15007235982068812, 0.21507716266307697, 9.999999999998899e-05, 0.04389362761153537, 0.26361334981825535, 0.2649755070468838, 0.17593994495108856, 0.3401705449759401, 0.23264881785773817, 0.13859327886008344, 0.26802669518661737, 0.2724081325097675, 0.31651446027659536, 0.10985142117475988, 0.479329838944503, 0.06161711154712812, 0.10178599823363987, 0.223247923649722, 0.07408231432648116, 0.10393092973513485, 0.2728718107065482, 0.21494261499998157, 0.11902724258247321, 0.1339281476880012, 0.34755117382584144, 0.1537544278939904, 0.3489318976828353, 0.3649590588184113, 0.293618226884361, 0.3426537041653809, 0.23377219808382343, 0.2671201336803699, 0.33162527711117995, 0.6415938847131184, 0.5894259839687706, 0.5915205790113788, 0.6439422225126079, 0.7173746297738062, 0.7045201826864653, 0.605685469014309, 0.6279432279136896, 0.6403192098944969, 0.09979132953229475, 0.10427176703648833, 0.10477491547386308, 0.11011554246702471, 0.09843303557829441, 0.1393470668407084, 0.1558616802241759, 0.11892675768732719, 0.10768842597581063, 0.1467562166892984, 0.13454292801129597, 0.15337315230799375, 0.12402830962755684, 0.1447078151753649, 0.22756935562098346, 0.1504156907661356, 0.24171170755619353, 0.23080561070720307, 0.42249980992001734, 0.45707624913010214, 0.4781041947529664, 0.4120569289726289, 0.4106306751276222, 0.470487307380796, 0.4374623974016656, 0.46498241179636934, 0.42793692576129694, 0.28408167307828425, 0.2882777006514602, 0.36241783416472595, 0.3340128961333827, 0.31581335969014224, 0.30892112829415785, 0.3599043972800464, 0.2701446377431175, 0.09363469803996982, 0.18488454349522876, 0.16872545629087254, 0.19112243306342724, 0.19483756946850594, 0.2139289887378204, 0.19256742054557519, 0.22459282429874505, 0.19671428534478852, 0.22472031939845105, 0.23320666501012688, 0.21537707361157665, 0.1907720608240896, 0.621759469411004, 0.1806805673041474, 0.2173633680577397, 0.22888770922290946, 0.2071905930623522, 0.23253523613375648, 0.1635490071663409, 0.8002956807563051, 0.14968414364017046, 0.7911181387678374, 0.8111616514504603, 0.1661872729990268, 0.199577866674027, 0.1624771975287358, 0.17310769243117174, 0.6233365169841693, 0.20531774945697212, 0.20830974314634654, 0.20594237044712904, 0.6893041645018286, 0.16699215606115791, 0.19761453382051375, 0.786628494573475, 0.8543452822530866, 0.18805130589750585, 0.16680875443648058, 0.1990153411389407, 0.1727778040972573, 0.16032193105913506, 0.16709578399142588, 0.17896637599174114, 0.20295623536935237, 0.188914065223727, 0.08209753120329899, 0.07548164159256299, 0.06713324159385792, 0.06792105073321453, 0.07358396970548786, 0.07235859652466914, 0.09761781170199268, 0.08452529895750105, 0.06996951972104104]}, "mutation_prompt": null}
{"id": "6a13c1db-86b6-4da1-8b10-f2d24f5a3cee", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        # Adjusting the mutation factor further for exploration\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.15  \n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.15)  # Adjust factor for more aggressive response\n                    self.base_CR = max(0.8, self.base_CR - 0.04)  # Allow CR to decrease slightly more\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Adaptive Mutation Intensity and Enhanced Stagnation Strategy for improved convergence speed and robustness.", "configspace": "", "generation": 67, "fitness": 0.3349796697532443, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.8598558003647676, 0.8438430249862562, 0.8642222602312706, 0.8452772172084733, 0.8190267495101781, 0.7992897095202257, 0.8344359523438399, 0.8304818225172211, 0.8321540093451779, 0.7020622615343548, 0.7435932303142194, 0.696102475333807, 0.7272052931610307, 0.7043099137585759, 0.06285687652125505, 0.6860675682961004, 0.7397408982876728, 0.6946085283317887, 0.530682245524263, 0.5219527426948845, 0.15506909047828032, 0.5715337711002837, 0.4791500678187999, 0.38691515751283323, 0.13584221077454695, 0.14321109402968146, 0.13624749412834392, 0.12509028614897166, 0.13438401641785203, 0.10210156949921634, 0.13769161965565146, 0.13082200058215276, 0.1179580783176678, 0.11518971342666806, 0.12054864622104755, 0.15539542370688963, 0.8598030733499955, 0.881216523741442, 0.9655274266117038, 0.8659682914806205, 0.9567046154361709, 0.9117751336331091, 0.8658903350615706, 0.8611000009483879, 0.8849005396396541, 0.4065770898264003, 0.06746030367559486, 0.2916652615103259, 0.19715426240859968, 0.3510615218176636, 0.4830073286524347, 0.24704643839284535, 0.15753925396748636, 0.559425733523941, 0.2273191599719827, 0.6215838767448467, 0.6616846641721471, 0.8020602035707107, 0.7999913606427899, 0.7135150224848625, 0.22482798420491534, 0.5648963265103935, 0.8696742214156106, 0.5837558136618877, 0.12864916063002874, 0.19682833216541806, 0.2939128825978653, 0.2317684468556941, 0.13249120880967424, 0.21512836698064952, 0.27868732819157394, 0.1865041622657232, 0.20258948532178023, 0.2087367275427875, 0.2210901931899284, 0.17070671452264885, 0.47357932264525515, 0.42841314957241516, 0.19535421521747576, 0.2301926649987488, 0.20944297026565695, 0.11897760904506882, 0.07210684095842967, 0.06123986959293848, 0.120697432032836, 0.17227600321940006, 0.05132716984944852, 0.26878481514411423, 0.14075451006081674, 0.19568766999783083, 0.16326799029257966, 0.2525433315204503, 0.29569107871126465, 0.22347664343745577, 0.1791969834474374, 0.16340907469276977, 0.21472962720622524, 0.43686149466562607, 0.16616401640007628, 0.07664645834150285, 0.09275319409280691, 0.07256238018042771, 0.15590676585795005, 0.19907276689647868, 0.0916674996489657, 0.14697715691822089, 0.14187404030127615, 0.27036382367878176, 0.2626117118513299, 0.1266690816006385, 0.26487426555896587, 0.2589186892512365, 0.22855543687616542, 0.33511763219796054, 0.27784454905434985, 0.26667515958968435, 0.28237324647020157, 0.6105663590149768, 0.6334463330878115, 0.565751392095667, 0.5708257547043615, 0.5762759183989562, 0.6130554308605217, 0.6240120956535686, 0.5954303909641538, 0.628559773199401, 0.11342280003849592, 0.11740206414941656, 0.0928274569347095, 0.10993391041392664, 0.09284101651439647, 0.09366910418878593, 0.10766612917838736, 0.13065487908699813, 0.21825833608320766, 0.19753680238947202, 0.2571150006678201, 0.12670820719541476, 0.12868525103665474, 0.14263783483168102, 0.14731003938867016, 0.1738213242015756, 0.10929356961899162, 0.15796334613192542, 0.3681029620111509, 0.41725656989458837, 0.31017727647381976, 0.4401934799632672, 0.3578633244255559, 0.37731733401456835, 0.3788685599090873, 0.4570056078450888, 0.4169691048230967, 0.2907287006300209, 0.2467554471623049, 0.2635458230243898, 0.2734110403397054, 0.2407000239532644, 0.24869393475822554, 0.29276967246499985, 0.3136204611435349, 0.2566582276589481, 0.1937474648531966, 0.17705546205652845, 0.18724148478154545, 0.19450663517003863, 0.18418729537560052, 0.20095201324420509, 0.16565530009309837, 0.20695566676529842, 0.1939247081930684, 0.20946741052818174, 0.2299323370390578, 0.1892265398641878, 0.512878928774171, 0.23602403354042523, 0.18490452185787676, 0.21898788178864037, 0.541090857514817, 0.4215283665110495, 0.17859924159416696, 0.7258898129246794, 0.1505547716788337, 0.6950106786978429, 0.8196555589296991, 0.16316422968734967, 0.2045293527189388, 0.16582593046905292, 0.7144911531913766, 0.16093937186520202, 0.16551847728514657, 0.715345967929524, 0.20435671040108394, 0.16545409420249757, 0.16742517481312202, 0.18902182422222658, 0.20898228590843337, 0.7110636132550072, 0.17931517424721866, 0.19188981020657536, 0.1947684621180178, 0.19836384456533018, 0.16626577460509162, 0.17149428035959624, 0.17451466750409494, 0.1766900156596063, 0.1647058542434412, 0.0780627423323822, 0.0683837899749522, 0.0672064671307202, 0.08092959615112227, 0.07268917973323952, 0.09714364824469413, 0.07414775344954427, 0.06933400665269951, 0.06851843419432646]}, "mutation_prompt": null}
{"id": "4abd918e-bf00-4b75-9a50-a3fbf2c9850e", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.075  # Adjusted line for more variability\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with dynamic crossover rate adjustment for improved exploration.", "configspace": "", "generation": 68, "fitness": 0.3319698609827339, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.8194083074633975, 0.8260313850048251, 0.767729865346419, 0.7798958692296983, 0.8392550556029129, 0.8397718837485724, 0.8651469633048464, 0.8243071883427529, 0.8341007348693372, 0.7530387907460939, 0.609304731115254, 0.5890946746287244, 0.7344554603878991, 0.6858517462761323, 0.684818690079597, 0.7299173674322023, 0.6999410041106775, 0.2779544481117998, 0.14284949629703425, 0.129186976476094, 0.4116860996128531, 0.14350330729038285, 0.13545495097714721, 0.4484924053817684, 0.10875562476655976, 0.3790640097955287, 0.5143971598605391, 0.13784586834904544, 0.12381691885368695, 0.0987565663772415, 0.1542718620942416, 0.1229435929227648, 0.12510356994449612, 0.1441984765316291, 0.14275791928709536, 0.1202304625945051, 0.8949667916281117, 0.8912768789244885, 0.9172525970153312, 0.9288649507954132, 0.9315607244658086, 0.8703126373260877, 0.9005207529406063, 0.9460540670170237, 0.9283477595695799, 0.40685118852783275, 0.3405615499489858, 0.3002429665821532, 0.3769023537063295, 0.4490876086183283, 0.22393935616396832, 0.12543386127756806, 0.36026768266740516, 0.3200973711463342, 0.7855393760936548, 0.831517573640892, 0.3674655457667291, 0.20938049700200845, 0.8512298705946176, 0.7814014773889583, 0.8465529949896904, 0.8631257739158128, 0.8447708528209265, 0.17771223573870887, 0.1852025425741065, 0.22783236152015762, 0.6293311178688806, 0.1455624286393169, 0.47147955942963704, 0.16964904612754472, 0.39414672201085954, 0.48089222147251187, 0.25509961215724475, 0.12772520015847622, 0.009964234757800283, 0.5053778623623573, 0.17506028640276128, 0.2144177206843011, 0.3319436341771932, 0.15988059337706184, 0.15665268056423898, 0.06067401351978585, 0.003409691683252225, 0.1271234861883761, 0.05311889061498021, 0.13899194847929486, 0.12255320201233522, 0.07820838585267642, 0.0169208832091986, 9.999999999998899e-05, 0.33308013206422227, 0.43948659194867823, 0.19571872556074055, 0.36883511505673205, 0.18540407781380885, 0.05816871126319634, 0.23587090523369358, 0.11174533812944631, 0.22786029919181006, 0.08942686832939839, 0.11268341519901082, 0.16547872488657667, 0.07769553730326828, 0.08261274164879706, 0.09413728797296572, 0.09188440327457958, 0.12361922911098178, 0.1410042814526714, 0.24024764104454666, 0.3512277228306714, 0.23619606886549005, 0.32592205458128787, 0.3162600435292602, 0.27203951592024145, 0.3257600451530396, 0.1836650564987925, 0.3104199769550062, 0.6932765671821092, 0.6593867224643523, 0.6229984514979704, 0.43126736841425095, 0.4782035205424596, 0.5439031628220714, 0.6633111367870691, 0.5767752182291476, 0.6860127878249049, 0.12672213025541057, 0.11175082041891293, 0.09128712248655302, 0.08819456444086571, 0.10716734466198763, 0.14124165357583462, 0.13402402796743085, 0.14673303990707098, 0.11202604080248257, 0.2179368421334873, 0.12052069403681054, 0.36041622004867746, 0.17754341786207806, 0.1084776927251534, 0.18024745132338071, 0.1842383038675134, 0.2579213577572841, 0.169322595815402, 0.40433447648787324, 0.43732213699124944, 0.39841753620422304, 0.39274719477349185, 0.4109532704132486, 0.3894378089611701, 0.4053482954992249, 0.4375364931256728, 0.4766484343875318, 0.29135266007809124, 0.3370545435447009, 0.24004969408115262, 0.32347231185436587, 0.2671433306267017, 0.3784113572157083, 0.2894738637572746, 0.39551514492767825, 0.41995330279140175, 0.19370230113046893, 0.1736964879686953, 0.21276671327124652, 0.1855986768183847, 0.207367284858614, 0.18488945469062124, 0.1785127777092954, 0.20595972449882805, 0.1990048524059559, 0.21329861950598505, 0.18911159154292656, 0.19971135702740417, 0.5473390131799369, 0.21430585806250768, 0.4672720243340437, 0.20139606015677514, 0.2247103469982037, 0.2057453208215868, 0.16355726041625007, 0.8730281714297905, 0.14641308715249812, 0.16856748709783964, 0.17602904032980093, 0.16225720330316162, 0.20302003468105378, 0.16942480207268273, 0.1642758206943158, 0.7612110438975264, 0.2070076338403155, 0.16435610178531368, 0.2040676419332046, 0.1663006968468892, 0.16412595934277474, 0.16275214052238063, 0.832863670814751, 0.11120687726246647, 0.18702325493435012, 0.18463122368056906, 0.19274753926109822, 0.17616766863494226, 0.1852277510806426, 0.16319830590510187, 0.16524661719765754, 0.15245189419964522, 0.16800825981149503, 0.08333821511114581, 0.06619391168709121, 0.07940006543476374, 0.09472509077385749, 0.06598741182974022, 0.06782441984385645, 0.06580989989010433, 0.0904403939840569, 0.0737912328840975]}, "mutation_prompt": null}
{"id": "95bf5d3c-1e3f-4146-87e2-ce11cdc06c56", "solution": "import numpy as np\n\nclass AdaptiveBiogeographyOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(5 * dim, 30), budget // 3)\n        self.mutation_rate = 0.3\n        self.elitism_rate = 0.2\n        self.migration_rate = 0.8\n        self.best_individual = None\n        self.best_value = float('inf')\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n    \n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            if self.fitness[i] < self.best_value:\n                self.best_value = self.fitness[i]\n                self.best_individual = self.population[i].copy()\n    \n    def migrate(self):\n        sorted_indices = np.argsort(self.fitness)\n        elites = sorted_indices[:int(self.elitism_rate * self.population_size)]\n        for i in range(self.population_size):\n            if np.random.rand() < self.migration_rate:\n                donor_idx = np.random.choice(elites)\n                donor = self.population[donor_idx]\n                mask = np.random.rand(self.dim) < self.migration_rate\n                self.population[i][mask] = donor[mask]\n    \n    def mutate(self):\n        for i in range(self.population_size):\n            if np.random.rand() < self.mutation_rate:\n                mutation_vector = np.random.uniform(self.lb, self.ub, self.dim)\n                mutation_mask = np.random.rand(self.dim) < self.mutation_rate\n                self.population[i][mutation_mask] = mutation_vector[mutation_mask]\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        while evals < self.budget:\n            self.evaluate_population(func)\n            self.migrate()\n            self.mutate()\n            evals += self.population_size\n        return self.best_individual, self.best_value", "name": "AdaptiveBiogeographyOptimization", "description": "Adaptive Biogeography-Based Optimization with Dynamic Habitat Suitability Index refinement for enhanced global exploration and convergence.", "configspace": "", "generation": 69, "fitness": 0.13333392694394525, "feedback": "The algorithm AdaptiveBiogeographyOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.09.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.36158270373082135, 0.2949360855471863, 0.3905310559460975, 0.3545960123972609, 0.34606745414720586, 0.3043498802315795, 0.3561643147331466, 0.32327579282551056, 0.3656305209358939, 0.0058831768440573695, 9.999999999998899e-05, 0.019424528555570086, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0049255262726101146, 0.011479251269771673, 0.00018694488755333083, 0.12499038359433601, 0.13615570961709234, 0.13569138915426704, 0.12571292398447298, 0.12434619845703077, 0.14691115939900135, 0.12216204088019311, 0.12853561847295625, 0.15815669407278643, 0.11871637659987921, 0.1522999474680733, 0.10862688225563089, 0.10549236376506144, 0.10626069266715932, 0.14536138277969368, 0.12585242498960503, 0.09966347617081805, 0.12158061114781571, 0.16088342569991432, 0.15449388680320553, 0.18058503724108033, 0.16790480011943787, 0.14983781659121664, 0.16169265049425396, 0.17316205926017825, 0.16203625252119658, 0.1613650447257109, 0.11701615366180085, 0.11044070170149245, 0.14668178656808772, 0.14774729954415655, 0.15322474688257803, 0.12524290554552464, 0.17399773965832355, 0.1396997078251745, 0.12855060240624228, 0.15425199503735054, 0.18695410575604032, 0.18028089311311601, 0.14562138556702398, 0.21025353447236417, 0.1888285933035353, 0.12817691760621852, 0.17482726350653288, 0.14485422369153989, 0.0930778937202984, 0.12813640366513612, 0.08655157723662377, 0.1033146134507128, 0.073126076543924, 0.07225041128895282, 0.10876110863718391, 0.14724779175587932, 0.14885937598387122, 0.12914100242522486, 0.07359673648041898, 9.999999999998899e-05, 0.12236652455832542, 0.11537086938697672, 0.10427329820402342, 0.08818022973176265, 0.071253987205808, 0.07434684501649136, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05567681324280549, 0.035992113149340366, 0.05532917081211364, 0.0798929074287662, 0.03479183552375997, 0.022851418873900187, 0.06038882395525835, 0.013694784961604145, 0.043731690802542134, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06701376958957195, 0.033595108096836857, 0.008893658652498915, 0.025867276416381868, 0.08328936589996028, 0.03980035073811594, 0.04592621632363991, 0.05879391895528263, 0.06879161581467164, 0.3061375287503947, 0.3191794081959286, 0.32121459004445985, 0.30185354418900756, 0.32979778432179685, 0.3023137120065521, 0.35983291457952393, 0.3017700272485553, 0.3110287645225792, 0.05705552435543071, 0.06811561149502632, 0.04606140231081013, 0.06302771041807209, 0.06838572779607877, 0.08894144689172534, 0.1008295640366974, 0.07827117963020591, 0.06158179903033578, 0.11495566030900572, 0.13724938317472168, 0.16747798234555944, 0.13339289211947003, 0.197325134484432, 0.11665270008789197, 0.14700751379907795, 0.18903062444743568, 0.12236037954437429, 0.17928807772918443, 0.17138325461304615, 0.17116030456218756, 0.2149864948738962, 0.17853309065665968, 0.20770551363527723, 0.22602555367490773, 0.2552242646783339, 0.16283711979993676, 0.14639826918912258, 0.1745760632930924, 0.14134992738208707, 0.142412051682424, 0.17938026665103934, 0.14042586560553394, 0.16299608289805345, 0.1873967708232971, 0.09830736099617499, 0.19272224935426274, 0.1394235576397337, 0.1749837069251753, 0.17376676379346268, 0.19017129939073407, 0.1643483690003018, 0.17884290432422711, 0.16180618323359175, 0.15329745111585524, 0.17520441732727576, 0.18096545892240024, 0.1955113607654323, 0.19438088032171974, 0.26416110367811685, 0.20055097521393894, 0.1767715276364341, 0.1940528988494823, 0.18382668874955166, 0.11713143463754316, 0.11199766625182073, 0.16470598638216927, 0.19297803880919961, 0.16688440231653745, 0.2963294437410132, 0.12471543442734456, 0.1285361930608342, 0.1629944187252782, 0.12019109139480044, 0.2029827327015491, 0.1321349525917036, 0.24421405364278015, 0.16390617829113419, 0.23817755411779307, 0.21978854700834938, 0.19038482395262468, 0.11845624615249672, 0.17713676251250177, 0.1849910676502332, 0.17474568833656579, 0.171733461967441, 0.17170068443805886, 0.17684752195478126, 0.19277035709515122, 0.1772804579697147, 0.20489304114163664, 0.07067662989796208, 0.07740048931507548, 0.06305075776553748, 0.067035620288869, 0.05979467095326729, 0.06285964754630735, 0.06895351985251674, 0.06273985705504548, 0.06234750919333276]}, "mutation_prompt": null}
{"id": "d2d6735d-f4d9-4516-a2fa-c7e29f02d184", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.15  # Slightly increased variability\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.06  # Slightly increased variability\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.04)  # Slightly adjusted decrement\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "HybridAdaptiveDifferentialEvolution", "description": "Adaptive scaling and crossover rate adjustments with dynamic population size for enhanced convergence.", "configspace": "", "generation": 70, "fitness": 0.355827534664128, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.8487908025698679, 0.8375645683882633, 0.8371502715765444, 0.8419598907258311, 0.8435068142580068, 0.8299505405323989, 0.8595452734552365, 0.8517470972523921, 0.8278696017209848, 0.7555991081620462, 0.7455427821147877, 0.7295639126908913, 0.7114745143255554, 0.7390553915497792, 0.7296732855701078, 0.7112627168678542, 0.7431782532945692, 0.7330861619871909, 0.14099095256813676, 0.13088449162976779, 0.5126307749740213, 0.1637586107822313, 0.13995922546830897, 0.11547327804353391, 0.12636110254719823, 0.15117624757637116, 0.4734330057712267, 0.10252580699722569, 0.11937971456748453, 0.12188833483498707, 0.13118313366587409, 0.13478521742714988, 0.11122259039682791, 0.1510020008418671, 0.1337638809232563, 0.45871726607798713, 0.898308750799917, 0.8983692906015657, 0.9474435183763593, 0.8637284653327958, 0.914621935452612, 0.9002783901402552, 0.8978430215807769, 0.8687338678733104, 0.9178312396357621, 0.38178046765490625, 0.1114220321228675, 0.44131851990502, 0.5260300159086624, 0.3144088022774624, 0.18123625875532823, 0.3133358315982725, 0.42368932423019967, 0.2320656953499861, 0.8310315103584147, 0.7457956420889654, 0.8473041119728851, 0.8464021031008467, 0.37285809222208566, 0.8174206600425152, 0.44220313734085503, 0.8507727124097483, 0.8641124509581088, 0.6670981772425818, 0.28076718614082385, 0.303922810696729, 0.24541826061245964, 0.3512965191779084, 0.2790018301214855, 0.5618385509604017, 0.18284242500487136, 0.33980010891302403, 0.20308327452224484, 0.1797078948266413, 0.009970499539209365, 0.19954340315586072, 0.2762565048555382, 0.18459396721100008, 0.24755868598597652, 0.3632769662020402, 0.2323972065003651, 0.2171789915759964, 0.10420856728501926, 9.999999999998899e-05, 0.24574450531183756, 0.11213125669018842, 9.999999999998899e-05, 0.4077292164783959, 0.06027331456303642, 0.2788325419341684, 0.20822332885745531, 0.23913201095625347, 0.1470421311983735, 0.14326897243666448, 0.187936697789289, 0.22551118132563042, 0.5775646694609595, 0.4966316578237804, 0.39155149034616354, 0.14959446421967038, 0.18410181589936792, 0.2746582686274184, 0.10713157813061447, 0.20814117608665472, 0.12812820747849762, 0.26583359990626354, 0.1546735623252221, 0.10573458953329407, 0.2322886644712654, 0.3411734848846677, 0.32254743239100503, 0.4184065214821657, 0.28737379943838304, 0.4655557008803939, 0.3069152990264117, 0.3197171266349603, 0.2848666116183728, 0.6202687997099976, 0.7687818000786042, 0.6309861579713516, 0.5939201667061624, 0.6146276447184794, 0.5703671228738815, 0.5901661086397135, 0.563994052826958, 0.5827783132826584, 0.10209181317772631, 0.10382423630680349, 0.08726525891179138, 0.1238185652737015, 0.10047960017086666, 0.12246304205005032, 0.12328166972642518, 0.1589196332862839, 0.11224931282455453, 0.2021132414534763, 0.14561187202262904, 0.199485607043851, 0.15436858360657202, 0.1992865591222076, 0.5748795271594422, 0.15163513945213414, 0.1635194062693094, 0.1871240901275425, 0.4044849701186194, 0.530368580282604, 0.3977333417683997, 0.3624778887078657, 0.4301042641065058, 0.42661842032499075, 0.3169517324893045, 0.513504554034101, 0.42936358758610216, 0.2663371052272906, 0.23583428670402395, 0.30803754958316665, 0.3153370802415072, 0.31788348461011906, 0.32520425717898815, 0.3350743188344041, 0.4352011167418144, 0.31154780979147967, 0.22029533245380695, 0.18642985394465195, 0.16127559023422255, 0.19255242072872147, 0.17141754497046224, 0.2031049895900685, 0.18890866727661604, 0.17521612272919485, 0.22042745278341425, 0.2041488482181919, 0.21993962370657805, 0.20072656834743163, 0.21320574235503587, 0.5516098025453993, 0.22901775666603863, 0.21771989319092666, 0.6075557946128882, 0.18320534012324485, 0.7057295254051087, 0.18675770704301542, 0.15267945645984804, 0.8125926097896853, 0.8035674272728687, 0.25713865823915794, 0.20526698704614588, 0.16861764828968262, 0.15252520397930514, 0.19685031059474656, 0.16587803189907702, 0.15202083909845987, 0.20655847836455055, 0.16471665742110997, 0.6703250366273399, 0.7191773463507583, 0.20831575576420702, 0.1110910429564701, 0.18592386897799607, 0.18013191443230403, 0.19302415706366793, 0.1793002976615068, 0.17973341136366217, 0.17211418276225798, 0.1747837016285272, 0.17783896490962603, 0.1734234845854148, 0.09580200948670992, 0.07337902513732097, 0.08009443876024869, 0.07195765412842936, 0.07615643471921663, 0.07138945618243941, 0.07914514573327236, 0.06647537987484098, 0.07675704087804258]}, "mutation_prompt": null}
{"id": "ad0bb496-9818-4e91-9c6b-9d5e719bf2e3", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        # Added more diversity by including the best individual\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Dynamic Population Resizing and Enhanced Mutation for Improved Convergence.", "configspace": "", "generation": 71, "fitness": 0.37033800397821987, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "f3ed88b8-d5ea-43f1-bdb1-9acf940f6bbc", "metadata": {"aucs": [0.8224044803738019, 0.8179724392500335, 0.850641011628226, 0.8384028592286684, 0.7877130093216396, 0.8535132353380341, 0.838107271756281, 0.8256958754588639, 0.8041018678129037, 0.6902472266522598, 0.7021570265873177, 0.7061907581907698, 0.6977192402918488, 0.6999063383889044, 0.7393873047210726, 0.6804839116794299, 0.01843945832226923, 0.693654605974336, 0.3625746369864632, 0.1429150071708325, 0.14572061480728005, 0.1669040223778202, 0.1650943487961919, 0.12542060668661215, 0.5121957217364334, 0.15542518074173117, 0.156036654665194, 0.1306888319326719, 0.13713763666934486, 0.12103617861368943, 0.1108145728001051, 0.12162453324578815, 0.12919728860391444, 0.1126955980130615, 0.12808633789584234, 0.11894113304110199, 0.9679550449668474, 0.9564243529826745, 0.9133014768927725, 0.9633257336450122, 0.8977285481587524, 0.929892276078919, 0.9761132882135239, 0.958463961190698, 0.9589543294018381, 0.4124778439917761, 0.4730527083781343, 0.5671653412451507, 0.565167204777556, 0.5614737520556143, 0.5399222991867659, 0.5457186136901426, 0.5457495944981965, 0.5268314689769826, 0.7413671015163, 0.8255297024745667, 0.8269980313851283, 0.8369989872821036, 0.19072795984062318, 0.840737347139446, 0.7984606620491094, 0.8363220317632304, 0.8055279935856607, 0.27924917589747267, 0.41102904601041657, 0.27916291610592625, 0.2980505254269822, 0.49710121931646667, 0.3352757798725514, 0.2755841528175209, 0.5501100013290292, 0.5979823370844469, 0.1319732873521149, 0.23906062762049218, 0.40209827231780193, 0.4267323992408253, 0.614656904667398, 0.2766121881066602, 0.4872533352804431, 0.3065614738115734, 0.4291234277240342, 0.10839022439899049, 0.5078731922630757, 0.36366780123526043, 0.12214080665625404, 0.018878184924318142, 0.3445038178677531, 0.2687338183754644, 0.15477994356714897, 0.22469773971467188, 0.36480006461764003, 0.27245081466272103, 0.40256724906426256, 0.38016697047027814, 0.4363241420372871, 0.10506885447560022, 0.37374463625374177, 0.4212454507674406, 0.38020453771780116, 0.05958502560044343, 0.22757323888819603, 0.15405389472040898, 0.1873532557556007, 0.17377557194461934, 0.15528815151255637, 0.2644229984291142, 0.13924412538066444, 0.17880153647064612, 0.37154502855521465, 0.27496413408484865, 0.25583398876533825, 0.314473701267892, 0.44512880661856924, 0.3263118701853468, 0.3040356807338067, 0.29171031397446445, 0.3885001317340593, 0.5400268842874019, 0.5919720225032257, 0.7086182839981366, 0.6268007093949011, 0.5615036291580369, 0.5815978579844597, 0.595779474697816, 0.5646092839640353, 0.6192323841355178, 0.12021603762010513, 0.10368121022201926, 0.0971650076546462, 0.10482437352496998, 0.12501188329570634, 0.12573844550913615, 0.13724793191886786, 0.124233764320129, 0.14812452719788494, 0.1424059052007699, 0.2936500698222708, 0.13595797886269356, 0.11959440697224288, 0.18805815103625323, 0.14371330302243568, 0.17858383670474798, 0.11638499799371582, 0.255992601084682, 0.3554349237207006, 0.29893672502525637, 0.3838227053890573, 0.3607091035449894, 0.29859881458002113, 0.3572510404740138, 0.4890637257616598, 0.35943583942444146, 0.4294957610461716, 0.3113342149874515, 0.2758672342878027, 0.2879252715900392, 0.28207019332808136, 0.2959188658888915, 0.23357817648284596, 0.34175065356689716, 0.3159978535316039, 0.26811400852923184, 0.18038055031729017, 0.17720622512521655, 0.18180404711707454, 0.16504344252227166, 0.16791554568975575, 0.1837536158540769, 0.18078407361970972, 0.19191241070064058, 0.1771580089304965, 0.21173699611706298, 0.1919374623153911, 0.20872289179497705, 0.22858512002166587, 0.19750169698228692, 0.19971395633962286, 0.1883082925965761, 0.18039641130887163, 0.20968627947838048, 0.8381192876516217, 0.17851777178639294, 0.14605837529621257, 0.17472855108155638, 0.8201148045960038, 0.8664170897627543, 0.8172655322142724, 0.20543304551769048, 0.748646073583398, 0.10948965307966296, 0.2043142427293998, 0.6953899860341657, 0.1680238374312465, 0.20460990384735722, 0.7629695600065551, 0.2100821253676961, 0.16462040811779477, 0.19950868524414167, 0.20548808891378745, 0.19577209967689646, 0.19578156381116651, 0.18043138581810403, 0.17118315820674346, 0.16171456229871106, 0.19106826479984285, 0.1773851509459362, 0.1851955579985406, 0.08335692171457088, 0.08775217140415648, 0.08807371025056343, 0.08516656926536181, 0.06598315797509569, 0.09720927313332273, 0.07548193864528008, 0.07110494645581533, 0.0698830497544164]}, "mutation_prompt": null}
{"id": "9c057dce-35e9-48bc-a605-871121007ee0", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        # Added more diversity by including the best individual\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = np.random.choice(self.population, self.population_size, replace=False)  # Modify line\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Introduce adaptive population resizing to balance exploration and exploitation dynamically, enhancing convergence speed.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "ad0bb496-9818-4e91-9c6b-9d5e719bf2e3", "metadata": {}, "mutation_prompt": null}
{"id": "44b737e9-01d1-4713-994e-92f9a6bb77eb", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.feedback_factor = 0.1\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def dynamic_strategy_adaptation(self):\n        if np.random.rand() < 0.5:\n            self.base_F = np.clip(self.base_F + self.feedback_factor * (np.random.rand() - 0.5), 0.4, 0.9)\n        else:\n            self.base_CR = np.clip(self.base_CR + self.feedback_factor * (np.random.rand() - 0.5), 0.8, 1.0)\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 3:  # Modified the threshold\n                    self.dynamic_strategy_adaptation()\n                    self.population_size = max(15, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Dynamic Strategy Adaptation and Feedback Mechanism for Improved Convergence Speed.", "configspace": "", "generation": 73, "fitness": 0.3335677303678804, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "ad0bb496-9818-4e91-9c6b-9d5e719bf2e3", "metadata": {"aucs": [0.8374838729188038, 0.6126738784566568, 0.8704720556268387, 0.8569697759096268, 0.8101406385761831, 0.8500973282810989, 0.8644258429194912, 0.8637026015529508, 0.8507270993085265, 0.7022111770501591, 0.7008039659960503, 0.7377849844952925, 0.7332655757636848, 0.7081373575840009, 0.7345863682720741, 0.7338927459732993, 0.7511847293876792, 0.6966263274102569, 0.4247616971013002, 0.15697761617432748, 0.13459144834778258, 0.152319429705714, 0.14964386368293503, 0.1679202685066562, 0.09940985204616504, 0.1482448397896856, 0.13616155219630544, 0.17202887470457062, 0.12747105646153034, 0.11683805725964325, 0.12185561994897709, 0.1158480117105779, 0.11249690357940612, 0.129860822683613, 0.12459121844092447, 0.09610164474819827, 0.9679550449668474, 0.9538563790874964, 0.9195960303715609, 0.9633257336450122, 0.9046516107733527, 0.929892276078919, 0.9761132882135239, 0.9596192770336134, 0.9530954382871674, 0.4999418513452105, 0.35540069261269214, 0.5050229751233005, 0.5773518907768502, 0.47166586747970096, 0.3765720257308294, 0.41287304011879444, 0.4742398524263134, 0.6370986576974449, 0.8579682013882921, 0.8303398493549092, 0.8737402542394386, 0.36484673101634457, 0.1908650431574218, 0.8562078141414751, 0.23354200199245745, 0.21719446439164403, 0.23447315383005374, 0.6528311993950141, 0.5731924296552011, 0.18471695281713307, 0.14334687817326153, 0.2415288234195928, 0.19572623734810413, 0.12558049898542412, 0.17578501146009473, 0.22239447271402457, 0.016366747025218342, 0.18385511742708327, 0.21375643148348522, 0.1762296498964766, 0.3267659579719774, 0.12910852549930374, 0.42121838708353776, 0.22193651617569743, 0.27085831485378953, 0.05130248647864011, 0.218479427653835, 0.20018814833192833, 0.18784890508321372, 0.010984579461101429, 0.08987006274811515, 0.034286267390658764, 0.0827290169526328, 0.09493798596376624, 0.2327344512920323, 0.1662170717572613, 0.3399686242828257, 0.6624270675344984, 0.27645488419100195, 0.049264895589720026, 0.2393253519622981, 0.32011341499161705, 0.26112017121565245, 0.0451781829327389, 0.17399997962166402, 0.08300062327797009, 0.0877695446606811, 0.17046316958629482, 0.1259945389874454, 0.18799888780871765, 0.18980689813073037, 0.22745472663886301, 0.2563079358375233, 0.25142101724163335, 0.26259769677769007, 0.2470751856137695, 0.3330914475767155, 0.272751244915174, 0.28865354040812286, 0.32398694802694417, 0.2575282190094961, 0.5158413523434605, 0.566080671509322, 0.6236341859654355, 0.6168610458845332, 0.5537436018399124, 0.5841835698260484, 0.721135846995026, 0.5450193418849871, 0.5147282464501479, 0.12733173824613275, 0.12832391886299865, 0.10503091540556142, 0.10779675196924055, 0.08073778638579554, 0.14184846827590714, 0.103469238770172, 0.13180314515465819, 0.11499558543643651, 0.13445249341969667, 0.15364572486290073, 0.19724863766289602, 0.1783788919565159, 0.12768198286687293, 0.13525186021583635, 0.17686515980556794, 0.1724791514436005, 0.16079347100419927, 0.3582738211671491, 0.41551161562099403, 0.46048585423668487, 0.5032544715404592, 0.22206445233662908, 0.3779957861403733, 0.39671381733042277, 0.6236710755826498, 0.443659268822193, 0.2878134657433322, 0.4166643872155048, 0.3564085712889, 0.27156831938034, 0.21822946376828078, 0.29679995556446614, 0.40184292328619287, 0.38282780660241555, 0.37974476641266464, 0.18265344877623158, 0.19040113098574152, 0.1968504401264769, 0.17285069122930585, 0.18546446123256055, 0.19211650025599092, 0.20505515112659178, 0.1885258384450922, 0.1838408084933083, 0.23737319508405474, 0.2202940335696688, 0.19657570200147567, 0.23463321339697263, 0.18636391953866394, 0.17946606927855135, 0.2022123510723619, 0.19133387330173468, 0.21537503593550933, 0.17859831774903978, 0.1660161151085474, 0.1502259450635487, 0.7685179424198083, 0.6438508362847436, 0.8600566170049004, 0.3703196630119756, 0.20958107432582018, 0.16322597462948107, 0.14936701136242503, 0.1663553060790437, 0.19597334922123943, 0.16792041299184857, 0.20228877350211183, 0.8395219776410998, 0.21078451824640776, 0.15329381907328476, 0.19950788526341035, 0.18034182756731498, 0.18396477319858184, 0.17670766866874998, 0.17046413430975682, 0.16212776918111105, 0.17708363776585156, 0.20143559085152263, 0.15977060910149887, 0.1680208257231519, 0.07280480385189281, 0.08120613424564616, 0.07366757200665419, 0.07569375630122177, 0.08326688888711686, 0.07660977963179161, 0.07914617828428416, 0.07554528561300489, 0.0847992157914248]}, "mutation_prompt": null}
{"id": "61a20e39-dffd-4e83-8c9c-d43353ed3b2c", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        # Introduced a slight bias towards the midpoint of search space for added exploration\n        if np.random.rand() < 0.1:\n            mutant += 0.1 * (self.lb + self.ub) / 2\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Population Scaling and Modified Mutation for Faster Convergence.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "ad0bb496-9818-4e91-9c6b-9d5e719bf2e3", "metadata": {}, "mutation_prompt": null}
{"id": "b8dca83c-159f-4a4c-81f3-22566a788025", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.15  # Slightly increased range for diversity\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.15:  # Increased probability for using the best individual\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.1  # Slightly increased range for adaptability\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.95, self.base_F * 1.1)  # Adjusted to avoid exceeding logical bounds\n                    self.base_CR = max(0.85, self.base_CR - 0.05)  # Adjusted to avoid being too low\n                    self.population_size = max(8, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Enhanced Diversity Management and Self-Adaptive Parameters for Faster Convergence.", "configspace": "", "generation": 75, "fitness": 0.3460266302305308, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "ad0bb496-9818-4e91-9c6b-9d5e719bf2e3", "metadata": {"aucs": [0.8219773830883679, 0.8162207700539897, 0.8006682420526655, 0.8037694114201235, 0.8345048025879566, 0.7939224173065746, 0.8378130722916559, 0.8378926664456497, 0.8211149787003116, 0.6950759899053665, 0.7085704979203069, 0.6752574077524308, 0.6886821353963541, 0.6623084737873572, 0.7185242658441897, 0.6538832367796723, 0.6558721361027686, 0.710955740637695, 0.15159207921742035, 0.14856325519743663, 0.15143740836565178, 0.16484733953128416, 0.13675473268850724, 0.15864987654488483, 0.4503484236029949, 0.4752087451089019, 0.11481095858444101, 0.13732108081065175, 0.16556477307504847, 0.10994424709215089, 0.46921808216344585, 0.13300712830537087, 0.442025783495958, 0.12672778425656728, 0.15295940061507152, 0.12121610557387263, 0.963721961110994, 0.9748764324430764, 0.9418205362901148, 0.9661186257664686, 0.9464179644171867, 0.9633314411104457, 0.9891856367126938, 0.9415820856119775, 0.942024368088596, 0.5563004943549377, 0.5312378249206617, 0.5242672327768025, 0.6001022791545306, 0.5488256573327925, 0.5476479669865297, 0.5775339504761701, 0.5565313186049883, 0.5608909121696467, 0.7222242516695789, 0.7435544673867049, 0.8547336393406029, 0.6663141601828202, 0.3443054307227137, 0.7192102727425973, 0.698333393525397, 0.342438089761235, 0.3702432989370378, 0.301118955546646, 0.2769377390431076, 0.3489058174430183, 0.24370659781518844, 0.32797307407081955, 0.38976115889712504, 0.26558388250595066, 0.3160921209270111, 0.45597842492687624, 0.11788088427000643, 0.2289371968484878, 0.24834736935238422, 0.25335002394271644, 0.1308681649707587, 0.39567232895074866, 0.36453127598791424, 0.2823385585781766, 0.3748840314864115, 0.20705123281953197, 0.07955664219554415, 0.18257532590877745, 9.999999999998899e-05, 0.0694013393468631, 0.13143087129366682, 0.16686994289017187, 0.09974605814111559, 0.25351204050724174, 0.19297134906817148, 0.4837167650494052, 0.3128261588683705, 0.18461988826785913, 0.48421715800524345, 0.09885120013256854, 0.36577449953914465, 0.4103945936741409, 0.3901862169932586, 0.1039780919182085, 0.08782277574146335, 0.18403606235219505, 0.08325585087046061, 0.18345384342224258, 0.12438371941572735, 0.19078343147306953, 0.09881527583716831, 0.0718682482957187, 0.2632658706443658, 0.3330636220145896, 0.27440804453067735, 0.23352149164673242, 0.35021059872544247, 0.33540285966383976, 0.2190338802854136, 0.29664774168360153, 0.2692180722434111, 0.5743492767011602, 0.5562067475418738, 0.6314226502922671, 0.5334059869616182, 0.5081085682713771, 0.5121947962297762, 0.6371451210660406, 0.5941607288750885, 0.5601352488028803, 0.129744033609401, 0.1148081477581624, 0.14800529214486724, 0.11596684934018175, 0.13247766767712088, 0.1269963678193029, 0.0845011187715834, 0.10634876106342839, 0.08382394639164903, 0.13541574223853425, 0.18711054621238232, 0.253761247609838, 0.1268778918694441, 0.24106518652465692, 0.16588524827037365, 0.12915782077297422, 0.21028038347994227, 0.24629084876064677, 0.35654172359865166, 0.4264058550103619, 0.3863975499842166, 0.32844668066368155, 0.4094154421402454, 0.35335437052511, 0.3883405188088491, 0.4198717492613506, 0.3161022627557071, 0.3178229599942597, 0.2958103789883677, 0.30547753438656833, 0.24820859344686896, 0.1716187740300782, 0.2761557715732611, 0.2691623958808401, 0.27706166763767104, 0.2122307707301171, 0.17070978566584927, 0.18291318430565429, 0.16815368891264404, 0.17952845157436748, 0.18161148966262175, 0.18733968253964794, 0.18572942160662564, 0.19306268807457705, 0.2201382546434245, 0.5963717190269457, 0.19549416010894127, 0.22819328756422064, 0.20071528652093218, 0.21034838311351756, 0.1936000980482503, 0.22564701524294706, 0.19194944703142047, 0.22539407526311128, 0.19349033566237417, 0.18261798602581825, 0.1850345612946267, 0.190685643615084, 0.18269796699671736, 0.826199660252736, 0.7679747319983843, 0.16811306059253583, 0.19010864327565813, 0.16272392506470335, 0.20836172452286683, 0.1628647901551582, 0.43705844180404707, 0.15889186859330384, 0.5863483560978464, 0.20769532292391646, 0.111693010380717, 0.20272393548950673, 0.16568192605701348, 0.22350109882984937, 0.1726278581839863, 0.17474595874664434, 0.1697689923046395, 0.1954349167862196, 0.26020593150992066, 0.1980847753396826, 0.1768364482597553, 0.11561281355029296, 0.07695343638295327, 0.09206045388931139, 0.06916324482110381, 0.09765415981391512, 0.07772929650715754, 0.08106432588368118, 0.08209524912786181, 0.06545304174705902]}, "mutation_prompt": null}
{"id": "b6e01357-0973-45bd-aadb-1374a7e04f79", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.restart_threshold = 20  # New: Threshold for restart\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n                if stagnation_counter > self.restart_threshold:  # New: Restart mechanism\n                    self.initialize_population()\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Population Size Adjustment and Strategic Restart Mechanism for Improved Convergence.", "configspace": "", "generation": 76, "fitness": 0.37033800397821987, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "ad0bb496-9818-4e91-9c6b-9d5e719bf2e3", "metadata": {"aucs": [0.8224044803738019, 0.8179724392500335, 0.850641011628226, 0.8384028592286684, 0.7877130093216396, 0.8535132353380341, 0.838107271756281, 0.8256958754588639, 0.8041018678129037, 0.6902472266522598, 0.7021570265873177, 0.7061907581907698, 0.6977192402918488, 0.6999063383889044, 0.7393873047210726, 0.6804839116794299, 0.01843945832226923, 0.693654605974336, 0.3625746369864632, 0.1429150071708325, 0.14572061480728005, 0.1669040223778202, 0.1650943487961919, 0.12542060668661215, 0.5121957217364334, 0.15542518074173117, 0.156036654665194, 0.1306888319326719, 0.13713763666934486, 0.12103617861368943, 0.1108145728001051, 0.12162453324578815, 0.12919728860391444, 0.1126955980130615, 0.12808633789584234, 0.11894113304110199, 0.9679550449668474, 0.9564243529826745, 0.9133014768927725, 0.9633257336450122, 0.8977285481587524, 0.929892276078919, 0.9761132882135239, 0.958463961190698, 0.9589543294018381, 0.4124778439917761, 0.4730527083781343, 0.5671653412451507, 0.565167204777556, 0.5614737520556143, 0.5399222991867659, 0.5457186136901426, 0.5457495944981965, 0.5268314689769826, 0.7413671015163, 0.8255297024745667, 0.8269980313851283, 0.8369989872821036, 0.19072795984062318, 0.840737347139446, 0.7984606620491094, 0.8363220317632304, 0.8055279935856607, 0.27924917589747267, 0.41102904601041657, 0.27916291610592625, 0.2980505254269822, 0.49710121931646667, 0.3352757798725514, 0.2755841528175209, 0.5501100013290292, 0.5979823370844469, 0.1319732873521149, 0.23906062762049218, 0.40209827231780193, 0.4267323992408253, 0.614656904667398, 0.2766121881066602, 0.4872533352804431, 0.3065614738115734, 0.4291234277240342, 0.10839022439899049, 0.5078731922630757, 0.36366780123526043, 0.12214080665625404, 0.018878184924318142, 0.3445038178677531, 0.2687338183754644, 0.15477994356714897, 0.22469773971467188, 0.36480006461764003, 0.27245081466272103, 0.40256724906426256, 0.38016697047027814, 0.4363241420372871, 0.10506885447560022, 0.37374463625374177, 0.4212454507674406, 0.38020453771780116, 0.05958502560044343, 0.22757323888819603, 0.15405389472040898, 0.1873532557556007, 0.17377557194461934, 0.15528815151255637, 0.2644229984291142, 0.13924412538066444, 0.17880153647064612, 0.37154502855521465, 0.27496413408484865, 0.25583398876533825, 0.314473701267892, 0.44512880661856924, 0.3263118701853468, 0.3040356807338067, 0.29171031397446445, 0.3885001317340593, 0.5400268842874019, 0.5919720225032257, 0.7086182839981366, 0.6268007093949011, 0.5615036291580369, 0.5815978579844597, 0.595779474697816, 0.5646092839640353, 0.6192323841355178, 0.12021603762010513, 0.10368121022201926, 0.0971650076546462, 0.10482437352496998, 0.12501188329570634, 0.12573844550913615, 0.13724793191886786, 0.124233764320129, 0.14812452719788494, 0.1424059052007699, 0.2936500698222708, 0.13595797886269356, 0.11959440697224288, 0.18805815103625323, 0.14371330302243568, 0.17858383670474798, 0.11638499799371582, 0.255992601084682, 0.3554349237207006, 0.29893672502525637, 0.3838227053890573, 0.3607091035449894, 0.29859881458002113, 0.3572510404740138, 0.4890637257616598, 0.35943583942444146, 0.4294957610461716, 0.3113342149874515, 0.2758672342878027, 0.2879252715900392, 0.28207019332808136, 0.2959188658888915, 0.23357817648284596, 0.34175065356689716, 0.3159978535316039, 0.26811400852923184, 0.18038055031729017, 0.17720622512521655, 0.18180404711707454, 0.16504344252227166, 0.16791554568975575, 0.1837536158540769, 0.18078407361970972, 0.19191241070064058, 0.1771580089304965, 0.21173699611706298, 0.1919374623153911, 0.20872289179497705, 0.22858512002166587, 0.19750169698228692, 0.19971395633962286, 0.1883082925965761, 0.18039641130887163, 0.20968627947838048, 0.8381192876516217, 0.17851777178639294, 0.14605837529621257, 0.17472855108155638, 0.8201148045960038, 0.8664170897627543, 0.8172655322142724, 0.20543304551769048, 0.748646073583398, 0.10948965307966296, 0.2043142427293998, 0.6953899860341657, 0.1680238374312465, 0.20460990384735722, 0.7629695600065551, 0.2100821253676961, 0.16462040811779477, 0.19950868524414167, 0.20548808891378745, 0.19577209967689646, 0.19578156381116651, 0.18043138581810403, 0.17118315820674346, 0.16171456229871106, 0.19106826479984285, 0.1773851509459362, 0.1851955579985406, 0.08335692171457088, 0.08775217140415648, 0.08807371025056343, 0.08516656926536181, 0.06598315797509569, 0.09720927313332273, 0.07548193864528008, 0.07110494645581533, 0.0698830497544164]}, "mutation_prompt": null}
{"id": "75690779-adab-4a3c-b9bc-003029374657", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.F = 0.5\n        self.CR = 0.9\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        diversity_measure = np.std(self.population, axis=0).mean() / (self.ub - self.lb)\n        adaptive_F = self.base_F + (0.5 - diversity_measure) * 0.1\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Introduced a dynamic scaling factor for mutation based on population diversity to enhance convergence.", "configspace": "", "generation": 77, "fitness": 0.3598821748244548, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "ad0bb496-9818-4e91-9c6b-9d5e719bf2e3", "metadata": {"aucs": [0.8430690900157862, 0.8146623874364609, 0.8062975855317301, 0.808554501297255, 0.8125059530844447, 0.8359284105199989, 0.8127141813277482, 0.7878157578604869, 0.8214272573371334, 0.7028508108814502, 0.6784866048861302, 0.7031284236750124, 0.679442574273736, 0.6665521255143474, 0.6638861418843204, 0.6900242283867103, 0.6535088842153078, 0.666092733742959, 0.13804715478254748, 0.135316502021548, 0.15206979405208987, 0.31002142078904316, 0.436583704376567, 0.1551854822829395, 0.1262081625392042, 0.1592491765957852, 0.12412113249015189, 0.11674958217201348, 0.16046800360187385, 0.15695873248042158, 0.12979258437249097, 0.12845308479436368, 0.1446770192192267, 0.13638522265918074, 0.1361128837713499, 0.12661351400549048, 0.9428174046993455, 0.9673855118768061, 0.9806867885583612, 0.9836195638340086, 0.9826451318318433, 0.9235794230389434, 0.9540703997591429, 0.9766852925609374, 0.9625731593163894, 0.5320194114039419, 0.5072574221745512, 0.5612065176035697, 0.4778023909955724, 0.4664658882793582, 0.5434642992169562, 0.5185213520092462, 0.5216624588561869, 0.4408241086844692, 0.8198263422676503, 0.674900919672237, 0.606371039291991, 0.7614462570779325, 0.8098746701655959, 0.747742297238488, 0.240829413388567, 0.3774253744902064, 0.7424157992538107, 0.4412906214368335, 0.28690536087182006, 0.29722230462412547, 0.3347609109507872, 0.5374949955638196, 0.3576113487861666, 0.5686229313530506, 0.3692770680674742, 0.2698178855263941, 0.44489041487587755, 0.01627668286317152, 0.37977366980809657, 0.42753374096059205, 0.4887382327131369, 0.18765659960664316, 0.5217433653685248, 0.32524005566340675, 0.3405191229990433, 0.1887109319644401, 0.37402589712797385, 0.18837038430083552, 0.04026702127429049, 0.3904536287681143, 0.1897271763549524, 0.2968786162422523, 0.3526311022318861, 0.3409332281008097, 0.4862910058766402, 0.42376874568059786, 0.271278892140157, 0.25771272455932415, 0.2300095281878154, 0.3384579768206858, 0.4118769937774528, 0.5707689258315879, 0.3972069786340888, 0.06771325762227076, 0.09542977197543534, 0.07161908139869355, 0.14935213796780644, 0.18902364975331376, 0.11610920793459156, 0.1724660928909172, 0.14976981568587766, 0.10291573034498802, 0.27889519240100413, 0.29531166314216195, 0.2762264502146803, 0.28842481764019967, 0.2997870371067902, 0.34929119201802483, 0.3052976488436231, 0.2829675818828993, 0.3385782935871533, 0.599065316700867, 0.6010480244307721, 0.542379138433601, 0.6610511269771886, 0.5270750136432568, 0.6579939417339129, 0.5822459448520643, 0.6215034309874272, 0.607751223687779, 0.1101968632178385, 0.11578857778347151, 0.14310356357743093, 0.099520249980381, 0.12108625848544674, 0.11958554436472713, 0.1030024661331227, 0.1396143322194492, 0.12025009406475218, 0.1309552156862288, 0.11562631648927602, 0.18369187539409026, 0.48772928054888687, 0.14569761112990076, 0.18155990516010012, 0.15806805180614525, 0.1606907574724964, 0.1288548600851025, 0.3200988479306337, 0.3330248045783195, 0.27019041094193585, 0.3898260763093353, 0.3014105801077982, 0.3670462547398602, 0.3312360097326358, 0.46453430315906363, 0.40508774004648573, 0.3488789311367314, 0.27674590749946415, 0.30902784701687047, 0.2891075405505057, 0.24695015246645802, 0.28322600577316803, 0.18773200801402357, 0.27211584269254496, 0.3389282836865348, 0.20597138863860687, 0.15490518189362013, 0.18875363643440368, 0.18174446071123418, 0.197775759632006, 0.20330771687244853, 0.2255098286428614, 0.18471590878142752, 0.22838703418505624, 0.5810818413377414, 0.18510616365583055, 0.19587054460517916, 0.2272146811918171, 0.19764574643295996, 0.22130750059278603, 0.21419942974429862, 0.19878658353200984, 0.20626415221024952, 0.1759349258358397, 0.20207733090975422, 0.11372772912703966, 0.1956297744228329, 0.17947461294762035, 0.183565717122967, 0.7418360691046227, 0.18729375334915044, 0.17502540517242648, 0.20799432941338214, 0.16702885230457398, 0.1627247095698522, 0.6502520694633751, 0.15858021557765845, 0.2022804770587231, 0.723636799919779, 0.7610272075610723, 0.6997133396717499, 0.17995574213532384, 0.17805964522350426, 0.17409761904602128, 0.1680083750216641, 0.19391325146489236, 0.16939081376634113, 0.17532823396045294, 0.1827922955641914, 0.1807058597352974, 0.09016842294031535, 0.08426629863684632, 0.08604994358496876, 0.07806751297426562, 0.07232877268763971, 0.0685767932732797, 0.08195928882960868, 0.07487051507906362, 0.09135383035680822]}, "mutation_prompt": null}
{"id": "564d803b-efff-4774-9f16-832793ef3772", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        # Enhanced adaptive mutation scaling\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        # Added more diversity by including the best individual\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Mutation Scaling for Improved Convergence and Robustness.", "configspace": "", "generation": 78, "fitness": 0.3742888932748431, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "ad0bb496-9818-4e91-9c6b-9d5e719bf2e3", "metadata": {"aucs": [0.7989546754499728, 0.8307747525849595, 0.8193767473777407, 0.8383753956452222, 0.8150306854446714, 0.8321202203805944, 0.8482796157509742, 0.8144230715392538, 0.7838247958020056, 0.6682736370967821, 0.6348918005956345, 0.6017112844410717, 0.7196393751125854, 0.6894980835099871, 0.7174280065289449, 0.7196576851846401, 0.6631721490824588, 0.6954268503372225, 0.1491733653490772, 0.12582435414483406, 0.31467299794474535, 0.44426538041249486, 0.13584540409802015, 0.4392128929043253, 0.14003994227390737, 0.14528560993178274, 0.12080272834657968, 0.10806515803699601, 0.11022037996005962, 0.12663280967454515, 0.13176422052133785, 0.14508319831005556, 0.13370458242563033, 0.12764551551835024, 0.15484050321066245, 0.13238562824917577, 0.9228920490411952, 0.9002074997518321, 0.9304330405715429, 0.9266263562998738, 0.9559701696513304, 0.9613199851863646, 0.9676096185098998, 0.9770735981328983, 0.9719647049827269, 0.5271169481941107, 0.5400964770063017, 0.6002851812890604, 0.5846532347886708, 0.49266247365765425, 0.5405802186566262, 0.47445665077693133, 0.589560299718288, 0.5463145468558989, 0.8161530126364077, 0.7941538379941984, 0.7186984092000239, 0.8067906693805826, 0.7495218768167027, 0.7660140961313111, 0.8525839627481364, 0.46513051356746404, 0.8461362392333194, 0.5050599703017129, 0.13027821764514902, 0.33167183101000863, 0.2678042644302695, 0.24465706764273476, 0.5379494408089767, 0.18963368096128852, 0.2812420030090732, 0.1827790663757154, 0.12889796263576425, 0.23430544789920527, 0.2609969945319264, 0.45172003883105893, 0.3605453114832079, 0.2704823298563298, 0.3462023951887624, 0.2588907846945251, 0.3885719247597661, 0.048065691711345226, 0.07299663652911947, 0.21364460955994224, 0.21784038056842947, 0.4780542019369083, 0.05318545920469131, 0.3964262035307591, 0.3982621080859887, 0.19836215561366277, 0.1850705872396332, 0.3915686937477586, 0.43100715315613924, 0.37251191304651643, 0.0851886183785786, 0.16645318464325187, 0.4606461811824195, 0.5175533807927357, 0.5276662244027246, 0.2719689879833119, 0.23049109975141369, 0.19635765469160127, 0.14093358983212967, 0.2856073608076807, 0.3962343781379012, 0.15717621340393484, 0.18193386588646776, 0.1985517680551998, 0.27895096930561314, 0.3402732524537355, 0.34475557732861983, 0.37916615751244576, 0.3021250356993339, 0.3676780380223804, 0.29565409479114124, 0.27380093404926253, 0.3645624206571345, 0.6249576341449883, 0.709669903808101, 0.5565166223450574, 0.6793127410829309, 0.5896559181413655, 0.5815261142820036, 0.670343818194692, 0.5677420100862265, 0.6736006561174402, 0.12537193193003227, 0.10805104395670406, 0.09723170578297069, 0.10173672539280365, 0.09289426801518696, 0.12114907046297652, 0.15413101108594807, 0.0873844189955214, 0.10026417621111272, 0.18596511903082114, 0.10968492845382771, 0.3401951143772124, 0.24262258021985028, 0.18440359989539434, 0.15072665921041084, 0.13367752577897463, 0.14870813061819244, 0.14652948896778584, 0.2626642038758199, 0.4178592630349983, 0.27430527152604, 0.3560855921517949, 0.3901004077592748, 0.34799787765081935, 0.4170254762612925, 0.5257355227348055, 0.5305181196018028, 0.31964531038658295, 0.3733146507931282, 0.23508941623598711, 0.36973818226356625, 0.2789615465079931, 0.28432662484863036, 0.41838195764366193, 0.311074064574699, 0.28582196622911993, 0.1738075163333258, 0.2300268140110071, 0.17283633876535365, 0.17207455059144394, 0.17512344601408603, 0.18307633153710468, 0.21095505973454998, 0.1898758989060434, 0.21006778249217872, 0.45106068654019915, 0.22549161857073985, 0.18636654942221198, 0.18816321294153338, 0.1948848607262028, 0.21963560627058243, 0.21660875010659042, 0.20144625736708677, 0.20300206299879697, 0.8023001067287108, 0.17850446044762014, 0.175219521243822, 0.7581110448913218, 0.1825763630569437, 0.8585850435300697, 0.7978803735206536, 0.19376214694549088, 0.1573388645436964, 0.7827911230669226, 0.16449088491792951, 0.783244242392379, 0.20553030609629008, 0.20002843867486986, 0.7369325787234677, 0.19693096239055152, 0.16619058384319618, 0.20821369849823923, 0.17436935658111619, 0.1573089435856022, 0.17315051580561525, 0.18036023482850383, 0.18415149596799318, 0.17626405738785866, 0.18632517569526286, 0.18310219769410718, 0.15340107485365573, 0.0873238986469762, 0.09437537360094161, 0.09327837701889763, 0.07454241262429584, 0.0761611112566577, 0.0854471896035024, 0.07972196499983242, 0.07565127033142072, 0.08189115165207006]}, "mutation_prompt": null}
{"id": "a4111a0d-b984-448a-8a39-fb1b85fc5c4b", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n    \n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.15:  # Slightly increased probability\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced mutation diversity with a new scaling factor for improved convergence.", "configspace": "", "generation": 79, "fitness": 0.36934381765055363, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.8112327896910981, 0.8379280293779922, 0.8357671741812689, 0.8407672771164971, 0.8016227965141853, 0.8120645373100058, 0.8530502408757648, 0.8203448599281742, 0.8288406479950613, 0.6540503608112109, 0.7193421478244834, 0.6989617924903659, 0.664499472406897, 0.6726261184721686, 0.7050961789872661, 0.7070869361184309, 0.6837865820045564, 0.6922758194396907, 0.14768636562660775, 0.3199886176802924, 0.3268032003491764, 0.13073444268794587, 0.14734978010686905, 0.14188128171376357, 0.14445535339961713, 0.15566244937295048, 0.29725248262486403, 0.12952719616906083, 0.3446639743024573, 0.10506584400194152, 0.11030207420935745, 0.13098882451409777, 0.1647888519020413, 0.126102893343773, 0.12191119598202171, 0.1353654366239232, 0.9242876941148095, 0.973158961557926, 0.9318213122167754, 0.9779585459663154, 0.9711947942046071, 0.9293200626488931, 0.9891576119743796, 0.9643535274189319, 0.9314991587904369, 0.5358334323151472, 0.5659322605070496, 0.4897946398131122, 0.575214812486947, 0.5969482406230497, 0.5796404966906006, 0.5247917438282859, 0.4762341555336036, 0.6002493560372529, 0.7341949242063426, 0.7999528517118646, 0.7758627901727844, 0.7763547452888836, 0.3575398845000798, 0.8391195500497979, 0.7449520354202637, 0.7297217619419807, 0.6783514105628214, 0.4730836575600569, 0.3645147995129663, 0.40563527539416455, 0.3148218728047355, 0.34673452120195614, 0.20706538087960924, 0.3778791241257431, 0.12812809352476673, 0.3350796442356776, 0.28345415339300484, 0.40276700276474786, 0.32606057056054083, 0.46082503523013074, 0.28070086477297773, 0.29313053167024317, 0.39247838769057186, 0.40957281638700893, 0.2752089786032522, 0.3110657436988392, 0.1392628527224471, 0.31354699463228863, 0.3220518760794808, 0.27045008963474604, 0.16249641741378673, 0.4570889309494276, 0.36271047896699926, 0.325918293850608, 0.5170220020143059, 0.3169513836721548, 0.2826364184598441, 0.20399046131659682, 0.2630495774130741, 0.3223996267699929, 0.5429994584274772, 0.4385465797196074, 0.5198197467304851, 0.1359727539270923, 0.15239144077903688, 0.0968593672062803, 0.1876034564278548, 0.31032089086591574, 0.15747085562479735, 0.09666478890660579, 0.11595934800551733, 0.12657024819020957, 0.27960461252283286, 0.2953494551697178, 0.31826122981350913, 0.3026077904350438, 0.34968584422264426, 0.34855498334856505, 0.26673745167197094, 0.29751646833349255, 0.3293368016568645, 0.5982180569635583, 0.5852872968718962, 0.7041199377957017, 0.6775876802544365, 0.6143993725599624, 0.7077435891379482, 0.5867775524367818, 0.5704038315592961, 0.689566943097782, 0.1110109198200242, 0.10857132397845548, 0.11360971211342219, 0.11750878879991433, 0.1316659301817088, 0.11395578050950084, 0.11271913101245468, 0.1014719320626486, 0.14449551364751456, 0.2112451111146103, 0.13052302403812843, 0.3089453649181805, 0.19228582687078244, 0.2779004397008047, 0.1853640994586363, 0.1735883791734263, 0.13807318086578468, 0.17266055542936298, 0.36314633875869007, 0.39843737934279977, 0.34832696895992177, 0.4004255004023013, 0.35365097217605557, 0.43998455132209846, 0.43611367782727073, 0.4157521450394157, 0.43421738055846615, 0.2801798536173091, 0.2966453774847969, 0.32118252893354327, 0.19947108788127688, 0.28311823648875767, 0.23335936379143774, 0.34370877687576606, 0.30778512616780695, 0.209174275143998, 0.186730096161292, 0.17525221991085693, 0.17487239857077908, 0.1634457569176575, 0.16411228496161379, 0.19081176533448796, 0.1997934631550663, 0.19908695539685528, 0.17634595632815508, 0.5799665277258406, 0.179841816475674, 0.18110054386231744, 0.212781252012067, 0.17804310935912349, 0.5187897244337811, 0.19055546506248167, 0.21552707589984665, 0.20152629310861803, 0.1938112911752512, 0.1805467243191713, 0.16783289140697577, 0.17596625533602817, 0.18907338272276852, 0.8838342625967017, 0.7868315918126297, 0.166106945060275, 0.1644762038410026, 0.7873168812103349, 0.2102494149366032, 0.16024963572019546, 0.653893514684198, 0.1643924562150041, 0.16458037113639878, 0.2108399044397874, 0.16729286386956954, 0.19817147549830438, 0.17269070700356537, 0.16896658913109308, 0.19555597212014186, 0.18057548930051182, 0.17786318116346123, 0.1911777891438815, 0.1729491814641959, 0.17416384218458747, 0.17377120112532607, 0.07525716729845411, 0.06747766741330485, 0.09119967361817904, 0.07884109093858371, 0.0791934184809504, 0.08003562453824453, 0.07262597585216868, 0.0805998886603887, 0.07696235064929535]}, "mutation_prompt": null}
{"id": "0dc0d123-361c-4d08-b81b-d9201322e225", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * (self.dynamic_shrink_factor * 1.005))) # Slightly altered factor\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Dynamic Population Adaptation and Improved Convergence Control.", "configspace": "", "generation": 80, "fitness": 0.3742888932748431, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.7989546754499728, 0.8307747525849595, 0.8193767473777407, 0.8383753956452222, 0.8150306854446714, 0.8321202203805944, 0.8482796157509742, 0.8144230715392538, 0.7838247958020056, 0.6682736370967821, 0.6348918005956345, 0.6017112844410717, 0.7196393751125854, 0.6894980835099871, 0.7174280065289449, 0.7196576851846401, 0.6631721490824588, 0.6954268503372225, 0.1491733653490772, 0.12582435414483406, 0.31467299794474535, 0.44426538041249486, 0.13584540409802015, 0.4392128929043253, 0.14003994227390737, 0.14528560993178274, 0.12080272834657968, 0.10806515803699601, 0.11022037996005962, 0.12663280967454515, 0.13176422052133785, 0.14508319831005556, 0.13370458242563033, 0.12764551551835024, 0.15484050321066245, 0.13238562824917577, 0.9228920490411952, 0.9002074997518321, 0.9304330405715429, 0.9266263562998738, 0.9559701696513304, 0.9613199851863646, 0.9676096185098998, 0.9770735981328983, 0.9719647049827269, 0.5271169481941107, 0.5400964770063017, 0.6002851812890604, 0.5846532347886708, 0.49266247365765425, 0.5405802186566262, 0.47445665077693133, 0.589560299718288, 0.5463145468558989, 0.8161530126364077, 0.7941538379941984, 0.7186984092000239, 0.8067906693805826, 0.7495218768167027, 0.7660140961313111, 0.8525839627481364, 0.46513051356746404, 0.8461362392333194, 0.5050599703017129, 0.13027821764514902, 0.33167183101000863, 0.2678042644302695, 0.24465706764273476, 0.5379494408089767, 0.18963368096128852, 0.2812420030090732, 0.1827790663757154, 0.12889796263576425, 0.23430544789920527, 0.2609969945319264, 0.45172003883105893, 0.3605453114832079, 0.2704823298563298, 0.3462023951887624, 0.2588907846945251, 0.3885719247597661, 0.048065691711345226, 0.07299663652911947, 0.21364460955994224, 0.21784038056842947, 0.4780542019369083, 0.05318545920469131, 0.3964262035307591, 0.3982621080859887, 0.19836215561366277, 0.1850705872396332, 0.3915686937477586, 0.43100715315613924, 0.37251191304651643, 0.0851886183785786, 0.16645318464325187, 0.4606461811824195, 0.5175533807927357, 0.5276662244027246, 0.2719689879833119, 0.23049109975141369, 0.19635765469160127, 0.14093358983212967, 0.2856073608076807, 0.3962343781379012, 0.15717621340393484, 0.18193386588646776, 0.1985517680551998, 0.27895096930561314, 0.3402732524537355, 0.34475557732861983, 0.37916615751244576, 0.3021250356993339, 0.3676780380223804, 0.29565409479114124, 0.27380093404926253, 0.3645624206571345, 0.6249576341449883, 0.709669903808101, 0.5565166223450574, 0.6793127410829309, 0.5896559181413655, 0.5815261142820036, 0.670343818194692, 0.5677420100862265, 0.6736006561174402, 0.12537193193003227, 0.10805104395670406, 0.09723170578297069, 0.10173672539280365, 0.09289426801518696, 0.12114907046297652, 0.15413101108594807, 0.0873844189955214, 0.10026417621111272, 0.18596511903082114, 0.10968492845382771, 0.3401951143772124, 0.24262258021985028, 0.18440359989539434, 0.15072665921041084, 0.13367752577897463, 0.14870813061819244, 0.14652948896778584, 0.2626642038758199, 0.4178592630349983, 0.27430527152604, 0.3560855921517949, 0.3901004077592748, 0.34799787765081935, 0.4170254762612925, 0.5257355227348055, 0.5305181196018028, 0.31964531038658295, 0.3733146507931282, 0.23508941623598711, 0.36973818226356625, 0.2789615465079931, 0.28432662484863036, 0.41838195764366193, 0.311074064574699, 0.28582196622911993, 0.1738075163333258, 0.2300268140110071, 0.17283633876535365, 0.17207455059144394, 0.17512344601408603, 0.18307633153710468, 0.21095505973454998, 0.1898758989060434, 0.21006778249217872, 0.45106068654019915, 0.22549161857073985, 0.18636654942221198, 0.18816321294153338, 0.1948848607262028, 0.21963560627058243, 0.21660875010659042, 0.20144625736708677, 0.20300206299879697, 0.8023001067287108, 0.17850446044762014, 0.175219521243822, 0.7581110448913218, 0.1825763630569437, 0.8585850435300697, 0.7978803735206536, 0.19376214694549088, 0.1573388645436964, 0.7827911230669226, 0.16449088491792951, 0.783244242392379, 0.20553030609629008, 0.20002843867486986, 0.7369325787234677, 0.19693096239055152, 0.16619058384319618, 0.20821369849823923, 0.17436935658111619, 0.1573089435856022, 0.17315051580561525, 0.18036023482850383, 0.18415149596799318, 0.17626405738785866, 0.18632517569526286, 0.18310219769410718, 0.15340107485365573, 0.0873238986469762, 0.09437537360094161, 0.09327837701889763, 0.07454241262429584, 0.0761611112566577, 0.0854471896035024, 0.07972196499983242, 0.07565127033142072, 0.08189115165207006]}, "mutation_prompt": null}
{"id": "736543e8-1240-4493-acb8-67565e0a7a00", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        group_influence = self.population[r2] - self.population[r3] + 0.1 * (self.population.mean(axis=0) - self.population[idx])\n        mutant = self.population[r1] + adaptive_F * group_influence\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Adaptive Group-Based Mutation Strategy for Improved Convergence in Differential Evolution by leveraging group-based interactions.", "configspace": "", "generation": 81, "fitness": 0.37412377590966955, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.8312254485746602, 0.8203037363424812, 0.8254368640922095, 0.842449542144036, 0.8297132984993376, 0.8177992855548375, 0.8514013292052787, 0.8163889140871958, 0.7936989125496495, 0.6870186104056979, 0.5366023259841417, 0.7420404661735833, 0.6985191452123266, 0.687957104246595, 0.7326050490784402, 0.7235312376791324, 0.735511421104334, 0.7115324394397347, 0.40153723810478636, 0.12988808822008235, 0.08934732664822076, 0.1289565700071995, 0.13803045009284254, 0.24409287347674202, 0.1359513474467252, 0.13878014489716428, 0.36363479782521146, 0.1278643350990496, 0.14152611986425268, 0.11397033342123009, 0.12515748187542375, 0.1181623166571355, 0.09332082949068321, 0.12382375203559381, 0.12878375125440367, 0.1340773131098285, 0.9301826321419607, 0.9472382690457242, 0.9406861008396338, 0.9036061176494239, 0.8954100890578148, 0.8633068608264655, 0.9549607271279204, 0.908508856198144, 0.9264451049223181, 0.5161765931834013, 0.5923794778058329, 0.5327407976649545, 0.5379342368517541, 0.5542586493963668, 0.5559655308119589, 0.45193296772426617, 0.5837769375186133, 0.5114433913739802, 0.7303556818062704, 0.7675430586099958, 0.8098617193686981, 0.26908099235418137, 0.7921412328937512, 0.8501790233057497, 0.8108943506037316, 0.7766544259344006, 0.8447208066332464, 0.12818270256429531, 0.3541178392019628, 0.3773346003598068, 0.1319113020998196, 0.27916770437984273, 0.21711087248890804, 0.1288923494314882, 0.3769542250426844, 0.3295951287936498, 0.18875491912526776, 0.24320738524487073, 0.20032364481453713, 0.4512421179302638, 0.12333038537454521, 0.26971796815673654, 0.4698273460421507, 0.3075661818001675, 0.5073742656393678, 0.10310925715246899, 0.4063711953954876, 0.38933661816165954, 0.4907610668752225, 0.1809767874964926, 0.10621109002857554, 0.4623520085690068, 0.33578240749998745, 0.16849585808702927, 0.35806443782343245, 0.25285802095912846, 0.41669416928693626, 0.44184015811739186, 0.09559212593394828, 0.5547780414715053, 0.46832358781707084, 0.18188347428447127, 0.48141038877302234, 0.17193037264249855, 0.26245641229397043, 0.06779025019015172, 0.26818291411214457, 0.21214172300615475, 0.16741179412253515, 0.16798034006700469, 0.2194570538790135, 0.12853214815606573, 0.3033783705800994, 0.30089209787262383, 0.34016203810122947, 0.41375853565457077, 0.3438391104102908, 0.3062933377597705, 0.30975522190738813, 0.326505774081155, 0.34831987605925674, 0.6539953924040011, 0.7454066091941725, 0.644058205246766, 0.7098174726612846, 0.7084967489697408, 0.6692295600726437, 0.6245092394660361, 0.6118823529834798, 0.6172882646876257, 0.07753184873824326, 0.11055709339908737, 0.11174992239420567, 0.09423273233256713, 0.11124114663453033, 0.14221724160845584, 0.102578789257871, 0.12390260136859688, 0.1305361538084744, 0.14176998157653964, 0.15078833442974615, 0.148457751092274, 0.3559897356721028, 0.13313322145706186, 0.11937859209913093, 0.14385566403579908, 0.13387371615343036, 0.1652380292100767, 0.4342148341779477, 0.4002409488271582, 0.41996776347551956, 0.5164548248991425, 0.49485371812285606, 0.39805948563370297, 0.4520775219799551, 0.4758786926139895, 0.4839524151367339, 0.3128430499339676, 0.30943245904793426, 0.2561162507612512, 0.35702467535748506, 0.35950679249040973, 0.30739310382471263, 0.3528688007235292, 0.31291597627124046, 0.27509460678455366, 0.18982866202030235, 0.17219832790846268, 0.21119642624730217, 0.20729817017401808, 0.17853287775783133, 0.18180400433624244, 0.19492626165117222, 0.18026617210423135, 0.18894893717952377, 0.42731993078151087, 0.20000589577903138, 0.2793244620477745, 0.33015869273082465, 0.2309926436765758, 0.23019154009983345, 0.2094000199814865, 0.20010383348712912, 0.25950246235650287, 0.6311051420483962, 0.16104059163415274, 0.7645352503095015, 0.18059798139453564, 0.18289011353247486, 0.7899410593385756, 0.14556077906451026, 0.20935219773824543, 0.7656069729031489, 0.15285438688920372, 0.6746978865799567, 0.6882372600398252, 0.195092434204582, 0.20359160792855724, 0.1645704613529504, 0.2100376142212388, 0.6994565328799556, 0.20458623205471893, 0.1699837587210692, 0.16688543701115743, 0.17616349658285513, 0.1932243347311714, 0.17817719369423213, 0.17009339956556013, 0.17074894277507868, 0.17453764318941745, 0.2325944204745003, 0.07106984229425184, 0.08243083051240596, 0.08713505703895785, 0.08695591813906067, 0.07729014832614645, 0.08022135133534014, 0.07976683441155641, 0.0982322581648436, 0.06159474940076193]}, "mutation_prompt": null}
{"id": "3fd3f785-bc5e-444b-9bf4-58dd2e8e04d0", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.15:  # Slightly increased diversity with small probability\n            mutant = self.best_individual - self.population[r2] + adaptive_F * (self.population[r1] - self.population[r3])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Improved Diversity Control and Dynamic Mutation Strategy.", "configspace": "", "generation": 82, "fitness": 0.3278984285392101, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.8182605480015144, 0.8111537838489908, 0.8388518608644466, 0.81731469945912, 0.8046863436811418, 0.8127148724282319, 0.8415338120984364, 0.8059329660501019, 0.7856288058613912, 0.5924050321583908, 0.6697409348515042, 0.6482590726094548, 0.6590504437789916, 0.6598982944004305, 0.238067964922124, 0.6317849539510464, 0.45164558586979087, 0.6441072239755967, 0.24743178241673236, 0.15491136233785396, 0.16797615354038553, 0.14024103451197867, 0.13362570335612145, 0.1179016260619925, 0.15568047847447708, 0.13189994950530726, 0.14672566883912896, 0.15490903549176127, 0.13806297119483224, 0.10388292629728291, 0.12015676144343579, 0.12134209314735467, 0.16265660708463514, 0.1322589959966335, 0.10853779066775038, 0.1516172562377568, 0.9098561722127945, 0.7976362859995919, 0.9326952160405764, 0.9151783981789143, 0.9530982816990492, 0.8795607923136796, 0.8467493120918606, 0.9725322581358816, 0.8957668068037894, 0.13009456779847628, 0.26984390365583133, 0.5041735659070938, 0.4931908111023089, 0.3374334709916046, 0.30038130043557165, 0.45883975086239437, 0.3174764010341913, 0.2800263737699108, 0.7517247127491833, 0.8239650472633666, 0.24755512740729546, 0.20464519452788021, 0.14905190407777158, 0.8408758442297569, 0.3740670209320306, 0.8323026137177745, 0.3773570856534004, 0.32787428232245497, 0.24229761602554745, 0.22555531751061675, 0.34049967872494435, 0.12756175192554497, 0.4087742388491806, 0.19001169256268935, 0.2039172519202611, 0.16451880053309942, 0.18692106109153173, 0.47689956570394665, 0.16299596201706223, 0.23570280585426107, 0.2054975532799289, 0.1782394903193415, 0.15517580295417355, 0.13959624317876973, 0.2278536566097057, 0.013351016319653852, 0.2176315795706688, 0.11680641022481375, 0.18812449440548185, 0.19065426031385113, 0.1440995322197146, 0.15738847366923914, 0.3053599534817134, 0.3328723823305453, 0.3436880733085198, 0.1345157443161915, 0.19921015649466367, 0.15661754752725188, 0.29895357557285807, 0.13409468256277524, 0.1916616960192865, 0.3021067521393078, 0.3250791021221553, 0.09649014207671336, 0.19046509488727548, 0.2260200376451693, 0.08754333021767613, 0.18524300314391084, 0.10698343584167946, 0.14120476043151542, 0.10195334310519777, 0.15696433885777628, 0.2652358153200698, 0.18991209228865502, 0.27159106489505025, 0.3220842695581717, 0.2601242931232667, 0.38694674785221983, 0.2669978579571848, 0.17634556324660922, 0.2515965615756717, 0.6178964670955349, 0.6228210413330834, 0.6545771082989249, 0.5801697437193037, 0.5364930763940579, 0.6211256736892122, 0.6432848309404866, 0.6040182003038079, 0.6310611691673838, 0.12671198368750103, 0.10836296974698656, 0.1118817727147805, 0.08983683483845273, 0.1152711080776575, 0.11183494303881603, 0.1094395154208101, 0.1144284199500345, 0.13222024297309087, 0.18609800573349644, 0.18735957526974023, 0.16342265811273393, 0.3190956073127199, 0.16935377802855545, 0.27870567759981935, 0.21282543750708038, 0.1920171978043541, 0.12371210462760096, 0.3931268061604727, 0.3726435467892131, 0.42300924731122735, 0.4181827638711295, 0.356514147253562, 0.4174757951192315, 0.40789334647677944, 0.3804378691897037, 0.4586945729916615, 0.295592888511261, 0.30260278566678656, 0.29389245880619996, 0.2721872369289836, 0.26454995278159965, 0.3517533569923501, 0.2257247122136392, 0.37394592891465905, 0.24868330602759392, 0.21368736400122434, 0.1899070306397449, 0.18006888721006475, 0.16567328097367096, 0.1914410512500513, 0.1819231753239987, 0.18566987357138043, 0.197135329865457, 0.19444897321569832, 0.4192030124200514, 0.2055322693659858, 0.18962718821655633, 0.4545826614845603, 0.22514585210185245, 0.18771315791184806, 0.1986551908130213, 0.6024156839433239, 0.3633626471884127, 0.1864866294254458, 0.1738564908921426, 0.1382987344033476, 0.16253601462530387, 0.7265658231656751, 0.8483114473771374, 0.1706641619437702, 0.16162513548385138, 0.16886141993152448, 0.6303373308618867, 0.199008909330201, 0.8152829679811829, 0.1108469420077205, 0.7212267003449715, 0.7876029863159624, 0.16778751055139451, 0.15160425833982494, 0.39463580486095284, 0.18464743207659828, 0.1746890545276658, 0.22829928574216096, 0.1933059887944607, 0.16744189490616423, 0.19839370733968564, 0.169363150872891, 0.16048999491992033, 0.19056293400470947, 0.0795967083721173, 0.09648258303451707, 0.07948613769260571, 0.08040477423754733, 0.08173990949101495, 0.0882245148631986, 0.08127392971307656, 0.06283600261918221, 0.07341122751691032]}, "mutation_prompt": null}
{"id": "b1c4eb04-4983-4127-940a-dcff7d711f50", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        # Introduced adaptive crossover probability reduction for better exploration\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        if np.random.rand() < 0.2:\n            adaptive_CR *= 0.8\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Crossover for Improved Convergence and Robustness.", "configspace": "", "generation": 83, "fitness": 0.35819623495472264, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.8330618616876163, 0.8182818324249168, 0.8169618987972417, 0.8503978937526167, 0.8313520648238087, 0.8236938908690249, 0.8360700296377931, 0.8135262631950796, 0.8413651524467858, 0.6991473460846094, 0.6356108517317093, 0.7093514133284304, 0.6944370738817551, 0.7369781895355569, 0.6738564467388097, 0.7310361219775205, 0.6790235964161841, 0.7145128360472874, 0.4063272429495426, 0.392873962699286, 0.15594199341526704, 0.16783415815186253, 0.42407516111018606, 0.16652846904520446, 0.14723534928008397, 0.2399606876832875, 0.14350050129702707, 0.1498395493127035, 0.10543818699671559, 0.14428343331394922, 0.151505505265644, 0.10547993532961009, 0.1304213764446247, 0.4275735714297506, 0.09983547609472043, 0.13918794537131274, 0.9780925717872135, 0.9640652989557172, 0.9794513232287305, 0.9530250632911416, 0.9617416777719829, 0.9766532356506405, 0.9529596816352754, 0.9506763839181068, 0.9074146340320535, 0.5437653428452947, 0.33333352315855125, 0.5800179379620285, 0.556646990196918, 0.5274112194956928, 0.5588071878208736, 0.5102346788499846, 0.48431322111594555, 0.5610310567679923, 0.7362219691412055, 0.7484675824817599, 0.6837719963153508, 0.7958665298760181, 0.25732156945015905, 0.25698685138685884, 0.7785412683194444, 0.7388204949633779, 0.8135657236336022, 0.22691641665811757, 0.3666814442852755, 0.29670568700646904, 0.43002985878457944, 0.2539725739454842, 0.4171158543030049, 0.3144660175557399, 0.35609976371158614, 0.6024502279394444, 0.2267138254417861, 0.2636393740431825, 0.3071853533479405, 0.4089639980475772, 0.12714119824566406, 0.24441746198495484, 0.2664801519695207, 0.40245770508960543, 0.3245923008754441, 0.3587195643819219, 0.16567046130120922, 0.2111873641666011, 0.20742359438640467, 0.2507387962426306, 0.3128748564518744, 0.23696005925434593, 0.1410988158596369, 0.16474923887834425, 0.24560998576736115, 0.24449534198044076, 0.2945337762603244, 0.3970967881583929, 0.22085729421472056, 0.45409818911287503, 0.2914872008736472, 0.36087723999571497, 0.22071041400968994, 0.10069566761821169, 0.0661850403687162, 0.12588873394323186, 0.28326718698119135, 0.2521772763738852, 0.1696532727624792, 0.13459185344610392, 0.1052371453985006, 0.08383044803708495, 0.3279335980967605, 0.2735321194249192, 0.33537202992732096, 0.2809256783964267, 0.37443870744513075, 0.2813147527110623, 0.2825112392032374, 0.3296829925697926, 0.28533111264722133, 0.6008021585976888, 0.6415267435701439, 0.6763463446563942, 0.5795944256937973, 0.6548209373003708, 0.6668710536583442, 0.6113788400370019, 0.5804739663104292, 0.5581860264682619, 0.09183723693907342, 0.10510694400316045, 0.1068412972292857, 0.13887205754723708, 0.09413789441146059, 0.11333351840365613, 0.1033541557066816, 0.12028814580620106, 0.11580805476143397, 0.15674006928897288, 0.2235090358905567, 0.26398996957095655, 0.17600059743896213, 0.13465968565952047, 0.14868792011997412, 0.18014650474918148, 0.14963982103228224, 0.12906713712528128, 0.42726279842953896, 0.42578436812393305, 0.38214331740216023, 0.472333852558782, 0.43481228152277973, 0.40669934228915516, 0.41339792598059844, 0.4473450501589671, 0.4331703022785798, 0.29025025833942764, 0.3353493321096266, 0.26113605822386377, 0.28185011976531127, 0.3631994405823159, 0.28472269824206564, 0.35555974977333304, 0.29806059014603814, 0.27276648946139403, 0.1918140295202988, 0.17220716766028177, 0.17775409462630154, 0.22595617344248553, 0.1725038336375101, 0.17547497380349253, 0.2526853745776132, 0.18741869203047468, 0.17910106820315008, 0.201533611360583, 0.5466233319320007, 0.19389475165189374, 0.2334417965004525, 0.6291530648730369, 0.18610415871940622, 0.1893087117275104, 0.2276972813157867, 0.5296800980207995, 0.7507201804266405, 0.1851284146605796, 0.17228221014896627, 0.15985652860689337, 0.16369341368890744, 0.16906161779768225, 0.7605575613153897, 0.19201628259457715, 0.1688087776755568, 0.12243580940417687, 0.2087303270969434, 0.1605231896122976, 0.18951527526440692, 0.20072735362147343, 0.20233501320916825, 0.21156073865722136, 0.20664307683043948, 0.20037197087253378, 0.17400763054553114, 0.1796295677876889, 0.22376496680576008, 0.17716346343709433, 0.17187991741757302, 0.17116062649108577, 0.17123497237528607, 0.1732095587829372, 0.17485091007885478, 0.08101096153584098, 0.06910596099129529, 0.09952702945932357, 0.08437957769267235, 0.08611391316205719, 0.07051723799097398, 0.0752658593638027, 0.07512881773926705, 0.07375197360969521]}, "mutation_prompt": null}
{"id": "152c6987-48a5-4ebb-93f9-323b7714c851", "solution": "import numpy as np\n\nclass AcceleratedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(5 * dim, 30), budget // 2)  # Adjusted population size\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.9  # More aggressive shrink factor\n        self.progress_threshold = 0.001  # Reduced threshold for quicker response\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.strategy_switch_threshold = 0.25\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        dynamic_F = self.base_F + (np.random.rand() - 0.5) * 0.3  # Increased F variability\n        mutant = self.population[r1] + dynamic_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.2:  # Increased probability to use the best individual\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.1  # Broader CR adaptation\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        adapt_mutation = True\n\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 3:  # Faster response to stagnation\n                    if adapt_mutation:\n                        self.base_F = min(0.9, self.base_F * 1.2)\n                        self.base_CR = max(0.8, self.base_CR - 0.1)\n                    else:\n                        self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                        self.population = self.population[:self.population_size]\n                    adapt_mutation = not adapt_mutation\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AcceleratedHybridAdaptiveDifferentialEvolution", "description": "Accelerated Hybrid Adaptive Differential Evolution with Dynamic Strategy Selection for Enhanced Global Search Efficiency.", "configspace": "", "generation": 84, "fitness": 0.2991732689246151, "feedback": "The algorithm AcceleratedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.7048195668801189, 0.6903788744510133, 0.7089904031248279, 0.7408448526468854, 0.682768428128018, 0.7465169047322979, 0.7163296915472732, 0.6965268140919487, 0.7167069609441241, 0.5439307966452939, 0.5011906125497405, 0.5015824424632145, 0.45828781753994474, 0.4763666286667121, 0.5524364373074632, 0.489522696373618, 0.5373797903299966, 0.4507498863016093, 0.26645156312409857, 0.36149190826847877, 0.3167764629139823, 0.23012856058217557, 0.15156525338957838, 0.13226963647156553, 0.11396785718008673, 0.1271253260915759, 0.2781309770645949, 0.1117458277888147, 0.22030724308020022, 0.13103830690608398, 0.1443557204310959, 0.12995364869813053, 0.12506447196357973, 0.16036015893844302, 0.1296880353356541, 0.11218268856502311, 0.9649789432577012, 0.9652007824568851, 0.9822182094934118, 0.9749457398389897, 0.9460104213323512, 0.9560823523276131, 0.9404537281182512, 0.934047806832166, 0.9598121080466349, 0.3685059732681657, 0.3001635692207617, 0.33741633416034833, 0.3980604524450283, 0.3518167864375079, 0.3812191799190323, 0.37033462100250425, 0.3477390504829593, 0.3207877106634034, 0.5768244288722157, 0.5689421468576805, 0.63730106595606, 0.7175934383930319, 0.4516752376917149, 0.6309812551460119, 0.616782252326475, 0.5781983927948249, 0.5979761792983397, 0.22048307628091557, 0.21757965070284857, 0.2072566116395116, 0.28705854409990517, 0.24781456079865638, 0.22937485705007254, 0.16581903921749985, 0.17680512331664633, 0.22534935950166568, 0.17129404083341793, 0.15128336412599475, 0.26980185327925377, 0.2354084564678196, 0.20610463521679745, 0.2866287421560494, 0.2178598296118739, 0.19553540200733044, 0.2742628177492268, 0.17503324985669622, 0.0702854422582132, 0.06066871813250074, 0.08795846412389452, 0.10050094509153751, 0.07503097404190451, 0.13231443975499046, 0.07840718690127246, 0.08353860236398736, 0.20365743489917576, 0.19869354298405006, 0.2860292204109569, 0.18479197741765874, 0.10267875624247957, 0.08468062508561958, 0.24450154148751568, 0.19471084479338652, 0.20417137885001269, 0.03817078792969619, 0.046624671148617236, 0.04032897149426995, 0.05087392358385601, 0.07688025783849262, 0.07003195244195526, 0.09931474716906596, 0.04978333184667827, 0.18235214363729924, 0.1575248463565907, 0.1673758411329589, 0.17522084700819374, 0.16644544386346583, 0.16608112056283408, 0.16287328734392126, 0.17016070173584252, 0.14898514217914105, 0.19243832504402603, 0.5124777750455679, 0.5015944023174499, 0.5002320908142825, 0.5516101948903032, 0.5526766207847041, 0.5272886334776035, 0.5150876909993739, 0.5513444571650441, 0.5258812795415537, 0.07685178954255245, 0.08202895450665415, 0.10851272618843044, 0.11536362057441163, 0.08572357565224697, 0.08350612499537624, 0.09001178679125788, 0.06772077137001198, 0.09607954398966123, 0.14118374519590815, 0.16931636534338235, 0.3127792172714523, 0.20553952601299974, 0.13310253580366194, 0.16649798896808732, 0.1597757460169843, 0.1363540062431322, 0.21429127438792117, 0.28098373418842015, 0.31899054375725444, 0.2952801337306612, 0.2929369609245557, 0.3066023634094954, 0.3501272150271495, 0.31788635416055944, 0.3678170530585846, 0.33353599847431414, 0.21018021974766288, 0.20001268531129368, 0.1927258545194913, 0.23720039138833449, 0.19270575521070266, 0.26457821483314303, 0.1910947151505067, 0.24836237127193328, 0.2394841669454748, 0.18357218175182555, 0.16651998314907268, 0.19106435754245754, 0.16818449740854324, 0.1722148983895, 0.16659484459541707, 0.17520231151189414, 0.17755694798388555, 0.20213947639272867, 0.5300821327893541, 0.18218100005950644, 0.19491154531697896, 0.17165142126087196, 0.4752995175250456, 0.19282718287527734, 0.19831928425123702, 0.19814383782926392, 0.17916044706671197, 0.6413258027125124, 0.6387695293081053, 0.5545933820706969, 0.7050000669324408, 0.17418865394292027, 0.1792827531878105, 0.15633373305908194, 0.17497860781119812, 0.44403776681763096, 0.6347063696179323, 0.19404699345358956, 0.5275906767188201, 0.15163773032671124, 0.5796135552016652, 0.19926520984977747, 0.20353375780255445, 0.11153623838102555, 0.14309980406058054, 0.17178049054602273, 0.17869316636278743, 0.17509018824074796, 0.1656696705220445, 0.17896474435082832, 0.1790649101504892, 0.1728983935465187, 0.16620863374459427, 0.17816721806275493, 0.07437500331183255, 0.06059277716181699, 0.0818998568711049, 0.06890649278546657, 0.07141182802490553, 0.07497761211311682, 0.0622393699387348, 0.07410126896775382, 0.07503971983558821]}, "mutation_prompt": null}
{"id": "6603051d-2de9-420c-9f27-c95dc930e4c9", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                if self.population_size < self.budget // 2:\n                    self.population_size = min(self.population_size + 1, self.budget // 2)  # Adaptive population increase\n                    new_individuals = np.random.uniform(self.lb, self.ub, (1, self.dim))  # Add new individuals\n                    self.population = np.vstack((self.population, new_individuals))\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Introduce adaptive population size adjustment based on convergence to enhance exploration while maintaining exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.316739583377283, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.7401113486468984, 0.7372558016137188, 0.7422456068311851, 0.7119316915885796, 0.6950422371385341, 0.7462602705248613, 0.7706855363260149, 0.781671909743457, 0.6983926649849134, 0.4262422554306453, 0.41086103211317493, 0.40161851911271373, 0.493894903105462, 0.4431766347972579, 0.4138061698701767, 0.3619056518934758, 0.4836455370477326, 0.38498664978909247, 0.1180054901327261, 0.1349732291940723, 0.14496844795346642, 0.18935176190865, 0.17781328404358088, 0.2975183377978293, 0.1453754711389298, 0.13201723046099556, 0.2688285543002302, 0.11097042359372211, 0.13002969118763008, 0.11137483232841316, 0.13133659193457914, 0.0867479246672167, 0.11632136978805152, 0.11024113634943167, 0.15479025133426727, 0.12591461399699366, 0.9659267417438082, 0.9824556433468551, 0.9886319895165996, 0.9494913417371479, 0.9610120615351749, 0.9834145216895367, 0.9655849659001113, 0.9552984110384412, 0.9581270844359107, 0.317414622623001, 0.28006854494437616, 0.32412717419425174, 0.3667787189359215, 0.3251779567698695, 0.3194499571446048, 0.26994341496583196, 0.3222840487273978, 0.33703711906972145, 0.7065889405192374, 0.7837633381850009, 0.7723422818749478, 0.6344790130067197, 0.5967835188703055, 0.6446948524431125, 0.6824929300182139, 0.6724440119044146, 0.77839090342654, 0.25548872846950643, 0.1941711458813158, 0.22005160963831527, 0.23958270040221064, 0.16353956064038755, 0.20958016499607746, 0.22321831922136814, 0.2453441123336526, 0.29397297850579485, 0.19396310514318515, 0.15840705580974224, 0.20383816963333234, 0.22233360153438764, 0.23244359877435994, 0.24591554577024266, 0.30817097388624226, 0.33781967030349147, 0.21112789634008677, 0.1986626470415267, 0.19805272415029684, 0.17097403949385248, 0.21128957301036266, 0.1655801682357152, 0.17910500943054264, 0.17974430359691596, 0.2181152163890947, 0.2632430507704262, 0.33555212238233345, 0.30838214996408264, 0.2273102201762658, 0.36066582540175984, 0.309797242379383, 0.35181721314420833, 0.2920706794138116, 0.39032475362686136, 0.40286967162117227, 0.04268547327377359, 0.08013016397094164, 0.07119495896747141, 0.12762712526606734, 0.0936046934669228, 0.0828454751734069, 0.10467157880220512, 0.06537368244150987, 0.0530049766017513, 0.20975932272957243, 0.18869822506318856, 0.22719334760736942, 0.2075907358672503, 0.21875990618397123, 0.17304386370999203, 0.15874475935039045, 0.2031380160644658, 0.16943460806957222, 0.6065419310562192, 0.5954937450708925, 0.6159866631629753, 0.5194906012075627, 0.5411346448439585, 0.5539259908133658, 0.5973587870503363, 0.5744899016895088, 0.5956617263831274, 0.11670721757207536, 0.11582098937419272, 0.10302944272065073, 0.09149847878193362, 0.09949401621822052, 0.1279661220470285, 0.11909307355717158, 0.09000820431126777, 0.0828065601435819, 0.17713401059274014, 0.21366303462146918, 0.15379812058573405, 0.22843017683374356, 0.12103229701143015, 0.3184050551479376, 0.1317474490636532, 0.1379907738150623, 0.18122912196776264, 0.2886908850975236, 0.34396912868372187, 0.33844390207229913, 0.33072933511793645, 0.3178966056840242, 0.3049839524255097, 0.3305810514924098, 0.3983004422883939, 0.31691984953712105, 0.2509910966650677, 0.2212185250270573, 0.26383309687718826, 0.26754099157920486, 0.23854856586608575, 0.23594704953131063, 0.25225783354782416, 0.2757654464262007, 0.299988702884632, 0.19145670647625157, 0.17797629443044483, 0.1979191705155926, 0.1787918329467737, 0.17840606204148612, 0.18405479814155357, 0.19732782628518097, 0.17652293183292733, 0.17129386068775165, 0.17514610281805687, 0.19959073331824673, 0.2208853727163459, 0.1992050131415577, 0.20116375912271334, 0.18074941057135185, 0.1959218579876083, 0.2409836382665156, 0.20394491753461663, 0.1629850565795854, 0.6622922489886092, 0.15012885818616362, 0.7349492361415958, 0.6213666892014313, 0.7221605183432835, 0.5103241575794579, 0.16392558577097516, 0.16902905357145737, 0.15178576314226755, 0.16471924032668217, 0.5391770295871088, 0.20109124382036847, 0.5947026141589715, 0.7215210490971562, 0.20942729096337676, 0.15182622227845188, 0.447934447456546, 0.19421423994554965, 0.21596485763744644, 0.18448611710408536, 0.2230965340990244, 0.1904234613031177, 0.1760415579296274, 0.18501535245776035, 0.17034640899377518, 0.18784998185246704, 0.08394512614282845, 0.07946838761882047, 0.06884586547235172, 0.07494018910837019, 0.07308305210007437, 0.06963018809978527, 0.06926272458311489, 0.07665027000689972, 0.0807108732045877]}, "mutation_prompt": null}
{"id": "0b62f068-095f-421d-8d44-1e4f1afc560b", "solution": "import numpy as np\n\nclass AugmentedEnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.15:  # Slightly increased chance to leverage the best\n            mutant += 0.5 * (self.best_individual - self.population[idx])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AugmentedEnhancedHybridAdaptiveDifferentialEvolution", "description": "Augmented Enhanced Hybrid Adaptive Differential Evolution introduces guided perturbation and adaptability for improved early convergence.", "configspace": "", "generation": 86, "fitness": 0.3728019152275258, "feedback": "The algorithm AugmentedEnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.8136527469735638, 0.8312049070040257, 0.8420088687476057, 0.8409413976976384, 0.829159741830727, 0.8500398542663555, 0.8443693556001433, 0.8302802496492744, 0.8186747840991662, 0.6923038463961775, 0.7267927119876003, 0.7437392597939778, 0.7212669541736776, 0.7592235463355934, 0.7145656313338056, 0.6965141150425478, 0.698192250281304, 0.7144337778340571, 0.14618913216148044, 0.1300420477196803, 0.12822887657275694, 0.13638942776272145, 0.15803660819912912, 0.1253160935120281, 0.13570374807295027, 0.1221185863413089, 0.10470622446987687, 0.13043982019559075, 0.13213587781779457, 0.109748409498714, 0.30437107977075994, 0.30117643735919486, 0.14584762030575182, 0.14318309838792753, 0.3251137726407288, 0.10267285952917826, 0.9342357961901454, 0.9708647805521373, 0.9139283583010251, 0.9490522513990993, 0.9742605189102211, 0.9114129654846215, 0.9821836351714411, 0.9287595053213311, 0.9549443629793221, 0.6212139401796888, 0.6020027919720495, 0.5432516410251935, 0.6039660785079386, 0.5456738013645406, 0.5689279981589519, 0.5821101061342704, 0.40218678546740916, 0.4503467109226529, 0.83754848206947, 0.759101085407014, 0.8390783573461411, 0.3496634292640458, 0.21644241992803825, 0.8515587952546828, 0.857712627055735, 0.17368824984861675, 0.7379926342173824, 0.34400089946664936, 0.5139845393612731, 0.5232440850770137, 0.36629676778749465, 0.32569248434313114, 0.4961913685476881, 0.4858606517775751, 0.32739244837358417, 0.36046656432034196, 0.053088469708121755, 0.3101954501256382, 0.16628323187150762, 0.4083237526536152, 0.4496374755364847, 0.5154708262766741, 0.5313566294975178, 0.32380354118651744, 0.2202854788006845, 0.2427554742872695, 0.3614580628664509, 0.4321044894133811, 0.11595338420596579, 0.34753792413999485, 0.5158406995194258, 0.4725640560699287, 0.3930294585015466, 0.23108416822838973, 0.20734126115763396, 0.5937884100323515, 0.20842298622519828, 0.1504459606504357, 0.13498919868111936, 0.303835705596212, 0.47377985640136067, 0.401046609361874, 0.5453736867971696, 0.2887105949698977, 0.13946641518213998, 0.15881147809742013, 0.2004514326806609, 0.23491616057148268, 0.16390191471369175, 0.3093455349026989, 0.13162589155171878, 0.07915280248949108, 0.34217956126223503, 0.2553751382196646, 0.32234378783333617, 0.31369033381696665, 0.40300670759626833, 0.332236004556583, 0.22679030222090946, 0.2386244545400643, 0.18054142399187856, 0.6970909623517781, 0.6001894221341313, 0.6589966446586473, 0.6220465733565763, 0.6754482040144563, 0.6008119072013058, 0.678441679949505, 0.6532191871994257, 0.6484819624130229, 0.1308823174035013, 0.12573209077140912, 0.12528038067790925, 0.11716326574341818, 0.1000561281740514, 0.10594681172258569, 0.09544892477089473, 0.15287613707502712, 0.12172414337581827, 0.14318925468198873, 0.1540697200301292, 0.13409026016299797, 0.20965877044593406, 0.17134636771235712, 0.30712361585429804, 0.16058213089121587, 0.149055841224367, 0.2100170393427797, 0.45830795915478506, 0.39734285789948764, 0.3239544936468731, 0.42063442716051624, 0.378103327355207, 0.32406669751692074, 0.34585416661188884, 0.4932952165984871, 0.4200857621742652, 0.2614273197862734, 0.4292862691890611, 0.3292343637417944, 0.2156744078758569, 0.29078990230117974, 0.32104054087843814, 0.3235721821619496, 0.2894645002084161, 0.3102183522256252, 0.18465950241030082, 0.1667907616338078, 0.17788788583242965, 0.17019398442128364, 0.1698764772272927, 0.1819986419019246, 0.1775683607668569, 0.18265807061650396, 0.21546326518981207, 0.5049580675816978, 0.6013575992166463, 0.23271510076097124, 0.5518988581696338, 0.22589789495641266, 0.4107418933655337, 0.21274521613717456, 0.22752660149568515, 0.19730126758293887, 0.2039674590078714, 0.15111147347882747, 0.15066318436053638, 0.16538818529292543, 0.19268349579034105, 0.8547850849550056, 0.7223868374644596, 0.1301874378181106, 0.16092569605646023, 0.15157437505701932, 0.1660866344677523, 0.7958716043247598, 0.20467759025951027, 0.20680460934586886, 0.19476351515586598, 0.16187052707407001, 0.2031230225250079, 0.6535668288670269, 0.17295607450559491, 0.16951526373055625, 0.18557710247709047, 0.18036023482850383, 0.185175179474251, 0.1805421762340922, 0.16343638707717123, 0.1710445674295965, 0.18861529174235925, 0.0768093902803999, 0.08645768239153928, 0.08700128207886682, 0.07335913148247786, 0.0858016521735806, 0.07421877084528072, 0.07543733850221745, 0.06925830602929095, 0.0706605336255045]}, "mutation_prompt": null}
{"id": "5f27d39b-b0ff-4bce-bf57-e4e75d9e16cd", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        # Enhanced adaptive mutation scaling with randomization\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        # More diversity by including best individual\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.15)  # Slight increase in mutation scaling\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Introduced a dynamic adjustment of mutation scaling factor based on stagnation and randomization to boost convergence.", "configspace": "", "generation": 87, "fitness": 0.3710641747287837, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.8008724642313007, 0.8222550897717521, 0.8208303638939629, 0.8293221967100293, 0.7960632735637239, 0.8473127613991939, 0.821565558383663, 0.8189475432544786, 0.7648711649288059, 0.7036161139651391, 0.6224275710392053, 0.5958333763784844, 0.727077782202842, 0.7189296945532901, 0.732467619854734, 0.6978749461771818, 0.6491448601019899, 0.6968881549418491, 0.48596572968107754, 0.15521806369057833, 0.14276420175440052, 0.1275930410118692, 0.15755541055517897, 0.14008429832003422, 0.42291334921463064, 0.12566421316911325, 0.1155668807233704, 0.14452745093578667, 0.13354619295426984, 0.13540385653007725, 0.14145533232614305, 0.157666887783819, 0.13962051559098654, 0.36340326861388417, 0.15077162271221733, 0.135239481004638, 0.9228920490411952, 0.8931338517290415, 0.9304330405715429, 0.9266263562998738, 0.9559701696513304, 0.9613199851863646, 0.9676096185098998, 0.9770735981328983, 0.9719647049827269, 0.4763353660956552, 0.552943483017473, 0.5097316640408246, 0.5681739379391405, 0.5164907594861037, 0.5568601487345305, 0.48612623648235853, 0.5892971637421416, 0.5491771266248988, 0.8161530126364077, 0.7131269541875245, 0.7308332668080898, 0.8043229131797333, 0.2662409642857453, 0.7633358992741778, 0.8525839627481364, 0.7272046129676375, 0.8461362392333194, 0.38399899724123454, 0.13015947583589316, 0.30759086727759566, 0.31296717464969415, 0.2410817058257949, 0.5424880855731751, 0.36498660613380807, 0.3197845415885271, 0.1881563157706574, 0.2142084547840004, 0.14485343391297134, 0.28956411507720525, 0.42386691149044486, 0.2589843785018223, 0.26709988588367595, 0.30283585891569276, 0.391848205874869, 0.32438583639143403, 0.17597063475749497, 0.23458249342244064, 0.3437523090114615, 0.34040593949097087, 0.25435934120920733, 0.10502329968460689, 0.3155457006130774, 0.30182785162577164, 0.31399469187515416, 0.4337600314055202, 0.3315696311699742, 0.42448426641543857, 0.32554814390693887, 0.12469353486263646, 0.21936289087713978, 0.2954944395396899, 0.44200174804106573, 0.5492811158762302, 0.2538874577870063, 0.3308563789265042, 0.07891255611477466, 0.10600302544819784, 0.25015087287516435, 0.2706998615711269, 0.13696253446802797, 0.13245650230383998, 0.1855208319729843, 0.3063910340965258, 0.36532028946290973, 0.2946357454143844, 0.3553397063839099, 0.3522430967164272, 0.2755206710609849, 0.298558567090632, 0.2515685403170913, 0.30757969549116204, 0.6963777308923307, 0.6832947079270475, 0.637421111310581, 0.5639364514398193, 0.631391773966359, 0.5613590675800371, 0.6026837505888982, 0.5950607801634697, 0.7356691005195022, 0.1294005699487849, 0.15615876994939026, 0.12773117891854147, 0.09982177752733878, 0.10508599787307482, 0.13629676951412895, 0.08895497951097842, 0.09007566781351706, 0.13471628189388263, 0.19854619802980833, 0.21540435698581462, 0.3019682238876613, 0.185585743472371, 0.1210700995220001, 0.20552307425329774, 0.20994752461156585, 0.15692364669960024, 0.1891290708316482, 0.2637436870550458, 0.4941095025230794, 0.31954597825100206, 0.35287671833123135, 0.40996466696695266, 0.36507547887910885, 0.4246370537045697, 0.4270129142882714, 0.4748492278962043, 0.2713842283664756, 0.3187023673817251, 0.2341401587743751, 0.2974059587782131, 0.20850798342763743, 0.3186704018578572, 0.29957970556788693, 0.30791691612890904, 0.25281273333905374, 0.1676550604632977, 0.17444896506618957, 0.1764948617414449, 0.1923761725694828, 0.18442798559963225, 0.17890376571336197, 0.18403021969467392, 0.18817429272629393, 0.16999361973349236, 0.18593378650405434, 0.1985155156736491, 0.22937062707792133, 0.22579221659248183, 0.22224970394491095, 0.18901223937468525, 0.1927400062693687, 0.1896237308511901, 0.27837587642428696, 0.7401182181093313, 0.16015406973341795, 0.19114898628319898, 0.7576791177973858, 0.7483753444615857, 0.84251777677334, 0.7709049496808847, 0.21179986667388306, 0.16303218271242526, 0.7953018005674749, 0.1647559295543657, 0.7712481034971403, 0.20063653318475272, 0.20402500883894537, 0.20019888066576086, 0.21034286248586187, 0.16618619872198248, 0.20821343895946598, 0.18890146340012182, 0.17802517651513317, 0.16896132434547473, 0.19141522489850227, 0.17786637974445296, 0.17709692464823168, 0.18516749566876967, 0.17787907372872835, 0.17317751340677479, 0.07830346513657693, 0.080284605718421, 0.07876534463768603, 0.08406877225029841, 0.07449449964287247, 0.08315919629932755, 0.07559901871652541, 0.09404496961311892, 0.08093959164816078]}, "mutation_prompt": null}
{"id": "a4ffa19c-bedb-4869-895c-75cfbcbf4603", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.diversity_threshold = 0.1  # Added part for dynamic diversity management\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n\n            # Introduced adaptive diversity improvement\n            if np.std(self.population) < self.diversity_threshold:\n                self.initialize_population()  # Re-initialize to maintain diversity\n\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Population Diversity and Stagnation Resilience for Improved Convergence.", "configspace": "", "generation": 88, "fitness": 0.3742888932748431, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.7989546754499728, 0.8307747525849595, 0.8193767473777407, 0.8383753956452222, 0.8150306854446714, 0.8321202203805944, 0.8482796157509742, 0.8144230715392538, 0.7838247958020056, 0.6682736370967821, 0.6348918005956345, 0.6017112844410717, 0.7196393751125854, 0.6894980835099871, 0.7174280065289449, 0.7196576851846401, 0.6631721490824588, 0.6954268503372225, 0.1491733653490772, 0.12582435414483406, 0.31467299794474535, 0.44426538041249486, 0.13584540409802015, 0.4392128929043253, 0.14003994227390737, 0.14528560993178274, 0.12080272834657968, 0.10806515803699601, 0.11022037996005962, 0.12663280967454515, 0.13176422052133785, 0.14508319831005556, 0.13370458242563033, 0.12764551551835024, 0.15484050321066245, 0.13238562824917577, 0.9228920490411952, 0.9002074997518321, 0.9304330405715429, 0.9266263562998738, 0.9559701696513304, 0.9613199851863646, 0.9676096185098998, 0.9770735981328983, 0.9719647049827269, 0.5271169481941107, 0.5400964770063017, 0.6002851812890604, 0.5846532347886708, 0.49266247365765425, 0.5405802186566262, 0.47445665077693133, 0.589560299718288, 0.5463145468558989, 0.8161530126364077, 0.7941538379941984, 0.7186984092000239, 0.8067906693805826, 0.7495218768167027, 0.7660140961313111, 0.8525839627481364, 0.46513051356746404, 0.8461362392333194, 0.5050599703017129, 0.13027821764514902, 0.33167183101000863, 0.2678042644302695, 0.24465706764273476, 0.5379494408089767, 0.18963368096128852, 0.2812420030090732, 0.1827790663757154, 0.12889796263576425, 0.23430544789920527, 0.2609969945319264, 0.45172003883105893, 0.3605453114832079, 0.2704823298563298, 0.3462023951887624, 0.2588907846945251, 0.3885719247597661, 0.048065691711345226, 0.07299663652911947, 0.21364460955994224, 0.21784038056842947, 0.4780542019369083, 0.05318545920469131, 0.3964262035307591, 0.3982621080859887, 0.19836215561366277, 0.1850705872396332, 0.3915686937477586, 0.43100715315613924, 0.37251191304651643, 0.0851886183785786, 0.16645318464325187, 0.4606461811824195, 0.5175533807927357, 0.5276662244027246, 0.2719689879833119, 0.23049109975141369, 0.19635765469160127, 0.14093358983212967, 0.2856073608076807, 0.3962343781379012, 0.15717621340393484, 0.18193386588646776, 0.1985517680551998, 0.27895096930561314, 0.3402732524537355, 0.34475557732861983, 0.37916615751244576, 0.3021250356993339, 0.3676780380223804, 0.29565409479114124, 0.27380093404926253, 0.3645624206571345, 0.6249576341449883, 0.709669903808101, 0.5565166223450574, 0.6793127410829309, 0.5896559181413655, 0.5815261142820036, 0.670343818194692, 0.5677420100862265, 0.6736006561174402, 0.12537193193003227, 0.10805104395670406, 0.09723170578297069, 0.10173672539280365, 0.09289426801518696, 0.12114907046297652, 0.15413101108594807, 0.0873844189955214, 0.10026417621111272, 0.18596511903082114, 0.10968492845382771, 0.3401951143772124, 0.24262258021985028, 0.18440359989539434, 0.15072665921041084, 0.13367752577897463, 0.14870813061819244, 0.14652948896778584, 0.2626642038758199, 0.4178592630349983, 0.27430527152604, 0.3560855921517949, 0.3901004077592748, 0.34799787765081935, 0.4170254762612925, 0.5257355227348055, 0.5305181196018028, 0.31964531038658295, 0.3733146507931282, 0.23508941623598711, 0.36973818226356625, 0.2789615465079931, 0.28432662484863036, 0.41838195764366193, 0.311074064574699, 0.28582196622911993, 0.1738075163333258, 0.2300268140110071, 0.17283633876535365, 0.17207455059144394, 0.17512344601408603, 0.18307633153710468, 0.21095505973454998, 0.1898758989060434, 0.21006778249217872, 0.45106068654019915, 0.22549161857073985, 0.18636654942221198, 0.18816321294153338, 0.1948848607262028, 0.21963560627058243, 0.21660875010659042, 0.20144625736708677, 0.20300206299879697, 0.8023001067287108, 0.17850446044762014, 0.175219521243822, 0.7581110448913218, 0.1825763630569437, 0.8585850435300697, 0.7978803735206536, 0.19376214694549088, 0.1573388645436964, 0.7827911230669226, 0.16449088491792951, 0.783244242392379, 0.20553030609629008, 0.20002843867486986, 0.7369325787234677, 0.19693096239055152, 0.16619058384319618, 0.20821369849823923, 0.17436935658111619, 0.1573089435856022, 0.17315051580561525, 0.18036023482850383, 0.18415149596799318, 0.17626405738785866, 0.18632517569526286, 0.18310219769410718, 0.15340107485365573, 0.0873238986469762, 0.09437537360094161, 0.09327837701889763, 0.07454241262429584, 0.0761611112566577, 0.0854471896035024, 0.07972196499983242, 0.07565127033142072, 0.08189115165207006]}, "mutation_prompt": null}
{"id": "2b5c69f0-345a-4f2b-b3e2-cb55d8f2ff61", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        # Enhanced adaptive mutation scaling\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.25  # Slightly increased range for more diversity\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        # Added more diversity by including the best individual\n        if np.random.rand() < 0.15:  # Increased likelihood of using the best individual\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.06  # Slightly adjusted for fine-tuning\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Slightly enhanced diversity and convergence control by refining mutation strategy and adjusting crossover adaptivity.", "configspace": "", "generation": 89, "fitness": 0.3725812917161088, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.8066837382759375, 0.8202209078760476, 0.8255056402003823, 0.8487759519505798, 0.833465251149599, 0.8337600518204716, 0.8213809599858826, 0.792044716462028, 0.8201327319689644, 0.719091137388393, 0.6461844177772367, 0.7456165445190264, 0.7062062833326733, 0.6953252262797298, 0.6899742528586721, 0.725597272774004, 0.6912241160498236, 0.6947395265012554, 0.31510546417414553, 0.13385648960283836, 0.36639125008789264, 0.10904302968483748, 0.38558504340035293, 0.14085487864405644, 0.1369504215377596, 0.5252821893159061, 0.1359240680068331, 0.13163679506621284, 0.12812631168230348, 0.13077819876772523, 0.12958315217638905, 0.10678679544981784, 0.09828263899963507, 0.13466023436230934, 0.16412813186202235, 0.1326872199032365, 0.933311308817706, 0.9713321740774011, 0.9323092376669739, 0.968338500031378, 0.9318720966858093, 0.9401870597991252, 0.9891308532542255, 0.938192661926667, 0.9651372526023106, 0.586495909730294, 0.566469931131097, 0.572355824110123, 0.5866586646802787, 0.5219199360078207, 0.4836866802318097, 0.5707416362078799, 0.5763059657914027, 0.5040006848170797, 0.7328344000907481, 0.7466379342230891, 0.8453415997444764, 0.804030946856827, 0.7541518056606417, 0.8237871452692596, 0.30428143977868927, 0.7223629508995861, 0.7527131417212028, 0.3444567481803432, 0.40596233857576325, 0.3374325996314905, 0.3892839253205741, 0.44118027284037276, 0.4302122138981779, 0.38430919395100804, 0.1261489995841144, 0.4672135341117095, 0.38878036143196837, 0.11085577125319646, 0.22699291049370074, 0.5099227269987396, 0.4392986777094595, 0.5485952642589363, 0.37455186422385456, 0.11754353935940476, 0.6396338181851424, 0.10574416244096807, 0.3183855234586679, 0.3876081552055982, 0.21292849410669978, 0.4368266906531394, 0.15723167264936877, 0.31505425723208125, 0.023546126017144897, 0.33483696278851394, 0.18722543779336298, 0.4054406779936347, 0.3765621391510977, 0.08396176527860477, 0.40515908703955406, 0.09009695467582701, 0.44684290356027245, 0.6007093327072154, 0.4556911147414274, 0.09249643084272197, 0.13793951649525082, 0.10570128742317064, 0.0894477374749516, 0.15833599514348584, 0.24494139287149386, 0.15902353442398454, 0.11047294393479534, 0.08879217350316926, 0.40159729317522996, 0.3026335694565325, 0.2834943866383587, 0.3759467836976551, 0.3250692691222573, 0.38518399893837474, 0.32358718673562126, 0.2616507476106207, 0.35091682411803826, 0.584146630592546, 0.6139229487206002, 0.6827764408524113, 0.6563396857754725, 0.5719119404737478, 0.7093839844437905, 0.5948269722742814, 0.6541276012705636, 0.638894994246838, 0.12186222134255764, 0.10085697395456739, 0.1051868551445938, 0.12083612440244085, 0.1266393916781361, 0.11447237372872043, 0.10428798561549069, 0.118772514912171, 0.1283168547083744, 0.15773405953881825, 0.15772590973367073, 0.10780405053575981, 0.14114794526093033, 0.14073547147618715, 0.39351391975382155, 0.2680042906362935, 0.3495677898760826, 0.15993652259549485, 0.37390569499606785, 0.315103396754458, 0.41383864193752695, 0.44893759297458724, 0.37358293232867557, 0.39331319238165097, 0.44403203878608144, 0.4397379907522696, 0.3837927880408474, 0.24190217743563613, 0.29167496018553696, 0.29377991169113726, 0.3131104185331901, 0.2758317465909983, 0.3063480637991107, 0.34926093964527705, 0.30932841659364674, 0.18113340103093356, 0.16180680534564285, 0.1582406513325414, 0.16401889773804723, 0.18213811907307031, 0.1754325061502372, 0.18115383522821016, 0.17691257542576622, 0.17881403449532973, 0.1690305462763375, 0.19453019610804723, 0.20379798926300474, 0.5398178285320596, 0.22141724294333054, 0.22822536832014373, 0.22250462974770568, 0.18594485014381545, 0.22139785422450153, 0.19415421030123736, 0.19428345129461233, 0.14960905215497822, 0.1754027767289832, 0.1696032066698041, 0.7638746975188585, 0.8451765070730378, 0.7270406134335982, 0.2093267448514713, 0.17338511111852783, 0.7143958989227002, 0.16649654415523474, 0.16373386795569167, 0.20493833014399498, 0.20306590033164174, 0.7754583899590879, 0.21152816694493093, 0.16572472701078766, 0.20646667282650566, 0.17195521183539908, 0.17578690491825744, 0.18548407188568972, 0.1831060091201494, 0.17516507419373906, 0.16847818121195213, 0.19271670186851175, 0.186574101883482, 0.17091182739748767, 0.09404736932389623, 0.06790052564160065, 0.08273027250869802, 0.07634367631591354, 0.0839823079621046, 0.08209459445798606, 0.08740990956271122, 0.08442979381702276, 0.08761084821370202]}, "mutation_prompt": null}
{"id": "1690d0ec-da7b-438b-9de3-a4e6ef8b967d", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n            # Introduce dynamic parameter tuning based on remaining budget\n            if evals < self.budget * 0.5:\n                self.base_F = 0.6\n                self.base_CR = 0.85\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Improved Stagnation Recovery and Dynamic Parameter Tuning for Faster Convergence.", "configspace": "", "generation": 90, "fitness": 0.3462995651179393, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.8072160925060541, 0.8299572140882768, 0.8381756887831981, 0.840668868666218, 0.8299189724430835, 0.832021812745001, 0.840161589074652, 0.8535035653466609, 0.8072380551882506, 0.69328193853297, 0.674669829740814, 0.6727262102645581, 0.7081161047487271, 0.7160845319278061, 0.6972698175574967, 0.7184849051204338, 0.6949983408588412, 0.7083995893751365, 0.14699008809246694, 0.1305041614767113, 0.13134182814135842, 0.15817720443548244, 0.40068635411476694, 0.48318979336352197, 0.115032756275803, 0.15256510737597162, 0.47481119021371965, 0.1342222753090636, 0.13435755949981854, 0.11758356176012363, 0.11580160649682658, 0.11516785776501692, 0.12542950416332022, 0.11216514984056958, 0.2966859416743155, 0.1401071511668488, 0.9434830272983163, 0.9890726263714089, 0.9742580469769511, 0.9514361902756077, 0.9800025180743016, 0.9711669199024908, 0.95885996525356, 0.9627829451419099, 0.9776008270872353, 0.2042854115284637, 0.5562710182649306, 0.5674238213096887, 0.41966058099261017, 0.44715079700730354, 0.4779430144469041, 0.45676420553319563, 0.42469253361948645, 0.5349319176362657, 0.3515641435806307, 0.3510442237471282, 0.7960739392792304, 0.7756696770634791, 0.7522001575554668, 0.8237723428876474, 0.7802628246279535, 0.7888677320386537, 0.37153153617993406, 0.30906843683679885, 0.4014526119648324, 0.21906002564592642, 0.2787438892689337, 0.2324505197026402, 0.22832442901749073, 0.25706992833153586, 0.29032762272426194, 0.16455030354314426, 0.3149158395799896, 0.4760581237636754, 0.1986019517027573, 0.3929211626864927, 0.16946085149462264, 0.30605152115140577, 0.2659663707034112, 0.2393919345558032, 0.30339804421040395, 0.1553491352376981, 0.2384817482026379, 0.11882842345904132, 0.15871169668880425, 0.06631783675399261, 0.09400443916535783, 0.10863689924633002, 0.05206604564087791, 0.07441782814023279, 0.3388925346021725, 0.19826146073805084, 0.20639715339667153, 0.2939411608890595, 0.33800283418394383, 0.2620314365439014, 0.38568237585209875, 0.42763788780986967, 0.36267782462328013, 0.07575248166843629, 0.09354914972995243, 0.05424076056231075, 0.24993100136557755, 0.12080921246348153, 0.15631721455586745, 0.1813371914944718, 0.05784959794464939, 0.09939521894876557, 0.27525581179290626, 0.21870400759401187, 0.27395696464144625, 0.3024278501830189, 0.244213076292494, 0.354416592288615, 0.23745230722584054, 0.1703100771028172, 0.20202236295703258, 0.5616723790254509, 0.6041872976612318, 0.6023174750047895, 0.6208623129538016, 0.6193295238742786, 0.6366064298702491, 0.5708420189780019, 0.5632841458170484, 0.555276778256079, 0.10614944404302418, 0.10298516608633435, 0.11186664161566573, 0.12118516802603152, 0.11169964387463516, 0.08780428577737243, 0.1262445277713563, 0.13399327672786054, 0.09220259519339813, 0.16217967409058598, 0.1495599314157785, 0.23111037539188306, 0.19693692126764073, 0.21098145694847614, 0.1372631281060328, 0.17924453587311295, 0.13555516673774914, 0.1720857956559979, 0.5017420397194824, 0.41574167730335, 0.32307734449612047, 0.39410330272877714, 0.43836635094558585, 0.40199030715871176, 0.4049663735614343, 0.4256701507046712, 0.5430373833064783, 0.3328886524324074, 0.2717759581791598, 0.35673001853119146, 0.32489706158351506, 0.3349821172151206, 0.3569160867196871, 0.3437196898978141, 0.32731935627253017, 0.329970598492458, 0.22083743242864484, 0.17771740744249875, 0.19015827041078726, 0.17362506539500333, 0.1687108341047946, 0.19294127361493352, 0.20232561034605445, 0.19001271110688722, 0.20145416268952965, 0.21933913741037003, 0.6262578081417458, 0.2186690586011686, 0.18550483181177568, 0.20949642548661995, 0.23312385398113777, 0.1966989301717471, 0.20628675511458827, 0.2047885251933299, 0.18420572281328784, 0.18225973288418373, 0.14970180452881832, 0.17968084501721515, 0.809446076385156, 0.8463860858296337, 0.17924420611307068, 0.1471139177724563, 0.16569726509299876, 0.7362242524047069, 0.20682872250067186, 0.16262861779257398, 0.19766500441432366, 0.20403252618007905, 0.37672287247785174, 0.2064503742443743, 0.4515866022863617, 0.20989772034726462, 0.20013592934641933, 0.20838363422829054, 0.18420891234740244, 0.1738667543372121, 0.17834325881482038, 0.17290424481145006, 0.17336263908425664, 0.18919913813055722, 0.1654982611290392, 0.07895464541106323, 0.07525204297749644, 0.07020157202514365, 0.07632047008736353, 0.07252764352915853, 0.06529208379577123, 0.08916130947190504, 0.07696573045868849, 0.07250845897535618]}, "mutation_prompt": null}
{"id": "dd7d7025-1870-4321-8c88-747f4b07bbeb", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n        self.reinit_threshold = 10  # Re-initialization threshold\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def reinitialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n                if stagnation_counter > self.reinit_threshold:  # Population re-initialization\n                    self.reinitialize_population()\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Introduced trial-based population re-initialization to maintain diversity and prevent premature convergence.", "configspace": "", "generation": 91, "fitness": 0.3742888932748431, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.7989546754499728, 0.8307747525849595, 0.8193767473777407, 0.8383753956452222, 0.8150306854446714, 0.8321202203805944, 0.8482796157509742, 0.8144230715392538, 0.7838247958020056, 0.6682736370967821, 0.6348918005956345, 0.6017112844410717, 0.7196393751125854, 0.6894980835099871, 0.7174280065289449, 0.7196576851846401, 0.6631721490824588, 0.6954268503372225, 0.1491733653490772, 0.12582435414483406, 0.31467299794474535, 0.44426538041249486, 0.13584540409802015, 0.4392128929043253, 0.14003994227390737, 0.14528560993178274, 0.12080272834657968, 0.10806515803699601, 0.11022037996005962, 0.12663280967454515, 0.13176422052133785, 0.14508319831005556, 0.13370458242563033, 0.12764551551835024, 0.15484050321066245, 0.13238562824917577, 0.9228920490411952, 0.9002074997518321, 0.9304330405715429, 0.9266263562998738, 0.9559701696513304, 0.9613199851863646, 0.9676096185098998, 0.9770735981328983, 0.9719647049827269, 0.5271169481941107, 0.5400964770063017, 0.6002851812890604, 0.5846532347886708, 0.49266247365765425, 0.5405802186566262, 0.47445665077693133, 0.589560299718288, 0.5463145468558989, 0.8161530126364077, 0.7941538379941984, 0.7186984092000239, 0.8067906693805826, 0.7495218768167027, 0.7660140961313111, 0.8525839627481364, 0.46513051356746404, 0.8461362392333194, 0.5050599703017129, 0.13027821764514902, 0.33167183101000863, 0.2678042644302695, 0.24465706764273476, 0.5379494408089767, 0.18963368096128852, 0.2812420030090732, 0.1827790663757154, 0.12889796263576425, 0.23430544789920527, 0.2609969945319264, 0.45172003883105893, 0.3605453114832079, 0.2704823298563298, 0.3462023951887624, 0.2588907846945251, 0.3885719247597661, 0.048065691711345226, 0.07299663652911947, 0.21364460955994224, 0.21784038056842947, 0.4780542019369083, 0.05318545920469131, 0.3964262035307591, 0.3982621080859887, 0.19836215561366277, 0.1850705872396332, 0.3915686937477586, 0.43100715315613924, 0.37251191304651643, 0.0851886183785786, 0.16645318464325187, 0.4606461811824195, 0.5175533807927357, 0.5276662244027246, 0.2719689879833119, 0.23049109975141369, 0.19635765469160127, 0.14093358983212967, 0.2856073608076807, 0.3962343781379012, 0.15717621340393484, 0.18193386588646776, 0.1985517680551998, 0.27895096930561314, 0.3402732524537355, 0.34475557732861983, 0.37916615751244576, 0.3021250356993339, 0.3676780380223804, 0.29565409479114124, 0.27380093404926253, 0.3645624206571345, 0.6249576341449883, 0.709669903808101, 0.5565166223450574, 0.6793127410829309, 0.5896559181413655, 0.5815261142820036, 0.670343818194692, 0.5677420100862265, 0.6736006561174402, 0.12537193193003227, 0.10805104395670406, 0.09723170578297069, 0.10173672539280365, 0.09289426801518696, 0.12114907046297652, 0.15413101108594807, 0.0873844189955214, 0.10026417621111272, 0.18596511903082114, 0.10968492845382771, 0.3401951143772124, 0.24262258021985028, 0.18440359989539434, 0.15072665921041084, 0.13367752577897463, 0.14870813061819244, 0.14652948896778584, 0.2626642038758199, 0.4178592630349983, 0.27430527152604, 0.3560855921517949, 0.3901004077592748, 0.34799787765081935, 0.4170254762612925, 0.5257355227348055, 0.5305181196018028, 0.31964531038658295, 0.3733146507931282, 0.23508941623598711, 0.36973818226356625, 0.2789615465079931, 0.28432662484863036, 0.41838195764366193, 0.311074064574699, 0.28582196622911993, 0.1738075163333258, 0.2300268140110071, 0.17283633876535365, 0.17207455059144394, 0.17512344601408603, 0.18307633153710468, 0.21095505973454998, 0.1898758989060434, 0.21006778249217872, 0.45106068654019915, 0.22549161857073985, 0.18636654942221198, 0.18816321294153338, 0.1948848607262028, 0.21963560627058243, 0.21660875010659042, 0.20144625736708677, 0.20300206299879697, 0.8023001067287108, 0.17850446044762014, 0.175219521243822, 0.7581110448913218, 0.1825763630569437, 0.8585850435300697, 0.7978803735206536, 0.19376214694549088, 0.1573388645436964, 0.7827911230669226, 0.16449088491792951, 0.783244242392379, 0.20553030609629008, 0.20002843867486986, 0.7369325787234677, 0.19693096239055152, 0.16619058384319618, 0.20821369849823923, 0.17436935658111619, 0.1573089435856022, 0.17315051580561525, 0.18036023482850383, 0.18415149596799318, 0.17626405738785866, 0.18632517569526286, 0.18310219769410718, 0.15340107485365573, 0.0873238986469762, 0.09437537360094161, 0.09327837701889763, 0.07454241262429584, 0.0761611112566577, 0.0854471896035024, 0.07972196499983242, 0.07565127033142072, 0.08189115165207006]}, "mutation_prompt": null}
{"id": "5e61c4fd-196e-4824-a8fe-bbafebea8591", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        # Probability-based crossover\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        if np.random.rand() < 0.05:  # Small chance to replace with mutant for added exploration\n            trial = mutant\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Mutation Scaling and Probability-based Crossover for Optimized Convergence.", "configspace": "", "generation": 92, "fitness": 0.37642754208479495, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "564d803b-efff-4774-9f16-832793ef3772", "metadata": {"aucs": [0.8147268593028908, 0.8234559236953851, 0.8257070769398627, 0.7797950837707273, 0.8189421895234229, 0.8328848114165597, 0.8401659651642435, 0.8367687157407828, 0.8292123579338941, 0.701524081905434, 0.6037146608915922, 0.7233957668597666, 0.6694026766447196, 0.7011664284136051, 0.7097134821605646, 0.6822497805410803, 0.7102070990743664, 0.7108322715898252, 0.1663000844546073, 0.39522441387300333, 0.13406150706091957, 0.376011514039459, 0.13562946431348122, 0.38723407699552603, 0.12481467821806713, 0.10629437769845174, 0.1306404655793314, 0.1448500534883086, 0.32623334512408475, 0.1297958894582356, 0.13850729432291753, 0.09192447885885735, 0.09575387809557356, 0.13938179674361595, 0.1405947908437738, 0.1557712227671193, 0.9904237838366012, 0.9204897530457459, 0.9788503296217982, 0.8837392968512974, 0.9653487446444238, 0.9439880217897105, 0.9583695769352873, 0.9382103473354799, 0.9261433393087491, 0.5973421040465573, 0.4750259243735291, 0.5896344507467438, 0.5448310183802884, 0.5973942649489616, 0.5441540622295878, 0.4552859014499522, 0.34635413211060295, 0.6135624043403831, 0.8174865632587789, 0.8036242159560515, 0.7526573506910972, 0.21077992475317198, 0.2786925850623888, 0.22615170850863153, 0.8217367951997028, 0.8370538005152599, 0.22731807036550822, 0.40353179953206386, 0.617696869142349, 0.43992766722949195, 0.5162593015814942, 0.2768722447681451, 0.6088363893792854, 0.5583563216031688, 0.17232027398034244, 0.2985322441709922, 0.2681684001924671, 0.22864691195277154, 0.40699092522434177, 0.12668247026181556, 0.21093111928534558, 0.32651847972234016, 0.4400290797832367, 0.2501620222924664, 0.11503889366965436, 0.24644021370784897, 0.29421093686940036, 0.1955995130817737, 0.3632864023449873, 0.11000686671023963, 0.4188634529087625, 0.25866102395473534, 0.11295638344876302, 0.40086467085856325, 0.23178572184508173, 0.2534442147671766, 0.47585318045345004, 0.2750602550398936, 0.186975849940477, 0.47861161511406325, 0.30992782218515913, 0.5009379867701776, 0.10151521148583342, 0.16798613246353467, 0.3170725572281543, 0.1809884493920847, 0.2623881585628174, 0.18752501881568673, 0.17630147009933483, 0.13755746356849008, 0.09436378166486992, 0.27609131039980717, 0.2216508599185345, 0.2827128607294238, 0.28914748434580473, 0.3239961562864354, 0.25036776351386514, 0.31692374758914565, 0.26291380352218297, 0.3159352072048134, 0.2534534034329039, 0.5680228259822881, 0.7383987603327342, 0.7846981068474141, 0.7149015875387656, 0.5424428964652829, 0.5880136176840427, 0.6144013030135134, 0.7390441856848731, 0.6338100853619828, 0.1579845154042876, 0.23683114647349468, 0.15374401165454488, 0.08660291705404322, 0.11401110140494752, 0.10954711466533695, 0.06777810493158853, 0.14899869588632486, 0.09601960889243233, 0.1559132384743085, 0.2192777301983403, 0.2872824560105687, 0.1266256657669952, 0.27660041091383514, 0.12770347941783078, 0.20766990500063798, 0.1729667759919863, 0.2252887923817778, 0.45605296130877804, 0.4435204729914781, 0.3624275815758654, 0.37257401292771086, 0.37058068985498327, 0.402979513318513, 0.38963515132891935, 0.493567415772486, 0.46721334753449584, 0.2732604558645182, 0.26765345484548697, 0.33788324858216434, 0.29752092417150755, 0.3209256224759163, 0.19967114321187296, 0.31844283339831836, 0.35114828678056753, 0.3585610757656351, 0.2045668165062069, 0.20337576912326272, 0.1678365556592193, 0.17613810150046771, 0.17876268205578394, 0.1737452405809421, 0.20050448251743413, 0.20188331233407053, 0.19142021299378098, 0.6223577417155506, 0.2084042235616318, 0.21674428061958528, 0.19070111505180953, 0.5588287439834193, 0.23063326378766946, 0.2235804865989096, 0.48298503666088166, 0.1863995500073673, 0.18598246334087476, 0.8126356859887724, 0.15131597194626756, 0.14099577167501998, 0.6909079392486726, 0.15942996046492575, 0.8025068348544024, 0.16575589387429135, 0.7927224118476304, 0.6753130671656401, 0.6756180426197099, 0.7169036025255546, 0.20530988771915037, 0.6287182362308144, 0.7435502566825555, 0.16676636981556547, 0.1495779242362072, 0.2096477575156327, 0.16397093881983804, 0.18401545867984537, 0.1808735897981132, 0.16833192237469308, 0.1724447041791216, 0.1682723071980492, 0.16908592954626545, 0.1699890661654232, 0.18988794045957635, 0.0867833373349235, 0.07884135289741911, 0.08088394319897996, 0.0629723957375552, 0.08532507967468772, 0.07456294049801349, 0.07266060946253416, 0.08109660571632937, 0.07221264661488136]}, "mutation_prompt": null}
{"id": "44a5d27c-7027-4ae4-8d80-49a5446d5ff3", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        if np.random.rand() < 0.05:\n            trial = mutant\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def dynamic_restart(self):\n        # Restart mechanism to escape local optima\n        self.initialize_population()\n        self.best_value = float('inf')\n        self.best_individual = None\n\n    def adapt_strategy(self):\n        # Dynamically choose a strategy based on the current performance\n        strategy_choice = np.random.rand()\n        if strategy_choice < 0.5:\n            self.base_F = max(0.4, self.base_F * 0.9)\n        else:\n            self.base_CR = min(0.95, self.base_CR * 1.05)\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.dynamic_restart()\n                    stagnation_counter = 0\n                else:\n                    self.adapt_strategy()\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "A fine-tuned Adaptive Differential Evolution incorporating a restart mechanism and dynamic strategy selection to enhance convergence speed across varying problem landscapes.", "configspace": "", "generation": 93, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "5e61c4fd-196e-4824-a8fe-bbafebea8591", "metadata": {}, "mutation_prompt": null}
{"id": "abebce3a-6a0d-47df-92c1-d7c06e17053f", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(self.population, axis=0).mean() / (self.ub - self.lb)  # Added line\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2 * (1 + diversity_factor)  # Modified line\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        if np.random.rand() < 0.05:\n            trial = mutant\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Introduced a dynamic mutation scaling factor adjustment based on population diversity to enhance exploration during stagnation.", "configspace": "", "generation": 94, "fitness": 0.3717297037294557, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "5e61c4fd-196e-4824-a8fe-bbafebea8591", "metadata": {"aucs": [0.7938999042569701, 0.8250441320408916, 0.8254142970244445, 0.8042855253523431, 0.8280242861471641, 0.8595136317167201, 0.8221061442535811, 0.8262325774580133, 0.8330148796514931, 0.6795181866919957, 0.6930706561744242, 0.6996482277182299, 0.6822008625907487, 0.7170041823875677, 0.703390256824575, 0.748534915221275, 0.7059990891614969, 0.693312323855632, 0.1348873752102996, 0.13625608242919862, 0.14087812847558412, 0.3035397302450489, 0.5177173689605908, 0.15822677844867683, 0.1382277545953695, 0.149534505596839, 0.12032332129569401, 0.13370912528487766, 0.10702506657373179, 0.12723832530415224, 0.26633891669522725, 0.13589674919574646, 0.15132152284783074, 0.14416330142155187, 0.13237911276958403, 0.11500607317231148, 0.9904470961224661, 0.9380389425737743, 0.9456050229642966, 0.9386852167926318, 0.9522160259666186, 0.9369121504581747, 0.9586225497600276, 0.8808469495105096, 0.9641766139451455, 0.4816597619103955, 0.5325659287587884, 0.6268710048781891, 0.4814151755603131, 0.4835566243884958, 0.589796794060063, 0.44678039136865333, 0.5074071672857787, 0.5732290945030581, 0.84477826678232, 0.7639557286288494, 0.8534746773136151, 0.7891850732830867, 0.8065250460274143, 0.8772414392067024, 0.7878001941452547, 0.8022408016296567, 0.5844080278556112, 0.5694720328349796, 0.2975983060326335, 0.37183067587009655, 0.2758690478010235, 0.28947474999254275, 0.644653208343315, 0.36839810014221375, 0.24737828392134587, 0.344593897858653, 0.1253806653354954, 0.17666113935134964, 0.2449419063600301, 0.29127618955863244, 0.2261243111322293, 0.6206286142807547, 0.24828732036892276, 0.3892807673127553, 0.22045750694182886, 0.1970354692191596, 9.999999999998899e-05, 0.4096382682780214, 0.3694174668449717, 0.35290669928125173, 0.3508573778876305, 0.1254653780220184, 0.3112275432334508, 0.08237207853861295, 0.44662627876720074, 0.36538935458104704, 0.37010445785794266, 0.2190444899887355, 0.3653322018102588, 0.13560959107123505, 0.46839112217479906, 0.4627221530037584, 0.2561766930028635, 0.07095159917788019, 0.13560815743345522, 0.06973916226116539, 0.11747336001027142, 0.27405756582533436, 0.14539054252309613, 0.19369707737651765, 0.23181910783368198, 0.086735253990457, 0.27044423875922474, 0.38281736943303946, 0.30393828934280576, 0.34631578219175774, 0.35503519846671705, 0.3708036071578721, 0.29845537426066593, 0.343685559544618, 0.22426757147792697, 0.5383656211000296, 0.6652102304849299, 0.7029741412771151, 0.5444910070582702, 0.7739033372517923, 0.5647396472839445, 0.6467790158516167, 0.6157068635894154, 0.5794347614836934, 0.12358876436102895, 0.11308338813154695, 0.12521191795198705, 0.09874431761071523, 0.09208057929976143, 0.12276584999043605, 0.13046055367516962, 0.14916526384630124, 0.12676014962768056, 0.13706028854324537, 0.15250030056241626, 0.23148684107189754, 0.16904469381846443, 0.14673874344697047, 0.13038481860711093, 0.41961361228829974, 0.17688538948747723, 0.13454280542713115, 0.436363843667836, 0.4230059617525105, 0.36939495260011823, 0.35743942266621065, 0.3246181505952913, 0.4161992998720022, 0.43916565716097333, 0.4962265294861177, 0.5018428455641173, 0.30379685548273005, 0.30303687524582523, 0.24747340106006244, 0.33854245080983214, 0.269495016394536, 0.31303578385732655, 0.35847446117347825, 0.386028594331123, 0.3374872794445928, 0.19013980173330602, 0.17493852149161648, 0.18250403896240563, 0.17913786034990353, 0.18494605605293957, 0.1892938508306905, 0.20258956835537878, 0.1913656420466786, 0.17425721518668102, 0.18433962925877012, 0.21904993514627547, 0.236622685860447, 0.1870220546340139, 0.1840001361593685, 0.5936441145170444, 0.4298767610817926, 0.7194750988651245, 0.2091781072992489, 0.18335158561204812, 0.17931186081212946, 0.1519322960988304, 0.1949930831131721, 0.19104019877620626, 0.8277490382610313, 0.17071151034994314, 0.1648296102409882, 0.7984250000633609, 0.11440046945761495, 0.1676042388656993, 0.8048260467705334, 0.20633143066200377, 0.2018377665792176, 0.7474559193319494, 0.1623866403180535, 0.1507325627824332, 0.20851667525507434, 0.18199977739125828, 0.1712474833980595, 0.1761542557057033, 0.18323591531743566, 0.18974885849201606, 0.16733101168700126, 0.18075560646087707, 0.18228424311128288, 0.17736591247452105, 0.09679051730151078, 0.08829453558682077, 0.0831403009744146, 0.08250289484071471, 0.0755658310222479, 0.08990595590250994, 0.0746186753302629, 0.07537802388454407, 0.0718456644081309]}, "mutation_prompt": null}
{"id": "bedbac4d-a138-46a0-8496-d39bce9fcaff", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.learning_rate = 0.1  # New parameter for learning\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        if np.random.rand() < 0.05:\n            trial = mutant\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        improvement = max(0, func(self.population[target_idx]) - trial_value)  # Calculate improvement\n        self.base_F = min(0.9, self.base_F + self.learning_rate * improvement)  # Adjust F based on improvement\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Incorporating a learning rate to adapt mutation scaling based on historical performance for improved convergence speed.", "configspace": "", "generation": 95, "fitness": 0.23796586305886033, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "5e61c4fd-196e-4824-a8fe-bbafebea8591", "metadata": {"aucs": [0.5328916744209096, 0.5838447152145224, 0.5763856194245587, 0.5490680228799563, 0.5840017480099985, 0.6303350981627166, 0.6263537128689838, 0.6016137280498456, 0.5495116361136756, 0.3256000604144921, 0.2574845556816041, 0.24567473518876026, 0.2325570904120534, 0.3288308941326461, 0.30936854480787057, 0.26319104453666187, 0.3251507930813574, 0.43477169955005257, 0.10367065511662676, 0.08821117444576632, 0.10517197570690495, 0.11425713536321602, 0.10833281329211553, 0.11820404552375818, 0.0992282782069065, 0.11795459813731235, 0.09861354417882662, 0.08014071289725011, 0.10218288225119998, 0.08228731403128209, 0.09366524596835113, 0.0972976610105607, 0.11070624342309088, 0.09502052995931698, 0.07896307759789756, 0.09059111504240736, 0.9876089033616952, 0.9344224982356634, 0.9509787606908213, 0.8763150961186648, 0.970346612541796, 0.9517641831935573, 0.9675819425888876, 0.9026592854592359, 0.88032713124844, 0.20544904961782584, 0.2348125342437971, 0.26247071560487567, 0.253467721980398, 0.15229747714328645, 0.23392539644908217, 0.29992234109423654, 0.3751326395132424, 0.08322025785788612, 0.44612969502206523, 0.544278162684857, 0.5387583558465159, 0.24651965759959338, 0.27281791247824894, 0.5267594494310566, 0.27813176744111046, 0.4914144987595951, 0.5335750461030795, 0.17083891505677407, 0.12891768831296901, 0.1711922959073694, 0.12724121988921688, 0.1307735047128974, 0.1456853027304813, 0.14569271878074574, 0.11476556613005995, 0.14582763527800413, 0.18552474540513098, 0.12055130662032665, 0.12878297363612512, 0.15913561754314198, 0.12136413398144341, 0.1355300137265214, 0.19117947190262974, 0.3486154009664977, 0.12789757164248672, 0.05176210300527784, 0.07349295151410384, 0.08096097482519649, 0.060564106508016136, 9.999999999998899e-05, 9.999999999998899e-05, 0.10519416942773607, 0.03083707601098773, 0.13382510154289162, 0.13868313569828772, 0.24837503601636968, 0.19532213696783385, 0.1548580696877756, 0.17010654308641882, 0.13381277923442925, 0.12001377492662901, 0.25420038805350387, 0.1341025158988305, 0.04455134930036819, 0.04426970860782309, 0.030272568766492647, 0.06270753818953512, 0.08724994063297453, 0.08132411979604748, 0.07218003561468667, 0.12867565504103118, 0.0662016424355858, 0.13420440114507726, 9.999999999998899e-05, 0.14568602043023127, 0.11141728633304704, 0.15962555824198643, 0.14592674099430036, 0.11810186237608744, 0.09795410664758042, 0.1562545476722237, 0.46507281653645915, 0.13145797865880282, 0.42206664780035463, 0.4103511582481789, 0.4410255040032943, 0.43149749278026917, 0.44509753625130766, 0.5131374550916639, 0.451463450481589, 0.08302629459576127, 0.07257639188244414, 0.09049284003354874, 0.09124444866930148, 0.07717793651828875, 0.07252255822131992, 0.07449496371094921, 0.10784428925026168, 0.060354306859104145, 0.12820882387829624, 0.13930994444992506, 0.13900743641742652, 0.14825523345447078, 0.17165707415650266, 0.2602855716669431, 0.1846324107009566, 0.1398049846100624, 0.1834057900132935, 0.3079227736716058, 0.27569995651952905, 0.271571496481251, 0.29119994142196237, 0.26817592451471495, 0.2803710418250287, 0.28291319754046207, 0.28542323782335466, 0.24778430195076306, 0.21944790953563797, 0.19367105911939875, 0.18092056962208802, 0.199505771153192, 0.16938447973948345, 0.1711593156766672, 0.19144283184775135, 0.19606785385177505, 0.1642772621991755, 0.14827779316750456, 0.1674729005337391, 0.17215746507287188, 0.1435688049728, 0.16401132994061884, 0.17007513828828413, 0.17229961449634212, 0.1594511304470163, 0.15989957321021597, 0.17102652641790628, 0.1913924044709593, 0.17425963189686355, 0.18210274549969496, 0.16470339781425558, 0.22511746366088936, 0.17129085535743738, 0.15310498078478907, 0.17607078897156203, 0.16140116188514442, 0.619735308866889, 0.12277917260217075, 0.5437960469589973, 0.17468866819108098, 0.6103116015150125, 0.14751959743226017, 0.15294732295394697, 0.5808512387353737, 0.15967868127225282, 0.19062389344725783, 0.5456931981539996, 0.18316474294697205, 0.18462538190910593, 0.47961212892277727, 0.19451071788477392, 0.11430111602538673, 0.20352405547125685, 0.1649901927810128, 0.1764589355626185, 0.1862736443819425, 0.1579889230799152, 0.1778819454199182, 0.193796574151605, 0.2018865936157419, 0.13675845600463576, 0.17319390151891967, 0.05495866019825002, 0.0661948371996457, 0.05810458973298305, 0.06704742953306864, 0.058301948462286424, 0.0563595320784227, 0.05768368024610704, 0.06320093708882946, 0.06633730177974617]}, "mutation_prompt": null}
{"id": "3e40a609-54e5-4399-aeb5-bceffa67c25b", "solution": "import numpy as np\n\nclass AdaptiveQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(5 * dim, 20), budget // 2)\n        self.base_F = 0.6\n        self.base_CR = 0.8\n        self.dynamic_shrink_factor = 0.93\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.best_individual = self.population[np.random.randint(self.population_size)]\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2 = np.random.choice(indices, 2, replace=False)\n        adaptive_F = self.base_F * (1 + np.log10(1 + self.budget / (10 * self.dim)))\n        quantum_factor = np.random.normal(0, 1, self.dim)\n        mutant = self.population[r1] + adaptive_F * (self.best_individual - self.population[r2]) + quantum_factor\n        return np.clip(mutant, self.lb, self.ub)\n\n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR * (1 - np.exp(-0.1 * self.budget / self.population_size))\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n\n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.15)\n                    self.base_CR = max(0.8, self.base_CR - 0.05)\n                    self.population_size = max(15, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "AdaptiveQuantumDifferentialEvolution", "description": "Adaptive Quantum-Inspired Differential Evolution with Nonlinear Dynamic Parameter Control for Enhanced Global Exploration and Exploitation Efficiency.", "configspace": "", "generation": 96, "fitness": 0.12377588766030025, "feedback": "The algorithm AdaptiveQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "5e61c4fd-196e-4824-a8fe-bbafebea8591", "metadata": {"aucs": [0.1982515878731438, 0.20553828484607206, 0.1906126772609802, 0.2121287039297115, 0.27765229873101316, 0.22973171823017113, 0.21648881219518412, 0.1888659818431534, 0.23938916538813815, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031326600756964584, 0.04987751769791571, 0.053465157169580224, 0.05312435113293146, 0.06599099595595803, 0.0460580672429971, 0.045592898987776964, 0.06143174109771121, 0.06245770169841669, 0.07281471836574016, 0.03393278874313199, 0.035538986374152204, 0.032172779183217814, 0.04408898412564799, 0.049551676403509326, 0.03651872978431914, 0.03448734239392548, 0.03240466388782992, 0.04596553262349534, 0.9774896578250813, 0.9942449886308421, 0.9914531300918099, 0.9903300373169049, 0.9858624166413028, 0.9994341538529926, 0.9978125482103585, 0.9802829647754419, 0.9910748544568188, 0.09989597142917706, 0.07293302234003729, 0.10181367936299446, 0.0966936218532608, 0.08050838806789906, 0.11646570706379922, 0.13542996561213116, 0.07233526414635927, 0.08440534410437539, 0.13213612937001273, 0.037728704566015625, 0.08609102828721282, 0.11272812368536811, 0.15488291927704545, 0.12449332896896581, 0.12584063229617237, 0.11118748932067135, 0.13160290812450526, 0.01143944400855379, 0.005412663963107467, 0.022586677903852825, 0.012860328038880264, 0.020410816754983685, 0.027838970447320754, 0.03501480976537119, 0.04873745924925044, 0.02492646391977138, 0.03034206840193232, 0.03139507004849551, 0.02655522844794489, 0.0022960018649264002, 0.0178499127469961, 0.02148959788588778, 0.0009190975173356541, 0.0015776316609994456, 0.0011020883216140698, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021337834642659592, 0.006474917336968478, 0.029962674706769388, 0.010916331929175849, 0.010815181369586924, 0.021426579576173888, 0.02926224959282009, 0.018905155879332725, 0.04896345244587774, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012724062076838183, 0.0008428991215391202, 9.999999999998899e-05, 0.00012730071994226932, 0.00856656814692447, 9.999999999998899e-05, 0.000554778890123786, 0.0049629128847474835, 0.013863359689195387, 0.16554195003022398, 0.18120125524565944, 0.20653597728345652, 0.23175978091308658, 0.20223027486420952, 0.2146116665063722, 0.17869933819468875, 0.22787012382071836, 0.15640737287696116, 0.05030889485905121, 0.04704144117886566, 0.052545151571312454, 0.04333309982119393, 0.056004579377962216, 0.04860276007474562, 0.044360201633141694, 0.0399500352264498, 0.03473040641511993, 0.10788429766815788, 0.12139302648664363, 0.13705192803408917, 0.12624399163449962, 0.14375506257827986, 0.13397050358177098, 0.1236281938439161, 0.1224442137868198, 0.13754842188725147, 0.13741395267105327, 0.12225250728784176, 0.1654160024567276, 0.1573373498943067, 0.13425710865863572, 0.16525967168027744, 0.16797005650248942, 0.18108326716229517, 0.16009265819111385, 0.09821864979638462, 0.08067046965050917, 0.11878263914332599, 0.1128569643098295, 0.11471413389553786, 0.0959307067644688, 0.10506389767514046, 0.10475577556856386, 0.12080331147678847, 0.12473308098359526, 0.12729926666389624, 0.1407474755265291, 0.14241015758390696, 0.151503491557611, 0.14319102764964375, 0.14464035138325015, 0.14000561480526708, 0.14109775399143287, 0.1034905628318975, 0.11308690964163348, 0.07422886055517697, 0.12031497065524088, 0.11767661916179872, 0.10540314939749573, 0.09284553816829844, 0.1270136962917442, 0.058578317464032637, 0.22330361604392956, 0.15755925363623702, 0.13752274008136778, 0.13977132281757398, 0.1330797510103381, 0.1334503653209702, 0.13651078012320883, 0.13836221849016073, 0.12988256146527632, 0.15594242055620544, 0.1311965493964199, 0.12537995341955466, 0.10582051447600027, 0.1189137120053303, 0.09642736922427975, 0.1916664079874031, 0.19998043672061372, 0.19151620633391253, 0.17787546145902455, 0.19590209403609338, 0.18647577451712027, 0.1805509426883023, 0.17160057900218217, 0.18058061595214292, 0.1827183458256212, 0.1806017395486953, 0.18105278068638375, 0.04430000282997426, 0.03557513692829961, 0.0505928946835309, 0.04206175542490709, 0.06960606739685682, 0.03567136505862056, 0.047133026023634894, 0.042650426950740394, 0.05269193120470628]}, "mutation_prompt": null}
{"id": "8e9e4445-f288-4f4e-ab01-cc9bca83161c", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        if np.random.rand() < 0.05:\n            trial = mutant\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Mutation Scaling, Probability-based Crossover, and Re-initialization for Stagnation to Enhance Convergence.", "configspace": "", "generation": 97, "fitness": 0.1914704822009864, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "5e61c4fd-196e-4824-a8fe-bbafebea8591", "metadata": {"aucs": [0.39087463403699907, 0.3838327303556204, 0.38977216720473795, 0.34325417679537773, 0.4130704179982412, 0.40621870044139774, 0.4138192851093472, 0.36148449793707205, 0.31594117995748383, 0.4256753893676921, 0.29355937318622405, 0.1977648870493116, 0.31775255348636433, 0.3250544170790849, 0.3305485410936315, 0.3753121128289072, 9.999999999998899e-05, 0.3743030322604236, 0.07414374493944065, 0.09448639134895798, 0.09174847491745497, 0.07450684693363219, 0.07307062621180993, 0.057533071698644966, 0.08134122871957261, 0.06856563759557688, 0.07391144961051255, 0.06662215107805791, 0.054741316390606753, 0.06923105477586777, 0.08064895001217354, 0.062151057922306574, 0.03549341912124815, 0.033441575621263486, 0.09358604503811674, 0.07602024795734141, 0.9904237838366012, 0.9204897530457459, 0.9788503296217982, 0.8880216627894038, 0.9653487446444238, 0.9439880217897105, 0.9583695769352873, 0.9382103473354799, 0.9229375485640757, 0.29036687331512534, 0.3202699106095376, 0.1738956028008113, 0.19156361784667497, 0.24968173792949233, 0.2892041333860367, 0.2599861426929677, 0.0878893247947371, 0.23579752763679862, 0.2203016016967656, 0.14305019692090704, 0.15713644677569105, 0.1864633325705679, 0.27104533233555894, 0.2057921227630789, 0.3827571519609765, 0.2364590399607862, 0.14051233956825704, 0.2294199297410653, 0.02286263952772749, 0.09614552242960295, 0.17382564839645187, 0.028339197151713624, 0.09335124984016474, 0.09318275818114108, 0.09989965060008799, 0.0650949019115229, 0.04590408185124428, 0.18833075887074802, 0.007149558274533785, 0.0905580189343913, 0.16786261527188473, 0.029646119619432976, 0.05954101595824124, 0.12066670619375941, 0.021867625877543095, 0.09365713495254568, 9.999999999998899e-05, 0.1357605848475898, 9.999999999998899e-05, 9.999999999998899e-05, 0.12256371546040046, 9.999999999998899e-05, 0.010547993550634627, 9.999999999998899e-05, 0.06724504482669724, 0.05087856811627167, 0.049851530683269085, 0.09678780001934406, 0.0474563144293505, 0.06952167824690891, 0.06131326164068396, 0.2278086984731832, 0.08868298507121108, 9.999999999998899e-05, 0.03033565192248766, 0.16609613975016868, 0.2080680876943567, 0.09070489319964015, 0.1679013655226983, 0.027829872706071512, 0.06528528394545752, 0.14867615131841627, 0.058774785873266566, 0.21598820602163915, 0.21336101595549628, 0.11857326241487443, 0.01809341797415731, 0.248609614550929, 0.010356123135682682, 0.19038222966505625, 0.19749335539661939, 0.4143032001262539, 0.370741659627008, 0.40293320736362914, 0.31488072041070503, 0.40960958754701493, 0.36824568797650326, 0.3740482848157145, 0.3102408179828917, 0.40871098082100776, 0.08050138176855182, 0.06611682812967323, 0.06066726140563583, 0.05847770383338724, 0.06585681535787458, 0.07235763357422642, 0.07464383348531811, 0.05580401431971804, 0.06019197049811209, 0.12348530488546072, 0.12423115834970644, 0.1241214011977112, 0.12041037716667635, 0.13400913295574302, 0.12807059428101997, 0.13135993290865866, 0.1267357612251674, 0.16314771976922615, 0.2616324429263259, 0.1703176116828763, 0.17664821782325835, 0.16604865923287848, 0.2653810610295293, 0.18819138201024288, 0.1895732882999025, 0.28819155607131053, 0.2530737950389643, 0.14322058663206005, 0.14785102426632035, 0.2469841633540779, 0.18614640274783478, 0.10204002388689792, 0.16054766053623715, 0.16025174543106968, 0.12152033942250706, 0.12668683414071147, 0.1799116802895927, 0.15506773662593099, 0.15162187073188138, 0.1501644307903085, 0.18768169877494967, 0.16143782917999683, 0.16480401034662884, 0.15709269420823258, 0.17339583263349867, 0.15561861884785955, 0.17405191827618727, 0.17387192571426258, 0.1526197292278908, 0.16166152390613242, 0.16041681126276996, 0.15843953994893767, 0.15990440101765746, 0.16007055507123769, 0.1628751580448814, 0.1610480149801088, 0.1573589006770364, 0.17871969877622818, 0.13657255588659756, 0.14685159015403637, 0.13019899116028988, 0.16676647408003664, 0.14500471423220718, 0.1600886050051833, 0.16395108796362823, 0.15214007621779635, 0.2037584280493182, 0.208641121699916, 0.16793099672924927, 0.190072083347953, 0.1410265887690315, 0.20922936929684444, 0.18966708009746858, 0.17851013120222947, 0.1740547872210536, 0.21228358048701712, 0.17023661371310772, 0.17727281685313978, 0.17649324920810372, 0.17282721272867851, 0.1703315379053767, 0.06986031958817185, 0.04838828444597443, 0.04929643023046115, 0.059420184037633716, 0.06224230194259761, 0.061777276669429226, 0.053173101815819024, 0.05975390839506578, 0.05251195442767187]}, "mutation_prompt": null}
{"id": "95c61755-d6b4-4bc3-97ce-ef121c0bf927", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = min(max(4 * dim, 20), budget // 2)\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.95\n        self.progress_threshold = 0.01\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.2\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.1:\n            mutant += self.best_individual - self.population[idx]\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.05\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        if np.random.rand() < 0.05:\n            trial = mutant\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        target_value = func(self.population[target_idx])\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < target_value or np.random.rand() < 0.1:  # Introduced greedy selection\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 5:\n                    self.base_F = min(0.9, self.base_F * 1.1)\n                    self.base_CR = max(0.9, self.base_CR - 0.05)\n                    self.population_size = max(10, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                self.base_F *= 0.9  # Dynamic adjustment for exploration\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Enhanced Hybrid Adaptive Differential Evolution with Adaptive Greedy Selection and Dynamic Mutation for Improved Convergence.", "configspace": "", "generation": 98, "fitness": 0.23007840072986413, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "5e61c4fd-196e-4824-a8fe-bbafebea8591", "metadata": {"aucs": [0.6057526089667551, 0.6653608485395239, 0.780273262633175, 0.6216391745497556, 0.6289122728466803, 0.6857700030534855, 0.8326133554531499, 0.7685984064369205, 0.7668623448900023, 0.15667589893841982, 0.5065828092435994, 0.17400333625823294, 0.4220635896934032, 0.24253709447097294, 0.2923028770678453, 0.10932328856527418, 0.15761126610067022, 0.10181779329679996, 0.14245298794279293, 0.17171178273419352, 0.1380257034201059, 0.12382383198378955, 0.15040846507085948, 0.09765846764607888, 0.13744648335465648, 0.1141986211979985, 0.11066458885551422, 0.0925112801700354, 0.1271698983212617, 0.13809369093698898, 0.07108523169637915, 0.1240557000462924, 0.08876504892352932, 0.11364780401543251, 0.08819206339475294, 0.057400847955290324, 0.9639927331896486, 0.973733782277666, 0.9546125995409818, 0.9543305164129551, 0.9018838699633387, 0.9538237495598587, 0.916369391984825, 0.8920404068658019, 0.9686641910924099, 0.12984579415629183, 0.09725206806911324, 0.133970861008049, 0.16518262397763028, 0.08408814345606219, 0.23576879937897832, 0.11308810994607155, 0.1337737783438161, 0.1696670517332194, 0.21041624878782772, 0.2371416635219472, 0.2512902790457824, 0.19195671584601326, 0.201858095826856, 0.20302724345842393, 0.23398084576741474, 0.3715827544665461, 0.2648850420595791, 0.19847082384996761, 0.12325057362337866, 0.1312077022196514, 0.12533732933028552, 0.16531297984425242, 0.12235872695633554, 0.1407959942457241, 0.15650703698568047, 0.13090879355608687, 0.21377274861177398, 0.12748083987075753, 0.14275994450109353, 0.09339054015907533, 0.14529739921423734, 0.2511062585793806, 0.1800718224413469, 0.10423756389086669, 0.11804160455137602, 0.06199300393352147, 0.004974421196691892, 9.999999999998899e-05, 0.12277389164260988, 0.08519927437567731, 9.999999999998899e-05, 0.061818256864085375, 0.00795068058834425, 0.008446425732752005, 0.11389324144261825, 0.1898471227123626, 0.03316280684047557, 0.0845256486154925, 0.03921282501730927, 0.020391052981360014, 0.11833025634835737, 0.11670903581799341, 0.12505035962119637, 0.1452189797615716, 0.10334582177561569, 0.046113631239334096, 0.10760122898639568, 0.16501195778359745, 9.999999999998899e-05, 0.0021899048554825384, 0.2662554062911596, 9.999999999998899e-05, 0.07221361892740386, 0.0502068281293887, 0.16358593359680962, 0.06705976148069115, 0.06460580036799057, 0.034231349374640896, 0.08943874192413892, 0.07049439984148698, 0.11447118270172674, 0.4680610132966948, 0.5810277421672381, 0.5066233924508488, 0.5243225726206504, 0.6070335159132203, 0.46662986626575476, 0.38678895042177364, 0.4258351161646504, 0.47003516803831125, 0.135568603652662, 0.107397677919426, 0.1349106005099373, 0.13257712521850995, 0.13559444024733824, 0.08823356398507787, 0.09640195160686837, 0.11162364877127506, 0.11924999398311831, 0.13357581746123637, 0.16559490561155366, 0.17142296455590478, 0.1606576209236098, 0.13496423707116334, 0.15588950591394823, 0.18012960288890012, 0.17652749546103463, 0.19272195907007839, 0.21467912601900174, 0.31291889450559907, 0.32396070372706387, 0.3019061836574465, 0.3641327525211978, 0.21729668553690484, 0.20502942784646694, 0.28194478809727697, 0.22940597586973732, 0.19523468187017845, 0.1590919631808171, 0.21755408255783537, 0.21963573497583944, 0.20563113572274883, 0.13276874364379687, 0.132069897250079, 0.30592481280191264, 0.19649121676679937, 0.1792943885211764, 0.20766729275960605, 0.17139328478233673, 0.2585320295125796, 0.19298732657380402, 0.1909849103436715, 0.2045646056354049, 0.1852820064093167, 0.20904271854283263, 0.19929296924025908, 0.19121952053533553, 0.23811802631177492, 0.23417904361332664, 0.18615694493360957, 0.18523480511408053, 0.18274525124637164, 0.4322271808315099, 0.17142999130022651, 0.16459152954929235, 0.20776405338368453, 0.1469408025022816, 0.16945352422148785, 0.1858716755547669, 0.7400798686414237, 0.15643775282425376, 0.1641913442083116, 0.16048496797966672, 0.42319374235438467, 0.23995402709756275, 0.18777961846410463, 0.20140771560856396, 0.5146562432562811, 0.16663815527736714, 0.12627457594458957, 0.2112199719726343, 0.20391804028259508, 0.17986939779621935, 0.1795566581323792, 0.19898631568322123, 0.1823732240133441, 0.19035948273807968, 0.17443507811975867, 0.18819197201434568, 0.17261675596374448, 0.21715301401797082, 0.08010315461815842, 0.07874521638154297, 0.06562157321729922, 0.09553905669719664, 0.07547889105561079, 0.07635460934584748, 0.07714557583004622, 0.0746153986847019, 0.07223179766194843]}, "mutation_prompt": null}
{"id": "6911eefb-f6c2-41ec-87fc-564d0c162d36", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.initial_population_size = min(max(4 * dim, 20), budget // 2)\n        self.population_size = self.initial_population_size\n        self.base_F = 0.5\n        self.base_CR = 0.9\n        self.dynamic_shrink_factor = 0.9\n        self.progress_threshold = 0.01\n        self.adaptive_learning_rate = 0.1\n        self.population = None\n        self.best_individual = None\n        self.best_value = float('inf')\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        r1, r2, r3 = np.random.choice(indices, 3, replace=False)\n        adaptive_F = self.base_F + (np.random.rand() - 0.5) * 0.3\n        mutant = self.population[r1] + adaptive_F * (self.population[r2] - self.population[r3])\n        if np.random.rand() < 0.2:\n            random_individual = self.population[np.random.choice(indices)]\n            mutant += self.adaptive_learning_rate * (random_individual - self.population[idx])\n        return np.clip(mutant, self.lb, self.ub)\n    \n    def crossover(self, target, mutant):\n        adaptive_CR = self.base_CR + (np.random.rand() - 0.5) * 0.1\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def select(self, target_idx, trial, func):\n        trial_value = func(trial)\n        if trial_value < self.best_value:\n            self.best_value = trial_value\n            self.best_individual = trial\n        if trial_value < func(self.population[target_idx]):\n            self.population[target_idx] = trial\n    \n    def __call__(self, func):\n        self.initialize_population()\n        evals = 0\n        stagnation_counter = 0\n        prev_best_value = self.best_value\n        while evals < self.budget:\n            for idx in range(self.population_size):\n                if evals >= self.budget:\n                    break\n                target = self.population[idx]\n                mutant = self.mutate(idx)\n                trial = self.crossover(target, mutant)\n                self.select(idx, trial, func)\n                evals += 1\n\n            if self.best_value >= prev_best_value - self.progress_threshold:\n                stagnation_counter += 1\n                if stagnation_counter > 4:\n                    self.base_F = min(0.9, self.base_F * 1.2)\n                    self.base_CR = max(0.7, self.base_CR - 0.1)\n                    self.population_size = max(5, int(self.population_size * self.dynamic_shrink_factor))\n                    self.population = self.population[:self.population_size]\n                    stagnation_counter = 0\n            else:\n                stagnation_counter = 0\n            prev_best_value = self.best_value\n\n        return self.best_individual, self.best_value", "name": "EnhancedHybridAdaptiveDifferentialEvolution", "description": "Introducing a hybrid mutation strategy with adaptive population resizing and learning-based crossover to accelerate convergence.", "configspace": "", "generation": 99, "fitness": 0.30834151663496456, "feedback": "The algorithm EnhancedHybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "5e61c4fd-196e-4824-a8fe-bbafebea8591", "metadata": {"aucs": [0.8586958104545056, 0.8740494812591262, 0.8526508480340804, 0.8353366820371959, 0.8620220386341824, 0.18938438074093566, 0.843464070844641, 0.8758443971048925, 0.8363037647239095, 0.7287728613403527, 0.7349249385549209, 0.729135621503631, 0.6756251287866832, 0.7131622142907186, 0.6352914266892269, 0.7196285287269384, 0.7600660596276565, 0.508775366528885, 0.14182686086785457, 0.13389926286143872, 0.11997098301796372, 0.16812425750590387, 0.14462590244496953, 0.7172665269783054, 0.2285812932125001, 0.13253955925578398, 0.17628502328574847, 0.14347133139039747, 0.1374041493588789, 0.12414860705024533, 0.16616673287778172, 0.14668098804040308, 0.1497644955748243, 0.17163818523339525, 0.24387732297997455, 0.12710894641232995, 0.8420742785881699, 0.8452901751637408, 0.9252767236503123, 0.9073019198074894, 0.9412038084655374, 0.9277197878476003, 0.9217994049211349, 0.9267062551149429, 0.9058541869571825, 0.36343598639536256, 0.4198344246540614, 0.33724152326091095, 0.5137224873925772, 0.31069578793403074, 0.5201943618504783, 0.4444316935412016, 0.49597150088538766, 0.3547629333509106, 0.35859577600175896, 0.21467535188105524, 0.8107702859460325, 0.3576374369288765, 0.7884091540362355, 0.26922881918014274, 0.3199834936259325, 0.3138273386433048, 0.7675106022593026, 0.39712140510594185, 0.167986995401592, 0.2899459679899683, 0.1408342773390019, 0.17203067806414385, 0.3035402129666621, 0.13017913361777633, 0.17503684445560608, 0.17425458081842538, 0.022131789805853286, 0.1624218384876136, 0.15750462165566026, 0.3140408379263825, 0.15564213868153742, 0.21917698903925797, 0.168414486404329, 0.19842406492886733, 0.15284895654564257, 0.07717903032200701, 9.999999999998899e-05, 9.999999999998899e-05, 0.06144587719849315, 0.14600821328983782, 0.05376117161487126, 0.018441480134658406, 0.05903932603899886, 0.015303681002050706, 0.15761054747839331, 0.07798988314231448, 0.09666643138677478, 0.2571371817126017, 0.1931165216001448, 0.00550958394803891, 0.16885359889420337, 0.2094925968648118, 0.24284981069748335, 0.1732579736624229, 0.11877086647475865, 0.1739246060487114, 0.08729971138286241, 0.19780754753299556, 0.07683925096146127, 0.07477790241848492, 0.188883883142542, 0.09450048086051788, 0.17646028738407582, 0.19345100341438992, 0.20413985538124757, 0.08609607100611483, 0.13014410174048263, 0.19380702121073057, 0.17448255566298898, 0.08902966329755324, 0.16245402585202462, 0.5269432912967966, 0.5572405962330722, 0.5367948301200367, 0.496376370882346, 0.5541155397974952, 0.5003585080611908, 0.6824892733952163, 0.5534222239229915, 0.5118071976101487, 0.11049460072744022, 0.1044878476383927, 0.11103997515994801, 0.106245575273623, 0.08173500854362314, 0.13111355765449317, 0.12232668982236194, 0.11406211594828564, 0.11949232744470828, 0.15861794121212147, 0.15204734070457326, 0.13635577773332463, 0.1727257652191081, 0.141885773914751, 0.2283173548216194, 0.159699544859926, 0.1897918118492009, 0.28814245819646456, 0.4634505723206427, 0.4138298692867346, 0.34737246836215385, 0.29040310077326015, 0.37098475199205094, 0.36788815562926525, 0.3894535819026861, 0.4270124705877323, 0.41655741405364277, 0.2270680733877135, 0.33870443822976737, 0.25153449332558, 0.23488675949426052, 0.3030529575710996, 0.19061703663270924, 0.19211045462523813, 0.2501762146127938, 0.29196746478944047, 0.2217677588688265, 0.18322499479956078, 0.19491043842461153, 0.1684075047231216, 0.20056151654972076, 0.19740835875647877, 0.187474427329271, 0.1785998085219549, 0.1954074985650388, 0.1964635044324211, 0.711873142328133, 0.2305220557234624, 0.21673804407202535, 0.23676295081068144, 0.19823325672916636, 0.21235403896721017, 0.6210490231186683, 0.6328085091531009, 0.8527306786029081, 0.16057635709524876, 0.16322217999278887, 0.16845050664813466, 0.19545864748299413, 0.8080374338876158, 0.17929298520964765, 0.15371479865062498, 0.17677300942633667, 0.6163933321732928, 0.16825078006939387, 0.14955897615815283, 0.19828585567406354, 0.19964983764296496, 0.5541668956303567, 0.20902050370811887, 0.2052634042504199, 0.12350922732394776, 0.1727341809534979, 0.1753968923504362, 0.17769073900086663, 0.18622997373607375, 0.18907611822328985, 0.18186290074935074, 0.1860943091465469, 0.20969456706840084, 0.1872861268211733, 0.07722212497273084, 0.09102571206211596, 0.06378235291258227, 0.07469456635258864, 0.0798279669715184, 0.08555719653135296, 0.06985731372560966, 0.07849342963979289, 0.08418219630474955]}, "mutation_prompt": null}
