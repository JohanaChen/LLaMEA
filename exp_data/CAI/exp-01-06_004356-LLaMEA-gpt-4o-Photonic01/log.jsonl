{"id": "3a418a44-243d-4856-8b03-fff7a3e99d38", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.7  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * r2 * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.4, self.inertia - 0.001)  # Decrease inertia over time\n\n        return global_best_position", "name": "HybridPSODE", "description": "A hybrid swarm-evolution approach combining Particle Swarm Optimization (PSO) and Differential Evolution (DE) to explore and exploit the search space efficiently using adaptive strategies within a fixed evaluation budget.", "configspace": "", "generation": 0, "fitness": 0.06024826129227127, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.058142083013799084, 0.06292890886256697, 0.059673792000447756]}, "mutation_prompt": null}
{"id": "41fb766f-d625-4bcb-a0e2-75a3ecf73eff", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.7  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * r2 * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.4, 0.8 - 0.4 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved inertia adaptation by incorporating a nonlinear decrease to enhance convergence speed and exploration balance.", "configspace": "", "generation": 1, "fitness": 0.0620246110037489, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "3a418a44-243d-4856-8b03-fff7a3e99d38", "metadata": {"aucs": [0.06278903471902808, 0.06182587173163656, 0.06145892656058205]}, "mutation_prompt": null}
{"id": "8ef55687-d9a6-4719-8ab2-46300062113c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * r2 * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.4, 0.8 - 0.4 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced the DE strategy by slightly increasing the crossover probability for improved exploration.", "configspace": "", "generation": 2, "fitness": 0.062156838463284715, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "41fb766f-d625-4bcb-a0e2-75a3ecf73eff", "metadata": {"aucs": [0.061015524103305796, 0.06388109268018505, 0.06157389860636331]}, "mutation_prompt": null}
{"id": "272e7df1-8c83-4bd9-846c-04a451bbf95e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * r2 * (global_best_position - positions[i]))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Fine-tuned PSO components by adjusting inertia weight decay for improved convergence rate.", "configspace": "", "generation": 3, "fitness": 0.062168883872349014, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "8ef55687-d9a6-4719-8ab2-46300062113c", "metadata": {"aucs": [0.06115309247816847, 0.06355964091134614, 0.06179391822753244]}, "mutation_prompt": null}
{"id": "8ad7b825-03b0-431b-8185-009a464db2d4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * r2 * (global_best_position - positions[i]))\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced nonlinear adaptive velocity clamping to enhance stability in particle movements.", "configspace": "", "generation": 4, "fitness": 0.06249522362725498, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "272e7df1-8c83-4bd9-846c-04a451bbf95e", "metadata": {"aucs": [0.06321488958200372, 0.06169759038871647, 0.06257319091104474]}, "mutation_prompt": null}
{"id": "7b68c6a9-efab-4436-9e30-613d9a226140", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.5 * np.sin(np.pi * self.evaluations / self.budget)) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a nonlinear adaptation to the social component to enhance exploration.", "configspace": "", "generation": 5, "fitness": 0.06296916270290746, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "8ad7b825-03b0-431b-8185-009a464db2d4", "metadata": {"aucs": [0.06176610681623007, 0.062225704160140505, 0.0649156771323518]}, "mutation_prompt": null}
{"id": "ab9f09bc-633d-4c3a-b3f0-094084278446", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget)) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced exploration by modifying the nonlinear adaptation factor in the social component of the velocity update.", "configspace": "", "generation": 6, "fitness": 0.06305791554022304, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "7b68c6a9-efab-4436-9e30-613d9a226140", "metadata": {"aucs": [0.06192523881244805, 0.062235007137980136, 0.06501350067024092]}, "mutation_prompt": null}
{"id": "6a14b5cf-5393-470e-9b24-9201da140a2e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * (1 + 0.3 * np.sin(np.pi * self.evaluations / self.budget)) * r1 * (personal_best_positions[i] - positions[i]) +  # Change made here\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget)) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved the velocity update by adding a dynamic factor to the cognitive component for enhanced convergence speed.", "configspace": "", "generation": 7, "fitness": 0.06229286737372516, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ab9f09bc-633d-4c3a-b3f0-094084278446", "metadata": {"aucs": [0.06166868165450867, 0.06173437353202449, 0.0634755469346423]}, "mutation_prompt": null}
{"id": "391162f9-2c8e-4047-809b-8a5adc817c21", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.7  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget)) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Fine-tune the cognitive component to improve convergence speed while maintaining diversity.", "configspace": "", "generation": 8, "fitness": 0.0617732542058087, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ab9f09bc-633d-4c3a-b3f0-094084278446", "metadata": {"aucs": [0.06146619882161952, 0.06103682779354391, 0.06281673600226267]}, "mutation_prompt": null}
{"id": "05977556-965f-4bfc-af7b-be38506a6ad8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.5  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget)) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced exploration by modifying the nonlinear adaptation factor in the social component of the velocity update.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "ab9f09bc-633d-4c3a-b3f0-094084278446", "metadata": {"aucs": [0.06192523881244805, 0.062235007137980136, 0.06501350067024092]}, "mutation_prompt": null}
{"id": "bbc80212-cd01-48ec-9fec-df1d248faf5c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget)) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced convergence by fine-tuning the DE mutation factor and PSO cognitive component.", "configspace": "", "generation": 10, "fitness": 0.06326672987740474, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "ab9f09bc-633d-4c3a-b3f0-094084278446", "metadata": {"aucs": [0.06150178519020777, 0.06219841587422403, 0.06609998856778243]}, "mutation_prompt": null}
{"id": "b7460219-dc6e-42df-912b-ae16174fcaf4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget)) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced dynamic crossover probability to enhance exploration and exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.06445944944128346, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "bbc80212-cd01-48ec-9fec-df1d248faf5c", "metadata": {"aucs": [0.06422010488025287, 0.06159600987192937, 0.06756223357166813]}, "mutation_prompt": null}
{"id": "584d03c8-6668-4452-ab7d-c7c8c2d7b48e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget)) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a decaying scaling factor for DE mutation to adaptively balance exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.06497845591802709, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "b7460219-dc6e-42df-912b-ae16174fcaf4", "metadata": {"aucs": [0.06483847761755834, 0.063441511634177, 0.06665537850234593]}, "mutation_prompt": null}
{"id": "de865440-0297-4aa8-ab0e-2c33b73ae2ac", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget)) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(2 * np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved dynamic crossover probability by introducing an adaptive cosine factor for enhanced exploration-exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.06480427172763266, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "584d03c8-6668-4452-ab7d-c7c8c2d7b48e", "metadata": {"aucs": [0.06497970238888551, 0.06359051473044952, 0.06584259806356296]}, "mutation_prompt": null}
{"id": "c8087c00-cf01-4621-8161-03695ae20fe5", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced exploration by introducing stochastic sine-modulated velocity update in PSO.", "configspace": "", "generation": 14, "fitness": 0.06527704192805794, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "584d03c8-6668-4452-ab7d-c7c8c2d7b48e", "metadata": {"aucs": [0.06264591904296446, 0.06611863229247106, 0.06706657444873831]}, "mutation_prompt": null}
{"id": "d524549c-4281-4b4b-81a9-341a515ace57", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                self.c1 = 0.5 + 0.8 * np.sin(np.pi * self.evaluations / self.budget)  # Dynamic cognitive component\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced exploration by optimizing the balance between exploration and exploitation through a dynamically adaptive cognitive component.", "configspace": "", "generation": 15, "fitness": 0.06491497063718317, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "c8087c00-cf01-4621-8161-03695ae20fe5", "metadata": {"aucs": [0.061706025119786845, 0.06607979208574799, 0.06695909470601469]}, "mutation_prompt": null}
{"id": "c782e6bc-2d36-4c41-88fe-aef88f8b77c4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            swarm_diversity = np.mean(np.std(positions, axis=0))\n            self.inertia = max(0.1, 0.7 + 0.1 * (swarm_diversity / (ub - lb).mean()))  # Dynamic inertia based on diversity\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved convergence by introducing dynamic inertia scaling based on diversity.", "configspace": "", "generation": 16, "fitness": 0.06502553807289446, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c8087c00-cf01-4621-8161-03695ae20fe5", "metadata": {"aucs": [0.06323664171216437, 0.0654416359088289, 0.06639833659769012]}, "mutation_prompt": null}
{"id": "6f1cce7a-6526-4565-89bb-537d3f5068e3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]))  # Nonlinear adaptation\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced variable population size adaptation based on convergence speed to enhance exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.06563184321549627, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "c8087c00-cf01-4621-8161-03695ae20fe5", "metadata": {"aucs": [0.06530666814791519, 0.0654506090325615, 0.06613825246601213]}, "mutation_prompt": null}
{"id": "4fcadd84-9c97-4887-8815-e683e8fa7a3e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Optimized convergence by enhancing particle diversity with a minor adjustment to velocity update.", "configspace": "", "generation": 18, "fitness": 0.06584181366535669, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "6f1cce7a-6526-4565-89bb-537d3f5068e3", "metadata": {"aucs": [0.06557462981485174, 0.06283936344558316, 0.06911144773563516]}, "mutation_prompt": null}
{"id": "59aecd41-1323-4e73-ba82-75c68899594a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Optimized convergence by enhancing particle diversity with a minor adjustment to velocity update.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "4fcadd84-9c97-4887-8815-e683e8fa7a3e", "metadata": {"aucs": [0.06557462981485174, 0.06283936344558316, 0.06911144773563516]}, "mutation_prompt": null}
{"id": "61058f7c-05e3-4452-83b5-30e9e76e4305", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.85  # Inertia weight (changed)\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly increased the inertia component to enhance exploration in early iterations.", "configspace": "", "generation": 20, "fitness": 0.06583836114987807, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "4fcadd84-9c97-4887-8815-e683e8fa7a3e", "metadata": {"aucs": [0.06556622386258082, 0.06283779057472927, 0.06911106901232411]}, "mutation_prompt": null}
{"id": "bbc726b5-1193-4389-91f7-79e9da346a27", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced convergence by introducing nonlinear inertia weight modulation for adaptive exploration-exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.06679505433904358, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "4fcadd84-9c97-4887-8815-e683e8fa7a3e", "metadata": {"aucs": [0.06636497790026186, 0.0649409145985902, 0.06907927051827867]}, "mutation_prompt": null}
{"id": "9285428d-42df-4c68-8d91-169ba828c515", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced convergence by introducing nonlinear inertia weight modulation for adaptive exploration-exploitation balance.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "bbc726b5-1193-4389-91f7-79e9da346a27", "metadata": {"aucs": [0.06636497790026186, 0.0649409145985902, 0.06907927051827867]}, "mutation_prompt": null}
{"id": "6bc0b157-1df9-40bd-af94-e08af2cc8c57", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * (1 + 0.3 * np.sin(np.pi * self.evaluations / self.budget)) * r1 * (personal_best_positions[i] - positions[i]) +  # Adaptive cognitive component\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced an adaptive cognitive component for improved exploration stability.", "configspace": "", "generation": 23, "fitness": 0.06622317703100322, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bbc726b5-1193-4389-91f7-79e9da346a27", "metadata": {"aucs": [0.06692101319218235, 0.06246038195723047, 0.06928813594359684]}, "mutation_prompt": null}
{"id": "9c03b0d3-f147-4f83-b210-c1692e80d61e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n            self.c1 = 1.3 + 0.2 * (np.sin(self.evaluations/self.budget * np.pi))  # Dynamic cognitive component adjustment\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced convergence by introducing dynamic cognitive component adjustment for better performance balance.", "configspace": "", "generation": 24, "fitness": 0.06639678946453031, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bbc726b5-1193-4389-91f7-79e9da346a27", "metadata": {"aucs": [0.06705354121828688, 0.06304430240891068, 0.06909252476639338]}, "mutation_prompt": null}
{"id": "771f50a9-bcbc-4cbf-9a73-52f3599e0a21", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - 0.5 * np.sin(2 * np.pi * self.evaluations / self.budget))  # Sinusoidal adaptive scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a sinusoidal adaptive scaling factor to enhance dynamic search capabilities.", "configspace": "", "generation": 25, "fitness": 0.06666941800978328, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bbc726b5-1193-4389-91f7-79e9da346a27", "metadata": {"aucs": [0.06647980629261141, 0.06495751745786704, 0.0685709302788714]}, "mutation_prompt": null}
{"id": "1b2255e9-28e6-45f6-941b-c5d7995a0150", "solution": "class HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (increased)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Increased cognitive component for better individual exploration.", "configspace": "", "generation": 26, "fitness": 0.06636811526891744, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bbc726b5-1193-4389-91f7-79e9da346a27", "metadata": {"aucs": [0.06725129017668241, 0.06262038027493433, 0.06923267535513555]}, "mutation_prompt": null}
{"id": "219d0425-70d6-4af7-9295-606a94616dbd", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * (1 - 0.5 * self.evaluations / self.budget) * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced dynamic cognitive component adjustment for improved exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.06617756247292399, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bbc726b5-1193-4389-91f7-79e9da346a27", "metadata": {"aucs": [0.06655029707395921, 0.0629077664710106, 0.06907462387380214]}, "mutation_prompt": null}
{"id": "6fdc5768-5b0b-4692-b542-047bec9b8bd7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * (self.evaluations / self.budget)**2)  # Nonlinear inertia decrease (changed)\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved convergence by introducing dynamic inertia weight scaling for better adaptability.", "configspace": "", "generation": 28, "fitness": 0.06569453814935396, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bbc726b5-1193-4389-91f7-79e9da346a27", "metadata": {"aucs": [0.06639291973024719, 0.06206530765975671, 0.06862538705805799]}, "mutation_prompt": null}
{"id": "1cda1685-155e-43f2-9d6d-91538aef41f8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget) + 0.01 * np.random.randn())  # Slight stochastic perturbation\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.2, 0.8 - 0.6 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced minor stochastic perturbation in crossover probability to enhance exploration dynamics.", "configspace": "", "generation": 29, "fitness": 0.06593761728718983, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bbc726b5-1193-4389-91f7-79e9da346a27", "metadata": {"aucs": [0.06593882311913868, 0.06396788736092729, 0.06790614138150353]}, "mutation_prompt": null}
{"id": "08f068e9-c4e7-47ff-ae88-1991f7634189", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))  # Added small random component for diversity\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved the exploration capability by adjusting the inertia weight with a more pronounced nonlinear decrease.", "configspace": "", "generation": 30, "fitness": 0.06739099756639955, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "bbc726b5-1193-4389-91f7-79e9da346a27", "metadata": {"aucs": [0.0666562663086342, 0.06640357767559124, 0.0691131487149732]}, "mutation_prompt": null}
{"id": "1db8c34b-9233-4533-a499-939473285d35", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced velocity dampening to enhance convergence in the final stages of the search process.", "configspace": "", "generation": 31, "fitness": 0.06740175995865101, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "08f068e9-c4e7-47ff-ae88-1991f7634189", "metadata": {"aucs": [0.06658644398132552, 0.06656689242864366, 0.06905194346598387]}, "mutation_prompt": null}
{"id": "c2c83a60-304a-4765-8694-d69dd6fcec65", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.3  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.9 - 0.8 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a dynamic inertia update to enhance exploration and exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.0669511183613537, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "1db8c34b-9233-4533-a499-939473285d35", "metadata": {"aucs": [0.06655063266014472, 0.06523223220210417, 0.06907049022181222]}, "mutation_prompt": null}
{"id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced convergence by increasing the cognitive component to strengthen self-learning.", "configspace": "", "generation": 33, "fitness": 0.06746464252696849, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "1db8c34b-9233-4533-a499-939473285d35", "metadata": {"aucs": [0.06663936673530946, 0.06648389087071715, 0.06927066997487885]}, "mutation_prompt": null}
{"id": "b13aa9d7-3886-41eb-ae64-264defbaea2e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n            self.c2 = 1.5 * (1 - self.evaluations / self.budget)  # Dynamic social component adjustment\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved convergence by dynamically adjusting the social component based on evaluations.", "configspace": "", "generation": 34, "fitness": 0.06643203161131998, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.066433299284538, 0.06376741849482415, 0.06909537705459778]}, "mutation_prompt": null}
{"id": "1fdcae1c-327e-4578-b86e-f073c9c2c69f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n\n        # Main loop\n        while self.evaluations < self.budget:\n            self.c1 += 0.0001  # Adaptive increment for c1\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce an adaptive cognitive component increment to enhance exploration and convergence balance.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {}, "mutation_prompt": null}
{"id": "7a0006c2-f7fb-45ee-be88-f32870cee122", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                # Adjust social component based on population diversity\n                diversity_factor = np.std(positions, axis=0).mean() / (ub - lb).mean()\n                adapted_c2 = self.c2 * (1 + 0.5 * diversity_factor)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 adapted_c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))\n                trial = np.where(crossover, mutant, positions[i])\n\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))\n\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved exploration by introducing an adaptive social component based on particle diversity.", "configspace": "", "generation": 36, "fitness": 0.0659985676719664, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06709089804835588, 0.06263441821974858, 0.06827038674779473]}, "mutation_prompt": null}
{"id": "df650ac5-d3e0-4975-af3a-6b2540b1f834", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < (self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)) * (1 + 0.2 * np.sin(np.pi * self.evaluations / self.budget)))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced PSODE algorithm with a dynamically adjusted crossover rate to improve exploration efficiency.", "configspace": "", "generation": 37, "fitness": 0.06516312689599235, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06661632930299954, 0.06252056734042544, 0.06635248404455207]}, "mutation_prompt": null}
{"id": "43690492-7adb-4f84-ae7e-6a7ebe21fa56", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget)) + 0.05 * np.random.rand()  # Nonlinear inertia decrease with randomness\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced slight randomness to inertia weight for enhanced exploration.", "configspace": "", "generation": 38, "fitness": 0.06719004858789253, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06661101397874591, 0.06603053213157972, 0.06892859965335196]}, "mutation_prompt": null}
{"id": "5ac1bb16-d66d-4bbc-a1ea-2ea53f9706d3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.c1 = 1.4\n        self.c2 = 1.5\n        self.inertia = 0.8\n        self.f = 0.6\n        self.cr = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))\n                trial = np.where(crossover, mutant, positions[i])\n\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))\n            diversity = np.std(personal_best_scores) / np.mean(personal_best_scores)\n            self.c1, self.c2 = (1.5 + 0.5 * diversity, 1.2 + 0.3 * (1 - diversity))\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive learning rates and diversity maintenance.", "configspace": "", "generation": 39, "fitness": 0.06647363421702963, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06721973417986093, 0.06278212405490247, 0.06941904441632551]}, "mutation_prompt": null}
{"id": "f34823f0-553c-486e-9827-2b81a0aae92b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() +\n                                           0.1 * np.random.rand(self.dim)) * r2 * (global_best_position - positions[i]) +  # Added random component\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced exploration by adding randomness to the social component.", "configspace": "", "generation": 40, "fitness": 0.06512834369048877, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06557126551208248, 0.06324605452291465, 0.06656771103646919]}, "mutation_prompt": null}
{"id": "9e3be153-d4b9-4e26-81b7-341c7cb56d41", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.c1 = 1.4\n        self.c2 = 1.5\n        self.inertia = 0.8\n        self.f = 0.6\n        self.cr = 0.75\n        self.evaluations = 0\n\n    def __call__(self, func):\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget) * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Sinusoidal DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))\n                trial = np.where(crossover, mutant, positions[i])\n\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced exploration by introducing a sinusoidal component to the DE scaling factor for improved balance between exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.06677756778729475, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06749823182082104, 0.06352133200060772, 0.06931313954045548]}, "mutation_prompt": null}
{"id": "19f1ac6e-0e77-4d20-baf4-1acdd47be3b2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.45  # Cognitive component (slightly adjusted)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced convergence by slightly adjusting the cognitive component for improved self-learning.", "configspace": "", "generation": 42, "fitness": 0.06642963087587239, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06719449789224352, 0.06273339118849375, 0.0693610035468799]}, "mutation_prompt": null}
{"id": "d20f36b2-f35c-4fc3-8ab2-d694f649c426", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * (1 - self.evaluations / self.budget) * r1 * (personal_best_positions[i] - positions[i]) +  # Decaying cognitive component\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a decay factor to the cognitive component to enhance adaptive exploration.", "configspace": "", "generation": 43, "fitness": 0.06648794921455259, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06693476277419808, 0.06352922108111458, 0.0689998637883451]}, "mutation_prompt": null}
{"id": "aca9407e-95ce-4103-8e50-f5ee98286356", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim) * (1 + 0.3 * np.random.rand())) * (0.95 ** (self.evaluations / self.budget))  # Increased randomness\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Increase exploration potential by enhancing the randomness in velocity updates.", "configspace": "", "generation": 44, "fitness": 0.06417874789251166, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06181616086622488, 0.06407972937270923, 0.06664035343860086]}, "mutation_prompt": null}
{"id": "08211fd7-13a4-4943-ab53-c32092564766", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n            # Modify social component dynamically (new line)\n            self.c2 = 1.5 + 0.5 * np.sin(np.pi * self.evaluations / self.budget)  # Adjust c2 over iterations\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce population diversity control through adaptive inertia reduction and dynamic social factor scaling for enhanced exploration and exploitation balance.", "configspace": "", "generation": 45, "fitness": 0.06727708225267688, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06731892577321463, 0.06516349875740535, 0.06934882222741068]}, "mutation_prompt": null}
{"id": "557f063e-a037-4581-9455-9ed6c5ebb48f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                self.c1 = 1.4 * (1 + 0.5 * np.sin(np.pi * self.evaluations / self.budget))  # Dynamic cognitive component\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a dynamic cognitive component to enhance exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.06590737119881658, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06652960233948269, 0.06190392095432462, 0.06928859030264245]}, "mutation_prompt": null}
{"id": "0b75b0ec-2ef5-4516-aacb-b7bd24985694", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.45  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Dampening factor added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly increased cognitive component to enhance self-learning and exploration.", "configspace": "", "generation": 47, "fitness": 0.06642963087587239, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06719449789224352, 0.06273339118849375, 0.0693610035468799]}, "mutation_prompt": null}
{"id": "22f9c980-0d6f-48ba-b732-0949983cc75b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim)) * (0.95 ** (self.evaluations / self.budget)) * (1 / (1 + np.exp(-velocities[i])))  # Sigmoid function applied\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a sigmoid function in velocity update to enhance exploration.", "configspace": "", "generation": 48, "fitness": 0.06725416719703521, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06645803438159592, 0.06736810191900722, 0.06793636529050251]}, "mutation_prompt": null}
{"id": "96fa3451-71be-4718-b43f-4ec99afa9482", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a sinusoidal perturbation factor to enhance exploration by slightly increasing randomness in velocity updates.", "configspace": "", "generation": 49, "fitness": 0.06748316738744849, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "8a35968d-3b89-408f-ad7a-b06a3e16f915", "metadata": {"aucs": [0.06667920459496224, 0.06648701727575634, 0.06928328029162689]}, "mutation_prompt": null}
{"id": "5b745c7e-154d-422a-9c68-e5f78c22eb11", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced exploration by increasing cognitive component slightly.", "configspace": "", "generation": 50, "fitness": 0.0663144357745085, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96fa3451-71be-4718-b43f-4ec99afa9482", "metadata": {"aucs": [0.06680202669587398, 0.0626293434792109, 0.06951193714844062]}, "mutation_prompt": null}
{"id": "9058bcea-abe0-4279-ae95-53d3865fe33c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.cos(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +  # Changed sin to cos\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a cosine perturbation factor to replace the sinusoidal perturbation, enhancing exploration with a smoother oscillation pattern.", "configspace": "", "generation": 51, "fitness": 0.06542255267510166, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96fa3451-71be-4718-b43f-4ec99afa9482", "metadata": {"aucs": [0.06411413816355904, 0.06340119796821608, 0.06875232189352987]}, "mutation_prompt": null}
{"id": "52a53223-aafe-477e-85d9-9301de6d7a96", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.cos(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved exploration by slightly increasing the randomness in velocity updates using a cosine function.", "configspace": "", "generation": 52, "fitness": 0.06542255267510166, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96fa3451-71be-4718-b43f-4ec99afa9482", "metadata": {"aucs": [0.06411413816355904, 0.06340119796821608, 0.06875232189352987]}, "mutation_prompt": null}
{"id": "7e1f6ccf-3158-4ae3-b169-b85a664de01e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.65  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn()) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhanced exploitation by slightly increasing the DE scaling factor to improve convergence rate.", "configspace": "", "generation": 53, "fitness": 0.06748316738744849, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96fa3451-71be-4718-b43f-4ec99afa9482", "metadata": {"aucs": [0.06667920459496224, 0.06648701727575634, 0.06928328029162689]}, "mutation_prompt": null}
{"id": "582122b7-970b-45ed-a0cc-af005de75d20", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce damping factor in the sinusoidal perturbation for controlled randomness in velocity updates.", "configspace": "", "generation": 54, "fitness": 0.06761692722060382, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "96fa3451-71be-4718-b43f-4ec99afa9482", "metadata": {"aucs": [0.06734999844605316, 0.0662040259116996, 0.06929675730405871]}, "mutation_prompt": null}
{"id": "0b7633b9-cd4a-4f08-aa02-b21b10c05947", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Fine-tune the cognitive component to enhance convergence speed.", "configspace": "", "generation": 55, "fitness": 0.06650058979160955, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "582122b7-970b-45ed-a0cc-af005de75d20", "metadata": {"aucs": [0.06717750789508636, 0.06293353111749356, 0.06939073036224874]}, "mutation_prompt": null}
{"id": "b9268054-3706-4e7b-81ec-b479766335ff", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 1.1) * r2 * (global_best_position - positions[i]) +  # Modified damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhancing exploration by increasing the range of sinusoidal perturbations in velocity updates.", "configspace": "", "generation": 56, "fitness": 0.06617126594297873, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "582122b7-970b-45ed-a0cc-af005de75d20", "metadata": {"aucs": [0.06611717130486572, 0.06303196495861074, 0.06936466156545973]}, "mutation_prompt": null}
{"id": "26986601-fbcf-4cfd-bb2e-e7d188a1b93a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a cosine annealing schedule for the crossover probability to enhance exploration and exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.06761692722060382, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "582122b7-970b-45ed-a0cc-af005de75d20", "metadata": {"aucs": [0.06734999844605316, 0.0662040259116996, 0.06929675730405871]}, "mutation_prompt": null}
{"id": "5ccd3f56-36be-42cd-aee3-d668913a9a5d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce damping factor in the sinusoidal perturbation for controlled randomness in velocity updates.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "582122b7-970b-45ed-a0cc-af005de75d20", "metadata": {"aucs": [0.06734999844605316, 0.0662040259116996, 0.06929675730405871]}, "mutation_prompt": null}
{"id": "32c36458-6bec-4438-94c8-3f784922bedc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce damping factor in the sinusoidal perturbation for controlled randomness in velocity updates.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "582122b7-970b-45ed-a0cc-af005de75d20", "metadata": {"aucs": [0.06734999844605316, 0.0662040259116996, 0.06929675730405871]}, "mutation_prompt": null}
{"id": "e5ec0868-4be0-4136-9806-d48ef6dd7e0b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                self.c1 = 1.4 - 0.5 * (self.evaluations / self.budget)  # Time-decaying cognitive component\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))  # Adaptive velocity clamping\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a time-decaying acceleration coefficient to dynamically adjust the cognitive component of the particle swarm.", "configspace": "", "generation": 60, "fitness": 0.06733543875408636, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "582122b7-970b-45ed-a0cc-af005de75d20", "metadata": {"aucs": [0.06664485839591705, 0.06630993596670864, 0.06905152189963337]}, "mutation_prompt": null}
{"id": "1bf475eb-68a3-4fce-b7ce-ad755f61c549", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a nonlinear velocity clamping mechanism to enhance exploration-exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.06786831339932686, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "582122b7-970b-45ed-a0cc-af005de75d20", "metadata": {"aucs": [0.06801548927718781, 0.06629340645584192, 0.06929604446495086]}, "mutation_prompt": null}
{"id": "d3ec0586-d3f3-4dbc-8989-1cc084c3cdc7", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.65 * (1 - self.evaluations / self.budget)  # Enhanced scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.7 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a nonlinear velocity clamping mechanism with enhanced differential evolution scaling for improved adaptation.", "configspace": "", "generation": 62, "fitness": 0.0676515597409663, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "1bf475eb-68a3-4fce-b7ce-ad755f61c549", "metadata": {"aucs": [0.0673805416493981, 0.06635327793127066, 0.06922085964223013]}, "mutation_prompt": null}
{"id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly increase the inertia decrement rate to enhance the exploration phase without altering stability.", "configspace": "", "generation": 63, "fitness": 0.06789059336914305, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "1bf475eb-68a3-4fce-b7ce-ad755f61c549", "metadata": {"aucs": [0.06802296065076763, 0.0662936115077637, 0.06935520794889782]}, "mutation_prompt": null}
{"id": "12d6ddbc-075b-4dca-9426-51d594eed9c4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 (1 - self.evaluations / self.budget) * self.c1 * r1 * (personal_best_positions[i] - positions[i]) +  # Added cooling schedule\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a cooling schedule to reduce the cognitive component linearly over time, promoting exploration in the early stages and exploitation towards the end.", "configspace": "", "generation": 64, "fitness": 0.06677123754981318, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06672608664565816, 0.06451633182178118, 0.0690712941820002]}, "mutation_prompt": null}
{"id": "d96d833f-2007-4b20-b4d7-fe3c745ac8a9", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget) * (1 + 0.5 * np.sin(np.pi * self.evaluations / self.budget))  # Adaptive DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce an adaptive mutation rate within Differential Evolution to enhance exploration capabilities.", "configspace": "", "generation": 65, "fitness": 0.06711594401514598, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06748033719125546, 0.0649309838121348, 0.06893651104204768]}, "mutation_prompt": null}
{"id": "4ca82ee1-f639-4ba5-b129-3e375131b0d3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.65 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor adjusted\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly enhance global exploration by adjusting the DE scaling factor's decay rate.", "configspace": "", "generation": 66, "fitness": 0.06773700088959, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06752850127548549, 0.06638254959958967, 0.06929995179369486]}, "mutation_prompt": null}
{"id": "1b3cd0d2-2337-4ff5-9100-2dc9edddcb2b", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - (self.evaluations / self.budget) ** 2)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Refine the DE mutation factor decay for smoother convergence.", "configspace": "", "generation": 67, "fitness": 0.06713849011322448, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06658599314794322, 0.065694370880934, 0.06913510631079622]}, "mutation_prompt": null}
{"id": "4cf42c43-50ca-4e82-95a1-9214008bb1da", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly increase the inertia decrement rate to enhance the exploration phase without altering stability.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06802296065076763, 0.0662936115077637, 0.06935520794889782]}, "mutation_prompt": null}
{"id": "74bcb4d3-44c3-4385-9a10-04ec50435c44", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  \n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  \n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  \n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  \n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  \n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhance exploration by refining the random factor in the velocity formula.", "configspace": "", "generation": 69, "fitness": 0.06789059336914305, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06802296065076763, 0.0662936115077637, 0.06935520794889782]}, "mutation_prompt": null}
{"id": "cfad4c8f-627e-4d29-9d7f-822aa19d493f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (adjusted)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly adjust the cognitive component (c1) to balance exploration and exploitation more effectively.", "configspace": "", "generation": 70, "fitness": 0.06781626855194604, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06782489843832651, 0.06609522626937503, 0.06952868094813658]}, "mutation_prompt": null}
{"id": "2136b92a-56e0-4529-94eb-dcc249193418", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.6  # Cognitive component (adjusted)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a slight modification to the cognitive component to enhance individual exploration.", "configspace": "", "generation": 71, "fitness": 0.06655193668615678, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.0678020258453913, 0.06235874415296072, 0.06949504006011831]}, "mutation_prompt": null}
{"id": "ca7a86e5-f65c-4470-b9ca-2217d1af8027", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.78 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease adjusted\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a nonlinear inertia adjustment to enhance convergence speed and exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.06788965953938923, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.0680539780831636, 0.06626966061120565, 0.06934533992379843]}, "mutation_prompt": null}
{"id": "1293a639-0b9c-4874-9458-b2ced931628a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < (self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget)) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget))  # Added sine perturbation\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a sine function perturbation in the DE crossover strategy to enhance diversity.", "configspace": "", "generation": 73, "fitness": 0.0655651477301376, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06771194533300162, 0.0626597769318562, 0.06632372092555494]}, "mutation_prompt": null}
{"id": "763e363c-932a-4a10-b3d3-bec97965e490", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < (self.cr * 0.8 + 0.2) * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability adjustment\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a minor adjustment to the crossover probability calculation to enhance diversity in the exploration phase.", "configspace": "", "generation": 74, "fitness": 0.06564797991766373, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06714769979429569, 0.06315305130729809, 0.0666431886513974]}, "mutation_prompt": null}
{"id": "a1f0f62c-fbb2-4567-8259-165ea76799bb", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.65  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.65 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhance exploration by slightly increasing the differential evolution scaling factor.", "configspace": "", "generation": 75, "fitness": 0.06773700088959, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06752850127548549, 0.06638254959958967, 0.06929995179369486]}, "mutation_prompt": null}
{"id": "8f712dca-40c5-4379-8296-48f12f6b6299", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget) + 0.01  # Slight increase in the DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a minor adjustment to enhance diversity by slightly altering the mutation strategy component.", "configspace": "", "generation": 76, "fitness": 0.06766119846164098, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06758310575420845, 0.06628974664512077, 0.06911074298559372]}, "mutation_prompt": null}
{"id": "7eb0943c-0d62-4139-b6fa-0e629e44780f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability updated\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhance the exploration phase by adjusting the dynamic crossover probability function.", "configspace": "", "generation": 77, "fitness": 0.0646718044989459, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06292337665653525, 0.06705947691747083, 0.06403255992283163]}, "mutation_prompt": null}
{"id": "944dfb26-2d2b-4334-a3b7-0327a8b6221f", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly increase the cognitive component to boost exploration and convergence speed.", "configspace": "", "generation": 78, "fitness": 0.06781626855194604, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06782489843832651, 0.06609522626937503, 0.06952868094813658]}, "mutation_prompt": null}
{"id": "2152f87f-22e8-4b31-b55c-601619c6c5b8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i] + 0.02 * np.random.randn(self.dim)) +  # Added stochastic component\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Add a small stochastic component to the cognitive component update to enhance exploration.", "configspace": "", "generation": 79, "fitness": 0.0655789024847259, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06546081137756199, 0.06355270179202877, 0.06772319428458695]}, "mutation_prompt": null}
{"id": "c25db7cc-db48-41b8-94dd-36adca2a135a", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (changed)\n        self.c2 = 1.7  # Social component (changed)\n        self.inertia = 0.9  # Inertia weight (changed)\n        self.f = 0.6  # Differential Evolution scaling factor\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (1.2 - 0.2 * np.cos(np.pi * self.evaluations / self.budget)) * (personal_best_positions[i] - positions[i]) +  # Nonlinear cognitive component (changed)\n                                 self.c2 * r2 * (global_best_position - positions[i]) +\n                                 0.1 * np.random.randn(self.dim))\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb), 0.5 * (ub - lb))\n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.9 - 0.8 * np.cos(np.pi * self.evaluations / self.budget))  # Adaptive inertia (changed)\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce nonlinear cognitive scaling and adaptive inertia to enhance convergence in a dynamic environment.", "configspace": "", "generation": 80, "fitness": 0.06389056723093156, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06573191284412205, 0.06212721316024672, 0.06381257568842591]}, "mutation_prompt": null}
{"id": "c0ad4f88-c7cb-4aae-88f9-2d15dc36c32c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i] + 0.01 * np.random.randn(self.dim), lb, ub)  # Random perturbation added\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a small random perturbation to enhance diversity in position updates.", "configspace": "", "generation": 81, "fitness": 0.06601409217449365, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06563737564116323, 0.0637822205086489, 0.06862268037366881]}, "mutation_prompt": null}
{"id": "f7a39ed6-bab9-4881-bf72-209b00d37db2", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                self.c1 = 1.4 + 0.2 * np.sin(np.pi * self.evaluations / self.budget)  # Adaptive c1\n                self.c2 = 1.5 + 0.2 * np.cos(np.pi * self.evaluations / self.budget)  # Adaptive c2\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget) + 0.2 * np.random.rand()  # Adaptive f\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce adaptive parameter tuning for PSO and DE components to improve exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.06624460695132028, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06770287527279983, 0.06456395195166975, 0.06646699362949127]}, "mutation_prompt": null}
{"id": "69e91234-e614-47c9-bcf2-3e49643fabc4", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = (global_best_position + trial) / 2  # Refined global best update\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Refine global best position update by considering a weighted average to enhance convergence stability.", "configspace": "", "generation": 83, "fitness": 0.06703430696559987, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06671892136223656, 0.06555916543699614, 0.0688248340975669]}, "mutation_prompt": null}
{"id": "caf9a959-a0f0-4f75-b130-8f65cf5ae8a3", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Increase the cognitive component slightly to enhance personal best influence.", "configspace": "", "generation": 84, "fitness": 0.06781626855194604, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06782489843832651, 0.06609522626937503, 0.06952868094813658]}, "mutation_prompt": null}
{"id": "372db6dc-fc1b-4a6b-9df0-579ff0221334", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.65 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Fine-tuned inertia factor decay rate to enhance global search capability.", "configspace": "", "generation": 85, "fitness": 0.06773199302693045, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06797741124729362, 0.06615780616646494, 0.06906076166703279]}, "mutation_prompt": null}
{"id": "80638d50-4bdb-4af2-be2b-0305faa74e5c", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * (1 + 0.5 * np.sin(2 * np.pi * self.evaluations / self.budget)) * r1 * (personal_best_positions[i] - positions[i]) +  # Dynamic cognitive component\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  \n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a dynamic cognitive component for Particle Swarm Optimization to enhance exploration-exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.0672477457720471, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06675185788688431, 0.06578939147066853, 0.06920198795858845]}, "mutation_prompt": null}
{"id": "f0216c87-c8fa-4a72-8506-50b7f65937bd", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget) + 0.03 * np.random.rand(self.dim)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Enhance exploration by integrating an adaptive random velocity perturbation factor.", "configspace": "", "generation": 87, "fitness": 0.06604865063363252, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06469178552013355, 0.06526988484906615, 0.06818428153169787]}, "mutation_prompt": null}
{"id": "6878ec32-0fec-4b41-914f-7386f5f1d5bc", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.75 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Adjusted damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.65 * (1 - self.evaluations / self.budget)  # Slightly increased DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Improved PSO dynamics by adjusting damping factor and mutation scaling.", "configspace": "", "generation": 88, "fitness": 0.06760629916674965, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06733544471766117, 0.06627879010367532, 0.06920466267891245]}, "mutation_prompt": null}
{"id": "3476c43b-ab69-47a2-a27f-b195de406be6", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n            # Dynamically adjust cognitive component\n            self.c1 = 1.4 * (1 - 0.5 * (self.evaluations / self.budget))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduced a dynamic adjustment to the cognitive component (c1) to enhance convergence speed.", "configspace": "", "generation": 89, "fitness": 0.06755297155990025, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06707135370785233, 0.06646192269744478, 0.06912563827440366]}, "mutation_prompt": null}
{"id": "8c819385-3c7b-42f5-974f-379c6e7a99c8", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.35  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Reduce cognitive component slightly to enhance cooperation among particles and balance exploration-exploitation.", "configspace": "", "generation": 90, "fitness": 0.06778953532267218, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06802522950407575, 0.06626424410782328, 0.06907913235611751]}, "mutation_prompt": null}
{"id": "7c0fb5a6-8723-46be-8557-f5d99364b739", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly adjust the cognitive component to balance exploration and exploitation.", "configspace": "", "generation": 91, "fitness": 0.06781626855194604, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06782489843832651, 0.06609522626937503, 0.06952868094813658]}, "mutation_prompt": null}
{"id": "8a422d4f-a8c8-43e1-bffd-ec0a2a000edd", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Fine-tune the cognitive component for better individual exploration.", "configspace": "", "generation": 92, "fitness": 0.06781626855194604, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06782489843832651, 0.06609522626937503, 0.06952868094813658]}, "mutation_prompt": null}
{"id": "3affcd1e-c70f-4eb7-8406-1aa7f102766e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget))  # Added dynamic sinusoidal adjustment\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a dynamic inertia adjustment for better balancing between exploration and exploitation.", "configspace": "", "generation": 93, "fitness": 0.06779646761786973, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06787848934278728, 0.06637465007077636, 0.06913626344004553]}, "mutation_prompt": null}
{"id": "caf6908f-0596-4344-8152-a06559c83af0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.6  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Increase the cognitive component to enhance individual exploration.", "configspace": "", "generation": 94, "fitness": 0.06655193668615678, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.0678020258453913, 0.06235874415296072, 0.06949504006011831]}, "mutation_prompt": null}
{"id": "bc4f5022-ae87-46db-b1bb-82c81befd8ba", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 (self.c1 + 0.1 * np.sin(np.pi * self.evaluations / self.budget)) * r1 * (personal_best_positions[i] - positions[i]) +  # Dynamic cognitive component\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a dynamic adjustment to the cognitive component to enhance convergence speed. ", "configspace": "", "generation": 95, "fitness": 0.06783510047229106, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.0677253769686964, 0.06624968576057355, 0.06953023868760322]}, "mutation_prompt": null}
{"id": "182596cc-3f22-455f-a8fe-43fa9e9dfefe", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.5  # Cognitive component (slightly increased)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly adjust the cognitive component to enhance the balance between exploration and exploitation.", "configspace": "", "generation": 96, "fitness": 0.06781626855194604, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06782489843832651, 0.06609522626937503, 0.06952868094813658]}, "mutation_prompt": null}
{"id": "cc9eb579-b936-4a0d-af04-b1391d946077", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.8  # Differential Evolution scaling factor (changed from 0.6)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.8 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Slightly enhance differential evolution scaling factor adaptation by increasing its initial value to improve exploration.", "configspace": "", "generation": 97, "fitness": 0.06594704214012974, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06317151590072378, 0.06578722051916142, 0.068882390000504]}, "mutation_prompt": null}
{"id": "aa784875-34d6-4b1f-a027-87d3c77e6a7e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.4  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt((self.evaluations / self.budget) ** 2))  # Nonlinear inertia decrease (altered formula)\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a non-uniform inertia weight decay to balance exploration and exploitation phases.", "configspace": "", "generation": 98, "fitness": 0.06662635299698665, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06727670914031914, 0.0635170383529241, 0.06908531149771668]}, "mutation_prompt": null}
{"id": "fbe895c8-df4b-478f-96e4-d185fa38ab96", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Population size\n        self.c1 = 1.42  # Cognitive component (changed)\n        self.c2 = 1.5  # Social component\n        self.inertia = 0.8  # Inertia weight\n        self.f = 0.6  # Differential Evolution scaling factor (changed)\n        self.cr = 0.75  # Crossover probability\n        self.evaluations = 0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        lb, ub = np.array(func.bounds.lb), np.array(func.bounds.ub)\n        positions = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.full(self.pop_size, np.inf)\n        \n        # Evaluate initial population\n        global_best_position = None\n        global_best_score = np.inf\n\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            score = func(positions[i])\n            self.evaluations += 1\n            if score < personal_best_scores[i]:\n                personal_best_scores[i] = score\n                personal_best_positions[i] = positions[i]\n            if score < global_best_score:\n                global_best_score = score\n                global_best_position = positions[i]\n\n        # Main loop\n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                # PSO Update\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia * velocities[i] +\n                                 self.c1 * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.c2 * (1 + 0.7 * np.sin(np.pi * self.evaluations / self.budget) * np.random.randn() * 0.9) * r2 * (global_best_position - positions[i]) +  # Added damping factor\n                                 0.1 * np.random.randn(self.dim) + 0.05 * np.sin(2 * np.pi * self.evaluations / self.budget)) * (0.95 ** (self.evaluations / self.budget))  # Sinusoidal perturbation added\n                velocities[i] = np.clip(velocities[i], -0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)), 0.5 * (ub - lb) * (0.8 ** (self.evaluations / self.budget)))  # Nonlinear velocity clamping \n                positions[i] = np.clip(positions[i] + velocities[i], lb, ub)\n\n                # DE Mutation and Crossover\n                indices = np.random.choice(np.delete(np.arange(self.pop_size), i), 3, replace=False)\n                a, b, c = positions[indices]\n                self.f = 0.6 * (1 - self.evaluations / self.budget)  # Decaying DE scaling factor\n                mutant = np.clip(a + self.f * (b - c), lb, ub)\n                crossover = np.random.rand(self.dim) < self.cr * (0.5 + 0.5 * np.cos(np.pi * self.evaluations / self.budget))  # Dynamic crossover probability\n                trial = np.where(crossover, mutant, positions[i])\n\n                # Evaluate new solution\n                if self.evaluations < self.budget:\n                    score = func(trial)\n                    self.evaluations += 1\n\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = trial\n                    \n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = trial\n\n            # Adaptive mechanism\n            self.inertia = max(0.1, 0.8 - 0.75 * np.sqrt(self.evaluations / self.budget))  # Nonlinear inertia decrease\n\n            # Dynamic population size adaptation\n            self.pop_size = max(5, int(10 * self.dim * (1 - self.evaluations / self.budget)))\n\n        return global_best_position", "name": "HybridPSODE", "description": "Introduce a slight increase in the cognitive component (c1) to enhance personal attraction in the search space.", "configspace": "", "generation": 99, "fitness": 0.06788876634161618, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_id": "f504c8f0-790e-4e11-9676-f816dc9f9f4e", "metadata": {"aucs": [0.06802811174973211, 0.06625375393324706, 0.06938443334186939]}, "mutation_prompt": null}
