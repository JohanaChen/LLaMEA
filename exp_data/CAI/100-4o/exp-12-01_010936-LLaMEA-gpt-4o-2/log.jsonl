{"id": "6989b8c9-9c10-4566-b7a9-706eca26cb4b", "solution": "import numpy as np\n\nclass APDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.pop = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = self.pop.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.7   # inertia weight\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Particle Swarm Update\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.personal_best_positions[i] - self.pop[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n                self.pop[i] = np.clip(self.pop[i], -5, 5)\n                \n                # Evaluate new solution\n                score = func(self.pop[i])\n                evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.pop[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.pop[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            # Differential Evolution Crossover and Mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[idxs]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, -5, 5)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.pop[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.pop[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial.copy()\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "APDE", "description": "The Adaptive Particle Differential Evolution (APDE) combines particle swarm dynamics with differential evolution for efficient exploration and exploitation in complex landscapes.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 29, in __call__\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n.", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 29, in __call__\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "cd108ff9-4dd1-4778-b8d9-f18033b44e14", "solution": "import numpy as np\n\nclass APDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.pop = np.random.uniform(-5, 5, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = self.pop.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.w = 0.9   # inertia weight adjusted for improved exploration\n        self.F = 0.8   # DE scaling factor\n        self.CR = 0.9  # DE crossover probability\n\n    def __call__(self, func):\n        evaluations = 0\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Particle Swarm Update\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.personal_best_positions[i] - self.pop[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.pop[i]))\n                self.pop[i] += self.velocities[i]\n                self.pop[i] = np.clip(self.pop[i], -5, 5)\n                \n                # Evaluate new solution\n                score = func(self.pop[i])\n                evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.pop[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.pop[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            # Differential Evolution Crossover and Mutation\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.pop[idxs]\n                mutant = x0 + self.F * (x1 - x2)\n                mutant = np.clip(mutant, -5, 5)\n\n                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.pop[i])\n                trial_score = func(trial)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.pop[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial.copy()\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial.copy()\n\n        return self.global_best_position, self.global_best_score", "name": "APDE", "description": "The Adaptive Particle Differential Evolution (APDE) refines its exploration strategy by dynamically adjusting the inertia weight for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "6989b8c9-9c10-4566-b7a9-706eca26cb4b", "metadata": {}, "mutation_prompt": null}
