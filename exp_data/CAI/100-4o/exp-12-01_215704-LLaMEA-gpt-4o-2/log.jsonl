{"id": "05fa44c4-6cc8-4fbd-b371-d5a19c676055", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "a8545172-7ee4-4993-865e-708f8b33d666", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = [-5.0, 5.0]\n        self.population_size = 50\n        self.f = 0.5\n        self.cr = 0.9\n        self.c1 = 0.5\n        self.c2 = 0.3\n        self.w = 0.5\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_positions = np.copy(self.positions)\n        self.global_best_position = np.copy(self.positions[np.argmin(self.evaluate_population())])\n        self.eval_count = 0\n    \n    def evaluate_population(self):\n        return np.array([func(ind) for ind in self.positions])\n    \n    def __call__(self, func):\n        self.func = func\n        while self.eval_count < self.budget:\n            self.de_step()\n            self.pso_step()\n            self.update_global_best()\n        return self.global_best_position\n\n    def de_step(self):\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.positions[np.random.choice(idxs, 3, replace=False)]\n            mutant_vector = np.clip(a + self.f * (b - c), self.bounds[0], self.bounds[1])\n            cross_points = np.random.rand(self.dim) < self.cr\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial_vector = np.where(cross_points, mutant_vector, self.positions[i])\n            if func(trial_vector) < func(self.positions[i]):\n                self.positions[i] = trial_vector\n                self.best_positions[i] = trial_vector\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                break\n\n    def pso_step(self):\n        r1 = np.random.rand(self.population_size, self.dim)\n        r2 = np.random.rand(self.population_size, self.dim)\n        self.velocities = self.w * self.velocities + self.c1 * r1 * (self.best_positions - self.positions) \\\n                          + self.c2 * r2 * (self.global_best_position - self.positions)\n        self.positions = np.clip(self.positions + self.velocities, self.bounds[0], self.bounds[1])\n\n    def update_global_best(self):\n        current_best_idx = np.argmin(self.evaluate_population())\n        if func(self.positions[current_best_idx]) < func(self.global_best_position):\n            self.global_best_position = np.copy(self.positions[current_best_idx])", "name": "HybridDEPSO", "description": "Hybrid Differential Evolution and Particle Swarm Optimization for efficient exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "05fa44c4-6cc8-4fbd-b371-d5a19c676055", "metadata": {}, "mutation_prompt": null}
