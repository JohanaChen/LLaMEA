{"id": "1bb4eabc-43e1-4385-b312-1354684e5ea9", "solution": "import numpy as np\n\nclass HybridDEAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutation(self, population, best_idx):\n        indices = np.arange(self.population_size)\n        for i in range(self.population_size):\n            indices = np.delete(indices, np.where(indices == i))\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            trial = np.copy(population[i])\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial[crossover] = mutant[crossover]\n            if np.random.rand() < 1.0 / self.dim:\n                trial[np.random.randint(0, self.dim)] = mutant[np.random.randint(0, self.dim)]\n            yield trial\n\n    def _annealing_acceptance(self, current_value, new_value):\n        if new_value < current_value:\n            return True\n        return np.random.rand() < np.exp((current_value - new_value) / self.temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        values = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(values)\n        best_value = values[best_idx]\n        best_solution = population[best_idx]\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i, trial in enumerate(self._mutation(population, best_idx)):\n                if evals >= self.budget:\n                    break\n                trial_value = func(trial)\n                evals += 1\n                if self._annealing_acceptance(values[i], trial_value):\n                    population[i] = trial\n                    values[i] = trial_value\n                    if trial_value < best_value:\n                        best_value = trial_value\n                        best_solution = trial\n            \n            self.temperature *= self.cooling_rate\n            best_idx = np.argmin(values)\n            best_value = values[best_idx]\n\n        return best_solution, best_value", "name": "HybridDEAnnealing", "description": "A hybridized metaheuristic combining differential evolution and simulated annealing for robust exploration and exploitation.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 45, in __call__\n  File \"<string>\", line 22, in _mutation\n  File \"mtrand.pyx\", line 984, in numpy.random.mtrand.RandomState.choice\nValueError: Cannot take a larger sample than population when 'replace=False'\n.", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 45, in __call__\n  File \"<string>\", line 22, in _mutation\n  File \"mtrand.pyx\", line 984, in numpy.random.mtrand.RandomState.choice\nValueError: Cannot take a larger sample than population when 'replace=False'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "9aaa5f6a-aa8b-4150-9c77-e2fd049c7019", "solution": "import numpy as np\n\nclass HybridDEAnnealing:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def _initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def _mutation(self, population, best_idx):\n        indices = np.arange(self.population_size)\n        for i in range(self.population_size):\n            valid_indices = np.delete(indices, np.where(indices == i))\n            a, b, c = population[np.random.choice(valid_indices, 3, replace=False)]\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            trial = np.copy(population[i])\n            crossover = np.random.rand(self.dim) < self.crossover_rate\n            trial[crossover] = mutant[crossover]\n            if np.random.rand() < 1.0 / self.dim:\n                trial[np.random.randint(0, self.dim)] = mutant[np.random.randint(0, self.dim)]\n            yield trial\n\n    def _annealing_acceptance(self, current_value, new_value):\n        if new_value < current_value:\n            return True\n        return np.random.rand() < np.exp((current_value - new_value) / self.temperature)\n\n    def __call__(self, func):\n        population = self._initialize_population()\n        values = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(values)\n        best_value = values[best_idx]\n        best_solution = population[best_idx]\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i, trial in enumerate(self._mutation(population, best_idx)):\n                if evals >= self.budget:\n                    break\n                trial_value = func(trial)\n                evals += 1\n                if self._annealing_acceptance(values[i], trial_value):\n                    population[i] = trial\n                    values[i] = trial_value\n                    if trial_value < best_value:\n                        best_value = trial_value\n                        best_solution = trial\n            \n            self.temperature *= self.cooling_rate\n            best_idx = np.argmin(values)\n            best_value = values[best_idx]\n\n        return best_solution, best_value", "name": "HybridDEAnnealing", "description": "A hybrid algorithm combining differential evolution and simulated annealing, refined by adjusting mutation mechanism to avoid sampling issues and enhance robustness.", "configspace": "", "generation": 1, "fitness": 0.19065657750131276, "feedback": "", "error": "", "parent_id": "1bb4eabc-43e1-4385-b312-1354684e5ea9", "metadata": {"aucs": [0.20689200982851175, 0.21554702534673553, 0.20240192855570494, 0.25065463403084154, 0.2384272300130671, 0.2397788773749011, 0.22402771829077173, 0.24227552045545508, 0.23061531885905828, 0.19764755703768455, 0.19635097017221825, 0.19987580541018002, 0.1982742836075998, 0.20232902287035548, 0.21549470653930658, 0.1956528511432023, 0.19470244689323613, 0.19163201269367758, 0.09026911477367672, 0.08157396728414712, 0.08040263548785387, 0.10169920235869467, 0.09329863055769105, 0.08042568616649737, 0.09225225704511975, 0.09087158716078225, 0.09142552898529832, 0.08812384228656467, 0.07740182330151402, 0.07481705473372224, 0.08845921803734602, 0.07555254265945055, 0.08743650663516278, 0.08338805057740117, 0.07893684046715643, 0.07137968396637295, 0.8859085663761932, 0.9454352758127617, 0.9447338703491354, 0.9728882372091261, 0.9710223435836611, 0.9623044380360349, 0.9792118635058222, 0.9644140700689221, 0.9559350772016711, 0.1511248691981376, 0.15661032390099894, 0.14836089206652325, 0.1563215797922909, 0.16296807332157282, 0.1652872254879758, 0.16367555658599753, 0.16866848386033284, 0.1683364360321531, 0.20590549945845094, 0.19462411327698492, 0.19660794210908694, 0.20592452560287267, 0.19589443690860142, 0.2032348579659401, 0.22059606635286888, 0.20914851790056377, 0.19069009742277798, 0.14293568308267746, 0.13340253051778694, 0.13984578340694953, 0.14806986209761275, 0.15218098022406434, 0.14274451383864595, 0.14104922084725768, 0.13901066436095444, 0.15103421830879304, 0.16729361739953563, 0.1539450612931318, 0.14455632742488356, 0.15457918509478563, 0.15572336146392374, 0.15268260932749822, 0.1579654463133482, 0.1541819557381452, 0.16452282539750374, 0.19505350779887276, 0.17812731855166453, 0.18380459627837886, 0.18506044723442194, 0.17879499323905057, 0.19009804098796113, 0.1995589014344875, 0.172937417523497, 0.216961788367525, 0.2215062956513144, 0.21038601532689094, 0.21633241847362694, 0.19537258013878123, 0.1834924586422807, 0.22410866352783831, 0.18470928791271168, 0.19799245533054732, 0.20898755144268166, 0.15314873560122577, 0.10989400568037322, 0.13609008499803987, 0.1548541916635171, 0.1527157449683495, 0.13912916854726154, 0.12137875965878098, 0.192266998093237, 0.11206189766561803, 0.11722839589416378, 0.11485283116078593, 0.11837486495732807, 0.11426860892300406, 0.11839841540594387, 0.11991994022438335, 0.10835964724154323, 0.12387247471191765, 0.1234255884175498, 0.22890378645601828, 0.20971530388962312, 0.23051055551821598, 0.21534279783150834, 0.22708169966701952, 0.21083652156719856, 0.2119639137378997, 0.23641394323085785, 0.2183584018093837, 0.07925193607907932, 0.07925539523712466, 0.08743566275412995, 0.07941410259251058, 0.09217620624440825, 0.08840094840179569, 0.07325961855793661, 0.07346789780284013, 0.07781444093847423, 0.14526308664838927, 0.16873434065931636, 0.1405600911877498, 0.16621985798640104, 0.1566936632347128, 0.1383487681145138, 0.15604781989778205, 0.14571083891115066, 0.17015377928608466, 0.16415415728820393, 0.17276460212944966, 0.16155171546818325, 0.16687309210966428, 0.1637515084012917, 0.16712887781399954, 0.1731478618482435, 0.18561740560694717, 0.1790466086103163, 0.1428014354957633, 0.14261570901672327, 0.1349352637372393, 0.13714993437620782, 0.1362132314409782, 0.13353383184349055, 0.1486146876591623, 0.1538216774178771, 0.14433159451816702, 0.1603152500992221, 0.1551479611908253, 0.16637580387662054, 0.15732328469205736, 0.16096219972161707, 0.15625163966653888, 0.153418303192285, 0.17605193857851742, 0.20611872256715602, 0.16969039399418218, 0.17513383107814784, 0.18569601947502667, 0.18880610711060486, 0.18639271236678345, 0.17900329521818914, 0.17487358772643058, 0.1692558975964905, 0.17201222202867916, 0.1438791734937659, 0.16960890147542973, 0.14407369247328827, 0.1638249056242379, 0.21279199889605516, 0.15491901142232034, 0.1625307166438471, 0.17484461841760368, 0.24152372422727175, 0.15216707431378396, 0.14981825312153274, 0.16702280959471283, 0.1458725253670765, 0.16252304724815825, 0.2011184296180195, 0.19063537579060708, 0.185976195883079, 0.1790388791916766, 0.1882111913590787, 0.18177390984431496, 0.1812983959308193, 0.185471070556248, 0.19352301303598907, 0.19335132438059044, 0.18279893867943275, 0.18550724789718875, 0.17190201999375532, 0.0674361442918775, 0.08944349103244076, 0.07310659394406449, 0.06049962063065906, 0.06662121192370252, 0.06960939907094199, 0.057740172730803674, 0.06247718793274548, 0.07528646223555202]}, "mutation_prompt": null}
