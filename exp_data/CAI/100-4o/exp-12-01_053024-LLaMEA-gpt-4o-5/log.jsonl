{"id": "1718214e-93c1-4408-ae21-0360637aaee1", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(10, 5 * dim)  # Ensure a reasonable population size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant_vector = np.clip(x1 + self.mutation_factor * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n            # Simulated Annealing\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                candidate = new_population[i] + np.random.normal(0, 1, self.dim) * (self.temperature / 1000.0)\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.eval_count += 1\n                delta_fitness = candidate_fitness - fitness[i]\n                acceptance_prob = np.exp(-delta_fitness / self.temperature)\n                if candidate_fitness < fitness[i] or np.random.rand() < acceptance_prob:\n                    new_population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            # Update population and temperature\n            population[:] = new_population\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridOptimizer", "description": "A novel hybrid metaheuristic algorithm that combines Differential Evolution and Simulated Annealing for robust exploration and exploitation in black box optimization.", "configspace": "", "generation": 0, "fitness": 0.17475346735775557, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.23210692587659976, 0.24361966293844894, 0.24540496307025683, 0.2679554406287713, 0.25870316696432893, 0.27460656188053933, 0.28692960577658333, 0.25664837416938924, 0.26582727508931225, 0.292317642751605, 0.325660422376728, 0.34833619230022717, 0.33185468880561175, 0.34549823558327175, 0.3156544754070253, 0.3357688365660494, 0.30705675017403333, 0.29952235639747216, 0.07206672712992623, 0.06110008472999484, 0.07169312533689787, 0.06856202578736648, 0.07141482000399868, 0.0641383759022327, 0.07371056700596146, 0.06954552757597088, 0.06730536461682712, 0.08680237456200324, 0.053823558228313195, 0.05033879417680054, 0.049338069850767496, 0.06025376049571474, 0.055573146652495464, 0.07067833589260375, 0.0800033675520675, 0.04870674920847995, 0.8271405352911052, 0.870024847144306, 0.8219693354124682, 0.7978590287523597, 0.9091182846259952, 0.9682928650886253, 0.745136210369068, 0.743684246112922, 0.8817236066162202, 0.1522593079346709, 0.14321774593096126, 0.1741797739409865, 0.14299826990777253, 0.14218265264708352, 0.14700424829826786, 0.13640477304840792, 0.14231851626609338, 0.12955463248053178, 0.16101963989739143, 0.15607382818555104, 0.16138953328921035, 0.21355976448232383, 0.2101797688464233, 0.18361237285540355, 0.16663137793941585, 0.17638400275923793, 0.16618681467699403, 0.08327304090411802, 0.09470410748758662, 0.1110518538519204, 0.09288599779379436, 0.0877262175112361, 0.07199938113159898, 0.12060438680347252, 0.08394094693161092, 0.0901175814386046, 0.07693915332590717, 0.07027246849451985, 0.08072546259944735, 0.08113568494690349, 0.0854453542354946, 0.09771940777141186, 0.08524587981861387, 0.06954996322947626, 0.08498650313971612, 0.14993189018634834, 0.14059994802393683, 0.10613683775796012, 0.10356865896156486, 0.13452415431363585, 0.1155978875385868, 0.1257382004907629, 0.12178836454842712, 0.10816083582740343, 0.16135831579118276, 0.18040655705448294, 0.19690855658457518, 0.17955607316023559, 0.19530492457462667, 0.14689601367152572, 0.19748945155507613, 0.2121802493861833, 0.26599306063207195, 0.028635467458991704, 0.04009513591667835, 0.007535918378227535, 0.052564203594938186, 0.01632007845243677, 0.021151862686469625, 0.06529863492477872, 0.033593717497878095, 0.018173346822166758, 0.0244774569806947, 0.030519671880058774, 0.03617396649758098, 0.03344987256494025, 0.033434492510996505, 0.03546071238018944, 0.03464107246245074, 0.03069210249461629, 0.03557770342340716, 0.2560298243490915, 0.2556212903564081, 0.24250477377851098, 0.2681734027820225, 0.26129699309746435, 0.2656409493299068, 0.2500152369605624, 0.24025231217506737, 0.2588033551419813, 0.0767378823176661, 0.07998115344798606, 0.0774375489567094, 0.08067578744958359, 0.07075088607579305, 0.0723258528595323, 0.07191152195807027, 0.07749786200233322, 0.06460779076452561, 0.12486603109507743, 0.14962491873324346, 0.14296843415669014, 0.22296253957092083, 0.1359988343517201, 0.13997249225710662, 0.13770028702347314, 0.14070011573121888, 0.14672288817279044, 0.200285043583599, 0.18896016729480258, 0.20898435156823447, 0.18893825205979087, 0.18156775057204877, 0.1866604988746693, 0.19608540206557423, 0.20687508033437874, 0.20403429663962847, 0.129019314670616, 0.1427940266142539, 0.13056728960905917, 0.1321656646332412, 0.1256473401493824, 0.13986618455830013, 0.13562955963415713, 0.1376395664920783, 0.142181266011144, 0.19119998233269875, 0.17132611983075263, 0.18735302587781444, 0.17320634350222008, 0.18589240409275154, 0.1640184569982266, 0.18814776248716836, 0.18379811175882654, 0.19554151367252903, 0.16763974312872965, 0.17393416112448745, 0.167337899589733, 0.1836822857422008, 0.1777114961948013, 0.17612521538505244, 0.1718954766983597, 0.17085022656697457, 0.1721373628132391, 0.16032236340085015, 0.1590008745777335, 0.16057465277974048, 0.17117500238310623, 0.17899391220649774, 0.16655336555038358, 0.17022705499639523, 0.21570025560015593, 0.16581856935148676, 0.1577717294672446, 0.16358992047826193, 0.18236391970977306, 0.17403344811210986, 0.1627756251953677, 0.14857363600989903, 0.19177748054717025, 0.19000637136922205, 0.19256034458932025, 0.19174754864274468, 0.18152653225427695, 0.18159728153770316, 0.18437333049592797, 0.18765635110062417, 0.1866744189109264, 0.19033212900699914, 0.18615429666723593, 0.1872262276491613, 0.06888753212854282, 0.06774127714280964, 0.07194062365684017, 0.0674115609095507, 0.07446581218036608, 0.06237715481320971, 0.06392046529027307, 0.057476541742470744, 0.06505060809783969]}, "mutation_prompt": null}
{"id": "6fa75ac7-c932-4cf4-ac4d-3ec6f4d3a909", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(10, 5 * dim)  # Ensure a reasonable population size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = 1000.0\n        self.cooling_rate = 0.99\n        self.eval_count = 0\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            new_population = np.copy(population)\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant_vector = np.clip(x1 + self.mutation_factor * (x2 - x3), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                trial_vector = np.copy(population[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                # Selection\n                trial_fitness = func(trial_vector)\n                self.eval_count += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n            # Simulated Annealing\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n                candidate = new_population[i] + np.random.normal(0, 1, self.dim) * (self.temperature / 1000.0)\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.eval_count += 1\n                delta_fitness = candidate_fitness - fitness[i]\n                acceptance_prob = np.exp(-delta_fitness / self.temperature)\n                if candidate_fitness < fitness[i] or np.random.rand() < acceptance_prob:\n                    new_population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            # Update population and temperature\n            population[:] = new_population\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridOptimizer", "description": "A novel hybrid metaheuristic algorithm that combines Differential Evolution and Simulated Annealing for robust exploration and exploitation in black box optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1718214e-93c1-4408-ae21-0360637aaee1", "metadata": {"aucs": [0.23210692587659976, 0.24361966293844894, 0.24540496307025683, 0.2679554406287713, 0.25870316696432893, 0.27460656188053933, 0.28692960577658333, 0.25664837416938924, 0.26582727508931225, 0.292317642751605, 0.325660422376728, 0.34833619230022717, 0.33185468880561175, 0.34549823558327175, 0.3156544754070253, 0.3357688365660494, 0.30705675017403333, 0.29952235639747216, 0.07206672712992623, 0.06110008472999484, 0.07169312533689787, 0.06856202578736648, 0.07141482000399868, 0.0641383759022327, 0.07371056700596146, 0.06954552757597088, 0.06730536461682712, 0.08680237456200324, 0.053823558228313195, 0.05033879417680054, 0.049338069850767496, 0.06025376049571474, 0.055573146652495464, 0.07067833589260375, 0.0800033675520675, 0.04870674920847995, 0.8271405352911052, 0.870024847144306, 0.8219693354124682, 0.7978590287523597, 0.9091182846259952, 0.9682928650886253, 0.745136210369068, 0.743684246112922, 0.8817236066162202, 0.1522593079346709, 0.14321774593096126, 0.1741797739409865, 0.14299826990777253, 0.14218265264708352, 0.14700424829826786, 0.13640477304840792, 0.14231851626609338, 0.12955463248053178, 0.16101963989739143, 0.15607382818555104, 0.16138953328921035, 0.21355976448232383, 0.2101797688464233, 0.18361237285540355, 0.16663137793941585, 0.17638400275923793, 0.16618681467699403, 0.08327304090411802, 0.09470410748758662, 0.1110518538519204, 0.09288599779379436, 0.0877262175112361, 0.07199938113159898, 0.12060438680347252, 0.08394094693161092, 0.0901175814386046, 0.07693915332590717, 0.07027246849451985, 0.08072546259944735, 0.08113568494690349, 0.0854453542354946, 0.09771940777141186, 0.08524587981861387, 0.06954996322947626, 0.08498650313971612, 0.14993189018634834, 0.14059994802393683, 0.10613683775796012, 0.10356865896156486, 0.13452415431363585, 0.1155978875385868, 0.1257382004907629, 0.12178836454842712, 0.10816083582740343, 0.16135831579118276, 0.18040655705448294, 0.19690855658457518, 0.17955607316023559, 0.19530492457462667, 0.14689601367152572, 0.19748945155507613, 0.2121802493861833, 0.26599306063207195, 0.028635467458991704, 0.04009513591667835, 0.007535918378227535, 0.052564203594938186, 0.01632007845243677, 0.021151862686469625, 0.06529863492477872, 0.033593717497878095, 0.018173346822166758, 0.0244774569806947, 0.030519671880058774, 0.03617396649758098, 0.03344987256494025, 0.033434492510996505, 0.03546071238018944, 0.03464107246245074, 0.03069210249461629, 0.03557770342340716, 0.2560298243490915, 0.2556212903564081, 0.24250477377851098, 0.2681734027820225, 0.26129699309746435, 0.2656409493299068, 0.2500152369605624, 0.24025231217506737, 0.2588033551419813, 0.0767378823176661, 0.07998115344798606, 0.0774375489567094, 0.08067578744958359, 0.07075088607579305, 0.0723258528595323, 0.07191152195807027, 0.07749786200233322, 0.06460779076452561, 0.12486603109507743, 0.14962491873324346, 0.14296843415669014, 0.22296253957092083, 0.1359988343517201, 0.13997249225710662, 0.13770028702347314, 0.14070011573121888, 0.14672288817279044, 0.200285043583599, 0.18896016729480258, 0.20898435156823447, 0.18893825205979087, 0.18156775057204877, 0.1866604988746693, 0.19608540206557423, 0.20687508033437874, 0.20403429663962847, 0.129019314670616, 0.1427940266142539, 0.13056728960905917, 0.1321656646332412, 0.1256473401493824, 0.13986618455830013, 0.13562955963415713, 0.1376395664920783, 0.142181266011144, 0.19119998233269875, 0.17132611983075263, 0.18735302587781444, 0.17320634350222008, 0.18589240409275154, 0.1640184569982266, 0.18814776248716836, 0.18379811175882654, 0.19554151367252903, 0.16763974312872965, 0.17393416112448745, 0.167337899589733, 0.1836822857422008, 0.1777114961948013, 0.17612521538505244, 0.1718954766983597, 0.17085022656697457, 0.1721373628132391, 0.16032236340085015, 0.1590008745777335, 0.16057465277974048, 0.17117500238310623, 0.17899391220649774, 0.16655336555038358, 0.17022705499639523, 0.21570025560015593, 0.16581856935148676, 0.1577717294672446, 0.16358992047826193, 0.18236391970977306, 0.17403344811210986, 0.1627756251953677, 0.14857363600989903, 0.19177748054717025, 0.19000637136922205, 0.19256034458932025, 0.19174754864274468, 0.18152653225427695, 0.18159728153770316, 0.18437333049592797, 0.18765635110062417, 0.1866744189109264, 0.19033212900699914, 0.18615429666723593, 0.1872262276491613, 0.06888753212854282, 0.06774127714280964, 0.07194062365684017, 0.0674115609095507, 0.07446581218036608, 0.06237715481320971, 0.06392046529027307, 0.057476541742470744, 0.06505060809783969]}, "mutation_prompt": null}
