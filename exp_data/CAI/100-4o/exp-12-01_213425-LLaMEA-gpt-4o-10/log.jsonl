{"id": "4ab26b06-1dab-484f-90df-01891e4a4ca6", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "96c7b458-a801-4b57-8942-c2352118c550", "solution": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 30\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        self.harmony_memory_fitness = np.array([float('inf')] * self.harmony_memory_size)\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.iteration = 0\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / (np.abs(v)**(1 / beta))\n        return step\n\n    def __call__(self, func):\n        evals = 0\n        while evals < self.budget:\n            new_harmony = np.copy(self.harmony_memory[np.random.randint(self.harmony_memory_size)])\n            if np.random.rand() < 0.9:  # Harmony memory consideration rate\n                new_harmony += self.levy_flight() * 0.05  # small step size for Lévy flight\n            else:\n                new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n\n            new_fitness = func(new_harmony)\n            evals += 1\n\n            if new_fitness < np.max(self.harmony_memory_fitness):\n                worst_index = np.argmax(self.harmony_memory_fitness)\n                self.harmony_memory[worst_index] = new_harmony\n                self.harmony_memory_fitness[worst_index] = new_fitness\n\n            if new_fitness < self.best_fitness:\n                self.best_fitness = new_fitness\n                self.best_solution = new_harmony\n\n            self.iteration += 1\n\n        return self.best_solution", "name": "AdaptiveHarmonySearch", "description": "Adaptive Harmony Search with Lévy Flights for efficient exploration and exploitation in high-dimensional spaces.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "4ab26b06-1dab-484f-90df-01891e4a4ca6", "metadata": {}, "mutation_prompt": null}
