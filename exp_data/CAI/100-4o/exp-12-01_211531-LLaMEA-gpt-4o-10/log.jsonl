{"id": "d3679921-1f68-41ad-a401-f7b6166cf4ca", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 2*self.dim)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.cr = 0.9  # Crossover rate for DE\n        self.f = 0.8   # Mutation factor for DE\n\n    def differential_evolution_step(self, func):\n        new_population = np.copy(self.population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.bounds[0], self.bounds[1])\n            cross_points = np.random.rand(self.dim) < self.cr\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, self.population[i])\n            f_trial = func(trial)\n            self.eval_count += 1\n            if f_trial < self.fitness[i]:\n                new_population[i] = trial\n                self.fitness[i] = f_trial\n            if self.eval_count >= self.budget:\n                break\n        self.population = new_population\n\n    def nelder_mead_step(self, func):\n        sorted_indices = np.argsort(self.fitness)\n        self.population = self.population[sorted_indices]\n        self.fitness = self.fitness[sorted_indices]\n        \n        centroid = np.mean(self.population[:-1], axis=0)\n        reflected = np.clip(centroid + (centroid - self.population[-1]), self.bounds[0], self.bounds[1])\n        f_reflected = func(reflected)\n        self.eval_count += 1\n        \n        if f_reflected < self.fitness[0]:\n            expanded = np.clip(centroid + 2 * (centroid - self.population[-1]), self.bounds[0], self.bounds[1])\n            f_expanded = func(expanded)\n            self.eval_count += 1\n            if f_expanded < f_reflected:\n                self.population[-1] = expanded\n                self.fitness[-1] = f_expanded\n            else:\n                self.population[-1] = reflected\n                self.fitness[-1] = f_reflected\n        elif f_reflected < self.fitness[-2]:\n            self.population[-1] = reflected\n            self.fitness[-1] = f_reflected\n        else:\n            contracted = np.clip(centroid + 0.5 * (self.population[-1] - centroid), self.bounds[0], self.bounds[1])\n            f_contracted = func(contracted)\n            self.eval_count += 1\n            if f_contracted < self.fitness[-1]:\n                self.population[-1] = contracted\n                self.fitness[-1] = f_contracted\n            else:\n                self.population[1:] = self.population[0] + 0.5 * (self.population[1:] - self.population[0])\n                for i in range(1, self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.eval_count += 1\n                    if self.eval_count >= self.budget:\n                        break\n\n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                return self.population[np.argmin(self.fitness)]\n\n        while self.eval_count < self.budget:\n            self.differential_evolution_step(func)\n            self.nelder_mead_step(func)\n\n        return self.population[np.argmin(self.fitness)]", "name": "HybridOptimizer", "description": "A hybrid Differential Evolution and Adaptive Nelder-Mead algorithm that leverages global exploration and local exploitation for robust optimization.", "configspace": "", "generation": 0, "fitness": 0.42232222541123854, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.9448925308308312, 0.9403018339206448, 0.9482554237628217, 0.9380613358226718, 0.9497892497507414, 0.9378135718187842, 0.9458920026071874, 0.9440589172424478, 0.9423898827988316, 0.9019144004699162, 0.8967751287564056, 0.9007797979180112, 0.907142760162517, 0.8916817964509816, 0.9005301713511937, 0.9065416814134372, 0.903466477078225, 0.884444901797566, 0.08366550457109079, 0.13623731094596603, 0.09767681298909536, 0.14851853793429437, 0.0980483717969095, 0.12022456498936485, 0.06732143910747235, 0.14829118934965557, 0.13746220070084914, 0.08113734545926088, 0.11849086872609538, 0.0938150279501686, 0.0560729498669722, 0.0401847031158199, 0.1068675302557518, 0.1657942513630698, 0.08637369838754316, 0.04488460334071365, 0.9846439676355286, 0.9917819271634942, 0.9638755318557559, 0.9558163805882447, 0.9779859077263732, 0.9668572095266998, 0.986631814139031, 0.9828225315820966, 0.9835822104315428, 0.8350981068040157, 0.8251267911252291, 0.7991967148183003, 0.8870714769049849, 0.8036751792130744, 0.8398681845405978, 0.8673635847140883, 0.8220633038874827, 0.8036038457582942, 0.2169962591200537, 0.17056468584961149, 0.3299126881335753, 0.9575248047157894, 0.21451793998328805, 0.9495421716229275, 0.38808130740614044, 0.23865412448731171, 0.17574063601414747, 0.8984569235795797, 0.5409334510804039, 0.6837119545316785, 0.7490003945893507, 0.7320290914399601, 0.7035800112276848, 0.6994873410787437, 0.829105214040583, 0.8432702693349687, 0.7007172747195543, 0.7744741347691904, 0.7401672576291667, 0.8199260376162527, 0.6517376398301278, 0.8343058609374518, 0.710784659864075, 0.13658011291118677, 0.7523057253846163, 0.13892050462468797, 0.23210024279748764, 0.18616221440170755, 0.565718541878861, 0.5443802532943322, 0.14126126239679782, 0.6466271049021237, 0.5861263852198604, 0.08074460941459494, 0.2578580927894294, 0.37995918181977917, 0.20516243588926708, 0.08817419369216728, 0.11987954924192368, 0.10794193765784243, 0.43956698356447865, 0.3259406459593419, 0.8939334208185851, 9.999999999998899e-05, 0.32586257267393515, 0.2154867501388048, 0.23541466978542902, 0.499797610368637, 0.3341410428302348, 0.5022160537827864, 0.4265295675134223, 0.19183333616292975, 0.4487150469465251, 9.999999999998899e-05, 0.4413836198197223, 0.34909975571289453, 0.6006518135455452, 0.6410599153095808, 0.34939288336473195, 0.4533322065129588, 0.38803704009233886, 0.8581853591756392, 0.7216494381682335, 0.8504470342645475, 0.6386894711764404, 0.8088250208907241, 0.7209048923508595, 0.6455019755195921, 0.812525861308, 0.8992527453738011, 0.13641098642121563, 0.07047332908240045, 0.07576588146363195, 0.10777744688438651, 0.12014323262425164, 0.0506985614804073, 0.13716170577506714, 0.07123507280097563, 0.10782555089093115, 0.2906246377936592, 0.15612026585591554, 0.1403908034974518, 0.2952130210841446, 0.16260616531712535, 0.1755162664554042, 0.21807720182115287, 0.3301253994215051, 0.3110166121733865, 0.27656862468526167, 0.3123713655861986, 0.26732009341040164, 0.20624626423452408, 0.20078669354847267, 0.23771789761029105, 0.16244474196501402, 0.17295571876849558, 0.1742028730473707, 0.1406395393321136, 0.21790211139119697, 0.10858750867499167, 0.09738406245826703, 0.2458937793421765, 0.2637174970253121, 0.19159964230909554, 0.26365362810115367, 0.19054919128622683, 0.200681061084805, 0.22195191893970245, 0.18732926520799198, 0.26817120541649475, 0.17104298623439085, 0.22096859095065935, 0.23295634227958006, 0.16763395090085997, 0.21500075948133468, 0.17939913386445983, 0.1839605000726935, 0.1956728482624328, 0.18688620741053208, 0.2565484456380157, 0.1878563003815632, 0.16938055603630164, 0.1762055421267541, 0.23084089477339798, 0.9607031866515614, 0.11993147467489418, 0.1882194877395077, 0.11718480046133939, 0.18883411484673984, 0.16929172325417408, 0.9641304822594505, 0.9526752726814447, 0.17916010811354555, 0.9276416677876546, 0.16925498663500005, 0.9684961477976978, 0.16971270152371598, 0.16870634697532694, 0.12868614888142815, 0.1695263160535464, 0.0949103810399633, 0.15727425548018759, 0.28242227338272285, 0.24373444282663215, 0.21912560570404116, 0.22755313997519444, 0.23461346651559478, 0.790489998057683, 0.21462679974390309, 0.28014889494314454, 0.2648570499797144, 0.11100740242013274, 0.1030311524235421, 0.10225344303413708, 0.11914533624604262, 0.0931747368940965, 0.09597904081191355, 0.10985244023426144, 0.0787282218235199, 0.08174310000538809]}, "mutation_prompt": null}
{"id": "34b6482d-e279-42f9-9400-a809517444da", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.eval_count = 0\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 2*self.dim)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.cr = 0.9  # Crossover rate for DE\n        self.f = 0.8   # Mutation factor for DE\n    \n    def adaptive_population_resize(self):\n        if self.eval_count < self.budget // 2:\n            self.population_size = max(10, int(self.population_size * 1.1))\n        else:\n            self.population_size = max(10, int(self.population_size * 0.9))\n        self.population = self.population[:self.population_size]\n        self.fitness = self.fitness[:self.population_size]\n\n    def dynamic_mutation_factor(self):\n        self.f = 0.5 + 0.3 * np.random.rand()\n\n    def differential_evolution_step(self, func):\n        new_population = np.copy(self.population)\n        for i in range(self.population_size):\n            idxs = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.bounds[0], self.bounds[1])\n            cross_points = np.random.rand(self.dim) < self.cr\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, self.population[i])\n            f_trial = func(trial)\n            self.eval_count += 1\n            if f_trial < self.fitness[i]:\n                new_population[i] = trial\n                self.fitness[i] = f_trial\n            if self.eval_count >= self.budget:\n                break\n        self.population = new_population\n\n    def nelder_mead_step(self, func):\n        sorted_indices = np.argsort(self.fitness)\n        self.population = self.population[sorted_indices]\n        self.fitness = self.fitness[sorted_indices]\n        \n        centroid = np.mean(self.population[:-1], axis=0)\n        reflected = np.clip(centroid + (centroid - self.population[-1]), self.bounds[0], self.bounds[1])\n        f_reflected = func(reflected)\n        self.eval_count += 1\n        \n        if f_reflected < self.fitness[0]:\n            expanded = np.clip(centroid + 2 * (centroid - self.population[-1]), self.bounds[0], self.bounds[1])\n            f_expanded = func(expanded)\n            self.eval_count += 1\n            if f_expanded < f_reflected:\n                self.population[-1] = expanded\n                self.fitness[-1] = f_expanded\n            else:\n                self.population[-1] = reflected\n                self.fitness[-1] = f_reflected\n        elif f_reflected < self.fitness[-2]:\n            self.population[-1] = reflected\n            self.fitness[-1] = f_reflected\n        else:\n            contracted = np.clip(centroid + 0.5 * (self.population[-1] - centroid), self.bounds[0], self.bounds[1])\n            f_contracted = func(contracted)\n            self.eval_count += 1\n            if f_contracted < self.fitness[-1]:\n                self.population[-1] = contracted\n                self.fitness[-1] = f_contracted\n            else:\n                self.population[1:] = self.population[0] + 0.5 * (self.population[1:] - self.population[0])\n                for i in range(1, self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.eval_count += 1\n                    if self.eval_count >= self.budget:\n                        break\n\n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.eval_count += 1\n            if self.eval_count >= self.budget:\n                return self.population[np.argmin(self.fitness)]\n\n        while self.eval_count < self.budget:\n            self.dynamic_mutation_factor()\n            self.differential_evolution_step(func)\n            self.nelder_mead_step(func)\n            self.adaptive_population_resize()\n\n        return self.population[np.argmin(self.fitness)]", "name": "HybridOptimizer", "description": "Integrates a dynamic mutation factor and adaptive population resizing in the hybrid optimizer for enhanced exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_id": "d3679921-1f68-41ad-a401-f7b6166cf4ca", "metadata": {}, "mutation_prompt": null}
