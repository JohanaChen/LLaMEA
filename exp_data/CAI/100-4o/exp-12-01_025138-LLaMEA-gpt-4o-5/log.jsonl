{"id": "61b95111-0ef6-43af-920b-ac28eb58bc0c", "solution": "import numpy as np\n\nclass HybridDEASA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Population size for Differential Evolution\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self evaluations = 0\n\n    def _differential_evolution(self, target_idx):\n        a, b, c = self.population[np.random.choice(self.population_size, 3, replace=False)]\n        F = np.random.uniform(0.5, 1.0)  # Mutation factor\n        mutant = np.clip(a + F * (b - c), -5.0, 5.0)\n        \n        crossover_rate = np.random.uniform(0.1, 0.9)\n        crossover = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n\n        trial = np.where(crossover, mutant, self.population[target_idx])\n        return trial\n\n    def _adaptive_simulated_annealing(self, trial, current_fitness):\n        T = max(1.0, (self.budget - self.evaluations) / self.budget * 100)\n        trial_fitness = func(trial)\n        acceptance_probability = np.exp((current_fitness - trial_fitness) / T)\n        \n        if trial_fitness < self.best_fitness:\n            self.best_solution = trial\n            self.best_fitness = trial_fitness\n        \n        return trial_fitness, acceptance_probability\n    \n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                trial = self._differential_evolution(i)\n                current_fitness = func(self.population[i])\n                self.evaluations += 1\n                \n                trial_fitness, acceptance_probability = self._adaptive_simulated_annealing(trial, current_fitness)\n                self.evaluations += 1\n\n                if trial_fitness < current_fitness or np.random.rand() < acceptance_probability:\n                    self.population[i] = trial\n            \n            if self.evaluations >= self.budget:\n                break\n        \n        return self.best_solution, self.best_fitness", "name": "HybridDEASA", "description": "A hybrid differential evolution and adaptive simulated annealing algorithm that balances exploration and exploitation by dynamically adjusting mutation and crossover rates.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 11\n    self evaluations = 0\n         ^\nSyntaxError: invalid syntax\n.", "error": "SyntaxError('invalid syntax', ('<string>', 11, 14, '        self evaluations = 0\\n'))Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 11\n    self evaluations = 0\n         ^\nSyntaxError: invalid syntax\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "a0b0ef36-5e34-40e2-a82f-a6572671e7d6", "solution": "import numpy as np\n\nclass HybridDEASA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Population size for Differential Evolution\n        self.population = np.random.uniform(-5.0, 5.0, (self.population_size, self.dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.evaluations = 0\n\n    def _differential_evolution(self, target_idx):\n        a, b, c = self.population[np.random.choice(self.population_size, 3, replace=False)]\n        F = 0.8  # Mutation factor (changed from random uniform to a fixed value)\n        mutant = np.clip(a + F * (b - c), -5.0, 5.0)\n        \n        crossover_rate = np.random.uniform(0.1, 0.9)\n        crossover = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n\n        trial = np.where(crossover, mutant, self.population[target_idx])\n        return trial\n\n    def _adaptive_simulated_annealing(self, trial, current_fitness):\n        T = max(1.0, 0.1 * (self.budget - self.evaluations) / self.budget * 100)  # Adjusted temperature schedule\n        trial_fitness = func(trial)\n        acceptance_probability = np.exp((current_fitness - trial_fitness) / T)\n        \n        if trial_fitness < self.best_fitness:\n            self.best_solution = trial\n            self.best_fitness = trial_fitness\n        \n        return trial_fitness, acceptance_probability\n    \n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                trial = self._differential_evolution(i)\n                current_fitness = func(self.population[i])\n                self.evaluations += 1\n                \n                trial_fitness, acceptance_probability = self._adaptive_simulated_annealing(trial, current_fitness)\n                self.evaluations += 1\n\n                if trial_fitness < current_fitness or np.random.rand() < acceptance_probability:\n                    self.population[i] = trial\n            \n            if self.evaluations >= self.budget:\n                break\n        \n        return self.best_solution, self.best_fitness", "name": "HybridDEASA", "description": "A hybrid differential evolution and adaptive simulated annealing algorithm with refined mutation factor and dynamic temperature scheduling.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "61b95111-0ef6-43af-920b-ac28eb58bc0c", "metadata": {}, "mutation_prompt": null}
