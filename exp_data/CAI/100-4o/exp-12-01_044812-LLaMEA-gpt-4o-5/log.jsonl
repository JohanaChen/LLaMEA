{"id": "65ca6ad7-1c61-4097-b4be-89baaca980d1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionOBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def opposition_based_learning(self, population):\n        opp_population = self.lower_bound + self.upper_bound - population\n        return opp_population\n\n    def mutation(self, population, best_idx):\n        indices = np.arange(self.population_size)\n        np.random.shuffle(indices)\n        for i in range(self.population_size):\n            x = population[i]\n            a, b, c = population[indices[i:i+3]]\n            mutant = a + self.F * (b - c)\n            mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n            yield x, mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, trial, target, trial_fitness, target_fitness):\n        if trial_fitness < target_fitness:\n            return trial, trial_fitness\n        else:\n            return target, target_fitness\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        opp_population = self.opposition_based_learning(population)\n        opp_fitness = self.evaluate_population(opp_population, func)\n        self.evaluations += self.population_size\n\n        merge_population = np.vstack((population, opp_population))\n        merge_fitness = np.concatenate((fitness, opp_fitness))\n\n        order = np.argsort(merge_fitness)\n        population = merge_population[order[:self.population_size]]\n        fitness = merge_fitness[order[:self.population_size]]\n\n        best_idx = np.argmin(fitness)\n\n        while self.evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for target, mutant in self.mutation(population, best_idx):\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                new_individual, new_fitness_value = self.select(trial, target, trial_fitness, fitness[best_idx])\n                new_population.append(new_individual)\n                new_fitness.append(new_fitness_value)\n\n                if self.evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            best_idx = np.argmin(fitness)\n\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolutionOBL", "description": "Adaptive Differential Evolution with Opposition-Based Learning to enhance exploration and convergence in high-dimensional optimization.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 67, in __call__\n  File \"<string>\", line 29, in mutation\nValueError: not enough values to unpack (expected 3, got 2)\n.", "error": "ValueError('not enough values to unpack (expected 3, got 2)')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 67, in __call__\n  File \"<string>\", line 29, in mutation\nValueError: not enough values to unpack (expected 3, got 2)\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "058ad1ad-0d91-4c61-b7b3-211bf6ffd46a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionOBL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def opposition_based_learning(self, population):\n        opp_population = self.lower_bound + self.upper_bound - population\n        return opp_population\n\n    def mutation(self, population, best_idx):\n        indices = np.arange(self.population_size)\n        np.random.shuffle(indices)\n        for i in range(self.population_size):\n            x = population[i]\n            a, b, c = population[indices[i:i+3]]\n            dynamic_F = self.F + np.random.rand() * 0.1  # Line changed for dynamic F adjustment\n            mutant = a + dynamic_F * (b - c)  # Line changed to use dynamic_F\n            mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n            yield x, mutant\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.CR\n        trial = np.where(crossover_mask, mutant, target)\n        return trial\n\n    def select(self, trial, target, trial_fitness, target_fitness):\n        if trial_fitness < target_fitness:\n            return trial, trial_fitness\n        else:\n            return target, target_fitness\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = self.evaluate_population(population, func)\n        self.evaluations += self.population_size\n\n        opp_population = self.opposition_based_learning(population)\n        opp_fitness = self.evaluate_population(opp_population, func)\n        self.evaluations += self.population_size\n\n        merge_population = np.vstack((population, opp_population))\n        merge_fitness = np.concatenate((fitness, opp_fitness))\n\n        order = np.argsort(merge_fitness)\n        population = merge_population[order[:self.population_size]]\n        fitness = merge_fitness[order[:self.population_size]]\n\n        best_idx = np.argmin(fitness)\n\n        while self.evaluations < self.budget:\n            new_population = []\n            new_fitness = []\n\n            for target, mutant in self.mutation(population, best_idx):\n                trial = self.crossover(target, mutant)\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                new_individual, new_fitness_value = self.select(trial, target, trial_fitness, fitness[best_idx])\n                new_population.append(new_individual)\n                new_fitness.append(new_fitness_value)\n\n                if self.evaluations >= self.budget:\n                    break\n\n            population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            best_idx = np.argmin(fitness)\n\n        return population[best_idx], fitness[best_idx]", "name": "AdaptiveDifferentialEvolutionOBL", "description": "Improved Adaptive Differential Evolution with dynamic scaling factor adjustment for enhanced exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('not enough values to unpack (expected 3, got 2)').", "error": "ValueError('not enough values to unpack (expected 3, got 2)')", "parent_id": "65ca6ad7-1c61-4097-b4be-89baaca980d1", "metadata": {}, "mutation_prompt": null}
