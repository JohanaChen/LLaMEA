{"id": "18721d01-4930-41b3-a033-696d9919626f", "solution": "import numpy as np\n\nclass PSO_ADE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.particles = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n\n    def __call__(self, func):\n        self._initialize_particles()\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # PSO Update\n                r1, r2 = np.random.uniform(0, 1, 2)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.particles[i]))\n                self.particles[i] = np.clip(self.particles[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # Evaluate particle\n                score = func(self.particles[i])\n                evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n                # ADE Update (Mutation and Crossover)\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(self.particles[a] + self.F * (self.particles[b] - self.particles[c]), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Evaluate trial vector\n                trial_score = func(trial)\n                evals += 1\n                if trial_score < score:\n                    self.particles[i] = trial\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n                if evals >= self.budget:\n                    break\n\n        return self.global_best_position, self.global_best_score\n\n    def _initialize_particles(self):\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        for i in range(self.population_size):\n            score = func(self.particles[i])\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i]", "name": "PSO_ADE_Optimizer", "description": "The algorithm combines a modified Particle Swarm Optimization (PSO) with Adaptive Differential Evolution (ADE) to dynamically balance exploration and exploitation based on the population's diversity.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 23, in __call__\n  File \"<string>\", line 78, in _initialize_particles\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 23, in __call__\n  File \"<string>\", line 78, in _initialize_particles\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "57d58c44-7c63-4fbe-9196-7a9c3af9284f", "solution": "import numpy as np\n\nclass PSO_ADE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.particles = None\n        self.velocities = None\n        self.personal_best_positions = None\n        self.personal_best_scores = None\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive parameter for PSO\n        self.c2 = 1.5  # Social parameter for PSO\n\n    def __call__(self, func):\n        self._initialize_particles()\n\n        evals = 0\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # PSO Update\n                r1, r2 = np.random.uniform(0, 1, 2)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.particles[i]))\n                self.particles[i] = np.clip(self.particles[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                # Evaluate particle\n                score = func(self.particles[i])\n                evals += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n                # ADE Update (Mutation and Crossover)\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = np.random.choice(idxs, 3, replace=False)\n                mutant = np.clip(self.particles[a] + self.F * (self.particles[b] - self.particles[c]), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                jrand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == jrand:\n                        trial[j] = mutant[j]\n\n                # Evaluate trial vector\n                trial_score = func(trial)\n                evals += 1\n                if trial_score < score:\n                    self.particles[i] = trial\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n                if evals >= self.budget:\n                    break\n\n        return self.global_best_position, self.global_best_score\n\n    def _initialize_particles(self):\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        for i in range(self.population_size):\n            score = func(self.particles[i])\n            if score < self.personal_best_scores[i]:\n                self.personal_best_scores[i] = score\n                self.personal_best_positions[i] = self.particles[i]\n            if score < self.global_best_score:\n                self.global_best_score = score\n                self.global_best_position = self.particles[i]", "name": "PSO_ADE_Optimizer", "description": "The algorithm combines a modified Particle Swarm Optimization (PSO) with Adaptive Differential Evolution (ADE) to dynamically balance exploration and exploitation based on the population's diversity.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "18721d01-4930-41b3-a033-696d9919626f", "metadata": {}, "mutation_prompt": null}
