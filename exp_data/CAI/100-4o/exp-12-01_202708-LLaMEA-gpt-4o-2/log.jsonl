{"id": "c5abfd5b-0664-4c78-bac7-633887af3cd9", "solution": "import numpy as np\n\nclass ADE_CM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.memory = []\n        self.bounds = (-5.0, 5.0)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct random indices\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((trial, trial_fitness))\n\n                    # Adaptive Update of F and CR based on memory\n                    if len(self.memory) > 10:\n                        self.memory.pop(0)\n                    self.F = np.mean([f for _, f in self.memory if f < np.median(fitness)])\n                    self.CR = 0.9  # Could be dynamically adjusted similarly\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "ADE_CM", "description": "Adaptive Differential Evolution with a Coevolutionary Memory (ADE-CM), which combines adaptive mechanisms with a memory bank of historically high-performing individuals to enhance exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.09144705030356524, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.11860917256239134, 0.08099573939876026, 0.09160418974405926, 0.126189596904413, 0.18592195432878666, 0.11033114211644335, 0.16369380424818814, 0.13397240725520754, 0.13371300085333826, 0.0, 0.0, 0.0, 0.0, 0.0, 9.999999999998899e-05, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.005275638633511659, 0.0358424647372374, 0.02863856899714301, 0.045718433068475006, 0.025419800163315243, 0.03977661585195802, 0.024542148255458418, 0.0, 0.0, 0.007213407006312789, 0.019501673109847073, 0.029727230050641817, 0.04457789367258269, 0.014664865741570776, 0.004564756744937615, 0.0, 0.9929787416295373, 0.9832689684183942, 0.9841746577478758, 0.9892665937505075, 0.9944647926828015, 0.9799450536019554, 0.9946974019393443, 0.9816127759771521, 0.9896175974022832, 0.06265423285318028, 0.02170728884471118, 0.0, 0.0, 0.00021551809509057218, 0.0, 0.0, 0.011194453811883665, 0.0, 0.1058541887381389, 0.12273007333177632, 0.06563509663062794, 0.11627311761654058, 0.07275849405212176, 0.007174666965020671, 0.04307781411060496, 0.05921649636366422, 0.08993191051910976, 0.0, 0.0, 9.999999999998899e-05, 0.0, 9.999999999998899e-05, 0.0, 0.0, 9.999999999998899e-05, 0.0, 0.0, 0.009234898781166345, 0.0, 9.999999999998899e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0024443276160555083, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1160962639054296, 0.1617195669707524, 0.14829537673711235, 0.15871977244349322, 0.11392186449868491, 0.09571399605654929, 0.16104568613219816, 0.10481874109280909, 0.12096781838999704, 0.025540048930293602, 0.0, 0.02307879996704776, 0.05081394302838127, 0.010259798852995328, 0.01750168379108641, 0.02248596960441296, 0.0, 0.055199212778905715, 0.12633315659761024, 0.12568368211476721, 0.12497861975762936, 0.10070552382314069, 0.10844057434014054, 0.10789794917811235, 0.08799080449358843, 0.08090029113184061, 0.07717165476235788, 0.09597227240618145, 0.14227920676029848, 0.16800569092974127, 0.13792052181394154, 0.1137187550761597, 0.1043582676218151, 0.12366182814551341, 0.1811998712930084, 0.12375744204765471, 0.05976163112617183, 0.05383138570261603, 0.11723169321705151, 0.08606363447235021, 0.06397588396999399, 0.06333484497577424, 0.10323662696044544, 0.09968109929815638, 0.08556071035006807, 0.11934558904189341, 0.09379139630447497, 0.13336421106438578, 0.11026790024335642, 0.14239340091783237, 0.13899976076770726, 0.13939729137192258, 0.07863718186214741, 0.126108974692136, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858711, 0.07457348599177183, 0.08157840845421893, 0.07318573935631267, 0.12648397556946334, 0.09505743923273402, 0.1094962893999335, 0.11217221805297473, 0.0692681884498908, 0.1103137036995071, 0.10548936194754055, 0.06922728298844572, 0.0505908534635271, 0.03728632333816151, 0.05893840155280994, 0.04680845216491614, 0.21172913457976006, 0.16105339406578423, 0.1603626458340336, 0.17027842747095745, 0.16360257345435913, 0.14982945073441456, 0.14995872319338066, 0.13224602528921636, 0.15994599135064202, 0.13668726249589913, 0.14680476350940785, 0.03529398082427038, 0.01581797651086858, 0.03129662407793543, 0.02691798931623468, 0.03415436066354671, 0.019947514614564676, 0.01612999899170031, 0.039064729494059036, 0.017545586508041167]}, "mutation_prompt": null}
{"id": "7a390b8f-0596-413a-8b0d-bc269eec671b", "solution": "import numpy as np\n\nclass ADE_CM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.memory = []\n        self.bounds = (-5.0, 5.0)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct random indices\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                while i in indices:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n\n                # Mutation\n                mutant = a + self.F * (b - c)\n                mutant = np.clip(mutant, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.memory.append((trial, trial_fitness))\n\n                    # Adaptive Update of F and CR based on memory\n                    if len(self.memory) > 10:\n                        self.memory.pop(0)\n                    self.F = np.mean([f for _, f in self.memory if f < np.median(fitness)])\n                    self.CR = 0.9  # Could be dynamically adjusted similarly\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return population[best_idx]", "name": "ADE_CM", "description": "Adaptive Differential Evolution with a Coevolutionary Memory (ADE-CM), which combines adaptive mechanisms with a memory bank of historically high-performing individuals to enhance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c5abfd5b-0664-4c78-bac7-633887af3cd9", "metadata": {"aucs": [0.11860917256239134, 0.08099573939876026, 0.09160418974405926, 0.126189596904413, 0.18592195432878666, 0.11033114211644335, 0.16369380424818814, 0.13397240725520754, 0.13371300085333826, 0.0, 0.0, 0.0, 0.0, 0.0, 9.999999999998899e-05, 0.0, 0.0, 0.0, 0.0, 0.014572254733962287, 0.005275638633511659, 0.0358424647372374, 0.02863856899714301, 0.045718433068475006, 0.025419800163315243, 0.03977661585195802, 0.024542148255458418, 0.0, 0.0, 0.007213407006312789, 0.019501673109847073, 0.029727230050641817, 0.04457789367258269, 0.014664865741570776, 0.004564756744937615, 0.0, 0.9929787416295373, 0.9832689684183942, 0.9841746577478758, 0.9892665937505075, 0.9944647926828015, 0.9799450536019554, 0.9946974019393443, 0.9816127759771521, 0.9896175974022832, 0.06265423285318028, 0.02170728884471118, 0.0, 0.0, 0.00021551809509057218, 0.0, 0.0, 0.011194453811883665, 0.0, 0.1058541887381389, 0.12273007333177632, 0.06563509663062794, 0.11627311761654058, 0.07275849405212176, 0.007174666965020671, 0.04307781411060496, 0.05921649636366422, 0.08993191051910976, 0.0, 0.0, 9.999999999998899e-05, 0.0, 9.999999999998899e-05, 0.0, 0.0, 9.999999999998899e-05, 0.0, 0.0, 0.009234898781166345, 0.0, 9.999999999998899e-05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0024443276160555083, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1160962639054296, 0.1617195669707524, 0.14829537673711235, 0.15871977244349322, 0.11392186449868491, 0.09571399605654929, 0.16104568613219816, 0.10481874109280909, 0.12096781838999704, 0.025540048930293602, 0.0, 0.02307879996704776, 0.05081394302838127, 0.010259798852995328, 0.01750168379108641, 0.02248596960441296, 0.0, 0.055199212778905715, 0.12633315659761024, 0.12568368211476721, 0.12497861975762936, 0.10070552382314069, 0.10844057434014054, 0.10789794917811235, 0.08799080449358843, 0.08090029113184061, 0.07717165476235788, 0.09597227240618145, 0.14227920676029848, 0.16800569092974127, 0.13792052181394154, 0.1137187550761597, 0.1043582676218151, 0.12366182814551341, 0.1811998712930084, 0.12375744204765471, 0.05976163112617183, 0.05383138570261603, 0.11723169321705151, 0.08606363447235021, 0.06397588396999399, 0.06333484497577424, 0.10323662696044544, 0.09968109929815638, 0.08556071035006807, 0.11934558904189341, 0.09379139630447497, 0.13336421106438578, 0.11026790024335642, 0.14239340091783237, 0.13899976076770726, 0.13939729137192258, 0.07863718186214741, 0.126108974692136, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.05559179745858711, 0.07457348599177183, 0.08157840845421893, 0.07318573935631267, 0.12648397556946334, 0.09505743923273402, 0.1094962893999335, 0.11217221805297473, 0.0692681884498908, 0.1103137036995071, 0.10548936194754055, 0.06922728298844572, 0.0505908534635271, 0.03728632333816151, 0.05893840155280994, 0.04680845216491614, 0.21172913457976006, 0.16105339406578423, 0.1603626458340336, 0.17027842747095745, 0.16360257345435913, 0.14982945073441456, 0.14995872319338066, 0.13224602528921636, 0.15994599135064202, 0.13668726249589913, 0.14680476350940785, 0.03529398082427038, 0.01581797651086858, 0.03129662407793543, 0.02691798931623468, 0.03415436066354671, 0.019947514614564676, 0.01612999899170031, 0.039064729494059036, 0.017545586508041167]}, "mutation_prompt": null}
