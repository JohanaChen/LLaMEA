{"id": "2110b04f-9453-487c-8205-be7be9023ab9", "solution": "import numpy as np\n\nclass ACMESR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.sigma = 0.3  # initial step size\n        self.population_size = 4 + int(3 * np.log(dim))\n        self.weights = np.log(self.population_size + 0.5) - np.log(np.arange(1, self.population_size + 1))\n        self.weights /= np.sum(self.weights)\n        self.mu_eff = 1. / np.sum(self.weights**2)\n        self.covariance_matrix = np.eye(dim)\n        self.mean = np.random.uniform(self.lower_bound, self.upper_bound, dim)\n        self.lambda_ = self.population_size\n        self.cs = (self.mu_eff + 2) / (dim + self.mu_eff + 5)\n        self.ds = 1 + 2 * max(0, np.sqrt((self.mu_eff - 1) / (dim + 1)) - 1) + self.cs\n        self.cc = (4 + self.mu_eff / dim) / (dim + 4 + 2 * self.mu_eff / dim)\n        self.c1 = 2 / ((dim + 1.3)**2 + self.mu_eff)\n        self.cmu = min(1 - self.c1, 2 * (self.mu_eff - 2 + 1 / self.mu_eff) / ((dim + 2)**2 + self.mu_eff))\n        self.pc = np.zeros(dim)\n        self.ps = np.zeros(dim)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_solution = None\n        best_fitness = float('inf')\n        \n        while eval_count < self.budget:\n            # Generate offspring\n            population = np.random.multivariate_normal(self.mean, self.sigma**2 * self.covariance_matrix, self.lambda_)\n            population = np.clip(population, self.lower_bound, self.upper_bound)\n            fitness_values = np.array([func(ind) for ind in population])\n            eval_count += self.lambda_\n\n            # Sort by fitness\n            indices = np.argsort(fitness_values)\n            population = population[indices]\n            fitness_values = fitness_values[indices]\n\n            # Update best solution found\n            if fitness_values[0] < best_fitness:\n                best_fitness = fitness_values[0]\n                best_solution = population[0]\n\n            # Update evolution paths\n            artmp = (population[:self.lambda_ // 2] - self.mean) / self.sigma\n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mu_eff) * np.mean(artmp, axis=0)\n            hsig = np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * eval_count / self.lambda_)) < (1.4 + 2 / (dim + 1))\n            self.pc = (1 - self.cc) * self.pc + hsig * np.sqrt(self.cc * (2 - self.cc) * self.mu_eff) * np.mean(artmp, axis=0)\n\n            # Update covariance matrix\n            rank_one = np.outer(self.pc, self.pc)\n            rank_mu = np.dot((self.weights * artmp.T), artmp)\n            self.covariance_matrix = (1 - self.c1 - self.cmu) * self.covariance_matrix + self.c1 * rank_one + self.cmu * rank_mu\n\n            # Update step-size\n            self.sigma *= np.exp((self.cs / self.ds) * (np.linalg.norm(self.ps) / np.sqrt(dim) - 1))\n\n            # Update mean\n            self.mean = np.dot(self.weights, population[:self.lambda_ // 2])\n\n            # Restart mechanism\n            if eval_count + self.population_size > self.budget:\n                break\n\n        return best_solution", "name": "ACMESR", "description": "Adaptive Covariance Matrix Evolution Strategy with Restart Mechanism (ACMES-R) to efficiently explore diverse search spaces by adapting mutation strategies and restarting upon stagnation.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 50, in __call__\nNameError: name 'dim' is not defined\n.", "error": "NameError(\"name 'dim' is not defined\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 50, in __call__\nNameError: name 'dim' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "e0945fdf-58dd-4651-a79b-48623aa57fd4", "solution": "import numpy as np\n\nclass HCMAAR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.sigma = 0.3\n        self.population_size = 4 + int(3 * np.log(dim))\n        self.weights = np.log(self.population_size + 0.5) - np.log(np.arange(1, self.population_size + 1))\n        self.weights /= np.sum(self.weights)\n        self.mu_eff = 1. / np.sum(self.weights**2)\n        self.covariance_matrix = np.eye(dim)\n        self.mean = np.random.uniform(self.lower_bound, self.upper_bound, dim)\n        self.lambda_ = self.population_size\n        self.cs = (self.mu_eff + 2) / (dim + self.mu_eff + 5)\n        self.ds = 1 + 2 * max(0, np.sqrt((self.mu_eff - 1) / (dim + 1)) - 1) + self.cs\n        self.cc = (4 + self.mu_eff / dim) / (dim + 4 + 2 * self.mu_eff / dim)\n        self.c1 = 2 / ((dim + 1.3)**2 + self.mu_eff)\n        self.cmu = min(1 - self.c1, 2 * (self.mu_eff - 2 + 1 / self.mu_eff) / ((dim + 2)**2 + self.mu_eff))\n        self.pc = np.zeros(dim)\n        self.ps = np.zeros(dim)\n        self.de_factor = 0.5  # Differential Evolution factor\n        self.cr = 0.9  # Crossover rate for DE\n\n    def __call__(self, func):\n        eval_count = 0\n        best_solution = None\n        best_fitness = float('inf')\n        \n        while eval_count < self.budget:\n            population = np.random.multivariate_normal(self.mean, self.sigma**2 * self.covariance_matrix, self.lambda_)\n            population = np.clip(population, self.lower_bound, self.upper_bound)\n            fitness_values = np.array([func(ind) for ind in population])\n            eval_count += self.lambda_\n\n            indices = np.argsort(fitness_values)\n            population = population[indices]\n            fitness_values = fitness_values[indices]\n\n            if fitness_values[0] < best_fitness:\n                best_fitness = fitness_values[0]\n                best_solution = population[0]\n\n            for i in range(self.lambda_):\n                a, b, c = np.random.choice(self.lambda_, 3, replace=False)\n                mutant = np.clip(population[a] + self.de_factor * (population[b] - population[c]), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness_values[i]:\n                    population[i] = trial\n                    fitness_values[i] = trial_fitness\n\n            artmp = (population[:self.lambda_ // 2] - self.mean) / self.sigma\n            self.ps = (1 - self.cs) * self.ps + np.sqrt(self.cs * (2 - self.cs) * self.mu_eff) * np.mean(artmp, axis=0)\n            hsig = np.linalg.norm(self.ps) / np.sqrt(1 - (1 - self.cs)**(2 * eval_count / self.lambda_)) < (1.4 + 2 / (self.dim + 1))\n            self.pc = (1 - self.cc) * self.pc + hsig * np.sqrt(self.cc * (2 - self.cc) * self.mu_eff) * np.mean(artmp, axis=0)\n\n            rank_one = np.outer(self.pc, self.pc)\n            rank_mu = np.dot((self.weights * artmp.T), artmp)\n            self.covariance_matrix = (1 - self.c1 - self.cmu) * self.covariance_matrix + self.c1 * rank_one + self.cmu * rank_mu\n\n            self.sigma *= np.exp((self.cs / self.ds) * (np.linalg.norm(self.ps) / np.sqrt(self.dim) - 1))\n\n            self.mean = np.dot(self.weights, population[:self.lambda_ // 2])\n            \n            if eval_count + self.population_size > self.budget:\n                break\n\n        return best_solution", "name": "HCMAAR", "description": "Hybrid Covariance Matrix Evolution Strategy with Adaptive Restart (HCMA-AR) that combines differential evolution with adaptive restarts to efficiently navigate complex landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (8,) (5,4) ').", "error": "ValueError('operands could not be broadcast together with shapes (8,) (5,4) ')", "parent_id": "2110b04f-9453-487c-8205-be7be9023ab9", "metadata": {}, "mutation_prompt": null}
