{"id": "b329d545-4244-4b26-9248-00c4ae714a00", "solution": "import numpy as np\n\nclass AdaptiveMemorySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.memory = []\n    \n    def evaluate_population(self, func, population):\n        return np.array([func(x) for x in population])\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = self.evaluate_population(func, personal_best_positions)\n        \n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                self.inertia_weight * velocities +\n                self.cognitive_coeff * r1 * (personal_best_positions - population) +\n                self.social_coeff * r2 * (global_best_position - population)\n            )\n            population += velocities\n            population = np.clip(population, self.lower_bound, self.upper_bound)\n            \n            scores = self.evaluate_population(func, population)\n            evaluations += self.population_size\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            \n            if np.min(scores) < global_best_score:\n                global_best_index = np.argmin(scores)\n                global_best_position = population[global_best_index]\n                global_best_score = scores[global_best_index]\n            \n            self.memory.append(global_best_position)\n            if len(self.memory) > 10:\n                self.memory.pop(0)\n            \n            # Adaptive mechanism: adjust inertia weight based on improvement\n            if len(self.memory) > 1 and np.var([func(pos) for pos in self.memory]) < 1e-4:\n                self.inertia_weight *= 0.9\n            else:\n                self.inertia_weight = min(0.9, self.inertia_weight * 1.1)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveMemorySwarmOptimizer", "description": "The algorithm combines swarm intelligence with adaptive memory to efficiently explore and exploit the search space within limited evaluations.", "configspace": "", "generation": 0, "fitness": 0.17995593243674313, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.21860541702058922, 0.21860541702058922, 0.21860541702058922, 0.595574588019011, 0.595574588019011, 0.595574588019011, 0.2083298703795542, 0.2083298703795542, 0.2083298703795542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05212510905540457, 0.05212510905540457, 0.05212510905540457, 0.002813656279775034, 0.002813656279775034, 0.002813656279775034, 0.08888985576721531, 0.08888985576721531, 0.08888985576721531, 0.06550885630087233, 0.06550885630087233, 0.06550885630087233, 0.10232221621742776, 0.10232221621742776, 0.10232221621742776, 0.043215734208203904, 0.043215734208203904, 0.043215734208203904, 0.08214251963045005, 0.08214251963045005, 0.08214251963045005, 0.11552544016109245, 0.11552544016109245, 0.11552544016109245, 0.985197279567068, 0.985197279567068, 0.985197279567068, 0.9842283589700177, 0.9842283589700177, 0.9842283589700177, 0.9857913433978435, 0.9857913433978435, 0.9857913433978435, 0.28544896047184853, 0.28544896047184853, 0.28544896047184853, 0.14081908918896224, 0.14081908918896224, 0.14081908918896224, 0.22961015173790567, 0.22961015173790567, 0.22961015173790567, 0.11968640891321303, 0.11968640891321303, 0.11968640891321303, 0.15412226051292532, 0.15412226051292532, 0.15412226051292532, 0.11463648531836157, 0.11463648531836157, 0.11463648531836157, 0.03329518096812212, 0.03329518096812212, 0.03329518096812212, 0.14503960241259195, 0.14503960241259195, 0.14503960241259195, 0.08288595483444738, 0.08288595483444738, 0.08288595483444738, 0.1730602364195456, 0.1730602364195456, 0.1730602364195456, 0.12488493114070587, 0.12488493114070587, 0.12488493114070587, 0.0821532093017795, 0.0821532093017795, 0.0821532093017795, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01320609674161699, 0.01320609674161699, 0.01320609674161699, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03517103959588075, 0.03517103959588075, 0.03517103959588075, 0.023512840552991077, 0.023512840552991077, 0.023512840552991077, 0.09319294165960768, 0.09319294165960768, 0.09319294165960768, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005192185474390265, 0.005192185474390265, 0.005192185474390265, 0.13428343478610294, 0.13428343478610294, 0.13428343478610294, 0.023163570956314494, 0.023163570956314494, 0.023163570956314494, 0.121647597135487, 0.121647597135487, 0.121647597135487, 0.45461317983368577, 0.45461317983368577, 0.45461317983368577, 0.4254667103514458, 0.4254667103514458, 0.4254667103514458, 0.38003206241032217, 0.38003206241032217, 0.38003206241032217, 0.08231809510101828, 0.08231809510101828, 0.08231809510101828, 0.09439245232458138, 0.09439245232458138, 0.09439245232458138, 0.06303250648858394, 0.06303250648858394, 0.06303250648858394, 0.14283364130504328, 0.14283364130504328, 0.14283364130504328, 0.15490007338589018, 0.15490007338589018, 0.15490007338589018, 0.1534822497707935, 0.1534822497707935, 0.1534822497707935, 0.25198355446611953, 0.25198355446611953, 0.25198355446611953, 0.33494392899185177, 0.33494392899185177, 0.33494392899185177, 0.19479772478587276, 0.19479772478587276, 0.19479772478587276, 0.13627705825656689, 0.13627705825656689, 0.13627705825656689, 0.18785483931497127, 0.18785483931497127, 0.18785483931497127, 0.11401701008914045, 0.11401701008914045, 0.11401701008914045, 0.23333523440309245, 0.23333523440309245, 0.23333523440309245, 0.1717022205383577, 0.1717022205383577, 0.1717022205383577, 0.17868556335862673, 0.17868556335862673, 0.17868556335862673, 0.20791100388439232, 0.20791100388439232, 0.20791100388439232, 0.17853370924557077, 0.17853370924557077, 0.17853370924557077, 0.2102100249767671, 0.2102100249767671, 0.2102100249767671, 0.2485601751852392, 0.2485601751852392, 0.2485601751852392, 0.15605744461786053, 0.15605744461786053, 0.15605744461786053, 0.16962215491177357, 0.16962215491177357, 0.16962215491177357, 0.20763827670030233, 0.20763827670030233, 0.20763827670030233, 0.20555896532993068, 0.20555896532993068, 0.20555896532993068, 0.15320946369501276, 0.15320946369501276, 0.15320946369501276, 0.18875817551248564, 0.18875817551248564, 0.18875817551248564, 0.19614384015218012, 0.19614384015218012, 0.19614384015218012, 0.19923723133436488, 0.19923723133436488, 0.19923723133436488, 0.07606251617391513, 0.07606251617391513, 0.07606251617391513, 0.07893317117932908, 0.07893317117932908, 0.07893317117932908, 0.05994045427309336, 0.05994045427309336, 0.05994045427309336]}, "mutation_prompt": null}
{"id": "16879f7b-7f86-45eb-8d91-9e051dfbb0a2", "solution": "import numpy as np\n\nclass AdaptiveMemorySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.memory = []\n    \n    def evaluate_population(self, func, population):\n        return np.array([func(x) for x in population])\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(population)\n        personal_best_scores = self.evaluate_population(func, personal_best_positions)\n        \n        global_best_index = np.argmin(personal_best_scores)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_score = personal_best_scores[global_best_index]\n        \n        evaluations = self.population_size\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                self.inertia_weight * velocities +\n                self.cognitive_coeff * r1 * (personal_best_positions - population) +\n                self.social_coeff * r2 * (global_best_position - population)\n            )\n            population += velocities\n            population = np.clip(population, self.lower_bound, self.upper_bound)\n            \n            scores = self.evaluate_population(func, population)\n            evaluations += self.population_size\n            \n            improved = scores < personal_best_scores\n            personal_best_positions[improved] = population[improved]\n            personal_best_scores[improved] = scores[improved]\n            \n            if np.min(scores) < global_best_score:\n                global_best_index = np.argmin(scores)\n                global_best_position = population[global_best_index]\n                global_best_score = scores[global_best_index]\n            \n            self.memory.append(global_best_position)\n            if len(self.memory) > 10:\n                self.memory.pop(0)\n            \n            # Adaptive mechanism: adjust inertia weight based on improvement\n            if len(self.memory) > 1 and np.var([func(pos) for pos in self.memory]) < 1e-4:\n                self.inertia_weight *= 0.9\n            else:\n                self.inertia_weight = min(0.9, self.inertia_weight * 1.1)\n        \n        return global_best_position, global_best_score", "name": "AdaptiveMemorySwarmOptimizer", "description": "The algorithm combines swarm intelligence with adaptive memory to efficiently explore and exploit the search space within limited evaluations.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b329d545-4244-4b26-9248-00c4ae714a00", "metadata": {"aucs": [0.21860541702058922, 0.21860541702058922, 0.21860541702058922, 0.595574588019011, 0.595574588019011, 0.595574588019011, 0.2083298703795542, 0.2083298703795542, 0.2083298703795542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05212510905540457, 0.05212510905540457, 0.05212510905540457, 0.002813656279775034, 0.002813656279775034, 0.002813656279775034, 0.08888985576721531, 0.08888985576721531, 0.08888985576721531, 0.06550885630087233, 0.06550885630087233, 0.06550885630087233, 0.10232221621742776, 0.10232221621742776, 0.10232221621742776, 0.043215734208203904, 0.043215734208203904, 0.043215734208203904, 0.08214251963045005, 0.08214251963045005, 0.08214251963045005, 0.11552544016109245, 0.11552544016109245, 0.11552544016109245, 0.985197279567068, 0.985197279567068, 0.985197279567068, 0.9842283589700177, 0.9842283589700177, 0.9842283589700177, 0.9857913433978435, 0.9857913433978435, 0.9857913433978435, 0.28544896047184853, 0.28544896047184853, 0.28544896047184853, 0.14081908918896224, 0.14081908918896224, 0.14081908918896224, 0.22961015173790567, 0.22961015173790567, 0.22961015173790567, 0.11968640891321303, 0.11968640891321303, 0.11968640891321303, 0.15412226051292532, 0.15412226051292532, 0.15412226051292532, 0.11463648531836157, 0.11463648531836157, 0.11463648531836157, 0.03329518096812212, 0.03329518096812212, 0.03329518096812212, 0.14503960241259195, 0.14503960241259195, 0.14503960241259195, 0.08288595483444738, 0.08288595483444738, 0.08288595483444738, 0.1730602364195456, 0.1730602364195456, 0.1730602364195456, 0.12488493114070587, 0.12488493114070587, 0.12488493114070587, 0.0821532093017795, 0.0821532093017795, 0.0821532093017795, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01320609674161699, 0.01320609674161699, 0.01320609674161699, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03517103959588075, 0.03517103959588075, 0.03517103959588075, 0.023512840552991077, 0.023512840552991077, 0.023512840552991077, 0.09319294165960768, 0.09319294165960768, 0.09319294165960768, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005192185474390265, 0.005192185474390265, 0.005192185474390265, 0.13428343478610294, 0.13428343478610294, 0.13428343478610294, 0.023163570956314494, 0.023163570956314494, 0.023163570956314494, 0.121647597135487, 0.121647597135487, 0.121647597135487, 0.45461317983368577, 0.45461317983368577, 0.45461317983368577, 0.4254667103514458, 0.4254667103514458, 0.4254667103514458, 0.38003206241032217, 0.38003206241032217, 0.38003206241032217, 0.08231809510101828, 0.08231809510101828, 0.08231809510101828, 0.09439245232458138, 0.09439245232458138, 0.09439245232458138, 0.06303250648858394, 0.06303250648858394, 0.06303250648858394, 0.14283364130504328, 0.14283364130504328, 0.14283364130504328, 0.15490007338589018, 0.15490007338589018, 0.15490007338589018, 0.1534822497707935, 0.1534822497707935, 0.1534822497707935, 0.25198355446611953, 0.25198355446611953, 0.25198355446611953, 0.33494392899185177, 0.33494392899185177, 0.33494392899185177, 0.19479772478587276, 0.19479772478587276, 0.19479772478587276, 0.13627705825656689, 0.13627705825656689, 0.13627705825656689, 0.18785483931497127, 0.18785483931497127, 0.18785483931497127, 0.11401701008914045, 0.11401701008914045, 0.11401701008914045, 0.23333523440309245, 0.23333523440309245, 0.23333523440309245, 0.1717022205383577, 0.1717022205383577, 0.1717022205383577, 0.17868556335862673, 0.17868556335862673, 0.17868556335862673, 0.20791100388439232, 0.20791100388439232, 0.20791100388439232, 0.17853370924557077, 0.17853370924557077, 0.17853370924557077, 0.2102100249767671, 0.2102100249767671, 0.2102100249767671, 0.2485601751852392, 0.2485601751852392, 0.2485601751852392, 0.15605744461786053, 0.15605744461786053, 0.15605744461786053, 0.16962215491177357, 0.16962215491177357, 0.16962215491177357, 0.20763827670030233, 0.20763827670030233, 0.20763827670030233, 0.20555896532993068, 0.20555896532993068, 0.20555896532993068, 0.15320946369501276, 0.15320946369501276, 0.15320946369501276, 0.18875817551248564, 0.18875817551248564, 0.18875817551248564, 0.19614384015218012, 0.19614384015218012, 0.19614384015218012, 0.19923723133436488, 0.19923723133436488, 0.19923723133436488, 0.07606251617391513, 0.07606251617391513, 0.07606251617391513, 0.07893317117932908, 0.07893317117932908, 0.07893317117932908, 0.05994045427309336, 0.05994045427309336, 0.05994045427309336]}, "mutation_prompt": null}
