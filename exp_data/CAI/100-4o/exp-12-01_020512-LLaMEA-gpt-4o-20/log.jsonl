{"id": "df3f1168-4bbd-486f-bcd3-94733ba7eb97", "solution": "import numpy as np\n\nclass HybridGADiffEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.elitism_ratio = 0.1\n        self.evaluations = 0\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        \n        while self.evaluations < self.budget:\n            new_population = self._elitism_selection(population, fitness)\n            for _ in range(self.population_size - len(new_population)):\n                parents = self._select_parents(fitness)\n                offspring = self._crossover(parents)\n                offspring = self._mutate(offspring)\n                new_population.append(offspring)\n            \n            population = np.array(new_population)\n            fitness = self._evaluate_population(func, population)\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n    \n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        fitness = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            fitness[i] = func(population[i])\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                break\n        return fitness\n    \n    def _elitism_selection(self, population, fitness):\n        num_elites = int(self.elitism_ratio * self.population_size)\n        elite_indices = fitness.argsort()[:num_elites]\n        return [population[i] for i in elite_indices]\n    \n    def _select_parents(self, fitness):\n        idx1, idx2 = np.random.choice(self.population_size, 2, replace=False)\n        if fitness[idx1] < fitness[idx2]:\n            return idx1, idx2\n        return idx2, idx1\n    \n    def _crossover(self, parents):\n        parent1, parent2 = parents\n        if np.random.rand() < self.crossover_rate:\n            crossover_point = np.random.randint(0, self.dim)\n            offspring = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            offspring = parent1\n        return offspring\n    \n    def _mutate(self, individual):\n        mutation = np.random.randn(self.dim) * self.mutation_factor\n        mutant = np.clip(individual + mutation, self.lb, self.ub)\n        return mutant", "name": "HybridGADiffEvolution", "description": "A novel hybrid Genetic Algorithm enriched with Differential Evolution crossover, leveraging adaptive mutation strategies for robust exploration and exploitation.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 23, in __call__\n  File \"<string>\", line 60, in _crossover\nIndexError: invalid index to scalar variable.\n.", "error": "IndexError('invalid index to scalar variable.')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 23, in __call__\n  File \"<string>\", line 60, in _crossover\nIndexError: invalid index to scalar variable.\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "938b7bfe-7092-41d6-ae6e-e77fda66834f", "solution": "import numpy as np\n\nclass HybridGADiffEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population_size = 20\n        self.crossover_rate = 0.7\n        self.mutation_factor = 0.8\n        self.elitism_ratio = 0.1\n        self.evaluations = 0\n    \n    def __call__(self, func):\n        population = self._initialize_population()\n        fitness = self._evaluate_population(func, population)\n        \n        while self.evaluations < self.budget:\n            new_population = self._elitism_selection(population, fitness)\n            for _ in range(self.population_size - len(new_population)):\n                parents = self._select_parents(fitness)\n                offspring = self._crossover(parents)\n                offspring = self._mutate(offspring)\n                new_population.append(offspring)\n            \n            population = np.array(new_population)\n            fitness = self._evaluate_population(func, population)\n        \n        best_index = np.argmin(fitness)\n        return population[best_index]\n    \n    def _initialize_population(self):\n        return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n    \n    def _evaluate_population(self, func, population):\n        fitness = np.zeros(self.population_size)\n        for i in range(self.population_size):\n            fitness[i] = func(population[i])\n            self.evaluations += 1\n            if self.evaluations >= self.budget:\n                break\n        return fitness\n    \n    def _elitism_selection(self, population, fitness):\n        num_elites = int(self.elitism_ratio * self.population_size)\n        elite_indices = fitness.argsort()[:num_elites]\n        return [population[i] for i in elite_indices]\n    \n    def _select_parents(self, fitness):\n        idx1, idx2 = np.random.choice(self.population_size, 2, replace=False)\n        if fitness[idx1] < fitness[idx2]:\n            return idx1, idx2\n        return idx2, idx1\n    \n    def _crossover(self, parents):\n        parent1, parent2 = parents\n        if np.random.rand() < self.crossover_rate:\n            crossover_point = np.random.randint(0, self.dim)\n            offspring = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n        else:\n            offspring = parent1\n        return offspring\n    \n    def _mutate(self, individual):\n        mutation = np.random.randn(self.dim) * self.mutation_factor\n        mutant = np.clip(individual + mutation, self.lb, self.ub)\n        return mutant", "name": "HybridGADiffEvolution", "description": "A novel hybrid Genetic Algorithm enriched with Differential Evolution crossover, leveraging adaptive mutation strategies for robust exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df3f1168-4bbd-486f-bcd3-94733ba7eb97", "metadata": {}, "mutation_prompt": null}
