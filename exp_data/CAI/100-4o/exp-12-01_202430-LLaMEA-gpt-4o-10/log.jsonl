{"id": "4d7a257d-5bf0-4a6e-9c1c-bf8e056ec7e9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(100, self.budget // 2)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_counter = 0\n\n    def evaluate(self, func, individual):\n        if self.eval_counter < self.budget:\n            self.eval_counter += 1\n            return func(individual)\n        else:\n            return np.inf\n\n    def mutate(self, target_idx):\n        indices = np.random.choice(np.delete(np.arange(self.pop_size), target_idx), 3, replace=False)\n        donor_vector = self.population[indices[0]] + self.mutation_factor * (self.population[indices[1]] - self.population[indices[2]])\n        return np.clip(donor_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, donor):\n        return np.array([donor[i] if np.random.rand() < self.crossover_probability else target[i] for i in range(self.dim)])\n\n    def select(self, target_idx, trial_vector, func):\n        trial_fitness = self.evaluate(func, trial_vector)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial_vector\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        if self.eval_counter >= self.budget:\n            return np.min(self.fitness), self.population[np.argmin(self.fitness)]\n        \n        # Initialize fitness\n        for i in range(self.pop_size):\n            self.fitness[i] = self.evaluate(func, self.population[i])\n\n        while self.eval_counter < self.budget:\n            for i in range(self.pop_size):\n                donor = self.mutate(i)\n                trial = self.crossover(self.population[i], donor)\n                self.select(i, trial, func)\n            \n            # Adaptive tuning of parameters\n            if self.eval_counter % (self.pop_size * 10) == 0:\n                self.mutation_factor = np.random.uniform(0.5, 1.0)\n                self.crossover_probability = np.random.uniform(0.7, 1.0)\n                \n            # Restart mechanism if stagnation detected\n            if np.ptp(self.fitness) < 1e-6:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n                for i in range(self.pop_size):\n                    self.fitness[i] = self.evaluate(func, self.population[i])\n\n        best_idx = np.argmin(self.fitness)\n        return self.fitness[best_idx], self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "This algorithm combines Differential Evolution with adaptive parameter tuning and a restart mechanism to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 0, "fitness": 0.21547969195503555, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.4806459170210109, 0.4615508377155251, 0.46204859598729253, 0.49375987715473957, 0.5185740269220599, 0.4738708292033582, 0.46661624719131356, 0.4844144046845278, 0.46659068871008014, 0.20332335397899937, 0.22441528290350943, 0.20293690273974274, 0.18256796273999776, 0.20455669349952044, 0.1979914508882007, 0.20634310502685205, 0.24128267475705123, 0.24839708131394544, 0.08435247960134473, 0.08743955383859137, 0.09170304215545966, 0.09087462155149517, 0.08541390201247812, 0.0830908402086239, 0.09195929324368912, 0.08441484286590561, 0.08688989278230275, 0.07956729917281591, 0.07643448561956645, 0.07753688538956227, 0.08654277258656584, 0.07553452863912824, 0.08791727123783788, 0.08242113135584606, 0.08513647025215088, 0.08884368705456858, 0.9050485279825291, 0.9760093606300129, 0.9578241115477117, 0.9344253873999467, 0.9168674478368192, 0.8715571877284805, 0.9197993206885637, 0.8990810379572753, 0.9085753150877824, 0.21475929214857026, 0.21515266602235106, 0.19167924344578635, 0.2032324499290008, 0.2117471865180468, 0.21228257431078923, 0.2012618261742275, 0.21295178194325992, 0.19663531503348264, 0.3661165512609238, 0.3858563997526743, 0.29564765557161754, 0.3797351429592579, 0.5385320337785549, 0.3697972801049777, 0.4516361055319439, 0.405705666620946, 0.3245504929453231, 0.14145042138895791, 0.13662852887871724, 0.12010118157848615, 0.13426123567714554, 0.12565174708551263, 0.14435757581502062, 0.15415373516808362, 0.14053093583041987, 0.13887392516584096, 0.13659536510376724, 0.13470084544085525, 0.044372286445911624, 0.12171194637215155, 0.1398372452846134, 0.1185703745524459, 0.11455045119648799, 0.14195281019001926, 0.14627431592476037, 0.06525581713647532, 0.062161399519346405, 0.054505946197017874, 0.08278292758877093, 0.04878583431645278, 0.04825766497841377, 0.06129908159417807, 0.05252537540805169, 0.04767449671147528, 0.19376815220276422, 0.1716519467453188, 0.1687705530058503, 0.15192579556266883, 0.17735996060001713, 0.16147372122860726, 0.19195722711820273, 0.21825915717538114, 0.1909431611026161, 0.0035497572085949614, 0.007828113239722545, 9.999999999998899e-05, 0.011765877787473289, 0.005976725124713034, 0.007897920693728522, 0.012395694195375118, 0.012506265136241757, 0.012474484418619203, 0.10124000186629711, 0.09712413024501332, 0.09400647166425746, 0.1049858915521289, 0.13234976133452925, 0.10346191689848505, 0.10545018759082703, 0.11975202432321785, 0.09626476754534141, 0.39727653701681, 0.39508668742545494, 0.3896575784958841, 0.40410824532002965, 0.411553028586364, 0.39353903515767874, 0.4348282216063807, 0.41005188801414616, 0.381227574120349, 0.08259885118361032, 0.09261342103563841, 0.07249700955099236, 0.09621503381142471, 0.08009728455683651, 0.07312914820061978, 0.09538997935149784, 0.09411018580804498, 0.0838355571460565, 0.15837657419801288, 0.14583912333403293, 0.15181784648799224, 0.15027477664712274, 0.17179914689916354, 0.13805150895727603, 0.14120426784073592, 0.13092434887493287, 0.12552571074598018, 0.2493882935272732, 0.2419646560618668, 0.23990616375012197, 0.23013097818389217, 0.24669005033780422, 0.23089100345510327, 0.2440314534977981, 0.2626143675255074, 0.25681183146545095, 0.18110089804560026, 0.16810428472891548, 0.17209701956587742, 0.17689534996763556, 0.16970945130855852, 0.17562024731763026, 0.19456123818537552, 0.18868990812993236, 0.17679945441251566, 0.18761924197977675, 0.16357630316281935, 0.22807133027079673, 0.17166975587122268, 0.1915094355054604, 0.17792482478628247, 0.17288414318743872, 0.18799447183934426, 0.1778014689600883, 0.1688564446594475, 0.17043146604002102, 0.17414318422295727, 0.17246629915598455, 0.17699860548913204, 0.16630690252671265, 0.16759272615317533, 0.1706999134722741, 0.18595957535918428, 0.3494572036697263, 0.16214388182970962, 0.2947928956928101, 0.1605039965951912, 0.15261636218407415, 0.139840621915701, 0.27692051330165146, 0.29885921308791963, 0.2755576169897932, 0.49408425031647263, 0.16002782836785812, 0.29612212095593826, 0.16939039083473673, 0.18032392169483336, 0.24968901992197357, 0.34375315114612004, 0.39796285207128, 0.19876801953838807, 0.1837476075520793, 0.18117559833477626, 0.17897697250895905, 0.18308888955759128, 0.192120112768992, 0.17022399852736492, 0.17728473453911286, 0.20524117103520378, 0.1814266882559218, 0.08260001670099315, 0.06960713754949521, 0.07048324196958089, 0.06160895788786114, 0.06621818492472697, 0.07606920104924719, 0.08061153979781555, 0.06281326533960674, 0.07387154236024873]}, "mutation_prompt": null}
{"id": "f746d4fe-a901-49c9-bbde-90998000225c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(100, self.budget // 2)\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.eval_counter = 0\n\n    def evaluate(self, func, individual):\n        if self.eval_counter < self.budget:\n            self.eval_counter += 1\n            return func(individual)\n        else:\n            return np.inf\n\n    def mutate(self, target_idx):\n        indices = np.random.choice(np.delete(np.arange(self.pop_size), target_idx), 3, replace=False)\n        donor_vector = self.population[indices[0]] + self.mutation_factor * (self.population[indices[1]] - self.population[indices[2]])\n        return np.clip(donor_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, donor):\n        return np.array([donor[i] if np.random.rand() < self.crossover_probability else target[i] for i in range(self.dim)])\n\n    def select(self, target_idx, trial_vector, func):\n        trial_fitness = self.evaluate(func, trial_vector)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial_vector\n            self.fitness[target_idx] = trial_fitness\n\n    def __call__(self, func):\n        if self.eval_counter >= self.budget:\n            return np.min(self.fitness), self.population[np.argmin(self.fitness)]\n        \n        # Initialize fitness\n        for i in range(self.pop_size):\n            self.fitness[i] = self.evaluate(func, self.population[i])\n\n        while self.eval_counter < self.budget:\n            for i in range(self.pop_size):\n                donor = self.mutate(i)\n                trial = self.crossover(self.population[i], donor)\n                self.select(i, trial, func)\n            \n            # Adaptive tuning of parameters\n            if self.eval_counter % (self.pop_size * 10) == 0:\n                self.mutation_factor = np.random.uniform(0.5, 1.0)\n                self.crossover_probability = np.random.uniform(0.7, 1.0)\n            \n            # Dynamic population adjustment\n            if self.eval_counter % (self.pop_size * 5) == 0 and np.ptp(self.fitness) < 1e-6:\n                new_pop_size = min(self.pop_size * 2, self.budget // 2)\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (new_pop_size, self.dim))\n                self.pop_size = new_pop_size\n                for i in range(self.pop_size):\n                    self.fitness[i] = self.evaluate(func, self.population[i])\n\n        best_idx = np.argmin(self.fitness)\n        return self.fitness[best_idx], self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Enhance exploration by introducing a dynamic population size adjustment and improved restart mechanism for better convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 100 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 100 is out of bounds for axis 0 with size 100')", "parent_id": "4d7a257d-5bf0-4a6e-9c1c-bf8e056ec7e9", "metadata": {}, "mutation_prompt": null}
