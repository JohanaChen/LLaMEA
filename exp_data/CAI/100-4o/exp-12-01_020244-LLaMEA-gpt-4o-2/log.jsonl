{"id": "3c3bad9c-acad-4105-b90d-ba0afbbab3c2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.evaluations = 0\n\n    def opposition_based_learning(self, population, fitness):\n        opposite_population = self.lower_bound + self.upper_bound - population\n        opposite_fitness = np.apply_along_axis(self.func, 1, opposite_population)\n        improved = opposite_fitness < fitness\n        population[improved] = opposite_population[improved]\n        fitness[improved] = opposite_fitness[improved]\n\n    def mutate(self, population, best_idx):\n        idxs = np.arange(self.population_size)\n        for i in range(self.population_size):\n            idxs = np.delete(idxs, np.where(idxs == i))\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            if np.random.rand() < 0.1:\n                best = population[best_idx]\n                mutant = best + self.F * (a - b) + self.F * (c - population[i])\n            else:\n                mutant = a + self.F * (b - c)\n            yield i, mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        trial = np.clip(trial, self.lower_bound, self.upper_bound)\n        return trial\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(self.func, 1, population)\n        self.evaluations += self.population_size\n        best_idx = np.argmin(fitness)\n\n        while self.evaluations < self.budget:\n            self.opposition_based_learning(population, fitness)\n            new_population = np.zeros_like(population)\n            new_fitness = np.zeros(self.population_size)\n\n            for i, mutant in self.mutate(population, best_idx):\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = self.func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n\n            population, fitness = new_population, new_fitness\n\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Opposition-Based Learning balances exploration and exploitation by using differential mutation and opposition-based strategies.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 53, in __call__\n  File \"<string>\", line 25, in mutate\n  File \"mtrand.pyx\", line 984, in numpy.random.mtrand.RandomState.choice\nValueError: Cannot take a larger sample than population when 'replace=False'\n.", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 53, in __call__\n  File \"<string>\", line 25, in mutate\n  File \"mtrand.pyx\", line 984, in numpy.random.mtrand.RandomState.choice\nValueError: Cannot take a larger sample than population when 'replace=False'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "57d9ff0c-e3e0-4d1f-bf91-a47003bfbeb6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.evaluations = 0\n\n    def opposition_based_learning(self, population, fitness):\n        opposite_population = self.lower_bound + self.upper_bound - population\n        opposite_fitness = np.apply_along_axis(self.func, 1, opposite_population)\n        improved = opposite_fitness < fitness\n        population[improved] = opposite_population[improved]\n        fitness[improved] = opposite_fitness[improved]\n\n    def mutate(self, population, best_idx):\n        idxs = np.arange(self.population_size)\n        for i in range(self.population_size):\n            idxs = np.delete(idxs, np.where(idxs == i))\n            if len(idxs) < 3:  # Safeguard against small populations\n                a, b, c = population[np.random.choice(np.arange(self.population_size), 3, replace=True)]\n            else:\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            if np.random.rand() < 0.1:\n                best = population[best_idx]\n                mutant = best + self.F * (a - b) + self.F * (c - population[i])\n            else:\n                mutant = a + self.F * (b - c)\n            yield i, mutant\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        trial = np.clip(trial, self.lower_bound, self.upper_bound)\n        return trial\n\n    def __call__(self, func):\n        self.func = func\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(self.func, 1, population)\n        self.evaluations += self.population_size\n        best_idx = np.argmin(fitness)\n\n        while self.evaluations < self.budget:\n            self.opposition_based_learning(population, fitness)\n            new_population = np.zeros_like(population)\n            new_fitness = np.zeros(self.population_size)\n\n            for i, mutant in self.mutate(population, best_idx):\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = self.func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n\n            population, fitness = new_population, new_fitness\n\n        return population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive DE with Opposite Learning and Safe Mutation uses differential mutation with a safeguard against small populations.", "configspace": "", "generation": 1, "fitness": 0.25055970901949315, "feedback": "", "error": "", "parent_id": "3c3bad9c-acad-4105-b90d-ba0afbbab3c2", "metadata": {"aucs": [0.5962172372267742, 0.564278027168134, 0.5881073634247562, 0.6357094729885184, 0.5733234869437456, 0.5647478767742845, 0.5217276587667845, 0.623076960944432, 0.5820854953777526, 0.2927912742498484, 0.29228015881572145, 0.2996788087757777, 0.26191088889854297, 0.2682903108564012, 0.28698602085080893, 0.3108546657849256, 0.3071509075919212, 0.25721235862970393, 0.10024993146650463, 0.09851599996280236, 0.10106655140694165, 0.12184210289369746, 0.09032916409555469, 0.1137007133286645, 0.0984858895567331, 0.08868977834196834, 0.09617068478408619, 0.07416670802228542, 0.07374108367543575, 0.1069326376897991, 0.08713243819600025, 0.08057839164918401, 0.09705321604063899, 0.08816475839491322, 0.08733014169622277, 0.08590108545290931, 0.7454256473399796, 0.7708909601167953, 0.8303297200455747, 0.8476116696804459, 0.7936278020133003, 0.7461591232648455, 0.7285244893473617, 0.8311890199925361, 0.6592818232129519, 0.219021011013401, 0.2590166414005979, 0.21163763476035335, 0.1374204144927973, 0.2333428493354891, 0.2910370956031847, 0.25729374377756165, 0.23390383690879557, 0.30266008500009367, 0.6145777693719712, 0.5102589022690407, 0.5225015461545661, 0.6743628575192366, 0.6129595188027313, 0.4899583677655355, 0.527841868509189, 0.565000750168989, 0.5573971177844714, 0.1303303294354362, 0.13583577270268632, 0.13427425082688893, 0.1304487944192686, 0.12947541633606396, 0.11607862791621515, 0.15202753433111993, 0.16227983870252405, 0.242340153702421, 0.16532574086885887, 0.1587793129174443, 0.15079513813498746, 0.2294442887046203, 0.1464139841762948, 0.2008941835960656, 0.18353669042214016, 0.18493917006133176, 0.20709540281278738, 0.15603311539384523, 0.15994930557920983, 0.12110650131438705, 0.15977331697407737, 0.11049567867470544, 0.13195289264989019, 0.1507197511044276, 0.1605037329771114, 0.13692914563001446, 0.3116430067468593, 0.2545553658074128, 0.29582529980073946, 0.2790515087190657, 0.0891526292750614, 0.27585375948640745, 0.24571780897013973, 0.24506624857857795, 0.2307364364342036, 0.04061752391136775, 0.030268422355022806, 0.11057645827841511, 0.038676448712174905, 0.019693080020509623, 0.05766696764212753, 0.07207652400079478, 0.05441394786144882, 0.06582645166175805, 0.19216683828348147, 0.13130657748653007, 0.1534412642876225, 0.1602012407287844, 0.1624203378101693, 0.17557885235929227, 0.14959845166618835, 0.14236903004644152, 0.18324003464198546, 0.5256472539264999, 0.477338028660117, 0.470118659108002, 0.4854761885768184, 0.4884413238927675, 0.4965060734889014, 0.4768522104368783, 0.4911315185488685, 0.48918893448663936, 0.08642955792986506, 0.07787344371289617, 0.11053646649504356, 0.0948454477620615, 0.08159552303721107, 0.08643500472428278, 0.07843280787592388, 0.08579723556922103, 0.08881617668213693, 0.1476936596167603, 0.14502220682480582, 0.16550537326902326, 0.11739903891522485, 0.16703290420629469, 0.11578099374621031, 0.1335937870607513, 0.13781894154013186, 0.11751561281727974, 0.2742270871728, 0.3118864181565093, 0.27906378817331146, 0.32998915861612943, 0.26660964332108894, 0.30179716605942575, 0.2897377257163002, 0.32806045642460147, 0.2748398220305488, 0.20878233263847268, 0.21939839676739503, 0.2331251924425396, 0.22712202531431802, 0.23911098842745648, 0.23129797673035246, 0.23242426102059377, 0.20564477245984492, 0.21365591238085313, 0.18304508815613418, 0.1853844940416277, 0.17787937452498792, 0.22553957919002954, 0.18222374394577068, 0.17427984708970656, 0.1901728586729564, 0.18950563415989663, 0.18611542471261067, 0.17749191594898217, 0.17761582736096293, 0.17981846334893703, 0.1699317484813324, 0.1751130527912499, 0.17271896989859903, 0.16694061591994847, 0.17506322984262734, 0.17830322052346892, 0.169875793683256, 0.40057779419041406, 0.6696196195227099, 0.6253599678044515, 0.3982465437050826, 0.1992345088198072, 0.1516588034049502, 0.1607065278479608, 0.1592106425033567, 0.5791166173612556, 0.20642440871596324, 0.19608340504034327, 0.1818957019622146, 0.3724125265941337, 0.15623184877087404, 0.20048754867057184, 0.1850123272308848, 0.27826015485502986, 0.17802079970100348, 0.18829917864438261, 0.1718818273988183, 0.17550669570189803, 0.18420177713377373, 0.1895160982389834, 0.19923546195708863, 0.1786062189472295, 0.20803859148459236, 0.07598074544285482, 0.07411575152238203, 0.08512451429463819, 0.07318988749070088, 0.06828020276481861, 0.07767549249596106, 0.07575011611780136, 0.07430862458588616, 0.07477873591909123]}, "mutation_prompt": null}
