import numpy as np

class AdaptiveExplorationExploitation:
    def __init__(self, budget, dim):
        self.budget = budget
        self.dim = dim
        self.lower_bound = -5.0
        self.upper_bound = 5.0
        self.population_size = 20
        self.max_generations = self.budget // self.population_size
        self.f_weights = np.linspace(0.5, 1.0, self.max_generations)
        self.w_inertia = np.linspace(0.9, 0.4, self.max_generations) 

    def __call__(self, func):
        np.random.seed(42)
        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))
        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))
        personal_best_positions = population.copy()
        personal_best_scores = np.array([func(ind) for ind in population])
        global_best_pos = personal_best_positions[np.argmin(personal_best_scores)]
        
        for generation in range(self.max_generations):
            f_weight = self.f_weights[generation]
            w_inertia = self.w_inertia[generation]
            
            for i in range(self.population_size):
                indices = np.random.choice(self.population_size, 3, replace=False)
                r1, r2, r3 = population[indices]
                mutant_vector = r1 + f_weight * (r2 - r3)
                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)
                
                crossover_mask = np.random.rand(self.dim) < 0.9
                trial_vector = np.where(crossover_mask, mutant_vector, population[i])
                
                velocities[i] = w_inertia * velocities[i] + 0.5 * np.random.rand() * (personal_best_positions[i] - population[i]) + 0.5 * np.random.rand() * (global_best_pos - population[i])
                trial_vector += velocities[i]
                trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)
                
                trial_score = func(trial_vector)
                if trial_score < personal_best_scores[i]:
                    personal_best_positions[i] = trial_vector
                    personal_best_scores[i] = trial_score
                    if trial_score < func(global_best_pos):
                        global_best_pos = trial_vector
                        
            population = personal_best_positions

        return global_best_pos