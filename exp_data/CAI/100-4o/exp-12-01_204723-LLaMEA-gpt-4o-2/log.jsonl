{"id": "465cf2f7-325b-40fd-9eca-63a08c8c7d92", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.num_evaluations = 0\n\n    def differential_evolution(self, func, population):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = population[indices]\n            mutant_vector = np.clip(x1 + self.mutation_factor * (x2 - x3), self.lower_bound, self.upper_bound)\n            trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, population[i])\n            if self.num_evaluations < self.budget:\n                trial_value = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_value < population[i][1]:\n                    population[i] = (trial_vector, trial_value)\n\n    def local_search(self, func, point):\n        step_size = 0.1\n        for _ in range(10):  # small number of iterations for local refinement\n            if self.num_evaluations >= self.budget:\n                break\n            candidate = point + step_size * np.random.randn(self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            if self.num_evaluations < self.budget:\n                candidate_value = func(candidate)\n                self.num_evaluations += 1\n                if candidate_value < point[1]:\n                    point = (candidate, candidate_value)\n        return point\n\n    def __call__(self, func):\n        # Initialize the population\n        population = [(np.random.uniform(self.lower_bound, self.upper_bound, self.dim), None) for _ in range(self.population_size)]\n        for i in range(self.population_size):\n            if self.num_evaluations < self.budget:\n                population[i] = (population[i][0], func(population[i][0]))\n                self.num_evaluations += 1\n\n        # Optimization loop with DE and local search\n        while self.num_evaluations < self.budget:\n            self.differential_evolution(func, population)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                population[i] = self.local_search(func, population[i])\n\n        # Return the best solution found\n        best_solution = min(population, key=lambda x: x[1])\n        return best_solution[0]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic integrating Differential Evolution with a local search phase to refine solutions and efficiently explore the search space.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 52, in __call__\n  File \"<string>\", line 19, in differential_evolution\nTypeError: only integer scalar arrays can be converted to a scalar index\n.", "error": "TypeError('only integer scalar arrays can be converted to a scalar index')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 52, in __call__\n  File \"<string>\", line 19, in differential_evolution\nTypeError: only integer scalar arrays can be converted to a scalar index\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "7ca70fd0-f039-465f-ba09-c4964500105f", "solution": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.num_evaluations = 0\n\n    def differential_evolution(self, func, population):\n        for i in range(self.population_size):\n            if self.num_evaluations >= self.budget:\n                break\n            indices = np.random.choice(self.population_size, 3, replace=False)\n            x1, x2, x3 = population[indices]\n            mutant_vector = np.clip(x1 + self.mutation_factor * (x2 - x3), self.lower_bound, self.upper_bound)\n            trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, population[i])\n            if self.num_evaluations < self.budget:\n                trial_value = func(trial_vector)\n                self.num_evaluations += 1\n                if trial_value < population[i][1]:\n                    population[i] = (trial_vector, trial_value)\n\n    def local_search(self, func, point):\n        step_size = 0.1\n        for _ in range(10):  # small number of iterations for local refinement\n            if self.num_evaluations >= self.budget:\n                break\n            candidate = point + step_size * np.random.randn(self.dim)\n            candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n            if self.num_evaluations < self.budget:\n                candidate_value = func(candidate)\n                self.num_evaluations += 1\n                if candidate_value < point[1]:\n                    point = (candidate, candidate_value)\n        return point\n\n    def __call__(self, func):\n        # Initialize the population\n        population = [(np.random.uniform(self.lower_bound, self.upper_bound, self.dim), None) for _ in range(self.population_size)]\n        for i in range(self.population_size):\n            if self.num_evaluations < self.budget:\n                population[i] = (population[i][0], func(population[i][0]))\n                self.num_evaluations += 1\n\n        # Optimization loop with DE and local search\n        while self.num_evaluations < self.budget:\n            self.differential_evolution(func, population)\n            for i in range(self.population_size):\n                if self.num_evaluations >= self.budget:\n                    break\n                population[i] = self.local_search(func, population[i])\n\n        # Return the best solution found\n        best_solution = min(population, key=lambda x: x[1])\n        return best_solution[0]", "name": "HybridMetaheuristic", "description": "A hybrid metaheuristic integrating Differential Evolution with a local search phase to refine solutions and efficiently explore the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "465cf2f7-325b-40fd-9eca-63a08c8c7d92", "metadata": {}, "mutation_prompt": null}
