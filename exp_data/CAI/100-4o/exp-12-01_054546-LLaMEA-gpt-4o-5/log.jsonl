{"id": "35f3d7fb-b6d0-4834-a158-1de02c4c1a5d", "solution": "import numpy as np\n\nclass HybridGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.local_search_rate = 0.2\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate fitness of the population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n            \n            # Selection: Tournament selection\n            parents = self.tournament_selection()\n\n            # Crossover: Simulated Binary Crossover\n            offspring = self.crossover(parents)\n            \n            # Mutation: Gaussian mutation\n            self.mutation(offspring)\n            \n            # Local Search\n            self.local_search(offspring, func, evaluations)\n            \n            # Replace worst solutions with new offspring\n            self.replace(offspring, func)\n        \n        # Return the best solution found\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index], self.fitness[best_index]\n    \n    def tournament_selection(self):\n        parents = []\n        for _ in range(self.population_size):\n            i, j = np.random.choice(self.population_size, 2, replace=False)\n            if self.fitness[i] < self.fitness[j]:\n                parents.append(self.population[i])\n            else:\n                parents.append(self.population[j])\n        return np.array(parents)\n    \n    def crossover(self, parents):\n        offspring = []\n        for i in range(0, self.population_size, 2):\n            if np.random.rand() < self.crossover_rate:\n                parent1, parent2 = parents[i], parents[i+1]\n                beta = np.random.rand(self.dim) * 2 - 1\n                child1 = 0.5 * ((1 + beta) * parent1 + (1 - beta) * parent2)\n                child2 = 0.5 * ((1 - beta) * parent1 + (1 + beta) * parent2)\n                child1 = np.clip(child1, self.lb, self.ub)\n                child2 = np.clip(child2, self.lb, self.ub)\n                offspring.extend([child1, child2])\n            else:\n                offspring.extend([parents[i], parents[i+1]])\n        return offspring\n\n    def mutation(self, offspring):\n        for i in range(self.population_size):\n            if np.random.rand() < self.mutation_rate:\n                mutation = np.random.normal(0, 0.1, self.dim)\n                offspring[i] += mutation\n                offspring[i] = np.clip(offspring[i], self.lb, self.ub)\n    \n    def local_search(self, offspring, func, evaluations):\n        for i in range(self.population_size):\n            if np.random.rand() < self.local_search_rate:\n                for _ in range(5):  # perform a few local search steps\n                    step = np.random.normal(0, 0.1, self.dim)\n                    candidate = offspring[i] + step\n                    candidate = np.clip(candidate, self.lb, self.ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < func(offspring[i]):\n                        offspring[i] = candidate\n                        if evaluations >= self.budget:\n                            return\n    \n    def replace(self, offspring, func):\n        for i in range(self.population_size):\n            if func(offspring[i]) < self.fitness[i]:\n                self.population[i] = offspring[i]\n                self.fitness[i] = func(offspring[i])", "name": "HybridGeneticOptimizer", "description": "A hybrid Genetic Algorithm with dynamic parameter tuning and adaptive local search to balance exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.18336358177141665, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.515878833137396, 0.443753243932242, 0.46084239112583647, 0.42237395100230124, 0.4887969943812043, 0.44461185814443094, 0.47489807365838255, 0.587187641605589, 0.43020724429704915, 9.999999999998899e-05, 0.027364640188157097, 9.999999999998899e-05, 9.999999999998899e-05, 0.0942437223466317, 9.999999999998899e-05, 9.999999999998899e-05, 0.09629853621246842, 0.00028646491760231374, 0.1318478689264786, 0.1456458930889667, 0.06668237948311706, 0.14742945340815383, 0.1338153500207191, 0.12475251480483929, 0.11638082339056743, 0.1202268572181816, 0.10637307050680012, 0.06868004844913356, 0.09645435902229749, 0.08042104225240343, 0.09614750906958014, 0.09025370140210631, 0.06136446296589548, 0.07392340419302368, 0.1319060041791179, 0.059697610407751234, 0.10081890965762452, 0.10728348799563558, 0.1192849672890427, 0.10585681450647322, 0.10745742846391582, 0.12524346944652676, 0.09547399981144022, 0.11069718581251509, 0.11746156680473252, 0.19691386447635217, 0.12626512634478282, 0.14411900044729786, 0.1750957408119479, 0.10114624772760239, 0.16986893128841363, 0.2515884082425991, 0.11575951176449217, 0.148106410601487, 0.19827343954226984, 0.5248979406617656, 0.167056991102832, 0.2610394099285721, 0.26461961083600083, 0.3103268033892569, 0.12494148368714209, 0.22483190121265517, 0.22858595646794921, 0.20657212478510834, 0.11113579046888022, 0.14464776548091374, 0.1652233407073651, 0.20786404253481838, 0.21376488681277217, 0.15877422480307501, 0.23730365628157002, 0.1597805420826578, 0.15209922526730735, 0.1451958542788918, 0.14187348043717862, 0.13755729245598292, 0.13997120568202848, 0.19687689930917252, 0.16274173664374247, 0.14332518771106328, 0.1415726625083331, 9.999999999998899e-05, 0.00046148714173577243, 9.999999999998899e-05, 0.006389396636801381, 0.06352353408320377, 9.999999999998899e-05, 0.009237326474187846, 0.09509962482802259, 0.04977144648808285, 0.15216748342167152, 0.09822221805168829, 0.10206578214323458, 0.0619112845032318, 0.05287902740659611, 0.037590897613610674, 0.1738716354962686, 0.08948982287337515, 0.03667375937808248, 0.08646486847546353, 0.11752158005717028, 0.053845736873193384, 0.06308608265037419, 0.0881035391609728, 0.014394543399210535, 0.15940489254103463, 0.04480397547694537, 0.08576534270135217, 0.09447439276737246, 0.11263614401759203, 0.11880169660705775, 0.05433874361161595, 0.13961301667785553, 0.08649071921214457, 0.11181301785857745, 0.11299676711155804, 0.06612376251088337, 0.39531704882097196, 0.4409244332992519, 0.5202834471898177, 0.39707996138195834, 0.42898442399768655, 0.3945172788260888, 0.4748948526278046, 0.41562969356995905, 0.42611708490630296, 0.11334075219780426, 0.10044664022080818, 0.05051848360707012, 0.1276778347989872, 0.10388841302571494, 0.09923490186121986, 0.1164082839697268, 0.12190259586792707, 0.1397647502330701, 0.20122694043817402, 0.18007944781836616, 0.17905506928189263, 0.18634865091049702, 0.24234920767539003, 0.15035639037618564, 0.1983970373509104, 0.2646341335663869, 0.17868610661058626, 0.18956862646015193, 0.21245035695767123, 0.30957401017028874, 0.2467046413883538, 0.34716516562210376, 0.349496736059694, 0.19932871369548522, 0.30748314562915047, 0.22724908916932385, 0.19482555369413312, 0.20810730536106303, 0.2473380392979012, 0.2112072771564013, 0.22106850307946535, 0.24973509379863035, 0.17335823285192165, 0.21624851172605497, 0.1955795186020266, 0.22778117132777542, 0.22979033232236545, 0.22816221607544995, 0.22671854727470175, 0.21163296436592904, 0.2284661433366797, 0.1837043109597145, 0.21106507164217536, 0.23054769891247195, 0.19276673128436794, 0.17944400585043319, 0.1784393051124039, 0.18046864599839085, 0.20215183848656004, 0.17017040624639124, 0.19732773919265267, 0.18481301572770403, 0.1868322308426268, 0.3861756397156664, 0.18195359902426766, 0.419654255003598, 0.7492450615452427, 0.1948236132962604, 0.6282992585159051, 0.16028709030841515, 0.16157864673445332, 0.16599567990383224, 0.39894932354213364, 0.15454543532246168, 0.3087617702011968, 0.4633781387442292, 0.1964539523705383, 0.4831045649137212, 0.182127780901439, 0.3135684678146393, 0.3351403838320405, 0.18159060732341337, 0.18780772326542183, 0.17188398025971985, 0.18177517001640597, 0.21265785545702276, 0.1898528468975852, 0.22368179782869468, 0.17641875524081574, 0.1887620319894585, 0.08800684309296902, 0.07491450707502967, 0.0671730519579603, 0.09848689545823386, 0.07509841536045858, 0.08559570401927763, 0.08787089541735327, 0.08924352682837089, 0.06796161077781526]}, "mutation_prompt": null}
{"id": "99fa4fae-87aa-48e9-ab6f-590c627029f8", "solution": "import numpy as np\n\nclass HybridGeneticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.7\n        self.local_search_rate = 0.2\n        self.lb = -5.0\n        self.ub = 5.0\n        self.population = np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n        \n        while evaluations < self.budget:\n            # Evaluate fitness of the population\n            for i in range(self.population_size):\n                if self.fitness[i] == np.inf:\n                    self.fitness[i] = func(self.population[i])\n                    evaluations += 1\n                    if evaluations >= self.budget:\n                        break\n            \n            # Selection: Tournament selection\n            parents = self.tournament_selection()\n\n            # Crossover: Simulated Binary Crossover\n            offspring = self.crossover(parents)\n            \n            # Mutation: Gaussian mutation\n            self.mutation(offspring)\n            \n            # Local Search\n            self.local_search(offspring, func, evaluations)\n            \n            # Replace worst solutions with new offspring\n            self.replace(offspring, func)\n        \n        # Return the best solution found\n        best_index = np.argmin(self.fitness)\n        return self.population[best_index], self.fitness[best_index]\n    \n    def tournament_selection(self):\n        parents = []\n        for _ in range(self.population_size):\n            i, j = np.random.choice(self.population_size, 2, replace=False)\n            if self.fitness[i] < self.fitness[j]:\n                parents.append(self.population[i])\n            else:\n                parents.append(self.population[j])\n        return np.array(parents)\n    \n    def crossover(self, parents):\n        offspring = []\n        for i in range(0, self.population_size, 2):\n            if np.random.rand() < self.crossover_rate:\n                parent1, parent2 = parents[i], parents[i+1]\n                beta = np.random.rand(self.dim) * 2 - 1\n                child1 = 0.5 * ((1 + beta) * parent1 + (1 - beta) * parent2)\n                child2 = 0.5 * ((1 - beta) * parent1 + (1 + beta) * parent2)\n                child1 = np.clip(child1, self.lb, self.ub)\n                child2 = np.clip(child2, self.lb, self.ub)\n                offspring.extend([child1, child2])\n            else:\n                offspring.extend([parents[i], parents[i+1]])\n        return offspring\n\n    def mutation(self, offspring):\n        for i in range(self.population_size):\n            if np.random.rand() < self.mutation_rate:\n                mutation = np.random.normal(0, 0.1, self.dim)\n                offspring[i] += mutation\n                offspring[i] = np.clip(offspring[i], self.lb, self.ub)\n    \n    def local_search(self, offspring, func, evaluations):\n        for i in range(self.population_size):\n            if np.random.rand() < self.local_search_rate:\n                for _ in range(5):  # perform a few local search steps\n                    step = np.random.normal(0, 0.1, self.dim)\n                    candidate = offspring[i] + step\n                    candidate = np.clip(candidate, self.lb, self.ub)\n                    candidate_fitness = func(candidate)\n                    evaluations += 1\n                    if candidate_fitness < func(offspring[i]):\n                        offspring[i] = candidate\n                        if evaluations >= self.budget:\n                            return\n    \n    def replace(self, offspring, func):\n        for i in range(self.population_size):\n            if func(offspring[i]) < self.fitness[i]:\n                self.population[i] = offspring[i]\n                self.fitness[i] = func(offspring[i])", "name": "HybridGeneticOptimizer", "description": "A hybrid Genetic Algorithm with dynamic parameter tuning and adaptive local search to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "35f3d7fb-b6d0-4834-a158-1de02c4c1a5d", "metadata": {"aucs": [0.515878833137396, 0.443753243932242, 0.46084239112583647, 0.42237395100230124, 0.4887969943812043, 0.44461185814443094, 0.47489807365838255, 0.587187641605589, 0.43020724429704915, 9.999999999998899e-05, 0.027364640188157097, 9.999999999998899e-05, 9.999999999998899e-05, 0.0942437223466317, 9.999999999998899e-05, 9.999999999998899e-05, 0.09629853621246842, 0.00028646491760231374, 0.1318478689264786, 0.1456458930889667, 0.06668237948311706, 0.14742945340815383, 0.1338153500207191, 0.12475251480483929, 0.11638082339056743, 0.1202268572181816, 0.10637307050680012, 0.06868004844913356, 0.09645435902229749, 0.08042104225240343, 0.09614750906958014, 0.09025370140210631, 0.06136446296589548, 0.07392340419302368, 0.1319060041791179, 0.059697610407751234, 0.10081890965762452, 0.10728348799563558, 0.1192849672890427, 0.10585681450647322, 0.10745742846391582, 0.12524346944652676, 0.09547399981144022, 0.11069718581251509, 0.11746156680473252, 0.19691386447635217, 0.12626512634478282, 0.14411900044729786, 0.1750957408119479, 0.10114624772760239, 0.16986893128841363, 0.2515884082425991, 0.11575951176449217, 0.148106410601487, 0.19827343954226984, 0.5248979406617656, 0.167056991102832, 0.2610394099285721, 0.26461961083600083, 0.3103268033892569, 0.12494148368714209, 0.22483190121265517, 0.22858595646794921, 0.20657212478510834, 0.11113579046888022, 0.14464776548091374, 0.1652233407073651, 0.20786404253481838, 0.21376488681277217, 0.15877422480307501, 0.23730365628157002, 0.1597805420826578, 0.15209922526730735, 0.1451958542788918, 0.14187348043717862, 0.13755729245598292, 0.13997120568202848, 0.19687689930917252, 0.16274173664374247, 0.14332518771106328, 0.1415726625083331, 9.999999999998899e-05, 0.00046148714173577243, 9.999999999998899e-05, 0.006389396636801381, 0.06352353408320377, 9.999999999998899e-05, 0.009237326474187846, 0.09509962482802259, 0.04977144648808285, 0.15216748342167152, 0.09822221805168829, 0.10206578214323458, 0.0619112845032318, 0.05287902740659611, 0.037590897613610674, 0.1738716354962686, 0.08948982287337515, 0.03667375937808248, 0.08646486847546353, 0.11752158005717028, 0.053845736873193384, 0.06308608265037419, 0.0881035391609728, 0.014394543399210535, 0.15940489254103463, 0.04480397547694537, 0.08576534270135217, 0.09447439276737246, 0.11263614401759203, 0.11880169660705775, 0.05433874361161595, 0.13961301667785553, 0.08649071921214457, 0.11181301785857745, 0.11299676711155804, 0.06612376251088337, 0.39531704882097196, 0.4409244332992519, 0.5202834471898177, 0.39707996138195834, 0.42898442399768655, 0.3945172788260888, 0.4748948526278046, 0.41562969356995905, 0.42611708490630296, 0.11334075219780426, 0.10044664022080818, 0.05051848360707012, 0.1276778347989872, 0.10388841302571494, 0.09923490186121986, 0.1164082839697268, 0.12190259586792707, 0.1397647502330701, 0.20122694043817402, 0.18007944781836616, 0.17905506928189263, 0.18634865091049702, 0.24234920767539003, 0.15035639037618564, 0.1983970373509104, 0.2646341335663869, 0.17868610661058626, 0.18956862646015193, 0.21245035695767123, 0.30957401017028874, 0.2467046413883538, 0.34716516562210376, 0.349496736059694, 0.19932871369548522, 0.30748314562915047, 0.22724908916932385, 0.19482555369413312, 0.20810730536106303, 0.2473380392979012, 0.2112072771564013, 0.22106850307946535, 0.24973509379863035, 0.17335823285192165, 0.21624851172605497, 0.1955795186020266, 0.22778117132777542, 0.22979033232236545, 0.22816221607544995, 0.22671854727470175, 0.21163296436592904, 0.2284661433366797, 0.1837043109597145, 0.21106507164217536, 0.23054769891247195, 0.19276673128436794, 0.17944400585043319, 0.1784393051124039, 0.18046864599839085, 0.20215183848656004, 0.17017040624639124, 0.19732773919265267, 0.18481301572770403, 0.1868322308426268, 0.3861756397156664, 0.18195359902426766, 0.419654255003598, 0.7492450615452427, 0.1948236132962604, 0.6282992585159051, 0.16028709030841515, 0.16157864673445332, 0.16599567990383224, 0.39894932354213364, 0.15454543532246168, 0.3087617702011968, 0.4633781387442292, 0.1964539523705383, 0.4831045649137212, 0.182127780901439, 0.3135684678146393, 0.3351403838320405, 0.18159060732341337, 0.18780772326542183, 0.17188398025971985, 0.18177517001640597, 0.21265785545702276, 0.1898528468975852, 0.22368179782869468, 0.17641875524081574, 0.1887620319894585, 0.08800684309296902, 0.07491450707502967, 0.0671730519579603, 0.09848689545823386, 0.07509841536045858, 0.08559570401927763, 0.08787089541735327, 0.08924352682837089, 0.06796161077781526]}, "mutation_prompt": null}
