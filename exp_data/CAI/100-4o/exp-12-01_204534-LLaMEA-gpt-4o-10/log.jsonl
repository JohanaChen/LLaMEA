{"id": "86c57dd2-6523-4fd0-a90e-d7acbac3f26b", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(5, dim * 10)\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def select_parents(self, exclude):\n        idxs = list(range(self.population_size))\n        idxs.remove(exclude)\n        return np.random.choice(idxs, 3, replace=False)\n\n    def mutate(self, population, target_idx):\n        a_idx, b_idx, c_idx = self.select_parents(target_idx)\n        return population[a_idx] + self.mutation_factor * (population[b_idx] - population[c_idx])\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        trial = np.where(cross_points, mutant, target)\n        trial = np.clip(trial, self.bounds[0], self.bounds[1])\n        return trial\n\n    def local_search(self, best_candidate, best_fitness, func):\n        for _ in range(5):  # simple local search step\n            neighbor = best_candidate + np.random.normal(0, 0.1, self.dim)\n            neighbor = np.clip(neighbor, self.bounds[0], self.bounds[1])\n            if self.evaluations < self.budget:\n                fitness = func(neighbor)\n                self.evaluations += 1\n                if fitness < best_fitness:\n                    best_candidate, best_fitness = neighbor, fitness\n        return best_candidate, best_fitness\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_candidate = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(population, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_candidate, best_fitness = trial, trial_fitness\n\n            best_candidate, best_fitness = self.local_search(best_candidate, best_fitness, func)\n\n        return best_candidate", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution with local search, combining global exploration and local exploitation for efficient black box optimization.", "configspace": "", "generation": 0, "fitness": 0.3863197745076541, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.7960827921774849, 0.8203058644504964, 0.8104421154234258, 0.7962749734206285, 0.8088699356927392, 0.8054673343393589, 0.8061917316858822, 0.7966904566813406, 0.7908711399612192, 0.6590136161571418, 0.6227669008330313, 0.6443287373997284, 0.6419138543057548, 0.6655397046160003, 0.6360669155233578, 0.6600343079111574, 0.6613964396258728, 0.649591506347933, 0.1281731993155707, 0.13058458356537173, 0.1331733302340039, 0.1484493944939833, 0.12192005003141781, 0.12119013079535346, 0.11308536521798873, 0.11931650461142185, 0.13874874451131358, 0.1132657980415348, 0.11067319153238309, 0.13443317373216324, 0.12387515479250266, 0.11560600035376278, 0.10733206152289643, 0.1216553686562023, 0.11144764845525768, 0.11399237473719459, 0.9467801219415451, 0.9498600597554789, 0.9404488381607945, 0.8508878421680478, 0.9494098300740448, 0.8989577514075515, 0.914428413772293, 0.8772934666326959, 0.8925405749246045, 0.5021247375927287, 0.4879810970554481, 0.4213419024099204, 0.45697107955668004, 0.5022267091637952, 0.4697173380238613, 0.47829592117053976, 0.49542774438244985, 0.4743086090098738, 0.7282497780687391, 0.7539446259161787, 0.7881342450580429, 0.7956224780217058, 0.7908835448921319, 0.7953201269967969, 0.7724498012180147, 0.793881201373543, 0.7904647658246818, 0.20456934957729467, 0.34566544201440064, 0.2049768888149459, 0.26196484012327037, 0.2553125775091115, 0.2294174113272981, 0.4237279472194796, 0.22960165110069597, 0.16337135086010313, 0.4176907357002494, 0.19306750550941154, 0.21405509608147344, 0.1886692270303595, 0.20431849515352185, 0.18240475804829492, 0.1717364454707977, 0.24854859642755878, 0.18256221701412512, 0.42633111334628715, 0.4235276646664047, 0.36054099450269983, 0.4552529717642, 0.4092227504027405, 0.4214424049567378, 0.4234703653579188, 0.3921840663149341, 0.3906167251478072, 0.5390594252373968, 0.5167277958282191, 0.5433142098763459, 0.5044870357251936, 0.4963029425280726, 0.5316974359190112, 0.5812558099229334, 0.5985240276454291, 0.5779300334939796, 0.1853883881264191, 0.2166052457714005, 0.2259616279372908, 0.24133058768093785, 0.15478409060487341, 0.18783527031932812, 0.13307889883410784, 0.16458216698510875, 0.13233352726694703, 0.33128626744638356, 0.31300079071140463, 0.3171069959991104, 0.3352411601526615, 0.34501192621236043, 0.3324484444172151, 0.3187584753478535, 0.3118770135321455, 0.32511304193599777, 0.7203950885339874, 0.6971194172380131, 0.7166318215592402, 0.7157867801030738, 0.7143128877955482, 0.7351895905210775, 0.706833702624585, 0.7087942069151522, 0.7105346900395126, 0.13110776457274187, 0.10811662477346995, 0.1241827715980085, 0.11384446099889045, 0.12507397523980357, 0.12020014149918246, 0.10773202271783844, 0.11247118726312688, 0.11560802168435624, 0.14033881966727146, 0.20534575723368143, 0.1490267774708236, 0.2543078633346322, 0.23484083918863075, 0.1542363431060123, 0.24076955342321849, 0.17733641109300824, 0.1779771496923026, 0.3891952696072335, 0.4183945840199663, 0.41025130810259514, 0.394519696702781, 0.4059380159236955, 0.4278546633795799, 0.40778863533426335, 0.44154163557993387, 0.4416027368298966, 0.31360422979790337, 0.3337559287095525, 0.33514687942895194, 0.30701145954676845, 0.32014312562903147, 0.3362713790276729, 0.3469330904767076, 0.3477173471757399, 0.37391592194451273, 0.22938804185133554, 0.1999082232692303, 0.1881364503685371, 0.2234928571483622, 0.225590672578863, 0.2293227882887564, 0.19547445595291701, 0.19374173536487038, 0.20376622751751694, 0.22501462995437316, 0.25807831674216264, 0.20391848356536868, 0.2301469517921011, 0.20615044798512705, 0.19827362307994623, 0.23784369115327086, 0.21302269123589002, 0.21044831171846112, 0.2059111985989609, 0.1632549679459533, 0.7482201026325026, 0.5670694571309773, 0.7509254245276125, 0.1994927722421197, 0.17424196768807654, 0.5546929035225509, 0.714485647421258, 0.7065404966078641, 0.40277899942839746, 0.7349054972878293, 0.6816240376175673, 0.203971137837192, 0.550922623119716, 0.4745428103436332, 0.7683401284513199, 0.20673184266442768, 0.18820229927309096, 0.19051198638652933, 0.2110157141341844, 0.18821738231283336, 0.20616553148707417, 0.1963376432258609, 0.19141492040264518, 0.18791647916589227, 0.20668011594685798, 0.08258005372838029, 0.07958152780344552, 0.0793183090675258, 0.08597939462076298, 0.08515721168227319, 0.08595320852221844, 0.07627260033469918, 0.08522307987697986, 0.08645741131768914]}, "mutation_prompt": null}
{"id": "2240e261-ae9c-451c-8090-415dd330748b", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(5, dim * 10)\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n    def select_parents(self, exclude):\n        idxs = list(range(self.population_size))\n        idxs.remove(exclude)\n        return np.random.choice(idxs, 3, replace=False)\n\n    def mutate(self, population, target_idx):\n        a_idx, b_idx, c_idx = self.select_parents(target_idx)\n        F = self.mutation_factor + np.random.rand() * 0.5  # Adaptive mutation factor\n        return population[a_idx] + F * (population[b_idx] - population[c_idx])\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        trial = np.where(cross_points, mutant, target)\n        trial = np.clip(trial, self.bounds[0], self.bounds[1])\n        return trial\n\n    def local_search(self, best_candidate, best_fitness, func):\n        for _ in range(5):  # simple local search step\n            neighbor = best_candidate + np.random.normal(0, 0.1, self.dim)\n            neighbor = np.clip(neighbor, self.bounds[0], self.bounds[1])\n            if self.evaluations < self.budget:\n                fitness = func(neighbor)\n                self.evaluations += 1\n                if fitness < best_fitness:\n                    best_candidate, best_fitness = neighbor, fitness\n        return best_candidate, best_fitness\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.apply_along_axis(func, 1, population)\n        self.evaluations += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_candidate = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                mutant = self.mutate(population, i)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_candidate, best_fitness = trial, trial_fitness\n\n            # Restart population if stagnation detected\n            if np.allclose(fitness, best_fitness, atol=1e-8):\n                population = self.initialize_population()\n                fitness = np.apply_along_axis(func, 1, population)\n                self.evaluations += self.population_size\n\n            best_candidate, best_fitness = self.local_search(best_candidate, best_fitness, func)\n\n        return best_candidate", "name": "HybridAdaptiveDifferentialEvolution", "description": "Enhanced hybrid differential evolution with adaptive mutation factor and population restart mechanism for improved convergence in black box optimization.", "configspace": "", "generation": 1, "fitness": 0.29084008922422305, "feedback": "", "error": "", "parent_id": "86c57dd2-6523-4fd0-a90e-d7acbac3f26b", "metadata": {"aucs": [0.5208424803923382, 0.5587046350301255, 0.5436431385119913, 0.4969871181025467, 0.4939899631243514, 0.4861048829951917, 0.5071128130148195, 0.49080877577520965, 0.5115805439191718, 0.36476704113887504, 0.36691456658499666, 0.34882540255225924, 0.38552321200033945, 0.36611617420594755, 0.37038842266607375, 0.35654048793185056, 0.3557960990066822, 0.3635391295218746, 0.11554027950083401, 0.11898774956839264, 0.11362509935969678, 0.14047307275244725, 0.10960487679050734, 0.12657026370722413, 0.11438243433196627, 0.14676548738040762, 0.13066524303879012, 0.09705079816433004, 0.11290195866890151, 0.10072854164311607, 0.10503092253914403, 0.09140347647253655, 0.08734466160564136, 0.11397876498288695, 0.09744504538000276, 0.10591188778455529, 0.9600888951340258, 0.9438384969427327, 0.9315237370748226, 0.9144346694132737, 0.9115326842903309, 0.9206745964696458, 0.9836672684607466, 0.9582550491010225, 0.9196465670024035, 0.3236425776810773, 0.3461660404690038, 0.3294886418200751, 0.3212495455158212, 0.3156505376649893, 0.32404597132323454, 0.3150018208398919, 0.3092458202116175, 0.3130709280853372, 0.5450436391149691, 0.8345934363442187, 0.5826464260461346, 0.4804979137599624, 0.6297419518633735, 0.5981680614228878, 0.5348852048824565, 0.6748469275312103, 0.5898711428568204, 0.24772260798765677, 0.19960306797070848, 0.255135658755849, 0.22961468654604655, 0.23707286295683072, 0.22998203381708882, 0.25007163281595146, 0.20089105977844834, 0.251206475921146, 0.20157143548344492, 0.14637367514493949, 0.19194704577170174, 0.2518663193317602, 0.26696987467930133, 0.18813212675819002, 0.21809373457729475, 0.18244878833553357, 0.25719424077839625, 0.18183512712886707, 0.13967744631930945, 0.13924691558174074, 0.15342269690224852, 0.16528431607796534, 0.15146896982408176, 0.1788988563174435, 0.15887226662455245, 0.15048446885135003, 0.3045816887132813, 0.29409690323871607, 0.2914446474900636, 0.2550481181659008, 0.25614352301597443, 0.2596664745820555, 0.3164118987763408, 0.3043939357963037, 0.29620807873043276, 0.04913933061497866, 0.04540419927665329, 0.04163696933154193, 0.048941818421839756, 0.0780410233118124, 0.056069048670357, 0.06855718497167096, 0.039163509596903845, 0.05597726809329273, 0.176942533169124, 0.18087511613931717, 0.19230481848756076, 0.17692671454905962, 0.19763386369695624, 0.20236078160478632, 0.17877395002242447, 0.17003398474299758, 0.18357788329761637, 0.5008956569449283, 0.4728040660495434, 0.5099633910680946, 0.4892591905370125, 0.4752907992925681, 0.4714740411070154, 0.49156147814185214, 0.48081220087369525, 0.48791219191328405, 0.09393589596075236, 0.09537322341569798, 0.14032657477393773, 0.11536297312351107, 0.10912325704247339, 0.10489595113702599, 0.10244326984254115, 0.09214133836650473, 0.10890891172364259, 0.20675320010552145, 0.18034363628499772, 0.24513121122938508, 0.17068240653922206, 0.3261993968628799, 0.3397887498496699, 0.1675724590794614, 0.265318990008667, 0.21621089626694723, 0.31251794975383695, 0.29827193937861307, 0.28179418823216806, 0.2720367524085109, 0.2920452519811765, 0.28479955175212646, 0.2972789734321797, 0.3192407530013328, 0.3286410683838126, 0.21755606665115124, 0.2243308550735491, 0.2322733018169073, 0.22771502351194772, 0.23042828862699294, 0.21512131530225398, 0.22270639159305672, 0.24293135395255672, 0.2505047947225759, 0.20371231028434345, 0.21382324557164123, 0.17843301957792224, 0.20472765628520628, 0.18957529244289684, 0.18656984572740087, 0.19664150918744783, 0.20191556069781602, 0.21484027915429438, 0.19555108512150898, 0.21476852850612838, 0.19281231579126124, 0.19389141773878404, 0.19277978128847295, 0.1909719476619246, 0.1953991093495605, 0.1961694493959868, 0.18576053112108804, 0.6638728864751213, 0.6057801391363287, 0.629788470385706, 0.4931693021488527, 0.2042706570869799, 0.7096722950407157, 0.2498262068042938, 0.18849211900858032, 0.6434538193352708, 0.4722477072559661, 0.21148388552383024, 0.47252799628687103, 0.2043626496325116, 0.43342226114212723, 0.4624400227052442, 0.310926909425168, 0.5437675140423717, 0.21021979428063442, 0.17881319328860612, 0.22085191938205606, 0.20556572631348424, 0.1749156638258237, 0.1903194044525679, 0.2082296937235999, 0.18505115234016212, 0.183852077159963, 0.19144950551371565, 0.0775749169180161, 0.0917869096679429, 0.09310656110066173, 0.07036827940579604, 0.08114948668368904, 0.07504271552479291, 0.0821209156001863, 0.07429774819216384, 0.09465904658918911]}, "mutation_prompt": null}
