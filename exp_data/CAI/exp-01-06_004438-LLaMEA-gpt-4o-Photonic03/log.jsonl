{"id": "7e2de6b3-770a-4f7f-a662-06889631a747", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that adapts to the dimensionality and bounds for efficient exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.12876852697724664, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": null, "metadata": {"aucs": [0.13105495617685037, 0.13025672843596037, 0.12499389631892921]}, "mutation_prompt": null}
{"id": "5b5d0688-e4a0-4272-89ab-3bd997f7628f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            self.mutation_factor = 0.5 + 0.3 * (self.budget - evals) / self.budget  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduced adaptive mutation factor in DE update to balance exploration and exploitation more effectively.", "configspace": "", "generation": 1, "fitness": 0.12871733092705465, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7e2de6b3-770a-4f7f-a662-06889631a747", "metadata": {"aucs": [0.13047054527956203, 0.12993576926179518, 0.12574567823980676]}, "mutation_prompt": null}
{"id": "86dbcfd4-f340-4e83-a004-a1a7a23bd599", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.85  # Increased mutation factor\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "A hybrid PSO and DE algorithm with an increased mutation factor for enhanced exploration capabilities.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'HybridPSO_DE' object has no attribute 'crossover_rate'\").", "error": "AttributeError(\"'HybridPSO_DE' object has no attribute 'crossover_rate'\")", "parent_id": "7e2de6b3-770a-4f7f-a662-06889631a747", "metadata": {}, "mutation_prompt": null}
{"id": "12a127a1-b5ac-468a-8aa2-d8b30a95b0f4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget)  # Adjust inertia weight\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduced dynamic inertia weight adjustment in the PSO component for improved balance between exploration and exploitation.", "configspace": "", "generation": 3, "fitness": 0.12889265061198174, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "7e2de6b3-770a-4f7f-a662-06889631a747", "metadata": {"aucs": [0.13055997368300154, 0.13026342971605198, 0.1258545484368917]}, "mutation_prompt": null}
{"id": "78337e89-009d-4a60-b752-eb1a8948215a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget)  # Adjust inertia weight\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Improved the DE mutation strategy by introducing a dynamic scaling factor to enhance exploration.", "configspace": "", "generation": 4, "fitness": 0.12976440431715805, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "12a127a1-b5ac-468a-8aa2-d8b30a95b0f4", "metadata": {"aucs": [0.13111591381789078, 0.1285361918611001, 0.12964110727248324]}, "mutation_prompt": null}
{"id": "86add8fa-7d39-4cec-bf98-9ddb7dded651", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Stochastic inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a stochastic inertia weight update to improve the balance between exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.13023282953187518, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "78337e89-009d-4a60-b752-eb1a8948215a", "metadata": {"aucs": [0.1313846279243035, 0.13006026154543326, 0.12925359912588874]}, "mutation_prompt": null}
{"id": "83df26bf-f52c-4b93-9f8d-403c9bc1982b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Stochastic inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            self.crossover_rate = 0.6 + 0.3 * np.random.rand()  # Dynamic crossover rate adjustment\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic crossover rate to better adapt exploration and exploitation phases.", "configspace": "", "generation": 6, "fitness": 0.12983057151263613, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "86add8fa-7d39-4cec-bf98-9ddb7dded651", "metadata": {"aucs": [0.13127378874494355, 0.12944334734117735, 0.12877457845178752]}, "mutation_prompt": null}
{"id": "e30416a2-6f4e-4586-acdb-2954f0686c6b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Stochastic inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (evals / self.budget)  # Adjusted dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Tweak the dynamic scaling factor of the DE component by adjusting its range to enhance convergence speed.", "configspace": "", "generation": 7, "fitness": 0.12898218640212797, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "86add8fa-7d39-4cec-bf98-9ddb7dded651", "metadata": {"aucs": [0.13002915566768058, 0.13020420807299637, 0.12671319546570692]}, "mutation_prompt": null}
{"id": "edceffc4-634f-42e6-91f2-19e4572adda5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Stochastic inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a variable mutation factor in the DE update to enhance adaptability across different stages of optimization. ", "configspace": "", "generation": 8, "fitness": 0.13147277844833752, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "86add8fa-7d39-4cec-bf98-9ddb7dded651", "metadata": {"aucs": [0.13061951233107094, 0.13140896274855662, 0.13238986026538502]}, "mutation_prompt": null}
{"id": "0d12d80a-42af-405b-808e-5e0d33a3924b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Stochastic inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic mutation factor in PSO for enhanced exploration in early stages.", "configspace": "", "generation": 9, "fitness": 0.13147277844833752, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "edceffc4-634f-42e6-91f2-19e4572adda5", "metadata": {"aucs": [0.13061951233107094, 0.13140896274855662, 0.13238986026538502]}, "mutation_prompt": null}
{"id": "b823953e-6ba1-472d-92db-079c04a8064a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Stochastic inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Changed line (1/65): Introduce randomness in scaling factor\n                dynamic_factor = 0.6 + np.random.rand() * 0.4 * (1 - evals / self.budget)  # Added randomness in scaling\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce randomness in mutation factor to enhance exploration around the search space.", "configspace": "", "generation": 10, "fitness": 0.12982266504596598, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "edceffc4-634f-42e6-91f2-19e4572adda5", "metadata": {"aucs": [0.13009516317222736, 0.13272105706479753, 0.1266517749008731]}, "mutation_prompt": null}
{"id": "2df288cd-dc3e-4a5b-9443-47d1510423b1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Stochastic inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                adaptive_crossover_rate = self.crossover_rate * (0.5 + 0.5 * (1 - evals / self.budget))  # Adaptive crossover\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate  # Updated line\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial  # Updated line\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce adaptive crossover in DE based on iteration progress to enhance exploration-exploitation balance.", "configspace": "", "generation": 11, "fitness": 0.1299491733598056, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "edceffc4-634f-42e6-91f2-19e4572adda5", "metadata": {"aucs": [0.1309995661650042, 0.13135913251268427, 0.12748882140172835]}, "mutation_prompt": null}
{"id": "95c5ea92-8a6b-48cc-95ac-c08732b91f58", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Stochastic inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.5 + 0.5 * (evals / self.budget)  # Dynamic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce dynamic crossover rates in DE updates to improve exploration-exploitation balance.", "configspace": "", "generation": 12, "fitness": 0.12850687135520125, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "edceffc4-634f-42e6-91f2-19e4572adda5", "metadata": {"aucs": [0.13002915566768058, 0.12809813805653314, 0.12739332034139006]}, "mutation_prompt": null}
{"id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a new inertia weight decay formula for better exploitation-exploration balance.", "configspace": "", "generation": 13, "fitness": 0.13148609129868938, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "edceffc4-634f-42e6-91f2-19e4572adda5", "metadata": {"aucs": [0.1307005063444031, 0.13140838492185125, 0.13234938262981377]}, "mutation_prompt": null}
{"id": "05088b60-0ea0-4163-9ded-893798c3942e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a new inertia weight decay formula for better exploitation-exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.1307005063444031, 0.13140838492185125, 0.13234938262981377]}, "mutation_prompt": null}
{"id": "b000611f-c060-4e92-ae4e-2a22bbb301a4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # Adjusted dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Adjust the dynamic scaling factor in DE to improve exploration-exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.1290276955746773, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13023816662605625, 0.13136359768738104, 0.12548132241059462]}, "mutation_prompt": null}
{"id": "f2e6d2cb-b424-4a5a-9de4-60b8337f6c6f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate * (1 - np.mean(personal_best_value) / global_best_value)  # Adaptive crossover rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce adaptive crossover rate based on the performance of the population to enhance diversity and convergence.", "configspace": "", "generation": 16, "fitness": 0.13076886452287506, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13163931543745278, 0.12987777037518589, 0.13078950775598652]}, "mutation_prompt": null}
{"id": "a3a69dd6-3550-4d16-b931-ab7b794efb19", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 - 0.4 * (evals / self.budget)  # Dynamic crossover rate adjustment\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Fine-tune crossover rate dynamically based on evaluations to balance exploration and exploitation.", "configspace": "", "generation": 17, "fitness": 0.12998036715527386, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13069105558097915, 0.13180505010620325, 0.12744499577863921]}, "mutation_prompt": null}
{"id": "80e6080b-50d5-4bfd-986f-8a534ddb51bd", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population)) + np.random.normal(0, 0.01, velocity.shape)  # Added perturbation\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Further enhance exploration by adding a small perturbation to velocity updates.", "configspace": "", "generation": 18, "fitness": 0.1286530040867253, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13103409644269715, 0.12935745857555392, 0.12556745724192486]}, "mutation_prompt": null}
{"id": "575a2213-4a25-4c59-bff1-c1a515dcf67e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                dynamic_crossover = 0.5 + 0.4 * np.random.rand() * (1 - evals / self.budget)  # Dynamic crossover rate\n                cross_points = np.random.rand(self.dim) < dynamic_crossover\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic crossover rate in DE to enhance diversification.", "configspace": "", "generation": 19, "fitness": 0.13010436810001882, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.1317139800862217, 0.12983582020537143, 0.12876330400846336]}, "mutation_prompt": null}
{"id": "c4e643b3-4b29-4f8d-b78a-95ba0c68107a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445  # Modify the cognitive coefficient limit\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.c1 = 1.5 + 0.5 * np.sin(2 * np.pi * evals / self.budget)  # Adjusting cognitive coefficient with a sine function\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * np.cos(np.pi * evals / self.budget)  # Use cosine function to adjust mutation factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance local exploitation by dynamically adjusting the cognitive coefficient and improve diversity with a mutation factor variation.", "configspace": "", "generation": 20, "fitness": 0.13115150360506023, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.1302677298409196, 0.13146535075867216, 0.1317214302155889]}, "mutation_prompt": null}
{"id": "79efffa8-e321-4e7e-b8d1-b7a4e22e74e9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 - 0.5 * (evals / self.budget)  # Dynamic crossover rate adaptation\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce dynamic crossover rate adaptation in DE to enhance diversity and convergence speed.", "configspace": "", "generation": 21, "fitness": 0.1293562091567276, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13026514245478138, 0.13135635811787705, 0.12644712689752435]}, "mutation_prompt": null}
{"id": "1c13460d-7f65-43c6-84b9-a1dd50f8bd4b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 - 0.5 * (evals / self.budget)  # Adaptive crossover rate adjustment\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce adaptive crossover rate for DE based on exploration-exploitation balance.", "configspace": "", "generation": 22, "fitness": 0.1293562091567276, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13026514245478138, 0.13135635811787705, 0.12644712689752435]}, "mutation_prompt": null}
{"id": "c5676aa0-bc74-45f4-a540-cf82d976d27d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            stochastic_component = np.random.uniform(-0.1, 0.1, velocity.shape)  # Small stochastic component for exploration\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population) + \n                        stochastic_component)  # Add stochastic component\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a small stochastic component to the velocity update for enhanced exploration.", "configspace": "", "generation": 23, "fitness": 0.12846366215718663, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13024982586518352, 0.1285554248173152, 0.12658573578906118]}, "mutation_prompt": null}
{"id": "456701eb-6098-42bc-924c-504e2b35ca0d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.9 + 0.1 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhanced convergence by fine-tuning the dynamic scaling factor for improved diversity.", "configspace": "", "generation": 24, "fitness": 0.13127624490590564, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13008077861431544, 0.13151717596984291, 0.1322307801335586]}, "mutation_prompt": null}
{"id": "5d50c913-43d1-4ced-8d21-97177ec58ad1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population) + \n                        np.random.uniform(-0.01, 0.01, (self.population_size, self.dim)))  # Added jitter to velocity\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a small random jitter in particle velocity update to enhance local search capabilities.", "configspace": "", "generation": 25, "fitness": 0.12847262301507253, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.1302250360947106, 0.1285460838199426, 0.1266467491305644]}, "mutation_prompt": null}
{"id": "a8d5a44e-903c-4826-aa81-349b7cdce0a9", "solution": "class HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # Slightly modified dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Refine the dynamic scaling factor for enhanced exploitation and exploration balance.", "configspace": "", "generation": 26, "fitness": 0.1290276955746773, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13023816662605625, 0.13136359768738104, 0.12548132241059462]}, "mutation_prompt": null}
{"id": "61a195eb-04c4-471f-85c8-04ff1db46396", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Dynamic crossover rate adjustment\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce dynamic crossover rate adjustment to balance exploration and exploitation.", "configspace": "", "generation": 27, "fitness": 0.13126588875095577, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13005133741245156, 0.13140838492185125, 0.13233794391856446]}, "mutation_prompt": null}
{"id": "3df76c71-bcc4-4aa4-a6c4-dfe249ea404d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.7 + 0.4 * (1 - evals / self.budget)  # Adjusted dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Adjusted the dynamic factor to enhance exploration in early iterations.", "configspace": "", "generation": 28, "fitness": 0.12934276246339746, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13040600396207191, 0.13160758710846399, 0.12601469631965645]}, "mutation_prompt": null}
{"id": "8ade9379-bcc7-4b1c-81be-5ab8b3e462bb", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population) + np.random.uniform(-0.01, 0.01, velocity.shape))  # Added random deviation\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance exploration by introducing a small random deviation to the velocity update step.", "configspace": "", "generation": 29, "fitness": 0.12847262301507253, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.1302250360947106, 0.1285460838199426, 0.1266467491305644]}, "mutation_prompt": null}
{"id": "d00140be-4ffd-4120-9800-3dfe89664a22", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            jitter = np.random.uniform(-0.01, 0.01, (self.population_size, self.dim))  # Added jitter for local search enhancement\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population) + jitter)\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Incorporate a jitter mechanism in the velocity update to enhance local search capabilities.", "configspace": "", "generation": 30, "fitness": 0.12847262301507253, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.1302250360947106, 0.1285460838199426, 0.1266467491305644]}, "mutation_prompt": null}
{"id": "216d1527-614a-445b-adaf-34b252447a97", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.5 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Adjust the rate of inertia weight decay to improve exploration-exploitation balance.", "configspace": "", "generation": 31, "fitness": 0.13147277844833752, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13061951233107094, 0.13140896274855662, 0.13238986026538502]}, "mutation_prompt": null}
{"id": "fc956741-8e28-4b81-8d26-4130db2686aa", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.8 + 0.2 * (evals / self.budget)  # Adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce an adaptive crossover rate to balance exploration and exploitation dynamically.", "configspace": "", "generation": 32, "fitness": 0.12927619894882025, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.13002915566768058, 0.1315576188762202, 0.12624182230255998]}, "mutation_prompt": null}
{"id": "4a1a1380-53c0-4329-ba0b-f90b6f97c392", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a stochastic element to the crossover rate for enhanced diversity and adaptability.", "configspace": "", "generation": 33, "fitness": 0.1315121663769342, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "d9ae7cc0-bdc9-4588-9186-92e2021f7e76", "metadata": {"aucs": [0.1314299714442596, 0.13096840625087036, 0.1321381214356726]}, "mutation_prompt": null}
{"id": "d3785867-c254-43dc-a5f8-69544318a4f6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * np.random.rand()  # Adjusted dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.7 + 0.2 * np.random.rand()  # Enhanced stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Adaptive scaling factor and enhanced stochastic crossover for increased exploration.", "configspace": "", "generation": 34, "fitness": 0.13000321226126713, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "4a1a1380-53c0-4329-ba0b-f90b6f97c392", "metadata": {"aucs": [0.13063706986726709, 0.12813820638615503, 0.1312343605303793]}, "mutation_prompt": null}
{"id": "14f98898-c59c-4e97-b38c-db84bc934751", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Adjust dynamic scaling factor in DE update for improved exploration-exploitation balance.", "configspace": "", "generation": 35, "fitness": 0.13170118804299338, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "4a1a1380-53c0-4329-ba0b-f90b6f97c392", "metadata": {"aucs": [0.1316169961013579, 0.1312792856699584, 0.13220728235766388]}, "mutation_prompt": null}
{"id": "7c8b2ce2-3762-4634-929a-9b1432fcd02e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        evals = 0\n        while evals < self.budget:\n            current_population_size = int(self.initial_population_size * (1 - evals / self.budget)) + 1  # Line changed\n            population = np.random.uniform(lb, ub, (current_population_size, self.dim))\n            velocity = np.random.uniform(-1, 1, (current_population_size, self.dim))\n\n            personal_best = population.copy()\n            personal_best_value = np.array([func(ind) for ind in population])\n            global_best = personal_best[np.argmin(personal_best_value)]\n            global_best_value = np.min(personal_best_value)\n\n            evals += current_population_size\n            if evals >= self.budget:\n                break\n\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(current_population_size, self.dim), np.random.rand(current_population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(current_population_size):\n                indices = list(range(current_population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce adaptive population size reduction to enhance convergence as evaluations progress.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "14f98898-c59c-4e97-b38c-db84bc934751", "metadata": {}, "mutation_prompt": null}
{"id": "298e9e20-4514-41a7-9ac3-0c493dc68010", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Introduced adaptive mutation factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduced adaptive mutation factor in DE update for enhanced adaptability to fitness landscape.", "configspace": "", "generation": 37, "fitness": 0.13124742372276668, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "14f98898-c59c-4e97-b38c-db84bc934751", "metadata": {"aucs": [0.13372730285802026, 0.13232959096515873, 0.1276853773451211]}, "mutation_prompt": null}
{"id": "fb7d3e34-28c8-4fae-a618-7a125c987500", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            self.population_size = int(10 * self.dim * (1 - evals / self.budget)) + 1  # Dynamic population size shrinkage\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduced adaptive population size shrinkage to enhance convergence speed over iterations.", "configspace": "", "generation": 38, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (55,6) (60,6) ').", "error": "ValueError('operands could not be broadcast together with shapes (55,6) (60,6) ')", "parent_id": "14f98898-c59c-4e97-b38c-db84bc934751", "metadata": {}, "mutation_prompt": null}
{"id": "087016d9-a032-4950-b369-c9a6b8006414", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * np.random.uniform(0.8, 1.2)  # New stochastic component added\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Further refine dynamic scaling factor in DE by incorporating a stochastic component.", "configspace": "", "generation": 39, "fitness": 0.1306510472913762, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "14f98898-c59c-4e97-b38c-db84bc934751", "metadata": {"aucs": [0.13371832496284164, 0.13247975698186487, 0.12575505992942204]}, "mutation_prompt": null}
{"id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance convergence speed by introducing adaptive acceleration coefficients in the PSO update.", "configspace": "", "generation": 40, "fitness": 0.13174848714981693, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "14f98898-c59c-4e97-b38c-db84bc934751", "metadata": {"aucs": [0.13210697558859275, 0.13130169743109799, 0.1318367884297601]}, "mutation_prompt": null}
{"id": "42024741-1e0a-43ab-8663-656be7256182", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.mutation_factor = 0.8 + 0.2 * np.random.rand()  # Adaptive mutation factor\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce an adaptive mutation factor in DE to enhance exploration capabilities.", "configspace": "", "generation": 41, "fitness": 0.1297458670212612, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "metadata": {"aucs": [0.1300294001108372, 0.13251849767753532, 0.12668970327541107]}, "mutation_prompt": null}
{"id": "5efeeb38-3155-4ac9-8e84-e3a334640f3d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = np.random.uniform(0.5, 1) * (1 - evals / self.budget)  # Stochastic dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Improve convergence by introducing stochastic scaling factors and adaptive initialization.", "configspace": "", "generation": 42, "fitness": 0.13157981894994164, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "metadata": {"aucs": [0.13431086457668828, 0.1307429700862779, 0.12968562218685875]}, "mutation_prompt": null}
{"id": "7bc2fcf6-c3d6-4768-b25f-75a94f3c25b5", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.8 + 0.2 * np.sin(evals / self.budget * np.pi)  # Dynamic mutation factor\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic mutation factor to balance exploration and exploitation.", "configspace": "", "generation": 43, "fitness": 0.13155959567827855, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "metadata": {"aucs": [0.13162820844151835, 0.13130738060607505, 0.1317431979872422]}, "mutation_prompt": null}
{"id": "0fe7e76c-3168-48f2-a655-b379be157444", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                mutant += np.random.normal(0, 0.1, self.dim)  # Gaussian mutation for enhanced exploration\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic personal best influence factor in PSO and apply a Gaussian mutation to DE for enhanced exploration.", "configspace": "", "generation": 44, "fitness": 0.12961125266201445, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "metadata": {"aucs": [0.13004487459598635, 0.1296456979833469, 0.1291431854067101]}, "mutation_prompt": null}
{"id": "cb3dfd8b-04d0-4943-af84-d869e45afe65", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)  # Dynamic neighborhood\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_value = func(trial)\n                evals += 1\n\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Improve exploration by integrating dynamic neighborhood selection with the hybrid PSO-DE framework.", "configspace": "", "generation": 45, "fitness": 0.1306840779883256, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "metadata": {"aucs": [0.1319433417270428, 0.13006051985377498, 0.130048372384159]}, "mutation_prompt": null}
{"id": "e87e64c0-3d4f-482e-962e-8799d1a5e5ee", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # Calculate diversity as standard deviation of population\n            diversity = np.std(population)\n\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05) * diversity  # Adjust inertia weight\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand() * (1 + diversity)  # Adjust crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce dynamic role adaptation between exploration and exploitation by varying the inertia weight and crossover rate based on population diversity.", "configspace": "", "generation": 46, "fitness": 0.12737238571260742, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "metadata": {"aucs": [0.13002915566768058, 0.12758029325297682, 0.12450770821716484]}, "mutation_prompt": null}
{"id": "95dba269-7216-4956-907f-da964f983bfe", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with stochastic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.1, 0.1)  # Modified stochastic range\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + np.random.uniform(0, 0.5) * (1 - evals / self.budget)  # Stochastic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce stochastic inertia weight and mutation factor for improved exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.13134874148224354, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "metadata": {"aucs": [0.13400506563482606, 0.1306321369998079, 0.12940902181209668]}, "mutation_prompt": null}
{"id": "91e12296-5d6c-46f9-94e5-4b3895a8e0a9", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.uniform(-0.05, 0.05)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)**2  # New dynamic scaling factor with quadratic term\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance convergence by introducing a quadratic term in dynamic scaling factor within DE update.", "configspace": "", "generation": 48, "fitness": 0.13143701174758615, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "metadata": {"aucs": [0.1315260015203531, 0.13135649790734705, 0.1314285358150583]}, "mutation_prompt": null}
{"id": "fef47501-a00c-4d80-8c67-94a71640990d", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Modify the dynamic inertia weight to incorporate random variations for enhanced exploration and fine-tuning.", "configspace": "", "generation": 49, "fitness": 0.1325409954118938, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "00d64b4e-1905-43c1-b126-3ad20b08fd5b", "metadata": {"aucs": [0.13287767225077252, 0.13136884832169204, 0.13337646566321681]}, "mutation_prompt": null}
{"id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic personal best influence factor for improved convergence.", "configspace": "", "generation": 50, "fitness": 0.13292119911466083, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "fef47501-a00c-4d80-8c67-94a71640990d", "metadata": {"aucs": [0.13354379780779746, 0.13113475175531564, 0.13408504778086938]}, "mutation_prompt": null}
{"id": "827c4beb-87c2-47aa-af61-3e2987be0bb6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        (self.c2 + 0.1 * np.random.normal(0, 1)) * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce adaptive control for velocity to balance exploration and exploitation more effectively.", "configspace": "", "generation": 51, "fitness": 0.13198957648021223, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13129514557922717, 0.13095971652223093, 0.13371386733917856]}, "mutation_prompt": null}
{"id": "0e3388c6-b189-47ba-81df-67100a432b68", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            # Adjust population size dynamically\n            self.population_size = 10 * self.dim + int(5 * np.sin(evals * np.pi / self.budget))\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic swarm size adjustment for better exploration-exploitation trade-off.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (62,6) (60,6) ').", "error": "ValueError('operands could not be broadcast together with shapes (62,6) (60,6) ')", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {}, "mutation_prompt": null}
{"id": "11cdb0d9-0d6a-4358-a959-15f028de01e4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            dynamic_global_factor = 0.5 + 0.5 * (evals / self.budget)  # New dynamic global influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        dynamic_global_factor * self.c2 * r2 * (global_best - population))  # Adjust dynamic global factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a new adaptive global best influence factor to enhance the exploration-exploitation balance.", "configspace": "", "generation": 53, "fitness": 0.13129901805781452, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13439627384651565, 0.13044795888399463, 0.12905282144293329]}, "mutation_prompt": null}
{"id": "957a47ad-9f4e-43d7-bad3-cce013da1079", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.7 - (0.3 * evals / self.budget) + np.random.normal(0, 0.03)  # Refined inertia weight adjustment\n            self.c1 = 1.49445 + 0.4 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.6 * (1 - evals / self.budget)  # Slight adjustment on dynamic factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance global convergence by introducing inertia weight dampening and personal influence factor adjustment.", "configspace": "", "generation": 54, "fitness": 0.13174804473400034, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.1321091531746712, 0.13116511023148314, 0.13196987079584666]}, "mutation_prompt": null}
{"id": "e305cf47-e25e-4b3a-b045-b0af367928f7", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.85 + 0.1 * np.cos(np.pi * evals / self.budget)  # Modified crossover rate dynamics\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhanced velocity and crossover dynamics to improve exploration and convergence balance.", "configspace": "", "generation": 55, "fitness": 0.12955689345365837, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.1305929099739338, 0.13162356452490376, 0.12645420586213751]}, "mutation_prompt": null}
{"id": "2c1c8c9c-ba67-467b-bd7f-347a83ea26c3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand() * (1 - evals / self.budget)  # Introduce dynamic scaling for crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic crossover rate scaling in DE for enhanced exploration.", "configspace": "", "generation": 56, "fitness": 0.13251306425141765, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13499145008115832, 0.13118793506541804, 0.13135980760767663]}, "mutation_prompt": null}
{"id": "f18e9cea-0553-4afd-9bbe-705f27c5472f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03) * np.random.rand()  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a stochastic dynamic inertia factor for improved exploration and exploitation balance.", "configspace": "", "generation": 57, "fitness": 0.13112683962265537, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13124195677490524, 0.13091475202767222, 0.13122381006538864]}, "mutation_prompt": null}
{"id": "03d9403f-4c41-4dd5-97cb-fefe5180e5a2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)\n            dynamic_global_factor = 0.5 + 0.5 * (evals / self.budget)  # New dynamic global influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        dynamic_global_factor * self.c2 * r2 * (global_best - population))  # Adjust global factor\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Improve convergence by dynamically adjusting the global influence factor.", "configspace": "", "generation": 58, "fitness": 0.13129901805781452, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13439627384651565, 0.13044795888399463, 0.12905282144293329]}, "mutation_prompt": null}
{"id": "32938a9a-e28e-4a4a-bee9-2104d14a69d2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * (evals / self.budget)**2) + np.random.normal(0, 0.03)  # Nonlinear decay for inertia weight\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * np.cos(evals * np.pi / (2 * self.budget))  # Dynamic mutation factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a nonlinear decay for inertia weight and a dynamic mutation factor to enhance exploration and exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.13196741562090394, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13091961494238014, 0.13065338730481835, 0.13432924461551332]}, "mutation_prompt": null}
{"id": "c038ef6a-8708-4b1f-9578-927618856eab", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # Adjusted dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.95 * np.random.rand()  # Adjusted stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance the dynamic scaling and crossover strategies for improved exploration and exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.1324249390335275, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.1335388977460572, 0.13131152043903327, 0.13242439891549207]}, "mutation_prompt": null}
{"id": "67c4a9b5-d1a3-4a2e-8fa1-2fa78db99fb6", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection with local search refinement\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial + 0.05 * np.random.uniform(-1, 1, self.dim)  # Add local search refinement\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Incorporate adaptive local search to refine the best solutions and improve convergence.", "configspace": "", "generation": 61, "fitness": 0.13107311097266683, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.1324831366661069, 0.12942519569892907, 0.13131100055296452]}, "mutation_prompt": null}
{"id": "266267a9-08f8-4fa9-8d06-c4aa90c7c3a0", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * (1 - evals / self.budget)  # Adaptive crossover rate based on evals\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce adaptive dynamic crossover probability to enhance exploration-exploitation balance.", "configspace": "", "generation": 62, "fitness": 0.12969789020400888, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13085730192283207, 0.13152725644375662, 0.1267091122454379]}, "mutation_prompt": null}
{"id": "435768d3-958d-4d85-b1c6-3b927ec06f39", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.6 + 0.4 * (1 - evals / self.budget)  # Updated dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Fine-tune the dynamic personal influence factor to enhance convergence efficiency.", "configspace": "", "generation": 63, "fitness": 0.13273802772936683, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13360950352917766, 0.1306051888132087, 0.1339993908457141]}, "mutation_prompt": null}
{"id": "074f4de4-f5ca-43f2-8a4f-ec1903448a87", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adaptive_mutation_factor = 0.5 + 0.5 * np.cos(np.pi * evals / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(population[a] + adaptive_mutation_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce an adaptive mutation factor to improve exploration and convergence balance.", "configspace": "", "generation": 64, "fitness": 0.13278987414739632, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13337854856241416, 0.13099297547516187, 0.13399809840461296]}, "mutation_prompt": null}
{"id": "afb5d6f5-76fc-4428-b0f4-74d43c168b8e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Added random perturbation vector\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]) + perturbation, lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce additional random perturbation in the DE mutation process to enhance exploration capabilities.", "configspace": "", "generation": 65, "fitness": 0.13155080565848512, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.131301886200482, 0.13090596247690955, 0.13244456829806384]}, "mutation_prompt": null}
{"id": "983b1a47-f48e-4ad7-b0dc-0fa596940988", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03) + 0.1 * (1 - evals / self.budget)  # Fine-tuned inertia weight\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic inertia weight further fine-tuned by a small adaptive factor for better exploration-exploitation balance.", "configspace": "", "generation": 66, "fitness": 0.13252963362369366, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.1320382949490747, 0.1311131979084329, 0.1344374080135734]}, "mutation_prompt": null}
{"id": "87ad2235-5120-4e88-8b9d-6e111445e6b2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * np.exp(-evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * np.exp(-evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Refine dynamic factors by introducing exponential decay for improved exploration-exploitation balance.", "configspace": "", "generation": 67, "fitness": 0.13281135304372557, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13359591881799004, 0.13076917041736025, 0.1340689698958264]}, "mutation_prompt": null}
{"id": "816fe597-94d3-4ae7-9866-1a88703ccad1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic scaling factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Adaptive boundary handling\n            population = np.where(population < lb, lb + 0.1 * (ub - lb), population)  \n            population = np.where(population > ub, ub - 0.1 * (ub - lb), population)\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce adaptive boundary handling to maintain exploration without violating constraints.", "configspace": "", "generation": 68, "fitness": 0.13292119911466083, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13354379780779746, 0.13113475175531564, 0.13408504778086938]}, "mutation_prompt": null}
{"id": "e24523d9-d1cd-4862-b37d-cbf955db3b32", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.8 + 0.2 * np.random.rand()  # Introduce dynamic mutation factor\n                mutant = np.clip(population[a] + self.mutation_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance exploration by introducing a dynamic mutation factor for better diversity in the DE component.", "configspace": "", "generation": 69, "fitness": 0.13053374880547997, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13367767052250412, 0.12980739713771283, 0.12811617875622294]}, "mutation_prompt": null}
{"id": "cca5d36c-044f-4316-a190-28fcf7501207", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce an adaptive mutation factor that decreases over time to enhance convergence in later stages.", "configspace": "", "generation": 70, "fitness": 0.1329556579284256, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "563d629c-eb7c-4eef-96bf-64d1f15717ac", "metadata": {"aucs": [0.13359763396235202, 0.13135303886215677, 0.133916300960768]}, "mutation_prompt": null}
{"id": "5495acc7-b245-4d40-832b-f8ecc1b8daa4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        # Adaptive velocity limit scaling based on budget utilization\n        v_max = (ub - lb) * (0.5 + 0.5 * (1 - self.budget / self.budget))  \n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            velocity = np.clip(velocity, -v_max, v_max)  # Apply velocity limit\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce adaptive velocity limit scaling to maintain diversity and prevent premature convergence in the population.", "configspace": "", "generation": 71, "fitness": 0.13253967922958557, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1327613758582754, 0.13170066835081906, 0.13315699347966226]}, "mutation_prompt": null}
{"id": "6225d9a4-8ca5-4e48-ad34-0b5badad28d3", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - np.std(population, axis=0))  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * np.std(population, axis=0)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic scaling for personal best influence and adaptively adjust mutation factor based on variance of population.", "configspace": "", "generation": 72, "fitness": 0.12845215067038585, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.131955932578526, 0.12799526298010067, 0.12540525645253087]}, "mutation_prompt": null}
{"id": "730410e2-53ac-478a-a42b-fe341ba6994f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            self.c2 = self.c2 + (0.5 * evals / self.budget)  # Dynamic global factor adjustment\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * (1 - evals / self.budget)  # Enhance stochastic crossover adaptation\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic global factor and enhance stochastic crossover adaptation to boost exploration.", "configspace": "", "generation": 73, "fitness": 0.13098278176472367, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13229842545136727, 0.13197950742752806, 0.12867041241527566]}, "mutation_prompt": null}
{"id": "eda6eebd-a3c4-4b64-b717-1bef703c90a4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            # Additive Gaussian noise to velocity for enhanced exploration\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population) +\n                        np.random.normal(0, 0.1, (self.population_size, self.dim)))  # Adding Gaussian noise\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance exploration by introducing Gaussian noise in the velocity update equation.", "configspace": "", "generation": 74, "fitness": 0.13274667458746126, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13508657484157482, 0.12976184051626583, 0.13339160840454312]}, "mutation_prompt": null}
{"id": "26123e50-2104-4743-9b0c-ef61b851e5a1", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        previous_velocity = np.zeros_like(velocity)  # Initialization of previous velocity for momentum\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population) +\n                        0.1 * previous_velocity)  # Added momentum term with weight 0.1\n            previous_velocity = velocity.copy()  # Save current velocity for the next iteration\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "HybridPSO_DE with momentum term in velocity update to stabilize convergence.", "configspace": "", "generation": 75, "fitness": 0.13245681079385638, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13205877203645877, 0.1310312391560795, 0.13428042118903083]}, "mutation_prompt": null}
{"id": "b934d1fe-07f2-4120-90c3-cd251e5ba841", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            velocity = np.clip(velocity, -0.5, 0.5)  # Added velocity clamping\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand() + 0.1  # Slightly raised base crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance exploration with dynamic velocity and crossover adjustments for improved convergence.", "configspace": "", "generation": 76, "fitness": 0.12802927832274372, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13002915566768058, 0.1287052742114717, 0.12535340508907888]}, "mutation_prompt": null}
{"id": "06221632-7fc4-4ed8-8c12-22b96573725b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            self.c2 = 1.49445 + 0.5 * (1 - evals / self.budget)  # New dynamic adjustment for social factor\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce dynamic scaling of the cognitive and social components to maintain diversity and improve convergence.", "configspace": "", "generation": 77, "fitness": 0.13084845754136168, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1313696769275161, 0.13151093180714535, 0.1296647638894236]}, "mutation_prompt": null}
{"id": "e775e81e-4c5c-4473-bdb4-e357717cea30", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * (0.1 + 0.9 * (evals / self.budget))  # Adaptive crossover rate increasing over time\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Refine the algorithm by incorporating an adaptive crossover rate that increases over time to improve solution diversity in the early stages.", "configspace": "", "generation": 78, "fitness": 0.13042445975462735, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1331485399314134, 0.12915969992975063, 0.12896513940271803]}, "mutation_prompt": null}
{"id": "7e9b0d4e-6d08-4bea-b0b2-a9cbf513b8c8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) ** 2 + 0.1 * np.sin(2 * np.pi * evals / self.budget)  # Sinusoidal modulation\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a sinusoidal modulation to the dynamic mutation factor for enhanced exploration across budget phases.", "configspace": "", "generation": 79, "fitness": 0.13277757589565822, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1334909496848382, 0.13075823453850677, 0.13408354346362972]}, "mutation_prompt": null}
{"id": "77f5d603-ce6c-4684-9f30-e42b0d32b172", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            dynamic_global_factor = 0.5 + 0.5 * (evals / self.budget)  # New dynamic global influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        dynamic_global_factor * self.c2 * r2 * (global_best - population))  # Adjust dynamic global factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic global influence factor in PSO to balance exploration and exploitation more effectively.", "configspace": "", "generation": 80, "fitness": 0.13169220823885944, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1344070976339844, 0.13087071142455087, 0.12979881565804308]}, "mutation_prompt": null}
{"id": "34a18953-1d15-4673-995e-25b00e3c3b5c", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic learning rate to improve exploration and convergence balance in the optimization process.", "configspace": "", "generation": 81, "fitness": 0.1329556579284256, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13359763396235202, 0.13135303886215677, 0.133916300960768]}, "mutation_prompt": null}
{"id": "50c0ed0e-6c4d-476d-8896-c73e2b2be11e", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Occasional perturbation for exploration enhancement\n            if evals % (self.population_size * 10) == 0:  # Add perturbation every 10 iterations\n                perturbation = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n                population += perturbation\n                population = np.clip(population, lb, ub)\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Integrated an occasional perturbation mechanism to escape local optima and improve exploration.", "configspace": "", "generation": 82, "fitness": 0.1329556579284256, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13359763396235202, 0.13135303886215677, 0.133916300960768]}, "mutation_prompt": null}
{"id": "a0f7e3b7-499c-4728-bab0-9aa1a12e6d7a", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * (1 - evals / self.budget)  # Time-varying crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a time-varying crossover rate to enhance exploration during early stages and exploitation later on.", "configspace": "", "generation": 83, "fitness": 0.12940779710134084, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1308422665917658, 0.13130811879075144, 0.12607300592150528]}, "mutation_prompt": null}
{"id": "74cdd4ef-d4ad-4463-9020-fc100cd0a3f4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.3 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce an adaptive personal influence factor that dynamically decreases with evaluations for enhanced exploration.", "configspace": "", "generation": 84, "fitness": 0.13264037787939298, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.132881748482236, 0.1310939546225366, 0.13394543053340635]}, "mutation_prompt": null}
{"id": "894e1985-ab7b-4997-979c-d9df72bc2825", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            self.c2 = 1.49445 - 0.5 * (evals / self.budget)  # New dynamic learning factor for velocity update\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a dynamic learning factor for velocity update to enhance exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.13226815280885787, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13155626455829184, 0.1312377230126901, 0.1340104708555917]}, "mutation_prompt": null}
{"id": "2383c901-44e4-4790-9b2a-563ef0aac668", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * np.tanh((1 - evals / self.budget))  # Non-linear decay\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * (0.5 + 0.5 * np.sin(np.pi * evals / self.budget))  # Dynamic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a non-linear decay for the mutation factor and dynamic crossover rate for smoother adaptation.", "configspace": "", "generation": 86, "fitness": 0.12912172231177454, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13097735001638322, 0.12953550438082784, 0.12685231253811258]}, "mutation_prompt": null}
{"id": "02b8841f-5e17-4040-843d-df65503e2a2f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector with Gaussian perturbation\n                trial_value = func(trial + np.random.normal(0, 0.01, size=self.dim))\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a Gaussian perturbation to enhance exploration without significantly altering the existing strategy.", "configspace": "", "generation": 87, "fitness": 0.1313523157790155, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1318076200966044, 0.13045303121185947, 0.13179629602858256]}, "mutation_prompt": null}
{"id": "9e6b7c16-95ea-42a4-9219-06363b42db81", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 0.5 + 0.7 * (1 - evals / self.budget) ** 2  # Adjusted dynamic factor\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.8 + 0.2 * np.random.rand()  # Refined stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Refine the mutation and crossover strategies with dynamic scaling to enhance diversity and convergence.", "configspace": "", "generation": 88, "fitness": 0.12985984752689683, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13086179840433032, 0.13171911240848144, 0.12699863176787873]}, "mutation_prompt": null}
{"id": "59c1f2c2-3f01-45f3-9c8a-06b7b4594db2", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial + np.random.normal(0, 0.1, self.dim))  # Add Gaussian perturbation\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce local neighborhood search using Gaussian perturbation to enhance local exploitation.", "configspace": "", "generation": 89, "fitness": 0.13135742805183248, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13181964541072733, 0.13044549397022398, 0.13180714477454614]}, "mutation_prompt": null}
{"id": "97f331f5-b43b-4265-9a46-ef36f0053eca", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.momentum = 0.1  # New: Introduce momentum factor\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            velocity = self.momentum * velocity + (1 - self.momentum) * velocity  # New: Apply momentum to velocity\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a momentum factor in velocity updates to stabilize exploration and improve convergence.", "configspace": "", "generation": 90, "fitness": 0.1329556579284256, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13359763396235202, 0.13135303886215677, 0.133916300960768]}, "mutation_prompt": null}
{"id": "fbda83c8-364b-4ab5-b444-35bf64fb24ff", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i] or np.random.rand() < 0.05:  # Added condition for diversity\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce an adaptive personal best update mechanism to enhance diversity and convergence.", "configspace": "", "generation": 91, "fitness": 0.13178160067472866, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1311590782871893, 0.1301336614279287, 0.13405206230906797]}, "mutation_prompt": null}
{"id": "703ecc0b-401a-4b91-9b09-0b6fac6dff1f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector with dynamic reweighting\n                trial_value = func(trial) * (0.5 + 0.5 * (evals / self.budget))\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Integrate dynamic reweighting of fitness values to enhance exploration-exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.13145284419755943, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13168374491813306, 0.13094247461922126, 0.13173231305532396]}, "mutation_prompt": null}
{"id": "126f57be-66ce-4563-a6c0-ca4c6bf381be", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.85 + 0.05 * (1 - evals / self.budget)  # Improved dynamic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Improved convergence by incorporating a dynamic crossover rate and velocity adjustment to better balance exploration and exploitation.", "configspace": "", "generation": 93, "fitness": 0.12961609757494233, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13098733773034765, 0.13098567349037882, 0.12687528150410055]}, "mutation_prompt": null}
{"id": "a9fdd5f2-2140-4134-89af-3cb93d53b6a4", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * (evals / self.budget)  # Introduce adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Improve the algorithm by introducing an adaptive crossover rate that increases over time to enhance exploration in early stages.", "configspace": "", "generation": 94, "fitness": 0.13198156535264982, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13278191697037844, 0.1304928574024221, 0.1326699216851489]}, "mutation_prompt": null}
{"id": "f707be9b-63eb-4a65-a62c-df38660ff3e8", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index] + np.random.normal(0, 0.001, self.dim)  # Slight perturbation\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a slight stochastic perturbation to the global best position to enhance exploration.", "configspace": "", "generation": 95, "fitness": 0.1314822902572943, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1318394347508839, 0.13083341843879526, 0.13177401758220375]}, "mutation_prompt": null}
{"id": "1746fd44-5560-460c-976c-0e2e8b043050", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            dynamic_global_factor = 0.5 + 0.5 * (evals / self.budget)  # Dynamic global influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        dynamic_global_factor * self.c2 * r2 * (global_best - population))  # Adjust dynamic personal and global factors here\n            if np.random.rand() < 0.05:  # Stochastic velocity reset\n                velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance diversity by introducing stochastic velocity reset and dynamic personal/global influence scaling in PSO.", "configspace": "", "generation": 96, "fitness": 0.13266905119819364, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.1344070976339844, 0.13117036740170007, 0.13242968855889647]}, "mutation_prompt": null}
{"id": "da3da7a0-0147-4377-a72e-1375246fcc3f", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 - 0.4 * (evals / self.budget)  # Dynamic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance convergence by dynamically adjusting the crossover rate based on the number of evaluations.", "configspace": "", "generation": 97, "fitness": 0.12990088638131123, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13134249102009965, 0.1313276207037698, 0.1270325474200642]}, "mutation_prompt": null}
{"id": "afca12f6-0aee-44f4-a1e8-cb9a99070d41", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)  # Modified inertia weight adjustment\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)  # Adaptive acceleration coefficient for personal best\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)  # New dynamic personal influence factor\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))  # Adjust dynamic personal factor here\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Updated mutation factor with adaptive decay\n                dynamic_factor = 0.5 + 0.5 * (1 - evals / self.budget) * (1 - evals / self.budget)  \n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.crossover_rate = 0.9 * np.random.rand()  # Introduce stochastic crossover rate\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value + np.random.normal(0, 0.01)  # Small random noise added here\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Introduce a small random noise to personal best values to potentially escape local optima.", "configspace": "", "generation": 98, "fitness": 0.13132328323303835, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13231796495222814, 0.13010533039573502, 0.13154655435115192]}, "mutation_prompt": null}
{"id": "74a7a0b2-7128-4f27-a902-30838c03486b", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.c1 = 1.49445\n        self.c2 = 1.49445\n        self.w = 0.729\n        self.initial_mutation_factor = 0.8\n        self.initial_crossover_rate = 0.9\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n\n        personal_best = population.copy()\n        personal_best_value = np.array([func(ind) for ind in population])\n        global_best = personal_best[np.argmin(personal_best_value)]\n        global_best_value = np.min(personal_best_value)\n\n        evals = self.population_size\n        while evals < self.budget:\n            # PSO Update with dynamic inertia weight\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (0.4 * evals / self.budget) + np.random.normal(0, 0.03)\n            self.c1 = 1.49445 + 0.5 * (evals / self.budget)\n            dynamic_personal_factor = 0.5 + 0.5 * (1 - evals / self.budget)\n            velocity = (self.w * velocity + \n                        dynamic_personal_factor * self.c1 * r1 * (personal_best - population) + \n                        self.c2 * r2 * (global_best - population))\n            population = population + velocity\n            population = np.clip(population, lb, ub)\n\n            diversity = np.mean(np.std(population, axis=0))  # Calculate population diversity\n\n            # DE Update\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = self.initial_mutation_factor * diversity  # Adapt mutation factor based on diversity\n                mutant = np.clip(population[a] + dynamic_factor * (population[b] - population[c]), lb, ub)\n                self.initial_crossover_rate = 0.9 * diversity  # Adapt crossover rate based on diversity\n                cross_points = np.random.rand(self.dim) < self.initial_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Evaluate trial vector\n                trial_value = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_value < personal_best_value[i]:\n                    personal_best[i] = trial\n                    personal_best_value[i] = trial_value\n\n            # Update global best\n            min_index = np.argmin(personal_best_value)\n            if personal_best_value[min_index] < global_best_value:\n                global_best = personal_best[min_index]\n                global_best_value = personal_best_value[min_index]\n\n            if evals >= self.budget:\n                break\n\n        return global_best, global_best_value", "name": "HybridPSO_DE", "description": "Enhance convergence by integrating a self-adaptive strategy for mutation and crossover rates based on population diversity.", "configspace": "", "generation": 99, "fitness": 0.12732643397429852, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.00.", "error": "", "parent_id": "cca5d36c-044f-4316-a190-28fcf7501207", "metadata": {"aucs": [0.13002915566768058, 0.1274424380380501, 0.12450770821716484]}, "mutation_prompt": null}
