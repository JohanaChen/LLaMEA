{"id": "2c3e9e85-efdc-49e1-98c9-bb08fd1201ba", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 10\n        self.bandwidth = 0.01\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            new_harmony = np.clip(np.random.uniform(-self.bandwidth, self.bandwidth, size=self.dim) + np.random.choice(self.harmony_memory), self.lower_bound, self.upper_bound)\n            if func(new_harmony) < func(self.harmony_memory[-1]):\n                self.harmony_memory[-1] = new_harmony\n                self.harmony_memory = self.harmony_memory[np.argsort([func(h) for h in self.harmony_memory])]\n        return self.harmony_memory[0]", "name": "HarmonySearch", "description": "Harmony Search Algorithm based on the musical improvisation process to find optimal solutions", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 15, in __call__\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n.", "error": "ValueError('a must be 1-dimensional')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 15, in __call__\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "e78a53c1-009c-48f9-b7ea-d0cc65123128", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.harmony_memory_size = 10\n        self.bandwidth = 0.01\n        self.harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, size=(self.harmony_memory_size, self.dim))\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            new_harmony = np.clip(np.random.uniform(-self.bandwidth, self.bandwidth, size=self.dim) + np.random.choice(self.harmony_memory), self.lower_bound, self.upper_bound)\n            if func(new_harmony) < func(self.harmony_memory[-1]):\n                self.harmony_memory[-1] = new_harmony\n                self.harmony_memory = self.harmony_memory[np.argsort([func(h) for h in self.harmony_memory])]\n        return self.harmony_memory[0]", "name": "HarmonySearch", "description": "Harmony Search Algorithm based on the musical improvisation process to find optimal solutions", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2c3e9e85-efdc-49e1-98c9-bb08fd1201ba", "metadata": {}, "mutation_prompt": null}
