{"id": "a643517b-4749-453c-8692-cad077060ee4", "solution": "import numpy as np\n\nclass ABC_DNS_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.limit = 0.6\n        self.max_trials = 100\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def __call__(self, func):\n        def random_solution():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        \n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.math.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v) ** (1 / beta)\n            return step\n        \n        def fitness(solution):\n            return func(solution)\n        \n        best_solution = random_solution()\n        best_fitness = fitness(best_solution)\n        \n        population = [random_solution() for _ in range(self.pop_size)]\n        trials = np.zeros(self.pop_size)\n        \n        for _ in range(self.budget):\n            for i, solution in enumerate(population):\n                new_solution = solution + levy_flight()\n                new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                new_fitness = fitness(new_solution)\n                \n                if new_fitness < fitness(solution):\n                    population[i] = new_solution\n                    trials[i] = 0\n                    if new_fitness < best_fitness:\n                        best_solution = new_solution\n                        best_fitness = new_fitness\n                else:\n                    trials[i] += 1\n                    if trials[i] >= self.max_trials:\n                        trials[i] = 0\n                        population[i] = random_solution()\n            \n            # Dynamic neighborhood search\n            for i in range(self.pop_size):\n                neighborhood = np.random.choice(population, self.neighborhood_size, replace=False)\n                best_neighbor = min(neighborhood, key=lambda x: fitness(x))\n                if fitness(best_neighbor) < fitness(population[i]):\n                    population[i] = best_neighbor\n            \n        return best_solution", "name": "ABC_DNS_Optimizer", "description": "Novel Artificial Bee Colony Algorithm with Dynamic Neighborhood Search for Black Box Optimization", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 55, in __call__\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n.", "error": "ValueError('a must be 1-dimensional')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 55, in __call__\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "d637b035-58b0-4b75-a982-6bd87a6394d3", "solution": "import numpy as np\n\nclass ABC_DNS_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 50\n        self.limit = 0.6\n        self.max_trials = 100\n        self.neighborhood_size = 5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n    \n    def __call__(self, func):\n        def random_solution():\n            return np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        \n        def levy_flight():\n            beta = 1.5\n            sigma = (np.math.gamma(1 + beta) * np.math.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n            u = np.random.normal(0, sigma, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.abs(v) ** (1 / beta)\n            return step\n        \n        def fitness(solution):\n            return func(solution)\n        \n        best_solution = random_solution()\n        best_fitness = fitness(best_solution)\n        \n        population = [random_solution() for _ in range(self.pop_size)]\n        trials = np.zeros(self.pop_size)\n        \n        for _ in range(self.budget):\n            for i, solution in enumerate(population):\n                new_solution = solution + levy_flight()\n                new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                new_fitness = fitness(new_solution)\n                \n                if new_fitness < fitness(solution):\n                    population[i] = new_solution\n                    trials[i] = 0\n                    if new_fitness < best_fitness:\n                        best_solution = new_solution\n                        best_fitness = new_fitness\n                else:\n                    trials[i] += 1\n                    if trials[i] >= self.max_trials:\n                        trials[i] = 0\n                        population[i] = random_solution()\n            \n            # Dynamic neighborhood search\n            for i in range(self.pop_size):\n                neighborhood = np.random.choice(population, self.neighborhood_size, replace=False)\n                best_neighbor = min(neighborhood, key=lambda x: fitness(x))\n                if fitness(best_neighbor) < fitness(population[i]):\n                    population[i] = best_neighbor\n            \n        return best_solution", "name": "ABC_DNS_Optimizer", "description": "Novel Artificial Bee Colony Algorithm with Dynamic Neighborhood Search for Black Box Optimization", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a643517b-4749-453c-8692-cad077060ee4", "metadata": {}, "mutation_prompt": null}
