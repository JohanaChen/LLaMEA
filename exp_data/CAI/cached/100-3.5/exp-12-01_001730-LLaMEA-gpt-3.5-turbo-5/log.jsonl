{"id": "d5ba5767-9ab1-4dbd-9536-110ac83e87a3", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "9e629919-007b-4e7f-9e85-b64fb6777b3d", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.max_iter = budget // self.population_size\n\n    def __call__(self, func):\n        def fitness(x):\n            return func(x)\n\n        def initialize_population():\n            return np.random.uniform(-5, 5, (self.population_size, self.dim))\n\n        def pso(particles):\n            # Particle Swarm Optimization\n            c1 = 2.0\n            c2 = 2.0\n            w = 0.7\n            pbest = particles.copy()\n            pbest_fit = np.array([fitness(p) for p in pbest])\n            gbest_idx = np.argmin(pbest_fit)\n            gbest = pbest[gbest_idx].copy()\n\n            for _ in range(self.max_iter):\n                r1 = np.random.rand(self.population_size, self.dim)\n                r2 = np.random.rand(self.population_size, self.dim)\n                v = w * v + c1 * r1 * (pbest - particles) + c2 * r2 * (gbest - particles)\n                particles = particles + v\n                particles = np.clip(particles, -5, 5)\n                current_fit = np.array([fitness(p) for p in particles])\n                update_indices = current_fit < pbest_fit\n                pbest[update_indices] = particles[update_indices]\n                pbest_fit[update_indices] = current_fit[update_indices]\n                gbest_idx = np.argmin(pbest_fit)\n                gbest = pbest[gbest_idx]\n\n            return gbest\n\n        def de(population):\n            # Differential Evolution\n            cr = 0.9\n            f = 0.8\n            scale_factor = 0.5\n            bounds = [(-5, 5)] * self.dim\n            for _ in range(self.max_iter):\n                for i in range(self.population_size):\n                    target = population[i]\n                    indices = [idx for idx in range(self.population_size) if idx != i]\n                    a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                    mutant = np.clip(a + f * (b - c), -5, 5)\n                    crossover = np.random.rand(self.dim) < cr\n                    trial = np.where(crossover, mutant, target)\n                    if fitness(trial) < fitness(target):\n                        population[i] = trial\n\n            return population[np.argmin([fitness(p) for p in population])]\n\n        best_solution = np.zeros(self.dim)\n        population = initialize_population()\n\n        for _ in range(self.max_iter):\n            new_solutions = np.array([pso(p) for p in population])\n            population = np.array([de(p) for p in new_solutions])\n\n        best_solution = population[np.argmin([fitness(p) for p in population])]\n        return best_solution", "name": "HybridPSODE", "description": "Utilizing a hybrid optimization approach combining particle swarm optimization (PSO) and differential evolution (DE) to efficiently explore the search space and exploit promising regions for improved optimization performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1. Sphere (iid=1 dim=5)>, 0.48813503927324753').", "error": "TypeError('__call__(): incompatible function arguments. The following argument types are supported:\\n    1. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[float]) -> float\\n    2. (self: ioh.iohcpp.problem.RealSingleObjective, arg0: List[List[float]]) -> List[float]\\n\\nInvoked with: <RealSingleObjectiveProblem 1. Sphere (iid=1 dim=5)>, 0.48813503927324753')", "parent_id": "d5ba5767-9ab1-4dbd-9536-110ac83e87a3", "metadata": {}, "mutation_prompt": null}
