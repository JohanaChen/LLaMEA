{"id": "e32be09a-9571-49e4-96e9-cf74d120699c", "solution": "import numpy as np\n\nclass DE_PSO_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.max_iter = budget // self.population_size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.7\n        self.cr = 0.9\n        self.f = 0.5\n\n    def __call__(self, func):\n        def initialize_population():\n            return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n        def clipToBounds(population):\n            return np.clip(population, self.lb, self.ub)\n\n        def evaluate_population(population):\n            return np.array([func(individual) for individual in population])\n\n        def mutate(current, pbest, gbest):\n            return current + self.f * (pbest - current) + self.f * (gbest - current)\n\n        def DE_Operator(population, fitness_values):\n            pbest_idx = np.argmin(fitness_values)\n            gbest_idx = np.argmin(fitness_values)\n            new_population = []\n            for idx, current in enumerate(population):\n                a, b, c = np.random.choice(population, 3, replace=False)\n                mutant = mutate(current, a, b)\n                crossover_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover_points, mutant, current)\n                if func(trial) < fitness_values[idx]:\n                    new_population.append(trial)\n                else:\n                    new_population.append(current)\n            return np.array(new_population), pbest_idx, gbest_idx\n\n        def PSO_Operator(population, fitness_values, pbest_idx, gbest_idx):\n            velocities = np.zeros((self.population_size, self.dim))\n            pbest = population[pbest_idx]\n            gbest = population[gbest_idx]\n            for _ in range(self.max_iter):\n                for idx, current in enumerate(population):\n                    r1, r2 = np.random.uniform(0, 1, (2, self.dim))\n                    velocities[idx] = self.w * velocities[idx] + self.c1 * r1 * (pbest - current) + self.c2 * r2 * (gbest - current)\n                    population[idx] = clipToBounds(current + velocities[idx])\n                fitness_values = evaluate_population(population)\n                pbest_idx, gbest_idx = DE_Operator(population, fitness_values)[1:]\n                pbest = population[pbest_idx]\n                gbest = population[gbest_idx]\n            return gbest\n\n        population = initialize_population()\n        fitness_values = evaluate_population(population)\n        pbest_idx, gbest_idx = DE_Operator(population, fitness_values)[1:]\n        gbest = PSO_Operator(population, fitness_values, pbest_idx, gbest_idx)\n        return gbest", "name": "DE_PSO_Optimizer", "description": "An adaptive hybrid optimization algorithm that combines Differential Evolution (DE) with Particle Swarm Optimization (PSO) to efficiently explore the search space and exploit promising regions.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 62, in __call__\n  File \"<string>\", line 35, in DE_Operator\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n.", "error": "ValueError('a must be 1-dimensional')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 62, in __call__\n  File \"<string>\", line 35, in DE_Operator\n  File \"mtrand.pyx\", line 930, in numpy.random.mtrand.RandomState.choice\nValueError: a must be 1-dimensional\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "a37ae86c-a812-4ccf-8a4e-411684784e36", "solution": "import numpy as np\n\nclass DE_PSO_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.max_iter = budget // self.population_size\n        self.lb = -5.0\n        self.ub = 5.0\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.w = 0.7\n        self.cr = 0.9\n        self.f = 0.5\n\n    def __call__(self, func):\n        def initialize_population():\n            return np.random.uniform(self.lb, self.ub, (self.population_size, self.dim))\n\n        def clipToBounds(population):\n            return np.clip(population, self.lb, self.ub)\n\n        def evaluate_population(population):\n            return np.array([func(individual) for individual in population])\n\n        def mutate(current, pbest, gbest):\n            return current + self.f * (pbest - current) + self.f * (gbest - current)\n\n        def DE_Operator(population, fitness_values):\n            pbest_idx = np.argmin(fitness_values)\n            gbest_idx = np.argmin(fitness_values)\n            new_population = []\n            for idx, current in enumerate(population):\n                a, b, c = np.random.choice(population, 3, replace=False)\n                mutant = mutate(current, a, b)\n                crossover_points = np.random.rand(self.dim) < self.cr\n                trial = np.where(crossover_points, mutant, current)\n                if func(trial) < fitness_values[idx]:\n                    new_population.append(trial)\n                else:\n                    new_population.append(current)\n            return np.array(new_population), pbest_idx, gbest_idx\n\n        def PSO_Operator(population, fitness_values, pbest_idx, gbest_idx):\n            velocities = np.zeros((self.population_size, self.dim))\n            pbest = population[pbest_idx]\n            gbest = population[gbest_idx]\n            for _ in range(self.max_iter):\n                for idx, current in enumerate(population):\n                    r1, r2 = np.random.uniform(0, 1, (2, self.dim))\n                    velocities[idx] = self.w * velocities[idx] + self.c1 * r1 * (pbest - current) + self.c2 * r2 * (gbest - current)\n                    population[idx] = clipToBounds(current + velocities[idx])\n                fitness_values = evaluate_population(population)\n                pbest_idx, gbest_idx = DE_Operator(population, fitness_values)[1:]\n                pbest = population[pbest_idx]\n                gbest = population[gbest_idx]\n            return gbest\n\n        population = initialize_population()\n        fitness_values = evaluate_population(population)\n        pbest_idx, gbest_idx = DE_Operator(population, fitness_values)[1:]\n        gbest = PSO_Operator(population, fitness_values, pbest_idx, gbest_idx)\n        return gbest", "name": "DE_PSO_Optimizer", "description": "An adaptive hybrid optimization algorithm that combines Differential Evolution (DE) with Particle Swarm Optimization (PSO) to efficiently explore the search space and exploit promising regions.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e32be09a-9571-49e4-96e9-cf74d120699c", "metadata": {}, "mutation_prompt": null}
