{"id": "6abad724-8445-452a-817a-e6f0fdbdd177", "solution": "import numpy as np\n\nclass GAVariablePopSize:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10\n        self.max_pop_size = 50\n        self.min_pop_size = 5\n        self.pc = 0.8\n        self.pm = 1/dim\n\n    def __call__(self, func):\n        def initialize_population():\n            return np.random.uniform(-5.0, 5.0, size=(self.pop_size, self.dim))\n\n        def mutate(child):\n            mask = np.random.rand(self.dim) < self.pm\n            child[mask] = np.random.uniform(-5.0, 5.0, size=np.sum(mask))\n            return child\n\n        def crossover(parent1, parent2):\n            if np.random.rand() < self.pc:\n                idx = np.random.randint(self.dim)\n                child = np.concatenate((parent1[:idx], parent2[idx:]))\n                return child\n            else:\n                return parent1\n\n        population = initialize_population()\n        fitness = np.array([func(individual) for individual in population])\n        \n        for _ in range(self.budget):\n            sorted_indices = np.argsort(fitness)\n            population = population[sorted_indices]\n            fitness = fitness[sorted_indices]\n\n            new_population = []\n            for i in range(self.pop_size):\n                parent1, parent2 = population[np.random.choice(self.pop_size, size=2, replace=False)]\n                child = crossover(parent1, parent2)\n                child = mutate(child)\n                new_population.append(child)\n            \n            new_population = np.array(new_population)\n            new_fitness = np.array([func(individual) for individual in new_population])\n            population = np.vstack((population, new_population))\n            fitness = np.concatenate((fitness, new_fitness))\n            \n            diversity = np.mean(np.std(population, axis=0))\n            if diversity < 1e-6:\n                break\n\n            if len(population) > self.max_pop_size:\n                idx = np.argsort(fitness)[:self.min_pop_size]\n                population = population[idx]\n                fitness = fitness[idx]\n                \n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        \n        return best_solution", "name": "GAVariablePopSize", "description": "Genetic Algorithm with Variable Population Size based on Fitness Diversity", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 40, in __call__\nIndexError: index 6 is out of bounds for axis 0 with size 5\n.", "error": "IndexError('index 6 is out of bounds for axis 0 with size 5')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 40, in __call__\nIndexError: index 6 is out of bounds for axis 0 with size 5\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "ef68888e-02b4-494a-8edc-63d88e65afe8", "solution": "import numpy as np\n\nclass GAVariablePopSize:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10\n        self.max_pop_size = 50\n        self.min_pop_size = 5\n        self.pc = 0.8\n        self.pm = 1/dim\n\n    def __call__(self, func):\n        def initialize_population():\n            return np.random.uniform(-5.0, 5.0, size=(self.pop_size, self.dim))\n\n        def mutate(child):\n            mask = np.random.rand(self.dim) < self.pm\n            child[mask] = np.random.uniform(-5.0, 5.0, size=np.sum(mask))\n            return child\n\n        def crossover(parent1, parent2):\n            if np.random.rand() < self.pc:\n                idx = np.random.randint(self.dim)\n                child = np.concatenate((parent1[:idx], parent2[idx:]))\n                return child\n            else:\n                return parent1\n\n        population = initialize_population()\n        fitness = np.array([func(individual) for individual in population])\n        \n        for _ in range(self.budget):\n            sorted_indices = np.argsort(fitness)\n            population = population[sorted_indices]\n            fitness = fitness[sorted_indices]\n\n            new_population = []\n            for i in range(self.pop_size):\n                parent1, parent2 = population[np.random.choice(self.pop_size, size=2, replace=False)]\n                child = crossover(parent1, parent2)\n                child = mutate(child)\n                new_population.append(child)\n            \n            new_population = np.array(new_population)\n            new_fitness = np.array([func(individual) for individual in new_population])\n            population = np.vstack((population, new_population))\n            fitness = np.concatenate((fitness, new_fitness))\n            \n            diversity = np.mean(np.std(population, axis=0))\n            if diversity < 1e-6:\n                break\n\n            if len(population) > self.max_pop_size:\n                idx = np.argsort(fitness)[:self.min_pop_size]\n                population = population[idx]\n                fitness = fitness[idx]\n                \n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        \n        return best_solution", "name": "GAVariablePopSize", "description": "Genetic Algorithm with Variable Population Size based on Fitness Diversity", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "6abad724-8445-452a-817a-e6f0fdbdd177", "metadata": {}, "mutation_prompt": null}
