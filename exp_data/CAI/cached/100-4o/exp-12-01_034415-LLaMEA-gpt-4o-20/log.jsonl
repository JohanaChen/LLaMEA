{"id": "e37651d6-4c4a-48fe-b559-83cad7facfae", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 40\n        self.inertia_weight = 0.5\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.de_cr = 0.9\n        self.de_f = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, dim))\n        self.personal_best_pos = np.copy(self.population)\n        self.personal_best_val = np.full(self.pop_size, np.inf)\n        self.global_best_pos = None\n        self.global_best_val = np.inf\n        self.eval_count = 0\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[i] = (self.inertia_weight * self.velocities[i] + \n                              self.cognitive_const * r1 * (self.personal_best_pos[i] - self.population[i]) +\n                              self.social_const * r2 * (self.global_best_pos - self.population[i]))\n        self.population[i] += self.velocities[i]\n        self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n        value = func(self.population[i])\n        self.eval_count += 1\n        if value < self.personal_best_val[i]:\n            self.personal_best_val[i] = value\n            self.personal_best_pos[i] = self.population[i]\n        if value < self.global_best_val:\n            self.global_best_val = value\n            self.global_best_pos = self.population[i]\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            if self.eval_count >= self.budget:\n                break\n            indices = list(range(self.pop_size))\n            indices.remove(i)\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n            trial = np.where(np.random.rand(self.dim) < self.de_cr, mutant, self.population[i])\n            value = func(trial)\n            self.eval_count += 1\n            if value < func(self.population[i]):\n                self.population[i] = trial\n                if value < self.personal_best_val[i]:\n                    self.personal_best_val[i] = value\n                    self.personal_best_pos[i] = trial\n                if value < self.global_best_val:\n                    self.global_best_val = value\n                    self.global_best_pos = trial\n\n    def __call__(self, func):\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if self.eval_count >= self.budget:\n                    break\n                self.update_particle(i, func)\n            self.differential_evolution(func)\n        return self.global_best_pos, self.global_best_val", "name": "HybridPSO_DE", "description": "Hybrid Particle Swarm Optimization with Differential Evolution employs swarm intelligence and evolutionary operations to enhance search exploration and exploitation within a given budget.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 64, in __call__\n  File \"<string>\", line 27, in update_particle\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n.", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 64, in __call__\n  File \"<string>\", line 27, in update_particle\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "128ff080-7a96-42da-8a25-c774cf791c78", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 40\n        self.inertia_weight = 0.9  # Changed from 0.5\n        self.cognitive_const = 1.5\n        self.social_const = 1.5\n        self.de_cr = 0.7  # Changed from 0.9\n        self.de_f = 0.8\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, dim))\n        self.personal_best_pos = np.copy(self.population)\n        self.personal_best_val = np.full(self.pop_size, np.inf)\n        self.global_best_pos = None\n        self.global_best_val = np.inf\n        self.eval_count = 0\n\n    def update_particle(self, i, func):\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        self.velocities[i] = (self.inertia_weight * self.velocities[i] + \n                              self.cognitive_const * r1 * (self.personal_best_pos[i] - self.population[i]) +\n                              self.social_const * r2 * (self.global_best_pos - self.population[i]))\n        self.population[i] += self.velocities[i]\n        self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n        value = func(self.population[i])\n        self.eval_count += 1\n        if value < self.personal_best_val[i]:\n            self.personal_best_val[i] = value\n            self.personal_best_pos[i] = self.population[i]\n        if value < self.global_best_val:\n            self.global_best_val = value\n            self.global_best_pos = np.copy(self.population[i])  # Ensure deep copy\n\n    def differential_evolution(self, func):\n        for i in range(self.pop_size):\n            if self.eval_count >= self.budget:\n                break\n            indices = list(range(self.pop_size))\n            indices.remove(i)\n            a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n            trial = np.where(np.random.rand(self.dim) < self.de_cr, mutant, self.population[i])\n            value = func(trial)\n            self.eval_count += 1\n            if value < func(self.population[i]):\n                self.population[i] = trial\n                if value < self.personal_best_val[i]:\n                    self.personal_best_val[i] = value\n                    self.personal_best_pos[i] = trial\n                if value < self.global_best_val:\n                    self.global_best_val = value\n                    self.global_best_pos = np.copy(trial)  # Ensure deep copy\n\n    def __call__(self, func):\n        while self.eval_count < self.budget:\n            for i in range(self.pop_size):\n                if self.eval_count >= self.budget:\n                    break\n                self.update_particle(i, func)\n            self.differential_evolution(func)\n            # Update inertia weight to improve adaptive behavior\n            self.inertia_weight = 0.4 + 0.5 * (self.eval_count / self.budget)\n        return self.global_best_pos, self.global_best_val", "name": "HybridPSO_DE", "description": "Enhanced HybridPSO_DE algorithm with adaptive parameter tuning for improved exploration and exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "e37651d6-4c4a-48fe-b559-83cad7facfae", "metadata": {}, "mutation_prompt": null}
