{"id": "5a122678-16f7-4a76-8c56-1c8990982bd4", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        self.F = 0.5 # Differential weight\n        self.CR = 0.9 # Crossover probability\n\n    def differential_evolution(self, target_idx):\n        idxs = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n        mutant_vector = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        trial_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.CR else self.population[target_idx][i]\n            for i in range(self.dim)\n        ])\n        return trial_vector\n\n    def simulated_annealing(self, candidate, candidate_fitness):\n        t_initial = 1.0\n        t_final = 0.01\n        alpha = 0.99\n        t = t_initial\n        current_solution = candidate\n        current_fitness = candidate_fitness\n\n        while t > t_final:\n            neighbor = current_solution + np.random.uniform(-0.1, 0.1, self.dim)\n            neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n            neighbor_fitness = self.evaluate(neighbor)\n\n            if neighbor_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - neighbor_fitness) / t):\n                current_solution = neighbor\n                current_fitness = neighbor_fitness\n\n            t *= alpha\n\n        return current_solution, current_fitness\n\n    def evaluate(self, solution):\n        if self.evaluations >= self.budget:\n            return np.inf\n        self.evaluations += 1\n        return solution.func(solution)\n\n    def __call__(self, func):\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = self.evaluate(self.population[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_fitness = self.fitness[i]\n                self.best_solution = self.population[i].copy()\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                trial_vector = self.differential_evolution(i)\n                trial_fitness = self.evaluate(trial_vector)\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial_vector\n\n                # Apply simulated annealing for further local refinement\n                refined_solution, refined_fitness = self.simulated_annealing(self.population[i], self.fitness[i])\n                self.population[i] = refined_solution\n                self.fitness[i] = refined_fitness\n\n                if refined_fitness < self.best_fitness:\n                    self.best_fitness = refined_fitness\n                    self.best_solution = refined_solution\n\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation capabilities.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 61, in __call__\n  File \"<string>\", line 53, in evaluate\nAttributeError: 'numpy.ndarray' object has no attribute 'func'\n.", "error": "AttributeError(\"'numpy.ndarray' object has no attribute 'func'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 61, in __call__\n  File \"<string>\", line 53, in evaluate\nAttributeError: 'numpy.ndarray' object has no attribute 'func'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "646b875f-44ca-4119-b56a-16488f5441ef", "solution": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n        self.F = 0.5 # Differential weight\n        self.CR = 0.9 # Crossover probability\n\n    def differential_evolution(self, target_idx):\n        idxs = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n        mutant_vector = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n        trial_vector = np.array([\n            mutant_vector[i] if np.random.rand() < self.CR else self.population[target_idx][i]\n            for i in range(self.dim)\n        ])\n        return trial_vector\n\n    def simulated_annealing(self, candidate, candidate_fitness):\n        t_initial = 1.0\n        t_final = 0.01\n        alpha = 0.99\n        t = t_initial\n        current_solution = candidate\n        current_fitness = candidate_fitness\n\n        while t > t_final:\n            neighbor = current_solution + np.random.uniform(-0.1, 0.1, self.dim)\n            neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n            neighbor_fitness = self.evaluate(neighbor)\n\n            if neighbor_fitness < current_fitness or np.random.rand() < np.exp((current_fitness - neighbor_fitness) / t):\n                current_solution = neighbor\n                current_fitness = neighbor_fitness\n\n            t *= alpha\n\n        return current_solution, current_fitness\n\n    def evaluate(self, solution):\n        if self.evaluations >= self.budget:\n            return np.inf\n        self.evaluations += 1\n        return solution.func(solution)\n\n    def __call__(self, func):\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluations = 0\n\n        for i in range(self.population_size):\n            self.fitness[i] = self.evaluate(self.population[i])\n            if self.fitness[i] < self.best_fitness:\n                self.best_fitness = self.fitness[i]\n                self.best_solution = self.population[i].copy()\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                trial_vector = self.differential_evolution(i)\n                trial_fitness = self.evaluate(trial_vector)\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial_vector\n\n                # Apply simulated annealing for further local refinement\n                refined_solution, refined_fitness = self.simulated_annealing(self.population[i], self.fitness[i])\n                self.population[i] = refined_solution\n                self.fitness[i] = refined_fitness\n\n                if refined_fitness < self.best_fitness:\n                    self.best_fitness = refined_fitness\n                    self.best_solution = refined_solution\n\n                if self.evaluations >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "HybridDE_SA", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for enhanced exploration and exploitation capabilities.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5a122678-16f7-4a76-8c56-1c8990982bd4", "metadata": {}, "mutation_prompt": null}
