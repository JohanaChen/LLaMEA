{"id": "6935333d-758d-4789-ab0d-ff330b80a607", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.current_evaluations = 0\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.current_evaluations >= self.budget:\n                    break\n\n                # Differential Evolution mutation\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[idxs]\n                mutant = x0 + self.mutation_factor * (x1 - x2)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                # Selection and Local Search\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                    # Local Search\n                    local_trial = trial + np.random.normal(0, 0.1, self.dim)\n                    local_trial = np.clip(local_trial, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_trial)\n                    self.current_evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_trial\n                        fitness[i] = local_fitness\n                        if local_fitness < best_fitness:\n                            best_solution = local_trial\n                            best_fitness = local_fitness\n\n        return best_solution", "name": "HybridDifferentialEvolution", "description": "The algorithm is a hybrid of Differential Evolution and Local Search to balance global exploration and local exploitation.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 15, in __call__\nAttributeError: 'HybridDifferentialEvolution' object has no attribute 'initialize_population'\n.", "error": "AttributeError(\"'HybridDifferentialEvolution' object has no attribute 'initialize_population'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 15, in __call__\nAttributeError: 'HybridDifferentialEvolution' object has no attribute 'initialize_population'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "fafd4bc9-7850-4020-a5fc-b98d322198b2", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.current_evaluations = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, \n                                 (self.population_size, self.dim))\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in population])\n        self.current_evaluations += self.population_size\n\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        while self.current_evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.current_evaluations >= self.budget:\n                    break\n\n                # Adaptive Differential Evolution mutation\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[idxs]\n                adaptive_factor = self.mutation_factor + 0.2 * np.random.rand()\n                mutant = x0 + adaptive_factor * (x1 - x2)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover = np.random.rand(self.dim) < (self.crossover_rate + 0.1 * np.random.rand())\n                trial = np.where(crossover, mutant, population[i])\n\n                # Evaluate trial\n                trial_fitness = func(trial)\n                self.current_evaluations += 1\n\n                # Selection and Local Search\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n                    # Local Search\n                    local_trial = trial + np.random.normal(0, 0.1, self.dim)\n                    local_trial = np.clip(local_trial, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_trial)\n                    self.current_evaluations += 1\n                    if local_fitness < trial_fitness:\n                        population[i] = local_trial\n                        fitness[i] = local_fitness\n                        if local_fitness < best_fitness:\n                            best_solution = local_trial\n                            best_fitness = local_fitness\n\n        return best_solution", "name": "HybridDifferentialEvolution", "description": "Integrates adaptive mutation factor and crossover rate to enhance exploration and exploitation dynamically based on fitness improvement.", "configspace": "", "generation": 1, "fitness": 0.2357289501070997, "feedback": "", "error": "", "parent_id": "6935333d-758d-4789-ab0d-ff330b80a607", "metadata": {"aucs": [0.4575093162173305, 0.4626271274060686, 0.49202529310710463, 0.5039779404934024, 0.5144662607049485, 0.5074926128180979, 0.48983062310938863, 0.4944932745757289, 0.4995516638288354, 0.22517837635507332, 0.22024086506252527, 0.21429418379725107, 0.20159506379624392, 0.22796621102544723, 0.21290732147176916, 0.22726348854135936, 0.2305746814875237, 0.23634276919221542, 0.09167120283927799, 0.09988663730631142, 0.11207578084251835, 0.1214167697443087, 0.08498453238594028, 0.096908141622977, 0.09078933500347253, 0.09001657270520214, 0.08915635555809331, 0.07059030340688477, 0.06670407242941712, 0.07389439047613433, 0.09721995268302142, 0.07340316738500441, 0.07780069644170651, 0.0796112884108694, 0.0773741923893605, 0.08570452836988784, 0.9249129070075746, 0.9381130517242278, 0.926237774267139, 0.8356444541317051, 0.8788531657454751, 0.8721856329204252, 0.9260927658340616, 0.9479121536952959, 0.9046539880586014, 0.19945277524460103, 0.2242856649097279, 0.22519613445681452, 0.2176751539063313, 0.2480574376206569, 0.2535756067644698, 0.24885473724009777, 0.2688234605333659, 0.22253512483141547, 0.5155931016334276, 0.37460773798476044, 0.38142121948439467, 0.38708244219648824, 0.39795623176781814, 0.5321788944673973, 0.4390424836537208, 0.42258197941565434, 0.4330834805439896, 0.13442811930255372, 0.14760447831302148, 0.1498124106666744, 0.1443780571869202, 0.1342890484071929, 0.14789845278509206, 0.14545758259427743, 0.1458449015875265, 0.15992752120703735, 0.20822994007827778, 0.25313162228257047, 0.2551402273777834, 0.1168857087414128, 0.14386084901703666, 0.1644238761559632, 0.16291501048585266, 0.14752756865575267, 0.1456947758507645, 0.09697455121930965, 0.1100464588915766, 0.11246677235136882, 0.1428820045726128, 0.1093803246410564, 0.12794246919716878, 0.09894959439058126, 0.09443675153439579, 0.09491799493254771, 0.2182302949780256, 0.22644715233637114, 0.2276603052887506, 0.2346372468302721, 0.21289906802350356, 0.2026404655402534, 0.2561674617196956, 0.27394633349309316, 0.2643411204824191, 0.016562354724179218, 0.022441707434683433, 0.013950163689635198, 0.019994199268277946, 0.011513037314183738, 0.034230378042162, 0.039074077350794156, 0.016426377814327098, 0.025350011963014563, 0.12238584020649601, 0.1398552135218244, 0.1379469610672881, 0.13653753014239045, 0.12069673081910093, 0.12561543784155582, 0.1365531191424919, 0.14933147946631165, 0.1445254683654681, 0.3801698638597931, 0.42308537284741066, 0.4355914957525946, 0.4337351051267959, 0.41893017612866557, 0.4172169171761645, 0.4276153224699202, 0.3818096966694685, 0.4207803353019449, 0.09064345601433199, 0.08098661795492823, 0.07912453058366464, 0.07530009341475485, 0.08466675895145048, 0.08845708801416918, 0.08013165917416865, 0.07363929484705933, 0.08401347734873865, 0.16753882009397147, 0.1421696373991448, 0.22487472982848877, 0.1418125074667831, 0.2363305236479465, 0.17859053890546206, 0.19861028676885706, 0.1832843602798524, 0.2069753662834708, 0.25442097052537704, 0.25096403877928475, 0.25790313583646407, 0.24601908007169593, 0.23914989852078194, 0.25305606801763003, 0.2607421160630983, 0.26446657943853336, 0.2493938809454186, 0.1794487452934329, 0.1920938981966368, 0.18452546541124992, 0.17889215885183873, 0.17768213698582935, 0.1718389190296924, 0.18904016412960345, 0.1749685471065976, 0.2004870384901929, 0.18710379555091794, 0.18689349182843384, 0.19333812691370156, 0.1741774212767201, 0.16483609187549952, 0.19239398913159478, 0.1827408930056743, 0.166597288195255, 0.18126617183529048, 0.17100292465046363, 0.1727361727914507, 0.17551751098814583, 0.1784578303677843, 0.16808908250029997, 0.1705340330802788, 0.17071999000185312, 0.16614062325401158, 0.17029641290389286, 0.5724478335980747, 0.16250819328770272, 0.6305952272947101, 0.49495376503628685, 0.17908992014684522, 0.29142657834904684, 0.1728252707399215, 0.4351713323522456, 0.1629566008308344, 0.4590723840090233, 0.1900479556798177, 0.15532954093808238, 0.37935575745364936, 0.2676575338351844, 0.18682016438931515, 0.5925612940284435, 0.20621728611155965, 0.21096330275189012, 0.17921522158464553, 0.18568061285329485, 0.19393331145033066, 0.18253245744288993, 0.17669142919642222, 0.2333886666499656, 0.1911832756984555, 0.19356362889415613, 0.20850380733524854, 0.06367358325324035, 0.05627337458612569, 0.06651707388890482, 0.08058090135600648, 0.07368806538054029, 0.06636762101635962, 0.06503782050804785, 0.07102159843886824, 0.056020946289540685]}, "mutation_prompt": null}
