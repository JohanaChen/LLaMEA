{"id": "a0daf739-1f2f-4008-baea-a7c45c749f42", "solution": "import numpy as np\n\nclass HybridPSOwithADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.F = 0.8  # DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = np.inf\n        \n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_coefficient * r2 * (self.best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j] for j in range(self.dim)])\n                trial_value = func(trial_vector)\n                evaluations += 1\n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                if trial_value < self.best_value:\n                    self.best_value = trial_value\n                    self.best_position = trial_vector\n\n            # Update global best\n            for i in range(self.population_size):\n                value = func(particles[i])\n                evaluations += 1\n                if value < personal_best_values[i]:\n                    personal_best_positions[i] = particles[i]\n                    personal_best_values[i] = value\n                if value < self.best_value:\n                    self.best_value = value\n                    self.best_position = particles[i]\n\n        return self.best_position, self.best_value", "name": "HybridPSOwithADE", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution for enhanced exploration and exploitation balance.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 32, in __call__\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n.", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 32, in __call__\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "80858f0f-6ff7-47cb-817d-159920b6763a", "solution": "import numpy as np\n\nclass HybridPSOwithADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.F = 0.8  # DE mutation factor\n        self.CR = 0.9  # DE crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = np.inf\n        \n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Update PSO velocities and positions\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coefficient * r1 * (personal_best_positions[i] - particles[i]) +\n                                 self.social_coefficient * r2 * (self.best_position - particles[i]))\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], self.lower_bound, self.upper_bound)\n\n            # Differential Evolution step\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = particles[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.CR else particles[i, j] for j in range(self.dim)])\n                trial_value = func(trial_vector)\n                evaluations += 1\n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                if trial_value < self.best_value:\n                    self.best_value = trial_value\n                    self.best_position = trial_vector\n\n            # Update global best\n            for i in range(self.population_size):\n                value = func(particles[i])\n                evaluations += 1\n                if value < personal_best_values[i]:\n                    personal_best_positions[i] = particles[i]\n                    personal_best_values[i] = value\n                if value < self.best_value:\n                    self.best_value = value\n                    self.best_position = particles[i]\n                    \n            # Elite Preservation\n            elite_indices = np.argpartition(personal_best_values, 1)[:1]\n            particles[elite_indices] = personal_best_positions[elite_indices]  # Ensure elite preservation\n\n            # Adaptive Parameter Tuning\n            self.inertia_weight *= 0.99  # Slowly decrease inertia weight\n\n        return self.best_position, self.best_value", "name": "HybridPSOwithADE", "description": "Introduce elite preservation and adaptive parameter tuning to enhance convergence and solution quality.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "a0daf739-1f2f-4008-baea-a7c45c749f42", "metadata": {}, "mutation_prompt": null}
