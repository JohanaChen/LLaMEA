{"id": "32890742-453a-4135-9b1f-f27d51399b90", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.random.randint(self.population_size)]\n        self.fitness = np.full(self.population_size, np.inf)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.curr_evals = 0\n\n    def evaluate(self, func):\n        for i in range(self.population_size):\n            if self.curr_evals >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.curr_evals += 1\n            if self.fitness[i] < self.personal_best_fitness[i]:\n                self.personal_best[i] = self.population[i]\n                self.personal_best_fitness[i] = self.fitness[i]\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best = self.population[i]\n                self.global_best_fitness = self.fitness[i]\n\n    def update_velocities_and_positions(self):\n        inertia_weight = 0.5\n        cognitive_comp = 1.5\n        social_comp = 1.5\n        for i in range(self.population_size):\n            if self.curr_evals >= self.budget:\n                break\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive_velocity = cognitive_comp * r1 * (self.personal_best[i] - self.population[i])\n            social_velocity = social_comp * r2 * (self.global_best - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n            # Differential Evolution Mutation\n            if np.random.rand() < 0.5:\n                idxs = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = self.population[idxs]\n                mutant_vector = x0 + 0.8 * (x1 - x2)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                if func(mutant_vector) < self.fitness[i]:\n                    self.population[i] = mutant_vector\n            else:\n                self.population[i] += self.velocities[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate(func)\n        while self.curr_evals < self.budget:\n            self.update_velocities_and_positions()\n            self.evaluate(func)\n        return self.global_best, self.global_best_fitness", "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization combined with Differential Evolution for enhanced exploration and exploitation balance.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 60, in __call__\n  File \"<string>\", line 51, in update_velocities_and_positions\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 60, in __call__\n  File \"<string>\", line 51, in update_velocities_and_positions\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "90abd761-400f-4698-a2d1-f982f75b6f75", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.random.randint(self.population_size)]\n        self.fitness = np.full(self.population_size, np.inf)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_fitness = np.inf\n        self.curr_evals = 0\n        self.archive = []\n\n    def evaluate(self, func):\n        for i in range(self.population_size):\n            if self.curr_evals >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.curr_evals += 1\n            if self.fitness[i] < self.personal_best_fitness[i]:\n                self.personal_best[i] = self.population[i]\n                self.personal_best_fitness[i] = self.fitness[i]\n            if self.fitness[i] < self.global_best_fitness:\n                self.global_best = self.population[i]\n                self.global_best_fitness = self.fitness[i]\n                self.archive.append(self.population[i])  # Archive update\n\n    def update_velocities_and_positions(self):\n        inertia_weight = 0.9 - 0.5 * (self.curr_evals / self.budget)  # Adaptive inertia weight\n        cognitive_comp = 1.5\n        social_comp = 1.5\n        for i in range(self.population_size):\n            if self.curr_evals >= self.budget:\n                break\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive_velocity = cognitive_comp * r1 * (self.personal_best[i] - self.population[i])\n            social_velocity = social_comp * r2 * (self.global_best - self.population[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n\n            # Differential Evolution Mutation with archive\n            if np.random.rand() < 0.5 and len(self.archive) >= 3:\n                idxs = np.random.choice(len(self.archive), 3, replace=False)\n                x0, x1, x2 = np.array(self.archive)[idxs]\n                mutant_vector = x0 + 0.8 * (x1 - x2)\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                if func(mutant_vector) < self.fitness[i]:\n                    self.population[i] = mutant_vector\n            else:\n                self.population[i] += self.velocities[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        self.evaluate(func)\n        while self.curr_evals < self.budget:\n            self.update_velocities_and_positions()\n            self.evaluate(func)\n        return self.global_best, self.global_best_fitness", "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive inertia weight and archive-based mutation for improved convergence.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "32890742-453a-4135-9b1f-f27d51399b90", "metadata": {}, "mutation_prompt": null}
