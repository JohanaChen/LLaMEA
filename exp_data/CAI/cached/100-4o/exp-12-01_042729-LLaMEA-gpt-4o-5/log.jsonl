{"id": "838202c3-b8af-4ffb-b5ff-53df9220764e", "solution": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass ACPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 40\n        self.inertia = 0.7\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lb, self.ub, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_position = personal_best_positions[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.swarm_size, self.dim)\n            velocities = (\n                self.inertia * velocities\n                + self.cognitive_weight * r1 * (personal_best_positions - particles)\n                + self.social_weight * r2 * (global_best_position - particles)\n            )\n            particles = np.clip(particles + velocities, self.lb, self.ub)\n            \n            # Evaluate new positions\n            new_values = np.array([func(p) for p in particles])\n            evaluations += self.swarm_size\n            \n            # Update personal and global bests\n            better_mask = new_values < personal_best_values\n            personal_best_positions[better_mask] = particles[better_mask]\n            personal_best_values[better_mask] = new_values[better_mask]\n            \n            if np.min(personal_best_values) < global_best_value:\n                global_best_position = personal_best_positions[np.argmin(personal_best_values)]\n                global_best_value = np.min(personal_best_values)\n            \n            # Clustering-based adaptation\n            if evaluations < self.budget:\n                n_clusters = max(2, self.swarm_size // 10)\n                kmeans = KMeans(n_clusters=n_clusters)\n                labels = kmeans.fit_predict(particles)\n                \n                cluster_bests = [func(kmeans.cluster_centers_[i]) for i in range(n_clusters)]\n                best_cluster_center = kmeans.cluster_centers_[np.argmin(cluster_bests)]\n                \n                # Use best cluster's center to guide swarm's social component\n                global_best_position = np.copy(best_cluster_center)\n        \n        return global_best_position, global_best_value", "name": "ACPSO", "description": "Adaptive Cluster-Based Particle Swarm Optimization (ACPSO) dynamically adjusts swarm exploration and exploitation using clustering techniques.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 2, in <module>\nModuleNotFoundError: No module named 'sklearn'\n.", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 32, in evaluateBBOB\n    exec(code, globals())\n  File \"<string>\", line 2, in <module>\nModuleNotFoundError: No module named 'sklearn'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "a2e2735e-f13b-494c-90e8-62c792595679", "solution": "import numpy as np\n\nclass ACPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = 40\n        self.inertia = 0.7\n        self.cognitive_weight = 1.5\n        self.social_weight = 1.5\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(self.lb, self.ub, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.array([func(p) for p in particles])\n        global_best_position = personal_best_positions[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(2, self.swarm_size, self.dim)\n            velocities = (\n                self.inertia * velocities\n                + self.cognitive_weight * r1 * (personal_best_positions - particles)\n                + self.social_weight * r2 * (global_best_position - particles)\n            )\n            particles = np.clip(particles + velocities, self.lb, self.ub)\n            \n            # Evaluate new positions\n            new_values = np.array([func(p) for p in particles])\n            evaluations += self.swarm_size\n            \n            # Update personal and global bests\n            better_mask = new_values < personal_best_values\n            personal_best_positions[better_mask] = particles[better_mask]\n            personal_best_values[better_mask] = new_values[better_mask]\n            \n            if np.min(personal_best_values) < global_best_value:\n                global_best_position = personal_best_positions[np.argmin(personal_best_values)]\n                global_best_value = np.min(personal_best_values)\n                \n            # Clustering-based adaptation\n            if evaluations < self.budget:\n                centroid = np.mean(particles, axis=0)\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                best_cluster_center = centroid + perturbation\n                \n                # Use best cluster's center to guide swarm's social component\n                global_best_position = np.copy(best_cluster_center)\n        \n        return global_best_position, global_best_value", "name": "ACPSO", "description": "Adaptive Cluster-Based Particle Swarm Optimization (ACPSO) leverages a centroid perturbation technique to enhance exploration and exploitation balance without relying on external libraries.", "configspace": "", "generation": 1, "fitness": 0.18959176923062473, "feedback": "", "error": "", "parent_id": "838202c3-b8af-4ffb-b5ff-53df9220764e", "metadata": {"aucs": [0.46900672555986433, 0.4454766749129271, 0.4593067013017238, 0.4631019996893784, 0.46859206016553323, 0.4553017401504309, 0.4410731045999411, 0.4456755152967278, 0.4503640841118064, 9.999999999998899e-05, 0.0073314940295670095, 9.999999999998899e-05, 9.999999999998899e-05, 0.01878203222353081, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0990018928974401, 0.08728099434468295, 0.09498765899224271, 0.09402634322851422, 0.07958422535487875, 0.09049604294930813, 0.08899763475111344, 0.11921482798626148, 0.1161493058914399, 0.08234358576536505, 0.07469254186981666, 0.06880350577624139, 0.09374582415836963, 0.05066811515608294, 0.08046784108628835, 0.07869842281475425, 0.059866516725170515, 0.07774939626598865, 0.9547384522638934, 0.9903714714964946, 0.9623163544049781, 0.25256154105424167, 0.5023732137905388, 0.6492568136082251, 0.8996142483619488, 0.8627742253845014, 0.733551502903488, 0.2785480895603374, 0.2574477204174399, 0.038589822432537724, 0.26584331236029934, 0.2934242948201121, 0.2710760975405385, 0.24547681996998827, 0.2094527315490976, 0.2692462668624187, 0.2826326911997863, 0.1133833593860647, 0.24510232073004112, 0.27908831482316454, 0.24477668615087333, 0.2061610201451639, 0.12250555923930273, 0.14972530952598628, 0.13654707807292876, 0.22817625586238788, 0.12871680967770482, 0.0759666312320122, 0.11690633822724228, 0.13482242077831197, 0.08975500332527608, 0.1359346191387214, 0.10932277261376255, 0.14012707349519682, 0.13648778776472792, 0.1382109010235839, 0.12988613623660916, 0.14174570283266452, 0.059994459892669716, 0.14234729929496825, 0.15271105065170265, 0.08617306151960402, 0.09579764873618823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037294836368420126, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07021451821867797, 0.0481085967672612, 0.09489511789401583, 0.06303843973670242, 0.014945337198028041, 0.01378512104548335, 0.04975425439276948, 0.06730486193923024, 0.04809675144211656, 9.999999999998899e-05, 0.021273762335279, 9.999999999998899e-05, 0.0009371728831744086, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12724554898374063, 0.04937717801111852, 0.11433208803759021, 0.044174220640733064, 0.1129397086545274, 0.07809982320333242, 0.11409823064529756, 0.12798887833935202, 0.09928265009777393, 0.42479961074302086, 0.42300874207981987, 0.4415715433404609, 0.4000204298478518, 0.42345488719746294, 0.4009478012077541, 0.4419192838518635, 0.42196344522767837, 0.42707415687380523, 0.09745727819725147, 0.09141647837309197, 0.08617686444299943, 0.12419091894644585, 0.06245357472037416, 0.14327181932935162, 0.09948723434184137, 0.10475935539052539, 0.09643635100248271, 0.26079104833573163, 0.14826078282083288, 0.13596801360075184, 0.17865109150605618, 0.1389146731196058, 0.14899380631902226, 0.1584081282640596, 0.17881310866575806, 0.14183499345730233, 0.26868010379858565, 0.24759284247500113, 0.3019795182518996, 0.2750514085550936, 0.2267783824836569, 0.1849132581481101, 0.30913773729679206, 0.28602298182159624, 0.23388567972878105, 0.1864379216173152, 0.17305214473540687, 0.22769617361507066, 0.20581048971477178, 0.18008028419448563, 0.20491985608859098, 0.22659324625892585, 0.26665426451803, 0.21290871576139037, 0.2219218475589808, 0.16225559485393493, 0.18430675663459362, 0.21973317483888954, 0.18146478675328082, 0.19010693920105148, 0.21246739692582428, 0.18623998309820744, 0.210466931704958, 0.18230943076271755, 0.21666721919776866, 0.17851638137481518, 0.1833826351353004, 0.19740836068469347, 0.18654207953381752, 0.19757576466425275, 0.18679568866518992, 0.1787176458908123, 0.5549525611096094, 0.16691073059627748, 0.14891451051173077, 0.28490987848501825, 0.19750303003765735, 0.19353649519802985, 0.16594311407562945, 0.17025947144646447, 0.6321591837619448, 0.5807585441107956, 0.21091407159813158, 0.29803449340408006, 0.19989605564247026, 0.23192109253416637, 0.15059319400457283, 0.10481928919636063, 0.1044094206009768, 0.22881398031600664, 0.18654613020010047, 0.18374845712236143, 0.20247815389788026, 0.1803099277647543, 0.18144745824916553, 0.17762782541716948, 0.17972103507054982, 0.19176434833710587, 0.19797361538543623, 0.06161229383575262, 0.0836470911837911, 0.08298410222740094, 0.08144483218072907, 0.09484207112982967, 0.0787661590171177, 0.08792509547754357, 0.08374925272496525, 0.0740249449698347]}, "mutation_prompt": null}
