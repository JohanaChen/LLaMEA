{"id": "9fd0379b-c121-4f30-a2a5-c77c71639060", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Define based on problem complexity\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.eval_count = 0\n\n    def differential_evolution_step(self, population, scores):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            # Select three random individuals\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            \n            # Mutation\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            crossover = np.random.rand(self.dim) < self.crossover_probability\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, population[i])\n            \n            # Selection\n            trial_score = func(trial)\n            self.eval_count += 1\n            if trial_score < scores[i]:\n                new_population[i] = trial\n                scores[i] = trial_score\n\n            if self.eval_count >= self.budget:\n                break\n        return new_population, scores\n    \n    def nelder_mead_local_search(self, best_individual):\n        res = minimize(func, best_individual, method='Nelder-Mead', bounds=[(self.lower_bound, self.upper_bound)] * self.dim, \n                       options={'maxfev': self.budget - self.eval_count, 'xatol': 1e-6, 'fatol': 1e-6})\n        self.eval_count += res.nfev\n        return res.x, res.fun\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            population, scores = self.differential_evolution_step(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            if self.eval_count < self.budget:\n                # Local search using Nelder-Mead\n                best_individual, best_score = self.nelder_mead_local_search(best_individual)\n\n            # Update best known positions and scores\n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n\n            if self.eval_count >= self.budget:\n                break\n\n        return population[np.argmin(scores)], np.min(scores)", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution combining differential mutation with Nelder-Mead local search for enhanced exploration and exploitation.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 55, in __call__\n  File \"<string>\", line 32, in differential_evolution_step\nNameError: name 'func' is not defined\n.", "error": "NameError(\"name 'func' is not defined\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 55, in __call__\n  File \"<string>\", line 32, in differential_evolution_step\nNameError: name 'func' is not defined\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "7aa455e6-8b80-4b5f-9d68-61a853a380f2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Define based on problem complexity\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.eval_count = 0\n\n    def differential_evolution_step(self, population, scores):\n        new_population = np.copy(population)\n        for i in range(self.population_size):\n            # Select three random individuals\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = population[np.random.choice(indices, 3, replace=False)]\n            \n            # Mutation\n            mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n            \n            # Crossover\n            crossover = np.random.rand(self.dim) < self.crossover_probability\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, population[i])\n            \n            # Selection\n            trial_score = func(trial)\n            self.eval_count += 1\n            if trial_score < scores[i]:\n                new_population[i] = trial\n                scores[i] = trial_score\n\n            if self.eval_count >= self.budget:\n                break\n        return new_population, scores\n    \n    def nelder_mead_local_search(self, best_individual):\n        res = minimize(func, best_individual, method='Nelder-Mead', bounds=[(self.lower_bound, self.upper_bound)] * self.dim, \n                       options={'maxfev': self.budget - self.eval_count, 'xatol': 1e-6, 'fatol': 1e-6})\n        self.eval_count += res.nfev\n        return res.x, res.fun\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        scores = np.array([func(ind) for ind in population])\n        self.eval_count += self.population_size\n\n        while self.eval_count < self.budget:\n            population, scores = self.differential_evolution_step(population, scores)\n            best_idx = np.argmin(scores)\n            best_individual, best_score = population[best_idx], scores[best_idx]\n            \n            if self.eval_count < self.budget:\n                # Local search using Nelder-Mead\n                best_individual, best_score = self.nelder_mead_local_search(best_individual)\n\n            # Update best known positions and scores\n            population[best_idx] = best_individual\n            scores[best_idx] = best_score\n\n            if self.eval_count >= self.budget:\n                break\n\n        return population[np.argmin(scores)], np.min(scores)", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive Differential Evolution combining differential mutation with Nelder-Mead local search for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fd0379b-c121-4f30-a2a5-c77c71639060", "metadata": {}, "mutation_prompt": null}
