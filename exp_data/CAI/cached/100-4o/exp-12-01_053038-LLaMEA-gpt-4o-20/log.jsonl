{"id": "ddf32642-2084-4258-b39d-fe171b32e14e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.CR = 0.9  # Crossover probability\n        self.F = 0.8   # Differential weight\n        self.evaluations = 0\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.pop[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return\n\n    def _select_parents(self):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        return indices\n\n    def _mutate(self, base, a, b, c):\n        mutant = base + self.F * (a - b + c - base)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self._evaluate_population(func)\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = self._select_parents()\n                while i in indices:\n                    indices = self._select_parents()\n                base, a, b = self.pop[indices]\n\n                mutant = self._mutate(base, a, b, self.pop[i])\n                trial = self._crossover(self.pop[i], mutant)\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.pop[i] = trial\n                    self.fitness[i] = trial_fitness\n\n            # Adapt F and CR based on diversity\n            population_std = np.std(self.pop, axis=0)\n            diversity = np.mean(population_std)\n            self.F = 0.5 + 0.3 * (1 - diversity) # More diversity, less greediness\n            self.CR = 0.5 + 0.4 * (diversity)    # More diversity, more exploration\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically tunes its parameters based on population diversity to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.2581312619238149, "feedback": "", "error": "", "parent_id": null, "metadata": {"aucs": [0.7013671185705347, 0.6817701717709418, 0.6924305990973081, 0.6840274481821467, 0.7078747934748294, 0.6901553342386, 0.7157840845354515, 0.697991264988471, 0.6618284813959641, 0.49059674818997423, 0.5125384541793148, 0.4532171141178384, 0.44507266574089066, 0.5364438034506244, 0.46281614372133584, 0.44059624457058033, 0.47379012700703416, 0.47663047248350443, 0.13543863518479138, 0.1337455417887652, 0.12014798656988512, 0.11833512808241742, 0.13560248162677813, 0.12806362038603836, 0.13714636041238903, 0.13671222377556824, 0.12941135687428273, 0.11477914532207012, 0.09266972888006841, 0.09387575762344236, 0.10834352058282726, 0.09685200919360615, 0.09469843880557927, 0.09106823776797135, 0.11649793655611962, 0.08887012922293958, 0.899754970548104, 0.7488246366679955, 0.8034809916535686, 0.8355975388914327, 0.8518905492174688, 0.8460305515043088, 0.8009669263260915, 0.7277262168330969, 0.8474438487154784, 0.33035848093950815, 0.2898131435600769, 0.24943037412508862, 0.284616829165418, 0.24780756322413988, 0.30812099144297656, 0.2828879700027823, 0.2921271656126332, 0.2990802564168129, 0.46046117588582536, 0.5379120258703358, 0.27618499483920145, 0.6235932145768524, 0.4041824888588511, 0.4481978404906558, 0.2787661453817364, 0.33006490791700205, 0.7052868793422703, 0.19601399353539506, 0.14003378685693058, 0.15100207903478768, 0.15316777355353528, 0.1536439041775598, 0.2114185147866594, 0.18414900890688557, 0.20793988935218233, 0.16499029257511288, 0.1410030848682685, 0.14335912560129638, 0.18646469971545976, 0.20457670858688626, 0.17305611365858675, 0.16365785764769203, 0.1625748257638575, 0.15911129418946535, 0.16124677787167607, 0.10233839041249648, 0.06704449666422185, 0.05121488141237862, 0.16157478814860882, 0.09474831926405602, 0.01349554927038843, 0.16544651939353028, 0.04079331290776478, 0.14781957937357693, 0.26390066833543613, 0.1620393594927415, 0.24480551049524824, 0.1709261198479226, 0.07501820919168334, 0.22362201924779646, 0.3296100186539488, 0.3052451250605819, 0.27900908300291727, 0.03043589137637759, 0.029666042909429424, 0.02716834421969594, 0.03275789879617863, 0.035766907379294444, 0.03264644114811377, 0.05392605556847485, 0.02428850492427903, 0.028430290646262124, 0.13646613006702357, 0.12883371845301972, 0.13988906444087712, 0.14184497913555627, 0.15873593339461223, 0.14500637893865553, 0.1317680395660067, 0.1461986438530568, 0.13346118372416182, 0.465269063194663, 0.48037430657040103, 0.48446950552320023, 0.4553237100118599, 0.4787668162574382, 0.4667652877972841, 0.491811065382438, 0.4753383537168471, 0.48651324335814283, 0.09430263240290171, 0.08232851769699301, 0.09766031685287946, 0.10735817272127679, 0.08021070663444385, 0.12250861718301564, 0.10221469294500074, 0.09836644252557158, 0.08101774970688891, 0.19550143803040332, 0.165614068877032, 0.18508022682409309, 0.14732359708579823, 0.27443677763770924, 0.19633741157045792, 0.32585601149348287, 0.18574687667438672, 0.2754294175345954, 0.2957851497169297, 0.2747777716243144, 0.2867322022932415, 0.2890452598052824, 0.2827005106782967, 0.290500839627042, 0.29154747945731574, 0.31685752742893214, 0.2904444216964597, 0.21765006158370892, 0.2382723481611917, 0.23458714528274627, 0.23609522096879942, 0.22302161812296073, 0.23574447419490785, 0.23521002505503452, 0.24917758905530596, 0.24271454392835645, 0.22408097922856307, 0.20320723252818385, 0.2056138652626035, 0.26885796789154515, 0.21727739008928004, 0.21730691644287325, 0.2169097946990175, 0.19366890029866923, 0.21445248824797158, 0.1865543557310435, 0.1856344272259527, 0.17710890970489013, 0.20119988627815832, 0.1932659418619167, 0.18602458740797467, 0.1934521439204151, 0.19291820377880298, 0.19189201926207677, 0.15165819975486594, 0.15307939847638774, 0.14930373650160367, 0.15999801725874152, 0.19734461827182115, 0.10377472018163536, 0.1645272783848637, 0.14459739493600032, 0.5114158481345512, 0.4380161139670832, 0.18971767840960685, 0.4336266540180982, 0.1588264290883733, 0.10971807257396904, 0.09781916661893697, 0.16524961020849738, 0.1514076211943206, 0.2156684043356143, 0.17507096241873243, 0.19048571739157705, 0.1977900585475545, 0.17522600764810792, 0.18410690815602082, 0.17825529633724602, 0.18426024081103276, 0.17580228022724131, 0.20647102424944297, 0.08695211280661896, 0.08172034981288057, 0.078036754684086, 0.08758722589133427, 0.08737040197962864, 0.09826542426177165, 0.08294857520005605, 0.07528777844992363, 0.09160115382662193]}, "mutation_prompt": null}
{"id": "0009f502-aa50-43ca-9b9a-8c7c5bf4162b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.CR = 0.9  # Crossover probability\n        self.F = 0.8   # Differential weight\n        self.evaluations = 0\n\n    def _evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.pop[i])\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return\n\n    def _select_parents(self):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        return indices\n\n    def _mutate(self, base, a, b, c):\n        F_adaptive = self.F * np.random.rand()\n        mutant = base + F_adaptive * (a - b + c - base)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self._evaluate_population(func)\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = self._select_parents()\n                while i in indices:\n                    indices = self._select_parents()\n                base, a, b = self.pop[indices]\n\n                mutant = self._mutate(base, a, b, self.pop[i])\n                trial = self._crossover(self.pop[i], mutant)\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.pop[i] = trial\n                    self.fitness[i] = trial_fitness\n\n            # Adapt F and CR based on diversity\n            population_std = np.std(self.pop, axis=0)\n            diversity = np.mean(population_std)\n            self.F = 0.5 + 0.3 * (1 - diversity) # More diversity, less greediness\n            self.CR = 0.5 + 0.4 * (diversity)    # More diversity, more exploration\n\n            if diversity < 0.1:\n                self._increase_population()\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx], self.fitness[best_idx]\n    \n    def _increase_population(self):\n        new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (self.dim, self.dim))\n        self.pop = np.vstack((self.pop, new_individuals))\n        self.fitness = np.append(self.fitness, np.full(self.dim, np.inf))\n        self.population_size += self.dim", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced differential evolution with adaptive mutation strategies and dynamic population size adjustment for improved exploration and exploitation.", "configspace": "", "generation": 1, "fitness": 0.24399488730814325, "feedback": "", "error": "", "parent_id": "ddf32642-2084-4258-b39d-fe171b32e14e", "metadata": {"aucs": [0.8222025183356836, 0.7570015179514632, 0.8103631879471223, 0.6475484229490012, 0.6709343702517145, 0.6324405785011649, 0.7849856193019389, 0.6403710286972495, 0.7122704338350873, 0.19038758952205947, 0.3637341060377004, 0.30174473310203453, 0.5371337115115642, 0.6143298770296146, 0.42740848132157094, 0.19231058492611552, 0.10573381547322458, 0.28168276723040564, 0.16687927591964657, 0.15468325577573527, 0.3461523401009774, 0.11669736218924787, 0.18701944359749922, 0.15934928864450704, 0.12271888259677344, 0.41400606741663437, 0.31567659123594616, 0.14062352168615144, 0.08706086163599847, 0.09940925419114666, 0.1079751594449817, 0.1290716254599391, 0.10979843868025962, 0.16488166922412562, 0.17429639868858338, 0.11776744856361188, 0.6951987167826749, 0.6453852092950967, 0.7015818649649854, 0.5871683745366838, 0.6490637296503274, 0.6051084527560721, 0.5861076598900636, 0.6596020109014076, 0.6515613502125964, 0.2053771289437839, 0.20310091520676365, 0.09128486882969922, 0.18836139307418487, 0.14156234991402072, 0.22994143078360607, 0.2737264660187265, 0.1549279352629248, 0.2246108258510382, 0.6757138857530991, 0.19294369072717932, 0.17086099485007622, 0.6139642647045835, 0.20161143567224504, 0.14432901642143092, 0.18190155309499234, 0.17494681974439463, 0.17830483421933463, 0.29777016700008085, 0.16099335273448723, 0.1299133549891489, 0.15171126747482955, 0.31214180588402285, 0.1617919808764129, 0.15778773264356294, 0.2879398404242417, 0.07159563546076408, 0.12812553601871546, 0.14882586146459342, 0.1459548710801859, 0.12418359518406286, 0.13777752434011103, 0.14019040144789163, 0.1834659489355892, 0.1717948090051472, 0.13463820608752353, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028756067056819656, 0.0864203192702967, 9.999999999998899e-05, 0.04770544085468409, 9.999999999998899e-05, 0.03877744140797035, 0.10725499711416975, 0.05930527377104167, 0.1301583687978204, 0.04801939244217135, 0.027127822649056332, 0.041218198133982864, 0.12919271143764077, 0.07603343825888675, 0.12774062394279317, 0.07445874485668069, 0.11862288233643614, 0.13570548660995774, 0.0803114619237083, 0.06777383406792137, 0.09579111326461409, 0.11578862817079061, 0.11280339985914489, 0.07233425703325924, 0.20792602643782954, 0.07842272694266561, 0.1913317849700552, 0.03795018440359765, 0.10738463832704015, 0.1585431750562657, 0.1596600450150376, 0.07183266723451798, 0.08542702394029167, 0.5240102681106233, 0.47743742587522786, 0.5419820804941418, 0.4090663383975002, 0.40248434151199997, 0.4755954548818021, 0.5622703479373461, 0.4412620579336918, 0.49426719385019924, 0.05987483993594289, 0.07643437928283114, 0.08395351885463564, 0.12149874385305215, 0.09126205928200792, 0.1315744677870565, 0.12100916288493901, 0.1816638109596812, 0.1014551599018092, 0.25519332139707696, 0.17630353852704705, 0.2450882505266262, 0.17607354776837547, 0.24823190611870982, 0.26482384366329037, 0.22684425759709703, 0.24501665592165178, 0.2506414340504465, 0.2551237946681659, 0.3442440000716309, 0.3438329199764052, 0.36718279328651593, 0.3047614372388757, 0.3520121368685091, 0.22955037869770245, 0.42300067741353986, 0.23761539380076113, 0.2302082928778474, 0.20623520264665318, 0.25898087719765717, 0.21470741857500752, 0.16480869661343023, 0.26304628428115373, 0.21142031648825765, 0.29090179020095297, 0.22712419534784023, 0.2598191609355017, 0.22141125440057763, 0.22335495588206344, 0.22734690062986262, 0.2210430646791578, 0.237804919275463, 0.2244240311699648, 0.2086700318835255, 0.25478689234565977, 0.2211597903457485, 0.21426085707626952, 0.20140962230706394, 0.21036762446741197, 0.21619813088623363, 0.23139588962886415, 0.20610049679772569, 0.4293357983321995, 0.21293166500562888, 0.40349363984470454, 0.18780290752521278, 0.5706162974699004, 0.40707785695482057, 0.19950560734537215, 0.1993824171134414, 0.13842732423739312, 0.16323857689773358, 0.15260517908677806, 0.4129076444797102, 0.2097023843817466, 0.08489738473861819, 0.27504846309344666, 0.1657333770433237, 0.32679960294540655, 0.27036629207104923, 0.3532727915598175, 0.30946474898664733, 0.21451419160143959, 0.18167560206095856, 0.22554208479141358, 0.20804632512431687, 0.20124065755897236, 0.20269165579984183, 0.2192040426812627, 0.210654368179514, 0.20517139664423822, 0.08163626158382953, 0.09209139888160356, 0.0954049912664583, 0.08500693487888689, 0.09668060983715054, 0.12665197104033232, 0.10091289367261325, 0.09212211813759263, 0.09963208576176275]}, "mutation_prompt": null}
