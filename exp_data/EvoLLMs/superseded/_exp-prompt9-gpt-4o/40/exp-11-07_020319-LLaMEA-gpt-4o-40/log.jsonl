{"id": "30fa9ac7-fd8b-4832-b596-51f7fa78bbc0", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Population size\n        self.inertia_weight = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8  # Mutation factor for DE\n        self.recombination_rate = 0.9  # Recombination rate for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.c1 * r1 * (personal_best_positions - positions)\n                          + self.c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            # Evaluate all particles\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            # Update personal bests\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            # Update global best\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            # Differential Evolution mutation and recombination\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "AdaptiveSwarmOptimizer", "description": "A novel adaptive swarm-based optimizer that combines particle swarm optimization with differential evolution for enhanced exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.3744724803921355, "feedback": "The algorithm AdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7989986418417774, 0.7927707653376858, 0.8203837584970056, 0.8298917754423807, 0.8328282229651067, 0.19077457232124362, 0.828805234961724, 0.797688131072892, 0.8352428426565499, 0.592686135755466, 0.614416006307235, 0.5687512167607289, 0.6076527311245735, 0.586484361104169, 0.6145340561645514, 0.6218679964025349, 0.5870529642192279, 0.6151084236581683, 0.16560860954470058, 0.35928869940623276, 0.12186238741538769, 0.1462527889593246, 0.15698442399763013, 0.17480575610305527, 0.1306742971102145, 0.1593185033886403, 0.1407083581084344, 0.12683055611116634, 0.14296603192534618, 0.14568167184658798, 0.1496734353638034, 0.12515808395862027, 0.11438680786649147, 0.14549965141189802, 0.10945732241260997, 0.10471585891959201, 0.9899765704119001, 0.9838943167269634, 0.9903222343342659, 0.9726913397195514, 0.9806862184408655, 0.9890438743805663, 0.9891008973411822, 0.9871415604436599, 0.9907615218702234, 0.6243246880326373, 0.0600453438947568, 0.5872511436151573, 0.6265900725273679, 0.6511285083944054, 0.15128264757585963, 0.582976596663944, 0.5984621050666168, 0.6194414242591868, 0.8045039893763757, 0.7416082248196529, 0.7958161769065248, 0.8588115701678709, 0.7793854712188545, 0.7394842588728753, 0.7276867564728978, 0.7526499602192656, 0.8326804524549528, 0.309270851817679, 0.3688658382254607, 0.3738820316370345, 0.3786214081519299, 0.35599650807449323, 0.4031663615961928, 0.4306160409817831, 0.34049907657921663, 0.3818480173200808, 0.34597205854019697, 0.016917224677294174, 0.3795094547974356, 0.3837671965300915, 0.39051159421824566, 0.39624971696924494, 0.39286096032341034, 9.999999999998899e-05, 0.3894615835521652, 0.32148627438033317, 0.054719331446704156, 0.29057734123985834, 9.999999999998899e-05, 0.31479658470094607, 0.2555397661075651, 0.3158819201981665, 0.30074772752120726, 0.2377518632845177, 0.3922044227834325, 0.457305274688403, 0.3865250328952592, 0.44285410129662606, 0.34011508817728786, 0.37405301090818066, 0.4118039155207761, 0.4387760631139437, 0.45351095028935307, 0.16603094404435237, 0.05424664886984498, 0.0571500527990495, 0.18620063604524006, 0.1587976278953631, 0.07755897225615305, 0.1635898415699647, 0.09786577011672493, 0.08988771345611624, 0.1961117768962003, 0.26822097370700226, 0.2401604488660477, 9.999999999998899e-05, 0.006171167618419404, 0.28621065615696384, 0.23602612261752465, 0.048887346904255335, 0.08219601077201277, 0.7010261158813813, 0.6866085806030013, 0.6710207466428623, 0.646845757121224, 0.6549761280836844, 0.20868449285044022, 0.6432085097439215, 0.6023261565314075, 0.6808490071334794, 0.10892949517091788, 0.13140314433758737, 0.11992620434471668, 0.13773656411753787, 0.12113201465987455, 0.16923445495014422, 0.124551503248995, 0.09121276213797447, 0.15485406312130856, 0.4149225425438796, 0.21436216278640097, 0.1501491610409732, 0.22224303337939533, 0.5956645498343437, 0.33709251016311825, 0.1986247389566138, 0.2505445197591667, 0.18440948290765424, 0.4997609860635125, 0.44858149845736983, 0.47055444663276025, 0.4603307656757304, 0.4613672830434834, 0.43411317528541205, 0.48180422663149103, 0.5113972122331218, 0.4986769452695139, 0.33992306373812486, 0.2832329693261858, 0.31679083904855876, 0.3097417901486874, 0.33844321119163057, 0.2958140231962235, 0.37272174642277156, 0.3712832052616092, 0.30109201574538236, 0.2125623626443225, 0.22026025430032192, 0.20031578433220398, 0.28434095478938703, 0.21982195397415283, 0.22452039960729175, 0.24374451288563115, 0.2136709602633401, 0.25096885411717185, 0.19522869346147587, 0.2414584713373018, 0.2112869851599598, 0.5378179650738908, 0.6324582753376501, 0.2065053796147297, 0.4815931396459088, 0.23211874364227525, 0.6840959277465557, 0.8675293035494389, 0.17621756661540655, 0.16499513050721304, 0.8372023579489762, 0.20130400889622602, 0.8753341271496974, 0.09969694705444432, 0.16972101287772257, 0.16424896177067527, 0.775507851610146, 0.21009937024530467, 0.12653822946308624, 0.7403304663964336, 0.16793976923193477, 0.21046269723322952, 0.18928554539401987, 0.15387455180467657, 0.819292449829423, 0.20698436436887568, 0.18403051390354286, 0.197947625787101, 0.19374675382364404, 0.17698107365022953, 0.18118046705487667, 0.18306073138455248, 0.1849234987041276, 0.19959540712421564, 0.09365830805135356, 0.09048731034028912, 0.08594853071404018, 0.0780066006608966, 0.08734319790729717, 0.10261005841739357, 0.09526563018704115, 0.08545941511516209, 0.0924721987845516]}, "mutation_prompt": null}
{"id": "2797fae7-e634-46ec-b28e-565167a2f8ba", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Population size\n        self.inertia_weight = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8  # Mutation factor for DE\n        self.recombination_rate = 0.9  # Recombination rate for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.c1 * r1 * (personal_best_positions - positions)\n                          + self.c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            # Evaluate all particles\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            # Update personal bests\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            # Update global best\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            # Differential Evolution mutation and recombination\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "AdaptiveSwarmOptimizer", "description": "A novel adaptive swarm-based optimizer that combines particle swarm optimization with differential evolution for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "30fa9ac7-fd8b-4832-b596-51f7fa78bbc0", "metadata": {"aucs": [0.7989986418417774, 0.7927707653376858, 0.8203837584970056, 0.8298917754423807, 0.8328282229651067, 0.19077457232124362, 0.828805234961724, 0.797688131072892, 0.8352428426565499, 0.592686135755466, 0.614416006307235, 0.5687512167607289, 0.6076527311245735, 0.586484361104169, 0.6145340561645514, 0.6218679964025349, 0.5870529642192279, 0.6151084236581683, 0.16560860954470058, 0.35928869940623276, 0.12186238741538769, 0.1462527889593246, 0.15698442399763013, 0.17480575610305527, 0.1306742971102145, 0.1593185033886403, 0.1407083581084344, 0.12683055611116634, 0.14296603192534618, 0.14568167184658798, 0.1496734353638034, 0.12515808395862027, 0.11438680786649147, 0.14549965141189802, 0.10945732241260997, 0.10471585891959201, 0.9899765704119001, 0.9838943167269634, 0.9903222343342659, 0.9726913397195514, 0.9806862184408655, 0.9890438743805663, 0.9891008973411822, 0.9871415604436599, 0.9907615218702234, 0.6243246880326373, 0.0600453438947568, 0.5872511436151573, 0.6265900725273679, 0.6511285083944054, 0.15128264757585963, 0.582976596663944, 0.5984621050666168, 0.6194414242591868, 0.8045039893763757, 0.7416082248196529, 0.7958161769065248, 0.8588115701678709, 0.7793854712188545, 0.7394842588728753, 0.7276867564728978, 0.7526499602192656, 0.8326804524549528, 0.309270851817679, 0.3688658382254607, 0.3738820316370345, 0.3786214081519299, 0.35599650807449323, 0.4031663615961928, 0.4306160409817831, 0.34049907657921663, 0.3818480173200808, 0.34597205854019697, 0.016917224677294174, 0.3795094547974356, 0.3837671965300915, 0.39051159421824566, 0.39624971696924494, 0.39286096032341034, 9.999999999998899e-05, 0.3894615835521652, 0.32148627438033317, 0.054719331446704156, 0.29057734123985834, 9.999999999998899e-05, 0.31479658470094607, 0.2555397661075651, 0.3158819201981665, 0.30074772752120726, 0.2377518632845177, 0.3922044227834325, 0.457305274688403, 0.3865250328952592, 0.44285410129662606, 0.34011508817728786, 0.37405301090818066, 0.4118039155207761, 0.4387760631139437, 0.45351095028935307, 0.16603094404435237, 0.05424664886984498, 0.0571500527990495, 0.18620063604524006, 0.1587976278953631, 0.07755897225615305, 0.1635898415699647, 0.09786577011672493, 0.08988771345611624, 0.1961117768962003, 0.26822097370700226, 0.2401604488660477, 9.999999999998899e-05, 0.006171167618419404, 0.28621065615696384, 0.23602612261752465, 0.048887346904255335, 0.08219601077201277, 0.7010261158813813, 0.6866085806030013, 0.6710207466428623, 0.646845757121224, 0.6549761280836844, 0.20868449285044022, 0.6432085097439215, 0.6023261565314075, 0.6808490071334794, 0.10892949517091788, 0.13140314433758737, 0.11992620434471668, 0.13773656411753787, 0.12113201465987455, 0.16923445495014422, 0.124551503248995, 0.09121276213797447, 0.15485406312130856, 0.4149225425438796, 0.21436216278640097, 0.1501491610409732, 0.22224303337939533, 0.5956645498343437, 0.33709251016311825, 0.1986247389566138, 0.2505445197591667, 0.18440948290765424, 0.4997609860635125, 0.44858149845736983, 0.47055444663276025, 0.4603307656757304, 0.4613672830434834, 0.43411317528541205, 0.48180422663149103, 0.5113972122331218, 0.4986769452695139, 0.33992306373812486, 0.2832329693261858, 0.31679083904855876, 0.3097417901486874, 0.33844321119163057, 0.2958140231962235, 0.37272174642277156, 0.3712832052616092, 0.30109201574538236, 0.2125623626443225, 0.22026025430032192, 0.20031578433220398, 0.28434095478938703, 0.21982195397415283, 0.22452039960729175, 0.24374451288563115, 0.2136709602633401, 0.25096885411717185, 0.19522869346147587, 0.2414584713373018, 0.2112869851599598, 0.5378179650738908, 0.6324582753376501, 0.2065053796147297, 0.4815931396459088, 0.23211874364227525, 0.6840959277465557, 0.8675293035494389, 0.17621756661540655, 0.16499513050721304, 0.8372023579489762, 0.20130400889622602, 0.8753341271496974, 0.09969694705444432, 0.16972101287772257, 0.16424896177067527, 0.775507851610146, 0.21009937024530467, 0.12653822946308624, 0.7403304663964336, 0.16793976923193477, 0.21046269723322952, 0.18928554539401987, 0.15387455180467657, 0.819292449829423, 0.20698436436887568, 0.18403051390354286, 0.197947625787101, 0.19374675382364404, 0.17698107365022953, 0.18118046705487667, 0.18306073138455248, 0.1849234987041276, 0.19959540712421564, 0.09365830805135356, 0.09048731034028912, 0.08594853071404018, 0.0780066006608966, 0.08734319790729717, 0.10261005841739357, 0.09526563018704115, 0.08545941511516209, 0.0924721987845516]}, "mutation_prompt": null}
{"id": "66aaedbf-2b1b-440d-ba8c-bb4aeeb9be46", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20  # Population size\n        self.inertia_weight = 0.7  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8  # Mutation factor for DE\n        self.recombination_rate = 0.9  # Recombination rate for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize particle positions and velocities\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.c1 * r1 * (personal_best_positions - positions)\n                          + self.c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            # Evaluate all particles\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            # Update personal bests\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            # Update global best\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            # Differential Evolution mutation and recombination\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "AdaptiveSwarmOptimizer", "description": "A novel adaptive swarm-based optimizer that combines particle swarm optimization with differential evolution for enhanced exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "30fa9ac7-fd8b-4832-b596-51f7fa78bbc0", "metadata": {"aucs": [0.7989986418417774, 0.7927707653376858, 0.8203837584970056, 0.8298917754423807, 0.8328282229651067, 0.19077457232124362, 0.828805234961724, 0.797688131072892, 0.8352428426565499, 0.592686135755466, 0.614416006307235, 0.5687512167607289, 0.6076527311245735, 0.586484361104169, 0.6145340561645514, 0.6218679964025349, 0.5870529642192279, 0.6151084236581683, 0.16560860954470058, 0.35928869940623276, 0.12186238741538769, 0.1462527889593246, 0.15698442399763013, 0.17480575610305527, 0.1306742971102145, 0.1593185033886403, 0.1407083581084344, 0.12683055611116634, 0.14296603192534618, 0.14568167184658798, 0.1496734353638034, 0.12515808395862027, 0.11438680786649147, 0.14549965141189802, 0.10945732241260997, 0.10471585891959201, 0.9899765704119001, 0.9838943167269634, 0.9903222343342659, 0.9726913397195514, 0.9806862184408655, 0.9890438743805663, 0.9891008973411822, 0.9871415604436599, 0.9907615218702234, 0.6243246880326373, 0.0600453438947568, 0.5872511436151573, 0.6265900725273679, 0.6511285083944054, 0.15128264757585963, 0.582976596663944, 0.5984621050666168, 0.6194414242591868, 0.8045039893763757, 0.7416082248196529, 0.7958161769065248, 0.8588115701678709, 0.7793854712188545, 0.7394842588728753, 0.7276867564728978, 0.7526499602192656, 0.8326804524549528, 0.309270851817679, 0.3688658382254607, 0.3738820316370345, 0.3786214081519299, 0.35599650807449323, 0.4031663615961928, 0.4306160409817831, 0.34049907657921663, 0.3818480173200808, 0.34597205854019697, 0.016917224677294174, 0.3795094547974356, 0.3837671965300915, 0.39051159421824566, 0.39624971696924494, 0.39286096032341034, 9.999999999998899e-05, 0.3894615835521652, 0.32148627438033317, 0.054719331446704156, 0.29057734123985834, 9.999999999998899e-05, 0.31479658470094607, 0.2555397661075651, 0.3158819201981665, 0.30074772752120726, 0.2377518632845177, 0.3922044227834325, 0.457305274688403, 0.3865250328952592, 0.44285410129662606, 0.34011508817728786, 0.37405301090818066, 0.4118039155207761, 0.4387760631139437, 0.45351095028935307, 0.16603094404435237, 0.05424664886984498, 0.0571500527990495, 0.18620063604524006, 0.1587976278953631, 0.07755897225615305, 0.1635898415699647, 0.09786577011672493, 0.08988771345611624, 0.1961117768962003, 0.26822097370700226, 0.2401604488660477, 9.999999999998899e-05, 0.006171167618419404, 0.28621065615696384, 0.23602612261752465, 0.048887346904255335, 0.08219601077201277, 0.7010261158813813, 0.6866085806030013, 0.6710207466428623, 0.646845757121224, 0.6549761280836844, 0.20868449285044022, 0.6432085097439215, 0.6023261565314075, 0.6808490071334794, 0.10892949517091788, 0.13140314433758737, 0.11992620434471668, 0.13773656411753787, 0.12113201465987455, 0.16923445495014422, 0.124551503248995, 0.09121276213797447, 0.15485406312130856, 0.4149225425438796, 0.21436216278640097, 0.1501491610409732, 0.22224303337939533, 0.5956645498343437, 0.33709251016311825, 0.1986247389566138, 0.2505445197591667, 0.18440948290765424, 0.4997609860635125, 0.44858149845736983, 0.47055444663276025, 0.4603307656757304, 0.4613672830434834, 0.43411317528541205, 0.48180422663149103, 0.5113972122331218, 0.4986769452695139, 0.33992306373812486, 0.2832329693261858, 0.31679083904855876, 0.3097417901486874, 0.33844321119163057, 0.2958140231962235, 0.37272174642277156, 0.3712832052616092, 0.30109201574538236, 0.2125623626443225, 0.22026025430032192, 0.20031578433220398, 0.28434095478938703, 0.21982195397415283, 0.22452039960729175, 0.24374451288563115, 0.2136709602633401, 0.25096885411717185, 0.19522869346147587, 0.2414584713373018, 0.2112869851599598, 0.5378179650738908, 0.6324582753376501, 0.2065053796147297, 0.4815931396459088, 0.23211874364227525, 0.6840959277465557, 0.8675293035494389, 0.17621756661540655, 0.16499513050721304, 0.8372023579489762, 0.20130400889622602, 0.8753341271496974, 0.09969694705444432, 0.16972101287772257, 0.16424896177067527, 0.775507851610146, 0.21009937024530467, 0.12653822946308624, 0.7403304663964336, 0.16793976923193477, 0.21046269723322952, 0.18928554539401987, 0.15387455180467657, 0.819292449829423, 0.20698436436887568, 0.18403051390354286, 0.197947625787101, 0.19374675382364404, 0.17698107365022953, 0.18118046705487667, 0.18306073138455248, 0.1849234987041276, 0.19959540712421564, 0.09365830805135356, 0.09048731034028912, 0.08594853071404018, 0.0780066006608966, 0.08734319790729717, 0.10261005841739357, 0.09526563018704115, 0.08545941511516209, 0.0924721987845516]}, "mutation_prompt": null}
{"id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 3, "fitness": 0.4226078490566027, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "30fa9ac7-fd8b-4832-b596-51f7fa78bbc0", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "69ed916b-8d90-41d9-a405-8a956e101dd9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.9  # Adjusted for more aggressive exploration\n        self.recombination_rate = 0.8  # Adjusted to increase diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.neighborhood_factor = 0.3  # New parameter for variable topology\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            # Adaptive topology: each particle considers a random subset of neighborhood\n            neighborhood_size = max(1, int(self.neighborhood_factor * self.population_size))\n            neighborhood_indices = [np.random.choice(self.population_size, neighborhood_size, replace=False) for _ in range(self.population_size)]\n\n            for i in range(self.population_size):\n                local_best_position = personal_best_positions[neighborhood_indices[i][np.argmin(personal_best_scores[neighborhood_indices[i]])]]\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (inertia_weight * velocities[i]\n                                 + c1 * r1 * (personal_best_positions[i] - positions[i])\n                                 + c2 * r2 * (local_best_position - positions[i]))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "Enhanced swarm optimizer utilizing variable topology and adaptive differential evolution for improved global search.", "configspace": "", "generation": 4, "fitness": 0.34899697992243106, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8170459037726183, 0.8007102356956982, 0.8402095741721473, 0.827868846795299, 0.8232125996042343, 0.8352233813965833, 0.835415035477866, 0.8185990989143361, 0.8199685394212167, 0.7029089123797485, 0.6915370354794345, 0.6860913524414671, 0.6903369602221265, 0.6873554858605093, 0.6856034279941248, 0.7009319810392571, 0.6519251243831834, 0.6858503999028447, 0.19079158140394792, 0.13635271313252384, 0.136217067994989, 0.12585485506031402, 0.13367595436043267, 0.0675502742805224, 0.11509751993077422, 0.1497157922813077, 0.12092297373209493, 0.12187397261738098, 0.13768341341794144, 0.10355256268658886, 0.11284861535502022, 0.11845121430054639, 0.12569858328859496, 0.12321002704907402, 0.12181434222188603, 0.12267214209680133, 0.9909086685902203, 0.9916332259126834, 0.9879312026651834, 0.9869404924492076, 0.9874589611968134, 0.9894029399623588, 0.9871428642969579, 0.9934296186095548, 0.9933418417507043, 0.655736533683414, 0.6491485566884558, 0.6773192292971977, 0.6791662737877893, 0.649523815012287, 0.6427175215675245, 0.6911417689843184, 0.6511427912605878, 0.08826628287961302, 0.7275432494044969, 0.7348927299202244, 0.6929927539152578, 0.19363073046709378, 0.21724209452630072, 0.6613209170496587, 0.7851294550228196, 0.723507394160725, 0.7257080289477118, 0.28343668266115896, 0.29517123789654687, 0.30960229477640433, 0.3509956727581237, 0.32964239099876425, 0.3645227583517744, 0.37509710243666505, 0.3311890621210586, 0.3309235894412059, 0.12733371111691139, 0.05381161824929659, 0.2898919094378912, 0.336443463661558, 0.315519630876827, 0.3323294664691231, 0.34045240880983973, 0.30676304376301056, 0.2755294731102307, 0.06221606504091903, 0.04807612147118867, 0.11109894846727097, 0.10313022049093756, 0.06868146244183115, 9.999999999998899e-05, 0.0604830011041233, 0.0455291187860043, 0.04887531230926356, 0.20434544212785544, 0.17961332486950254, 0.16272579615406468, 0.1571934650229434, 0.19525121024355918, 0.16441432613394968, 0.2117228197627653, 0.24969848440264863, 0.1950726444080939, 0.04416200025910366, 0.03779503153727315, 0.0420612566666525, 0.022124137500587282, 0.05257033625726559, 0.00888854958453611, 0.08770607996391522, 0.09236988244187783, 0.06687363172585048, 0.14103198825625607, 0.18263897045849053, 0.16905475678505322, 0.17075308227684505, 0.17148538976532057, 0.18797027636217667, 0.1389362304449987, 0.1420784462078526, 0.1728242615473582, 0.5279564260696756, 0.5476658840619907, 0.538217877838982, 0.579900338996935, 0.5567816553702167, 0.5455296660163673, 0.5662763238089736, 0.5985401521553588, 0.5773459160499869, 0.11338568646760072, 0.11622662156160934, 0.09403639648097784, 0.0904163126442723, 0.09203116746183126, 0.11063693360566507, 0.10742936090672794, 0.10908596575465201, 0.09917201591703961, 0.14539249248642172, 0.17657789530372225, 0.1418397636284281, 0.1949967589371524, 0.16238287046206734, 0.1436613279633604, 0.14298077944084875, 0.1798801770506523, 0.24190248314346485, 0.4267963157400422, 0.6140787251082018, 0.5679350991822693, 0.47525417717947405, 0.5577469828385486, 0.4097595651425957, 0.6325435378720696, 0.49579002420697327, 0.6057494603825511, 0.29414803422869495, 0.27437186796903756, 0.29838494525866877, 0.38182147808755806, 0.3246709370177614, 0.19662548358532006, 0.33188196872520825, 0.3617270764329146, 0.3729898090971804, 0.19332994863808317, 0.20138980175332488, 0.1898397525055462, 0.1960435277406919, 0.19000430368804178, 0.18921348186361597, 0.17116684998228193, 0.1735968727317615, 0.20357286151516374, 0.5000544121764359, 0.20875320395227848, 0.4171767801660309, 0.3311799364819411, 0.6331379604927052, 0.30974767072007703, 0.2154797994069867, 0.19254476295310263, 0.1913390577628884, 0.8084126621987269, 0.20391143622391605, 0.8656925580296553, 0.8005375029443191, 0.19798173161346644, 0.8351735849314843, 0.5956670110421141, 0.16752308914778224, 0.7798275122116956, 0.6775834500224202, 0.1687839084304742, 0.7103004237767252, 0.20573550984233768, 0.16677854316697371, 0.20189846539151357, 0.19291409043466545, 0.18497386011042039, 0.12652575193979088, 0.1871506739790474, 0.18709751543176378, 0.18674915025301309, 0.17791683009316295, 0.1778307396294776, 0.20073397789123293, 0.19296823723888157, 0.1844132436748247, 0.2768151895739406, 0.08495836144292368, 0.07425466695000482, 0.07607237127583644, 0.08016863233503391, 0.07501825694871389, 0.08098090970525551, 0.08400210871723501, 0.08602381974938689, 0.08257113433856134]}, "mutation_prompt": null}
{"id": "30e70926-74e3-480c-bf70-8b842a4175d5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size for diversity\n        self.inertia_weight = 0.6  # Adjusted inertia for better balance\n        self.c1 = 1.4  # Fixed cognitive coefficient\n        self.c2 = 1.6  # Fixed social coefficient\n        self.mutation_factor = 0.85  # Higher mutation factor for exploration\n        self.recombination_rate = 0.8  # Lower recombination rate for stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.c1 * r1 * (personal_best_positions - positions)\n                          + self.c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = np.delete(np.arange(self.population_size), i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerV2", "description": "An improved hybrid optimizer combining adaptive swarm dynamics with a refined local search strategy, optimizing performance and convergence speed.", "configspace": "", "generation": 5, "fitness": 0.34871064006104885, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8228729176076159, 0.8254918268607412, 0.8266329838510891, 0.8301159897835727, 0.819010219038575, 0.8323206559125784, 0.8262952381485258, 0.8255290320533815, 0.8204289760816765, 0.6050755694362601, 0.6429509955019963, 0.63978212163679, 0.6233131536308096, 0.625146507155311, 0.6058042459230253, 0.6383563387506148, 0.6506899574911637, 0.6029942122293166, 0.3822032462565449, 0.15226504947550312, 0.15077090477673738, 0.16497081552185866, 0.11230156572814598, 0.1491732378635343, 0.15647371608679728, 0.17483367893312374, 0.13677655935238076, 0.10993473602028336, 0.13198860734908013, 0.13509001868245052, 0.2947500054422644, 0.1292753659537753, 0.13120554947126917, 0.1362812370569998, 0.11267010412719136, 0.15548630798629726, 0.9867844231353068, 0.9860783956477774, 0.9871786130873716, 0.9855011557298538, 0.9824367704190793, 0.9758675953173402, 0.9859164073417801, 0.9856834990021048, 0.9860702173066059, 0.6400143964460645, 0.5314673554609437, 0.5934319883375738, 0.6429611572729415, 0.1516582055463579, 0.6475900332583548, 0.615937205517191, 0.6524685389584732, 0.5477823898166951, 0.22928450928110655, 0.8055033583055118, 0.7585166733778546, 0.7908278177020767, 0.20531344902859838, 0.20095594617154933, 0.7683122972853578, 0.2315419531716424, 0.7101411567326991, 0.25496300126935323, 0.30232812114616003, 0.3054471618611526, 0.12737541858384793, 0.26737324605951907, 0.12826689764863153, 0.2873830762675953, 0.2697242589180042, 0.3760357986923225, 0.2672557264572776, 0.016552732695092387, 0.267278935208791, 0.3234588383402106, 0.28018098029317984, 0.2877923236467378, 0.2748187084509406, 0.21477818955379901, 0.3363704681137881, 0.0492121308240534, 0.038447881787153304, 0.09016625066211326, 9.999999999998899e-05, 0.03960594128902373, 0.046939261249665076, 0.05771840907074488, 0.05414832426558347, 0.0942684889308597, 0.1944562059052145, 0.18908361429249376, 0.17485277104547292, 0.16247906037514426, 0.11998171075467157, 0.14315744337310443, 0.19524272163611855, 0.17345277790811997, 0.18258338868595847, 0.04694580926705527, 0.030930094358747384, 0.2225784452036228, 0.06956386887439092, 0.22671234982358968, 0.12047274893616577, 0.31339609541951785, 0.1624615254535935, 0.06648042985865255, 0.2052350174466181, 0.041495300760524656, 0.1646247068292177, 0.2198459775519268, 0.1712441417073387, 0.2351209230790382, 0.1556341159025374, 0.05519192155758934, 0.13279421441441752, 0.5432544639114403, 0.5801753107648256, 0.5441407350874952, 0.5702944918869263, 0.5669090564997536, 0.5688537600872863, 0.5641061357377839, 0.5615983116984024, 0.6061116862692464, 0.14777229972277295, 0.13683386620091786, 0.09656315120451076, 0.10761395950177688, 0.13459575707553229, 0.1597274942055621, 0.11859317346904175, 0.17816418251014943, 0.13249945625722082, 0.3026474208730856, 0.2206703653917852, 0.19831836224932153, 0.19298237434620114, 0.5134279301477551, 0.1742291718018889, 0.6087068623049714, 0.14346092758215379, 0.2050911825079258, 0.3059116440069971, 0.3590903313425663, 0.3598118492372948, 0.4043629417208683, 0.5235917467533172, 0.4179238268267179, 0.5343921339133271, 0.5411329316981972, 0.5393809173027337, 0.2757588572484171, 0.25620875880377536, 0.2826928237593268, 0.3828809171412464, 0.29974555405274506, 0.2857780136052557, 0.2678369317528071, 0.29095203440090744, 0.28056291281836654, 0.21434247260598438, 0.21360983195461192, 0.22261593051908246, 0.2412334685657722, 0.21940444159962957, 0.23045700509936395, 0.24687192986243078, 0.235425821484876, 0.20277351499093643, 0.23372517432940132, 0.21813529467559933, 0.2136299751874322, 0.24209310037773668, 0.24132978131412186, 0.21960509994368616, 0.48830078252432196, 0.18428181751190864, 0.6185826120343636, 0.8554985785467866, 0.16199034748845165, 0.8006606810502908, 0.17241529833658897, 0.20086955507954152, 0.20091284868175951, 0.14519027656627803, 0.1673696095504441, 0.8713601467247896, 0.7746572869336925, 0.15574217906864085, 0.7786178167636897, 0.7624635435950087, 0.768532965788848, 0.7812133016354224, 0.20691041814004552, 0.20777541412374145, 0.8176454239373776, 0.2021660277337578, 0.21474551997586855, 0.1905720249880466, 0.18949048826076842, 0.17743486066951863, 0.1868267293618534, 0.20494465300517206, 0.1746575886643681, 0.1864321194250671, 0.09612683473194139, 0.08906333880081241, 0.07767893187897512, 0.08927251169731532, 0.0896389975557147, 0.08721764755753425, 0.08423657358852998, 0.08461653672951075, 0.09628099874658569]}, "mutation_prompt": null}
{"id": "2d65c7d4-2d2f-4e24-abdd-87e3820d2ccc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "367bdc16-9751-4cde-b932-ca197fe6d417", "solution": "import numpy as np\n\nclass EnhancedHybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25\n        self.inertia_weight = 0.8\n        self.c1_initial = 1.2\n        self.c2_initial = 1.2\n        self.c1_final = 0.6\n        self.c2_final = 2.4\n        self.mutation_rate = 0.85\n        self.crossover_prob = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_rate * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.crossover_prob\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridSwarmOptimizer", "description": "A hybrid swarm optimizer with enhanced local search through differential mutation and adaptive inertia.", "configspace": "", "generation": 7, "fitness": 0.3628054355831928, "feedback": "The algorithm EnhancedHybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8268156371953308, 0.808462220788883, 0.8179847427137382, 0.8401800088857877, 0.8262192871389082, 0.8146912573691143, 0.8220998701023975, 0.8135098552451614, 0.8225324046084816, 0.6531012543948576, 0.6739846476822744, 0.6565632007814901, 0.6441995752342353, 0.6498521985159929, 0.6635956485380721, 0.6908246867803359, 0.6636317218608666, 0.6548966168329955, 0.17148489105076403, 0.17444194558228843, 0.17464791664841883, 0.13327677025676132, 0.16027590712700035, 0.5168897976549014, 0.14806456182261796, 0.1381273380725503, 0.1420920796140679, 0.12891973137918555, 0.1437365908623739, 0.16450751725324753, 0.11107145252330897, 0.12046160577444465, 0.11225259251135189, 0.13788437048128743, 0.1355575777369673, 0.13033982247109255, 0.9878463199230834, 0.9907492387718954, 0.9917469382916801, 0.982675829429852, 0.983130473762644, 0.9858594133379378, 0.988136193820114, 0.988228701752539, 0.9833663510107238, 0.6696565608845098, 0.6912959498691074, 0.706425655100743, 0.15006855345469228, 0.7034654671287665, 0.648229501171656, 0.08847481571603089, 0.685938605489366, 0.6913364172466538, 0.2268223757611969, 0.778193654435968, 0.7650201687974008, 0.8183078203306886, 0.785930982798999, 0.2741618076216228, 0.2240864513936015, 0.7545821403252101, 0.8111770531369774, 0.11485583734238192, 0.4903108199897406, 0.32644284035291826, 0.33029210917731655, 0.2988454836616776, 0.3565241890229571, 0.39965284880827046, 0.3662130121791891, 0.37480843477735204, 0.3833738036427732, 0.022289872180033865, 0.3947185484586153, 0.13161477990933712, 0.3998629828381759, 0.3516853784887318, 0.36869996493385493, 0.31309813823723576, 0.3665084204013036, 0.05094695836753349, 9.999999999998899e-05, 0.10923647829938454, 0.04333764483875835, 0.06979672729009889, 0.09091764297332106, 0.13262784191242194, 0.09844136141080073, 0.06909421166011886, 0.17814180987688355, 0.1983437326483346, 0.2070939651843141, 0.2117599589704049, 0.18967269767384864, 0.18701409438026095, 0.2849194029023082, 0.2797242005986472, 0.257093545873619, 0.07643206265525171, 0.03069269834172539, 0.05924770990422712, 0.06969050797064014, 0.1615301771050619, 0.07394529944167638, 0.17439050286194613, 0.08580821865675137, 0.14155033448251086, 0.4114789851468621, 0.28436795409975435, 0.19047711691662306, 0.20972341786178583, 0.2215308363991727, 0.22528089463479417, 0.08045037124710286, 0.2474853889224471, 0.0810210797332116, 0.599484007785813, 0.5988521719820077, 0.6086459832430424, 0.6009508927890955, 0.5988137195063217, 0.20777210840808624, 0.6216642237835288, 0.639992347260206, 0.6088155868262093, 0.08242093573248999, 0.1327432414809282, 0.12529685440502836, 0.1291863632089626, 0.12546586062516674, 0.15479281085880214, 0.12325050134795235, 0.13320316673370558, 0.1351079580474911, 0.17395562447601864, 0.652358414867877, 0.1542553492567944, 0.19996072022891043, 0.6471560872547886, 0.3412691037525002, 0.5449298593799821, 0.1872316834635691, 0.3944777924225913, 0.41184985690056264, 0.6402121085249542, 0.45770226738078623, 0.332717898348877, 0.3920106197197455, 0.6286205394967431, 0.6338207194900116, 0.46433349483283914, 0.6487463901628103, 0.29840054393444504, 0.33740070209485196, 0.40705178217992066, 0.19319294867326897, 0.22369313803899682, 0.31132945658011446, 0.2681612089774871, 0.4513644442706435, 0.2704885299126766, 0.22434869122818735, 0.19849301470125602, 0.21739631743131027, 0.22445138444449575, 0.21419236304804323, 0.22176806757580925, 0.20608745311449583, 0.1891981048648933, 0.22973608171299476, 0.701397825706014, 0.19946649943376182, 0.24562929067184014, 0.19901172254131294, 0.6065906061869705, 0.18221738702091939, 0.6975021965777581, 0.2365328995782212, 0.22031877700764124, 0.8164693263895191, 0.1928203885467611, 0.15340483998227283, 0.12586995227406772, 0.19863531038486404, 0.1968820125836681, 0.12579181341678736, 0.1695210203874632, 0.8063223711680978, 0.08289597863910625, 0.1575854466410076, 0.20736661608030138, 0.7923602571599914, 0.15385989517151488, 0.21070599528502543, 0.8067658689904293, 0.7990521567352189, 0.7576927753422582, 0.1949163820391977, 0.17974230781112088, 0.1882635423833663, 0.18876380153843242, 0.19565703591323969, 0.20743990760236908, 0.19092841628823276, 0.190655621119599, 0.21100367484218074, 0.10131675618261193, 0.0903199996796058, 0.10139917213475214, 0.0908339467980872, 0.08895825435675431, 0.09734774936109569, 0.09154067905896213, 0.08490884582762137, 0.09523322646083654]}, "mutation_prompt": null}
{"id": "dcced8b0-ec59-427d-8f6f-4c139a578a8d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f690ca48-c357-4f1d-a63a-af6ea1a97548", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f5fc71f2-4426-4e3d-b978-d292d772607d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "3db279dd-d443-444c-aa9d-b238117b34d7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "6613dab7-412a-479e-9ef3-9c09103b529f", "solution": "import numpy as np\n\nclass ImprovedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size for diversity\n        self.inertia_weight = 0.6  # Adaptive inertia weight\n        self.c1_initial, self.c2_initial = 1.2, 1.7\n        self.c1_final, self.c2_final = 0.7, 2.3\n        self.mutation_factor = 0.85\n        self.recombination_rate = 0.8  # Reduced for more exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Reduced initial velocity\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight - 0.4 * (evaluations / self.budget)  # Adaptive inertia\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities \n                          + c1 * r1 * (personal_best_positions - positions) \n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "ImprovedAdaptiveSwarmOptimizer", "description": "An optimized swarm-based search algorithm enhanced with adaptive inertia and crossover strategies for improved convergence and efficiency.", "configspace": "", "generation": 12, "fitness": 0.3560884730097402, "feedback": "The algorithm ImprovedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8465242005792069, 0.8429350735432308, 0.8392610635378258, 0.8403532489416661, 0.19050784578235802, 0.8253145741015075, 0.8444776180055926, 0.8404703433884446, 0.8603235177826426, 0.6853577800473896, 0.6926764821361729, 0.6650595433697724, 0.7019507833353688, 0.6654275284553061, 0.6969789185438162, 0.7042059988655265, 0.7158440077791255, 0.6978139959304874, 0.1279556297597796, 0.15626130465157517, 0.6301795914735475, 0.15771909302212062, 0.14917658179452664, 0.16902606149365473, 0.1536111734802944, 0.6613410624899716, 0.13485387316454767, 0.11007223908592423, 0.1044499743095817, 0.1338682129058849, 0.16877964080317964, 0.12249723877291052, 0.10846818832432203, 0.12780779532059983, 0.10316770261308206, 0.15595333140795287, 0.9866016256080261, 0.9864459220093174, 0.986772649757426, 0.9857999623503017, 0.9824417601668683, 0.975761816776547, 0.9865168607681155, 0.9857407509759718, 0.9861539565596034, 0.7032838083403117, 0.05852172476457618, 0.6904270551806004, 0.6260899821562554, 0.1518414441136665, 0.6908023136446216, 0.7006691680546553, 0.6941148561745198, 0.6603796313644708, 0.1722677209524156, 0.7530602780912017, 0.8479794163446956, 0.27759117571204994, 0.18944109197527026, 0.2721572231184163, 0.8229272736217974, 0.7961741368023685, 0.23389174300607551, 0.12921212200188237, 0.32294076160439744, 0.27783357297391476, 0.3639087385526537, 0.34951309345005244, 0.3774047114635728, 0.4025636718444704, 0.3021522245114323, 0.35879194711558926, 0.13287544717528021, 0.016814123177647522, 0.3400008523075654, 0.399751799825699, 0.35066062750741867, 0.3341292157579516, 0.39931890171866835, 0.14543530340407596, 0.30224541999762256, 0.0634596321453812, 0.09939658600967427, 0.10623758789378046, 0.10909147785047901, 0.014494093734784497, 0.05417995678542353, 0.0967080093024999, 0.0839007079649553, 0.10380181336033134, 0.20081815093806288, 0.14471262200338875, 0.157608746753095, 0.17724517187333932, 0.14736182376555917, 0.15284008134745253, 0.24829554312181112, 0.20096607388431476, 0.21682853007227465, 0.10215918433656856, 9.999999999998899e-05, 0.046982568933559565, 0.07410981994113086, 0.09473308449186224, 0.07358374233919307, 0.12719012662120455, 0.09426638073858051, 0.06840556665783282, 0.20358732330509033, 0.1794926724710092, 0.40474930492424266, 0.2692276899967252, 0.19348031130600218, 0.2508600014325959, 0.12447137368987005, 0.05629992395103056, 0.14728998743579702, 0.6102320356599934, 0.5731624385832714, 0.5950050194606066, 0.6455533318779112, 0.6250118597595362, 0.6083267573237474, 0.6144877449969157, 0.6113421235236651, 0.6375723043244552, 0.6695284082660797, 0.4673779797075931, 0.11872184550983889, 0.12608068112652326, 0.1351557080351211, 0.12805622318638055, 0.17967414904064316, 0.11065547674806953, 0.1676865827345687, 0.2941519879122936, 0.221723112861401, 0.155417220035732, 0.21080702302677634, 0.40174105358930157, 0.2116241245115299, 0.40827316676831327, 0.1709933401690743, 0.22666406052441812, 0.45965129732279897, 0.4274019093336381, 0.42863775169287055, 0.23724559244547094, 0.4154152350106005, 0.39210572273131405, 0.5363737320365147, 0.4540749626947006, 0.5303518949864368, 0.24377076905856465, 0.23364963170057396, 0.27390500479866575, 0.25353976053008787, 0.20529252468371484, 0.30726140063598095, 0.39713250843634584, 0.36987515203956867, 0.27622719610347646, 0.1988084359513318, 0.24065629749641926, 0.22826616322969528, 0.19754421134628064, 0.1841239837235572, 0.21985928541404076, 0.22304993154227248, 0.1944780113165031, 0.2296325065388264, 0.7103458637293929, 0.24571697241085444, 0.20923992423262638, 0.19797784861934142, 0.706794343009843, 0.6806218620849404, 0.2202663104607404, 0.23773253729858357, 0.20453997674044555, 0.17251989119157296, 0.16248991538260105, 0.15381601294047542, 0.16388685640074085, 0.20146273463031483, 0.19977178349986502, 0.1312732008970413, 0.16966826615473307, 0.8697515997752577, 0.833962803801816, 0.7442004716491577, 0.7410735151280355, 0.2688351017044247, 0.7209602258163536, 0.7973866917473439, 0.211058675376961, 0.20779178436232548, 0.8232975681081319, 0.2017499140552157, 0.1893873707470186, 0.18601015748553418, 0.20046168722505586, 0.17451230358659686, 0.1965660366617008, 0.21795055747057157, 0.19723119791119448, 0.1887456955914275, 0.12056059645944261, 0.09615099052373899, 0.0815631159789234, 0.08502555663938616, 0.10652799143323632, 0.0859525673726399, 0.10819065932041538, 0.08572461302029899, 0.09398501624570943]}, "mutation_prompt": null}
{"id": "242d2dc5-6e7d-4e3d-bd6d-819cc9e19c5f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "02232ccc-6467-43c0-a605-3927932ad407", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Adjusted population size\n        self.inertia_weight = 0.6  # Adjusted inertia weight\n        self.c1 = 0.8  # Simplified adaptive coefficients\n        self.c2 = 1.8\n        self.c3 = 0.5  # New coefficient for random exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))  # Initialized to zero\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2, r3 = np.random.rand(3, self.population_size, self.dim)\n            random_exploration = r3 * self.c3 * (np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim)) - positions)\n            velocities = (self.inertia_weight * velocities\n                          + self.c1 * r1 * (personal_best_positions - positions)\n                          + self.c2 * r2 * (global_best_position - positions)\n                          + random_exploration)\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive random exploration and velocity adjustments to enhance convergence efficiency.", "configspace": "", "generation": 14, "fitness": 0.16540794061574574, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.2808868719982577, 0.257516632872566, 0.2948481713583334, 0.25477187861101913, 0.26355400961698605, 0.27525601032475355, 0.2577132147863208, 0.26329423630729165, 0.25633669452774444, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09092659038105122, 0.0747648272735647, 0.06925330407108976, 0.0682630466948907, 0.07048831742730033, 0.10102573491593647, 0.1050642895111128, 0.08073080706908953, 0.08093996752602439, 0.0687647353032953, 0.07514162203096908, 0.07929062554659139, 0.06643893512277577, 0.05961217998890511, 0.07792539614654959, 0.08744214124209848, 0.0769888528935988, 0.07044124732291424, 0.9249754191808086, 0.9893916136973958, 0.9429734270720588, 0.9830526410607336, 0.9580810351133273, 0.9257623767379111, 0.9768160363678775, 0.992589959004037, 0.9423106024473595, 0.1434103778689223, 0.1452813941021588, 0.17888862394767036, 0.15132420598668395, 0.16970471822468736, 0.15851300144085967, 0.1578016202175746, 0.17671807181887378, 0.16552218991014145, 0.20806882082417488, 0.20883990314133427, 0.19413471951712358, 0.18487445644587053, 0.1695798163667841, 0.19595720382643234, 0.18496218798416542, 0.20473859149448348, 0.1954591896706107, 0.053583904771080104, 0.07994710934657956, 0.07446434382547618, 0.07671614093005197, 0.11794753137479874, 0.05590715921414213, 0.12676176963363883, 0.07962527017569954, 0.06842894750814199, 0.10004792031917842, 0.08377080434282247, 0.11348708750644798, 0.10274258003599335, 0.10344208257913756, 0.10573949110647718, 0.08696015732978579, 0.07511841575422151, 0.09285747281641565, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09077072349049708, 0.1096958789166319, 0.06168751400354233, 0.0853312580603599, 0.04179918199617694, 0.049477852652846765, 0.08119084581014235, 0.1342713851987133, 0.08686681410125985, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012000540542205451, 0.031211537276669477, 0.021611463378808926, 0.024269925237941026, 0.028264187576360178, 0.021431660012242504, 0.014847162492643284, 0.026710664949136653, 0.029213348853915022, 0.2692760235839048, 0.2787811925215853, 0.3104322662134147, 0.2817688699085621, 0.2636605545745776, 0.2674718820201346, 0.2658063556238147, 0.29745016668077784, 0.3056950158058883, 0.07654961230691004, 0.06250789578459659, 0.07474682918782471, 0.06824388043948004, 0.0811910492133282, 0.08514413467139004, 0.08299345661648383, 0.0803575876634286, 0.08479105216721616, 0.15241385853095457, 0.13624042803629732, 0.1315319096022628, 0.14688983760526386, 0.14010719227139778, 0.13131202609319426, 0.12394636054699071, 0.1306116973725331, 0.16263362279901228, 0.20643321119429325, 0.2018473924478088, 0.22054450999079278, 0.20942105158413638, 0.20467231112510842, 0.21597671814258523, 0.2135047356230515, 0.2062627681991781, 0.20850265508787913, 0.15487545401447456, 0.1389218107390725, 0.15475428235506428, 0.16102369094933877, 0.14908831384353394, 0.1645056689060459, 0.16372872963481133, 0.1590759412485544, 0.1571872824969951, 0.20675110919365536, 0.18883843266471134, 0.1959062676920832, 0.18876443969048806, 0.17438860185785265, 0.19651214761283686, 0.2176252587924259, 0.19989443523605932, 0.19172337113039462, 0.16708135788263212, 0.1669309018215266, 0.1680871589255526, 0.166129412937155, 0.1629873357798337, 0.16626372484315055, 0.1693878700974032, 0.17018277792260728, 0.16517696399182913, 0.3591525557443248, 0.1147785539575592, 0.1478815775740906, 0.22462778392640192, 0.16841227357828015, 0.3293171171464685, 0.15967091292078517, 0.16618992151993228, 0.3128397133472468, 0.26536905313239045, 0.1499600781489755, 0.300453475962301, 0.18739796651999918, 0.2465753624432342, 0.20184289284540535, 0.29419125188912787, 0.3018475674713583, 0.19557045458226563, 0.18089140852248276, 0.18388780816109473, 0.18568356108134043, 0.1948452758181397, 0.17885183065021681, 0.19185352881136086, 0.19322871221519444, 0.17090138073599992, 0.18254991974876877, 0.0839175005762891, 0.08191204110109485, 0.07020162597053459, 0.07465525298186271, 0.07532955840909794, 0.08143397505260042, 0.08026956532075669, 0.08303304546392387, 0.07476513871275692]}, "mutation_prompt": null}
{"id": "9d8bdf77-7904-4f24-ade2-56208ca1d334", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "c1a04de0-bfbb-4eb9-9f02-5e1fc397b962", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "a060fc76-9e9b-43c5-8435-f65e39504a4b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "e59e6f89-5ac2-48c6-a8ce-491c9cdda079", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "a169c6e0-89c9-41e6-8ad3-5622bf7e6cf4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "5f9680f7-c075-4943-acd2-47ed4edd7de3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "5fc706b8-93ce-4a1b-af36-62f5c45e9a6e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "90e61370-4d1f-4547-9fca-1efee056f8d4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "7f2d3235-e873-4f3f-bec8-a90640b0828f", "solution": "import numpy as np\n\nclass EnhancedDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.6\n        self.c1_initial = 2.0\n        self.c2_initial = 1.0\n        self.c1_final = 0.4\n        self.c2_final = 2.4\n        self.mutation_factor = 0.9\n        self.recombination_rate = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight - (0.5 * evaluations / self.budget)\n            c1 = self.c1_initial - (1.6 * evaluations / self.budget)\n            c2 = self.c2_initial + (1.4 * evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = indices\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedDynamicSwarmOptimizer", "description": "Adaptive Particle Swarm with Dynamic Differential Mutation and Enhanced Velocity Updates.", "configspace": "", "generation": 23, "fitness": 0.3869308984621948, "feedback": "The algorithm EnhancedDynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8566916503736902, 0.8391545071907378, 0.8486560534265835, 0.8600934499814694, 0.8563276686522839, 0.8584050731874622, 0.8635434999200351, 0.8551911965216574, 0.850596710481774, 0.6795459279904228, 0.712045102298672, 0.7163760946604901, 0.7100401571182184, 0.6913847361545957, 0.7022903667678077, 0.6968864138958715, 0.7093777715113387, 0.7090172161954253, 0.1693633671714404, 0.7185854215250989, 0.16729569724709237, 0.1509925555340813, 0.5436562409696896, 0.1766761225938126, 0.4251630890088086, 0.6487437155299245, 0.17180225677606265, 0.1536561018946062, 0.14954566002755487, 0.13577948713304, 0.15178675712838519, 0.1250884990158, 0.1688093259641793, 0.13917267013143864, 0.1122515689917114, 0.11859898803626423, 0.9849591452334028, 0.9807883814329277, 0.9858213550027881, 0.9785956064835751, 0.9848235140219106, 0.9754630484677986, 0.9852020784004913, 0.9879986754325726, 0.9857992532524887, 0.685699949139254, 0.6914384837177665, 0.6951756848199414, 0.7062657482972796, 0.6921894188446286, 0.7106314683031079, 0.6981715820624017, 0.7036037526481027, 0.6993187121537907, 0.8266317846582084, 0.21890176890198076, 0.7766795377925835, 0.7706306016313454, 0.21065931679549232, 0.36367977134822493, 0.7890988711110402, 0.7593788025093036, 0.8238504469848489, 0.3352458517421004, 0.37041090406288, 0.3561355686164651, 0.3544480807703789, 0.4218376595922737, 0.47256843419991656, 0.3803519030212036, 0.3662218050147329, 0.3583893311447255, 0.334441266953203, 0.0523859748238632, 0.3163808055661895, 0.34725502488003035, 0.3569060875987833, 0.41241559797873784, 0.3765565428541702, 0.30840783479314504, 0.4054394060251665, 0.0981681662807945, 0.07456636759478874, 0.14584438836804225, 0.09959033091352887, 0.1205472258111766, 0.08878557128891773, 0.09348486866445016, 0.11664561442394239, 0.2123410655100132, 0.1988101971274231, 0.16486504975760108, 0.17679968962948556, 0.21883605214227686, 0.19308906410153026, 0.1754009535910478, 0.22811205309136662, 0.17300674387685644, 0.1975914134536091, 0.2631853292799864, 0.04839420783539994, 0.15892725481564796, 0.07645174034584057, 0.07438782579211001, 0.11271960536326664, 0.12258169261769813, 0.07162817850025871, 0.07481014667103991, 0.1957829708687111, 0.26861657979707687, 0.3240368625404604, 0.21173103960888306, 0.21398705363201098, 0.30145217511286515, 0.21844976054095733, 0.1817476049423492, 0.18821677183767382, 0.679710993603668, 0.6066321664514976, 0.5965183999614267, 0.598656161466864, 0.6172716793666331, 0.6289435027739716, 0.6193562801750911, 0.6317958187102418, 0.62699669770488, 0.13273137556286396, 0.16980944339066695, 0.10180401899977021, 0.13379924994785708, 0.15133396830476709, 0.1513827018687387, 0.11054879025698394, 0.13857908762739501, 0.13665696087409362, 0.15256277427332043, 0.1852226949146678, 0.27666468546214806, 0.22711375411280932, 0.4371407160521795, 0.3034875202818774, 0.2397353347163702, 0.14430199391684095, 0.21217446683990226, 0.4166752165910951, 0.45110401759575813, 0.4000340890205877, 0.49939570638642294, 0.4066327529854824, 0.3745183121085969, 0.45976501219627486, 0.6464828984602644, 0.5026690263806479, 0.3018259549127813, 0.3892265385764615, 0.30646322327004605, 0.23014252299233628, 0.2565432338424548, 0.42895547062682204, 0.335212376767404, 0.29702476269203726, 0.29581940007653473, 0.24113793024143626, 0.19124029900397277, 0.19199827974944284, 0.21107852252771686, 0.2246516755711605, 0.20422418129140174, 0.20268395759165847, 0.2086297850908102, 0.2242116898164066, 0.2262458057512613, 0.6471019064923251, 0.24109481033895241, 0.19448215726605544, 0.7276511288284478, 0.2209310777150868, 0.18704957789806398, 0.2091066201437799, 0.6773460053859817, 0.9030751747342051, 0.18409308018417325, 0.15312522362489212, 0.8226805904912493, 0.2005977711951068, 0.8658802479819936, 0.12314307201226216, 0.16980705108060867, 0.8903469933843831, 0.1688198137691579, 0.16747171501961133, 0.8103112539825532, 0.8256566288828446, 0.7841289997161226, 0.21026365875838793, 0.10401123810793356, 0.20536082428793312, 0.7866074713594762, 0.206349738822875, 0.18466921621222343, 0.18091375525046238, 0.19228870375122242, 0.21753020361577668, 0.20299688673503558, 0.19654075402373627, 0.18934444439596176, 0.22660222292427512, 0.08979104790968628, 0.09308012590242465, 0.09041257948480885, 0.09239862247550112, 0.10472293385940523, 0.07698107495122386, 0.09608960722022308, 0.10306272910887981, 0.09419387299214033]}, "mutation_prompt": null}
{"id": "20b7d1a2-da60-4e49-afe3-24d53112d642", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "91396b50-feda-499f-b16c-653901eeadec", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f469af98-bff8-4485-a4d8-0c7d1fcbe064", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "5e3a8dd3-ea6a-4855-a780-5814834989d2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "49078b6c-d9fc-41a2-8dab-e44086f56b5a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f3ad6cac-834f-4054-89ca-70da0ccc7f9c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "41abeefd-2994-4c9c-bf40-33902865a3b5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "969a04d1-2a69-4433-bdcc-7d65cf19f1be", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "34264b7c-ba2e-45d2-b024-e8bbdef22d96", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "7ebda16f-cbc0-4095-9f0e-328ddcb797dc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "5ee01081-cab8-4193-95b3-2da7ed887e72", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "229d6369-e715-4a3f-9197-7606a72bd413", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "10eb63a9-75a4-4791-8bc3-3f95bd6b6779", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "290fa193-e0f9-4613-932c-da6049b0944a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f64dad93-fa5b-4a59-96a3-57e8e9a6dc9f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Adjusted population for improved diversity\n        self.inertia_weight = 0.6  # More agile swarm dynamics\n        self.c1_initial = 1.2\n        self.c2_initial = 1.7\n        self.c1_final = 0.7\n        self.c2_final = 2.2\n        self.mutation_factor = 0.9\n        self.recombination_rate = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            perturbation = np.random.normal(0, 0.1, (self.population_size, self.dim))\n            positions += velocities + perturbation  # Added perturbation for exploration\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerV2", "description": "Integration of novel random perturbation and parameter adaptation in swarm dynamics to enhance global search efficiency.", "configspace": "", "generation": 38, "fitness": 0.28517023156403415, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.5226328150370292, 0.5757630567408077, 0.6053677427245303, 0.5352553123501727, 0.5628106315826145, 0.5638805579808737, 0.5310001500959596, 0.5434840419599325, 0.5584881552836829, 0.26138979564689946, 0.21779417775102472, 0.19749200035909575, 0.23959165688208228, 0.23203790396355684, 0.27023289172818665, 0.21534045894596943, 0.22263164075601805, 0.26642419233423487, 0.14106635325660322, 0.14003766874691592, 0.1387581673394228, 0.12743804301325345, 0.12981369923662245, 0.1262582922652018, 0.13157606487116258, 0.12054406194234213, 0.14153557355501978, 0.1242115761261452, 0.11992544008331152, 0.12255164964943543, 0.10409423627225711, 0.11628854092278795, 0.10230958258627565, 0.12724135527182534, 0.0658566003341754, 0.10931785702267494, 0.9884833529670634, 0.9942648400542283, 0.9888594680273232, 0.9822332281970013, 0.9880385976645261, 0.9842858490424774, 0.9887148483993087, 0.9882473367904476, 0.9866686183542789, 0.3435571568885908, 0.34269430308328397, 0.35699482970952245, 0.3345392870606123, 0.36750539491564704, 0.3327169991618062, 0.3306936557824516, 0.3572463561110091, 0.3471598499251882, 0.48825502390989073, 0.6695998697279584, 0.6402246780646907, 0.5336034268435415, 0.6389866314894816, 0.66759872620985, 0.7171475630674295, 0.706966532194876, 0.5831249276951802, 0.25912923911156927, 0.23988819022899832, 0.24710027922066824, 0.26294381897067676, 0.26019780145819427, 0.12510962440696172, 0.24900990409960044, 0.19360911804289882, 0.26908899564097666, 0.2979863376067936, 0.16096695642866776, 0.2294670755299658, 0.17354166013558392, 0.22912189623871126, 0.1696150771093815, 0.27174024297847366, 0.20893488327991905, 0.24165141617800356, 0.14382512363855326, 0.1367856498377552, 0.1037390854810607, 0.140380434205981, 0.08063490985561383, 0.07533146954295733, 0.07613603409558967, 0.06363540528173217, 0.07326179890224316, 0.2176232722471948, 0.21886779584067761, 0.2484568459030947, 0.21754669188407705, 0.1353300815342815, 0.1819060002352315, 0.25465155631351377, 0.21944871377988817, 0.20150176388713825, 0.025023782212830747, 0.02777006247436098, 0.0248729192473649, 0.027730955957132042, 0.07097842027264101, 0.03201875313181057, 0.004370754613678418, 0.05663008131884928, 0.05017238850947758, 0.17267694215458596, 0.14245743384503462, 0.18408857275368307, 0.18487376783293252, 0.15503220059822487, 0.16379582908571433, 0.13872289482167421, 0.15706236037108123, 0.1795250177634038, 0.5082590597449645, 0.5288701003885043, 0.4943673702395984, 0.5023086318302503, 0.46631819649785433, 0.5375600895810577, 0.5037472134644564, 0.467047194588318, 0.5035329837632115, 0.13872743836596568, 0.11801516342399065, 0.11327938762217948, 0.10851873364127318, 0.14033559389039563, 0.1205158994278458, 0.13057478952991874, 0.11403684075207254, 0.12271873002608336, 0.3260474644608541, 0.22410699342814389, 0.3005117288560668, 0.25404048229614584, 0.3432595912780696, 0.19221781820473194, 0.3347589839832056, 0.3955264753407812, 0.17396784719139502, 0.32252941798295054, 0.3288829450980826, 0.31099502364248, 0.3123106777924821, 0.3038674637444828, 0.31650272956623904, 0.3136906063669347, 0.3270923743631995, 0.3381033723130049, 0.23780133177325447, 0.25607905285596133, 0.25990450376268825, 0.2523940035307761, 0.2536730120327083, 0.2588854567257912, 0.2507253263829301, 0.23235364398855984, 0.280240003273312, 0.19447678899046938, 0.19387409692621171, 0.21183325831309419, 0.21255004446853798, 0.20748237283522386, 0.20761141828409113, 0.20805258633325996, 0.19245376283281845, 0.2202200164116377, 0.2356812225628323, 0.24006397329703932, 0.2394082302347471, 0.33561162579231907, 0.24116108439769524, 0.34428680937667855, 0.23312527985135334, 0.22102449019363135, 0.20006232595759255, 0.19775028070266576, 0.16762638278229258, 0.15433262788649604, 0.8167940476386562, 0.8212598428760847, 0.19980706850255525, 0.09959267501093949, 0.17048945057885834, 0.21217180493832755, 0.15443505910495858, 0.15492421663863531, 0.648931593839098, 0.2062211287116179, 0.16875348365415688, 0.20983532718637588, 0.7190947465985433, 0.2120441335303891, 0.6924798252373346, 0.1845582426354525, 0.19202766304155428, 0.18678130245026925, 0.18910360650130698, 0.1773270347253667, 0.19356622180749528, 0.17703019786404528, 0.1799165755133847, 0.18969202233073845, 0.08949473435589039, 0.08321858018140937, 0.08482633284728658, 0.08531729676093114, 0.10054027945756028, 0.08872104786161294, 0.09164784786465574, 0.11129021269026851, 0.09216440739887655]}, "mutation_prompt": null}
{"id": "c5c5761d-8610-44f5-b4a8-d3781df8b31f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "bcd3e33d-0b0d-4458-b041-5b45835df97d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f881a9f6-eb3e-4043-9164-a6789c4d04bd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "2d68c145-54cd-408f-8be4-d23220536be5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "ace965ff-053c-41e6-9ffe-0d957aaa9e13", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "2068a627-5cd2-467f-b6e3-09e6ce13e06e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "b8cd8bab-ce23-4aef-a431-651310905843", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population for diversity\n        self.inertia_weight = 0.6  # Adjusted for better exploration-exploitation trade-off\n        self.c1_initial = 1.3  # Modified cognitive coefficient\n        self.c2_initial = 1.7  # Modified social coefficient\n        self.c1_final = 0.6\n        self.c2_final = 2.4\n        self.mutation_factor = 0.6  # Dynamic scaling\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Reduced initial velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - (evaluations / self.budget)**2)  # Quadratic decay\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                mutation_factor_dynamic = self.mutation_factor * (1 + np.sin(np.pi * evaluations / self.budget))  # Dynamic mutation\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + mutation_factor_dynamic * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerV2", "description": "An enhanced adaptive swarm optimizer utilizing a dynamic mutation strategy and velocity control for improved search efficiency.", "configspace": "", "generation": 45, "fitness": 0.3502516001831055, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8355979085376918, 0.8137307339490079, 0.8086582374613098, 0.8242038851343024, 0.8390682286735242, 0.8343284178046873, 0.8261564008196138, 0.8097063235845856, 0.8088675090042048, 0.639322430431138, 0.61445814926234, 0.6442775060186079, 0.6405367462162744, 0.04559671500780116, 0.5969537644838208, 0.6540285511356347, 0.6590092895547313, 0.6704021987325692, 0.1376911070617669, 0.5953449928733401, 0.16716095802454656, 0.6101120369632675, 0.15156900508773252, 0.16919348711419502, 0.15885829746614577, 0.15378428025737068, 0.1490453855861722, 0.15002859467113305, 0.15236678306906393, 0.13449834393267723, 0.1038738395424238, 0.15420559789599897, 0.15938889449262883, 0.17014308139820056, 0.11162088463823638, 0.14188164605268905, 0.9906070178040992, 0.9858234755510645, 0.9868709008180078, 0.9809453367679603, 0.978225983714548, 0.9802657633032632, 0.9822366170387961, 0.9829779777678098, 0.9861556367918584, 0.059891316977373044, 0.6139932561322274, 0.6481446785449778, 0.1504892368454721, 0.6715115590692577, 0.6326246006091163, 0.6632187857071177, 0.65181302789113, 0.08726341344427146, 0.5373702567054277, 0.7720564290249059, 0.7945306082237249, 0.8077122494480833, 0.6819752053279626, 0.21123509731444623, 0.7528984202683556, 0.8078771633451063, 0.717482021079701, 0.3544816884559395, 0.3401089380772091, 0.3158411084741727, 0.39562283178769353, 0.21012797989102194, 0.3297918953823067, 0.46143144675091385, 0.5126240400456779, 0.2640932206681583, 0.314194212175, 0.021831476804301975, 0.33472492861971403, 0.3768228082293851, 0.3721870959521931, 0.3897600638798463, 0.3097620499301541, 0.10208558863420636, 0.12714749516908708, 0.07951008451479336, 0.06576721514872719, 0.09337626842910463, 0.11100038257020328, 0.07143816834485328, 0.05138307331307046, 0.06803867732908497, 0.0776694536248711, 0.06828733022744837, 0.20162318908816224, 0.2267565296148435, 0.16269706993746258, 0.18242688971985377, 0.1501545874684489, 0.1530717689038582, 0.25935207686252915, 0.22285933695265103, 0.21006971320978685, 0.08394823892078096, 0.0333683137998656, 0.2988764669798979, 0.07269934110117315, 0.11236684391776508, 0.11755373840558991, 0.09607035337795355, 0.14569607007216978, 0.06685428970214524, 0.20295059094282408, 0.23191576202182063, 0.21988290781326958, 0.14336964443004485, 0.2770989103096385, 0.21525863688088798, 0.16978372655415663, 0.18055667181444301, 0.21974156777742204, 0.5634938762439003, 0.5961887263606696, 0.5816192606628121, 0.6060994114580318, 0.5716861173485305, 0.5650416317834674, 0.574098879983193, 0.581454837049999, 0.6236068902593253, 0.12011325811955498, 0.1245692340988237, 0.13855339761266028, 0.170479694792543, 0.10419240870379165, 0.12706763499079465, 0.14891753908428196, 0.10990858525441294, 0.1254759465804698, 0.23692321624111734, 0.22935958883869567, 0.17353907008000302, 0.45189188503670896, 0.23970797574381075, 0.1439164385444145, 0.19968557862509784, 0.2719780463435606, 0.30482728561430383, 0.4812378281548204, 0.38381462210752815, 0.44405452818821967, 0.32284056308127207, 0.2522274832874176, 0.4035824062291816, 0.4307809151046288, 0.525965548115441, 0.609719606785134, 0.25803841941778505, 0.3537054710100528, 0.30467960051282006, 0.38047908715294243, 0.19428625203344352, 0.3568932069250854, 0.32917828486910117, 0.4110147203543184, 0.3234162969668103, 0.20283441953327896, 0.16952366160931742, 0.21581428878681275, 0.1902450374582686, 0.20141553317676786, 0.1957004720520421, 0.24771079782837246, 0.21480639043232663, 0.21058640555156094, 0.22159854179493088, 0.22144024008537377, 0.22115193115848286, 0.22747246762473028, 0.24123777243211364, 0.2073598089577834, 0.24494024309533424, 0.1965392557946687, 0.23486881145147986, 0.16494015722410582, 0.17566804914508594, 0.154095548427032, 0.8887299159391728, 0.20085342345725155, 0.19974179739859077, 0.1309258432644751, 0.1699202989540376, 0.8532377961417256, 0.8033608203308062, 0.1563485510039172, 0.7389426644968515, 0.20692126560657476, 0.7999671446839463, 0.8111356130010002, 0.1049800148540706, 0.20103532431135818, 0.7960724756026079, 0.18840109871861266, 0.20238096502400116, 0.19429900778930798, 0.18749667127396819, 0.20042342986600958, 0.19080790736808417, 0.1990975786446183, 0.19998325918101012, 0.19015451014855278, 0.0940048841686505, 0.09647236486988697, 0.09645682332698458, 0.09502360721360914, 0.10232820374891505, 0.09446226535246838, 0.13370194182582906, 0.0850666775829646, 0.10337139856601352]}, "mutation_prompt": null}
{"id": "ea567308-d707-4b33-9f3d-abc5f7395bb2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "2f634040-d096-4778-a0b4-9a181c0672d2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "9f20a1dd-39af-4530-a1cd-82be9d0d1e2a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.8\n        self.c1_initial = 1.2\n        self.c2_initial = 2.0\n        self.c1_final = 0.4\n        self.c2_final = 2.5\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.9\n        self.recombination_rate = 0.85\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            escape_velocity = np.random.normal(0, 0.1, (self.population_size, self.dim))\n            positions += velocities + escape_velocity\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerV2", "description": "A refined hybrid swarm optimizer using dynamic escape velocity and adaptive mutation to enhance convergence efficiency.", "configspace": "", "generation": 48, "fitness": 0.28902588183330236, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.5618068481377567, 0.514853989628092, 0.529950264108981, 0.5379706061289083, 0.5821061095025739, 0.5458469034981326, 0.5299334189802729, 0.5200281744452879, 0.5394246317650846, 0.2601211307242477, 0.27825879177194845, 0.2521019686230055, 0.24767509406794697, 0.24080363012482153, 0.23783776944931856, 0.24806742317969765, 0.22999911118286454, 0.26162773989279553, 0.15645252849442481, 0.11436153023998796, 0.11726135061562037, 0.14148386138049462, 0.1282329454124327, 0.12579805658679633, 0.12306037300877293, 0.06747740357947674, 0.12701242309338545, 0.10111166419399653, 0.10059778915555384, 0.10623114910719744, 0.11554979360684536, 0.12320249185336885, 0.09791338038028274, 0.11972989725918892, 0.10704861996363402, 0.10061743512070576, 0.9931004242499664, 0.9869991836835802, 0.9943337962981391, 0.9881477433692232, 0.9889387315101084, 0.9907400761288135, 0.9888718427723621, 0.9896698010174774, 0.9906040377448714, 0.31574529927691786, 0.32640104319835994, 0.35285516807801054, 0.33275993350016386, 0.32089777110183637, 0.3391839604696769, 0.3252823253025573, 0.31970764128663276, 0.30877727759404483, 0.6924158741187894, 0.6000770938953466, 0.6529692921199921, 0.5705201817753788, 0.4551225452659464, 0.6540942834278634, 0.5974528751976997, 0.6288497558141103, 0.5909258130264311, 0.23788846435548205, 0.2273251073376673, 0.2163945490910284, 0.28148671858311647, 0.22202053160899915, 0.23514116238751337, 0.26747697552440963, 0.20224180695914373, 0.2574192495412101, 0.24828995458845637, 0.1352671502159657, 0.21160432681991315, 0.20573445195474627, 0.2195126999953072, 0.23052880426132027, 0.22034840445048054, 0.20973307714917733, 0.211939362002453, 0.16270464883205693, 0.10194086378232114, 0.13619292910010883, 0.01883583127717503, 0.08433117997311224, 0.10672741141198405, 0.14116741302343494, 0.1371586052803807, 0.09377473558500149, 0.2510116217461632, 0.22425519749295642, 0.28094686181465645, 0.27908987609064473, 0.23745350189236247, 0.2390875798591462, 0.259917835522403, 0.32544295782192423, 0.31454386562897063, 0.028547787226684163, 0.043541094781324174, 0.03188169403766328, 0.05684323107451761, 0.030403825700097475, 0.06280596020696616, 0.0433495932480249, 0.02028533306730007, 0.022633072538521648, 0.14622083037241407, 0.17367351740629533, 0.14832986179417562, 0.16845149170170204, 0.16666977209173417, 0.15840871094989273, 0.12926828298965443, 0.14897160616600535, 0.14770200185634386, 0.5231708665082963, 0.4687305030384229, 0.4927060681907859, 0.5241499936771877, 0.49030978039602524, 0.5017370886635588, 0.4920897151501388, 0.49573288798280224, 0.4646290461076217, 0.11799866084191057, 0.11177535291959084, 0.10557420937392814, 0.11124338753719243, 0.11652084679407271, 0.10495360350704375, 0.1071703011261872, 0.11989408972893922, 0.10921517199988562, 0.2125995749032309, 0.1725170873247609, 0.2478460707479999, 0.2924691142219009, 0.3189384756427901, 0.37082623473244447, 0.25419024014126923, 0.32472811958892855, 0.27114082829312736, 0.29946004888747013, 0.3130929067404925, 0.2856221819511242, 0.2969079367198486, 0.3012542056458627, 0.3109491340162456, 0.29247016726863106, 0.31120152959007485, 0.25947148780568885, 0.25133918478055517, 0.22342207454025242, 0.16773399132677136, 0.2427985220245179, 0.1929725002433259, 0.22743582284541863, 0.2614095245039495, 0.25891698521136375, 0.242929285658657, 0.21561144663345122, 0.18861149438828528, 0.20471302193424512, 0.1991120944906717, 0.21351034799506308, 0.2000587753090428, 0.20742219460074507, 0.19880639973552972, 0.19866543444229423, 0.2147882093458522, 0.29357673946432084, 0.31784839418073296, 0.22997447870238596, 0.19089322399035602, 0.2750427480653531, 0.30586799932789643, 0.23585981184679772, 0.20440124740255095, 0.7960027477779159, 0.7277321604184344, 0.1539918908947211, 0.735466784389388, 0.7651425308278623, 0.19794850336729952, 0.0999648362003569, 0.7556943132484804, 0.6960469346498686, 0.6493587535079908, 0.20573964534257494, 0.12565024360817245, 0.20576326360994412, 0.1682787708161252, 0.2121637537021417, 0.12623669335477228, 0.2110766001756068, 0.6878923269182438, 0.1896563017675389, 0.18921998579875976, 0.2567581694683241, 0.17418041531728412, 0.19103085190014213, 0.1898102253605104, 0.18901427730987086, 0.20206884081955923, 0.18230627074649575, 0.08296039178855896, 0.08718271115022302, 0.08485856401247183, 0.08254434461801685, 0.07942316140170169, 0.08523430016392564, 0.0779811706823631, 0.08445775709672365, 0.07381966336636092]}, "mutation_prompt": null}
{"id": "01897d4b-84c8-46b8-a969-d97beef8a9c8", "solution": "import numpy as np\n\nclass AdaptiveCooperativeSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.6  # Adjusted for better exploration\n        self.c1 = 1.7  # Unified cognitive parameter\n        self.c2 = 1.7  # Unified social parameter\n        self.mutation_factor = 0.9  # Increased for diverse exploration\n        self.recombination_rate = 0.85  # Adjusted for exploration-exploitation balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Refined velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia_weight * velocities\n                          + self.c1 * r1 * (personal_best_positions - positions)\n                          + self.c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = indices\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "AdaptiveCooperativeSwarmOptimizer", "description": "Adaptive Cooperative Swarm Optimizer with refined velocity update and dynamic mutation for enhanced convergence.", "configspace": "", "generation": 49, "fitness": 0.35469265103182923, "feedback": "The algorithm AdaptiveCooperativeSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8421536092481289, 0.8317825808960313, 0.8298560823333712, 0.8407913989068719, 0.8642803220594568, 0.8324078791143604, 0.8575733504766063, 0.8374040384265407, 0.8409517872734008, 0.6656257938103856, 9.999999999998899e-05, 0.6792676985480569, 0.6732168823923327, 0.5581460403930781, 0.6907473212182698, 0.6400065414706275, 0.6777578786874157, 0.6991530731773712, 0.15093639206798581, 0.1779326427639396, 0.14953251674823442, 0.3575931236951264, 0.17161864640877722, 0.14108453677545785, 0.5417036154485901, 0.05756553888359395, 0.6479429748774701, 0.11537935163635737, 0.12463239827991524, 0.14708471103627052, 0.15363442182641662, 0.16134599696349428, 0.15008822917061193, 0.2517852027964217, 0.1518221824381757, 0.10806851783627203, 0.9908634659947969, 0.9872458451016379, 0.9870568795759797, 0.9877869712503197, 0.9875423728230083, 0.9869375479940726, 0.9905268891708601, 0.9872006657092267, 0.9890577584420147, 0.621201275516775, 0.059730668821735944, 0.6018556209505315, 0.5869081545351896, 0.6466262774618624, 0.625767318890367, 0.08897007793293765, 0.0886540299987324, 0.6252259763799406, 0.7917023754455599, 0.8167166348338206, 0.7731227400244403, 0.275215302938448, 0.730305108025864, 0.19327212662423343, 0.797428138866877, 0.4135738041952547, 0.7580696395424797, 0.3428093324562246, 0.24585329920611199, 0.35656991902845525, 0.34664867685655965, 0.33123065451918754, 0.3077980817418755, 0.3159358431600008, 0.36286483502250444, 0.3642534872144281, 0.35429913100126564, 0.05384095164253899, 0.33538985155301104, 0.4003994607820619, 0.35810743073747175, 0.34190364542863294, 0.13082881278506442, 0.03380138437642022, 0.30023374996048047, 0.13329311837240898, 0.04843424034357846, 0.1028565397843384, 0.14734642997820757, 0.1394089416656934, 0.04877805904693089, 0.14599967752116916, 0.08261204490119001, 0.13782678764658662, 0.25533901585883, 0.2579273714057072, 0.27430749044263625, 0.2210158993216662, 0.26311430346343945, 0.1902316787084326, 0.2541416436324002, 0.24934759258816364, 0.25691972317977774, 0.0458726626422058, 0.15619446840224027, 9.999999999998899e-05, 0.0887064160196902, 0.0746931331163827, 0.27131661392832584, 0.10661699001714353, 0.03282001750337005, 0.09872039544401323, 0.18291907981014732, 0.19281537790860692, 0.2520571064017403, 0.006758678539293794, 0.2619623924677892, 0.20752257462157941, 0.24422071681085245, 0.1903834726248027, 0.0806308493694059, 0.6523820719563245, 0.5741400973136082, 0.573530939641432, 0.587838017734607, 0.5612942905397706, 0.6461262237202785, 0.6311903939511079, 0.6043689194124648, 0.6376555343868093, 0.11124115139216051, 0.1701534946437132, 0.13964772392182034, 0.14988746537452624, 0.14611114141800885, 0.11827564573602845, 0.11601363949601495, 0.13678294000695623, 0.1307494328220573, 0.14625040046730287, 0.2043980832185477, 0.16799609690841588, 0.2528165732332224, 0.34824834377720104, 0.26815666040687947, 0.19454280442749794, 0.18186088558107472, 0.2661834705109791, 0.44271061981285387, 0.49198592161685406, 0.35941120487410516, 0.47833337848732416, 0.4305447880510894, 0.45244358619450564, 0.5074455813805184, 0.5320219024103056, 0.5223126149710111, 0.3334906555774345, 0.2660277606568059, 0.27349414425134977, 0.3322428139855711, 0.31875544861479255, 0.28436310624872163, 0.39366806006551847, 0.3715501954623729, 0.37108421236364797, 0.20268220218283284, 0.20044022988474441, 0.18881366624432927, 0.20057091477503552, 0.2009018685981585, 0.190838358749172, 0.22549382172469856, 0.20576061747673324, 0.20763377417260764, 0.24148003738726675, 0.24122921798707686, 0.22720202078198914, 0.22537370312000304, 0.20783603202151735, 0.5808598594171042, 0.21567265962680293, 0.19811352169902186, 0.20157425040102384, 0.16401928915596253, 0.8661342043561178, 0.12433652214230295, 0.8898093434584124, 0.18642995031128828, 0.1677271371148652, 0.09994564605964174, 0.16966266851464828, 0.1646178183981094, 0.8400785478519227, 0.21152534380578414, 0.6503427525753811, 0.790316169362698, 0.7893900530841998, 0.2105645103395477, 0.7565885406760339, 0.7020396849211312, 0.15550866479196124, 0.18278772888898565, 0.19020678660970303, 0.1891744676820174, 0.21452667399153713, 0.21922592978729882, 0.19010566248428162, 0.1964824000851506, 0.24677819797679357, 0.19193075625479827, 0.08363011227463191, 0.07966082326364665, 0.08516630464632102, 0.0891611682243365, 0.099253699171171, 0.0901721839801034, 0.0994321608534805, 0.09198610637131477, 0.09717242404240511]}, "mutation_prompt": null}
{"id": "004bd48b-40b6-4ef8-949e-c556ed57ab2a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "63a7d1a8-b8e0-430e-b651-1734784db4dc", "solution": "import numpy as np\n\nclass ImprovedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.6\n        self.c1_initial = 1.2\n        self.c2_initial = 1.8\n        self.c1_final = 0.4\n        self.c2_final = 2.2\n        self.mutation_factor = 0.7\n        self.recombination_rate = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "ImprovedAdaptiveSwarmOptimizer", "description": "An improved adaptive swarm optimizer with enhanced update rules and streamlined logic for faster convergence.", "configspace": "", "generation": 51, "fitness": 0.3815310551278003, "feedback": "The algorithm ImprovedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8927203439389838, 0.8798275945312709, 0.8926441653565094, 0.8706516598716459, 0.8928194879559408, 0.8913489749429675, 0.8863876676829425, 0.8817443242326106, 0.8995987849959165, 0.7772504316574338, 0.7949422421205665, 0.7713727115410186, 0.7381550335585709, 0.7780645791095944, 0.06703543731484674, 0.7844990470392385, 0.7808198507158756, 0.7976207314179944, 0.18264584710728382, 0.14127583820982526, 0.12431951777193351, 0.13928510277515038, 0.15719672760924164, 0.15490703670619, 0.10556592690030864, 0.14736980969747404, 0.14658228845565913, 0.18274009648918332, 0.12973795327053272, 0.15650075154264798, 0.11195720619569871, 0.09484824931714175, 0.10682920870429335, 0.10991440266015884, 0.12335868684318685, 0.11489715518622923, 0.9908772299219698, 0.983363846888177, 0.993966421553744, 0.9888009244172549, 0.9907434636733593, 0.9872255124113734, 0.9862503789785154, 0.9881100935849322, 0.9867847714061414, 0.778666609941753, 0.7866097864876779, 0.19417550295036767, 0.7926699456277484, 0.15099288109362874, 0.15305276356660547, 0.7851797903623167, 0.08927438942270838, 9.999999999998899e-05, 0.8888535940432987, 0.16891686804623673, 0.8443602795429223, 0.27689696947399867, 0.19440810353007965, 0.7795972045309922, 0.8484803189959251, 0.12672981309047848, 0.8605148489614529, 0.5450125874975205, 0.41272350859725027, 0.538409538103761, 0.45601237145273776, 0.41785198426358816, 0.5213135477411741, 0.5532052468365587, 0.4252713385330822, 0.5027945023236776, 0.3148640949496939, 0.022434943156295795, 0.4072911536359889, 0.5022592339008229, 0.13306482297724165, 0.6229208939788375, 0.44895262408770054, 0.6193489265802223, 0.4974588886728135, 9.999999999998899e-05, 0.3270272687258473, 0.2843651715041057, 0.029495428325761575, 0.3166963751493952, 0.2638459937584908, 0.3785591116560808, 0.2637856764883466, 0.2820617652816829, 0.4296702559026254, 0.3554006443141732, 0.36025791598452417, 0.36820772410145286, 0.4055011031876875, 0.332978925112973, 0.4896688441176553, 0.44576392067212567, 0.46870543579288493, 0.04226196237087243, 0.12762758870729773, 0.05057460652034096, 0.08144001563446523, 0.1623513009521128, 0.18192819973078977, 0.10968042890205965, 0.09897704743561186, 0.0777496674572834, 0.19574675336260594, 0.2991384355618707, 0.30092324759978073, 9.999999999998899e-05, 0.31841947933208703, 0.3801007165379814, 0.25581166947944134, 0.2954193423443665, 0.08409735015586106, 0.7227178078724863, 0.7054167827571125, 0.6841442449892364, 0.7438430499682445, 0.7288246774061724, 0.7052009649537074, 0.7324338915492001, 0.6893446975224966, 0.7829243005677777, 0.07103818273899543, 0.0749797216414867, 0.1041605595642302, 0.12880806815845625, 0.12151754423754102, 0.1303723021987958, 0.0826436741855967, 0.15338782015793817, 0.11265584648714777, 0.1787983938859543, 0.7452779592321017, 0.1676092654292981, 0.36958298414762725, 0.42578695934636834, 0.2788358191781839, 0.21310267298885333, 0.3203181815665571, 0.2510676401785532, 0.42277524002893785, 0.46943923314239, 0.564877485845675, 0.7475744166352754, 0.7769435683100036, 0.598307851605823, 0.5030891706947447, 0.6425793998425968, 0.6358175843750681, 0.42530157958233417, 0.45875289735450286, 0.2073795079487557, 0.2679883440507842, 0.3264951323363764, 0.1877922989033698, 0.406830361789858, 0.46777022794997625, 0.3726432817050006, 0.23508793191452892, 0.2142055627912126, 0.20750553817270045, 0.22826622341615077, 0.24187103626845297, 0.25988673716699007, 0.21213251475012518, 0.22763203361255713, 0.24478456651355995, 0.19559509034053013, 0.21999017791649622, 0.22310561697947695, 0.21358357058399802, 0.7240600902141484, 0.22955312561840224, 0.18541490406990413, 0.22138325159728756, 0.19793826578605744, 0.2668602699097836, 0.18761913033422184, 0.1246102754478412, 0.16846031042083487, 0.20066222174840942, 0.9026068624469951, 0.10006945313032412, 0.1696301017843942, 0.17804049210240103, 0.08292314119841482, 0.16908310663067028, 0.8838084138543837, 0.8403217876719644, 0.16940117616397588, 0.2129963829471182, 0.20230890834916737, 0.12727296249414144, 0.20158560844578333, 0.18955432242275505, 0.1970495029328171, 0.2278725345027517, 0.19335919532968793, 0.20459455297391982, 0.18375150277641772, 0.20306414104839776, 0.18760520699619598, 0.24435596297284756, 0.08857533874184609, 0.08394936816383525, 0.10105837126317418, 0.08838796766324575, 0.10774841917253142, 0.10555076637797844, 0.08967742924240352, 0.11749919389268748, 0.09097892794704365]}, "mutation_prompt": null}
{"id": "4a214f4b-e3a0-4921-bde4-fca0ab826121", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "241dfbcf-5d35-48dd-8bf0-4fb7093c741a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "6e2ee95d-d224-4837-bca0-660ec8eed693", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "d00b9d70-91f1-4aa9-92c9-6c7d248cf693", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "1c5a0607-e31c-43e9-bb99-af2f22421103", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor_initial = 0.5\n        self.mutation_factor_final = 0.9\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = (self.inertia_weight_max - (evaluations / self.budget) \n                              * (self.inertia_weight_max - self.inertia_weight_min))\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            mutation_factor = (self.mutation_factor_initial \n                               + (self.mutation_factor_final - self.mutation_factor_initial) * (evaluations / self.budget))\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A modified swarm optimizer with dynamic inertia and adaptive mutation strategy for enhanced search capabilities.", "configspace": "", "generation": 56, "fitness": 0.36480798003826415, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.814037509653474, 0.7822036648350397, 0.7800692308334465, 0.7916906875418008, 0.18256881053559348, 0.7942174696499049, 0.7764297320958016, 0.8040002370675761, 0.7669908411590499, 0.6408519857192273, 0.6045317689774956, 0.6354889577877443, 0.6150980829684883, 0.5895564119573068, 0.599644599117392, 0.6244395845450784, 0.6273908774513386, 0.610777271520035, 0.15443510792417037, 0.15289785093541797, 0.15733149255997692, 0.4746817556168832, 0.4289284128247157, 0.11974177675221764, 0.12518590154097942, 0.14241488181587536, 0.1460763753504596, 0.11301564314871049, 0.1211000962153026, 0.11587350725949452, 0.12262189727794703, 0.13537508202014703, 0.13922353450785818, 0.1339404466554719, 0.11495609175329013, 0.1314422681509686, 0.9900271985492947, 0.9874559961211725, 0.9905682731621439, 0.9801855943944053, 0.9880782219657739, 0.9905696179553616, 0.9908975355645852, 0.9903844547966687, 0.9875086842248223, 0.6096977217868216, 0.5427634903752325, 0.5894378110678954, 0.622165017160971, 0.5989567340618003, 0.5895535667667631, 0.61029239653771, 0.0883576533251007, 0.5889935671749551, 0.7895425320667842, 0.7603610840679793, 0.7705617476439361, 0.27220878015221395, 0.8507343927550367, 0.8347474113048976, 0.6696206447241589, 0.8156774746601481, 0.3661912882056332, 0.4658830369515886, 0.33850299077350243, 0.3294243096356695, 0.35788614913159733, 0.4749538282360046, 0.3503320304402785, 0.4460936110227691, 0.3402223063242583, 0.369956853914854, 0.4882203644748411, 0.022164879989503006, 0.46510580884560426, 0.3563509768739004, 0.3292582550708507, 0.35281056119523224, 0.3744927104646194, 0.21491011226596934, 0.3640619772069127, 0.10082476509093774, 0.0626957958412575, 0.4191100702864322, 0.029614023680351265, 0.4510126272700461, 0.2843767142408298, 0.16771333347382678, 0.41290236096989597, 0.14994967073167842, 0.23421339830257848, 0.17805533239445182, 0.28995186244556925, 0.6075215570846068, 0.07459799343859796, 0.12828826049377917, 0.6525991162824192, 0.45149007051169965, 0.16313095123129462, 0.04395517526013859, 0.21809065336917688, 0.13685351711923655, 0.15540157204567917, 0.15108097060083925, 0.2726512411638077, 0.2512329769225353, 0.11372863662218202, 0.10335754560942312, 0.2954632083142732, 0.04190447013120557, 0.26264572030347966, 0.32527231847172833, 0.22132800510654638, 0.36498312173736613, 0.2942811988858667, 0.15979600252583515, 0.08075636773517403, 0.664585989110551, 0.739647752223219, 0.6885697598666447, 0.7363746215396028, 0.6416493815971682, 0.624058234506775, 0.6922639003963992, 0.6266123549393663, 0.6423779436455281, 0.13334980989284118, 0.1350141281215419, 0.06122562203430748, 0.12666874429323904, 0.08397303840700931, 0.10479164655916806, 0.1266016404242215, 0.14153986265507668, 0.1201154437054398, 0.17902155334866943, 0.18790192404669614, 0.18717421511336674, 0.4285233337571043, 0.21473263767321382, 0.25725332365646625, 0.22830174200586684, 0.1937970524814968, 0.36620429125280074, 0.5160122481840894, 0.48343746418526024, 0.4579604645103661, 0.47278729868751845, 0.4918158526040026, 0.4464113715621033, 0.5025960281655837, 0.5368149662200787, 0.4742668441067732, 0.34956678224678006, 0.3669726293778445, 0.3202894537964659, 0.26249245334700266, 0.34931151581246966, 0.23444940742391085, 0.39167435593954325, 0.4163183138337505, 0.21045091352298373, 0.23150773215228082, 0.22857534777302624, 0.19857531923278227, 0.2067910572708055, 0.20872711570643854, 0.20726475972025182, 0.2246971971590681, 0.21067144346300937, 0.19460721845451168, 0.19376360904073087, 0.20594984904899682, 0.22896110058646768, 0.21045268793377347, 0.1910766308474533, 0.2275284861788428, 0.19128703059229646, 0.19955492703307054, 0.19643241271405143, 0.16739437416800684, 0.1651282033113568, 0.12434773732985471, 0.871280075669316, 0.20079984043680288, 0.19922126845671806, 0.09934412245121349, 0.16999052025973338, 0.19663872024373108, 0.7534281533428956, 0.16963152857220376, 0.12639895256163491, 0.20785989950993955, 0.1678407213843759, 0.7641724246431442, 0.21252680658506218, 0.7003846720789711, 0.7113089528912743, 0.2170194089418207, 0.2167592264723035, 0.22253411517662836, 0.20852008720922266, 0.2138787238906814, 0.20950745664573955, 0.1935534578415422, 0.1797874995112243, 0.19717465855092897, 0.09019808642084914, 0.0908894385557022, 0.08887416856568708, 0.08671963526388549, 0.08890639159335711, 0.11681688072635277, 0.094647597801653, 0.08009423625867407, 0.09633330444375099]}, "mutation_prompt": null}
{"id": "2a3085b7-e656-4cb7-8d37-264fb8f12526", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "630e8dc9-a8c3-49bb-ab47-29dd9990e6f6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "b0646d76-f323-4fcd-bdc3-e72e81b84096", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "b4b0e6b5-8640-4189-927c-1cf91d194db8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "d78f61b5-67d0-4d31-baba-7a193fdf4bc8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "0177a2fe-c4fe-4be6-8f6c-c5e28361d917", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "7753ae95-c7cd-4ead-a02b-61f9739bd18e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "c75a2888-aa60-4ac2-aec4-a87e4265bee2", "solution": "import numpy as np\n\nclass RefinedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.c1 = 1.5\n        self.c2 = 2.0\n        self.mutation_factor = 0.85\n        self.recombination_rate = 0.95\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight_initial - (self.inertia_weight_initial - self.inertia_weight_final) * (evaluations / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + self.c1 * r1 * (personal_best_positions - positions)\n                          + self.c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    neighbors = np.random.choice(range(self.population_size), 3, replace=False)\n                    a, b, c = neighbors\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "RefinedAdaptiveSwarmOptimizer", "description": "A refined hybrid swarm optimizer with dynamic inertia, adaptive neighborhood search, and enhanced mutation for efficient convergence.", "configspace": "", "generation": 64, "fitness": 0.30158136416655484, "feedback": "The algorithm RefinedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.6205435162339297, 0.5990699022954014, 0.5939524032687888, 0.6480846454053188, 0.6461197831811814, 0.6320971002859775, 0.6229829816283496, 0.608676612529468, 0.6335398714911535, 0.4068700612256997, 0.3824284779103979, 0.3853267177624784, 0.38125731798602946, 0.3830965877865399, 0.34758884424269554, 0.3752300147680867, 0.4130288291701306, 0.3885764268066879, 0.10350579018054884, 0.17490485856677718, 0.1972377109666661, 0.2849330720478873, 0.14389430306198192, 0.11219761300996922, 0.10301992623929035, 0.11681314846014834, 0.1262706141550488, 0.1144590444621546, 0.09544763355304331, 0.11017710221631094, 0.11277997371343518, 0.10286730040444658, 0.10126737319027723, 0.09793287279376328, 0.11372213043090273, 0.10911967621003371, 0.9930736360501708, 0.9910015550033029, 0.9929245988037239, 0.98868407700725, 0.9857918033108922, 0.9881631388466723, 0.9912437256848503, 0.9926990285314263, 0.988700779587899, 0.4208829876377438, 0.35716713680528334, 0.3928440168484568, 0.1449325726680929, 0.37431623778976053, 0.4054405246757137, 0.3904683896930957, 0.3676485507075833, 0.051207038276920525, 0.5276036512073647, 0.5466124787795719, 0.5783294884145613, 0.6558431634616411, 0.19871846253919478, 0.708130874208476, 0.5943293630392525, 0.6499493430001075, 0.5885811684119073, 0.23386573184842074, 0.31018452230028737, 0.2045464557181268, 0.17876496692791444, 0.11944182541390458, 9.999999999998899e-05, 0.2051395475872495, 0.21902361621302757, 0.22733621005125992, 0.2443367632312361, 0.010138702982463887, 0.20358377830260233, 0.22416384327090477, 0.2110311066162629, 0.2586597369520566, 0.2663175610009809, 0.2461381687952453, 0.2105542588667486, 0.2083813178950421, 0.19065655000603177, 0.18095925958721104, 0.20955640450675117, 0.21113855347354304, 0.016539668302047894, 0.18555482408340296, 0.18525535518506342, 0.19933369893001096, 0.3293098686728392, 0.3245814953748941, 0.3138325127280174, 0.3482278059966829, 0.3044452281127623, 0.3058385200862914, 0.3495993633750669, 0.3492511660650697, 0.3374200529262703, 0.030173510985282648, 0.030011081474358603, 0.031062692627981447, 0.05535048869906134, 0.04791363297258522, 0.04580070587687202, 0.035523168039397035, 0.11142312293185097, 0.04198986132374283, 0.16453949435423, 0.17138505128837989, 0.16558031041241306, 0.17030751759954632, 0.1808917893289056, 0.18587917509552399, 0.18255140729795694, 0.1847023287349432, 0.16844835390807367, 0.5116825813536661, 0.49900709095862417, 0.5029438720966939, 0.4839003686034644, 0.49608517451701173, 0.4694241468868695, 0.45699833130587975, 0.46679904351761725, 0.4891193970315627, 0.11426192267424973, 0.09894009670189408, 0.11023024229930456, 0.10804031953427862, 0.09454092984326157, 0.09154565514599544, 0.10936180035588983, 0.10255852373089891, 0.13237596093987214, 0.23841049068560738, 0.14020367819878243, 0.208916340993075, 0.2150962151555751, 0.18157042441616, 0.17537926963983952, 0.17962774396434766, 0.4512418331567072, 0.20085767350757855, 0.32778778565904154, 0.3148636124466895, 0.3192481467003774, 0.3179356686935212, 0.29335239229862964, 0.3118544207793782, 0.3321997163899235, 0.359885577172937, 0.342113638112295, 0.223909706247993, 0.2518115514560434, 0.21302767553191504, 0.21344593714808724, 0.20120566782990013, 0.2365383401095491, 0.2698485114594046, 0.2780439529377682, 0.28009881567483197, 0.21208300780212574, 0.18720210490475697, 0.20040888444439864, 0.19445319856257048, 0.17969785164696583, 0.1864581766842589, 0.19385387499747675, 0.2539787508457765, 0.19484978464350633, 0.2016301447319241, 0.19522351389239845, 0.3002358907661238, 0.3179127607557476, 0.3234600447174871, 0.31835666320515843, 0.20508288854392054, 0.18896146863190144, 0.3994733867535548, 0.6965605025528427, 0.6902285032293622, 0.15424699245460127, 0.6490581111005875, 0.6983177773753708, 0.19070934671050876, 0.1678984708447233, 0.17648301758631368, 0.6949228755556507, 0.6567529125650761, 0.15588005857175047, 0.5706564127685682, 0.641664124547821, 0.16207938150736767, 0.7187813410994626, 0.21067659984733378, 0.19591346308330126, 0.1971059709418712, 0.19461590276218532, 0.19314408904127134, 0.18367825090265788, 0.20439473079147663, 0.18458969094326116, 0.2011989042298018, 0.19957727772104195, 0.203399438059075, 0.19276586109574323, 0.08434535786782982, 0.0814105979840577, 0.07019409439364299, 0.08431336093133557, 0.08620994760295364, 0.07417277969235492, 0.07255527406896367, 0.0750322695329464, 0.07737816665097763]}, "mutation_prompt": null}
{"id": "1aa68eec-909f-4ea6-bd6b-54a401f3ffe9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "91e6f815-3903-4387-8392-e2222abdaf86", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "978feb69-a4e4-4be2-a487-78cb6d843abe", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "06cb29a8-5722-447a-af35-7d1d0f6de5dd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "ee088786-56d5-453c-9623-5ce274e20170", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "638c115c-f5e0-47e7-9af7-1462dc146ec4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "ac47d0b6-f6b1-4bd3-b5c7-2427a8a96a7c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "a6b7fa9a-c752-45ca-81af-12a37a2001cd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "a7226e28-dd52-419b-81a9-a005ac126a26", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "9e6effc8-a90d-4f7d-b0a2-facebb66cdb4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "3926f825-1082-4b3b-b686-7131d4e088b1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f0f9e0e1-b40e-456d-b243-79ffcef490a7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population for more diversity\n        self.inertia_weight = 0.9  # Adjusted inertia weight for better exploration\n        self.c1_initial = 1.4\n        self.c2_initial = 1.6\n        self.c1_final = 0.6\n        self.c2_final = 1.9\n        self.mutation_factor = 0.85  # Changed mutation factor for variation\n        self.recombination_rate = 0.8  # Lower recombination for focused crossover\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / (2 * self.budget))\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerV2", "description": "EnhancedAdaptiveSwarmOptimizerV2: Introduces self-adaptive parameters and dynamic population control for more efficient exploration and exploitation balance.", "configspace": "", "generation": 76, "fitness": 0.2810598217465176, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.6173878453389408, 0.6102168586517631, 0.6060678895282448, 0.6346603250187035, 0.6521544152178833, 0.6296347105200645, 0.6296682765824242, 0.6259538555261478, 0.6467616740224433, 0.3633903662967012, 0.3452594841274539, 0.3767901772879655, 0.38477514108705024, 0.312772373630407, 0.3518076014902627, 0.3549145121827514, 0.36490124389499623, 0.36244015991021816, 0.14973636965346415, 0.29441452872253604, 0.14319148268970916, 0.13084133753489036, 0.1367278524025458, 0.11328068373031308, 0.15683653325706404, 0.11944174570503707, 0.12011965248867496, 0.09859153079916227, 0.09664105486521224, 0.10397429263630298, 0.11457595337734061, 0.11071932657520156, 0.11408137608570601, 0.11201418756732107, 0.11882229589536242, 0.10674881030055527, 0.9904732420131768, 0.9867588294544225, 0.9868149208764764, 0.9858338415045186, 0.9823878105049673, 0.9819904917818255, 0.9860940029229941, 0.9857447578147738, 0.9861632400592699, 0.36257828417546534, 0.4071199299719821, 0.41422582683276454, 0.4560176885958822, 0.43125753464871797, 0.4124585500101213, 0.40860270316632197, 0.4310855370244884, 0.0872879459636502, 0.17230427069664112, 0.582567869981236, 0.6513559922712722, 0.6370303211601003, 0.188407192317379, 0.5538305238986749, 0.5722304457274645, 0.6421106789447729, 0.5576616967276843, 0.23769317202260754, 0.19998984159196975, 0.1669111111877164, 0.20784233580188138, 0.2013731908545181, 0.19487410295865448, 0.20415970026520247, 0.18412318847322462, 0.20372025762448442, 0.20497243831861311, 0.0524544457887105, 0.146803779515018, 0.22171507414801594, 0.16643636646953985, 0.19132683854364174, 0.24448203877238361, 0.031206779873521162, 0.1875300729687367, 0.04219009453077183, 0.06352596836437263, 0.05088310782537575, 0.0003883460461191479, 0.008730294773629299, 0.02188412358670211, 0.034734696464096104, 0.01630531968004001, 0.07180937347537042, 0.15217471116029158, 0.12558731991398764, 0.14215479984809953, 0.17604419861226106, 0.13406565162489237, 0.1305208619248267, 0.2072722224219281, 0.16116937968954193, 0.13703287736825953, 0.06811593838300833, 0.018740027234779744, 0.06626516467385557, 0.043280754306195934, 0.022155607915174014, 0.07105587956698178, 0.11074401798240019, 0.1099973830452543, 0.06723043532683792, 0.1503472810667854, 0.1661660603807753, 0.16784627619595416, 0.14698362877660043, 0.16830561644617215, 0.13675953392793672, 0.1583886839611932, 0.128209486319252, 0.13918317944088865, 0.4594787615501523, 0.46493528766314474, 0.4471130398563684, 0.4776175299794222, 0.46643171301131114, 0.486068339357394, 0.5120121033461753, 0.45566645471233547, 0.46641579678188383, 0.10428146183359932, 0.10217471017162227, 0.10377648003380058, 0.1138486657940252, 0.10110133111829478, 0.11797511174144415, 0.11996786253854552, 0.09403498760830631, 0.11841224804361405, 0.30817188389867833, 0.43791936788390795, 0.141034853495286, 0.16857563082341698, 0.2620092195619834, 0.1315193397064579, 0.34701724295156344, 0.13338436078380023, 0.1990443405738168, 0.30252866926204214, 0.37951464410318614, 0.30745087865711385, 0.36004303571488394, 0.30659447761091163, 0.32257348657114093, 0.38878659525281056, 0.4043168974754515, 0.3814863451219237, 0.29385042273400097, 0.26329025072634304, 0.24980918316538137, 0.2535058265967175, 0.2701347408493989, 0.24653799761288064, 0.2792644839697225, 0.2969277207783637, 0.29492264154718284, 0.1906490930677741, 0.1983582210860012, 0.2087442688057366, 0.19205430517010658, 0.19920719627289518, 0.17471339047765322, 0.22673809372287967, 0.19546173416867996, 0.21479485524505726, 0.2168315255990999, 0.19146683449394475, 0.18842361714177336, 0.2954988946314083, 0.21981600582178484, 0.19825358971996077, 0.22306821347136596, 0.215949941774911, 0.2088734367989762, 0.1687415923162252, 0.16362841934937078, 0.15344892370661822, 0.7478444715409021, 0.19820153201776125, 0.6709334468231138, 0.14510042955158187, 0.16743546497653095, 0.20886086686385552, 0.6293435889618975, 0.15520261473276298, 0.5535286955363181, 0.556016120098949, 0.552483824089772, 0.6309309554802145, 0.19632967482065689, 0.1832707519660488, 0.5642485415184613, 0.1787147998175186, 0.2036520953095613, 0.19318258782277775, 0.18280851891281336, 0.19185373472377054, 0.18391207209294114, 0.20701376756778433, 0.18705568339757017, 0.181361137981074, 0.09034829580147852, 0.08925564061452729, 0.07140079420359502, 0.07739672980504042, 0.07076690408042252, 0.08403144549650698, 0.10379710954551213, 0.07300168224188586, 0.07881585235524946]}, "mutation_prompt": null}
{"id": "96d4ebd5-4b7c-49b0-b3a4-7928e0dfc247", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.7\n        self.c2_final = 2.3  # Changed final values for better exploration\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.recombination_rate = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            if evaluations + 3 * self.population_size <= self.budget:  # Check for differential evolution cycle\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerV2", "description": "An enhanced optimizer integrating differential evolution with adaptive velocity updates and dynamic population strategies for improved performance.", "configspace": "", "generation": 77, "fitness": 0.27907063949151273, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.6254049377155547, 0.6149854901371111, 0.6431669973630283, 0.6597815325830945, 0.6602611421577467, 0.6771034001552536, 0.6406219018927239, 0.638950052210517, 0.6373654803330213, 0.38760322180910667, 0.4022694590528161, 0.3755625036356677, 0.4362903432266326, 0.3871048703729857, 0.37079704136854097, 0.40617547581179925, 0.36492368228229854, 0.3897908003240089, 0.24485004244919706, 0.1262189712378713, 0.12510730821821525, 0.12710906819129453, 0.12014631816462862, 0.12066663959756752, 0.14106910639366266, 0.11560526005403748, 0.11264380481924363, 0.10511057514874433, 0.11479892253118473, 0.10538022714354378, 0.10755370212293824, 0.15228318670056562, 0.11184657790671992, 0.13415056695591798, 0.10781661022546052, 0.10811260745160634, 0.9880068624603141, 0.9928681138421959, 0.9917570541788356, 0.9855976710171116, 0.9877342614400807, 0.9842642219837434, 0.988730800077574, 0.9879797522004006, 0.9882230864874604, 0.37912426900951546, 0.43123820486691977, 0.3743514572020198, 0.4096899697950033, 0.39874584177843597, 0.4359917601578224, 0.3926970054355087, 0.4001136618146086, 0.4355688505375158, 0.549503604706697, 0.5937895009158309, 0.5580172483656075, 0.5689225755420162, 0.4482081189159489, 0.6317509801344838, 0.7049027133382737, 0.5456310119307625, 0.5420732971255483, 0.2285270369299366, 0.2933041796564517, 0.19869462372011815, 0.25647353468582434, 0.24861401864402888, 0.20418431632163014, 0.20477735248199347, 0.1981981171052497, 0.21300030377040835, 0.1807368382173652, 0.010072132150442115, 0.21161380946169717, 0.23779750316202386, 0.21197364275856634, 0.23990864571579895, 0.21265092850721412, 0.10402587464240609, 0.21645540201197289, 0.10121343688340134, 0.06144783605167903, 0.06634123891012822, 9.999999999998899e-05, 0.052361321378775805, 0.10521046161595715, 0.0619699610716401, 0.08836809107144472, 0.10002791067837258, 0.17355793269836417, 0.1669947818180777, 0.22093777413941096, 0.16658894933421475, 0.20366912539419768, 0.15880010363414643, 0.25413358836071576, 0.2102651258645788, 0.2649185017692389, 0.005286266648635851, 0.007362426662887223, 0.02598049261686408, 0.006490335357187682, 0.010937345240650043, 0.021288615889473506, 0.018661118040670943, 0.013845604093236763, 0.02852008625175495, 0.1253545494676348, 0.1427480116969655, 0.13379959445315093, 0.15333313212744193, 0.15211776566309942, 0.1491628655964572, 0.11571772654606216, 0.1434800221848711, 0.13395227219730188, 0.4497337267740875, 0.44642730640083295, 0.483106894855883, 0.4765699896179616, 0.4685575285641793, 0.48969311996225273, 0.46317991339119713, 0.4801296873334767, 0.45558131290913506, 0.11730196215151167, 0.15377391915386684, 0.15773823810220333, 0.1256308243732457, 0.09967374715949406, 0.10005423788277534, 0.10158953809990212, 0.11451535795279721, 0.10630935762083105, 0.14988535038210338, 0.16634952693175964, 0.17683756967270636, 0.22953600379117656, 0.21608915487167557, 0.1408921625797479, 0.18414912378478177, 0.1517017997477289, 0.1983935379021099, 0.3772646397984094, 0.3732660160271689, 0.34432578115995205, 0.3396055795151386, 0.35489413747748544, 0.34892606050813824, 0.3745360482501384, 0.3835859110723363, 0.36112698338701354, 0.2310006274920463, 0.29527939968307004, 0.25320566007061873, 0.2434950449733042, 0.21520616444604235, 0.24459758146746813, 0.2543218299798681, 0.30526000699350275, 0.2621629587360852, 0.184129591383967, 0.18514310282491042, 0.2028319898546297, 0.1978917009047203, 0.1923396920238699, 0.19382945224781323, 0.18948160159612237, 0.18715460563877562, 0.21059681387228602, 0.19171967060023776, 0.2151013682937204, 0.3649496317782367, 0.21077713828546152, 0.22456341908235122, 0.24766563038537925, 0.20921083518292205, 0.29458355162217076, 0.19593972063975384, 0.2573066831305283, 0.17063755356649013, 0.15255537404407293, 0.7486382613298984, 0.1953798700920818, 0.19465037477512903, 0.12300931468359666, 0.16958533922795826, 0.7121218013244534, 0.1393025929818532, 0.1525200772539682, 0.11167683099882997, 0.19418778856417418, 0.4378437945016872, 0.20140382686006775, 0.22094709933812307, 0.20799939459926065, 0.20779941991765039, 0.2103259963557278, 0.21570844672201417, 0.20146937153561417, 0.1887970794331425, 0.2070833490774071, 0.1796382246016741, 0.19378664295960069, 0.19468105474424313, 0.19521187940618145, 0.08114558007740302, 0.07621199938671397, 0.08338459722498015, 0.07212138922560007, 0.06891315062207415, 0.0953923531101063, 0.07728421761487647, 0.08006918986284361, 0.08703501743582676]}, "mutation_prompt": null}
{"id": "3665a536-a43e-4bad-b01a-cfb050310758", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f8cf922c-d2f4-441b-9973-9f84cb1bd742", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f4350630-b758-4955-aa6d-2889bc8d43ce", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "c2a267c5-3348-44db-bda3-5d96d775f8d4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.6\n        self.c1_initial = 1.2\n        self.c2_initial = 1.2\n        self.c1_final = 0.4\n        self.c2_final = 2.4\n        self.mutation_factor = 0.9\n        self.recombination_rate = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = inertia_weight * velocities + c1 * r1 * (personal_best_positions - positions) + c2 * r2 * (global_best_position - positions)\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]), self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerV2", "description": "A refined swarm optimizer with dynamically adjusted mutation strategies and adaptive velocity scaling for enhanced exploration and exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.38756222593042605, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.29.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.9060117209255297, 0.9018551534245957, 0.9116755487451679, 0.9080567368201623, 0.9086760857212172, 0.905451285228673, 0.9145795221443606, 0.9018681789851606, 0.9142202004874007, 0.7967386053870564, 0.8141041879403003, 0.8105905770350134, 0.8125758443501718, 0.8174903323800072, 0.8056170578355342, 0.05941364467647492, 0.8083217271693455, 0.8120752488829885, 0.14342953011591197, 0.6943259131124189, 0.13287647996963747, 0.1524561672882333, 0.18519935659808195, 0.13126569982778058, 0.1464809723538839, 0.17985960608527185, 0.1831397795342634, 0.1443641579801349, 0.1007106187349629, 0.11790851201726149, 0.15402805871181102, 0.13964214704763578, 0.08976126295739084, 0.13980475761998878, 0.14307177887897837, 0.12286387037919799, 0.9875036414896389, 0.9830990003338619, 0.9871512581777407, 0.9868130448378162, 0.9867664113384934, 0.9892541312096085, 0.9839357549243962, 0.98678421446689, 0.9900596536995993, 0.8144964244350346, 0.8038036912970937, 0.1146889464022377, 0.7902301604352078, 0.8309289464130659, 0.8263332417127629, 0.8341075949615889, 0.7528901107584586, 0.7897118431251209, 0.9064354410009399, 0.859763912380479, 0.8480272992136031, 0.21429461852611698, 0.371057583923306, 0.2798397982130667, 0.7463116776851114, 0.39608709922011454, 0.905178401250849, 0.7626283438244874, 0.5967860470387307, 0.1264509658411429, 0.5494397810196818, 0.13605011515571563, 0.5611961890229367, 0.5945847201639884, 0.6277069454757591, 0.56464254333324, 0.43526171004106307, 0.016922133728820676, 0.38984157913528583, 0.7150966826314775, 0.38860306558812874, 0.6299010781937066, 0.5700086474797872, 0.13807061858862124, 0.47361090748510537, 0.17154382786835798, 0.12548453932474202, 0.2605009158525988, 0.09910786641897606, 0.19941865899899935, 0.24452182048940385, 0.17048649729825682, 0.1723632952824823, 0.16581270349409094, 0.31635026431116875, 0.3907563584488126, 0.3329113569571962, 0.29872340649088236, 0.30944340114830415, 0.26955743547887645, 0.3783470758629093, 0.29165549644178923, 0.29691177832289417, 0.2046123547487667, 0.0915274870950098, 0.2989233218639952, 0.07949027376858653, 0.09612850218769031, 0.12542217720545146, 0.10106871452389621, 0.2760915166906457, 0.07339575675627708, 0.17479467924259895, 0.2551630160480546, 0.2758999053308341, 9.999999999998899e-05, 0.208097482612709, 0.1702177939795394, 0.21736911334475206, 0.049734672200394736, 0.3171892203070359, 0.723161904041874, 0.6808750902789682, 0.7131360755879751, 0.7064720092652848, 0.7434462253409975, 0.20939410751705534, 0.7320084572621246, 0.7668359526640788, 0.7262441812481442, 0.10370660775990004, 0.1602519999233798, 0.1425617637671287, 0.10924461012718689, 0.18339556659042655, 0.18102411678357622, 0.14260023660145704, 0.1308385061379509, 0.13870440272743434, 0.21227572824733487, 0.29253104297001864, 0.23095391780083996, 0.2993087124478775, 0.17113614371432107, 0.3610814788786303, 0.28576368126190843, 0.2026781718825198, 0.3302163507735092, 0.38845093215902327, 0.47580600669626205, 0.3656863050333067, 0.547450468747449, 0.48024720345002214, 0.4353815823236252, 0.5583198973728756, 0.6087198113753653, 0.3216136112731822, 0.2778486227263466, 0.3086743879219037, 0.2180300296284584, 0.22303482032434752, 0.22996432074099316, 0.29683082733899746, 0.40060311892622846, 0.3268773921111203, 0.2819851763719897, 0.2364183025646892, 0.19734136206173347, 0.24016381882477666, 0.21239621775184536, 0.21964129274389566, 0.25379219556239363, 0.2398543418381136, 0.2180245983141409, 0.23938777494317187, 0.2110122455455551, 0.2256547240336646, 0.2081741164357913, 0.2527670424184387, 0.22341100130666902, 0.2250499433338533, 0.19328512413693788, 0.7953728187252496, 0.2213938381811973, 0.9249020244629466, 0.16723561002405551, 0.15480972423275086, 0.17302484542387897, 0.20066294709169052, 0.1978494886031288, 0.17715118872131042, 0.17021138078724596, 0.19595054739074036, 0.12711360424775886, 0.21314398504553123, 0.15518676412319632, 0.21165148317070992, 0.8470129464079992, 0.2113042983046587, 0.1994864886849037, 0.9086922347161465, 0.1982045868190878, 0.18576030451301617, 0.195699563193641, 0.20412778994672154, 0.2077348901259095, 0.22155001247888417, 0.23200038549758206, 0.18717587578753958, 0.19025020881685162, 0.1995548274404848, 0.11060957150402828, 0.08391815304438077, 0.08601322860815452, 0.09819002058817494, 0.09735824689566308, 0.09604860910570767, 0.09007467772228861, 0.0948549406955086, 0.0984240429753519]}, "mutation_prompt": null}
{"id": "66866c45-3fe7-42cc-a207-4254e5a40584", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size for better exploration\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.mutation_factor = 0.6  # Adjusted mutation factor for balance\n        self.recombination_rate = 0.7  # Adjusted recombination rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (evaluations / self.budget)\n            c1_dynamic = self.c1 * (1 - evaluations / self.budget)\n            c2_dynamic = self.c2 * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1_dynamic * r1 * (personal_best_positions - positions)\n                          + c2_dynamic * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "An improved hybrid swarm optimizer with dynamic inertia and enhanced mutation for better exploration and convergence.", "configspace": "", "generation": 82, "fitness": 0.33289141283568346, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.7398820410236857, 0.6987474637007289, 0.6981037065713033, 0.7072453787097057, 0.7069452273466066, 0.7275116860410686, 0.7003759262218257, 0.7116352344626953, 0.707577018346191, 0.508214526006624, 0.47555170351261955, 0.49331975913981896, 0.49304285460880926, 0.49188599504277863, 0.48951614477880556, 0.5066134760130381, 0.49403788444206553, 0.5005471024680415, 0.14780209762284524, 0.14686517084803685, 0.1230570822773881, 0.43109086933290364, 0.12413606094199947, 0.15894349937341956, 0.38554075393243825, 0.12199306819834599, 0.15607759699372092, 0.11421413351325305, 0.10859024092037328, 0.12166512933718454, 0.1201001965873173, 0.1183775686710471, 0.10929732190147567, 0.13055136294834924, 0.10789889042928003, 0.12781226601464513, 0.9738155190481774, 0.9744896995526133, 0.9739203355623716, 0.9659878269666125, 0.9798315997635024, 0.9790204371106176, 0.9767552049418824, 0.9757339284658727, 0.9738699314754253, 0.5595806111750254, 0.5536073241515804, 0.5771293527573931, 0.5798585950501188, 0.547571632067648, 0.5741271682965849, 0.5901782928846837, 0.08613842992199738, 0.08580525479092627, 0.6570190403629514, 0.6634077465250109, 0.6194936299416562, 0.2642619752333546, 0.6627751266559352, 0.6976396896189918, 0.6851422928830029, 0.6552020392349812, 0.645640681734931, 0.26618711656915994, 0.2501184180207062, 0.20738904501500022, 0.1758928361187525, 0.2187447960382055, 0.22097283783055555, 0.23386348828547376, 0.28797758071583235, 0.22158894700692677, 0.020427818088356586, 0.22525598228491928, 0.22718318665795645, 0.1965381795765906, 0.24861944307214567, 0.22410267071966494, 0.2682908008614602, 0.21608202698429746, 0.31194739074300404, 0.09350224978536992, 0.07767957944287374, 0.06026835101351402, 0.0698443337722574, 0.05549397183434723, 0.06975402311695345, 0.053857732967238725, 0.05822860962493448, 0.08318881721088434, 0.212667991350718, 0.1686986032093779, 0.2227068618000677, 0.23045474046422565, 0.14704966897308036, 0.15872943760497948, 0.2050938942920718, 0.19908382128479385, 0.17961510387000235, 0.03334814432694344, 0.06038514058308664, 0.03162933925620015, 0.06339535989488487, 0.11896289165327201, 0.1290734149148357, 0.08014480118685785, 0.07583029091970783, 0.13711663893042025, 0.13605659928820968, 0.17437833304295525, 0.18917740964642515, 0.2519830659412299, 0.1906274682964748, 0.1493499965001902, 0.20998200526022903, 0.15096192022389643, 0.1360036222110519, 0.527160360312686, 0.5039855011998443, 0.5031654174446427, 0.4953250629299082, 0.5081183924430881, 0.5312593375205334, 0.5288036508697764, 0.5095436578578219, 0.558062301841828, 0.12125074203285258, 0.1296904850539342, 0.11032993982508088, 0.1259742699228984, 0.12146656072986783, 0.15269906833326552, 0.11494585819099379, 0.11010212406000242, 0.12251055138559264, 0.1694768186248028, 0.17807639524737007, 0.2000168448102705, 0.18462141667557275, 0.16166772732709234, 0.1961465869868283, 0.19980610639763485, 0.24621911935091967, 0.16025510058010073, 0.34709346205269587, 0.31559682093631214, 0.378708979015944, 0.4309539864639923, 0.46918849622155523, 0.40514750173508907, 0.491946519499739, 0.47122640662839266, 0.4712267035336686, 0.27940900354552156, 0.27297197975023346, 0.28642205422798106, 0.29093613372905747, 0.23650998672780954, 0.3274699994236593, 0.24671411877064142, 0.2868684405433187, 0.2931416931875358, 0.2009054142885267, 0.19766033611490608, 0.20571567967592508, 0.21974785167436517, 0.21584253878063275, 0.20875476558630202, 0.2781072498567928, 0.2008609086113059, 0.21713358802282123, 0.5443477743196211, 0.19100050552707637, 0.2223275158577912, 0.5251701679492802, 0.19180004667127903, 0.5325559961457289, 0.21641879037688283, 0.19637844267358062, 0.19410185088702436, 0.7129095805188392, 0.7063854476416429, 0.733335329801309, 0.7180417795684719, 0.6140548032476363, 0.6992033474870619, 0.5982047056173343, 0.6967484338582364, 0.7489683074537983, 0.6283643431225672, 0.5161029819923215, 0.6519176456560966, 0.5409669790432693, 0.20141153018645386, 0.6099072861358286, 0.20262234676455693, 0.203116050487969, 0.20700435690686503, 0.19435680934593158, 0.18458019296827388, 0.189928438043376, 0.18454586948215979, 0.21748198967616028, 0.18573128140453599, 0.1917037558317073, 0.19334794901721075, 0.1871993017245892, 0.09504253370176907, 0.08638552338253536, 0.07700803049356963, 0.09337083518854361, 0.09068368879021305, 0.0851446610772969, 0.08657315339148552, 0.08269718879239496, 0.09018100499956416]}, "mutation_prompt": null}
{"id": "82a90f7d-1211-437f-99c2-43e7a01770ce", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "864d66e3-f0e2-4651-93df-8714cec6a4d9", "solution": "import numpy as np\n\nclass EnhancedHybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.initial_inertia = 0.9\n        self.final_inertia = 0.4\n        self.cognitive_coef = 1.6\n        self.social_coef = 1.4\n        self.mutation_factor_initial = 0.5\n        self.mutation_factor_final = 1.0\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget\n            inertia_weight = self.initial_inertia - progress * (self.initial_inertia - self.final_inertia)\n            mutation_factor = self.mutation_factor_initial + progress * (self.mutation_factor_final - self.mutation_factor_initial)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + self.cognitive_coef * r1 * (personal_best_positions - positions)\n                          + self.social_coef * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            current_best_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[current_best_idx] < global_best_score:\n                global_best_score = personal_best_scores[current_best_idx]\n                global_best_position = personal_best_positions[current_best_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < 0.8\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedHybridSwarmOptimizer", "description": "An enhanced hybrid swarm optimizer using adaptive inertia and mutation strategies to improve exploration and exploitation balance.", "configspace": "", "generation": 84, "fitness": 0.34270572371672564, "feedback": "The algorithm EnhancedHybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.7241217015957928, 0.733305542532865, 0.7301369967385763, 0.7382365192608843, 0.7262771289949524, 0.739328973709707, 0.7421951654938701, 0.7427461493250875, 0.727265657704917, 0.5539453984725159, 0.5436039935802224, 0.5134048982423998, 0.49655267602751885, 0.511017041114405, 0.5208297799809198, 0.5224155081171107, 0.5336646660049201, 0.5643715695783387, 0.1265350715639546, 0.12860484627672764, 0.15688580772884564, 0.12895474522777894, 0.1426540893251529, 0.1551033228330131, 0.34423955828940467, 0.14830797032963583, 0.14077799609624286, 0.10699811519028224, 0.10117972947432285, 0.12935145609989396, 0.12794547959837455, 0.14391525486382195, 0.14824445608856662, 0.11485437212142147, 0.12491984520643962, 0.10803574431096752, 0.9899731974429052, 0.9853445497715542, 0.9904494949084537, 0.9729762624008569, 0.9836756871047636, 0.9905648375265145, 0.9908622543822792, 0.9874009956985631, 0.9873746775087816, 0.5483348594279768, 0.059422495616100246, 0.5234395509012614, 0.5754231813622745, 0.5329665117079849, 0.5491553151942341, 0.553035371413504, 0.5486649798503076, 0.17604404402315488, 0.7291282440865918, 0.703906434210232, 0.7616214992083699, 0.7574765671886361, 0.7495889725645782, 0.8091114998546319, 0.7265707755639133, 0.8114879743323693, 0.7730581805181621, 0.29777864320356706, 0.2751201519108045, 0.2640145861891722, 0.10019073764019681, 0.30623607186068, 0.2617456277180251, 0.31845733425426637, 0.30299090826532815, 0.30061166085374, 0.28305449924955495, 0.053604951649051547, 0.2583693739530606, 0.2511662720216782, 0.22290195139928692, 0.3456852128548603, 0.2942728669167496, 0.2979654905976582, 0.2662456748277152, 0.07034424293011365, 0.056537496671126286, 0.11620871928923793, 0.05589277737165688, 0.1901930898046691, 0.04705693434198188, 0.25880598579130454, 0.03068617241603422, 0.11293716408593524, 0.1580959749315094, 0.37143883336195027, 0.2640237324341761, 0.28260629513054825, 0.12039691736501368, 0.07301917399669944, 0.15805531004965812, 0.37290597412415605, 0.22031945810026732, 0.08294800304571581, 0.04965861327812493, 0.15340051545410482, 0.09092462102140764, 0.10976706031758965, 0.13084020657556117, 0.09508003836188417, 0.12099469946098451, 0.06388707969242913, 0.17281086724658257, 0.23769718499784886, 0.22488280508753145, 0.20163767903625618, 0.22083663943989562, 0.23424029295641946, 0.1445454199818168, 0.20499089995787456, 0.20563990738124294, 0.5499180578048442, 0.551378559837123, 0.5587433503287322, 0.5604120864579116, 0.557099387976835, 0.5516668672451734, 0.554922405475811, 0.5309613553478355, 0.566660856152144, 0.11103774843612224, 0.13546374939965045, 0.12120544503683317, 0.12401849120675301, 0.11851477928808485, 0.105459812489759, 0.1200521151957753, 0.12323356397447371, 0.10689962922799368, 0.17428951506206525, 0.19725951872443803, 0.4608765254782662, 0.27941731807855497, 0.27853402376761605, 0.26919966091798386, 0.493218045478493, 0.18648838340910046, 0.4583384333821976, 0.4420062057740003, 0.4189449800724948, 0.4357583543188377, 0.4500075886629714, 0.4528143758616576, 0.43458245936707085, 0.475437254565901, 0.47224588410750834, 0.2742322978729632, 0.2257526188612231, 0.2872357451969709, 0.2906813229794203, 0.29547869456194364, 0.1962935873708498, 0.3270773348202183, 0.3575002071851825, 0.32843443037176556, 0.33484854585544177, 0.20473656148840746, 0.19934558684965986, 0.19190164505984242, 0.23715981503761752, 0.19253827610363528, 0.22038771036923155, 0.1995883948947378, 0.21523418427718144, 0.23543959658994518, 0.48944704642232406, 0.2059351906381689, 0.5034531400087163, 0.19679618941682941, 0.5182986480810469, 0.1910644649616582, 0.4336723948408828, 0.19974903490746365, 0.2323369906704632, 0.8344864944539857, 0.1828609098823295, 0.15078973094692882, 0.8199195149328268, 0.20014947948096862, 0.19715840987821898, 0.09976403468907158, 0.170097725622805, 0.15618543644130534, 0.7966717803391284, 0.16861849548612662, 0.12646484217304754, 0.6592858705643707, 0.6293871075373736, 0.20967667424947656, 0.21242504187955324, 0.7981854369226955, 0.7466615994157303, 0.1858180770793193, 0.18805624405162957, 0.185765027518764, 0.2223264799658904, 0.1952215527962159, 0.18226800782802688, 0.20116996715929258, 0.18965453962748358, 0.1852723898171711, 0.0842785948682887, 0.08405976163525342, 0.10728834356197514, 0.10033074383123708, 0.08522527266129964, 0.08672008951898968, 0.08877515077370535, 0.08208948845200725, 0.08693712144193066]}, "mutation_prompt": null}
{"id": "ccd5d221-c4a8-473d-ac4e-6ae77c004aa5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "2de2f3af-6260-4ac1-8f2f-ce9cb9bd1705", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "a04612e8-1871-44c7-829e-cb793768e4d3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "9ee98382-b7e1-4bbe-b9e4-e982f40d119b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "345d20ad-f3ed-475d-93eb-ab324a15061b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "361042e7-f774-42db-a09d-3235b42fdc93", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "fb1caa6b-28ef-495d-a67d-ad4ecc80c512", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "d76bbd4d-ab8c-4235-bfb7-2a3a0b69af81", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # increased population size for diversity\n        self.inertia_weight = 0.6  # updated to balance exploration-exploitation\n        self.c1_initial = 1.3  # adjusted cognitive component\n        self.c2_initial = 1.7  # adjusted social component\n        self.c1_final = 0.7  # adjusted final cognitive component\n        self.c2_final = 1.9  # adjusted final social component\n        self.mutation_factor = 0.9  # increased for diverse mutations\n        self.recombination_rate = 0.8  # slightly reduced\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # adjusted initial velocity\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (0.9 + 0.1 * np.sin(2 * np.pi * evaluations / self.budget))  # adaptive inertia\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (1 - np.cos(evaluations / self.budget))\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (np.sin(evaluations / self.budget))\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = inertia_weight * velocities + c1 * r1 * (personal_best_positions - positions) + c2 * r2 * (global_best_position - positions)\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]), self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerV2", "description": "An enhanced hybrid swarm optimizer with adaptive velocity control and randomized local perturbations for improved search efficiency.", "configspace": "", "generation": 92, "fitness": 0.3567976984362136, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8499272790956862, 0.8294811675026397, 0.876226991899514, 0.8735852616806512, 0.8574179060820981, 0.8579396659491285, 0.8462040309172966, 0.842940628677971, 0.8850963888133789, 0.6942327008162203, 0.6723778625779259, 0.6870929403989747, 0.6649460859284837, 0.6888822830853083, 0.7027266208120276, 0.720610601447119, 0.6995657909401509, 0.701167036791873, 0.1727353172429661, 0.17385720701048646, 0.1732297104441448, 0.12459406745226809, 0.5323642329612026, 0.14588138980791432, 0.1667921420093177, 0.16984793658067499, 0.12239888136082955, 0.1700477212724434, 0.16019329847145292, 0.109030925306562, 0.10942708065386486, 0.14945478680562752, 0.10842526772815164, 0.13337265099592654, 0.12347431346846571, 0.16938813702259903, 0.9903163403028914, 0.9911115199319593, 0.9917215445647131, 0.9839269469175588, 0.9868303565247512, 0.9860227544984228, 0.988386446801916, 0.984219570401918, 0.9859510007874299, 0.675263161401435, 0.6935300383840484, 0.6961721538735781, 0.15242012776128155, 0.6760518064058031, 0.15243784379865555, 0.12635365178050428, 0.6687083573782147, 9.999999999998899e-05, 0.8544226711949978, 0.35355922506933046, 0.7430978204983114, 0.27991412008239225, 0.7634787641483975, 0.2705710739042082, 0.8015952365500243, 0.7147444479570118, 0.8144985475837694, 0.4098482249763996, 0.3003854610077564, 0.3692023296419371, 0.32105243388720395, 0.3593747558985706, 0.2917318188354201, 0.13115597035475335, 0.30883174187665585, 0.3496333181291533, 0.35563411065496897, 0.022193570114982353, 0.29841814733955685, 0.40499833307779176, 0.30779246390413595, 0.3672302634968898, 0.36656575663232116, 0.13279963324063504, 0.11730857510887838, 0.0725380746124702, 0.08437939200755029, 0.12378624671373561, 0.10056241543162447, 0.04753017047986319, 0.08029802431546829, 0.057615472995918626, 0.1062205467224081, 0.06749826379120749, 0.17484693272623897, 0.14018276701484444, 0.2363793045350009, 0.15716790014845083, 0.12960653877455075, 0.24393812146629512, 0.2025599499218521, 0.19800498720406423, 0.1918232494043537, 0.033855476156171016, 0.04361981365689949, 0.1394238406056536, 0.09890586218825848, 0.0775948852774393, 0.14633385439635227, 0.09496508156680772, 0.3735926886817802, 0.06959865524063447, 0.16133556856900066, 0.17170493030110445, 0.16162186669438838, 0.20789369492274823, 0.19956213509502962, 0.2415394271798179, 0.08104057221105943, 0.17598841774106389, 0.08257608934768945, 0.5447637270656354, 0.5806311083290805, 0.5776504669692653, 0.6061959643242609, 0.5782211627264526, 0.2088625907271705, 0.6086889223500829, 0.5820711965113112, 0.6171546032999832, 0.11094851968769359, 0.1253789246630378, 0.08235887026935163, 0.1382990626317856, 0.1289471131253478, 0.12064728404431113, 0.136903912175247, 0.14766662665330366, 0.13576545987954758, 0.2342667344839342, 0.18741762022277475, 0.28305567466581527, 0.61986621880174, 0.33681031220290636, 0.20162337380518025, 0.45519067553347037, 0.19553969668591187, 0.31296420718701135, 0.3538590055227432, 0.5493642285955236, 0.4781516993304884, 0.4684656782458336, 0.5664618350810522, 0.4318809390690348, 0.5605492850116541, 0.6660294516723434, 0.5067131121273492, 0.279034492363892, 0.21624122809170898, 0.2722387098964415, 0.24103249808366733, 0.18883405029104572, 0.25911029227103266, 0.39346692534881755, 0.4233029005445572, 0.39185231929288145, 0.22907631657888972, 0.2378666334430013, 0.18763442066637315, 0.24143328092830163, 0.22431679866854792, 0.21228090221817586, 0.23407534597368262, 0.23319239255569058, 0.22050129949703112, 0.23980181269519785, 0.6630811254494489, 0.22028368983854185, 0.2217034794211561, 0.7591038466970441, 0.19340377350454296, 0.22029305464500304, 0.2151978316438894, 0.20465164210287123, 0.8960989743700649, 0.8559052360120203, 0.15439863858649294, 0.9027170990673532, 0.8675975607834114, 0.20034212103436644, 0.10014377997882351, 0.16982972122673967, 0.21158537630129304, 0.8085641388643303, 0.20682362483889472, 0.11228770389357012, 0.20343925361807358, 0.1600443943117611, 0.2107297167950677, 0.20263257898776355, 0.8019054205775635, 0.7891286001248488, 0.19938086577111558, 0.19477465937406468, 0.2032483260369219, 0.1986456093686948, 0.22967053288344985, 0.19527077364773182, 0.18640117214444663, 0.19856753258804716, 0.1794963766512988, 0.11048105594580371, 0.08174419266932398, 0.10666135458117809, 0.09006182042008226, 0.078162030961209, 0.0958407177288958, 0.1300728772636458, 0.09370362324109816, 0.09897911039295415]}, "mutation_prompt": null}
{"id": "28718341-4fea-443a-bdc3-72448651a90c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "0843809b-b62a-426d-9397-813e89099266", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30  # Increased population size for better exploration\n        self.inertia_weight = 0.6  # Adjusted to balance exploration-exploitation\n        self.c1_initial = 1.0  # Adjusted for better convergence\n        self.c2_initial = 2.0\n        self.c1_final = 0.4\n        self.c2_final = 2.5\n        self.mutation_factor = 0.9  # Increased for stronger mutation\n        self.recombination_rate = 0.7  # Decreased to focus on promising areas\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerV2", "description": "An enhanced swarm optimizer with dynamic mutation and recombination for improved adaptability and exploration.", "configspace": "", "generation": 94, "fitness": 0.31234857010197753, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8251356528166329, 0.8295909552462818, 0.8430419448631631, 0.8380839941011176, 0.8441927385952355, 0.8356297519258431, 0.8378367370757135, 0.8440696708535221, 0.8487789007684917, 0.7106271552983974, 0.6944443396510643, 0.670601765864584, 0.6876457814486978, 0.5903930652462694, 9.999999999998899e-05, 0.6845580106435853, 0.7020951708919391, 0.6285209747445717, 0.11401256637330859, 0.11454997246787535, 0.1656583083174541, 0.13613252868369818, 0.5686066839430539, 0.07352684300035983, 0.1266222977401238, 0.17969476436384957, 0.11215650852408343, 0.17197882912096463, 0.12935531230209052, 0.13781787901136178, 0.13711064155943442, 0.13147925043062847, 0.17363798291469412, 0.1354188175609985, 0.09114748544422036, 0.11187532174002413, 0.9880270281052884, 0.9901787361598179, 0.9913344486417336, 0.9861464968727475, 0.9811507744692383, 0.9788389902808715, 0.9866247433779575, 0.9859907467277941, 0.9816162263736099, 0.05989429871605112, 0.678627470540828, 0.05525134320654601, 0.15173609598634719, 0.7311719926977243, 0.1517958912776869, 0.6747694703731865, 0.664164404009928, 0.051777641200195124, 0.8017123895028188, 0.7407367298061731, 0.21933385476240208, 0.2776554445822007, 0.19078340568083918, 0.19222105068358075, 0.7705050559972215, 0.8126878735750855, 0.37668845376132243, 0.35230607324309626, 0.26671265778263786, 0.2895732950421407, 0.2988130664090646, 0.2568335912480342, 0.27873399560399825, 0.30419775694846796, 0.2660437174857361, 0.3117865851137991, 0.33062644005581165, 0.05399679020302661, 0.12506229772311195, 0.3289682080009174, 0.3215761581578519, 0.3516140080618283, 0.1272210810750508, 9.999999999998899e-05, 0.32619302334898537, 0.0654389807739868, 0.05698474743698845, 0.07109305240432551, 0.032781090869202334, 0.06117336819186381, 0.04136769103612625, 0.0631204121534592, 0.08844717952277692, 0.07401187651619401, 0.16481808029769962, 0.12248129628372573, 0.14032937581971472, 0.13680312073723233, 0.0779363570178726, 0.043674434322769407, 0.1529338815866137, 0.16585860367855532, 0.17639342260415214, 0.19229742203118727, 0.03459125366466265, 0.08541463747794553, 0.07325425001070596, 0.07558271466403044, 0.07389260522782881, 0.09114864310585513, 0.20905955074638483, 0.10941603759418117, 0.23517285423528245, 0.040812760391718106, 0.15371501001596533, 0.19527210909608717, 0.31488741725809544, 0.20732960233580855, 0.07959638700340854, 0.056281140829818055, 0.08253275362227142, 0.6069021773828479, 0.5882827802376724, 0.6158759795815288, 0.5874940437123639, 0.5633389473125714, 0.6104490686483237, 0.6020122790945764, 0.5726491608073871, 0.6221794249370455, 0.10051174246142713, 0.12659489130220714, 0.09703767116074924, 0.1094149093220893, 0.13306836994198734, 0.11861803453206754, 0.12681818525586208, 0.12776410961153783, 0.11374252398595419, 0.14971060516935542, 0.21583503209976906, 0.1866606979749873, 0.24585347464708707, 0.24055932011290737, 0.5370558729354789, 0.22223453732376297, 0.22211985083020902, 0.15746422183239905, 0.38973966430435747, 0.2552503365665736, 0.3911798824633723, 0.5742199856695588, 0.30461450244628263, 0.43794196160405197, 0.5599020505585954, 0.5940413058934606, 0.33355142802926074, 0.4152111220798671, 0.3014969683483706, 0.2510973160534341, 0.2328738601660464, 0.21454249767785805, 0.22641762247809338, 0.31787847319481355, 0.37434474046806854, 0.4281206718134325, 0.2892840289149834, 0.15256493879431332, 0.21741627756024873, 0.20615170655255977, 0.23435294335035328, 0.21827200721239126, 0.2215708284376895, 0.22382386875596927, 0.2565953396152195, 0.21141606356726605, 0.24222832716623277, 0.20987069049126528, 0.21107401798536551, 0.23630319737685446, 0.20487161816798394, 0.20261654792540562, 0.22305535072134308, 0.6644381779787496, 0.14052455298402078, 0.1702029794607639, 0.11307191818981954, 0.1721019400612579, 0.198501398692995, 0.19868261900940076, 0.12285727683968284, 0.1695932091422172, 0.21007286569319772, 0.7657471985896231, 0.15425109005782522, 0.20584014483483282, 0.20946908663128394, 0.2258036153805718, 0.20968746676030792, 0.10507271312252597, 0.10424912326407287, 0.7917769550346959, 0.19319463575289475, 0.21283559793290796, 0.19362539667513534, 0.22350457910140598, 0.19448607464024192, 0.19279222248106287, 0.19721813431730584, 0.21035405278405106, 0.20118188772429335, 0.143376247837677, 0.0871875668887615, 0.08954738780014182, 0.10345589428306612, 0.09478254790818641, 0.09515318374960802, 0.11725268646211429, 0.09561330873721963, 0.09183282362755474]}, "mutation_prompt": null}
{"id": "c3b662eb-8d85-4ef8-8ff7-7ed6af961da1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizerImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population size\n        self.inertia_weight = 0.6  # Adjusted inertia weight\n        self.c1_initial = 1.2  # Adjusted cognitive parameter\n        self.c2_initial = 1.8  # Adjusted social parameter\n        self.c1_final = 0.6\n        self.c2_final = 1.9\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.recombination_rate = 0.8  # Adjusted recombination rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - (evaluations / self.budget)**2)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * ((evaluations / self.budget)**0.5)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * ((evaluations / self.budget)**0.5)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizerImproved", "description": "An enhanced hybrid swarm optimizer using selective dimension updates and dynamic parameter adjustment for increased convergence efficiency.", "configspace": "", "generation": 95, "fitness": 0.3579797973566455, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizerImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8415872902737346, 0.8275831903794539, 0.8604737095255188, 0.862229051224345, 0.8401754822360123, 0.8435139768322213, 0.8537822122395737, 0.8532414442302322, 0.8576139530003555, 0.7056242161673071, 0.7153348669620376, 0.7127356117014123, 9.999999999998899e-05, 0.6013636472313669, 0.6871685761494264, 0.7211584662413298, 0.6974150548642104, 0.7224151877140244, 0.15731050729348195, 0.10928547213613471, 0.13893993978443564, 0.14016161426628582, 0.6170554205492882, 0.7145114595053339, 0.1537476647185404, 0.18243545538881323, 0.5878261717191939, 0.10679645606701726, 0.13017008955034015, 0.10788978762359946, 0.10029348245863001, 0.11706446252077007, 0.10960036219497182, 0.11704212855064111, 0.1405432433966407, 0.13009440962468866, 0.9917698175673784, 0.9929053199606538, 0.9917152572596685, 0.9841143750235152, 0.9868447260468467, 0.9859266618793023, 0.9884227658380338, 0.9883433780123401, 0.987099730927543, 0.7325053127811822, 0.7141672907553274, 0.7185282406004401, 0.14921045775432973, 0.7446597783262004, 0.14984254620087212, 0.12668830723556335, 0.7062011715586144, 9.999999999998899e-05, 0.3804213350319896, 0.7610370965490239, 0.776706570705434, 0.8127701863505903, 0.858837747131458, 0.37104111404379025, 0.7989164190436571, 0.7525218235744466, 0.7903091685795409, 0.5057850060964602, 0.32662380443172656, 0.41912981123989823, 9.999999999998899e-05, 0.13408516192841713, 0.3574230636639243, 0.39929380435385675, 0.38907238686298395, 0.3581741659949321, 0.29292893768872175, 0.01662927911412404, 0.022015302804764048, 0.45719095248089203, 0.4254917597026293, 0.39892622244434517, 0.208798318283125, 9.999999999998899e-05, 0.37127034852762053, 0.1239417756233242, 0.06691967276289146, 0.08262962549194142, 0.0006676048915311705, 0.09286331719815677, 0.09664360794544102, 0.07285943073084178, 9.999999999998899e-05, 0.1610697538133864, 0.18966605941010928, 0.20807812121346692, 0.16369567351831704, 0.20609285596126747, 0.16889921087479887, 0.15152644465456866, 0.2167528720709383, 0.19136731522996953, 0.19575061446470698, 9.999999999998899e-05, 9.999999999998899e-05, 0.06707152461676125, 0.0751885218918178, 9.999999999998899e-05, 0.07777654358036612, 0.09892212018166724, 0.09347382621289257, 0.10929195964278604, 0.1838626758225428, 0.25872129612256023, 0.11190372402103455, 0.19767106328593542, 0.2585094296675404, 0.24726225666933843, 0.21206357809064325, 0.12236031139343906, 0.08277826748680805, 0.6211452867013849, 0.6443035855598357, 0.6194915005620395, 0.625886890135408, 0.6693140748297204, 0.6351441384185509, 0.6497880288219259, 0.6069497893323583, 0.6189093523250101, 0.08164836606067716, 0.10756219797497635, 0.11433958936047928, 0.13720696039257707, 0.09973413589948055, 0.14385187055902737, 0.10306670083906921, 0.09835691090756149, 0.15000179619846532, 0.18994678128444376, 0.21442537413401708, 0.5107468268845947, 0.24099356333210065, 0.2504523249422448, 0.32913254988568486, 0.19198378006766648, 0.2953549647304763, 0.20160765675347425, 0.3260789782511586, 0.29471499376013777, 0.4845448935523159, 0.5519362280605686, 0.3230428503017664, 0.40894396931251165, 0.6516869062198432, 0.47427373361354075, 0.560874803385317, 0.2760551814606753, 0.3702783434233414, 0.27934892460818317, 0.2702901649186339, 0.34209831987898554, 0.3030034809270852, 0.3906146048898228, 0.2975941792743, 0.2639802027072842, 0.22523985717958017, 0.27215174314078117, 0.21480986908959, 0.19580533318819926, 0.21091335726219018, 0.2590581429468941, 0.2105435846752901, 0.1999474018737858, 0.2110245349147769, 0.2304620367483593, 0.19374651771292406, 0.19587707152658063, 0.2092711198396373, 0.23773362278934473, 0.2027308702904066, 0.2198166281114068, 0.6717985106455675, 0.1893243308904633, 0.8790611299619898, 0.17725414234195092, 0.15430281786583655, 0.8966030231928652, 0.19982896327046074, 0.19829242385001267, 0.09983840828589363, 0.1702259166646498, 0.21315067230906026, 0.8184675605664213, 0.7655766648271278, 0.1117030293547907, 0.8425211727283202, 0.741119082151654, 0.21039640431957196, 0.7890408517214229, 0.8164087952472401, 0.21191550151475924, 0.19239989898400667, 0.1893644253257888, 0.25789932866797016, 0.1995565315595732, 0.19319789517716512, 0.20192597555559277, 0.20269546597187627, 0.20068110099953818, 0.19213895233583167, 0.09326836130994232, 0.09915209894950716, 0.08744375373329005, 0.10091400756785207, 0.09683189461916686, 0.09304887514566085, 0.10295506125369325, 0.09480749324525894, 0.0830782169758586]}, "mutation_prompt": null}
{"id": "c93c2a3e-938a-4e59-a67e-5ff50c299fea", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 25  # Increased population for better exploration\n        self.inertia_weight_initial = 0.9  # Dynamic inertia\n        self.inertia_weight_final = 0.4\n        self.c1 = 2.0  # Standard cognitive component\n        self.c2 = 2.0  # Standard social component\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.recombination_rate = 0.8  # Adjusted recombination rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))  # Start with zero velocities\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight_initial - (self.inertia_weight_initial - self.inertia_weight_final) * (evaluations / self.budget)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities + self.c1 * r1 * (personal_best_positions - positions) + self.c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "An enhanced swarm optimizer with dynamic adaptation strategies and selective local search for improved convergence.", "configspace": "", "generation": 96, "fitness": 0.21978611911856863, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.512233125919469, 0.5141094812787395, 0.5084135708604547, 0.5450357614846641, 0.18883209279947866, 0.5530887509690787, 0.49443170369004796, 0.4927030622450562, 0.5342509265438833, 0.27592283628592906, 0.21280673907316427, 0.24858278368521602, 0.24486598326154085, 0.2245425744384837, 0.2583258672172809, 0.281215808911078, 0.22295947170055386, 0.26032364412070297, 0.10408164451906399, 0.10674058624360605, 0.10745549681907929, 0.13546059894104234, 0.13093472718062127, 0.1060142277119781, 0.11432077801125684, 0.09331298539790334, 0.09143632525519385, 0.09920827060735815, 0.093256921489145, 0.10240272337790557, 0.08614792767900237, 0.07845384688738721, 0.08501246349361957, 0.08478330677188495, 0.08940158935447085, 0.08754453410614893, 0.9894461377735577, 0.9928997892876704, 0.9890306072071754, 0.9889639826506637, 0.9884955142060453, 0.9866813395735657, 0.9915092565215172, 0.9884352001326884, 0.9883705337266395, 0.27052837215952774, 0.05854019556030321, 0.2565524233663693, 0.2629540503642326, 0.26851876350996995, 0.2953938344031878, 0.0857853853302446, 0.28671181392826517, 0.08616209883598058, 0.43064150565171244, 0.17007072408784896, 0.4072818357823844, 0.5459938301479779, 0.3466141058722165, 0.3755200573819013, 0.3999722807398831, 0.3425037139839422, 0.3933116620254905, 0.14060051593363987, 0.11696796017051403, 0.1518887919434504, 0.15826452733735497, 0.13564727443923508, 0.1330483109757693, 0.1564382288501951, 0.133308995282873, 0.1518401882960415, 0.12657990071434055, 0.02219191927466857, 0.12293812273390614, 0.15284173415853275, 0.14103568108236053, 0.16105326212096804, 0.15635809887157137, 0.10438607885329387, 0.1396881689115551, 0.025998643141171618, 0.03629504617928747, 0.02344162272903083, 0.06601419901770045, 0.027000163501306296, 0.01518134500922419, 0.022675455252804566, 0.03033217904853369, 0.0518455158009139, 0.11386740057177724, 0.10649202664502955, 0.12712667277079703, 0.13618694452111668, 0.13364857270595998, 0.14198514173534948, 0.1755859789612978, 0.15348544927416297, 0.16689090233482984, 0.0045090003946893775, 9.999999999998899e-05, 0.006350030755979064, 0.0005186012889245584, 9.999999999998899e-05, 0.010774285622234148, 9.999999999998899e-05, 0.006698132382213728, 0.011654561602586377, 0.07180787787951537, 0.08401972276516956, 0.0987466620920201, 0.10995783405633852, 0.09729435115705087, 0.11658550624097219, 0.08643325695114779, 0.10079244184672786, 0.1288926128756095, 0.38809509616684357, 0.375443145771272, 0.39701546943206856, 0.3892478192904959, 0.4076287386904558, 0.3981924068186167, 0.3971434265357874, 0.39404299526720155, 0.37348366047507076, 0.10838126334593212, 0.0737688184498515, 0.1057657178509731, 0.0850114916174538, 0.08229693993077014, 0.08664755499823784, 0.07229085211326602, 0.11054080561565172, 0.08769199491969426, 0.15743856671528533, 0.23984006838074334, 0.15732214973068148, 0.19903084876266552, 0.22657140432401524, 0.2360928760034149, 0.16504935985510016, 0.17307054374676645, 0.12204685668555737, 0.27516378978936173, 0.2822258570482149, 0.28505158617952064, 0.25065931338624436, 0.262158974091682, 0.2694896244050612, 0.2977843551178996, 0.2955255988209903, 0.30871864885230726, 0.1985474647943477, 0.19535756981598884, 0.19167934521373553, 0.2011029089484806, 0.186623635023897, 0.21062507181126744, 0.23050129862093216, 0.2213536959475192, 0.22109778307872396, 0.1861548191130491, 0.16755441552554728, 0.1778570840922028, 0.18233591467932497, 0.1621316722917443, 0.18248475737819403, 0.19628266180002596, 0.18615873374536962, 0.175255875275393, 0.1755976512335392, 0.21805162207435091, 0.21958320791614516, 0.17797136059531826, 0.25609012793836927, 0.17949669185914974, 0.18890628178808655, 0.2907313283362287, 0.2505433145394066, 0.16321919451502254, 0.6428200855453468, 0.11476373208806667, 0.1913902929734944, 0.1901494493681246, 0.19047986496634262, 0.17208051634452748, 0.16600671987745952, 0.18291103687042898, 0.08220506447416065, 0.19943697975458852, 0.1941265356361348, 0.20296379192648872, 0.16413569735410816, 0.19815280775858202, 0.19497083504544876, 0.115700465130948, 0.1947378539621749, 0.2318001084090362, 0.1879747511215698, 0.19060674639686104, 0.23555943061163087, 0.21154792882909146, 0.18085500472294336, 0.18610574892426857, 0.20883673769865163, 0.2021512808077799, 0.0751792485995264, 0.06456631744874508, 0.07996750429469957, 0.07942691682121727, 0.06099346644179782, 0.07428448522556697, 0.07054392568092405, 0.0819361572295404, 0.07524208452984438]}, "mutation_prompt": null}
{"id": "cd5cc250-398c-41be-9206-64c2079161c3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "f6f3f199-a361-42db-952e-21ce812b97df", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
{"id": "39ad1a4d-fad0-47c2-b5d7-710506fd8290", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.inertia_weight = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.0\n        self.mutation_factor = 0.8\n        self.recombination_rate = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(ind) for ind in positions])\n        global_best_position = positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight * (1 - evaluations / self.budget)\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (evaluations / self.budget)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * (evaluations / self.budget)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (inertia_weight * velocities\n                          + c1 * r1 * (personal_best_positions - positions)\n                          + c2 * r2 * (global_best_position - positions))\n            positions += velocities\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            scores = np.array([func(ind) for ind in positions])\n            evaluations += self.population_size\n\n            improved = scores < personal_best_scores\n            personal_best_scores[improved] = scores[improved]\n            personal_best_positions[improved] = positions[improved]\n\n            min_score_idx = np.argmin(personal_best_scores)\n            if personal_best_scores[min_score_idx] < global_best_score:\n                global_best_score = personal_best_scores[min_score_idx]\n                global_best_position = personal_best_positions[min_score_idx]\n\n            if evaluations + self.population_size <= self.budget:\n                for i in range(self.population_size):\n                    indices = list(range(self.population_size))\n                    indices.remove(i)\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = np.clip(personal_best_positions[a] \n                                            + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c]),\n                                            self.lower_bound, self.upper_bound)\n                    crossover_mask = np.random.rand(self.dim) < self.recombination_rate\n                    trial_vector = np.where(crossover_mask, mutant_vector, positions[i])\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_positions[i] = trial_vector\n                        personal_best_scores[i] = trial_score\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector\n\n        return global_best_position, global_best_score", "name": "EnhancedAdaptiveSwarmOptimizer", "description": "A hybrid swarm optimizer with adaptive parameters and local search enhancements for improved convergence.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ad8e8044-47b4-4b03-8cfd-ac43fcaf38ae", "metadata": {"aucs": [0.8609312903321995, 0.8578453454669658, 0.8552919132602705, 0.8606088264637428, 0.8579952946267198, 0.1907901099839705, 0.859534364013435, 0.8578261469616107, 0.8676210572215659, 0.738627852170999, 0.7320716073816418, 0.7179216335605261, 0.7127716357646507, 0.7544160097348108, 0.7436651703396788, 0.6952703814209029, 0.7414305744553649, 0.7482240292628715, 0.14261366957277188, 0.14915582493183233, 0.17692227831143337, 0.63398106089697, 0.1512153596831578, 0.14966834579810762, 0.17362218701111665, 0.10995373564403088, 0.6210306934571983, 0.12467602160878632, 0.12622067572528994, 0.1336425851754124, 0.1390218988548091, 0.17449097772644107, 0.10306891875675805, 0.152283740055301, 0.1194672207413392, 0.11614322287828838, 0.9899766218861814, 0.9838834016193109, 0.9903199522706531, 0.9726657590183533, 0.9806402383802718, 0.9890405916621575, 0.9890914512159552, 0.9871392380020082, 0.9907599129357533, 0.7655670289988178, 0.060057067534997954, 0.7639908533542958, 0.7450679614307987, 0.7318918622807288, 0.7637341887630192, 0.763019166758893, 0.7443825097191734, 0.7586549630499082, 0.8319513966860977, 0.8242239235259667, 0.8651804463474274, 0.870001484540532, 0.8085839548205107, 0.8509400432241373, 0.8426921156117955, 0.8003241982489078, 0.23184243762950285, 0.463597092935937, 0.5475610594408529, 0.5364689790110235, 0.49522197184933636, 0.6146485381015814, 0.5429577167289368, 0.5070224899947439, 0.5825691944650606, 0.5248761734058012, 0.4757481814151825, 0.1199148185450073, 0.48462044684684413, 0.1308257204181802, 0.5270147545890924, 0.5777027225824813, 0.5513398063345154, 0.35606076462220637, 0.542064448572394, 0.0781327572860886, 9.999999999998899e-05, 0.28753469317007707, 0.32888466690127793, 0.28771096679672314, 0.22863395475968895, 0.2636815922561032, 0.3275087163955249, 0.26180948952973937, 0.4546703719753654, 0.4708607005417893, 0.46912164276024126, 0.4110505010400033, 0.41529366377309807, 0.32482010685025275, 0.5014601505174272, 0.3562691028196706, 0.5085582643673479, 0.23297853936327206, 0.03382014812365708, 0.13516559416907004, 0.17502799965177784, 0.09409727296879222, 0.23396471924011142, 0.13953381263839348, 0.11171478736937046, 0.10068942808735282, 0.2830957276976731, 0.3062749402516375, 0.32262050643880724, 9.999999999998899e-05, 0.006409127194413333, 0.3068239765596795, 0.28266562219623037, 0.048795054700580986, 0.08237216787284996, 0.6950623171605319, 0.6919019975774101, 0.6998360465868186, 0.7518940244037757, 0.7381023713861965, 0.7028123740183063, 0.7294586949580468, 0.7068613216683821, 0.7382993058925746, 0.09121741477343148, 0.13993784994599212, 0.12180028086062866, 0.14545733661775317, 0.10776084632992511, 0.13840843283617943, 0.10793654536106512, 0.1036292456224932, 0.09123007028810493, 0.16620734617549093, 0.42260913086905116, 0.25852032219296583, 0.66393990256063, 0.6993390500315599, 0.5041477465483566, 0.22132092122103064, 0.31573469789308606, 0.23750944499330595, 0.3725525123371386, 0.5267573301165236, 0.43480602406806057, 0.7240668183673684, 0.5730673968301429, 0.42809116945944525, 0.515484492969325, 0.6048763998438, 0.5734156387381653, 0.26525397361476466, 0.27440441053177067, 0.3901076004694817, 0.3787953366417328, 0.3429413700506795, 0.3504794354752051, 0.37630514057253905, 0.3756312429917159, 0.45079578377775764, 0.22383024437200416, 0.22251353349956493, 0.21981932723794484, 0.22475190124048838, 0.23633765881671365, 0.2467508803494216, 0.20465336254204858, 0.23148632082015963, 0.2596137842985641, 0.19459241256337878, 0.19724123861548082, 0.2394336244469235, 0.20452100060503586, 0.20556411045455458, 0.22352412505477715, 0.20550559764634468, 0.7606032581525825, 0.24303403494141262, 0.8951936735573469, 0.8642190511759285, 0.16488383720038213, 0.17313035666580256, 0.20115870869163377, 0.8712602590313434, 0.09971678609792056, 0.16972130925617968, 0.19487161171575684, 0.8296830493731152, 0.21095344015203987, 0.12621927445770975, 0.7851951366320942, 0.8361751693647231, 0.21014244096362644, 0.19514347450149439, 0.8039068110627745, 0.845496324395025, 0.18526448549323082, 0.2224312128459326, 0.24556585564579747, 0.22387465902159942, 0.19334932910768543, 0.23538817692954894, 0.24915224596827024, 0.20461312745236193, 0.21346915497526897, 0.09574294804753913, 0.09389033929541069, 0.08474549197099879, 0.09412024452411694, 0.10349696629665028, 0.09009877514440523, 0.09693836265307543, 0.08218335030246726, 0.10124635008042682]}, "mutation_prompt": null}
