{"id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 28, in __call__\nTypeError: '<' not supported between instances of 'float' and 'list'\n.", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 28, in __call__\nTypeError: '<' not supported between instances of 'float' and 'list'\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "4fe21968-da01-4485-8773-f951480fa4fb", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.bandwidth = 0.5  # Bandwidth for selecting new harmonies based on memory\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.bandwidth:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive parameter tuning.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "f16f8ed6-e440-48d6-8b20-0b0924b427f1", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "c6cd0bb6-e842-4431-a514-ee8d50da50ce", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "257f7103-02fc-4a54-a7ba-6fafb97a1e85", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "2e5fea44-e08a-4112-81ef-3cd373bec76a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "2a1d8cf8-e045-4b4c-be51-82bd3861516b", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "6299c64e-198e-4f78-88bf-9a5124dbeaa3", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.bandwidth = 0.5\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n                    if np.random.rand() < 0.1:  # Adaptive pitch adjustment\n                        new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)\n\n                    new_harmony[i] = max(min(new_harmony[i], self.upper_bound), self.lower_bound)\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive pitch adjustment for enhanced convergence speed.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "2323c8a0-4765-4289-85c0-d5ee333f7f58", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "3ff6a74e-8674-4ef0-a2b4-353a62225cdf", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "0f2d040d-1eae-4c70-a681-514fc9987f32", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "92f6dde3-95c8-424e-b6b0-2e4e1398ee2a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.bandwidth = 0.5\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n                new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Improved Harmony Search Algorithm with adaptive parameter control for better exploration and exploitation balance.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "889efdfc-e1ee-4fb0-9890-2a5f0f6737f9", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "d45d0989-cdfd-4acc-a295-05970caa43f7", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "57f4c669-fcd1-4526-82bb-e96cb8bbaa16", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "6d8c898c-0a90-4101-b566-295baa1b310d", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.bandwidth = 1.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_harmony += np.random.normal(0, self.bandwidth, self.dim)\n            new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n            self.bandwidth *= 0.95  # Adaptive bandwidth control for balancing exploration and exploitation\n\n        return best_harmony", "name": "HarmonySearch", "description": "Improved Harmony Search Algorithm with adaptive bandwidth control for better exploration and exploitation balance.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "64b83b2b-02cc-465b-ac26-287781b2436a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "5ecc9a43-19d8-4811-9335-408e17ae6b8a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "66f19bd6-e022-41d0-be43-9a90563dc4be", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "908b8319-a0ae-40da-8886-e556ed0162c8", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "85d8f477-a278-424b-9719-ff1da13df76a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "3821214d-00fe-4514-a539-564d3f56519b", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "402a5f6a-f41b-4d2e-bb45-5d44ca95218e", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.bandwidth = 0.1\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n                if np.random.rand() < 0.1:  # Probabilistic pitch adjustment\n                    new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Improved Harmony Search Algorithm using a probabilistic pitch adjustment mechanism for better exploration.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "a72a918b-8d26-4560-b59b-fcf1d332318e", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "c9fc3bf6-3ddb-4c1d-96cd-c99b15650581", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "68a33998-6a61-468e-a8ba-2539fb960bbd", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "9e715d62-17a0-4018-b757-e7459cbd6da7", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.bandwidth = 0.5  # New parameter for adaptive pitch adjustment\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n                    new_harmony[i] += np.random.uniform(-self.bandwidth, self.bandwidth)  # Adaptive pitch adjustment\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Improved Harmony Search Algorithm by incorporating adaptive pitch adjustment to enhance exploration and exploitation balance.", "configspace": "", "generation": 26, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "79e53bb3-855b-4eef-b92e-b7a1b5cb561c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "4e92aa7a-c5e6-4805-9da2-5bc7fc760fdc", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "b78ac4e3-6e20-465d-a047-c2bfb3e59311", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "5f3f421b-4b6f-4859-bb55-2a5c91fcd42a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "78f68296-97d4-4acf-bb8b-9f94cc5e7a50", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "bc37324c-aa3b-4510-acdd-47de160197dc", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "dbf2924e-806d-4f00-812b-8a0bef4ac01c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "1e08c361-cc08-4cf6-906d-f079e0cf9ea5", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "373729bd-f800-4127-bda0-47dba13c2963", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.bandwidth = 0.5\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i], p=[self.bandwidth / (self.upper_bound - self.lower_bound)] * harmony_memory_size)\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Improved Harmony Search Algorithm with adaptive bandwidth selection for better exploration and exploitation balance.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "cffda4f8-39d3-4bc7-8f9f-22da80857af8", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "e190fc1a-eef8-4927-bb64-b154bbf4d208", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "5fa1261d-65ef-41fc-b20b-e1f3ca820dbd", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "4de6eabc-84ca-4c86-aded-c4f6d711a5fe", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "89e5fe8b-7172-40cf-832b-412c4bc8749b", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "a6e8855e-e229-4c8f-91a6-080cf0e409a1", "solution": "import numpy as np\n\nclass ImprovedHarmonySearch(HarmonySearch):\n    def __init__(self, budget, dim):\n        super().__init__(budget, dim)\n        self.bandwidth = 0.5\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.bandwidth:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n            self.bandwidth = max(0.3, self.bandwidth * 0.99)  # Adaptive bandwidth update\n\n        return best_harmony", "name": "ImprovedHarmonySearch", "description": "Improved Harmony Search algorithm with adaptive bandwidth for better exploration and exploitation balance.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "1cd380e8-73a3-4ab8-a482-6d7b4befca45", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "3fc0436c-5490-4cfd-8c3e-a4d56525b70b", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "878cce7e-0a56-4e05-bd3a-18781a8a025b", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "743fca90-3ede-4cbd-a9da-cdd20a650759", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "36bc3283-187d-45ac-bdfe-3acca3b49350", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "b556a33f-f56d-417c-aefc-b3e171e44ead", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "a324d403-3c2b-42ab-8757-0e9c87739cce", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "07715ec6-5655-4a86-ac1f-1a1cd1f1c0f8", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "4ffa787f-c338-4b6a-9ca0-fee85dedccc1", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "27dc1190-02aa-4fd5-b3db-7a06ff5f3795", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "91f46169-e627-48f8-9b1c-5cc3bbae06fe", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "640a52ca-218f-440a-a8d1-9624060e3b16", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "8b444f14-1c1c-46fa-9855-7195fb63ef5f", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "6b5ec0ae-6186-4cb2-bb70-6fe69393a757", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "0b3f0282-aa98-4e58-bfd7-2e03f43caafb", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "67d0554b-f0eb-4c87-8bbf-d4994662f02e", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "a493d895-acf2-4293-9f46-c8cba57cb61c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "f4a836ad-49ed-40d3-930c-dd5e7c47326a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "af2c2e1b-19ca-48f2-82ce-6ce023e6c64b", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.hmcr = 0.7  # Harmony Memory Consideration Rate\n        self.par = 0.3  # Pitch Adjustment Rate\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.hmcr:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n                if np.random.rand() < self.par:\n                    new_harmony[i] += np.random.uniform(-1, 1)\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive parameter control for better convergence.", "configspace": "", "generation": 60, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "10f2622a-82fd-4559-bdef-5f32710a8389", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "148c6cf6-41f0-4b2e-b896-aa8de5d09946", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "cc85b257-702d-4896-8be6-a366a98afceb", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "91542cb2-3c79-49ec-bcce-aa9c7a972e47", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "6c92f36b-4bfb-4af9-90d8-f2dad0560636", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "9bd62e33-bf1a-47f4-9a2b-a9c504da3dd0", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "f47f001b-929c-4a8d-b9a7-82e1fcd24d34", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "6dc7a433-2938-425e-a6d4-8894c6205b37", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "2e8e8666-fcc9-4059-a416-e314fb771201", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "6026a890-82d9-4623-ac1a-cda5c42da529", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "82e901be-569c-453f-a49d-f46d85a78eaa", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "6bf17b84-b1a8-4552-bda9-67455352e4f8", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "a02ab77d-96bf-4100-97b5-d29e19b493e3", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "8bfe5b11-ea2a-4799-a129-363f2bbc08f2", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "e2799a4f-f282-4088-bd2f-a64eb2d509a1", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "6b3dc80f-abc8-4a66-b17d-f9255e33d22c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "ed3e7bce-8e3c-4147-8141-bbcac1a437a3", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "97c9a8ab-aca0-473a-a9f9-d3443da03148", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.bandwidth = 1.0  # New adaptive bandwidth parameter\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.clip(new_harmony[i] + np.random.uniform(-self.bandwidth, self.bandwidth), self.lower_bound, self.upper_bound)  # Local search with adaptive band width\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Improved Harmony Search algorithm with adaptive band width for local search", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"'<' not supported between instances of 'float' and 'list'\").", "error": "TypeError(\"'<' not supported between instances of 'float' and 'list'\")", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "01ed8509-420b-4c8f-bd67-4a96b0b7df68", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "0b283a99-164e-4404-ab5b-3cd5a5755d1c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "8ca103cd-5637-4590-8049-29273a38429d", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "db49669a-6f18-422a-93a8-cd6a45f7b257", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "e7651848-b065-47f5-8468-1e89166867cc", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "a433c9c2-3da1-4f1d-81cf-8adb6630d56a", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "b1dc0a83-9dfb-4db5-a079-83e781f4a6c6", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "8ce977de-85e6-4d61-8f34-e36d3af9ce6c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "7a2a1247-78ec-4fea-b25f-bae8b3a08b81", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "607cf4c0-f274-4bb1-a9bc-c1bfde5a64cd", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "80630dd3-f994-4123-84d0-b6b24542079b", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "afd7c924-8278-4a7e-9f06-f161a3830c16", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "422dfc6c-354f-4736-8224-40925f4b605d", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "7f6dcc21-8e91-4927-b5f9-01a91027f434", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "10fa5530-877c-4d51-b462-2bbf9a7419b8", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "fe4f2bc8-33c9-45a8-bf53-98812c404989", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "993c588e-f628-4ad2-b102-93638060fd08", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "d9f51c79-62a2-4149-93bb-3ff6e98ad38c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "7c1dfe75-c95e-42e7-a429-0d3e4943f34c", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "cfc5f0c3-41dc-41a5-8e6f-65d24e992089", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
{"id": "3107528d-c52f-4191-b88d-aa8ee2064d58", "solution": "import numpy as np\n\nclass HarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        harmony_memory_size = 20\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (harmony_memory_size, self.dim))\n        best_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_fitness = np.inf\n\n        for _ in range(self.budget):\n            new_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < 0.7:\n                    new_harmony[i] = np.random.choice(harmony_memory[:, i])\n\n            new_fitness = func(new_harmony)\n            if new_fitness < best_fitness:\n                best_harmony = new_harmony\n                best_fitness = new_fitness\n\n            worst_idx = np.argmax(harmony_memory, axis=0)\n            if new_fitness < func(harmony_memory[worst_idx]):\n                harmony_memory[worst_idx] = new_harmony\n\n        return best_harmony", "name": "HarmonySearch", "description": "Harmony Search Algorithm - A metaheuristic algorithm inspired by the improvisation process of musicians to find optimal solutions by creating harmony among decision variables.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eaee0d84-09b3-451d-972e-f5658ce0bc46", "metadata": {}, "mutation_prompt": null}
