{"id": "cfb67ed3-57e7-4dbe-8e29-afabd32b0ca3", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 1, "fitness": 0.26508070779992, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "cfb67ed3-57e7-4dbe-8e29-afabd32b0ca3", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "2a52439c-6648-4120-b195-5b04811c4d50", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n            \n            # Adjust population size to enhance exploration\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = max(4, int(self.population_size * 0.95))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that incorporates adaptive population sizing to enhance exploration and convergence efficiency.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 98 is out of bounds for axis 0 with size 95').", "error": "IndexError('index 98 is out of bounds for axis 0 with size 95')", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {}, "mutation_prompt": null}
{"id": "07d53ce9-9d37-42d6-85d3-da30e6c35402", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.6  # adjusted initial mutation factor\n        self.CR = 0.85  # adjusted initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Refined adaptive strategy for F and CR\n                        self.F = np.clip(self.F + 0.015 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.015 * (np.random.rand() - 0.5), 0.7, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "A refined adaptive differential evolution algorithm with enhanced adaptive strategies for mutation and crossover rates to improve convergence speed and robustness.", "configspace": "", "generation": 3, "fitness": 0.22139888057503504, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.5328768380630093, 0.5442370851614926, 0.5342420551880923, 0.6032837197653185, 0.5340222510723877, 0.586012090280106, 0.5631241579983717, 0.5603272664205812, 0.5700481073063162, 0.2767870202870161, 0.2633556508098438, 0.2759594203017246, 0.25876670165325777, 0.25825385383043153, 0.2834928881518307, 0.2788914049038581, 0.23771097807968522, 0.2765304379715001, 0.10201885221430806, 0.09946684424551078, 0.09625699045954006, 0.08989435794996536, 0.09457488027140026, 0.09219639619987663, 0.09578197250724174, 0.09916887305560429, 0.08768318630421401, 0.08823347668407056, 0.08517921252425553, 0.08128558664558494, 0.09056207934177618, 0.07975229122945915, 0.0841848907584486, 0.08458042946889888, 0.08937001255766319, 0.08276968203954038, 0.8784846257373409, 0.9367300942781069, 0.919734012941567, 0.9084221067530657, 0.9246274830998513, 0.8715815595448692, 0.8978558458933041, 0.9388799577789567, 0.9298687253724159, 0.23308966196215652, 0.21016310906083036, 0.20891547913056108, 0.22458340111260144, 0.2225839224614662, 0.24389430962650993, 0.22081497101830438, 0.2423586913226673, 0.2103821885907109, 0.36297759133037766, 0.27688240202109704, 0.3272006943680813, 0.39582598467610364, 0.45507648172080173, 0.39259485435813646, 0.4769947000810377, 0.4821742054885696, 0.37058013560884306, 0.12470148853391094, 0.15649163526969823, 0.12864813386705243, 0.13027041609676493, 0.13034596090037465, 0.13156263802882062, 0.1368567151343526, 0.15215131154218287, 0.1408663427925756, 0.10712703323490036, 0.14571524987398332, 0.1444759645243643, 0.15530404766077155, 0.13054291332204426, 0.1547580865045436, 0.1338049843787894, 0.11672506890748047, 0.13417118905924053, 0.02729057418068337, 0.037463734461369635, 0.04884252990672555, 0.053956420467321964, 0.05061241767229019, 0.03120772006846617, 0.04322773167116889, 0.03182052726288387, 0.04589418651652344, 0.15777817704672958, 0.16948985707221398, 0.17700267519282165, 0.14406130463677091, 0.13286472311575104, 0.150564014775051, 0.17126171012760205, 0.19505499420963646, 0.18631316384089103, 0.016017419621143336, 0.012643562652688178, 0.006644063779423948, 0.01905996775899188, 0.017526581882557735, 0.017162618618250747, 0.007761558828358606, 0.003751568232967295, 0.017353736888362947, 0.09532334097106776, 0.11263959388843381, 0.12206569556545455, 0.10004805683128792, 0.11723104692918218, 0.12291051589275193, 0.10531409347337373, 0.09001671686281276, 0.11480603574427095, 0.4373116084280403, 0.40785759621526907, 0.4195199666865428, 0.4242764743419568, 0.4426660776170517, 0.43020677776962113, 0.4341640342735764, 0.43689567475864444, 0.442147994137684, 0.08725669945799219, 0.08578386441570984, 0.0783147757337943, 0.08831081006249042, 0.08461202366201104, 0.09158065775330704, 0.08240625666601442, 0.10482470330639748, 0.08442010990826798, 0.15371622226932136, 0.13298987360013925, 0.14874753558726772, 0.14281165721148592, 0.1419201288837456, 0.1558515180894623, 0.16456216725386053, 0.13859851037108362, 0.12918266981477733, 0.2745394297397036, 0.251085439939856, 0.25713753380600746, 0.2550370845592491, 0.2320691451139668, 0.24409201540364567, 0.26209563866061636, 0.2761470342986957, 0.2594649721228185, 0.17707360303849728, 0.18464412144581577, 0.18239730289329115, 0.1939271822312847, 0.1842267299183954, 0.17506397136235663, 0.1992110918339527, 0.18026982073405884, 0.20426834361928725, 0.18157480574394969, 0.19561191650186982, 0.18749749160263274, 0.18883924645160188, 0.19496294770675404, 0.1924212587409092, 0.1880912214938294, 0.18983244978375768, 0.19189927574503296, 0.18007411868166145, 0.1751847860509259, 0.16722800149105566, 0.18021410247778713, 0.17500018946799878, 0.17244317587885893, 0.18252645720219274, 0.18970993842898276, 0.1738059787751558, 0.18244660327809292, 0.17602435581444842, 0.20416061182409373, 0.174408378801726, 0.18588248532654983, 0.19018268323459298, 0.17373791022515483, 0.1820974086959235, 0.19781784092375065, 0.416183271024266, 0.19296279076686673, 0.19005474515012888, 0.17091173266670578, 0.16327948266742331, 0.26199161820301786, 0.4043562055976856, 0.3501144385474908, 0.2043246420767444, 0.17354915426159712, 0.18382869989144035, 0.17725070924686193, 0.19570402362538952, 0.17627102892515212, 0.18117208014708985, 0.186551779490724, 0.1869691104778446, 0.17986980821297116, 0.0657580650290116, 0.07067916378490469, 0.08075164129448309, 0.07534205577913267, 0.06850044978089731, 0.07555225056384263, 0.06988440887136327, 0.07620167637629671, 0.07511972908327735]}, "mutation_prompt": null}
{"id": "1736b9df-3afa-46c6-bda0-71be639bc3c1", "solution": "import numpy as np\n\nclass AdaptiveRestartDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n        self.restart_threshold = int(self.budget * 0.05)  # 5% of budget for stagnation detection\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        no_improvement_counter = 0\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        no_improvement_counter = 0\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n                else:\n                    no_improvement_counter += 1\n\n            # Restart if stagnation is detected\n            if no_improvement_counter > self.restart_threshold:\n                self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                self.fitness.fill(np.inf)\n                no_improvement_counter = 0\n        \n        return best", "name": "AdaptiveRestartDifferentialEvolution", "description": "An enhanced adaptive differential evolution algorithm integrating a global population restart strategy to prevent stagnation and maintain diversity.", "configspace": "", "generation": 4, "fitness": 0.21726929066025832, "feedback": "The algorithm AdaptiveRestartDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.578594070418319, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.3529383906032063, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09625921681416783, 0.09060416715004627, 0.09452999965653275, 0.08281936382021127, 0.07658416111695965, 0.09514483606653046, 0.13359997832321446, 0.08863685215411354, 0.08730271027054992, 0.08037629874260843, 0.06590288182553172, 0.06932395481560705, 0.07292667754831106, 0.08788054645116516, 0.07803925167455672, 0.08391615345075443, 0.06719080598445959, 0.06951475059347323, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.17813789503320332, 0.20697402109477636, 0.2840695727245136, 0.27661642898295735, 0.24380450042784396, 0.25662015823408124, 0.24863661438549844, 0.26569045511933964, 0.2073748751818062, 0.3171641181492715, 0.2330584452470662, 0.26230774700386283, 0.21899775277309386, 0.5757663476640754, 0.2863986761678634, 0.3367120585141534, 0.24036231882659853, 0.25421325089273616, 0.1245333120618678, 0.1084868616377116, 0.160532706226297, 0.10537040470010395, 0.11574129858174964, 0.14567530500160208, 0.11696846620990309, 0.12184981770061332, 0.13376605591648183, 0.1250730818137603, 0.16367513402010025, 0.08955246797124528, 0.18051552966637352, 0.1958121700982417, 0.17858460432344037, 0.17724286290896285, 0.08221916595208256, 0.16142411723690475, 9.999999999998899e-05, 0.12442849714647675, 0.01701720624264358, 0.14732895410250912, 0.058669497923471536, 0.006617877543466211, 0.006067150442342295, 0.0026281166810171452, 0.1390737619880381, 0.13228387136253272, 0.1818762026648254, 0.2656801507157175, 0.08500487425659753, 0.10832861441161912, 0.08274753670652679, 0.10539431627688123, 0.23331991444377553, 0.14170870424345938, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.055833855321992254, 0.015657511897952614, 0.004896439096976457, 9.999999999998899e-05, 9.999999999998899e-05, 0.011276604743292062, 0.08299645279408119, 0.15433122421633194, 0.07807089395978306, 0.09445555928978688, 0.14144764347437355, 0.19229281085340477, 0.07123785993567633, 0.09548231126101325, 0.09882150461647543, 0.4198806257649359, 0.38549693343579494, 0.47833670216119994, 0.43818890155538004, 0.43522065011258615, 0.4776185496637191, 0.4165997299277052, 0.5117190716373523, 0.4281518166458519, 0.1004813562105239, 0.10341225271697962, 0.08041879342046887, 0.08961678175866405, 0.08990288455776685, 0.0734085301600873, 0.07869023375900974, 0.07702448443634313, 0.07177139066049021, 0.14815187035752353, 0.1407443237298881, 0.14068950208074116, 0.13717626411470885, 0.1660168709645894, 0.1723409408740887, 0.12143188376364633, 0.14279002749370906, 0.12865780146202455, 0.24580567460467873, 0.26943894794098133, 0.2138989324009123, 0.25408894993279596, 0.242508772174708, 0.2508111747521262, 0.25508033913964134, 0.22383037002014594, 0.26872374852101844, 0.19605413916678915, 0.17271460655614024, 0.16305831303303808, 0.15129135940302874, 0.16475777690643556, 0.17966488718027085, 0.2019441183271824, 0.1654947652184241, 0.19296373288777735, 0.18231627101240355, 0.17362510026978728, 0.17372721535438052, 0.18038432219950007, 0.1706189073429767, 0.17378879264552216, 0.1742208425684736, 0.17729916668936496, 0.1893148750932685, 0.17100930934318326, 0.16415143998634607, 0.17027246581454947, 0.16469177108516575, 0.17154149451223, 0.16416973701804216, 0.18352186164944673, 0.16998310532398553, 0.1678682377281555, 0.17827330424649912, 0.19604583349493399, 0.17666221881075495, 0.19015933276370578, 0.1700011816403285, 0.1675910230983122, 0.15577509427723513, 0.14942565170503497, 0.16334592625759958, 0.1664368521394861, 0.17833614444894175, 0.2134952281653253, 0.17056481352837238, 0.13210955231122368, 0.16344910313940486, 0.15101232231416073, 0.18866535664790918, 0.19788705504998105, 0.1829279354100054, 0.17854171125246543, 0.18003705172213325, 0.17779330584300368, 0.18546628608618532, 0.18858101749037093, 0.1918507479350069, 0.18144675630918805, 0.18637878662640772, 0.07354207330738405, 0.06700321267925136, 0.06597487977531657, 0.06135112661137754, 0.07231340511791662, 0.09203618601678154, 0.06660135949881774, 0.07306884764136246, 0.061147365874002046]}, "mutation_prompt": null}
{"id": "b3479422-0a01-4f78-af11-b2faffcff5cb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "bde0c71f-80b6-4dc9-8679-fba3e7b42cc7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "36b9e8a8-9267-4f31-9255-7a028e41bb1b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "1056d5af-5e56-4c08-91e3-ce6098b77110", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "18beb6ae-dea2-4ec1-9200-85346f1d59b5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "983d880a-644c-475f-9c74-649c924f00a5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "45b56a45-21de-4715-a2b2-29051e957fc5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n        self.reset_interval = 0.1 * self.budget  # reset strategy interval\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % self.reset_interval == 0 and self.evaluations != 0:\n                self.F = 0.5  # reset mutation factor periodically\n                self.CR = 0.9\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive exploration by periodically resetting mutation factors and introducing diversity.", "configspace": "", "generation": 11, "fitness": 0.2642633168343321, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6170548544191866, 0.6344625175944052, 0.5925298744004905, 0.6761426881267127, 0.6409996714138448, 0.6321660988479443, 0.63547733042729, 0.6530016284391305, 0.6307473763040976, 0.3646538912071038, 0.33780162569891825, 0.35762463258997124, 0.35852475396271744, 0.37562914499166355, 0.3464011125656964, 0.3339247365545044, 0.38482661952984965, 0.3496253685504087, 0.10005001354016785, 0.09623624021053279, 0.1065114444162969, 0.09517703906447117, 0.09572383023829789, 0.10713201397349659, 0.1042355587256465, 0.11157840564081489, 0.11031954488395335, 0.08891347930942772, 0.08876701344822435, 0.0827448240849924, 0.0861752796951345, 0.08853856547528283, 0.09474622485054329, 0.09128071196327925, 0.08131353348249926, 0.0788675853668368, 0.9775088563126167, 0.8713195847258396, 0.828267327478542, 0.7311845216072808, 0.8151656389253452, 0.8174970989507633, 0.8344828923283232, 0.7167237554231972, 0.9454419527432444, 0.23924109298239682, 0.2644438259721762, 0.28351568410838945, 0.28510754682943973, 0.2762625212393629, 0.281488961989492, 0.2876074472362121, 0.2743739585338639, 0.282932316910547, 0.5836604163345992, 0.5507371441240314, 0.5999767825487375, 0.5781303235769981, 0.5536710703486858, 0.6012238686034532, 0.6334380593550109, 0.5664093514531587, 0.559446633076135, 0.21335124874948563, 0.19852974869435602, 0.1563952493015004, 0.17762098858789288, 0.1495035470911047, 0.16820825053156663, 0.19361222254368426, 0.18323787299471317, 0.1825041293354016, 0.16791616859677583, 0.17373266094254614, 0.1114473660471369, 0.16166053354110177, 0.1488833849097233, 0.16700139930363855, 0.15655390310210582, 0.1688264408951431, 0.14157297666680602, 0.16187829963517508, 0.1376781348651015, 0.14745962850360028, 0.12390911313037667, 0.17956158022422752, 0.15339921894113828, 0.17076279367565528, 0.16176112644617802, 0.15097236061533292, 0.29156951969574396, 0.26873803857191614, 0.2790562598040909, 0.2849869082715104, 0.286507525326535, 0.2455968348219224, 0.3143651462765865, 0.3030204458121075, 0.3230082448906303, 0.05340543701053013, 0.047320953910700125, 0.036585475082874463, 0.051658709025179106, 0.050042887059732366, 0.08623973450466471, 0.06874811570074402, 0.0819104043464165, 0.07578054155502156, 0.1470793633702493, 0.15192364646388246, 0.16371421009519016, 0.1769459155822366, 0.15568186827266817, 0.17195747011318874, 0.17309442053995427, 0.15805907831547372, 0.16989865982849028, 0.49765290810613105, 0.4786937864374282, 0.504478120746549, 0.5114472890014972, 0.5225115192928975, 0.49368918805801687, 0.48536774541366745, 0.4908219009685717, 0.48949976699093156, 0.10201776574343546, 0.08749214849154918, 0.09896729134915838, 0.09618230759453017, 0.08388544894972261, 0.08498374333796199, 0.09926492835992717, 0.11403910554532448, 0.07608722568868964, 0.15827263854713725, 0.13953652234828917, 0.14951650325689458, 0.1503828516634378, 0.1660168709645894, 0.17256098790960273, 0.13851084500257949, 0.1489289725458992, 0.13285162270162854, 0.3061064558934754, 0.30708214451084925, 0.3070174773284575, 0.30361680710952965, 0.28546814435085976, 0.28064270327411, 0.3287726500403826, 0.3185896163849047, 0.30373507368649333, 0.23751629181346534, 0.2245957934487427, 0.2438137398745711, 0.21564616604287534, 0.23006257775442396, 0.22338029156507, 0.24292747969762885, 0.24700971018980433, 0.2311947971941748, 0.1975685937315912, 0.17104046733874678, 0.19450248732376574, 0.19524063100208666, 0.20203907314264358, 0.22039016707791592, 0.18376264842297363, 0.18565777786795568, 0.1928485560254699, 0.17223637335634812, 0.17191301324229824, 0.18327842583087572, 0.17492743241731712, 0.17727583396069402, 0.1713416161407082, 0.18446384051648823, 0.17587061279079463, 0.18242262459740533, 0.551707125724385, 0.2568978151089173, 0.15874465106520763, 0.2890421381582112, 0.24032627037195042, 0.577238481399657, 0.16485618704919003, 0.1732536853347858, 0.4525740175812427, 0.19906250318652774, 0.192599689597726, 0.16158571337697236, 0.3513196243015313, 0.1848103077435137, 0.24156161671716292, 0.15096889460490237, 0.41274897059146864, 0.19538496835403107, 0.18245129859824516, 0.18370034715987205, 0.19198768788255127, 0.1928115521636954, 0.18582177559604696, 0.19616713070690917, 0.19775312000723233, 0.18052123584339863, 0.18656961565938146, 0.07703249250720523, 0.08413570932291603, 0.07691745912647552, 0.0711831910904479, 0.0730537986887041, 0.08191372472711278, 0.07592247064081947, 0.07617119300142183, 0.07046184343257478]}, "mutation_prompt": null}
{"id": "88c09449-1fd3-48a0-a760-362718f30a32", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n        self.no_improvement_counter = 0\n        self.restart_threshold = 50\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            improved = False\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        improved = True\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n            \n            if improved:\n                self.no_improvement_counter = 0\n            else:\n                self.no_improvement_counter += 1\n                if self.no_improvement_counter >= self.restart_threshold:\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness[:] = np.inf\n                    self.no_improvement_counter = 0\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhancing diversity by introducing a random restart mechanism when no improvement is detected for a number of generations.", "configspace": "", "generation": 12, "fitness": 0.2650459647840261, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.09891841910912702, 0.11292230815181048, 0.09944976056672217, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09165872290233823, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09208867742788007, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.1004813562105239, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.14815187035752353, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.1660168709645894, 0.1814983413931215, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.1897590301919787, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.19844201452637822, 0.1918507479350069, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "17da1f15-48d2-4453-980e-e249ddecc2e4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "29acc7f0-d74a-4771-8520-3c57e236c50a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "34922f27-8d3a-4d1b-bcc4-0a9ac9fcad05", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n            \n            # Calculate population diversity and adjust mutation factor\n            diversity = np.std(self.population)\n            self.F = np.clip(self.F + 0.02 * diversity, 0.4, 0.9)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced adaptive differential evolution algorithm that incorporates a dynamic adjustment of exploration and exploitation balance through a diversity-based strategy.", "configspace": "", "generation": 15, "fitness": 0.1722193504835454, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.32772154061023917, 0.34541580622309775, 0.32450566724538, 0.3672742224987553, 0.36787599316186115, 0.37083259883099495, 0.33912593440376537, 0.3748341092246894, 0.34008461441562177, 0.11284949369378483, 0.11157620151790582, 0.09866421252464841, 0.08428141282966495, 0.09257948250684744, 0.10691213797570343, 0.10991687354537394, 0.1103739283833971, 0.10236618023099386, 0.0848698883463167, 0.08904220568303767, 0.07950964890759571, 0.07996934227252872, 0.07692000495317575, 0.07616796931516423, 0.07742454863872594, 0.0872081058284393, 0.072348310762551, 0.06716498764135981, 0.06981318325992669, 0.06497008685918448, 0.07106736988999218, 0.06228209185431044, 0.0710392484581478, 0.06485383212697593, 0.05813858772950298, 0.060086440606334834, 0.9775088563126167, 0.927551146903779, 0.9475353722575164, 0.9028157537475886, 0.9533132842832615, 0.965397581366562, 0.8985283533237751, 0.9177247247933144, 0.9502766044598476, 0.14570540859217185, 0.14430180105385537, 0.14659730250470548, 0.14968788654837917, 0.14651315987857472, 0.13359642147476225, 0.16916166722252235, 0.15470348738705075, 0.165789260031049, 0.19884510532713828, 0.20926998815708386, 0.20278779722951823, 0.20359035683705007, 0.21729483153482165, 0.21566971293122184, 0.22517078257993928, 0.20928281643567492, 0.19662572237185272, 0.08095223460718803, 0.07519349254439534, 0.0735078024377932, 0.08319932751218262, 0.08077845212885382, 0.09599362968815517, 0.08317131203620798, 0.07870976661862572, 0.08662647672747714, 0.11587939670101188, 0.09726801960921805, 0.12103133358119211, 0.08655953194412591, 0.07488163667648007, 0.07806117642097432, 0.07936143053675226, 0.0566158820946433, 0.06977857995170211, 0.001604202193545512, 0.0015630877073000704, 0.0051129424519514854, 0.010502175199300301, 0.0007295790759836995, 0.005406802268429378, 0.01158285940018855, 0.00773254161553083, 0.0074911193666515885, 0.1030358348501359, 0.10802162084913525, 0.10524691098180938, 0.08936211409614425, 0.10332134785041214, 0.10538454976399503, 0.11334177338927742, 0.13055279259823438, 0.13412161074397644, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056484634265871136, 0.05088233222085403, 0.06185609322991659, 0.050350275176375026, 0.05859796756951219, 0.05210995192118517, 0.05486367263973402, 0.06533459149615906, 0.06511532661678487, 0.31036011092285654, 0.3018552131582224, 0.3033412738672765, 0.34035067455521384, 0.34014263081119533, 0.3357007804356591, 0.308517136539881, 0.30556815862940656, 0.32504166751065955, 0.06984735810808673, 0.08187795837567957, 0.07799255469488076, 0.07083130151154182, 0.07342130793338819, 0.0744395401644311, 0.07979705910243151, 0.07061684559476289, 0.05851780474186563, 0.12819161409875302, 0.14217676199449014, 0.13852978811241978, 0.13765933733929725, 0.15767609463449994, 0.17831376117065323, 0.15438367981944645, 0.1341664535642052, 0.1308344182271154, 0.2055892978818823, 0.20110893540450558, 0.21384896538292886, 0.18873610433368992, 0.1900726537131543, 0.18437762408333946, 0.2154265886004163, 0.21882665102146404, 0.20630672090333768, 0.1456413889664243, 0.15228750203018282, 0.17838877424109578, 0.14738143873455645, 0.1333608605816804, 0.14195112410336352, 0.14897806175750505, 0.137671048645982, 0.14845295673967407, 0.187350773082555, 0.17054949181409462, 0.17316175513328358, 0.1661794720305103, 0.16455348437171646, 0.1658789461534823, 0.1974268548398299, 0.18194894585491717, 0.1789351981778866, 0.1666579046419292, 0.15904396937399545, 0.16626102380744745, 0.16393583454361305, 0.1626918105528008, 0.16541854106874798, 0.16340161072227077, 0.15535924502389076, 0.16265536220356425, 0.1728801761884532, 0.1608876986603326, 0.29072667489509496, 0.2484156813409758, 0.21759509360160578, 0.21276386214269738, 0.2656390342266679, 0.15712763672222885, 0.20953891712001882, 0.19747655345460413, 0.15804355135315296, 0.1729866652250276, 0.19013283166834605, 0.18143732000318047, 0.15014366366546728, 0.19396060471856413, 0.18809896869618126, 0.3726286945226026, 0.18511772004220184, 0.19146246738135841, 0.19756998576839124, 0.18095116665350586, 0.18504513581019755, 0.19242097103462952, 0.19127818969096166, 0.17297092959622185, 0.19888768100485377, 0.06570212338041492, 0.05570382866291823, 0.055729963169844465, 0.06094998364476034, 0.056071451675775985, 0.062079677813321577, 0.06692835771052852, 0.06718899454649985, 0.0793796026571767]}, "mutation_prompt": null}
{"id": "9e2acc43-97c6-4567-bb9f-14b952c795c9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm that dynamically adjusts mutation and crossover rates to explore and exploit the search space effectively.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6259206789173952, 0.5849875713349926, 0.6205273855510037, 0.6358792956583181, 0.6507472206547362, 0.6403140204871054, 0.6438446977265709, 0.6181558668034123, 0.6306815797905445, 0.37922234833471113, 0.3633447651660333, 0.35185942215068455, 0.37232873684606327, 0.36576744372776326, 0.3508638597336906, 0.33646701272448043, 0.3767296701325611, 0.36248494666720754, 0.09913582106535668, 0.11797331650020837, 0.10403354972454504, 0.10243458657674731, 0.10115941801039441, 0.11292230815181048, 0.099592774053892, 0.10414671823044286, 0.10887460848528463, 0.08211961728813422, 0.09908306631142383, 0.07461207491866284, 0.08696984863720192, 0.09300080875710304, 0.0885222957944859, 0.10054377591909247, 0.08687816268751392, 0.09211919003662061, 0.9775088563126167, 0.8706037425013871, 0.8223089416515128, 0.8386403935390792, 0.8798188382536616, 0.8355103782056997, 0.82257436585104, 0.8726194836602114, 0.9454419527432444, 0.2355662409856093, 0.27642392858528186, 0.2840695727245136, 0.27661642898295735, 0.2732031469153783, 0.25662015823408124, 0.27695666490036264, 0.26569045511933964, 0.26468405551225127, 0.5471973914741007, 0.638986524886226, 0.5589244943387488, 0.5147337047566481, 0.5757663476640754, 0.6077356622824817, 0.5996843516967024, 0.5614392769684688, 0.559048469507041, 0.1502433688124566, 0.17298443486171222, 0.160532706226297, 0.16367757469756594, 0.16203334820255655, 0.14567530500160208, 0.17463923557468097, 0.15989757879750977, 0.17705550813360693, 0.14058312995479227, 0.16367513402010025, 0.1220174554570671, 0.18051552966637352, 0.1971790994974707, 0.17858460432344037, 0.17724286290896285, 0.16113835409837052, 0.16142411723690475, 0.14579954453857458, 0.14918291994482658, 0.1125391664043014, 0.1692570486395958, 0.1840579853590153, 0.13656923424411194, 0.1512608658914636, 0.1634027858234116, 0.14966559218700326, 0.2447014699129083, 0.2770538018743586, 0.31711057275156596, 0.25947963074884095, 0.2570586791800956, 0.24939750627093904, 0.2889487325832356, 0.3021963371409543, 0.3262077120885386, 0.032485105469422515, 0.05627147027512924, 0.03558879731012188, 0.055833855321992254, 0.04175700579338082, 0.03386825820867312, 0.03362722535083307, 0.04638095676935028, 0.05594890791348661, 0.1493679190543029, 0.1656228607588719, 0.1611190746616541, 0.16785037564182181, 0.15246068680478642, 0.19229281085340477, 0.17050831798547228, 0.14759249028752763, 0.16938627857002575, 0.49168779027477894, 0.4714868588693869, 0.5070565648288166, 0.498024382656296, 0.49493467909718525, 0.4776185496637191, 0.5096126204458897, 0.5117190716373523, 0.4872189919936354, 0.10199145804549459, 0.09535323505763948, 0.09237196896081767, 0.10360262826474176, 0.10242431242256245, 0.10018240063213524, 0.0940706319792074, 0.1114754882129888, 0.08530605523849577, 0.1513776809679077, 0.14099296108265502, 0.176582956681679, 0.15515912280073552, 0.18008180078007097, 0.17290605853502294, 0.13364257315716443, 0.15048818590322066, 0.14051805943717333, 0.3180521514235889, 0.29021080080242434, 0.28626596938624993, 0.290852585433786, 0.28299730664604705, 0.29730201130124934, 0.3118825132176716, 0.33286388842886516, 0.29755484365339013, 0.23905335843938702, 0.22598654589652056, 0.23917776604581764, 0.23056922397546264, 0.21774149225150807, 0.21707230973402547, 0.2392901436931294, 0.2281617241029663, 0.23207063856752363, 0.1845614186564909, 0.22399074344508296, 0.1806656487221069, 0.1888777545419077, 0.1807809944210419, 0.19848367415987933, 0.1767517051331603, 0.18724169589123518, 0.180528126373241, 0.1861093332679703, 0.17540612555824497, 0.18097575857629522, 0.17789035617597893, 0.17731483386171276, 0.1768414664120781, 0.17615872427903267, 0.1823157254177138, 0.17607366551313552, 0.5091060676096497, 0.3731217403113144, 0.17233554947174234, 0.2737925900368683, 0.2574071886566617, 0.5770690588211608, 0.20046061643353963, 0.23263675732761235, 0.48674268235481, 0.1997012404659554, 0.2504203576487103, 0.19483284457155436, 0.37144786638045746, 0.17588241668495375, 0.18396519450667925, 0.15101232231416073, 0.4193280065719467, 0.1962077475557722, 0.18902908211747682, 0.19016298574668777, 0.18392650180260994, 0.18350648731159924, 0.1849302675299086, 0.18936489326245032, 0.19406323482263266, 0.18613854347955794, 0.18517030213449992, 0.07359500028948895, 0.08473407411291067, 0.0885014264554278, 0.07477762355447026, 0.07733210141772273, 0.09203618601678154, 0.07430851784320625, 0.07247755843186965, 0.07837411780278403]}, "mutation_prompt": null}
{"id": "0aa46215-cc33-4595-abd8-a1b35542db8f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic population size to improve exploration and convergence.", "configspace": "", "generation": 17, "fitness": 0.2777846808240155, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "eb757c75-195d-48e1-9550-b3b0c4cea504", "metadata": {"aucs": [0.6833570264235399, 0.6456560945535844, 0.6589726951954895, 0.6544844656740696, 0.6599008695462987, 0.6702742251244275, 0.6479249102548639, 0.6583627487204571, 0.6715988167196096, 0.39154396081551046, 0.4257229752673799, 0.4234246435944986, 0.4038134932186793, 0.40802512166618177, 0.3893385256178754, 0.3937609788774614, 0.4074756643615982, 0.4121273506353229, 0.09516329356799347, 0.10311847232911064, 0.11240632585810095, 0.1161908554014408, 0.11396839193480612, 0.10741842206730923, 0.10110743293647395, 0.11079593488391748, 0.11917098614897115, 0.10631956528801034, 0.08983925491451106, 0.09785212875852722, 0.0916342596563876, 0.09161657868630269, 0.10109846047212845, 0.0896527134734777, 0.09503734667580122, 0.08938972368879328, 0.8921623851999437, 0.7894493364995774, 0.8486342639744158, 0.7182040654198969, 0.7230537371035108, 0.8711928257545096, 0.8997390674001836, 0.8114760159011931, 0.937198197093137, 0.27604386351121357, 0.3046097539237135, 0.2741021135394238, 0.2973413237141773, 0.3099430937045856, 0.2786394104865295, 0.3064708018391006, 0.32430930476306885, 0.28779614055664837, 0.5606037988269368, 0.6334051714102885, 0.5868563866813897, 0.6457058855646138, 0.6456358149085742, 0.6561901543590758, 0.6674137196499701, 0.6660305531824303, 0.6054860696601485, 0.20819503856622423, 0.16092557480800673, 0.18066270172053722, 0.169443361625491, 0.21034968539767473, 0.16949025258898842, 0.19581742851631512, 0.21665626455472842, 0.22464260563219907, 0.1932136305017671, 0.12278679754996424, 0.1972842339471077, 0.16128368999845355, 0.20704162477097665, 0.1787188513298512, 0.18689690060153163, 0.16732187658437503, 0.21969927035587444, 0.20281461496775488, 0.16685562436325252, 0.22921448978632375, 0.15670187606108044, 0.1770966127648408, 0.1614893555525141, 0.21322475895142046, 0.15701514173572795, 0.20881904622120473, 0.30826467564693716, 0.2609203495248331, 0.25446779475487313, 0.29272098454195816, 0.3011685142373107, 0.28694698232553273, 0.31824608787435293, 0.28624900725791036, 0.33381145556405367, 0.06926001216217648, 0.06578979801146756, 0.05741940586353389, 0.0735419220687209, 0.04039909815523879, 0.04854273387963115, 0.08314852708713294, 0.09362385784211202, 0.05250519942490428, 0.20695754852931525, 0.1647543827793312, 0.16844267940814894, 0.16862520675679005, 0.19496675944011688, 0.21088363383635622, 0.17478918269042298, 0.1876992118983979, 0.17896830725370017, 0.5304758402879959, 0.49009545509716823, 0.5330392832156305, 0.5109718427923238, 0.5536287060567059, 0.5271084344184607, 0.5283520871879926, 0.5461056713556565, 0.5336905868375401, 0.08988014927497934, 0.09200391944806396, 0.0926435336019178, 0.08322897776083626, 0.0928616454374882, 0.10291601008270623, 0.09888719819891378, 0.09638483901193795, 0.09498339808819933, 0.14549950729108296, 0.13051138868769452, 0.1531991747762106, 0.13129108059727257, 0.13932340146320088, 0.13684947013860804, 0.14910933817123218, 0.14094921224389345, 0.13486217628807662, 0.30537165864059157, 0.2973928023205943, 0.31260832390488946, 0.324988231128971, 0.298723708790134, 0.31436293981076946, 0.34521116577816957, 0.34199602206671276, 0.32518587283666867, 0.23891171612979245, 0.24521525982286219, 0.24183670065491347, 0.23710349948022302, 0.23949539398057496, 0.21342739331800875, 0.23457702097108823, 0.2487017179489881, 0.23974862744054648, 0.19112289041859631, 0.1983012270497827, 0.18581997776708514, 0.2047530629455523, 0.18098503630730378, 0.21248930029355595, 0.1868795917267213, 0.2261273178220773, 0.18010938293886758, 0.17749542155681142, 0.18602942977155257, 0.18048484168380308, 0.19284441648521133, 0.17877352563423465, 0.1864458151671733, 0.19545852781765471, 0.1835155832101334, 0.18035843107926341, 0.17793062559771156, 0.1934664870494699, 0.4798951649023575, 0.18006341040375917, 0.4165874062979308, 0.3284516360178521, 0.3770184587162554, 0.21484795935370782, 0.3367382704397359, 0.19314123584831533, 0.19188404678304327, 0.1620436605739023, 0.1776523336588749, 0.30652699471572065, 0.42723226299570516, 0.20626225938889187, 0.5715161558062729, 0.20421036709833285, 0.1812629492257175, 0.1892319810241101, 0.19913353075246998, 0.18728812816200102, 0.1723773878330076, 0.19328882255233626, 0.17462940913149028, 0.18437788140367706, 0.22102395986689205, 0.07684757632018879, 0.0753149370145767, 0.07871241533755124, 0.07327235579111235, 0.0760677072566015, 0.07153529072231957, 0.07430696373354695, 0.07639082809910147, 0.07724343969452585]}, "mutation_prompt": null}
{"id": "0e896bcb-6795-40bc-aaae-e2822bc83a8f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic population size to improve exploration and convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0aa46215-cc33-4595-abd8-a1b35542db8f", "metadata": {"aucs": [0.6833570264235399, 0.6456560945535844, 0.6589726951954895, 0.6544844656740696, 0.6599008695462987, 0.6702742251244275, 0.6479249102548639, 0.6583627487204571, 0.6715988167196096, 0.39154396081551046, 0.4257229752673799, 0.4234246435944986, 0.4038134932186793, 0.40802512166618177, 0.3893385256178754, 0.3937609788774614, 0.4074756643615982, 0.4121273506353229, 0.09516329356799347, 0.10311847232911064, 0.11240632585810095, 0.1161908554014408, 0.11396839193480612, 0.10741842206730923, 0.10110743293647395, 0.11079593488391748, 0.11917098614897115, 0.10631956528801034, 0.08983925491451106, 0.09785212875852722, 0.0916342596563876, 0.09161657868630269, 0.10109846047212845, 0.0896527134734777, 0.09503734667580122, 0.08938972368879328, 0.8921623851999437, 0.7894493364995774, 0.8486342639744158, 0.7182040654198969, 0.7230537371035108, 0.8711928257545096, 0.8997390674001836, 0.8114760159011931, 0.937198197093137, 0.27604386351121357, 0.3046097539237135, 0.2741021135394238, 0.2973413237141773, 0.3099430937045856, 0.2786394104865295, 0.3064708018391006, 0.32430930476306885, 0.28779614055664837, 0.5606037988269368, 0.6334051714102885, 0.5868563866813897, 0.6457058855646138, 0.6456358149085742, 0.6561901543590758, 0.6674137196499701, 0.6660305531824303, 0.6054860696601485, 0.20819503856622423, 0.16092557480800673, 0.18066270172053722, 0.169443361625491, 0.21034968539767473, 0.16949025258898842, 0.19581742851631512, 0.21665626455472842, 0.22464260563219907, 0.1932136305017671, 0.12278679754996424, 0.1972842339471077, 0.16128368999845355, 0.20704162477097665, 0.1787188513298512, 0.18689690060153163, 0.16732187658437503, 0.21969927035587444, 0.20281461496775488, 0.16685562436325252, 0.22921448978632375, 0.15670187606108044, 0.1770966127648408, 0.1614893555525141, 0.21322475895142046, 0.15701514173572795, 0.20881904622120473, 0.30826467564693716, 0.2609203495248331, 0.25446779475487313, 0.29272098454195816, 0.3011685142373107, 0.28694698232553273, 0.31824608787435293, 0.28624900725791036, 0.33381145556405367, 0.06926001216217648, 0.06578979801146756, 0.05741940586353389, 0.0735419220687209, 0.04039909815523879, 0.04854273387963115, 0.08314852708713294, 0.09362385784211202, 0.05250519942490428, 0.20695754852931525, 0.1647543827793312, 0.16844267940814894, 0.16862520675679005, 0.19496675944011688, 0.21088363383635622, 0.17478918269042298, 0.1876992118983979, 0.17896830725370017, 0.5304758402879959, 0.49009545509716823, 0.5330392832156305, 0.5109718427923238, 0.5536287060567059, 0.5271084344184607, 0.5283520871879926, 0.5461056713556565, 0.5336905868375401, 0.08988014927497934, 0.09200391944806396, 0.0926435336019178, 0.08322897776083626, 0.0928616454374882, 0.10291601008270623, 0.09888719819891378, 0.09638483901193795, 0.09498339808819933, 0.14549950729108296, 0.13051138868769452, 0.1531991747762106, 0.13129108059727257, 0.13932340146320088, 0.13684947013860804, 0.14910933817123218, 0.14094921224389345, 0.13486217628807662, 0.30537165864059157, 0.2973928023205943, 0.31260832390488946, 0.324988231128971, 0.298723708790134, 0.31436293981076946, 0.34521116577816957, 0.34199602206671276, 0.32518587283666867, 0.23891171612979245, 0.24521525982286219, 0.24183670065491347, 0.23710349948022302, 0.23949539398057496, 0.21342739331800875, 0.23457702097108823, 0.2487017179489881, 0.23974862744054648, 0.19112289041859631, 0.1983012270497827, 0.18581997776708514, 0.2047530629455523, 0.18098503630730378, 0.21248930029355595, 0.1868795917267213, 0.2261273178220773, 0.18010938293886758, 0.17749542155681142, 0.18602942977155257, 0.18048484168380308, 0.19284441648521133, 0.17877352563423465, 0.1864458151671733, 0.19545852781765471, 0.1835155832101334, 0.18035843107926341, 0.17793062559771156, 0.1934664870494699, 0.4798951649023575, 0.18006341040375917, 0.4165874062979308, 0.3284516360178521, 0.3770184587162554, 0.21484795935370782, 0.3367382704397359, 0.19314123584831533, 0.19188404678304327, 0.1620436605739023, 0.1776523336588749, 0.30652699471572065, 0.42723226299570516, 0.20626225938889187, 0.5715161558062729, 0.20421036709833285, 0.1812629492257175, 0.1892319810241101, 0.19913353075246998, 0.18728812816200102, 0.1723773878330076, 0.19328882255233626, 0.17462940913149028, 0.18437788140367706, 0.22102395986689205, 0.07684757632018879, 0.0753149370145767, 0.07871241533755124, 0.07327235579111235, 0.0760677072566015, 0.07153529072231957, 0.07430696373354695, 0.07639082809910147, 0.07724343969452585]}, "mutation_prompt": null}
{"id": "139cc7e7-1af6-4ac9-bebc-969a5dec094f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n        self.success_rate = 0.0  # Track success rate to adjust parameters\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            successful_trials = 0  # Track successful trials\n            \n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    successful_trials += 1  # Increment success count\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n            \n            # Adjust F and CR based on successful trials\n            self.success_rate = successful_trials / self.population_size\n            self.F = np.clip(self.F + 0.05 * (np.random.rand() - 0.5) * (1 if self.success_rate > 0.2 else -1), 0.4, 0.9)\n            self.CR = np.clip(self.CR + 0.05 * (np.random.rand() - 0.5) * (1 if self.success_rate > 0.2 else -1), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Optimized Differential Evolution using adaptive F and CR adjustments based on success rates.", "configspace": "", "generation": 19, "fitness": 0.2717319916833865, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "0aa46215-cc33-4595-abd8-a1b35542db8f", "metadata": {"aucs": [0.6955922969042783, 0.612129629802629, 0.624285597131662, 0.693826338859737, 0.6240345491863862, 0.6340011621519844, 0.6921012765806285, 0.6293361145655642, 0.6184036469509622, 0.44662085423417297, 0.337483388983711, 0.35297707615432583, 0.4609102174548777, 0.3166803822735095, 0.35668513384050227, 0.46669660071114527, 0.31885141753889135, 0.33246759784334357, 0.09699501191880322, 0.10375938299481235, 0.10757157438781417, 0.10443727919676427, 0.09949764945243567, 0.11487972313421546, 0.1121982761233663, 0.0932537249478641, 0.10764436862054683, 0.09016312882555777, 0.08659978160301618, 0.09303238241938305, 0.09067776631949531, 0.07854611619580265, 0.08679319670005226, 0.09396988626469593, 0.08553593001968784, 0.1006206218669593, 0.8247575264056297, 0.9098221509268294, 0.8233947729489025, 0.8678834107765232, 0.9026041730334581, 0.9183804618825153, 0.8983708526048652, 0.8625863949985808, 0.8573578904876338, 0.348996465201745, 0.26963894594748117, 0.23509208963039097, 0.3160757040652792, 0.2690495914532437, 0.278961657757549, 0.2976282672517968, 0.23777424939666303, 0.25616551026443646, 0.49194661233798753, 0.5212764363825975, 0.6668070533886897, 0.5114343246006812, 0.5299879781001527, 0.6173189456635706, 0.5331457064116735, 0.5563854432082733, 0.6870867012697117, 0.15843480718518188, 0.153856878583586, 0.2653566905039778, 0.14433293773774947, 0.1616123404419908, 0.24858646420812225, 0.13137559146353528, 0.16894846445421552, 0.22093092093045275, 0.1277120772036937, 0.09766676824225329, 0.19529998227121037, 0.16804769068002456, 0.17291810341653602, 0.23467642599310423, 0.17282060745876948, 0.14096325551573996, 0.18998930827810545, 0.040313678808165054, 0.09825455752228751, 0.1553317769106558, 0.25768362640372466, 0.15398841249581707, 0.1461325495740321, 0.21350724550782885, 0.1168046044686738, 0.2024551128809251, 0.17454296295431682, 0.24043195386112037, 0.31281130310850935, 0.13944781451007493, 0.22773987078703517, 0.22951492158774933, 0.17899412695015582, 0.2462478539312981, 0.3400272983063036, 0.08311129959795105, 0.022109768979176936, 0.09153939830929592, 0.0565345944837945, 0.012842670142427237, 0.030994843360002244, 0.09457650126427108, 0.020524198822647444, 0.09098847617460137, 0.1654801314321228, 0.1585116261439734, 0.20561195039356828, 0.17523744618526438, 0.13038432164763436, 0.20863513501940456, 0.14021466781839242, 0.13692096571459855, 0.1693627091719312, 0.5651638192388154, 0.4631420695160181, 0.5029173438707819, 0.5070477805379562, 0.4459782977439065, 0.5187426243730053, 0.5262074075484321, 0.468418815744722, 0.49522508645266083, 0.0934785032715717, 0.09185582852278096, 0.08629475731970992, 0.09818939035120544, 0.09565410442386546, 0.09388853414305287, 0.08809755596830893, 0.09937121080211642, 0.08664537344518508, 0.15182666962441604, 0.14803880567537087, 0.13985898304810052, 0.1261233330400482, 0.13980293143665767, 0.15056240053320324, 0.13434580442766997, 0.17719449209657046, 0.12460585727943685, 0.31829331039619724, 0.31435655451331646, 0.3378695085435848, 0.2892110884159321, 0.27955958357941435, 0.30528052379095083, 0.3596912546223342, 0.33603576987835115, 0.3631158248621197, 0.18833170614206807, 0.22221485200782987, 0.2549635406354399, 0.1920332457520334, 0.25633896546787716, 0.24633196113321942, 0.21904516051916978, 0.24492861225943297, 0.26410789325267536, 0.18424762834857045, 0.1741824285512572, 0.20124787168183467, 0.19701090433516932, 0.18919655074874275, 0.19805633050117522, 0.21713760594582687, 0.18094215136387626, 0.21471944901932016, 0.18245697618748558, 0.1749100534560224, 0.19295838179950586, 0.1732118767986507, 0.19004716388442744, 0.21277742354925544, 0.17741702140763715, 0.1854740182778446, 0.18487589786926406, 0.16653154608930376, 0.49697012190691636, 0.6013128233497452, 0.5069930189222065, 0.39196250309493386, 0.21373006413839746, 0.18924857438324705, 0.390087620335397, 0.23110683710972368, 0.184742788968, 0.39979807499988695, 0.1946440035514081, 0.21854624999350214, 0.2952060477239107, 0.36292875479563835, 0.545158657172564, 0.48880237163184537, 0.3652266222196042, 0.17989179381645404, 0.17172344375984172, 0.18815257591880974, 0.18081443088453475, 0.1831137044966603, 0.192425632262185, 0.20128081416845967, 0.18777129180806162, 0.18362297579953202, 0.08218308517680073, 0.07254349664782389, 0.07244394825412925, 0.06952242947884546, 0.07600968820418563, 0.07929324438788077, 0.07240539738647478, 0.07352908644335998, 0.07260152604342207]}, "mutation_prompt": null}
{"id": "e69e50a6-7001-4378-ba44-122d0f6f96f8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic F and CR adaptation for improved convergence.", "configspace": "", "generation": 20, "fitness": 0.30200222141623484, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.21.", "error": "", "parent_id": "0aa46215-cc33-4595-abd8-a1b35542db8f", "metadata": {"aucs": [0.7026268339767757, 0.6653659116157373, 0.7156150669675281, 0.7016602664035907, 0.6958931378339349, 0.6893772830262275, 0.701039800655223, 0.7068306394769848, 0.683690753191339, 0.47429452103882963, 0.47792679033082064, 0.4581149730533006, 0.48698242870714425, 0.4420796246729678, 0.4792028439465428, 0.4463292751105794, 0.45266711289389217, 0.47846710466630693, 0.10613930153062023, 0.11057262604554596, 0.12409139005951997, 0.0962006746012507, 0.10541782222774876, 0.11774530255878779, 0.10132457922767624, 0.11522106619009498, 0.10570780836746141, 0.0939071508608802, 0.10288203677505792, 0.09463685256733201, 0.09699571197078183, 0.1047638798431495, 0.10624959303027848, 0.09320611199267892, 0.09269142837445798, 0.11127962666183999, 0.7891748115416992, 0.808446234149556, 0.8286701328891686, 0.782362630297023, 0.8607015396340864, 0.8744648297082508, 0.755329051218393, 0.7319568311255207, 0.8382494897016828, 0.3276482501438659, 0.35703546661459984, 0.32898145684929614, 0.29595538256322973, 0.3019432283655664, 0.29261595518123773, 0.335476525332536, 0.31632051462685973, 0.33222395488965284, 0.6365740460582185, 0.682738396966144, 0.6584919716328419, 0.6552479635130087, 0.6614338125763304, 0.6600580187591731, 0.652153135182185, 0.7006663272290699, 0.5928678428305653, 0.1948359875632668, 0.15169893506011944, 0.2035943964395106, 0.17629131901857475, 0.1723441333019462, 0.15668859082886633, 0.1773371634073535, 0.18925482328859766, 0.18328531469374443, 0.1754268268432474, 0.14077698148189333, 0.26924833125585523, 0.19062524326905073, 0.20994322080330485, 0.16263521778166434, 0.15148315819680824, 0.18890155346921988, 0.19092322027393405, 0.2635801033806894, 0.21141950203777882, 0.14296790106084534, 0.24069442955700937, 0.20847560292907363, 0.19593073829694163, 0.2870229212779807, 0.20165762181445712, 0.19549796956914756, 0.4339399552930908, 0.2929276428522618, 0.35019322899729954, 0.31200304118910105, 0.33297767005817613, 0.39694695577656147, 0.39417779182314816, 0.36256611460153143, 0.3395363847667806, 0.06256230615025449, 0.1280885861649158, 0.08092683140857859, 0.10757581112246595, 0.08570099599561887, 0.08791805963263521, 0.07215501229960519, 0.07428894585119283, 0.062187885530606946, 0.2368799543210599, 0.19230192811768598, 0.2048529676398987, 0.2116628949637248, 0.228701582797892, 0.21618166101001313, 0.20686616003828917, 0.1998111944220774, 0.1792029789111479, 0.5743919471196506, 0.5341187214336496, 0.5698578445914954, 0.5678263982989292, 0.5778197460738881, 0.5619856507462624, 0.5906464226208921, 0.5492786328732974, 0.6025920835154563, 0.11433370942489596, 0.11416052323974202, 0.10149002596697287, 0.1086776693595537, 0.09835703201083401, 0.11775313507808316, 0.09339903082297862, 0.07987201739015581, 0.08584268378197446, 0.17176157988107021, 0.11919542749126322, 0.12901899342865686, 0.14858679186857204, 0.1366614028238411, 0.17218871470319863, 0.14859382514271313, 0.12409283392789239, 0.12794874748998752, 0.3465306027683259, 0.3561107592264512, 0.35169200025624314, 0.3418213337346776, 0.33878828502019775, 0.3337316479743433, 0.3761911445410213, 0.32501585219187223, 0.3330907561199604, 0.2492732953014003, 0.2573447237131108, 0.28828729455440816, 0.2570178766102402, 0.2391168403666415, 0.25694141422998495, 0.25476335237586123, 0.26065406464101626, 0.2538892197852327, 0.1743051313167131, 0.1843464028678814, 0.1954468772759982, 0.2083982742231788, 0.21012612053644564, 0.20559244156490397, 0.1845675843397131, 0.18581422476141496, 0.19332678092275013, 0.1874585237841957, 0.17763560012213964, 0.1843490140094427, 0.18591610713442408, 0.18644476528055198, 0.18797716238224815, 0.1801187062361851, 0.18939226270901177, 0.18115586918696125, 0.5260588455105237, 0.6485863537609151, 0.6735894096621222, 0.5239595418461306, 0.26159036591161033, 0.3894083392890484, 0.6809180400044976, 0.40475402790221504, 0.4871233573025242, 0.19171277748931015, 0.19532370113479258, 0.18838710573248119, 0.4822119217316565, 0.411268762174677, 0.19242082255383053, 0.5712744271606134, 0.2043108817638486, 0.20162032240528727, 0.18645821072471958, 0.17733461420135754, 0.20339032096095666, 0.1862999421356435, 0.17868605814869865, 0.18074235680698125, 0.17426579881360282, 0.18605362119080204, 0.18218589884275094, 0.0865493349463834, 0.07702580605104015, 0.09037713971942607, 0.07934288960201741, 0.0756633573738198, 0.07462771552999425, 0.07533160518475901, 0.08414731584679869, 0.07573405465069649]}, "mutation_prompt": null}
{"id": "cf86a388-b43e-462f-a076-f5029d6bb417", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n        self.success_count = np.zeros(self.population_size)  # Track improvements\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust parameters dynamically based on performance\n                avg_success_rate = np.mean(self.success_count / np.max(self.success_count))\n                self.F = np.clip(self.F * (1 + 0.1 * (avg_success_rate - 0.5)), 0.4, 0.9)\n                self.CR = np.clip(self.CR * (1 + 0.1 * (avg_success_rate - 0.5)), 0.8, 1.0)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    self.success_count[i] += 1\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic mutation factor and crossover rate based on success rates.", "configspace": "", "generation": 21, "fitness": 0.051628001051752366, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.05.", "error": "", "parent_id": "e69e50a6-7001-4378-ba44-122d0f6f96f8", "metadata": {"aucs": [0.11869729595922507, 0.12023113931555696, 0.09169502728636048, 0.13112642370491867, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07553714411058787, 0.1094008673217095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010834892625041559, 0.015169340368183293, 0.018911566204957708, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.0288090533811044, 0.007792397052521438, 0.010674738340807233, 9.999999999998899e-05, 9.999999999998899e-05, 0.01140668175185855, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.05881044770816646, 0.05823541065093363, 0.054877264043567076, 0.05331602884281661, 0.04865133012201606, 0.0639706079335367, 0.057803977829267716, 0.053494718807759134, 0.06274794416174423, 0.029078853981581276, 0.0188958639049861, 0.037102256751242346, 0.03923690144124814, 9.999999999998899e-05, 9.999999999998899e-05, 0.016675340803576577, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.059824388882108726, 0.0667108215001172, 0.07285119553694963, 0.08132921701227258, 0.049366521008575415, 0.05931056463008866, 0.10017772473897679, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004514399195837737, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12539741187488818, 0.15756555760738078, 0.16308692172496542, 0.11299707672965909, 0.10274288241579344, 0.12416483807742551, 0.16112956940342849, 0.12648358403994353, 0.1210557193025883, 0.013739533971539819, 0.023159114465262642, 0.02198412468535549, 0.03266886175302153, 0.0008380415396770369, 0.01759993274736349, 0.005932183898287424, 0.021948067854712816, 0.0267656688986897, 0.08494000004272673, 0.08609370886951495, 0.11842175776965747, 0.13766266535167793, 0.13511880823300437, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.0798722905190411, 0.11985149873023437, 0.12244191735429832, 0.1613932299901244, 0.13800672315110074, 0.1362913836684968, 0.161856142914947, 0.1219584187816024, 0.17377774300845283, 0.11544443549682837, 0.05985564337097804, 0.05884243066818107, 0.08398582550377798, 0.06286377713170932, 0.06633611147388963, 0.09793549997287943, 0.0837317855149382, 0.0997711199450243, 0.06766106901929891, 0.11943364695601921, 0.10491313827275839, 0.13345086981233123, 0.11551405703943707, 0.10248497347293928, 0.10896891037713907, 0.12245976138762271, 0.10201798564705933, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12680551929410044, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16207881422481074, 0.10630450851969886, 0.08967513334876764, 0.10161371339885394, 0.09360775873740623, 0.1207914665021157, 0.06995893837844436, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10838827416952768, 0.06932034027342138, 0.08059276491351852, 0.03738259240699027, 0.0794872468536234, 0.07376503436009862, 0.05346335986028028, 0.04699248306696513, 0.13480174570059533, 0.1608614726286951, 0.148124017676316, 0.14552268903905985, 0.1282201447801723, 0.13994288924415266, 0.14969714796693134, 0.15308535452138583, 0.14689007985489466, 0.027007085248150542, 0.024813730588825633, 0.031393493129599714, 0.027015293023570086, 0.03425093938292756, 0.0388165651178235, 0.031077609664734718, 0.03803354422653826, 0.02489289782248183]}, "mutation_prompt": null}
{"id": "c5a88fc3-aef4-40d9-a3ae-66ea1ed8bea2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n        self.prev_best_fitness = np.inf\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                # Add momentum adaptation to F for smooth transitions\n                if self.prev_best_fitness < self.fitness[best_idx]:\n                    self.F = np.clip(self.F * 0.95, 0.4, 0.9)\n                self.prev_best_fitness = self.fitness[best_idx]\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with momentum-based parameter adaptation for balanced exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.2777846808240155, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "e69e50a6-7001-4378-ba44-122d0f6f96f8", "metadata": {"aucs": [0.6833570264235399, 0.6456560945535844, 0.6589726951954895, 0.6544844656740696, 0.6599008695462987, 0.6702742251244275, 0.6479249102548639, 0.6583627487204571, 0.6715988167196096, 0.39154396081551046, 0.4257229752673799, 0.4234246435944986, 0.4038134932186793, 0.40802512166618177, 0.3893385256178754, 0.3937609788774614, 0.4074756643615982, 0.4121273506353229, 0.09516329356799347, 0.10311847232911064, 0.11240632585810095, 0.1161908554014408, 0.11396839193480612, 0.10741842206730923, 0.10110743293647395, 0.11079593488391748, 0.11917098614897115, 0.10631956528801034, 0.08983925491451106, 0.09785212875852722, 0.0916342596563876, 0.09161657868630269, 0.10109846047212845, 0.0896527134734777, 0.09503734667580122, 0.08938972368879328, 0.8921623851999437, 0.7894493364995774, 0.8486342639744158, 0.7182040654198969, 0.7230537371035108, 0.8711928257545096, 0.8997390674001836, 0.8114760159011931, 0.937198197093137, 0.27604386351121357, 0.3046097539237135, 0.2741021135394238, 0.2973413237141773, 0.3099430937045856, 0.2786394104865295, 0.3064708018391006, 0.32430930476306885, 0.28779614055664837, 0.5606037988269368, 0.6334051714102885, 0.5868563866813897, 0.6457058855646138, 0.6456358149085742, 0.6561901543590758, 0.6674137196499701, 0.6660305531824303, 0.6054860696601485, 0.20819503856622423, 0.16092557480800673, 0.18066270172053722, 0.169443361625491, 0.21034968539767473, 0.16949025258898842, 0.19581742851631512, 0.21665626455472842, 0.22464260563219907, 0.1932136305017671, 0.12278679754996424, 0.1972842339471077, 0.16128368999845355, 0.20704162477097665, 0.1787188513298512, 0.18689690060153163, 0.16732187658437503, 0.21969927035587444, 0.20281461496775488, 0.16685562436325252, 0.22921448978632375, 0.15670187606108044, 0.1770966127648408, 0.1614893555525141, 0.21322475895142046, 0.15701514173572795, 0.20881904622120473, 0.30826467564693716, 0.2609203495248331, 0.25446779475487313, 0.29272098454195816, 0.3011685142373107, 0.28694698232553273, 0.31824608787435293, 0.28624900725791036, 0.33381145556405367, 0.06926001216217648, 0.06578979801146756, 0.05741940586353389, 0.0735419220687209, 0.04039909815523879, 0.04854273387963115, 0.08314852708713294, 0.09362385784211202, 0.05250519942490428, 0.20695754852931525, 0.1647543827793312, 0.16844267940814894, 0.16862520675679005, 0.19496675944011688, 0.21088363383635622, 0.17478918269042298, 0.1876992118983979, 0.17896830725370017, 0.5304758402879959, 0.49009545509716823, 0.5330392832156305, 0.5109718427923238, 0.5536287060567059, 0.5271084344184607, 0.5283520871879926, 0.5461056713556565, 0.5336905868375401, 0.08988014927497934, 0.09200391944806396, 0.0926435336019178, 0.08322897776083626, 0.0928616454374882, 0.10291601008270623, 0.09888719819891378, 0.09638483901193795, 0.09498339808819933, 0.14549950729108296, 0.13051138868769452, 0.1531991747762106, 0.13129108059727257, 0.13932340146320088, 0.13684947013860804, 0.14910933817123218, 0.14094921224389345, 0.13486217628807662, 0.30537165864059157, 0.2973928023205943, 0.31260832390488946, 0.324988231128971, 0.298723708790134, 0.31436293981076946, 0.34521116577816957, 0.34199602206671276, 0.32518587283666867, 0.23891171612979245, 0.24521525982286219, 0.24183670065491347, 0.23710349948022302, 0.23949539398057496, 0.21342739331800875, 0.23457702097108823, 0.2487017179489881, 0.23974862744054648, 0.19112289041859631, 0.1983012270497827, 0.18581997776708514, 0.2047530629455523, 0.18098503630730378, 0.21248930029355595, 0.1868795917267213, 0.2261273178220773, 0.18010938293886758, 0.17749542155681142, 0.18602942977155257, 0.18048484168380308, 0.19284441648521133, 0.17877352563423465, 0.1864458151671733, 0.19545852781765471, 0.1835155832101334, 0.18035843107926341, 0.17793062559771156, 0.1934664870494699, 0.4798951649023575, 0.18006341040375917, 0.4165874062979308, 0.3284516360178521, 0.3770184587162554, 0.21484795935370782, 0.3367382704397359, 0.19314123584831533, 0.19188404678304327, 0.1620436605739023, 0.1776523336588749, 0.30652699471572065, 0.42723226299570516, 0.20626225938889187, 0.5715161558062729, 0.20421036709833285, 0.1812629492257175, 0.1892319810241101, 0.19913353075246998, 0.18728812816200102, 0.1723773878330076, 0.19328882255233626, 0.17462940913149028, 0.18437788140367706, 0.22102395986689205, 0.07684757632018879, 0.0753149370145767, 0.07871241533755124, 0.07327235579111235, 0.0760677072566015, 0.07153529072231957, 0.07430696373354695, 0.07639082809910147, 0.07724343969452585]}, "mutation_prompt": null}
{"id": "263cc073-86a6-4652-a81e-4b0194b2d5fe", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                # Introduce adaptive random sampling in mutation\n                rand_sample = np.random.uniform(-5, 5, self.dim)\n                mutant = np.clip(a + self.F * (b - c) + 0.1 * rand_sample, -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive random sampling during mutation to enhance exploration capabilities and diversify search space.", "configspace": "", "generation": 23, "fitness": 0.18572705016034743, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "e69e50a6-7001-4378-ba44-122d0f6f96f8", "metadata": {"aucs": [0.3583779016540817, 0.34958850067136393, 0.35193627426512863, 0.36111121332539053, 0.3467075588558646, 0.34365963278732525, 0.3260031510779018, 0.36417177335583595, 0.3323378070033174, 0.003964417936047737, 0.0006458282200499932, 9.999999999998899e-05, 0.011119249674407361, 0.011590757499925552, 0.013082385408600072, 0.00048687373674660694, 0.005475884496452643, 0.022547670397839337, 0.10908553279343647, 0.10107701444637951, 0.09531781089121283, 0.09809662377254713, 0.10830959614212043, 0.09809366580851797, 0.10403351073173783, 0.1032757694504477, 0.10291430695118176, 0.08321111512787283, 0.08843690523841674, 0.08181840935926799, 0.08850489661191929, 0.0799245187226656, 0.09685965541304853, 0.09327606071420291, 0.08067137377526956, 0.08217803608480534, 0.932874816861359, 0.8627292584713052, 0.899504106375675, 0.9024611966636957, 0.9351291603880457, 0.8484461310776414, 0.8600772276604824, 0.9107162056043935, 0.8298617664900974, 0.1828494934894095, 0.17739253885732653, 0.21269457409196102, 0.2088289314619327, 0.1993554079549683, 0.20403860110901206, 0.19158975159972658, 0.21011349904361454, 0.187191742593394, 0.24919014084981594, 0.22218007208849855, 0.23391376337226344, 0.2684323249395848, 0.256664461080098, 0.2615526445012616, 0.24925346378729174, 0.2328911377756394, 0.2902478170024597, 0.13000293945408936, 0.1235159127716755, 0.1228611801515106, 0.1160291331045128, 0.11293469499736397, 0.13400383317638576, 0.10929595486005705, 0.11880414122072702, 0.1280796752967357, 0.10713507214899787, 0.13183751522175313, 0.11340691227916722, 0.1314483729000181, 0.1439002453755025, 0.1306716709269955, 0.12127549067300736, 0.13393007390483835, 0.1441451206629003, 0.02095175189505627, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09666333211938505, 0.06140513033786177, 0.08253528554266609, 0.06791377347490091, 0.11620193605821627, 0.06825878713028033, 0.1173086691614168, 0.07583394223180273, 0.07907105763164968, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06585301503535124, 0.06773469585744174, 0.0636441435380124, 0.06270269774733173, 0.07618783098110182, 0.06800432448793126, 0.07414761171918594, 0.05643991505184365, 0.07182266713035879, 0.33579611845558066, 0.34479785276596153, 0.3393226405508185, 0.33977576687911093, 0.3204623228664497, 0.33610564223719963, 0.32852816484176106, 0.34312264345919763, 0.3427834480146996, 0.08485107907147904, 0.09469184007355247, 0.09359573354435236, 0.08303078931601071, 0.10506133967478692, 0.0964526481998419, 0.08857142826690156, 0.08801023008901099, 0.08804161842182823, 0.13008617881195028, 0.13917166453368013, 0.15858165749189446, 0.135781573771518, 0.16044917201325426, 0.16584082440537784, 0.14385446349277442, 0.12499049502893889, 0.13942633134198346, 0.2541778120145778, 0.24549955781250965, 0.24220138521525614, 0.24146982627105085, 0.24315015297586162, 0.24642940516443157, 0.24454715276912797, 0.25556346425480136, 0.2407526650497972, 0.17364509454403454, 0.18296927225956927, 0.1779557998714748, 0.18086141503597908, 0.16222522624636682, 0.18106668580240903, 0.1857614902224023, 0.17838736808144695, 0.18440656373641617, 0.20038855022382718, 0.1939069484896757, 0.20019052964991846, 0.18841221584864631, 0.19365479894141813, 0.17914546607501403, 0.1854582729791847, 0.20528561641719367, 0.19349417783054157, 0.1810497781881989, 0.17610453340290788, 0.1751152454188295, 0.18064436865078348, 0.17546030468433405, 0.1711609561180938, 0.1837809597453014, 0.17706602307499708, 0.18026418720355109, 0.2769342714256291, 0.36708277521806065, 0.3245537307140677, 0.380637856822421, 0.3527177217112819, 0.286738969254801, 0.3313312935542182, 0.3473033298211733, 0.1667608549048173, 0.26367669086663525, 0.2901384525287143, 0.2214270388469064, 0.25243148711399344, 0.23099759977526313, 0.18647666571113064, 0.20006455554447322, 0.20244094764685028, 0.2033133766950478, 0.17497946724377778, 0.19127347939114603, 0.18682379715770203, 0.18789792467527555, 0.21499825656564264, 0.17508337047355982, 0.1910001748679535, 0.17744401851510028, 0.18180779628452126, 0.07171865787282061, 0.07391247328009742, 0.08560234706845715, 0.07240563462365024, 0.07615981261268823, 0.06960230069492734, 0.07345209356195315, 0.07445895789005241, 0.07472729196007988]}, "mutation_prompt": null}
{"id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Stochastic Adaptive Differential Evolution with periodic reinitialization to enhance exploration-exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.3092175291662179, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "e69e50a6-7001-4378-ba44-122d0f6f96f8", "metadata": {"aucs": [0.7026268339767757, 0.6773810415186622, 0.7038549693971967, 0.7016602664035907, 0.6946779429295518, 0.712621925237794, 0.701039800655223, 0.7102842836440815, 0.6883153319101745, 0.47429452103882963, 0.4683809124498086, 0.48603972638847526, 0.4869052081046752, 0.47092234102151986, 0.46374395485197073, 0.44612442562588317, 0.4994459790883182, 0.5020092715832774, 0.10613930153062023, 0.11202253112287786, 0.10086699022838164, 0.0962006746012507, 0.11343598073248018, 0.10375617649675228, 0.10132457922767624, 0.10019804919067388, 0.10870929732496681, 0.0939071508608802, 0.1018209903842171, 0.09117719787638123, 0.09699571197078183, 0.09755346728926984, 0.09043664769212412, 0.09320611199267892, 0.10214158694094388, 0.09096915395630223, 0.7891748115416992, 0.8536968478486159, 0.8456020679398626, 0.782362630297023, 0.9518168809359636, 0.8651674810445391, 0.755329051218393, 0.7754015121037893, 0.9079386963650734, 0.3255870189003779, 0.3382681956442143, 0.28984680864446977, 0.29595538256322973, 0.29985140370618113, 0.3128080334186083, 0.33521654374336907, 0.32137628615019476, 0.2951787852562183, 0.6365740460582185, 0.6524046345063796, 0.7011740731728827, 0.6552479635130087, 0.5941926361205278, 0.690729659944326, 0.652153135182185, 0.7111117373065508, 0.5909498509732443, 0.19470768246780668, 0.1982991382752214, 0.2321280030320052, 0.17629131901857475, 0.18035151599291388, 0.15490654886548094, 0.1773371634073535, 0.20639874679651116, 0.22775859654526465, 0.1754691562349302, 0.21582443912962135, 0.16489600501715085, 0.19062524326905073, 0.17736993668181367, 0.17736863039479045, 0.15148033769096925, 0.19232187210243223, 0.17334375187371187, 0.2625415453635219, 0.25097550044187855, 0.22532240867419207, 0.24069442955700937, 0.18279075605659056, 0.21469863099892283, 0.28569064734193195, 0.19976980835838676, 0.20644023128749012, 0.43730564845185393, 0.37900290843890594, 0.31099973782081125, 0.31200304118910105, 0.30946122059583214, 0.32191768470246696, 0.39352351268328156, 0.3750631621978814, 0.3892545408077641, 0.06256230615025449, 0.055595110181177354, 0.07390655318763262, 0.10757581112246595, 0.14620081600189283, 0.10428006692693503, 0.07215501229960519, 0.07947266716774959, 0.09422169731346297, 0.2368799543210599, 0.20535810138086452, 0.21501600242068375, 0.2116628949637248, 0.2492973584011401, 0.21796512715783456, 0.20686616003828917, 0.17992845690675185, 0.21069142374793903, 0.5741147364493852, 0.5293554274290598, 0.5786375302615985, 0.5678263982989292, 0.5679743774859491, 0.5497616517734107, 0.5906464226208921, 0.5765673990080746, 0.5814108975881421, 0.11433370942489596, 0.10044643917611995, 0.10838979048458919, 0.1086776693595537, 0.09013173730174528, 0.09646819612874136, 0.09339903082297862, 0.08669853940672778, 0.09858297963439178, 0.17176157988107021, 0.13573489836644692, 0.1482758908536207, 0.14858679186857204, 0.1363953042260393, 0.1778718736678193, 0.14859382514271313, 0.14233623447641897, 0.15991683739349516, 0.3465306027683259, 0.3415816282784052, 0.3607241425050318, 0.34195999961163814, 0.3372171879301852, 0.33966239380454166, 0.3761911445410213, 0.37122443859890486, 0.3486532268733423, 0.2492732953014003, 0.238535313992139, 0.25928342065805465, 0.25943797199444474, 0.2654406441649588, 0.2730580226119955, 0.25476335237586123, 0.2823674437954832, 0.2557875469588664, 0.1743051313167131, 0.21473463915143243, 0.1976599707455431, 0.2083982742231788, 0.1851043529656381, 0.2012485445059211, 0.1845675843397131, 0.1990656789096068, 0.1961835520325672, 0.1874585237841957, 0.19414326118200098, 0.1815339394174862, 0.18591610713442408, 0.1778557023007945, 0.19291799796383713, 0.1801187062361851, 0.1915778398223712, 0.19140661201952047, 0.5260588455105237, 0.5225038637916894, 0.6116964951673375, 0.5239595418461306, 0.47395266460662233, 0.41478960411679, 0.6809180400044976, 0.5157612496026325, 0.3331582197782881, 0.19171277748931015, 0.5561518865400501, 0.19191383899721182, 0.4822119217316565, 0.5538100987305319, 0.5010589662828961, 0.5712744271606134, 0.20135731885322916, 0.20287866137981503, 0.18645821072471958, 0.19370783587793283, 0.17869247778759922, 0.1862999421356435, 0.19862500821056217, 0.1699966898555666, 0.17426579881360282, 0.18287558926349512, 0.187100994730526, 0.0865493349463834, 0.07982606058307029, 0.08730512091032305, 0.07934288960201741, 0.08135406982669735, 0.0872756264923924, 0.07533160518475901, 0.07771668169598012, 0.08403404752777133]}, "mutation_prompt": null}
{"id": "32f0611c-ced6-48e7-884c-a773ecd0c41d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Stochastic Adaptive Differential Evolution with periodic reinitialization to enhance exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.7026268339767757, 0.6773810415186622, 0.7038549693971967, 0.7016602664035907, 0.6946779429295518, 0.712621925237794, 0.701039800655223, 0.7102842836440815, 0.6883153319101745, 0.47429452103882963, 0.4683809124498086, 0.48603972638847526, 0.4869052081046752, 0.47092234102151986, 0.46374395485197073, 0.44612442562588317, 0.4994459790883182, 0.5020092715832774, 0.10613930153062023, 0.11202253112287786, 0.10086699022838164, 0.0962006746012507, 0.11343598073248018, 0.10375617649675228, 0.10132457922767624, 0.10019804919067388, 0.10870929732496681, 0.0939071508608802, 0.1018209903842171, 0.09117719787638123, 0.09699571197078183, 0.09755346728926984, 0.09043664769212412, 0.09320611199267892, 0.10214158694094388, 0.09096915395630223, 0.7891748115416992, 0.8536968478486159, 0.8456020679398626, 0.782362630297023, 0.9518168809359636, 0.8651674810445391, 0.755329051218393, 0.7754015121037893, 0.9079386963650734, 0.3255870189003779, 0.3382681956442143, 0.28984680864446977, 0.29595538256322973, 0.29985140370618113, 0.3128080334186083, 0.33521654374336907, 0.32137628615019476, 0.2951787852562183, 0.6365740460582185, 0.6524046345063796, 0.7011740731728827, 0.6552479635130087, 0.5941926361205278, 0.690729659944326, 0.652153135182185, 0.7111117373065508, 0.5909498509732443, 0.19470768246780668, 0.1982991382752214, 0.2321280030320052, 0.17629131901857475, 0.18035151599291388, 0.15490654886548094, 0.1773371634073535, 0.20639874679651116, 0.22775859654526465, 0.1754691562349302, 0.21582443912962135, 0.16489600501715085, 0.19062524326905073, 0.17736993668181367, 0.17736863039479045, 0.15148033769096925, 0.19232187210243223, 0.17334375187371187, 0.2625415453635219, 0.25097550044187855, 0.22532240867419207, 0.24069442955700937, 0.18279075605659056, 0.21469863099892283, 0.28569064734193195, 0.19976980835838676, 0.20644023128749012, 0.43730564845185393, 0.37900290843890594, 0.31099973782081125, 0.31200304118910105, 0.30946122059583214, 0.32191768470246696, 0.39352351268328156, 0.3750631621978814, 0.3892545408077641, 0.06256230615025449, 0.055595110181177354, 0.07390655318763262, 0.10757581112246595, 0.14620081600189283, 0.10428006692693503, 0.07215501229960519, 0.07947266716774959, 0.09422169731346297, 0.2368799543210599, 0.20535810138086452, 0.21501600242068375, 0.2116628949637248, 0.2492973584011401, 0.21796512715783456, 0.20686616003828917, 0.17992845690675185, 0.21069142374793903, 0.5741147364493852, 0.5293554274290598, 0.5786375302615985, 0.5678263982989292, 0.5679743774859491, 0.5497616517734107, 0.5906464226208921, 0.5765673990080746, 0.5814108975881421, 0.11433370942489596, 0.10044643917611995, 0.10838979048458919, 0.1086776693595537, 0.09013173730174528, 0.09646819612874136, 0.09339903082297862, 0.08669853940672778, 0.09858297963439178, 0.17176157988107021, 0.13573489836644692, 0.1482758908536207, 0.14858679186857204, 0.1363953042260393, 0.1778718736678193, 0.14859382514271313, 0.14233623447641897, 0.15991683739349516, 0.3465306027683259, 0.3415816282784052, 0.3607241425050318, 0.34195999961163814, 0.3372171879301852, 0.33966239380454166, 0.3761911445410213, 0.37122443859890486, 0.3486532268733423, 0.2492732953014003, 0.238535313992139, 0.25928342065805465, 0.25943797199444474, 0.2654406441649588, 0.2730580226119955, 0.25476335237586123, 0.2823674437954832, 0.2557875469588664, 0.1743051313167131, 0.21473463915143243, 0.1976599707455431, 0.2083982742231788, 0.1851043529656381, 0.2012485445059211, 0.1845675843397131, 0.1990656789096068, 0.1961835520325672, 0.1874585237841957, 0.19414326118200098, 0.1815339394174862, 0.18591610713442408, 0.1778557023007945, 0.19291799796383713, 0.1801187062361851, 0.1915778398223712, 0.19140661201952047, 0.5260588455105237, 0.5225038637916894, 0.6116964951673375, 0.5239595418461306, 0.47395266460662233, 0.41478960411679, 0.6809180400044976, 0.5157612496026325, 0.3331582197782881, 0.19171277748931015, 0.5561518865400501, 0.19191383899721182, 0.4822119217316565, 0.5538100987305319, 0.5010589662828961, 0.5712744271606134, 0.20135731885322916, 0.20287866137981503, 0.18645821072471958, 0.19370783587793283, 0.17869247778759922, 0.1862999421356435, 0.19862500821056217, 0.1699966898555666, 0.17426579881360282, 0.18287558926349512, 0.187100994730526, 0.0865493349463834, 0.07982606058307029, 0.08730512091032305, 0.07934288960201741, 0.08135406982669735, 0.0872756264923924, 0.07533160518475901, 0.07771668169598012, 0.08403404752777133]}, "mutation_prompt": null}
{"id": "c8f8c23e-cf8c-4e8c-9aca-a8bcdecebd82", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Stochastic Adaptive Differential Evolution with periodic reinitialization to enhance exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.7026268339767757, 0.6773810415186622, 0.7038549693971967, 0.7016602664035907, 0.6946779429295518, 0.712621925237794, 0.701039800655223, 0.7102842836440815, 0.6883153319101745, 0.47429452103882963, 0.4683809124498086, 0.48603972638847526, 0.4869052081046752, 0.47092234102151986, 0.46374395485197073, 0.44612442562588317, 0.4994459790883182, 0.5020092715832774, 0.10613930153062023, 0.11202253112287786, 0.10086699022838164, 0.0962006746012507, 0.11343598073248018, 0.10375617649675228, 0.10132457922767624, 0.10019804919067388, 0.10870929732496681, 0.0939071508608802, 0.1018209903842171, 0.09117719787638123, 0.09699571197078183, 0.09755346728926984, 0.09043664769212412, 0.09320611199267892, 0.10214158694094388, 0.09096915395630223, 0.7891748115416992, 0.8536968478486159, 0.8456020679398626, 0.782362630297023, 0.9518168809359636, 0.8651674810445391, 0.755329051218393, 0.7754015121037893, 0.9079386963650734, 0.3255870189003779, 0.3382681956442143, 0.28984680864446977, 0.29595538256322973, 0.29985140370618113, 0.3128080334186083, 0.33521654374336907, 0.32137628615019476, 0.2951787852562183, 0.6365740460582185, 0.6524046345063796, 0.7011740731728827, 0.6552479635130087, 0.5941926361205278, 0.690729659944326, 0.652153135182185, 0.7111117373065508, 0.5909498509732443, 0.19470768246780668, 0.1982991382752214, 0.2321280030320052, 0.17629131901857475, 0.18035151599291388, 0.15490654886548094, 0.1773371634073535, 0.20639874679651116, 0.22775859654526465, 0.1754691562349302, 0.21582443912962135, 0.16489600501715085, 0.19062524326905073, 0.17736993668181367, 0.17736863039479045, 0.15148033769096925, 0.19232187210243223, 0.17334375187371187, 0.2625415453635219, 0.25097550044187855, 0.22532240867419207, 0.24069442955700937, 0.18279075605659056, 0.21469863099892283, 0.28569064734193195, 0.19976980835838676, 0.20644023128749012, 0.43730564845185393, 0.37900290843890594, 0.31099973782081125, 0.31200304118910105, 0.30946122059583214, 0.32191768470246696, 0.39352351268328156, 0.3750631621978814, 0.3892545408077641, 0.06256230615025449, 0.055595110181177354, 0.07390655318763262, 0.10757581112246595, 0.14620081600189283, 0.10428006692693503, 0.07215501229960519, 0.07947266716774959, 0.09422169731346297, 0.2368799543210599, 0.20535810138086452, 0.21501600242068375, 0.2116628949637248, 0.2492973584011401, 0.21796512715783456, 0.20686616003828917, 0.17992845690675185, 0.21069142374793903, 0.5741147364493852, 0.5293554274290598, 0.5786375302615985, 0.5678263982989292, 0.5679743774859491, 0.5497616517734107, 0.5906464226208921, 0.5765673990080746, 0.5814108975881421, 0.11433370942489596, 0.10044643917611995, 0.10838979048458919, 0.1086776693595537, 0.09013173730174528, 0.09646819612874136, 0.09339903082297862, 0.08669853940672778, 0.09858297963439178, 0.17176157988107021, 0.13573489836644692, 0.1482758908536207, 0.14858679186857204, 0.1363953042260393, 0.1778718736678193, 0.14859382514271313, 0.14233623447641897, 0.15991683739349516, 0.3465306027683259, 0.3415816282784052, 0.3607241425050318, 0.34195999961163814, 0.3372171879301852, 0.33966239380454166, 0.3761911445410213, 0.37122443859890486, 0.3486532268733423, 0.2492732953014003, 0.238535313992139, 0.25928342065805465, 0.25943797199444474, 0.2654406441649588, 0.2730580226119955, 0.25476335237586123, 0.2823674437954832, 0.2557875469588664, 0.1743051313167131, 0.21473463915143243, 0.1976599707455431, 0.2083982742231788, 0.1851043529656381, 0.2012485445059211, 0.1845675843397131, 0.1990656789096068, 0.1961835520325672, 0.1874585237841957, 0.19414326118200098, 0.1815339394174862, 0.18591610713442408, 0.1778557023007945, 0.19291799796383713, 0.1801187062361851, 0.1915778398223712, 0.19140661201952047, 0.5260588455105237, 0.5225038637916894, 0.6116964951673375, 0.5239595418461306, 0.47395266460662233, 0.41478960411679, 0.6809180400044976, 0.5157612496026325, 0.3331582197782881, 0.19171277748931015, 0.5561518865400501, 0.19191383899721182, 0.4822119217316565, 0.5538100987305319, 0.5010589662828961, 0.5712744271606134, 0.20135731885322916, 0.20287866137981503, 0.18645821072471958, 0.19370783587793283, 0.17869247778759922, 0.1862999421356435, 0.19862500821056217, 0.1699966898555666, 0.17426579881360282, 0.18287558926349512, 0.187100994730526, 0.0865493349463834, 0.07982606058307029, 0.08730512091032305, 0.07934288960201741, 0.08135406982669735, 0.0872756264923924, 0.07533160518475901, 0.07771668169598012, 0.08403404752777133]}, "mutation_prompt": null}
{"id": "d4abaffe-6f6d-4dd8-8b22-38a0abee1ce0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Stochastic Adaptive Differential Evolution with periodic reinitialization to enhance exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.7026268339767757, 0.6773810415186622, 0.7038549693971967, 0.7016602664035907, 0.6946779429295518, 0.712621925237794, 0.701039800655223, 0.7102842836440815, 0.6883153319101745, 0.47429452103882963, 0.4683809124498086, 0.48603972638847526, 0.4869052081046752, 0.47092234102151986, 0.46374395485197073, 0.44612442562588317, 0.4994459790883182, 0.5020092715832774, 0.10613930153062023, 0.11202253112287786, 0.10086699022838164, 0.0962006746012507, 0.11343598073248018, 0.10375617649675228, 0.10132457922767624, 0.10019804919067388, 0.10870929732496681, 0.0939071508608802, 0.1018209903842171, 0.09117719787638123, 0.09699571197078183, 0.09755346728926984, 0.09043664769212412, 0.09320611199267892, 0.10214158694094388, 0.09096915395630223, 0.7891748115416992, 0.8536968478486159, 0.8456020679398626, 0.782362630297023, 0.9518168809359636, 0.8651674810445391, 0.755329051218393, 0.7754015121037893, 0.9079386963650734, 0.3255870189003779, 0.3382681956442143, 0.28984680864446977, 0.29595538256322973, 0.29985140370618113, 0.3128080334186083, 0.33521654374336907, 0.32137628615019476, 0.2951787852562183, 0.6365740460582185, 0.6524046345063796, 0.7011740731728827, 0.6552479635130087, 0.5941926361205278, 0.690729659944326, 0.652153135182185, 0.7111117373065508, 0.5909498509732443, 0.19470768246780668, 0.1982991382752214, 0.2321280030320052, 0.17629131901857475, 0.18035151599291388, 0.15490654886548094, 0.1773371634073535, 0.20639874679651116, 0.22775859654526465, 0.1754691562349302, 0.21582443912962135, 0.16489600501715085, 0.19062524326905073, 0.17736993668181367, 0.17736863039479045, 0.15148033769096925, 0.19232187210243223, 0.17334375187371187, 0.2625415453635219, 0.25097550044187855, 0.22532240867419207, 0.24069442955700937, 0.18279075605659056, 0.21469863099892283, 0.28569064734193195, 0.19976980835838676, 0.20644023128749012, 0.43730564845185393, 0.37900290843890594, 0.31099973782081125, 0.31200304118910105, 0.30946122059583214, 0.32191768470246696, 0.39352351268328156, 0.3750631621978814, 0.3892545408077641, 0.06256230615025449, 0.055595110181177354, 0.07390655318763262, 0.10757581112246595, 0.14620081600189283, 0.10428006692693503, 0.07215501229960519, 0.07947266716774959, 0.09422169731346297, 0.2368799543210599, 0.20535810138086452, 0.21501600242068375, 0.2116628949637248, 0.2492973584011401, 0.21796512715783456, 0.20686616003828917, 0.17992845690675185, 0.21069142374793903, 0.5741147364493852, 0.5293554274290598, 0.5786375302615985, 0.5678263982989292, 0.5679743774859491, 0.5497616517734107, 0.5906464226208921, 0.5765673990080746, 0.5814108975881421, 0.11433370942489596, 0.10044643917611995, 0.10838979048458919, 0.1086776693595537, 0.09013173730174528, 0.09646819612874136, 0.09339903082297862, 0.08669853940672778, 0.09858297963439178, 0.17176157988107021, 0.13573489836644692, 0.1482758908536207, 0.14858679186857204, 0.1363953042260393, 0.1778718736678193, 0.14859382514271313, 0.14233623447641897, 0.15991683739349516, 0.3465306027683259, 0.3415816282784052, 0.3607241425050318, 0.34195999961163814, 0.3372171879301852, 0.33966239380454166, 0.3761911445410213, 0.37122443859890486, 0.3486532268733423, 0.2492732953014003, 0.238535313992139, 0.25928342065805465, 0.25943797199444474, 0.2654406441649588, 0.2730580226119955, 0.25476335237586123, 0.2823674437954832, 0.2557875469588664, 0.1743051313167131, 0.21473463915143243, 0.1976599707455431, 0.2083982742231788, 0.1851043529656381, 0.2012485445059211, 0.1845675843397131, 0.1990656789096068, 0.1961835520325672, 0.1874585237841957, 0.19414326118200098, 0.1815339394174862, 0.18591610713442408, 0.1778557023007945, 0.19291799796383713, 0.1801187062361851, 0.1915778398223712, 0.19140661201952047, 0.5260588455105237, 0.5225038637916894, 0.6116964951673375, 0.5239595418461306, 0.47395266460662233, 0.41478960411679, 0.6809180400044976, 0.5157612496026325, 0.3331582197782881, 0.19171277748931015, 0.5561518865400501, 0.19191383899721182, 0.4822119217316565, 0.5538100987305319, 0.5010589662828961, 0.5712744271606134, 0.20135731885322916, 0.20287866137981503, 0.18645821072471958, 0.19370783587793283, 0.17869247778759922, 0.1862999421356435, 0.19862500821056217, 0.1699966898555666, 0.17426579881360282, 0.18287558926349512, 0.187100994730526, 0.0865493349463834, 0.07982606058307029, 0.08730512091032305, 0.07934288960201741, 0.08135406982669735, 0.0872756264923924, 0.07533160518475901, 0.07771668169598012, 0.08403404752777133]}, "mutation_prompt": null}
{"id": "92b1f005-2945-476e-b654-3045254f5117", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            fitness_variance = np.var(self.fitness)  # Calculate fitness variance\n            adjusted_CR = self.CR * (1 + (fitness_variance / (np.abs(np.mean(self.fitness)) + 1e-8)))\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < adjusted_CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by introducing adaptive scaling of crossover rate based on fitness variance to improve exploration-exploitation.", "configspace": "", "generation": 28, "fitness": 0.13830793078552162, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.18.", "error": "", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.11869729595922507, 0.7159263640621683, 0.09169502728636048, 0.13112642370491867, 0.7007929603568912, 0.11042008850345264, 0.0998473575412605, 0.6890414282231156, 0.1094008673217095, 9.999999999998899e-05, 0.4772603466451423, 9.999999999998899e-05, 9.999999999998899e-05, 0.42175635006203505, 9.999999999998899e-05, 9.999999999998899e-05, 0.49376976075557, 9.999999999998899e-05, 0.009789823877150217, 0.1025270861559271, 0.018911566204957708, 0.010643411704069683, 0.08896969373475172, 0.006669962766643223, 0.018603296811771308, 0.10424815960831457, 0.010674738340807233, 9.999999999998899e-05, 0.10279896315980153, 9.999999999998899e-05, 0.01959972157639278, 0.08683995070181005, 9.999999999998899e-05, 0.014763392921912755, 0.09555510710804116, 9.999999999998899e-05, 0.045179741609489454, 0.6662357188660455, 0.04287777107098589, 0.054877264043567076, 0.763031124514782, 0.04865133012201606, 0.0639706079335367, 0.6651426156092604, 0.053494718807759134, 0.06274794416174423, 0.3345903650843721, 9.999999999998899e-05, 0.037102256751242346, 0.37251918887781854, 9.999999999998899e-05, 9.999999999998899e-05, 0.3353811080974848, 9.999999999998899e-05, 0.10027683525177622, 0.7116863578025311, 0.059824388882108726, 0.0667108215001172, 0.7795094664695859, 0.08132921701227258, 0.049366521008575415, 0.7217096674996284, 0.10017772473897679, 9.999999999998899e-05, 0.2305162479000561, 9.999999999998899e-05, 9.999999999998899e-05, 0.18905223367040014, 9.999999999998899e-05, 9.999999999998899e-05, 0.21341257588865603, 9.999999999998899e-05, 9.999999999998899e-05, 0.16476268959450613, 9.999999999998899e-05, 9.999999999998899e-05, 0.23125263115608075, 9.999999999998899e-05, 9.999999999998899e-05, 0.3214674308579144, 9.999999999998899e-05, 9.999999999998899e-05, 0.35708502669732867, 9.999999999998899e-05, 9.999999999998899e-05, 0.3273871542724477, 9.999999999998899e-05, 9.999999999998899e-05, 0.3105879689389056, 9.999999999998899e-05, 9.999999999998899e-05, 0.4310722906030142, 0.004514399195837737, 9.999999999998899e-05, 0.4900959080730156, 9.999999999998899e-05, 9.999999999998899e-05, 0.42364666450647115, 9.999999999998899e-05, 9.999999999998899e-05, 0.11684517769674041, 9.999999999998899e-05, 9.999999999998899e-05, 0.2157252594245025, 9.999999999998899e-05, 9.999999999998899e-05, 0.15731009073402913, 9.999999999998899e-05, 9.999999999998899e-05, 0.24437796290286307, 9.999999999998899e-05, 9.999999999998899e-05, 0.24462868708050955, 9.999999999998899e-05, 9.999999999998899e-05, 0.21373452490438094, 9.999999999998899e-05, 0.12539741187488818, 0.5950186746616484, 0.16308692172496542, 0.11299707672965909, 0.5813194175303174, 0.12416483807742551, 0.16112956940342849, 0.5830347753066147, 0.1210557193025883, 0.013739533971539819, 0.08589329914466814, 0.02198412468535549, 0.03266886175302153, 0.12312685716375948, 0.01759993274736349, 9.999999999998899e-05, 0.10373654111123776, 0.0267656688986897, 0.08494000004272673, 0.1854156213645448, 0.11842175776965747, 0.13766266535167793, 0.14264971606602705, 0.10798713552628325, 0.08808199726801991, 0.15827036309594045, 0.0798722905190411, 0.11985149873023437, 0.343616557063422, 0.1613932299901244, 0.13800672315110074, 0.3260170134363417, 0.161856142914947, 0.1219584187816024, 0.35139916412393624, 0.11544443549682837, 0.05985564337097804, 0.27358729493648226, 0.08398582550377798, 0.058279853167365614, 0.26981193298039774, 0.09793549997287943, 0.0837317855149382, 0.26239902468410203, 0.06766106901929891, 0.11943364695601921, 0.19196347000696823, 0.13345086981233123, 0.1103568689991713, 0.18224622323603423, 0.10896891037713907, 0.12245976138762271, 0.20771727569243614, 0.1261963614278906, 9.999999999998899e-05, 0.18318045176150066, 9.999999999998899e-05, 9.999999999998899e-05, 0.1970666082518907, 9.999999999998899e-05, 9.999999999998899e-05, 0.178463226372084, 9.999999999998899e-05, 0.10630450851969886, 0.1897192667798594, 0.10161371339885394, 0.09360775873740623, 0.6879221843223768, 0.06995893837844436, 0.1070176662487543, 0.1805445294329293, 0.0693612576838919, 0.11040265245322212, 0.5599455809284655, 0.06932034027342138, 0.08059276491351852, 0.16014545997917362, 0.0794872468536234, 0.07376503436009862, 0.20804786671769637, 0.04699248306696513, 0.13480174570059533, 0.1852825101868747, 0.148124017676316, 0.14552268903905985, 0.18436605767095193, 0.13994288924415266, 0.14969714796693134, 0.1891467981936643, 0.14689007985489466, 0.027007085248150542, 0.08735134186999327, 0.031393493129599714, 0.027015293023570086, 0.08980307800857557, 0.0388165651178235, 0.02672016584536452, 0.08887755790679963, 0.02489289782248183]}, "mutation_prompt": null}
{"id": "f21da12d-0ace-402d-ac18-e7fbcecfaff7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Stochastic Adaptive Differential Evolution with periodic reinitialization to enhance exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.7026268339767757, 0.6773810415186622, 0.7038549693971967, 0.7016602664035907, 0.6946779429295518, 0.712621925237794, 0.701039800655223, 0.7102842836440815, 0.6883153319101745, 0.47429452103882963, 0.4683809124498086, 0.48603972638847526, 0.4869052081046752, 0.47092234102151986, 0.46374395485197073, 0.44612442562588317, 0.4994459790883182, 0.5020092715832774, 0.10613930153062023, 0.11202253112287786, 0.10086699022838164, 0.0962006746012507, 0.11343598073248018, 0.10375617649675228, 0.10132457922767624, 0.10019804919067388, 0.10870929732496681, 0.0939071508608802, 0.1018209903842171, 0.09117719787638123, 0.09699571197078183, 0.09755346728926984, 0.09043664769212412, 0.09320611199267892, 0.10214158694094388, 0.09096915395630223, 0.7891748115416992, 0.8536968478486159, 0.8456020679398626, 0.782362630297023, 0.9518168809359636, 0.8651674810445391, 0.755329051218393, 0.7754015121037893, 0.9079386963650734, 0.3255870189003779, 0.3382681956442143, 0.28984680864446977, 0.29595538256322973, 0.29985140370618113, 0.3128080334186083, 0.33521654374336907, 0.32137628615019476, 0.2951787852562183, 0.6365740460582185, 0.6524046345063796, 0.7011740731728827, 0.6552479635130087, 0.5941926361205278, 0.690729659944326, 0.652153135182185, 0.7111117373065508, 0.5909498509732443, 0.19470768246780668, 0.1982991382752214, 0.2321280030320052, 0.17629131901857475, 0.18035151599291388, 0.15490654886548094, 0.1773371634073535, 0.20639874679651116, 0.22775859654526465, 0.1754691562349302, 0.21582443912962135, 0.16489600501715085, 0.19062524326905073, 0.17736993668181367, 0.17736863039479045, 0.15148033769096925, 0.19232187210243223, 0.17334375187371187, 0.2625415453635219, 0.25097550044187855, 0.22532240867419207, 0.24069442955700937, 0.18279075605659056, 0.21469863099892283, 0.28569064734193195, 0.19976980835838676, 0.20644023128749012, 0.43730564845185393, 0.37900290843890594, 0.31099973782081125, 0.31200304118910105, 0.30946122059583214, 0.32191768470246696, 0.39352351268328156, 0.3750631621978814, 0.3892545408077641, 0.06256230615025449, 0.055595110181177354, 0.07390655318763262, 0.10757581112246595, 0.14620081600189283, 0.10428006692693503, 0.07215501229960519, 0.07947266716774959, 0.09422169731346297, 0.2368799543210599, 0.20535810138086452, 0.21501600242068375, 0.2116628949637248, 0.2492973584011401, 0.21796512715783456, 0.20686616003828917, 0.17992845690675185, 0.21069142374793903, 0.5741147364493852, 0.5293554274290598, 0.5786375302615985, 0.5678263982989292, 0.5679743774859491, 0.5497616517734107, 0.5906464226208921, 0.5765673990080746, 0.5814108975881421, 0.11433370942489596, 0.10044643917611995, 0.10838979048458919, 0.1086776693595537, 0.09013173730174528, 0.09646819612874136, 0.09339903082297862, 0.08669853940672778, 0.09858297963439178, 0.17176157988107021, 0.13573489836644692, 0.1482758908536207, 0.14858679186857204, 0.1363953042260393, 0.1778718736678193, 0.14859382514271313, 0.14233623447641897, 0.15991683739349516, 0.3465306027683259, 0.3415816282784052, 0.3607241425050318, 0.34195999961163814, 0.3372171879301852, 0.33966239380454166, 0.3761911445410213, 0.37122443859890486, 0.3486532268733423, 0.2492732953014003, 0.238535313992139, 0.25928342065805465, 0.25943797199444474, 0.2654406441649588, 0.2730580226119955, 0.25476335237586123, 0.2823674437954832, 0.2557875469588664, 0.1743051313167131, 0.21473463915143243, 0.1976599707455431, 0.2083982742231788, 0.1851043529656381, 0.2012485445059211, 0.1845675843397131, 0.1990656789096068, 0.1961835520325672, 0.1874585237841957, 0.19414326118200098, 0.1815339394174862, 0.18591610713442408, 0.1778557023007945, 0.19291799796383713, 0.1801187062361851, 0.1915778398223712, 0.19140661201952047, 0.5260588455105237, 0.5225038637916894, 0.6116964951673375, 0.5239595418461306, 0.47395266460662233, 0.41478960411679, 0.6809180400044976, 0.5157612496026325, 0.3331582197782881, 0.19171277748931015, 0.5561518865400501, 0.19191383899721182, 0.4822119217316565, 0.5538100987305319, 0.5010589662828961, 0.5712744271606134, 0.20135731885322916, 0.20287866137981503, 0.18645821072471958, 0.19370783587793283, 0.17869247778759922, 0.1862999421356435, 0.19862500821056217, 0.1699966898555666, 0.17426579881360282, 0.18287558926349512, 0.187100994730526, 0.0865493349463834, 0.07982606058307029, 0.08730512091032305, 0.07934288960201741, 0.08135406982669735, 0.0872756264923924, 0.07533160518475901, 0.07771668169598012, 0.08403404752777133]}, "mutation_prompt": null}
{"id": "d9cedca2-8eee-4463-9f6b-6afd3c1b6930", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Stochastic Adaptive Differential Evolution with periodic reinitialization to enhance exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.7026268339767757, 0.6773810415186622, 0.7038549693971967, 0.7016602664035907, 0.6946779429295518, 0.712621925237794, 0.701039800655223, 0.7102842836440815, 0.6883153319101745, 0.47429452103882963, 0.4683809124498086, 0.48603972638847526, 0.4869052081046752, 0.47092234102151986, 0.46374395485197073, 0.44612442562588317, 0.4994459790883182, 0.5020092715832774, 0.10613930153062023, 0.11202253112287786, 0.10086699022838164, 0.0962006746012507, 0.11343598073248018, 0.10375617649675228, 0.10132457922767624, 0.10019804919067388, 0.10870929732496681, 0.0939071508608802, 0.1018209903842171, 0.09117719787638123, 0.09699571197078183, 0.09755346728926984, 0.09043664769212412, 0.09320611199267892, 0.10214158694094388, 0.09096915395630223, 0.7891748115416992, 0.8536968478486159, 0.8456020679398626, 0.782362630297023, 0.9518168809359636, 0.8651674810445391, 0.755329051218393, 0.7754015121037893, 0.9079386963650734, 0.3255870189003779, 0.3382681956442143, 0.28984680864446977, 0.29595538256322973, 0.29985140370618113, 0.3128080334186083, 0.33521654374336907, 0.32137628615019476, 0.2951787852562183, 0.6365740460582185, 0.6524046345063796, 0.7011740731728827, 0.6552479635130087, 0.5941926361205278, 0.690729659944326, 0.652153135182185, 0.7111117373065508, 0.5909498509732443, 0.19470768246780668, 0.1982991382752214, 0.2321280030320052, 0.17629131901857475, 0.18035151599291388, 0.15490654886548094, 0.1773371634073535, 0.20639874679651116, 0.22775859654526465, 0.1754691562349302, 0.21582443912962135, 0.16489600501715085, 0.19062524326905073, 0.17736993668181367, 0.17736863039479045, 0.15148033769096925, 0.19232187210243223, 0.17334375187371187, 0.2625415453635219, 0.25097550044187855, 0.22532240867419207, 0.24069442955700937, 0.18279075605659056, 0.21469863099892283, 0.28569064734193195, 0.19976980835838676, 0.20644023128749012, 0.43730564845185393, 0.37900290843890594, 0.31099973782081125, 0.31200304118910105, 0.30946122059583214, 0.32191768470246696, 0.39352351268328156, 0.3750631621978814, 0.3892545408077641, 0.06256230615025449, 0.055595110181177354, 0.07390655318763262, 0.10757581112246595, 0.14620081600189283, 0.10428006692693503, 0.07215501229960519, 0.07947266716774959, 0.09422169731346297, 0.2368799543210599, 0.20535810138086452, 0.21501600242068375, 0.2116628949637248, 0.2492973584011401, 0.21796512715783456, 0.20686616003828917, 0.17992845690675185, 0.21069142374793903, 0.5741147364493852, 0.5293554274290598, 0.5786375302615985, 0.5678263982989292, 0.5679743774859491, 0.5497616517734107, 0.5906464226208921, 0.5765673990080746, 0.5814108975881421, 0.11433370942489596, 0.10044643917611995, 0.10838979048458919, 0.1086776693595537, 0.09013173730174528, 0.09646819612874136, 0.09339903082297862, 0.08669853940672778, 0.09858297963439178, 0.17176157988107021, 0.13573489836644692, 0.1482758908536207, 0.14858679186857204, 0.1363953042260393, 0.1778718736678193, 0.14859382514271313, 0.14233623447641897, 0.15991683739349516, 0.3465306027683259, 0.3415816282784052, 0.3607241425050318, 0.34195999961163814, 0.3372171879301852, 0.33966239380454166, 0.3761911445410213, 0.37122443859890486, 0.3486532268733423, 0.2492732953014003, 0.238535313992139, 0.25928342065805465, 0.25943797199444474, 0.2654406441649588, 0.2730580226119955, 0.25476335237586123, 0.2823674437954832, 0.2557875469588664, 0.1743051313167131, 0.21473463915143243, 0.1976599707455431, 0.2083982742231788, 0.1851043529656381, 0.2012485445059211, 0.1845675843397131, 0.1990656789096068, 0.1961835520325672, 0.1874585237841957, 0.19414326118200098, 0.1815339394174862, 0.18591610713442408, 0.1778557023007945, 0.19291799796383713, 0.1801187062361851, 0.1915778398223712, 0.19140661201952047, 0.5260588455105237, 0.5225038637916894, 0.6116964951673375, 0.5239595418461306, 0.47395266460662233, 0.41478960411679, 0.6809180400044976, 0.5157612496026325, 0.3331582197782881, 0.19171277748931015, 0.5561518865400501, 0.19191383899721182, 0.4822119217316565, 0.5538100987305319, 0.5010589662828961, 0.5712744271606134, 0.20135731885322916, 0.20287866137981503, 0.18645821072471958, 0.19370783587793283, 0.17869247778759922, 0.1862999421356435, 0.19862500821056217, 0.1699966898555666, 0.17426579881360282, 0.18287558926349512, 0.187100994730526, 0.0865493349463834, 0.07982606058307029, 0.08730512091032305, 0.07934288960201741, 0.08135406982669735, 0.0872756264923924, 0.07533160518475901, 0.07771668169598012, 0.08403404752777133]}, "mutation_prompt": null}
{"id": "a6632c6a-e3bc-4875-a0ce-8c2de89ff886", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.02 * (np.random.rand() - 0.5), 0.8, 1.0)  # Increased CR modulation\n\n        return best", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Stochastic Adaptive Differential Evolution with adaptive crossover rate modulation for improved convergence.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 86 is out of bounds for axis 0 with size 81').", "error": "IndexError('index 86 is out of bounds for axis 0 with size 81')", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {}, "mutation_prompt": null}
{"id": "8c77164f-2922-41aa-b2e6-b772a3e4bc48", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Stochastic Adaptive Differential Evolution with periodic reinitialization to enhance exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.7026268339767757, 0.6773810415186622, 0.7038549693971967, 0.7016602664035907, 0.6946779429295518, 0.712621925237794, 0.701039800655223, 0.7102842836440815, 0.6883153319101745, 0.47429452103882963, 0.4683809124498086, 0.48603972638847526, 0.4869052081046752, 0.47092234102151986, 0.46374395485197073, 0.44612442562588317, 0.4994459790883182, 0.5020092715832774, 0.10613930153062023, 0.11202253112287786, 0.10086699022838164, 0.0962006746012507, 0.11343598073248018, 0.10375617649675228, 0.10132457922767624, 0.10019804919067388, 0.10870929732496681, 0.0939071508608802, 0.1018209903842171, 0.09117719787638123, 0.09699571197078183, 0.09755346728926984, 0.09043664769212412, 0.09320611199267892, 0.10214158694094388, 0.09096915395630223, 0.7891748115416992, 0.8536968478486159, 0.8456020679398626, 0.782362630297023, 0.9518168809359636, 0.8651674810445391, 0.755329051218393, 0.7754015121037893, 0.9079386963650734, 0.3255870189003779, 0.3382681956442143, 0.28984680864446977, 0.29595538256322973, 0.29985140370618113, 0.3128080334186083, 0.33521654374336907, 0.32137628615019476, 0.2951787852562183, 0.6365740460582185, 0.6524046345063796, 0.7011740731728827, 0.6552479635130087, 0.5941926361205278, 0.690729659944326, 0.652153135182185, 0.7111117373065508, 0.5909498509732443, 0.19470768246780668, 0.1982991382752214, 0.2321280030320052, 0.17629131901857475, 0.18035151599291388, 0.15490654886548094, 0.1773371634073535, 0.20639874679651116, 0.22775859654526465, 0.1754691562349302, 0.21582443912962135, 0.16489600501715085, 0.19062524326905073, 0.17736993668181367, 0.17736863039479045, 0.15148033769096925, 0.19232187210243223, 0.17334375187371187, 0.2625415453635219, 0.25097550044187855, 0.22532240867419207, 0.24069442955700937, 0.18279075605659056, 0.21469863099892283, 0.28569064734193195, 0.19976980835838676, 0.20644023128749012, 0.43730564845185393, 0.37900290843890594, 0.31099973782081125, 0.31200304118910105, 0.30946122059583214, 0.32191768470246696, 0.39352351268328156, 0.3750631621978814, 0.3892545408077641, 0.06256230615025449, 0.055595110181177354, 0.07390655318763262, 0.10757581112246595, 0.14620081600189283, 0.10428006692693503, 0.07215501229960519, 0.07947266716774959, 0.09422169731346297, 0.2368799543210599, 0.20535810138086452, 0.21501600242068375, 0.2116628949637248, 0.2492973584011401, 0.21796512715783456, 0.20686616003828917, 0.17992845690675185, 0.21069142374793903, 0.5741147364493852, 0.5293554274290598, 0.5786375302615985, 0.5678263982989292, 0.5679743774859491, 0.5497616517734107, 0.5906464226208921, 0.5765673990080746, 0.5814108975881421, 0.11433370942489596, 0.10044643917611995, 0.10838979048458919, 0.1086776693595537, 0.09013173730174528, 0.09646819612874136, 0.09339903082297862, 0.08669853940672778, 0.09858297963439178, 0.17176157988107021, 0.13573489836644692, 0.1482758908536207, 0.14858679186857204, 0.1363953042260393, 0.1778718736678193, 0.14859382514271313, 0.14233623447641897, 0.15991683739349516, 0.3465306027683259, 0.3415816282784052, 0.3607241425050318, 0.34195999961163814, 0.3372171879301852, 0.33966239380454166, 0.3761911445410213, 0.37122443859890486, 0.3486532268733423, 0.2492732953014003, 0.238535313992139, 0.25928342065805465, 0.25943797199444474, 0.2654406441649588, 0.2730580226119955, 0.25476335237586123, 0.2823674437954832, 0.2557875469588664, 0.1743051313167131, 0.21473463915143243, 0.1976599707455431, 0.2083982742231788, 0.1851043529656381, 0.2012485445059211, 0.1845675843397131, 0.1990656789096068, 0.1961835520325672, 0.1874585237841957, 0.19414326118200098, 0.1815339394174862, 0.18591610713442408, 0.1778557023007945, 0.19291799796383713, 0.1801187062361851, 0.1915778398223712, 0.19140661201952047, 0.5260588455105237, 0.5225038637916894, 0.6116964951673375, 0.5239595418461306, 0.47395266460662233, 0.41478960411679, 0.6809180400044976, 0.5157612496026325, 0.3331582197782881, 0.19171277748931015, 0.5561518865400501, 0.19191383899721182, 0.4822119217316565, 0.5538100987305319, 0.5010589662828961, 0.5712744271606134, 0.20135731885322916, 0.20287866137981503, 0.18645821072471958, 0.19370783587793283, 0.17869247778759922, 0.1862999421356435, 0.19862500821056217, 0.1699966898555666, 0.17426579881360282, 0.18287558926349512, 0.187100994730526, 0.0865493349463834, 0.07982606058307029, 0.08730512091032305, 0.07934288960201741, 0.08135406982669735, 0.0872756264923924, 0.07533160518475901, 0.07771668169598012, 0.08403404752777133]}, "mutation_prompt": null}
{"id": "80d7e5ca-880b-4f46-943d-fbf0e652d486", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamic adjustment of CR based on current evaluations\n                        self.CR = 0.8 + 0.2 * (1 - self.evaluations / self.budget)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic adjustment of crossover rate to improve convergence speed and solution diversity.", "configspace": "", "generation": 33, "fitness": 0.30365567257305676, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.20.", "error": "", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.6897917484733846, 0.7105173285031174, 0.6881162091162876, 0.7098183152211179, 0.6913797221430116, 0.6773628927439745, 0.6609371527713475, 0.7057313714841021, 0.7071229309200182, 0.5004152758367659, 0.4363813685865672, 0.4388299212061251, 0.4776828659974085, 0.41555434530223034, 0.4211404457880078, 0.4409212787335334, 0.49058303581253626, 0.4733109264559652, 0.10430904351490156, 0.11281964750560869, 0.11325479232899038, 0.10164278669892168, 0.1008616155417903, 0.09088064410894581, 0.09658919412014133, 0.10596418464958401, 0.11038618811926515, 0.09353389243340693, 0.08769743736531654, 0.09403049395313245, 0.09851236894334192, 0.09722705975394907, 0.09260957814060822, 0.09313471595132983, 0.09315603343068435, 0.10547468226374945, 0.7611149211690819, 0.6706089044088928, 0.6390046300007373, 0.5471491322171429, 0.5911781641137557, 0.9599706591429277, 0.6876584031653921, 0.7396547611870841, 0.8906072529704143, 0.284401102229057, 0.3330105300685261, 0.31949810859569405, 0.32072329709911385, 0.38960273609769736, 0.3275625536702852, 0.297539175536612, 0.3350478575171648, 0.3648513871300737, 0.7372623295602425, 0.6945942724617642, 0.6652745793527794, 0.720273448915389, 0.7579435917108984, 0.6941740839174267, 0.7577889653950362, 0.7696559953640547, 0.7271485488491687, 0.17650294921376442, 0.19026310503650778, 0.17847984754751756, 0.15786168800757272, 0.16487963381160897, 0.18263994704819375, 0.2197660155808111, 0.23894045832491384, 0.2275987493776146, 0.16478815431882554, 0.15545450099753655, 0.22146205125960172, 0.16147637155627692, 0.17322014750179293, 0.2291059244143887, 0.22508427323160862, 0.22809034920957116, 0.20285781097567213, 0.28245400438262724, 0.27051010799808484, 0.3303319193751577, 0.29501667160970635, 0.31858068760801295, 0.2107535328727702, 0.30460070309937615, 0.3021657041331457, 0.26248461657044553, 0.43413323484956723, 0.4898810932935924, 0.43881454752214877, 0.4589806361620936, 0.4638745310289166, 0.41240449328216444, 0.4334818181291883, 0.4687758778281341, 0.480856706352622, 0.11324276234071617, 0.09275109052005515, 0.07306348992357703, 0.1277534699157401, 0.16913201675487943, 0.10976500472977291, 0.1161605330324732, 0.11225718295362441, 0.1335254009457414, 0.23005501518873783, 0.22775653595317458, 0.22244920817697744, 0.22239769267838738, 0.22049438866884175, 0.2559580945382013, 0.21814311116902796, 0.23143085958305942, 0.22620756994454783, 0.5711070897736701, 0.5594436016711284, 0.5563633025144703, 0.577248071540355, 0.5452837854369875, 0.6000209479474914, 0.5858913015676201, 0.5523659427030952, 0.5434014831840472, 0.09662335544116574, 0.10558678208276706, 0.11885123531876507, 0.09422443185804863, 0.1198636176114567, 0.10125504108531802, 0.10868814659649728, 0.09393835640902903, 0.0948359516111934, 0.14756579235518397, 0.13403538934267745, 0.1944516991527756, 0.14351820827909778, 0.15378990292129346, 0.16738641467730575, 0.1756188283996709, 0.13410077368982787, 0.12175380051556417, 0.3584310885543467, 0.38114169720555535, 0.351734061979351, 0.34475174525608987, 0.340222316574769, 0.34067667758722997, 0.359059719776472, 0.36627776612578355, 0.35570684645303285, 0.2692290270050688, 0.28157032928780434, 0.2815088789934418, 0.2834777983030844, 0.26945028415999994, 0.268657158438365, 0.265812050030111, 0.29165465244630606, 0.28320329121603094, 0.20672714212632815, 0.19593468392097468, 0.22884120537555042, 0.2177187695841788, 0.1793638512725786, 0.19207136758583399, 0.20059547672343792, 0.19736487561679006, 0.18550175372229816, 0.17680520143989265, 0.18446758058141843, 0.18251437861189457, 0.1860310656884976, 0.18412191964122815, 0.18779258094723228, 0.18076436194695256, 0.18633693583883526, 0.19037356195296584, 0.18313295291409737, 0.17742144064273702, 0.16080770217575624, 0.17460788106057612, 0.3663902058695405, 0.5239795273477778, 0.3228874821024462, 0.5331786093546381, 0.6092408828148588, 0.3962385717250019, 0.15944625142025703, 0.1999492207079976, 0.16526565368479296, 0.16021025633810493, 0.48903430940293846, 0.20666582833510738, 0.20674897550370885, 0.19545957477512566, 0.1847376676946697, 0.18041400330177915, 0.19421788929218586, 0.1895070195016466, 0.18929037744450172, 0.18076372624778947, 0.21811426146876167, 0.1828543323804166, 0.19939144148115762, 0.08143621411312929, 0.07911398592824737, 0.07388302917629008, 0.08818608289853513, 0.07260449125739377, 0.09191677429737033, 0.07174368077875393, 0.07966188352505965, 0.07792055686623678]}, "mutation_prompt": null}
{"id": "2b255519-c614-4dd0-94cb-2326bff51d38", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Stochastic Adaptive Differential Evolution with periodic reinitialization to enhance exploration-exploitation balance.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.7026268339767757, 0.6773810415186622, 0.7038549693971967, 0.7016602664035907, 0.6946779429295518, 0.712621925237794, 0.701039800655223, 0.7102842836440815, 0.6883153319101745, 0.47429452103882963, 0.4683809124498086, 0.48603972638847526, 0.4869052081046752, 0.47092234102151986, 0.46374395485197073, 0.44612442562588317, 0.4994459790883182, 0.5020092715832774, 0.10613930153062023, 0.11202253112287786, 0.10086699022838164, 0.0962006746012507, 0.11343598073248018, 0.10375617649675228, 0.10132457922767624, 0.10019804919067388, 0.10870929732496681, 0.0939071508608802, 0.1018209903842171, 0.09117719787638123, 0.09699571197078183, 0.09755346728926984, 0.09043664769212412, 0.09320611199267892, 0.10214158694094388, 0.09096915395630223, 0.7891748115416992, 0.8536968478486159, 0.8456020679398626, 0.782362630297023, 0.9518168809359636, 0.8651674810445391, 0.755329051218393, 0.7754015121037893, 0.9079386963650734, 0.3255870189003779, 0.3382681956442143, 0.28984680864446977, 0.29595538256322973, 0.29985140370618113, 0.3128080334186083, 0.33521654374336907, 0.32137628615019476, 0.2951787852562183, 0.6365740460582185, 0.6524046345063796, 0.7011740731728827, 0.6552479635130087, 0.5941926361205278, 0.690729659944326, 0.652153135182185, 0.7111117373065508, 0.5909498509732443, 0.19470768246780668, 0.1982991382752214, 0.2321280030320052, 0.17629131901857475, 0.18035151599291388, 0.15490654886548094, 0.1773371634073535, 0.20639874679651116, 0.22775859654526465, 0.1754691562349302, 0.21582443912962135, 0.16489600501715085, 0.19062524326905073, 0.17736993668181367, 0.17736863039479045, 0.15148033769096925, 0.19232187210243223, 0.17334375187371187, 0.2625415453635219, 0.25097550044187855, 0.22532240867419207, 0.24069442955700937, 0.18279075605659056, 0.21469863099892283, 0.28569064734193195, 0.19976980835838676, 0.20644023128749012, 0.43730564845185393, 0.37900290843890594, 0.31099973782081125, 0.31200304118910105, 0.30946122059583214, 0.32191768470246696, 0.39352351268328156, 0.3750631621978814, 0.3892545408077641, 0.06256230615025449, 0.055595110181177354, 0.07390655318763262, 0.10757581112246595, 0.14620081600189283, 0.10428006692693503, 0.07215501229960519, 0.07947266716774959, 0.09422169731346297, 0.2368799543210599, 0.20535810138086452, 0.21501600242068375, 0.2116628949637248, 0.2492973584011401, 0.21796512715783456, 0.20686616003828917, 0.17992845690675185, 0.21069142374793903, 0.5741147364493852, 0.5293554274290598, 0.5786375302615985, 0.5678263982989292, 0.5679743774859491, 0.5497616517734107, 0.5906464226208921, 0.5765673990080746, 0.5814108975881421, 0.11433370942489596, 0.10044643917611995, 0.10838979048458919, 0.1086776693595537, 0.09013173730174528, 0.09646819612874136, 0.09339903082297862, 0.08669853940672778, 0.09858297963439178, 0.17176157988107021, 0.13573489836644692, 0.1482758908536207, 0.14858679186857204, 0.1363953042260393, 0.1778718736678193, 0.14859382514271313, 0.14233623447641897, 0.15991683739349516, 0.3465306027683259, 0.3415816282784052, 0.3607241425050318, 0.34195999961163814, 0.3372171879301852, 0.33966239380454166, 0.3761911445410213, 0.37122443859890486, 0.3486532268733423, 0.2492732953014003, 0.238535313992139, 0.25928342065805465, 0.25943797199444474, 0.2654406441649588, 0.2730580226119955, 0.25476335237586123, 0.2823674437954832, 0.2557875469588664, 0.1743051313167131, 0.21473463915143243, 0.1976599707455431, 0.2083982742231788, 0.1851043529656381, 0.2012485445059211, 0.1845675843397131, 0.1990656789096068, 0.1961835520325672, 0.1874585237841957, 0.19414326118200098, 0.1815339394174862, 0.18591610713442408, 0.1778557023007945, 0.19291799796383713, 0.1801187062361851, 0.1915778398223712, 0.19140661201952047, 0.5260588455105237, 0.5225038637916894, 0.6116964951673375, 0.5239595418461306, 0.47395266460662233, 0.41478960411679, 0.6809180400044976, 0.5157612496026325, 0.3331582197782881, 0.19171277748931015, 0.5561518865400501, 0.19191383899721182, 0.4822119217316565, 0.5538100987305319, 0.5010589662828961, 0.5712744271606134, 0.20135731885322916, 0.20287866137981503, 0.18645821072471958, 0.19370783587793283, 0.17869247778759922, 0.1862999421356435, 0.19862500821056217, 0.1699966898555666, 0.17426579881360282, 0.18287558926349512, 0.187100994730526, 0.0865493349463834, 0.07982606058307029, 0.08730512091032305, 0.07934288960201741, 0.08135406982669735, 0.0872756264923924, 0.07533160518475901, 0.07771668169598012, 0.08403404752777133]}, "mutation_prompt": null}
{"id": "e5368412-f2ce-4c2c-96b1-1758cd0b4d82", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 8) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Implicit reinitialization by introducing new candidates\n                    new_candidates = np.random.uniform(-5, 5, (int(0.1 * self.population_size), self.dim))\n                    self.population[:new_candidates.shape[0]] = new_candidates\n                    self.fitness[:new_candidates.shape[0]] = np.inf\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.02 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adaptation of crossover rate and implicit reinitialization to enhance diversity and convergence.", "configspace": "", "generation": 35, "fitness": 0.30663945218241684, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.7050397228946057, 0.68598759616047, 0.6811529776530791, 0.6989382629688402, 0.7033507722794834, 0.6824669903760587, 0.6832661115883687, 0.6895780521660488, 0.6998541260289515, 0.4487499323751214, 0.4734398328416263, 0.46804583386712273, 0.4848358181520933, 0.48241454834504127, 0.49492952338144125, 0.48198295512283595, 0.49351757176989763, 0.4919280462645743, 0.10404023217562075, 0.10314914487563565, 0.09242895934304396, 0.1057063617914229, 0.10409855853947081, 0.11737303294236923, 0.09941274919079113, 0.10650691191130279, 0.11646228691192029, 0.09377631971857026, 0.09477063071253267, 0.09451012431436012, 0.112286191593996, 0.10756305688869128, 0.09301534382747922, 0.10077477140392332, 0.09688624257828937, 0.09546285383479791, 0.837632315343108, 0.9174329937940061, 0.7387807367608364, 0.6271650084253788, 0.868541530373057, 0.8905820540604734, 0.8599848337739906, 0.9323852143634446, 0.9337023733815302, 0.3471047512920189, 0.31058369597799096, 0.3055056293569557, 0.3282292568030535, 0.3374819436478991, 0.341288229711329, 0.31809863542441685, 0.3145954519313303, 0.3234714048274492, 0.578298888628209, 0.6846811816276279, 0.6774065785685441, 0.7048368735637016, 0.6690819933710284, 0.6284619745673196, 0.6526762899819916, 0.6709685836311692, 0.6576647069266144, 0.15004720258892779, 0.18641878039544502, 0.1736269947301451, 0.1772820004730935, 0.15069186936697565, 0.18518121569282253, 0.1589949039452775, 0.18846009670210706, 0.3446190187491085, 0.17714968766308792, 0.18619338591051637, 0.1652003273180901, 0.22912827690060844, 0.17704467997202322, 0.25178242414403484, 0.15107016326119194, 0.17155949347823585, 0.26167957333798253, 0.21580881856913336, 0.25027623356898676, 0.18390532072129206, 0.25040849075962857, 0.13928824302349507, 0.2023326689116126, 0.1796848587372316, 0.28830782298289026, 0.16378079979428117, 0.33920269057906804, 0.3917203310883465, 0.4136352890488235, 0.32194827107429824, 0.32013380863393737, 0.3155216972702175, 0.40633672071697224, 0.3840395954771145, 0.43293646772488514, 0.06445740700264235, 0.025200177250922162, 0.08678536666511849, 0.14697824644719004, 0.12322410715402998, 0.11713554096802958, 0.09620133852871826, 0.06502809265913223, 0.06493268417947473, 0.25703124812172196, 0.2164675785965483, 0.22185922368096977, 0.2237353476781513, 0.2074970730290826, 0.20380156288890738, 0.19725755716341087, 0.16582968031973744, 0.2528156130065746, 0.5552953598528889, 0.5906070055728312, 0.5678596172040786, 0.5338925174160687, 0.5080367218511944, 0.5695157352668745, 0.5461368586334454, 0.5411631178813547, 0.5902891220962532, 0.11155274191921705, 0.0965223873906027, 0.09850828711180981, 0.09439017880018741, 0.09018369512608493, 0.08777911146128203, 0.0850749999836331, 0.08900608654313213, 0.10031524768450584, 0.13522337305228682, 0.14172173289269463, 0.13188253149020324, 0.1268045378275512, 0.14371563937126686, 0.13568689714638382, 0.14140008138006033, 0.16546148180692022, 0.1194742037847869, 0.32825163374151956, 0.34343347121723744, 0.34616230042733465, 0.33786399721421934, 0.30535387739171826, 0.35829376164316895, 0.36956723333942165, 0.3490466492201677, 0.3541306327025586, 0.2763897047958813, 0.25614478363826143, 0.28896621123970956, 0.24702881482191985, 0.23623903257118195, 0.2521983122742778, 0.2750952487820503, 0.27848876615076323, 0.25429732987251996, 0.18645620144911412, 0.19648929355243183, 0.1889487306335501, 0.19895460385354968, 0.20199495021680802, 0.1932859855587482, 0.18759925123645194, 0.1958604269341061, 0.19580995781274602, 0.18156197143644126, 0.18555121888444126, 0.2001305525250171, 0.18128039640503613, 0.17758181584782984, 0.18086219272773152, 0.21369366033728954, 0.18036812205857644, 0.1835057610103782, 0.5037449112613339, 0.627799504660314, 0.31996391481623254, 0.3493920693374678, 0.17711421811178785, 0.4383523369147744, 0.4767820679016348, 0.3485035537516682, 0.610681485973728, 0.5402010739053802, 0.5089501616546488, 0.5398039648045628, 0.32086691203953965, 0.43289185647430584, 0.18529409491534043, 0.5999132663007894, 0.44484002293847746, 0.199512019313263, 0.16906333870371637, 0.18366773144656423, 0.197679488056258, 0.17537852866495174, 0.2051943019997371, 0.18635812457853695, 0.18485123076149257, 0.17796333499589057, 0.177356137843813, 0.0753264024231537, 0.083261158563678, 0.07449089190091784, 0.07381449286490482, 0.08018819636871011, 0.07343322425765997, 0.0808516692634732, 0.08899318225476305, 0.07127503175020489]}, "mutation_prompt": null}
{"id": "ce7e362d-4b2c-4bd5-bd55-bfe1ebfda0e2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.95, 0.4, 0.9)  # Adjust mutation factor\n                if np.random.rand() < 0.1:\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n            elitism_factor = 0.01\n            elite_idx = np.argmin(self.fitness)\n            if np.random.rand() < elitism_factor:\n                new_candidate = self.population[elite_idx] + np.random.normal(0, 0.1, self.dim)\n                new_candidate = np.clip(new_candidate, -5, 5)\n                new_fitness = func(new_candidate)\n                self.evaluations += 1\n                if new_fitness < self.fitness[elite_idx]:\n                    self.fitness[elite_idx] = new_fitness\n                    self.population[elite_idx] = new_candidate\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with enhanced parameter tuning and elitism for better convergence.", "configspace": "", "generation": 36, "fitness": 0.29230731105702684, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.6792072364152042, 0.6916562421277056, 0.6750957809712, 0.6792453424403959, 0.7011898924586943, 0.6743967675612172, 0.6776796188221517, 0.6831396903934646, 0.6590635719310678, 0.41778178120714293, 0.39704234351800727, 0.4155802229402621, 0.4096735367311184, 0.4549766397380862, 0.4077158077769497, 0.4274237004181045, 0.4472856625972702, 0.4403584362646671, 0.10688709220389081, 0.11704912040057824, 0.10683263052063108, 0.09721342053768312, 0.11107034890787326, 0.10660628399714167, 0.10721504927058978, 0.10252934522731816, 0.09869645156017737, 0.09892547723405565, 0.09340113655993432, 0.09848715357279847, 0.08721121053326719, 0.09516457625985164, 0.09219940142227812, 0.10381174828381134, 0.11104254730147478, 0.08810828481541555, 0.7926367394060114, 0.7480016343270088, 0.779592730239248, 0.7512926698526475, 0.8961313566666992, 0.9510870816338902, 0.7965009632591147, 0.9192851259757399, 0.9407215693567441, 0.279615404528483, 0.3296359025204262, 0.2966018549838494, 0.32627870254670555, 0.2888070875059773, 0.32560680669678255, 0.3644500732056931, 0.3301477666403655, 0.3081198808057878, 0.6307764058261368, 0.6053279286167561, 0.6716039077833855, 0.6204673485273299, 0.6661828536733003, 0.6398778231139242, 0.6751542764844565, 0.6459668833258271, 0.6442543612927167, 0.16539291742119844, 0.19540576493197093, 0.1795739200570564, 0.17518168297579317, 0.15054361084073353, 0.20860894144131625, 0.1767256515700919, 0.15686737329602385, 0.27337042225274577, 0.15357915036951475, 0.2547260616854672, 0.18699972897093753, 0.1663933495649973, 0.1626610776352001, 0.2736372861397469, 0.20618636341804208, 0.1998329826629146, 0.2783743836011884, 0.21940902943632723, 0.18579709801862299, 0.2252021722364972, 0.2389013827370844, 0.18941534796114734, 0.1917199743525856, 0.17834951709473368, 0.16866739478800064, 0.20092931138809966, 0.36473478496092515, 0.36186811487871695, 0.3082107128271264, 0.27916207886553046, 0.33683650856636216, 0.31322418779570393, 0.3529592788119693, 0.36820933680406653, 0.36943715443119285, 0.049318742873683874, 0.09096015096043086, 0.12668291702784884, 0.09292513714981054, 0.10610819626506707, 0.07301390491043491, 0.06799495133721778, 0.05845040062084117, 0.07516472382982942, 0.20109699338586218, 0.1908144668952786, 0.2069313537439076, 0.18567951996074794, 0.20162841015707023, 0.2159469122763219, 0.17183793920907842, 0.18306854139630524, 0.18567603008699185, 0.5599284932809425, 0.5343319344032968, 0.5314497703090919, 0.5279548335536532, 0.5487235118862417, 0.5277103957024196, 0.5424154623872475, 0.5309600946093282, 0.5106969027014846, 0.1037326540096577, 0.09071319037263115, 0.10181520870946226, 0.10965845891438963, 0.08550949971630684, 0.09287786215504168, 0.08744773659057015, 0.10263124817586089, 0.10148345625347832, 0.1411756844914196, 0.14831687062469678, 0.13997050114204357, 0.1430596489135838, 0.14261831661857083, 0.13722905621992665, 0.17263680288444483, 0.1674154954673699, 0.13454446497504724, 0.31178883672079416, 0.33523052581630497, 0.3270723870555968, 0.3313302847754358, 0.34016760245351985, 0.3399738149018866, 0.32465352959985394, 0.3256348279947976, 0.3272073493413714, 0.28745120966900817, 0.2434546119550257, 0.25576518452824115, 0.2240698374730291, 0.2495333569096846, 0.25375736339805466, 0.2664980927740951, 0.2692381993384394, 0.25941489526047623, 0.21038138861980338, 0.20700678199335465, 0.18823790727319334, 0.19728617813002547, 0.2000035823383184, 0.17205236445273298, 0.1890659091761393, 0.19443904528011813, 0.18423358299420256, 0.17786781871927926, 0.18056641703414844, 0.1852777660222661, 0.18447215471767764, 0.180894131501102, 0.17917769012078266, 0.17735942780593628, 0.18997623035792544, 0.18846877471564805, 0.21382715902069005, 0.5956789109591225, 0.17296381029971786, 0.4259864350983861, 0.4163528637784423, 0.48350200153308853, 0.4200397753070194, 0.47796248037836253, 0.36462826471684995, 0.15799348157960358, 0.4858535354975969, 0.16416999631429063, 0.19455161038612856, 0.4996791306404823, 0.41357716248969856, 0.19982736794705713, 0.19542608904298053, 0.36250859814946446, 0.18280416063038596, 0.1796973144444275, 0.17737587655340326, 0.17154241517041102, 0.19860192427361445, 0.181499571830968, 0.18329056841567848, 0.18097759891816745, 0.18150735542801122, 0.08178294296820532, 0.07409067568013417, 0.07221751879548555, 0.07854060392151352, 0.076717957907108, 0.07621508217960782, 0.07639766708444873, 0.07910880589528935, 0.07998382020263162]}, "mutation_prompt": null}
{"id": "9de15e4d-5d37-4398-8784-2a77eb6796a2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 8) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.85), self.population_size)\n                self.F = np.clip(self.F * 0.92, 0.4, 0.9)  # Adjust mutation factor slightly\n                self.CR = np.clip(self.CR * 0.95, 0.8, 1.0)  # Adjust crossover rate for diversity\n                if np.random.rand() < 0.15:  # Introduce adaptive reinitialization\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with adaptive reinitialization and improved parametric adjustments for robust convergence.", "configspace": "", "generation": 37, "fitness": 0.2935916273092032, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.6742449890355682, 0.7029614224179564, 0.7381319337472427, 0.6940596789239439, 0.6796230770318252, 0.7081025324520085, 0.7018000591677895, 0.7044667069176169, 0.6936847646341338, 0.4411416916865656, 0.43973310082419426, 0.5298258872908823, 0.48542210813675446, 0.48189959886662614, 0.491092806618312, 0.43903155503588287, 0.47811444097719535, 0.47742087133257116, 0.10979091465164381, 0.10983614257553431, 0.10572898691971244, 0.10209936695473165, 0.1088206740469464, 0.10111763720750766, 0.1195428254639348, 0.10430514160060789, 0.09606289477635022, 0.10897604607579192, 0.10117705532657872, 0.11721527375141394, 0.10548204681597217, 0.09691216377923195, 0.09506977502149605, 0.09699055222294173, 0.09368164818733982, 0.10784797661197754, 0.7686021874326141, 0.8175260038315438, 0.8090430112349541, 0.8779675693180363, 0.8536132221661719, 0.8739134255883586, 0.8118960437421161, 0.9438505470340516, 0.904528868605035, 0.3202567896061822, 0.32049436609496373, 0.32040032495558657, 0.3154314746201705, 0.2871976698881017, 0.35211961174364714, 0.31836213317659834, 0.32702775740309964, 0.36401873184888167, 0.5654279874581307, 0.606811695526219, 0.6179516141542434, 0.6175054930464172, 0.5965875217278487, 0.6250651392650459, 0.5678280246906482, 0.6227713797620282, 0.5770532731407783, 0.17735241861189155, 0.1919368633583317, 0.1484169925872444, 0.1439634404097635, 0.1674843229509534, 0.2218167381072813, 0.17449242360551376, 0.19180014394574096, 0.190669094331823, 0.1906705478855305, 0.1784223678671859, 0.17907539482445722, 0.171218280782367, 0.18256761708110814, 0.16121078337550332, 0.15715314277698567, 0.17300498715825818, 0.16609823636687782, 0.13028718623872815, 0.16897993130717348, 0.1751367699442089, 0.1593141529504477, 0.16106882833793223, 0.15044393665862066, 0.15318922862579132, 0.13829351479050167, 0.14155629685605764, 0.28850071693220514, 0.2499366456360672, 0.2813685439905723, 0.2681566684369727, 0.26833788296036576, 0.31854531930593344, 0.3234293759721921, 0.30009641448858626, 0.2998230579730402, 0.0714659278020916, 0.07923972679373514, 0.051075124428455965, 0.069417001723594, 0.1107164132482159, 0.03412869809948482, 0.08358958328772803, 0.09430259264082796, 0.08627455109106086, 0.18614947578320384, 0.17798393988362327, 0.19564157505232582, 0.18324077786934612, 0.1944359522951754, 0.18226373199697188, 0.16924648071517845, 0.18055857327825364, 0.16372630360865348, 0.5266005122659221, 0.5746348198757499, 0.5513521637661636, 0.5289987779982486, 0.5480453889810666, 0.5423031141231194, 0.5073142299378637, 0.550537153726381, 0.5413054591755075, 0.08819616353482684, 0.08612204837740156, 0.10609149968518361, 0.10544997873003392, 0.11235964117540786, 0.10213994510583002, 0.09024596332936485, 0.08722593567226722, 0.09051720003696206, 0.15554067928166004, 0.2061497868630343, 0.14910093551910808, 0.13722586594790576, 0.15511247199912903, 0.13337513761031694, 0.147008711675503, 0.14601532269447848, 0.15447712288577875, 0.33545916157075495, 0.3513312971413902, 0.3206760515286764, 0.3294134287782595, 0.33684550219844955, 0.3420306495627392, 0.35543034803862794, 0.353410335106368, 0.34466886581896716, 0.25117201899257924, 0.2435087733860678, 0.2519207894467028, 0.2448983417527124, 0.26878221256725354, 0.23885195537871973, 0.25495566874657116, 0.27509840485404025, 0.25251343788015834, 0.1869499165376738, 0.1910750649502736, 0.21935301078460412, 0.192408809805785, 0.19753575168237325, 0.19445887636290515, 0.18135611474423585, 0.1889866317627843, 0.20950238118207254, 0.18665748475638, 0.18840153446679175, 0.19103373952646685, 0.18939424089743784, 0.17691260550783172, 0.18277690756246523, 0.17963096896661424, 0.1865635598577302, 0.19320771930302028, 0.5284977052810387, 0.6118199269293645, 0.6962806056196917, 0.4025458228946701, 0.3634215283632739, 0.40738695556262816, 0.44568815262563566, 0.6328964355307813, 0.3356064201830874, 0.16392466789513105, 0.5675210404263289, 0.45880188802026356, 0.550545345135504, 0.23146173056580732, 0.19570571260438374, 0.19699425681777294, 0.20342464256574866, 0.2094285425092789, 0.1952229968237128, 0.18250081241629468, 0.1951030965613848, 0.1782136685426985, 0.19314963082156988, 0.1795985052761644, 0.20001277259500738, 0.186534751407347, 0.1873901282549295, 0.07946849355520191, 0.07920594025858829, 0.0818443894517501, 0.07640068788329513, 0.08291006671405943, 0.07852589620240613, 0.07946186455744175, 0.0745537589284222, 0.09118315644812114]}, "mutation_prompt": null}
{"id": "0d776b7e-f85a-407e-b3a1-5baee697d941", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n\n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and CR based on fitness improvement\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.CR = np.clip(self.CR + 0.01 * (np.random.rand() - 0.5), 0.8, 1.0)\n                    else:\n                        self.CR = np.clip(self.CR - 0.01, 0.8, 1.0)  # reduce CR if no improvement\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic mutation and crossover rates based on fitness improvement.", "configspace": "", "generation": 38, "fitness": 0.2667409218855047, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.6994317723550205, 0.6988220373344018, 0.6727387958496678, 0.6950670824905512, 0.6865708045117441, 0.6724419686956903, 0.7148116098596082, 0.6902423464470857, 0.6443755156752413, 0.44850197911331235, 0.47667001813365517, 0.4171001910714526, 0.42894181445146173, 0.3949789041216075, 0.44596024777548515, 0.46589550847622063, 0.45742037968003446, 0.4170983465280862, 0.10346219734963291, 0.10701712188476808, 0.1031722924777847, 0.11406451185934252, 0.11665602566588928, 0.11821154918031951, 0.11268125656380612, 0.11296700605227183, 0.09775532327985914, 0.09518530125058189, 0.123109670236493, 0.10939806523220064, 0.10371251020677696, 0.10426411243570932, 0.10950777251170307, 0.1052200658039899, 0.10654584002062417, 0.1082851998065959, 0.836998118793152, 0.9200872891891794, 0.8497031275550031, 0.8440145141444115, 0.8788194730876073, 0.9188517424217219, 0.8995689833038951, 0.9012373026449257, 0.8748621131772616, 0.29239542349326686, 0.2925564394887872, 0.279459815394116, 0.2862989671827382, 0.3123291929946651, 0.29583745474875445, 0.2886278729508983, 0.31583084245932547, 0.30516498923172086, 0.5128006043635398, 0.48250997617595126, 0.5164869368035614, 0.45809786413962783, 0.6496078176611737, 0.5051912127798217, 0.46641907035152397, 0.5821209127445737, 0.5656603851406743, 0.1537152334840992, 0.16012016289052666, 0.2149848983754774, 0.17150441250371862, 0.18314063215799092, 0.16097605188232333, 0.16421446944030416, 0.17088509633003446, 0.16789157475848515, 0.15648255082322704, 0.16306173643393085, 0.1515959758094121, 0.16012035055616491, 0.1583997549091709, 0.15857820836128267, 0.15304301634342188, 0.15325858896727929, 0.15676952602590633, 0.08296540806816577, 0.09453063417511509, 0.07817361535529144, 0.07352864589582697, 0.09100039222704659, 0.08310325662499363, 0.07362884430992855, 0.08239168247337225, 0.09490662709876174, 0.19484984400836047, 0.2221580779565696, 0.18192135231992312, 0.17328432381593195, 0.2136591942481536, 0.22798076902506004, 0.2346269607037621, 0.24567693056925333, 0.22795434200175702, 0.011369444258010897, 0.046566576299686635, 0.007369234765727706, 0.02559812691953789, 0.053250086457477974, 0.03306046022261, 0.020874141681494818, 0.05098587884073946, 0.032307562858882366, 0.14712417167004244, 0.13762059908366786, 0.1436423619384355, 0.14447110458231893, 0.1495879108355026, 0.17429629379856304, 0.133040520263785, 0.12219381262103557, 0.1426804608284099, 0.49060400712023855, 0.4949810856372243, 0.49675317086052806, 0.47087179193666207, 0.5100667129520926, 0.49290959256546196, 0.4934284814111147, 0.510261705892533, 0.48510055202459457, 0.09531479191287384, 0.08520900757185268, 0.0938887509384323, 0.0920849188874161, 0.09635476403330523, 0.08535309731196816, 0.0991370197620326, 0.09457972418771987, 0.09567807057125788, 0.14168546038428742, 0.14725746382371596, 0.12634696665250555, 0.16990371560886675, 0.14274185861755073, 0.14297276696781613, 0.13840384469697853, 0.1374288309505215, 0.1623076785587777, 0.3221928488283573, 0.33386494113234066, 0.29581089538968663, 0.3138980752655558, 0.33863390788224, 0.3149386788500492, 0.3582117096522921, 0.3377228603895672, 0.3262557058574336, 0.23328336482452794, 0.22591090692569182, 0.23381447944000744, 0.222026515671087, 0.21213261228668645, 0.23106706539361843, 0.2422473458348624, 0.22986997947649324, 0.23081502531924003, 0.20506547400391884, 0.1935174482424249, 0.1994422508877315, 0.22308084843958698, 0.21089136759387628, 0.2014298963624328, 0.19232348203414817, 0.19623961940582701, 0.18969516078856208, 0.18638331025910415, 0.18261502532369311, 0.18702445637261178, 0.18750323992734697, 0.20559228341119984, 0.18730997649281822, 0.186937517579431, 0.18600884262366246, 0.1874962529404277, 0.1773922068710706, 0.1651194139056542, 0.6087071920354292, 0.43150082179305305, 0.39982037387918, 0.3049636766322913, 0.34408439002736113, 0.16217792158689115, 0.22128669363874343, 0.3770724504407208, 0.22225402384029513, 0.16330368715725252, 0.3642303237501944, 0.22844926456295034, 0.33585080123975863, 0.40449023415550167, 0.20236615110123557, 0.3691562118197901, 0.19964190515687763, 0.1768008743295013, 0.2016423183520526, 0.18897006875740696, 0.18368663054414203, 0.18794806721853807, 0.1941277764620366, 0.1867182395282253, 0.1943333051844084, 0.07998466066969578, 0.07471020658749583, 0.07524975291502123, 0.07890740395604867, 0.08891171984019275, 0.07483697343849216, 0.07547605267310042, 0.07113286320484913, 0.0769097914001774]}, "mutation_prompt": null}
{"id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 39, "fitness": 0.31338142985697776, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "ff9ec37b-aaf3-48f5-af87-53037e96caeb", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "094224da-dd74-4bf9-b5eb-0654205f62ad", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "7cb7fb20-a172-4642-b4be-70cd8b7d93af", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "0e4c5de0-a0c9-4fe6-8def-4aeb39b2125c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                perturbation = np.random.normal(0, 0.1, size=self.dim)  # Added Gaussian perturbation\n                mutant = np.clip(a + self.F * (b - c) + perturbation, -5, 5)  # Adjusted mutation\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by introducing Gaussian perturbation to mutation for increased exploration in high-dimensional spaces.", "configspace": "", "generation": 42, "fitness": 0.2108849934175613, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.42918456513323644, 0.4574395669460184, 0.4341653612431454, 0.4362842696095808, 0.45455371930097055, 0.41221336119834373, 0.4383545805528317, 0.4302242103293741, 0.4096615708234729, 0.060739720828307364, 0.06358716990123814, 0.047831867963379904, 0.04477919280430687, 0.03554148774368293, 0.04048741832291469, 0.053090886665126846, 0.06030012924903627, 0.036896765116885, 0.10132951968087622, 0.10362608210908908, 0.1038646949249229, 0.09539617146015356, 0.11667566424024756, 0.10055550816050307, 0.10971148092423755, 0.10438079714210868, 0.11464212453033618, 0.09448867076710954, 0.10176648906551922, 0.08746765103095933, 0.10361587936449745, 0.09328019660128617, 0.08748380817538126, 0.08325028605541396, 0.12415469829040815, 0.09435747062700428, 0.8047760967687231, 0.791907287483776, 0.7868980275378141, 0.8319300897334234, 0.8633862763144186, 0.8330961136229111, 0.8530743864858517, 0.8605619978225345, 0.8584119740384291, 0.2265950983359748, 0.23635296690970653, 0.25192502729155797, 0.25789514962502624, 0.2777927662873969, 0.24010310771551024, 0.23384635066156734, 0.2465848422318202, 0.2470391968423612, 0.3278153854231248, 0.3062417177504222, 0.375385049034768, 0.3346404734280187, 0.32639253970719107, 0.3422200647312609, 0.3327909329924468, 0.3152658597138459, 0.32978072779787504, 0.1390154663179668, 0.16037681421941075, 0.15623348580318108, 0.1417839397137748, 0.14660694368437854, 0.14939186631704104, 0.15794792082563613, 0.15629069082292935, 0.15004544032450318, 0.13464498729250918, 0.1353281675525454, 0.1416357377220091, 0.15427602513723193, 0.1419662182055732, 0.14373095077904907, 0.13420399233671065, 0.14524608955083262, 0.15914161843009023, 0.022423142520429984, 0.0205394136546867, 0.015775877033953667, 0.025651474931290608, 0.016595576467997475, 0.029155384730618294, 0.04021201631195814, 0.015345378004802845, 0.032369409933581506, 0.09698030653391976, 0.115598145412108, 0.12369292418035815, 0.09265947774562444, 0.09294023121236694, 0.10443763277286566, 0.11069915400537633, 0.1384817877217962, 0.11277693129200539, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09042012741209582, 0.09251414931001511, 0.10232993072567442, 0.09859202927554656, 0.10973059438996458, 0.09757794210859683, 0.09283680753099144, 0.10075101654810537, 0.1038135320215553, 0.39630971593830255, 0.3982100332558234, 0.39380612128084, 0.37462695662191003, 0.391499413095426, 0.3868579070591438, 0.40788844453081397, 0.4038017285864366, 0.3841266036890525, 0.0913128315188414, 0.09523926429402674, 0.09690307750075566, 0.08878310899511055, 0.14622470388293096, 0.09931697405302509, 0.10802268692285089, 0.09854185968177465, 0.08901658465083362, 0.14186430642936354, 0.12996938530564017, 0.14633812763195853, 0.14552877872788883, 0.13676164160197546, 0.1403733157720719, 0.1381211661153786, 0.20567009593549979, 0.14911828312375452, 0.27653021456883253, 0.26305113442543604, 0.277679923502265, 0.27276376486856657, 0.27760935862186564, 0.2736506961968421, 0.27850439115628856, 0.27408156808930095, 0.279594671960951, 0.2136121778867719, 0.20727761328562788, 0.218289460685251, 0.20951328134195868, 0.19852596580125814, 0.20964411458363752, 0.21772938034402634, 0.20522840555901156, 0.22550999078972223, 0.19575820245368403, 0.20126667428438072, 0.18759245971747218, 0.19757502734917864, 0.1903089461391777, 0.22496571928995568, 0.19382134331568468, 0.21488512627266532, 0.19681187561776636, 0.18498949332665937, 0.18525209754906402, 0.18857107058882872, 0.18587024452396395, 0.18236639040947789, 0.17557761064088973, 0.1986775527575464, 0.17587249514758296, 0.1848992954159877, 0.5009059445445267, 0.16073377378024145, 0.5010011600134581, 0.4905769623212526, 0.18418705082882458, 0.1710976747325167, 0.4364391294621096, 0.4626826913371547, 0.4524748846385661, 0.19741477882638236, 0.40424487734800474, 0.2024338355684897, 0.18892974806063234, 0.19625150120189605, 0.42064399016134923, 0.19104336301269786, 0.2057676541293707, 0.49177126155448503, 0.18146755885526789, 0.19961918610541307, 0.2041967314754457, 0.20030541864193674, 0.18165833883668725, 0.1881269314509515, 0.19785851220721118, 0.21335369623654943, 0.18663414433680114, 0.07701118228374582, 0.08421830608773018, 0.07126131379064704, 0.07115900800227992, 0.07567469019815087, 0.08911953134209782, 0.07563660121465177, 0.08284429877034782, 0.08256270017304812]}, "mutation_prompt": null}
{"id": "68ebe39f-a63c-4dbc-902e-bd6d0c703346", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "476cb7cd-63e9-4aa2-b0c3-9eeb83e07ddf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "ca606f4a-1863-47f8-9155-6482cc9f7493", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "cd9efbbb-eb5a-4b53-a2dd-e606df7a4ec1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "7d2d37a3-d2d3-4989-a11f-86b4b2a2a100", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "cba758f1-e1e5-4549-987f-d8a3379bbc62", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "af04e14c-8758-42bb-9544-3da0ea61c13b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "24ec9b6a-df21-4a3d-8fcd-ca369373a522", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "69664aee-422c-4119-91fc-6cf3af725bef", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "1e574fe5-b21a-438a-9411-28da5988efb1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n        self.success_count = 0  # Track successful improvements\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n              \n                # Adjust population size based on success frequency\n                if self.success_count < (self.population_size // 2):\n                    self.population_size = min(int(self.population_size * 1.1), 50 * self.dim)\n                self.success_count = 0\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    self.success_count += 1  # Increment success count\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by integrating adaptive population size scaling based on performance improvement frequency to bolster exploration-exploitation balance.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 97 is out of bounds for axis 0 with size 90').", "error": "IndexError('index 97 is out of bounds for axis 0 with size 90')", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {}, "mutation_prompt": null}
{"id": "cea7754c-9230-4ae8-999b-a75ceeec27f5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "d2434cef-e16d-4f9e-8dce-3e1ebaa41360", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "33b8149c-7a2f-4d3d-9e2c-0b80af9d08e0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Introduce gradient-inspired CR adjustment\n                        gradient = np.abs(trial - self.population[i]).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (gradient / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with stochastic gradient-inspired crossover adaptation for improved convergence.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 88 is out of bounds for axis 0 with size 81').", "error": "IndexError('index 88 is out of bounds for axis 0 with size 81')", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {}, "mutation_prompt": null}
{"id": "6864e5a8-133a-48d3-acc4-8b4baaff5267", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "53575291-30c6-4cb6-a348-7689217e8d49", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "25714b77-e228-42fb-bead-81853c7097db", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n            \n            # Adjust F based on evaluations to balance exploration and exploitation\n            self.F = 0.4 + 0.5 * (1 - self.evaluations / self.budget)\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with time-varying mutation factor adapted to maintain a balance between exploration and exploitation.", "configspace": "", "generation": 58, "fitness": 0.2209278917724655, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.45467178434122735, 0.49664082601386694, 0.46874174594630336, 0.5111709837603167, 0.5119828120575018, 0.5263789608856964, 0.4843816051719164, 0.5112168737280687, 0.507239328178102, 0.23267827315108303, 0.2499347926110307, 0.25295723032300343, 0.2593391411757079, 0.23394984929813523, 0.22944484078662586, 0.24559465476209708, 0.25686301230768926, 0.25317423198970523, 0.08010552477151123, 0.08270971090917723, 0.0803197208667088, 0.08768558239340929, 0.09598067203611116, 0.08167843314437617, 0.08683397468696241, 0.08853532787242968, 0.09288194210833933, 0.08821969612903302, 0.0770858275302504, 0.07892253154009321, 0.07806457498628605, 0.06759951056636948, 0.08207919300979682, 0.06924476796426082, 0.08018332805683637, 0.07252132226500996, 0.7829252320250597, 0.936314260157979, 0.7426244733953136, 0.9579744105443794, 0.8751593078402173, 0.8848011728574134, 0.9407867810686928, 0.9226206377975011, 0.9417106263531719, 0.21601235438847521, 0.19219816008824242, 0.19871891139597375, 0.20363715467745924, 0.21061443757238651, 0.21196574102806087, 0.2345584374469093, 0.21306768269951348, 0.22795260687396668, 0.3651264090995594, 0.33714545623984193, 0.388935999622818, 0.37063814628780456, 0.32702672679888956, 0.41627819333144944, 0.45108455839282946, 0.3387378532202965, 0.39903631103432, 0.13255089551082855, 0.11350743102497651, 0.12770690726012124, 0.1183182734707483, 0.12686648420724866, 0.13649879656610542, 0.12008225614137213, 0.12656776386348212, 0.12108144459073666, 0.10070721588534548, 0.149216775358618, 0.046104915416542824, 0.1179675572198906, 0.10861698342981474, 0.12153626332742073, 0.12113543147808359, 0.11600568758919849, 0.12851241484948328, 0.08988404784555515, 0.08734087928622414, 0.12155664657810672, 0.12582655191134107, 0.09963591642960634, 0.12271147300997054, 0.1265312413653824, 0.08952242461974835, 0.10570157879854547, 0.24823379560664294, 0.21951471597972183, 0.2269858432763634, 0.24005783176868278, 0.2076590489396215, 0.24756316705306303, 0.253142906547152, 0.21045995211320045, 0.2576860665387115, 0.032882403883732314, 0.013032283625839969, 0.02084066581574462, 0.026404643481942935, 0.007450687303586556, 0.02418541505416616, 0.0168521418775337, 0.013727761021763207, 0.008843644725638256, 0.12267290875583836, 0.08364275321764203, 0.12429337691398545, 0.11763399620739712, 0.09500223464718494, 0.1216840515493226, 0.1300788732259056, 0.08880018754418217, 0.13870239927358852, 0.4052525563704845, 0.37317191136948813, 0.38285663745928755, 0.3884751602267953, 0.398791988677373, 0.39732842269250557, 0.40982207468583187, 0.397816803632705, 0.39386564413103176, 0.09417968021543144, 0.08400422396765406, 0.0830867090186066, 0.07308499632045118, 0.07479600564239319, 0.08127868841713004, 0.08434347455563873, 0.0741510830485489, 0.07861620961882199, 0.1290445909677166, 0.1416951280140646, 0.150070584782785, 0.1401192378780184, 0.14268683272041394, 0.17894331052220291, 0.15313258891885384, 0.13135149991845252, 0.1496982497865541, 0.24182905133521604, 0.23587950211558706, 0.23030314284348574, 0.24012226021793381, 0.22752770256820487, 0.23145150447032226, 0.2596829540281602, 0.2474198632297554, 0.254925294871288, 0.18899330248751012, 0.18472513103532906, 0.17359225157043334, 0.18763640368108547, 0.19409950806869725, 0.1820048406707382, 0.1875476178133204, 0.18831198212870226, 0.1828298561166395, 0.18760328889586864, 0.16969168759384212, 0.17870223433203591, 0.18748598819189033, 0.16337390962121412, 0.17595382753034994, 0.188388248414866, 0.19104519336272774, 0.20733567481683657, 0.16556488954124704, 0.16771829814235006, 0.17724084655287065, 0.17442805989805887, 0.17244438176241006, 0.16625297886670265, 0.16047746337111002, 0.16566401180110457, 0.16901266360814493, 0.41897085329091543, 0.16392346088791931, 0.20127448095397182, 0.1661791236684388, 0.17215738977401684, 0.17777293519889115, 0.3145490892572139, 0.14653763441371737, 0.5223785871618032, 0.43402835289007546, 0.21964572795897597, 0.44508278236068244, 0.21790500197244156, 0.17012501366080446, 0.28009016623261795, 0.20817327670188335, 0.20207493473099847, 0.5498228623492132, 0.1820363556584721, 0.1737238992960891, 0.1994687654470677, 0.17755058657684952, 0.1756557413192561, 0.18237627044166727, 0.19202098692594427, 0.192153002212351, 0.17715719761366622, 0.06209766777890979, 0.06968587292320338, 0.07172690962828387, 0.06377173072567144, 0.06590772498265118, 0.0689734363594312, 0.06652225799755229, 0.06413028184948, 0.08145150998992268]}, "mutation_prompt": null}
{"id": "2291011d-a955-4d50-a567-279d40cd747d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "f57e5b98-f429-484a-9421-28abeedf25b6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "26c2e1bc-b0cc-4066-bd9a-a89226023df7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                \n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + (0.01 * (np.random.rand() - 0.5)) * (1 if trial_fitness < self.fitness[best_idx] else -1), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhance the Adaptive Differential Evolution by incorporating a dynamic mutation factor based on fitness improvement trends to balance exploration and exploitation.", "configspace": "", "generation": 61, "fitness": 0.28451092874783473, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.6714232226955553, 0.6500387493572376, 0.6644689819343021, 0.6835285420018125, 0.6644213761855509, 0.6914472920807585, 0.6353339480086351, 0.6425518033644428, 0.6697975167469203, 0.3775319558896373, 0.42961710204847237, 0.41033658458994904, 0.4329161748997381, 0.4378653768737273, 0.4332631681441672, 0.4398748105078166, 0.4344550272734957, 0.4492243268017354, 0.09298388205933383, 0.10065588126578096, 0.10627847263093715, 0.10542871491615025, 0.09605629875972277, 0.10071917058818292, 0.10534544239092991, 0.10990664517314874, 0.09484061817718592, 0.09250768647436813, 0.08480992380931296, 0.09372756762632584, 0.08681329805635474, 0.0895027479686007, 0.09223700008152846, 0.09247912844924722, 0.0949248769345179, 0.09381500623851158, 0.7527543116320227, 0.9121412206289115, 0.42259270895243795, 0.49579713870462605, 0.8674281686332663, 0.636368018209502, 0.8816197379220003, 0.8741544243196888, 0.882387452438083, 0.29966177264153204, 0.28295803450055934, 0.294164302904383, 0.30954853972798135, 0.28298507152599217, 0.30785993866488603, 0.31326434211613396, 0.3453959612189308, 0.3373911828871704, 0.6113203826182614, 0.550337219179629, 0.630926945093311, 0.6699960061073491, 0.5782514880651025, 0.6650993928865757, 0.6467053345981411, 0.6143165379211345, 0.7064695758094615, 0.16230104196062534, 0.16520534551548316, 0.20316090020019473, 0.14632935345192433, 0.1760287071303721, 0.17147778069218111, 0.20674572217739562, 0.16557543746037084, 0.1855530206256789, 0.16461129593579404, 0.1584770317122307, 0.12429690873453059, 0.2088974978974284, 0.19014655140034942, 0.22013945912999633, 0.15544227168039637, 0.15933105465298303, 0.20328582710461074, 0.21551456712354278, 0.17068864609076007, 0.2386610730929487, 0.2510809052888616, 0.1789342684623011, 0.26420316321616066, 0.2206719997260227, 0.2029211955843584, 0.2660544302847143, 0.3776265350892192, 0.3181101160181663, 0.3605138416128243, 0.4023713240848098, 0.312695533355837, 0.36508127012028524, 0.3856995743304197, 0.3326123486765138, 0.3724192087593732, 0.06422626818254373, 0.031631762703639654, 0.0679177722631582, 0.10153981644688814, 0.02010774641485713, 0.10082342048247661, 0.07055544798214142, 0.051900983566412706, 0.10219908267403388, 0.2142856142401811, 0.1483895735634012, 0.1884544389367515, 0.18125029686376048, 0.14062464832181953, 0.20945695284952315, 0.20679020520934877, 0.14632323015330473, 0.2126520947751971, 0.545736760299482, 0.4822510019893812, 0.5290734116030584, 0.5337370643711234, 0.4594199242091107, 0.4997376471203526, 0.49485636418439494, 0.47621837318931326, 0.5126130602576593, 0.11319440498119127, 0.09199272991115526, 0.09715663626267446, 0.09729686757794842, 0.09373152978651522, 0.09538075118601375, 0.0912646593128098, 0.09235353451308725, 0.10134342170864186, 0.1342483626379566, 0.14237645470967486, 0.16768300949205606, 0.16157584383817325, 0.14890484200009413, 0.19558973999400164, 0.14816979691757404, 0.1666435446728336, 0.15217611747091286, 0.33851602993399554, 0.3114587764714962, 0.32040522254763915, 0.31992510586599576, 0.3111271717064519, 0.29848402042049293, 0.2987899169240653, 0.32907045382754097, 0.33889370034567745, 0.24733718611918265, 0.2297143240014079, 0.2417259477925402, 0.24042789249902619, 0.2343814475697612, 0.2485658531759969, 0.252549440020861, 0.24756371313522973, 0.24562018747654712, 0.17841050126989544, 0.21811683898575274, 0.19993494853488536, 0.19588251541030754, 0.18834709577256192, 0.20232768137228008, 0.20634740394452933, 0.1929343618109277, 0.18351778691989573, 0.18554981885498978, 0.19240785472329858, 0.18014878425317327, 0.1806989956026509, 0.18243508583929713, 0.18205606667178853, 0.17550412403521698, 0.18415780147931327, 0.1801562679627412, 0.5628290917542931, 0.18195524029631815, 0.1613833601315584, 0.17314918276865265, 0.5739727728969573, 0.18951094227313503, 0.20238877211024542, 0.7095943115092973, 0.6755947238459483, 0.19848714326372163, 0.4889362523923252, 0.16491209085255853, 0.6774395599539327, 0.39665072522618416, 0.49972215878640314, 0.20393328162382196, 0.20806860570335606, 0.151434003929115, 0.1878136188316486, 0.18956029837956379, 0.17910531595503343, 0.1829260584736545, 0.18905991252710241, 0.19215444003626658, 0.18155327729895587, 0.19805367169483845, 0.18563889065652084, 0.06504927281961703, 0.07413762631840581, 0.08062987407478517, 0.07357125229958661, 0.06955720007412292, 0.07481379649127229, 0.08192767298914405, 0.07563035174627641, 0.07998158715281534]}, "mutation_prompt": null}
{"id": "eb280328-fe2f-4671-8da1-ff50cf225fa0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                candidates = np.random.choice(indices, 6, replace=False)  # Select 6 individuals for tournament\n                a, b, c = self.population[candidates[np.argmin(self.fitness[candidates[:3]])]], self.population[candidates[3]], self.population[candidates[4]]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by incorporating tournament selection to maintain diversity and prevent premature convergence.", "configspace": "", "generation": 62, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 87 is out of bounds for axis 0 with size 81').", "error": "IndexError('index 87 is out of bounds for axis 0 with size 81')", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {}, "mutation_prompt": null}
{"id": "c28c5a44-79ab-4eb5-ab1c-a5481e63b4bc", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "b51c2d0a-8276-45db-a974-e3a2eccfd55c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n        self.success_history = []  # Track successful mutations\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.success_history.append(1)\n                    else:\n                        self.success_history.append(0)\n                        \n                    # Dynamically adjust CR based on population diversity\n                    diversity = np.std(self.population, axis=0).mean()\n                    self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n                # Adjust F based on success rate\n                if len(self.success_history) > 10:\n                    success_rate = sum(self.success_history[-10:]) / 10.0\n                    self.F = np.clip(self.F * (1 + 0.1 * (success_rate - 0.5)), 0.4, 0.9)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation factor scaling based on success history and diversity to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 82 is out of bounds for axis 0 with size 81').", "error": "IndexError('index 82 is out of bounds for axis 0 with size 81')", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {}, "mutation_prompt": null}
{"id": "7f4d8032-7b0e-4f14-b9dc-a40551013981", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n        self.memory_F = np.full(self.population_size, self.F)  # memory for dynamic F\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.memory_F[i] * (b - c), -5, 5)  # Use memory_F for mutation factor\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F and update memory_F for better adaptation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        self.memory_F[i] = self.F  # Update memory\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by introducing a memory-based mechanism for mutation factor adjustment to improve convergence and search efficiency.", "configspace": "", "generation": 65, "fitness": 0.2938980299379378, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.20.", "error": "", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.6869124871593177, 0.6746639519668179, 0.6473785416772533, 0.6959842064645922, 0.663372594551837, 0.6987635443982514, 0.6651601102784249, 0.6659252235546351, 0.6571295847618448, 0.4273355399471698, 0.41934630034218867, 0.4418551148438542, 0.4428806079864658, 0.4306504482064062, 0.45757354694095986, 0.4539605387498694, 0.4135372661907858, 0.46696675395241316, 0.09449587189703745, 0.09778334325936433, 0.10392618208325333, 0.10560971188605983, 0.10203029065854485, 0.09840667971294492, 0.11143618477948403, 0.10424787650122957, 0.0961369896728993, 0.10259268133246402, 0.08771903975128992, 0.08706012583673906, 0.09137108975227726, 0.10774441332057771, 0.08107217226884367, 0.09604134352970117, 0.10661562761801491, 0.08844223711961952, 0.6560071477121248, 0.8881521722527569, 0.45940648278001694, 0.4954372801888578, 0.8550980471551495, 0.831729272639649, 0.5652137429371143, 0.8270040230542252, 0.8893041807726743, 0.28019893644839877, 0.3140818041306279, 0.2644491484265977, 0.30075560639979926, 0.31566522460928426, 0.3190184374579933, 0.3023292652878067, 0.3165028799611844, 0.2956779766352332, 0.5645871299537499, 0.5749700149783081, 0.6315458305363287, 0.6768386791288468, 0.5871024247878466, 0.6372531238864756, 0.6988128851099267, 0.6850772027369647, 0.6552933757203326, 0.18466355815191138, 0.17598636413256408, 0.27623486100805517, 0.20904950326267469, 0.16905644670311504, 0.16419417165007877, 0.19121269037263033, 0.16924876882379503, 0.2433058337609667, 0.12173967057761126, 0.1551164871159244, 0.24439876576911101, 0.18151758600605183, 0.17249936700901702, 0.16286264623413826, 0.167801991830688, 0.160498684560481, 0.1770828635893439, 0.24265304534604892, 0.17609280011536388, 0.2459641829264011, 0.24661574423494237, 0.19040095023365944, 0.2761687406905339, 0.24254020961160683, 0.2035679642172875, 0.25227253675561245, 0.4006549773486596, 0.3206332204221569, 0.41185127551615974, 0.39048586275756625, 0.31868170733464607, 0.35251216840936994, 0.4338766121109414, 0.33626606173722995, 0.40271931172563846, 0.07864259960187792, 0.033288977468578396, 0.05823814699572338, 0.13273255051538468, 0.05366589714004599, 0.09240457557326409, 0.07540125426100242, 0.05179568792188216, 0.07987713330363055, 0.2150796034976704, 0.14805855435441662, 0.19051160416000723, 0.2153979308083106, 0.1553844916430277, 0.19394629361760818, 0.20141256312461142, 0.13883839054343572, 0.2277582377463615, 0.5592440063558379, 0.47882477645117927, 0.5367588093832396, 0.5452010259183562, 0.5017196724492169, 0.5324858635931182, 0.5390961069790149, 0.48425170704955023, 0.5555995218304157, 0.09586523984434903, 0.0930349881712842, 0.10262709045126173, 0.09027829075842253, 0.0809346851927889, 0.09276284741722718, 0.08872295989033085, 0.10655857781851807, 0.09830543898732025, 0.15293237703012397, 0.15316067116828724, 0.1418874808751429, 0.1482849848862159, 0.13404061201480777, 0.14131532550618742, 0.17215077015869507, 0.14109325330979283, 0.1730894854425773, 0.32583741130205546, 0.30901237793225556, 0.3214368699956036, 0.3028948279936129, 0.31104572840458233, 0.3181932576126978, 0.3363696086802743, 0.3177288741102321, 0.34044435250026894, 0.24966151517882795, 0.21769665700755692, 0.24839368469571976, 0.23970473092863476, 0.23663130434376323, 0.24362029563365772, 0.24353860152382578, 0.24901409487418613, 0.27813637904805133, 0.19456836352633622, 0.19467897448998916, 0.20042826577772055, 0.1829988387278635, 0.1834137110317039, 0.21090725463404192, 0.2149188483836849, 0.19239316240871607, 0.20196870537749823, 0.1782614840047141, 0.17742216129542898, 0.184353225407475, 0.18751615180125047, 0.1809250932207519, 0.17870815444282673, 0.17481023656342654, 0.20258625983033474, 0.18905666796384213, 0.5608957070433169, 0.16818759903760672, 0.1735071069601125, 0.6487844868801577, 0.5890582228606754, 0.3699765523170836, 0.5465145388294409, 0.5172924281482216, 0.5921696853255072, 0.1974312945754928, 0.45336794878858544, 0.2001048361198493, 0.6250102975766936, 0.6057500005228653, 0.547219580982938, 0.20321694108737698, 0.20792787583526318, 0.5561570143327874, 0.19707384917213455, 0.21029499128310025, 0.1925152506100325, 0.18700873086700498, 0.2222155685546423, 0.19537028202439854, 0.18626112769319136, 0.1859963722094491, 0.1967378365554383, 0.08136270284160996, 0.07966528653143012, 0.07402795167353793, 0.07293614607648491, 0.08785427693753778, 0.08966118065517314, 0.0746285708633021, 0.07617767525042074, 0.07760920701450535]}, "mutation_prompt": null}
{"id": "cf2c0414-58e6-49df-90cb-996e5338b4dd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "240ed916-d385-4323-ad3d-f881b1c1ca90", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "bb701dcc-83f9-470e-a6b9-ebcff44554e5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        self.F = np.clip(self.F + 0.02 * (np.random.rand() - 0.5), 0.4, 0.9)  # Adjusting mutation factor more responsively\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by introducing a feedback mechanism for mutation factor adjustment to better balance exploration and exploitation phases.", "configspace": "", "generation": 68, "fitness": 0.3055912379224963, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.6950394272644134, 0.7054352607105396, 0.670021407590567, 0.7003563547429829, 0.6619545596914488, 0.6963298749448992, 0.6559776463487829, 0.6906720171686626, 0.6884154414518661, 0.5151266902169276, 0.41167734476297535, 0.46860720950973644, 0.47792025864734, 0.4991360705908914, 0.4035225765900585, 0.4506948309499289, 0.4553915984502762, 0.43315853382835234, 0.13591264177199447, 0.09890330761098776, 0.09680743661276936, 0.10150189493955986, 0.11491284571650595, 0.10731810954757803, 0.1035482438155958, 0.11906019003638935, 0.10373813452825831, 0.09978232622802952, 0.09113087100960415, 0.0969788709710665, 0.08748392469753963, 0.09753563746209604, 0.09377861598344439, 0.09436036644271517, 0.10143171275138407, 0.0992898333190293, 0.6847969969695824, 0.894841227813739, 0.7116605665534645, 0.8251077137032687, 0.8670431009939978, 0.9579544973176088, 0.855748233095862, 0.836820156707091, 0.8471358233427874, 0.3112135224223226, 0.29742231783902884, 0.2608852670416104, 0.3176770846434943, 0.33509340862054815, 0.3002358742578748, 0.33466240760878463, 0.30231476467693585, 0.3612376007032807, 0.6523196922370167, 0.6761616789576363, 0.6560235537711172, 0.7246801600330166, 0.6842814964352599, 0.631243016990984, 0.7967286483518811, 0.6518707650676029, 0.696358592629383, 0.1447891998332751, 0.1764212850843223, 0.22460401089093218, 0.13688257845024931, 0.1415534916804394, 0.3344058178966569, 0.2165227678651782, 0.15048387367251248, 0.1752152156651029, 0.13569235389642542, 0.1763817894604197, 0.19924408233670543, 0.26042275230803924, 0.16916173042874139, 0.1532028655118387, 0.20764048043432937, 0.17432225456835204, 0.15856429378300074, 0.2777019965832903, 0.18680762429343523, 0.2713523329636164, 0.2669183287623509, 0.18536296274168762, 0.29437960547205466, 0.2960141035479177, 0.22558137594304561, 0.2676619290555796, 0.4063490296455968, 0.3597686793857995, 0.425421513865783, 0.44455759425320995, 0.3388294196133387, 0.4025123249110244, 0.44927524682599707, 0.34457085310592706, 0.43964039384807196, 0.0859185558931913, 0.06359363076088698, 0.08316729523793931, 0.1738713354576168, 0.06869931246853467, 0.1229029972136344, 0.10127795692622166, 0.08738455586427285, 0.05913497594787509, 0.2057024253036287, 0.18722702063241692, 0.20212069907895436, 0.22912146872213357, 0.1738664848951894, 0.2275189251313947, 0.230722713948889, 0.1581000106329804, 0.22417313881370005, 0.5820497998770316, 0.49981903068125777, 0.5972975583515331, 0.582134669804081, 0.49617791549488877, 0.5756219829554554, 0.5777211389261446, 0.5337181868931073, 0.5294363949052886, 0.09506252166329399, 0.09614855372187847, 0.10073458617977737, 0.09068664108688063, 0.0882481577427181, 0.09386657191818926, 0.1016283064316198, 0.10610924339883077, 0.0880434241083583, 0.18573076967974844, 0.15517525401399124, 0.13202145030493628, 0.15409065195171312, 0.17826827227914455, 0.1795729285793365, 0.14293038489131626, 0.12558678622030361, 0.14526910401418514, 0.3157542719906442, 0.33087372185405595, 0.32326767805481116, 0.3251433357094434, 0.32141182606857066, 0.3382166166069682, 0.3698956586041089, 0.3289121301833585, 0.3497184647833884, 0.2580399102799368, 0.24164943933593463, 0.26605197663618607, 0.2616484585748883, 0.2274518879693853, 0.251758102777492, 0.27129097341411423, 0.2570865837474626, 0.2648099785874387, 0.19909219926355304, 0.19910420873554524, 0.18075410104943657, 0.18382099533222152, 0.19806167176323908, 0.18444661664676143, 0.19359867170460932, 0.20700871349412164, 0.20614375367025262, 0.19011632666566003, 0.17647518249582006, 0.18720692041699405, 0.18804633977724383, 0.18961782955637618, 0.19910311840182016, 0.17847772650266547, 0.18718176768802464, 0.1781692461426133, 0.18002607171706841, 0.18965400337434135, 0.2045992074114914, 0.5791955707222477, 0.18079058023714678, 0.6533560871353432, 0.5808363650668684, 0.18910068441706274, 0.6678513725060782, 0.4122946197309686, 0.3705381701582803, 0.20122980344459984, 0.6056709607765749, 0.4984188897558317, 0.5973206945247586, 0.6642267748437025, 0.2087263140106519, 0.15793955885911837, 0.19105834460759663, 0.19312976814711347, 0.2250896120193785, 0.18701043859136446, 0.18574718625951758, 0.17987509874119934, 0.18356418993209644, 0.17727461623932594, 0.18080798065952508, 0.07316175433712646, 0.0794541230177398, 0.08193193770976526, 0.08378570539486885, 0.07519596494046998, 0.07906891438023955, 0.08190518803418123, 0.0745147026864037, 0.07364954910491883]}, "mutation_prompt": null}
{"id": "2e457de6-34a0-4bdf-9f80-5ac5401d4dfb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "2e4028ab-e37c-4065-8650-aa37d8309a26", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "dfc92b36-fb5e-4b26-929f-8062fd5f3069", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "a54a9ed8-bd8d-409f-89d6-4a49db58ac3c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "ce4f7d68-f9c2-4c9f-885c-128cf038626f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "22879e25-a0e5-46af-b920-37ede1d5cbe8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                adaptive_F = self.F * (1 + np.random.randn() * 0.1)  # Adaptive mutation scaling\n                mutant = np.clip(a + adaptive_F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n            \n            # Periodic local search to enhance exploitation\n            if self.evaluations % (self.budget // 4) == 0:\n                for j in range(self.population_size):\n                    local_trial = self.population[j] + np.clip(np.random.randn(self.dim) * 0.1, -5, 5)\n                    local_trial_fitness = func(local_trial)\n                    self.evaluations += 1\n                    if local_trial_fitness < self.fitness[j]:\n                        self.fitness[j] = local_trial_fitness\n                        self.population[j] = local_trial\n                        if local_trial_fitness < self.fitness[best_idx]:\n                            best = local_trial\n                            best_idx = j\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by incorporating adaptive mutation scaling and periodic local search for improved exploitation and exploration balance.", "configspace": "", "generation": 74, "fitness": 0.30430892019711586, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.21.", "error": "", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.6835460539241869, 0.710696268080738, 0.7000644778471479, 0.7345211590282199, 0.7115539666222284, 0.7174172349808157, 0.6948544960273169, 0.7045096632095862, 0.7024908055617517, 0.44630355140803046, 0.5097120105805195, 0.452125775285553, 0.47265864204276997, 0.46607868127229246, 0.44752993274186426, 0.46728503266535504, 0.4669766770366246, 0.43958138553257087, 0.11033018810302564, 0.1077255325352886, 0.10777721405198537, 0.1083023455680574, 0.1080583955615182, 0.10003726272316038, 0.11857160204696648, 0.1089366291617836, 0.1035497188766934, 0.09681273019564485, 0.10184722925190415, 0.10168864217856555, 0.11192314462422182, 0.09890487710867513, 0.08771188083031589, 0.08435173527186213, 0.09632025625473672, 0.08835642732027682, 0.6737993175427699, 0.8246503884423897, 0.5764062684848315, 0.6174183891773976, 0.8236621329359627, 0.8049827730305414, 0.9735016554286381, 0.8162268179316189, 0.7786213730654787, 0.31371280520469436, 0.34043185826846123, 0.34758718237169883, 0.32469270211630263, 0.3055187555267491, 0.35648985170053527, 0.31848305613064565, 0.28201828272756835, 0.3469913851182309, 0.6722157633970751, 0.6667417063968266, 0.6769055521869914, 0.6632428258475291, 0.6699035609298865, 0.6687583005937594, 0.7375238236119551, 0.6997443465738329, 0.7414984382764069, 0.15561901148409307, 0.17565160209169428, 0.20308972191393682, 0.22323727307206953, 0.18138902287295477, 0.1679780895682832, 0.19609391656405495, 0.18265502286132196, 0.14972799695919836, 0.21615063129275225, 0.14972645586503963, 0.15435458946400338, 0.18488455515258606, 0.1649293754973169, 0.17904006732147992, 0.19406489396828286, 0.17028542421366277, 0.25099665137636573, 0.25082216903819354, 0.19645535513733403, 0.23019276458787052, 0.2645100088759367, 0.21158403552304472, 0.3115260675411802, 0.2815267028124886, 0.21261764316744425, 0.3141739276465557, 0.44561492475451225, 0.31876777313922944, 0.41524210941134587, 0.421717657075633, 0.3552585297369315, 0.4000617865275944, 0.40117588759928824, 0.37833836191035974, 0.4196373247792493, 0.0670258088666249, 0.037646758486051146, 0.07473799871255338, 0.09783651586567399, 0.06575001307578365, 0.1010424182265548, 0.13580780006095916, 0.0797112204763264, 0.1079428752294409, 0.2344797160980806, 0.15593819130496556, 0.20657504386714998, 0.2211693102204022, 0.18101428991447377, 0.2492945841884896, 0.21066335699122785, 0.1790313914367636, 0.22896715096101838, 0.545662628244413, 0.49951713659519814, 0.5616255811314348, 0.5773045961820666, 0.49180847280056494, 0.5680311028575091, 0.5567188256773581, 0.5347770348178327, 0.5531879243289548, 0.09802902961772075, 0.1051323754356428, 0.08636094925718552, 0.10163112531191432, 0.08901209572089175, 0.1034031802123978, 0.10471407892334506, 0.11041932844276292, 0.10076292555925959, 0.15830490838778788, 0.15104081302400096, 0.17283430614332884, 0.16652617968592154, 0.14917138887631265, 0.15842330712960262, 0.1829252749335144, 0.20143667165254742, 0.16035650442338212, 0.33436740719359337, 0.3338911817613962, 0.33317646190261874, 0.34424525919377424, 0.3205774286338777, 0.344266593089702, 0.36141381901177405, 0.3432775389898288, 0.3498315203282234, 0.2793228588488893, 0.25735347455765234, 0.2587403160258356, 0.27268874257489706, 0.24756087477080901, 0.24622551228662226, 0.29414651974835604, 0.23483301934233014, 0.26975096738416016, 0.2011781985263219, 0.20820453375993597, 0.21334602007588277, 0.19108044653757872, 0.19050495457218697, 0.19963906896140904, 0.24098793814571307, 0.19998907373237218, 0.1852082383640551, 0.18831873009532185, 0.18401324038533473, 0.17904836543139424, 0.17795037141421777, 0.19845632865418716, 0.17464534218565553, 0.18906682727651403, 0.18685877469409162, 0.18535193882712664, 0.18443943402119234, 0.19180620741300336, 0.6516858012451259, 0.17689748383161963, 0.4843938356187979, 0.6027045580820856, 0.5007849097981674, 0.6591650832682551, 0.48194914822894197, 0.16307547917166465, 0.6940108777951101, 0.16473111009835406, 0.6075000034907727, 0.19683158471114215, 0.5729125973438804, 0.2033687839302879, 0.20308283309353448, 0.20267556903084583, 0.19484614825425461, 0.18453964348542984, 0.2002783963035717, 0.1828141295844271, 0.1786365803358796, 0.18836942811898694, 0.191655643058531, 0.19254040402687045, 0.20883814141452983, 0.07943018843336991, 0.07846537908383888, 0.07846619803549204, 0.07979029555669293, 0.07296359566856103, 0.07842723663533802, 0.08149788312405237, 0.07431332250343115, 0.07963050280762085]}, "mutation_prompt": null}
{"id": "b39aef3c-a0e8-4875-aed2-abdd3509a316", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "f1607ffd-b3d4-4dc5-bbcc-0bc1700fd3ad", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "070d51b7-e40c-4b9b-84f1-5535ddbceea6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "b03ffad0-1e7f-4505-bb71-1e02ac2f2e5d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "48a82aa6-ccae-40b0-ac1e-bb077db4269f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "f6220985-28b1-4d44-8ea3-ff23aa751a96", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "15c887b8-0d76-4c0c-9b2c-2e1a9173f4d3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "ffce5d69-37f9-4ba6-ae98-80311200af1e", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "3bb590a6-2bf2-4663-9f65-3007e85348ee", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "231bbc77-3786-40b3-b94c-7e8cafb827f5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "c026e9c0-f65d-4dff-954f-7be05174ee28", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "c98570c4-c79e-44ab-8be2-11d0df3a64f9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "691fe8b8-7629-4992-86eb-f9691c52dc57", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce selective reinitialization\n                    worst_idx = np.argmax(self.fitness)\n                    self.population[worst_idx] = np.random.uniform(-5, 5, self.dim)\n                    self.fitness[worst_idx] = np.inf\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.015 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by introducing selective reinitialization and adaptive mutation strategy for balanced exploration and exploitation.", "configspace": "", "generation": 87, "fitness": 0.3093705885653361, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.69720385259026, 0.7065718213251266, 0.6633652648621866, 0.7169567429424248, 0.6974626282774219, 0.7106865201453445, 0.6884204263168545, 0.6791054074051519, 0.7271623220173196, 0.483380679822782, 0.4647784133406, 0.4316658010239519, 0.48302648366235823, 0.49257257593014936, 0.4838455774205299, 0.46451504575239955, 0.5199612018735236, 0.4497740616395286, 0.11612050842746247, 0.1025851750018334, 0.10754676433126498, 0.10415464594149759, 0.11048263808917202, 0.09806921356999865, 0.0920860146376653, 0.0929783463186914, 0.09925268116525787, 0.08428795244584275, 0.10813331729256515, 0.1054883057198267, 0.10474360897155821, 0.09312941071368819, 0.08982549925508287, 0.0963201238791016, 0.09920050769734057, 0.09590424560670163, 0.565239788557556, 0.6490097699717338, 0.6093469994574188, 0.47702423090140333, 0.523135709303555, 0.9579567201791306, 0.6982767001734784, 0.4842917149971593, 0.8798001335742224, 0.30850284423974594, 0.35185570336980565, 0.3136194844166015, 0.3163446810506756, 0.34327834876101004, 0.2995014780606502, 0.34304658581164726, 0.35385070253414763, 0.3564053103103464, 0.6759683801870047, 0.719747774850996, 0.6478769093261383, 0.7366079049526523, 0.6779073544401745, 0.6396584567688886, 0.7409812011627106, 0.6911035863611918, 0.6535244231354669, 0.2553762509157679, 0.18103058621582147, 0.2308314967049977, 0.18523711408398413, 0.21425905410145507, 0.17242437124414078, 0.17603133607480104, 0.17020966345764987, 0.16659967104551776, 0.20150649084572314, 0.17091299661384018, 0.2071925347962127, 0.15507170944400128, 0.1656150198388202, 0.18048659596085037, 0.19415246575065914, 0.21836760399679034, 0.17994855488612738, 0.2580884374981025, 0.3010468344505758, 0.2242118760729206, 0.260863638204923, 0.2555221211147387, 0.30238265515110074, 0.2841028052591613, 0.2785262273456769, 0.25110881344491764, 0.41506746301933817, 0.42263442205898905, 0.3912272786724449, 0.4320277869008462, 0.384346733289342, 0.47477364206594663, 0.4701092788882587, 0.4351291299297756, 0.4072742129538055, 0.07867578855755453, 0.06572388980977206, 0.11425716136668229, 0.15582471207461057, 0.0904329927423041, 0.11987511518173943, 0.07255156268538376, 0.10795893409946489, 0.10292548389540057, 0.23658154767564443, 0.21160132481503935, 0.20659908881032474, 0.2193243842537439, 0.19522969795668965, 0.23795872350942515, 0.21262500278791419, 0.22254788207039455, 0.24104397695287683, 0.5777192303561669, 0.572293581223431, 0.567880389389035, 0.5524178842722737, 0.550518275869091, 0.5668742880967264, 0.6099936649524178, 0.5609177287579279, 0.5623574147353312, 0.09464420189864908, 0.1080865592223792, 0.09655131909984827, 0.12278283710352922, 0.10020341855728898, 0.10476725896774897, 0.08981167783650468, 0.08477432572268606, 0.09056662389410863, 0.16358274524840266, 0.15923017628140146, 0.268079855058204, 0.13997706105090912, 0.14039596016703904, 0.18237187978606728, 0.1445738952108493, 0.14361648052030485, 0.2478679563239492, 0.33089680153413914, 0.3625259303346158, 0.3319886685773674, 0.3580870182276291, 0.3552341946978773, 0.35665966608034905, 0.36179313597087037, 0.330052483170026, 0.33622741681043733, 0.29117430993133475, 0.26398704751316415, 0.2534887599708048, 0.2602093211230647, 0.27412462420889383, 0.26373900453822485, 0.2685474339668057, 0.2743232614293959, 0.2726694126499184, 0.19537283616145584, 0.17674059124364117, 0.198339668703441, 0.1879999368636195, 0.20871825509833886, 0.20143988213185826, 0.18917248773085205, 0.20921738723937555, 0.17357511008638737, 0.18435120945120287, 0.1818391723585231, 0.17960226274815216, 0.1890933508668441, 0.19496603859617467, 0.18153822771802475, 0.1975995337687464, 0.17562624533832183, 0.19200841636165544, 0.18959121425781245, 0.7301869406173822, 0.6983878128413499, 0.17971927776938645, 0.49859347256731523, 0.5042589056396316, 0.5496642063742361, 0.5036013204393645, 0.6040834983292314, 0.5984510311313755, 0.5497863116767975, 0.20288926254414297, 0.6607585136347185, 0.20027411259889727, 0.4412559729665254, 0.4310921327651177, 0.20453157509337327, 0.1519744488027105, 0.19938983538835908, 0.18612541661166615, 0.19415467242610096, 0.18761534269190105, 0.1814011746536638, 0.18042794136890883, 0.18234311471991727, 0.18268950504123405, 0.1704601787925627, 0.07778593251966393, 0.09429497996369407, 0.0814319982192806, 0.08723464746499243, 0.09063011604059756, 0.08112381846164574, 0.07558260583147836, 0.0783031346629699, 0.08810608858982139]}, "mutation_prompt": null}
{"id": "69767f81-ddfc-40b0-8a7a-7895c1691f2f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "78f73a93-1dbe-4662-ad53-ca44f3b04f83", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.95, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.15:  # Increase probability for reinitialization\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.15 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic reinitialization and mutation strategies to enhance both exploration and exploitation.", "configspace": "", "generation": 89, "fitness": 0.2907532917169308, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.6976797045195544, 0.673090701906599, 0.6541291053987139, 0.7166833679245974, 0.6632824388169979, 0.7081317112678964, 0.6818434542762501, 0.6836275823464519, 0.6839231302736992, 0.4265226077594091, 0.40624124616177815, 0.4133254687222989, 0.4151091294013787, 0.4715677860954479, 0.44666823128524513, 0.4091183487754255, 0.4224074467722315, 0.4029855539856366, 0.10825162491394136, 0.11276442305353396, 0.10742218804927584, 0.11867024260441306, 0.1063324424578046, 0.09862098074604386, 0.1169204725577152, 0.10811286374030515, 0.10390101505366989, 0.08950157544636073, 0.10297204950678984, 0.09327095507068772, 0.10223898219132821, 0.09791246912722673, 0.0872348539580613, 0.09597404760271133, 0.10421171461191969, 0.1004148091222774, 0.7406285392818285, 0.9532551133632616, 0.7793049638184424, 0.7390216886563032, 0.8316764446032945, 0.8654212379518037, 0.8802199950553554, 0.8697870594697024, 0.9648116242802012, 0.27353491100603455, 0.2806336190864558, 0.285497835440816, 0.3181151248079763, 0.2969437475568396, 0.3014552641526935, 0.33028589475582726, 0.3047323690889743, 0.32847945061081196, 0.6775488731824588, 0.5631058126553526, 0.6304330582634251, 0.6193908292700291, 0.5958490379501611, 0.6656684941913691, 0.6804472455187066, 0.5883639306109911, 0.6162658550469786, 0.1997341074658543, 0.17363646264107702, 0.18983273376433452, 0.15379751406867248, 0.18646400630752424, 0.168898316559982, 0.19340480205328403, 0.16336328681021772, 0.1723604051325598, 0.15015171007943195, 0.1153624955744521, 0.1674134818642955, 0.17552403386179394, 0.15723968644603703, 0.23706035457788577, 0.18693509454904156, 0.17770285178001632, 0.16195997034190945, 0.18983941801954352, 0.1785875651266362, 0.1988379420341989, 0.19156967292572402, 0.16387042104556637, 0.19378946912403894, 0.22833063256501596, 0.1623417812267146, 0.19963111437962278, 0.3867880683197801, 0.32077345724532647, 0.3499197104022891, 0.3065389795907728, 0.33626411806774836, 0.3564429008660346, 0.36160594043356553, 0.31685682183142017, 0.38512891427810036, 0.07932556263872592, 0.04558535813347131, 0.058116714026557714, 0.07901341631951275, 0.056758739824631865, 0.08300147826495852, 0.08513927011873257, 0.03535187223895042, 0.04869677289258234, 0.19991777235995178, 0.16671078639288595, 0.18693020106185476, 0.20434324398475923, 0.1702270600205329, 0.20353241062577831, 0.19165244081014188, 0.1550112514094164, 0.20155757161693177, 0.5371398811395947, 0.5005349518368685, 0.5322802403968436, 0.5305792760774053, 0.48092648887352496, 0.5366078977181037, 0.5577944452615333, 0.48948172531914835, 0.5095977004265944, 0.100317535909077, 0.09278002191794588, 0.09201490766850806, 0.09835013966077588, 0.08420376564652887, 0.09196302960290592, 0.08679731729294904, 0.0942267446706041, 0.09112631282505412, 0.1407557341119383, 0.14674570184235636, 0.16306250545104872, 0.17893157158066408, 0.18915231382654918, 0.14507327078963694, 0.13833923842536444, 0.22432168570949518, 0.21070596546543985, 0.31751940468730855, 0.3244953253224958, 0.32400845367871445, 0.32461136012941894, 0.29947644004798557, 0.31398976928784617, 0.32660830008969566, 0.33651902047292603, 0.32397191444358864, 0.25144091980011485, 0.22515137483920844, 0.24897487800491103, 0.2564551340449178, 0.21403572309209684, 0.24360388830382484, 0.27529664073019844, 0.24970758784479596, 0.2465156114211977, 0.22176425994963345, 0.19787844626838136, 0.20426717794556515, 0.22430590512956328, 0.1881009408317148, 0.19337418293508513, 0.19125230313956254, 0.20529288817753533, 0.1951332681692899, 0.17938742909891026, 0.20088115638486093, 0.18143616646409733, 0.1826100553929475, 0.18644704520508804, 0.17445433843851665, 0.19105067335035764, 0.18874685040711237, 0.18458624069770913, 0.5357313494957685, 0.16664440024564442, 0.17954034906351135, 0.6006198568072981, 0.1766450506058358, 0.6373200641968859, 0.5134949202525007, 0.5382985639729069, 0.6347451725916258, 0.19818124728017816, 0.48981535401766585, 0.1993237138431294, 0.4711845413676309, 0.1763858334140277, 0.2156659680916092, 0.20414504247027454, 0.20402390512025037, 0.6075152277404476, 0.1910005838187786, 0.18561593348774919, 0.17984981429651692, 0.17053823536018664, 0.1882320478244398, 0.17858235131956812, 0.1911274372416758, 0.1888437664575403, 0.1990666748387293, 0.08287210511396548, 0.0957048041730919, 0.07749587184129325, 0.08748318744962347, 0.07041980002979908, 0.07090959541445407, 0.08192362508254225, 0.07620170153768757, 0.07962856203796709]}, "mutation_prompt": null}
{"id": "a44745ef-e021-4ddb-9c9e-7d303888cc72", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "1a03fca3-5699-4d39-97b5-2b4e2e645e4b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "87ce4888-1b14-4d5b-af27-d0c96d980b63", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "4f615b97-420c-49fa-8626-2048b3d0e9e6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "7cb4e5e4-9dc4-46dc-817f-2459fcee79ac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "58e8a10b-a767-4733-a344-ed17fb5cac6a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.02 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity and fitness improvement\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * ((diversity + 0.1) / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by incorporating a self-adaptive strategy for both mutation factor and crossover rate based on fitness improvement and diversity for better convergence.", "configspace": "", "generation": 95, "fitness": 0.3063394969663545, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.21.", "error": "", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7039014944251796, 0.7033768774921901, 0.6852838725464765, 0.6907209178724911, 0.6672261029279969, 0.6698792774175428, 0.6733976513083004, 0.7107013800983801, 0.7017923479599519, 0.4629951428840191, 0.47768069968979476, 0.44457736440477136, 0.4674775739030912, 0.4739197390105112, 0.4597129872844018, 0.46238396048770847, 0.47341379740857215, 0.45602885998012666, 0.1061795462244558, 0.10843085147313125, 0.11758235500112657, 0.09950628263442707, 0.11325496633069976, 0.10235643694386676, 0.11390252863608963, 0.10915090111175396, 0.10992682154949596, 0.10017439409475681, 0.10597379106346694, 0.0939964750553911, 0.0867613109339973, 0.09608681823110188, 0.090500456171826, 0.10668292354189457, 0.08703901697240668, 0.10825049301691092, 0.4941482888056127, 0.8727375596796931, 0.4580110290102115, 0.6438452882072541, 0.8362610924138263, 0.9579544973176088, 0.6627300206084836, 0.8405377321531388, 0.8432748325008764, 0.3131331742707324, 0.3128399672103849, 0.2817382908216972, 0.3473396889673872, 0.31992524695981717, 0.3244259668903, 0.3365047064904342, 0.3201362842643567, 0.3492890168177112, 0.7007941267213134, 0.7042425670469915, 0.6240739993607944, 0.7212063750057014, 0.7593695248013947, 0.6378650972348461, 0.6992832964178298, 0.746419181229526, 0.7407447367130663, 0.183885027642667, 0.1705865874546838, 0.2317021789662579, 0.20394232084220654, 0.15322142748031853, 0.16528707972943735, 0.22304581541512525, 0.17663676823488061, 0.2085593810238522, 0.1673910509753841, 0.15533649693125295, 0.18768696715436306, 0.1436993687783954, 0.20436991899472823, 0.16486701485745603, 0.18672805324045205, 0.15941837690263583, 0.17304426179701982, 0.2844630668038308, 0.22320146973691102, 0.272850428469132, 0.2862402082231378, 0.20803116580817083, 0.3007619995648998, 0.2678740403911961, 0.22794406468441464, 0.27372066385288185, 0.43989709408699074, 0.3861689464415633, 0.4176035125171741, 0.4765765285498844, 0.37024380766770515, 0.44769172420209835, 0.473826717105327, 0.369346900452328, 0.4453222280057869, 0.0932777581856864, 0.03667217544813617, 0.10261667578132916, 0.1499851755890773, 0.0766659965591533, 0.12873313459192182, 0.1330576353760372, 0.07774485031545264, 0.10809029805111692, 0.22881705541592934, 0.19195583468216315, 0.23329206896571042, 0.2450119599056213, 0.17898179536939118, 0.24334128055054693, 0.22730537351305524, 0.15492784543076266, 0.2425971185693463, 0.5743687079460484, 0.503982009238331, 0.5694365780028567, 0.5973858087980812, 0.48841850285703736, 0.5691077512111931, 0.6050653777071321, 0.5089113512992358, 0.5624745946882743, 0.10525644572475412, 0.10743132732211635, 0.10181383281927392, 0.1033723868128722, 0.09749662975041717, 0.08750360027988158, 0.10479338170052366, 0.09863198704736675, 0.09579029713683596, 0.18652099678271394, 0.15517525401399124, 0.13202145030493628, 0.15409065195171312, 0.17826827227914455, 0.1795729285793365, 0.14293038489131626, 0.12558678622030361, 0.14526910401418514, 0.3327506280037634, 0.32922385926205844, 0.3495270188305988, 0.33935159704292905, 0.31886612577043894, 0.34589000057620345, 0.3456751000694157, 0.339963313902063, 0.3486744525837384, 0.3050597233576706, 0.2515216443065449, 0.26521603396257154, 0.2574017851168853, 0.23289014076426362, 0.2507992736610276, 0.2888318992513257, 0.2581183167854758, 0.2839572511400521, 0.19909219926355304, 0.18501703390899238, 0.18615097633238598, 0.18851303857866142, 0.19647455410941517, 0.187469923361266, 0.1921462870097007, 0.17951229478855457, 0.18648349029861333, 0.1759022435303541, 0.20381086381824476, 0.18682898927307, 0.1891216496912893, 0.18550855662410737, 0.18551408785180223, 0.18631901277685714, 0.180702946893867, 0.18223986266623438, 0.18006237597971708, 0.19080813132485608, 0.20463170111088658, 0.5757179964313655, 0.1810333334413865, 0.6610907744919685, 0.5898148160880099, 0.18905971189173498, 0.6671313130859744, 0.34049835253490446, 0.4429255164621796, 0.1986849667334324, 0.6859420098899593, 0.5206729099398069, 0.6259913208165814, 0.6749553851068456, 0.20865002470075455, 0.15808043672874406, 0.19105834460759663, 0.19312976814711347, 0.2250896120193785, 0.18701043859136446, 0.18574718625951758, 0.17987509874119934, 0.18356418993209644, 0.17727461623932594, 0.18080798065952508, 0.07763286083884957, 0.07538991095887737, 0.08434256452521771, 0.07670079507512806, 0.0694874182826255, 0.07719559135789189, 0.07401868327869321, 0.07712164468533955, 0.08362628993558341]}, "mutation_prompt": null}
{"id": "8d758427-8448-41f5-87bd-6dd0fef82cac", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "0247fcce-2d2e-4441-a023-50352db773b1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "e8484882-7ded-45ab-a8c7-59ffe69bcbaf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
{"id": "ba8cfc23-20b7-4e9c-b613-83b8c885d211", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, population_size=None):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = population_size or 20 * dim\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.F = 0.5  # initial mutation factor\n        self.CR = 0.9  # initial crossover rate\n        self.evaluations = 0\n\n    def __call__(self, func):\n        best_idx = np.argmin(self.fitness)\n        best = self.population[best_idx]\n        \n        while self.evaluations < self.budget:\n            if self.evaluations % (self.budget // 10) == 0:  # Adjust population size dynamically\n                self.population_size = min(int(self.population_size * 0.9), self.population_size)\n                self.F = np.clip(self.F * 0.9, 0.4, 0.9)  # Adjust mutation factor to improve convergence\n                if np.random.rand() < 0.1:  # Introduce reinitialization with a small probability\n                    self.population = np.random.uniform(-5, 5, (self.population_size, self.dim))\n                    self.fitness = np.full(self.population_size, np.inf)\n                \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), -5, 5)\n                cross_points = np.random.rand(self.dim) < self.CR\n                trial = np.where(cross_points, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                self.evaluations += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial\n                    if trial_fitness < self.fitness[best_idx]:\n                        best = trial\n                        best_idx = i\n                        # Slightly adjust F for better exploration and exploitation\n                        self.F = np.clip(self.F + 0.01 * (np.random.rand() - 0.5), 0.4, 0.9)\n                        # Dynamically adjust CR based on population diversity\n                        diversity = np.std(self.population, axis=0).mean()\n                        self.CR = np.clip(0.8 + 0.2 * (diversity / np.sqrt(self.dim)), 0.8, 1.0)\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution by introducing dynamic crossover rate adjustment based on population diversity to enhance exploitation capability.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ea9396a4-a8d3-4534-aa54-be19e31c9ff1", "metadata": {"aucs": [0.7033754149739171, 0.6996987220344404, 0.6838196359826827, 0.7095970927312172, 0.6786251695956098, 0.6940397857263951, 0.6832176981625179, 0.7081468245884077, 0.7066578666194075, 0.45582479497988593, 0.4655469519598555, 0.4761985867087022, 0.5369441711617922, 0.432012698235376, 0.46256668668051404, 0.48476371410471486, 0.4310815776399527, 0.4521361189330211, 0.10094574269617129, 0.11169655497293474, 0.10820453684876297, 0.10281272868665803, 0.11490253947158346, 0.11001087983533053, 0.11137493566030843, 0.1293101238623281, 0.10217032965442763, 0.1010531148026772, 0.09563814691972106, 0.09370251521491413, 0.10243667414500446, 0.09232129617681406, 0.10084975894816983, 0.08622759661104118, 0.1056502563157461, 0.09329191845894269, 0.5686893761438714, 0.8924314079548445, 0.6611054024444714, 0.5750774763386934, 0.8399934832121928, 0.9579591982640933, 0.9181301392570449, 0.8567510938220957, 0.8170500982286412, 0.2922762473437479, 0.3283584911964952, 0.33866782961627084, 0.355465501353766, 0.3066513391074591, 0.359390374458041, 0.33352213563040434, 0.2976557349496395, 0.34455732364059644, 0.6604776877264003, 0.6551111939274226, 0.5855920730628503, 0.7089171042562891, 0.6369172235575857, 0.6837137216866083, 0.7334391198591875, 0.6152636583813834, 0.7165449809963758, 0.19098541199848806, 0.15227854254770368, 0.18193388130190824, 0.1828163261954, 0.15045776660485977, 0.2096454533627723, 0.26909068199100916, 0.1741192548981091, 0.18106356670766144, 0.23699035825246462, 0.14287051512989113, 0.17988504930263716, 0.16341537929987804, 0.1712885373695905, 0.24286464954322196, 0.23160569019734056, 0.16785945662129276, 0.2083669128768072, 0.26970320601575837, 0.18794527231229163, 0.26227137509777276, 0.2901235640262866, 0.23808909757680752, 0.25876782089499795, 0.29436026326159603, 0.20232729528526272, 0.2845801494026612, 0.3862646535453301, 0.34294453967387795, 0.4342776485032248, 0.414814918971407, 0.33744347951114995, 0.430437076317425, 0.4334863360409206, 0.35645154545035607, 0.45603118998005476, 0.0972232998185355, 0.06415467396701424, 0.0863274472321156, 0.10656408810454254, 0.07504649864129442, 0.11108045835725022, 0.1348212693409181, 0.06359520424409837, 0.11242847140606682, 0.23581954497022484, 0.1759265355521462, 0.21870292483618836, 0.20265309750550087, 0.16399609513704194, 0.23740341933529485, 0.23529027774299938, 0.1583985048535902, 0.2308859444435829, 0.5539308974267373, 0.48955666425567246, 0.5359462824743542, 0.5688497674145663, 0.5098983544640183, 0.5733627188315762, 0.5643428612376754, 0.5231639102749148, 0.5783580076917283, 0.10106921583357631, 0.10040732770833916, 0.09472279455816102, 0.10135566942113383, 0.09383384810681583, 0.10526152578202308, 0.13160732530766728, 0.0869967683681796, 0.09020300772820333, 0.12574647663480287, 0.13681938154082907, 0.15772399569507, 0.17538377220866042, 0.15525917860940186, 0.14522694003936376, 0.1795345126446275, 0.1462802164573559, 0.13142270532036815, 0.35328633048219216, 0.33774070520073984, 0.3337827749277268, 0.32145971505941573, 0.32698739489731943, 0.3275949063371729, 0.3486437936055933, 0.3199421932959915, 0.35546785685890003, 0.29142855215771124, 0.2526483116086532, 0.2770970470709707, 0.2720598228125648, 0.2329843355630159, 0.27874480266632173, 0.2981445561295174, 0.25677057596549946, 0.2744203638158783, 0.1910008616539962, 0.2043118565558043, 0.19207107324356099, 0.19439288457111348, 0.19833267962754453, 0.21171716854314704, 0.1932603783210608, 0.17867011116700904, 0.20205042642592497, 0.18141983232079983, 0.17746718219496194, 0.1869370313301758, 0.1935581995457859, 0.19738683463859596, 0.20516406828192635, 0.1957824456273567, 0.18546755304690543, 0.18304154341415035, 0.18293857031737637, 0.16836834353258923, 0.6928550090879921, 0.5554761285252987, 0.6131821354163483, 0.5823591473250904, 0.4990291659851884, 0.5910125342445258, 0.6424389388301968, 0.5902318409591463, 0.6012714752732522, 0.47773530302992095, 0.6190767352926667, 0.19236849046328142, 0.6056932639291691, 0.6058271625863548, 0.40449455742201046, 0.19584102137265968, 0.19398057919494072, 0.1795503124266259, 0.18417469612411907, 0.18549849811112462, 0.19191112815264055, 0.17229778357263603, 0.18308551547740504, 0.17821151417997394, 0.1927780168960309, 0.08600099510069048, 0.07452513864253885, 0.07798528906555291, 0.08083877782700344, 0.09288791098616911, 0.07790454317073414, 0.08017891668334143, 0.07913042842025786, 0.0770114884084886]}, "mutation_prompt": null}
