{"id": "a3273c8e-d739-463d-b646-bf5bd3dbaee5", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20 + dim  # A frequently used heuristic for DE population size\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        # Initial evaluation of the population\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                # Selection\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Adaptive Covariance-based Local Search\n            if self.evaluations >= self.budget:\n                break\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "HybridDifferentialEvolution", "description": "A hybrid differential evolution algorithm augmented with adaptive covariance-based local search to explore and exploit complex landscapes effectively.", "configspace": "", "generation": 0, "fitness": 0.30247626094708313, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7072877773565559, 0.6558976057314065, 0.7011739607032947, 0.73928446885631, 0.7208374042906973, 0.720767061504876, 0.670013523983648, 0.6944784696755282, 0.7171474679158691, 0.45905814165473613, 0.38685346405448373, 0.4285267889185136, 0.40152791495380447, 0.44381595203713575, 0.3856054663979166, 0.38568901383341203, 0.4434867053869739, 0.4135707091768883, 0.11300779691743612, 0.14007326235487072, 0.1060389868855387, 0.143557128254461, 0.12249319045999385, 0.10322735915890568, 0.09279753192946716, 0.1145524867030634, 0.09135312621170966, 0.09174570496021384, 0.09142853840738008, 0.09045952247856481, 0.08944956500390966, 0.09125415791777691, 0.0951185446615731, 0.08259260136757551, 0.09040329202806219, 0.09437530829494523, 0.9655090264681291, 0.9236870055189949, 0.9528228955000331, 0.9645559896342301, 0.9646350661548537, 0.9336561500823548, 0.9606788658992433, 0.9964070659403929, 0.975465937189539, 0.3317819050828069, 0.3189729977994131, 0.29762181338438687, 0.3431284963127158, 0.31573375104437584, 0.32748285644561237, 0.361203867966817, 0.3188135331670907, 0.29771741193767953, 0.5798179470611124, 0.5736872985163861, 0.702142203475202, 0.7245770406165921, 0.6463603318240645, 0.7082288178644378, 0.6231120808703328, 0.6248469202314326, 0.6761229935418601, 0.22304693875994708, 0.20590107891647036, 0.2432499800905591, 0.27603088114005736, 0.2285424522443419, 0.25008263314062484, 0.2360395762578893, 0.24776917827570355, 0.2542156174504564, 0.20332092198015217, 0.20389465270695817, 0.16020950244257837, 0.18909596009688778, 0.20857282706674474, 0.20567054947827879, 0.1876923806159665, 0.23884372953031496, 0.27826938660988887, 0.23675102491171196, 0.2072062401429664, 0.19649306903826635, 0.19156209116283485, 0.16313924018179038, 0.23341829407998782, 0.1791659106763398, 0.18327240279828816, 0.2092800245037859, 0.3032952849510895, 0.3592658756735957, 0.31895114974961813, 0.28300087459037493, 0.3013699139208954, 0.3136829101242542, 0.3687479317198795, 0.35244720692330167, 0.3144519404955467, 0.05120223687101899, 0.07233124816809955, 0.051074110003637596, 0.11066158280450544, 0.08217996854277976, 0.07403742847877781, 0.09966990559633959, 0.10055048568700509, 0.06377973927585845, 0.2049838760405952, 0.19392693652145898, 0.1854162626525191, 0.20344785055013093, 0.20847298838246908, 0.21057062904255874, 0.20970564051380725, 0.1959537919652592, 0.20016886169568382, 0.5404109818203486, 0.5509719107343907, 0.5355102139040449, 0.5374707999423639, 0.5285614340077252, 0.5419155762853838, 0.5075899618594938, 0.5593141286784773, 0.5398047436589148, 0.09381492875649933, 0.10573146657932864, 0.10745160639899909, 0.09031523414355758, 0.0961504216310537, 0.10253945976624168, 0.09309262400825624, 0.08862787578753217, 0.10490594489643768, 0.35149529423194104, 0.13789447129250565, 0.1728438312052729, 0.19932429325505086, 0.17574803425381946, 0.1419732708943049, 0.14085485778779494, 0.1544399003360326, 0.21064947988565907, 0.30038057941471197, 0.2845520081381231, 0.31134056028317836, 0.31484790003330765, 0.27841876406979893, 0.3083613568934891, 0.3190905790478529, 0.3210955634213065, 0.3411935447999175, 0.24901233680447854, 0.2579910518640104, 0.2496086816372176, 0.2158212082113763, 0.23393658328332223, 0.21134755686588147, 0.2746291611993398, 0.24913154617384636, 0.24258713269831667, 0.19048559297929601, 0.23733786714653138, 0.2231372465131466, 0.19038708595700138, 0.2070678415756313, 0.19230284677092746, 0.20241096247697143, 0.20307100787507493, 0.1949296114266299, 0.20889740715546357, 0.19769357334173054, 0.17713830481996684, 0.18221485965377038, 0.17437352340773704, 0.22646563916383677, 0.1962137227506089, 0.18698019957957446, 0.17644316903457524, 0.18244321218837378, 0.18240287162978008, 0.7856369040387594, 0.5910008177688655, 0.3295900225472076, 0.5655201245942717, 0.6364469169704675, 0.47128386615127016, 0.17993911468413482, 0.20358932366410065, 0.20566733182968855, 0.161264793108016, 0.5943525825021447, 0.16247859718994806, 0.5955169621264453, 0.20759202074872996, 0.14963390611129057, 0.12511824351443324, 0.18247661546104388, 0.19685500513535348, 0.18738503679895824, 0.26226216719108586, 0.19284426012758316, 0.17781001479387937, 0.18428810234869775, 0.21224509692947702, 0.17985006373010415, 0.07652353924066502, 0.07563137992162994, 0.06776562272751452, 0.08202231135889693, 0.07992806279916853, 0.06974908540381564, 0.07518809997189946, 0.07663619754242768, 0.08383132405202065]}, "mutation_prompt": null}
{"id": "fa833380-807c-423d-939d-bb42fba81c6c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Dynamic Population Resizing\n            if self.evaluations < self.budget * 0.5:\n                self.population_size = max(10, int(self.population_size_initial * 0.9))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with dynamic population resizing to improve convergence efficiency.", "configspace": "", "generation": 1, "fitness": 0.307771156762841, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "a3273c8e-d739-463d-b646-bf5bd3dbaee5", "metadata": {"aucs": [0.7120086292868473, 0.7078536329500429, 0.736470826922167, 0.7016088323414426, 0.6633572657542004, 0.6935497258531413, 0.6867545702961286, 0.7262743078468513, 0.7069125341570547, 0.4893985090287599, 0.4981635123223289, 0.46280027261172585, 0.48232198235985857, 0.4627004899970736, 0.46920801281768754, 0.4883443831793295, 0.4779423965016273, 0.45919821051607146, 0.11171862720078352, 0.1337750373340768, 0.08782753604663518, 0.13444374999422293, 0.10825661986708823, 0.1108367602722572, 0.0871120612588, 0.10176322909321511, 0.12701707606768087, 0.10479594883176357, 0.09984275693655398, 0.08638266540738238, 0.08300085673972357, 0.08809376829066695, 0.10714798645562151, 0.10316449143413664, 0.11178282853625077, 0.10412284731097587, 0.9596127499617412, 0.9070257014742117, 0.9792019080135113, 0.9830434516433151, 0.9677702556054599, 0.9483483176281254, 0.9616230660348905, 0.9964070659403929, 0.9579412038981794, 0.359497529830498, 0.3587626383703728, 0.3383635492948034, 0.3600926410562305, 0.37532497748792426, 0.32588787139847286, 0.35809318072755014, 0.3806796605216505, 0.3342548116881878, 0.6142656737261551, 0.5522897761585117, 0.610782130281718, 0.6468182781924098, 0.664504106577819, 0.6708331913555943, 0.6106074136746642, 0.6263046673945415, 0.6230116665399488, 0.2393670380482592, 0.2921270615620961, 0.24427780835175705, 0.31506286306837017, 0.27809531218891115, 0.24073020847723814, 0.18928491930746882, 0.22940360901364565, 0.3046244259737798, 0.19131680351825175, 0.1861862635105337, 0.31078007276092423, 0.22543189413510667, 0.20078318352379498, 0.20594213045687082, 0.22136795586836688, 0.24059983635571824, 0.19997014111640998, 0.2562168700338997, 0.21982224019881103, 0.23401013265313064, 0.19370574530272622, 0.20161955744160054, 0.24502250210886822, 0.17800337379568643, 0.2441922489252728, 0.1763591421020192, 0.35859589251289414, 0.3567890301394978, 0.35795170313716096, 0.36044623108635765, 0.33993803945897794, 0.35754921002119455, 0.30863325528433116, 0.36262333806380764, 0.387813607427994, 0.07240830943139176, 0.04279633441371422, 0.02935249394400219, 0.07816537767147691, 0.06810642420316648, 0.06394917480245799, 0.09102757522125926, 0.09292144101754052, 0.05986138924550266, 0.19841363751758356, 0.20126624216032263, 0.21091205369937194, 0.21469018013192864, 0.22196082085457702, 0.19466578127184198, 0.17839808959855252, 0.1903775905775308, 0.20526927768668246, 0.5678265329008592, 0.5475090351530203, 0.5880869191462688, 0.5351205135678372, 0.5324658135658, 0.5291226279499877, 0.5216560925236309, 0.5574903031587617, 0.5479582765744023, 0.08921586741061782, 0.1012512892554478, 0.08810706268741664, 0.08408825826678767, 0.07160190563388369, 0.09302185071099944, 0.07851863122221803, 0.09843677995121147, 0.07718147360868133, 0.14626201804535977, 0.15255763564675195, 0.1903286051541324, 0.138210834122945, 0.24193572943741415, 0.1445149678090314, 0.18994909388157655, 0.16561105130713694, 0.14729115618611, 0.3010299167556304, 0.3170295462257827, 0.2966733824461244, 0.2956406822282138, 0.28645334566636493, 0.2842662333728533, 0.31211570232693076, 0.33267930876831875, 0.32000907771596077, 0.21342074651247045, 0.24595390767917136, 0.22539042915934882, 0.2404053693184156, 0.24686464326867985, 0.22417491651488253, 0.22773645851620405, 0.24109285438122785, 0.27245944967673263, 0.20586664595451398, 0.17378440894224423, 0.18207872801728264, 0.17663165019642768, 0.19138126371604958, 0.18911373794894804, 0.21112570827907817, 0.17403437358907392, 0.20586253794108256, 0.1889159148454833, 0.18511783697499107, 0.18065670835132752, 0.24170097978727, 0.22326033567657788, 0.1877314629874155, 0.18018166810775726, 0.24805166213252527, 0.2023258813223625, 0.674277550285383, 0.15751244278663346, 0.664221332600748, 0.17118997463951258, 0.1816919143544864, 0.6444313774502815, 0.19743370741589872, 0.15859379176176458, 0.17495363338437897, 0.4555734452901248, 0.4984993276277342, 0.2040849714776789, 0.18405327214497924, 0.5562857663377911, 0.30168246447863467, 0.20963105451768682, 0.5974353725777695, 0.589082894915644, 0.19340664595298285, 0.18863827879011263, 0.17739051963549113, 0.1837890138854429, 0.19182294966566116, 0.1865890323843422, 0.18096125934155638, 0.18460929313342556, 0.18248308393848378, 0.09052906337023747, 0.07340293597427738, 0.07058947928534398, 0.06644823394682575, 0.06468583509186299, 0.07422275254447519, 0.07017398173298695, 0.08672696321704532, 0.07844217797626774]}, "mutation_prompt": null}
{"id": "6c41c619-6c8b-4f19-959b-31ec83c28ccd", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Dynamic Population Resizing\n            if self.evaluations < self.budget * 0.5:\n                self.population_size = max(10, int(self.population_size_initial * 0.9))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with dynamic population resizing to improve convergence efficiency.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fa833380-807c-423d-939d-bb42fba81c6c", "metadata": {"aucs": [0.7120086292868473, 0.7078536329500429, 0.736470826922167, 0.7016088323414426, 0.6633572657542004, 0.6935497258531413, 0.6867545702961286, 0.7262743078468513, 0.7069125341570547, 0.4893985090287599, 0.4981635123223289, 0.46280027261172585, 0.48232198235985857, 0.4627004899970736, 0.46920801281768754, 0.4883443831793295, 0.4779423965016273, 0.45919821051607146, 0.11171862720078352, 0.1337750373340768, 0.08782753604663518, 0.13444374999422293, 0.10825661986708823, 0.1108367602722572, 0.0871120612588, 0.10176322909321511, 0.12701707606768087, 0.10479594883176357, 0.09984275693655398, 0.08638266540738238, 0.08300085673972357, 0.08809376829066695, 0.10714798645562151, 0.10316449143413664, 0.11178282853625077, 0.10412284731097587, 0.9596127499617412, 0.9070257014742117, 0.9792019080135113, 0.9830434516433151, 0.9677702556054599, 0.9483483176281254, 0.9616230660348905, 0.9964070659403929, 0.9579412038981794, 0.359497529830498, 0.3587626383703728, 0.3383635492948034, 0.3600926410562305, 0.37532497748792426, 0.32588787139847286, 0.35809318072755014, 0.3806796605216505, 0.3342548116881878, 0.6142656737261551, 0.5522897761585117, 0.610782130281718, 0.6468182781924098, 0.664504106577819, 0.6708331913555943, 0.6106074136746642, 0.6263046673945415, 0.6230116665399488, 0.2393670380482592, 0.2921270615620961, 0.24427780835175705, 0.31506286306837017, 0.27809531218891115, 0.24073020847723814, 0.18928491930746882, 0.22940360901364565, 0.3046244259737798, 0.19131680351825175, 0.1861862635105337, 0.31078007276092423, 0.22543189413510667, 0.20078318352379498, 0.20594213045687082, 0.22136795586836688, 0.24059983635571824, 0.19997014111640998, 0.2562168700338997, 0.21982224019881103, 0.23401013265313064, 0.19370574530272622, 0.20161955744160054, 0.24502250210886822, 0.17800337379568643, 0.2441922489252728, 0.1763591421020192, 0.35859589251289414, 0.3567890301394978, 0.35795170313716096, 0.36044623108635765, 0.33993803945897794, 0.35754921002119455, 0.30863325528433116, 0.36262333806380764, 0.387813607427994, 0.07240830943139176, 0.04279633441371422, 0.02935249394400219, 0.07816537767147691, 0.06810642420316648, 0.06394917480245799, 0.09102757522125926, 0.09292144101754052, 0.05986138924550266, 0.19841363751758356, 0.20126624216032263, 0.21091205369937194, 0.21469018013192864, 0.22196082085457702, 0.19466578127184198, 0.17839808959855252, 0.1903775905775308, 0.20526927768668246, 0.5678265329008592, 0.5475090351530203, 0.5880869191462688, 0.5351205135678372, 0.5324658135658, 0.5291226279499877, 0.5216560925236309, 0.5574903031587617, 0.5479582765744023, 0.08921586741061782, 0.1012512892554478, 0.08810706268741664, 0.08408825826678767, 0.07160190563388369, 0.09302185071099944, 0.07851863122221803, 0.09843677995121147, 0.07718147360868133, 0.14626201804535977, 0.15255763564675195, 0.1903286051541324, 0.138210834122945, 0.24193572943741415, 0.1445149678090314, 0.18994909388157655, 0.16561105130713694, 0.14729115618611, 0.3010299167556304, 0.3170295462257827, 0.2966733824461244, 0.2956406822282138, 0.28645334566636493, 0.2842662333728533, 0.31211570232693076, 0.33267930876831875, 0.32000907771596077, 0.21342074651247045, 0.24595390767917136, 0.22539042915934882, 0.2404053693184156, 0.24686464326867985, 0.22417491651488253, 0.22773645851620405, 0.24109285438122785, 0.27245944967673263, 0.20586664595451398, 0.17378440894224423, 0.18207872801728264, 0.17663165019642768, 0.19138126371604958, 0.18911373794894804, 0.21112570827907817, 0.17403437358907392, 0.20586253794108256, 0.1889159148454833, 0.18511783697499107, 0.18065670835132752, 0.24170097978727, 0.22326033567657788, 0.1877314629874155, 0.18018166810775726, 0.24805166213252527, 0.2023258813223625, 0.674277550285383, 0.15751244278663346, 0.664221332600748, 0.17118997463951258, 0.1816919143544864, 0.6444313774502815, 0.19743370741589872, 0.15859379176176458, 0.17495363338437897, 0.4555734452901248, 0.4984993276277342, 0.2040849714776789, 0.18405327214497924, 0.5562857663377911, 0.30168246447863467, 0.20963105451768682, 0.5974353725777695, 0.589082894915644, 0.19340664595298285, 0.18863827879011263, 0.17739051963549113, 0.1837890138854429, 0.19182294966566116, 0.1865890323843422, 0.18096125934155638, 0.18460929313342556, 0.18248308393848378, 0.09052906337023747, 0.07340293597427738, 0.07058947928534398, 0.06644823394682575, 0.06468583509186299, 0.07422275254447519, 0.07017398173298695, 0.08672696321704532, 0.07844217797626774]}, "mutation_prompt": null}
{"id": "48cee537-9cbd-4cc2-84e5-7b33eacf12f5", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Dynamic Population Resizing\n            if self.evaluations < self.budget * 0.5:\n                self.population_size = max(10, int(self.population_size_initial * 0.9))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with dynamic population resizing to improve convergence efficiency.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fa833380-807c-423d-939d-bb42fba81c6c", "metadata": {"aucs": [0.7120086292868473, 0.7078536329500429, 0.736470826922167, 0.7016088323414426, 0.6633572657542004, 0.6935497258531413, 0.6867545702961286, 0.7262743078468513, 0.7069125341570547, 0.4893985090287599, 0.4981635123223289, 0.46280027261172585, 0.48232198235985857, 0.4627004899970736, 0.46920801281768754, 0.4883443831793295, 0.4779423965016273, 0.45919821051607146, 0.11171862720078352, 0.1337750373340768, 0.08782753604663518, 0.13444374999422293, 0.10825661986708823, 0.1108367602722572, 0.0871120612588, 0.10176322909321511, 0.12701707606768087, 0.10479594883176357, 0.09984275693655398, 0.08638266540738238, 0.08300085673972357, 0.08809376829066695, 0.10714798645562151, 0.10316449143413664, 0.11178282853625077, 0.10412284731097587, 0.9596127499617412, 0.9070257014742117, 0.9792019080135113, 0.9830434516433151, 0.9677702556054599, 0.9483483176281254, 0.9616230660348905, 0.9964070659403929, 0.9579412038981794, 0.359497529830498, 0.3587626383703728, 0.3383635492948034, 0.3600926410562305, 0.37532497748792426, 0.32588787139847286, 0.35809318072755014, 0.3806796605216505, 0.3342548116881878, 0.6142656737261551, 0.5522897761585117, 0.610782130281718, 0.6468182781924098, 0.664504106577819, 0.6708331913555943, 0.6106074136746642, 0.6263046673945415, 0.6230116665399488, 0.2393670380482592, 0.2921270615620961, 0.24427780835175705, 0.31506286306837017, 0.27809531218891115, 0.24073020847723814, 0.18928491930746882, 0.22940360901364565, 0.3046244259737798, 0.19131680351825175, 0.1861862635105337, 0.31078007276092423, 0.22543189413510667, 0.20078318352379498, 0.20594213045687082, 0.22136795586836688, 0.24059983635571824, 0.19997014111640998, 0.2562168700338997, 0.21982224019881103, 0.23401013265313064, 0.19370574530272622, 0.20161955744160054, 0.24502250210886822, 0.17800337379568643, 0.2441922489252728, 0.1763591421020192, 0.35859589251289414, 0.3567890301394978, 0.35795170313716096, 0.36044623108635765, 0.33993803945897794, 0.35754921002119455, 0.30863325528433116, 0.36262333806380764, 0.387813607427994, 0.07240830943139176, 0.04279633441371422, 0.02935249394400219, 0.07816537767147691, 0.06810642420316648, 0.06394917480245799, 0.09102757522125926, 0.09292144101754052, 0.05986138924550266, 0.19841363751758356, 0.20126624216032263, 0.21091205369937194, 0.21469018013192864, 0.22196082085457702, 0.19466578127184198, 0.17839808959855252, 0.1903775905775308, 0.20526927768668246, 0.5678265329008592, 0.5475090351530203, 0.5880869191462688, 0.5351205135678372, 0.5324658135658, 0.5291226279499877, 0.5216560925236309, 0.5574903031587617, 0.5479582765744023, 0.08921586741061782, 0.1012512892554478, 0.08810706268741664, 0.08408825826678767, 0.07160190563388369, 0.09302185071099944, 0.07851863122221803, 0.09843677995121147, 0.07718147360868133, 0.14626201804535977, 0.15255763564675195, 0.1903286051541324, 0.138210834122945, 0.24193572943741415, 0.1445149678090314, 0.18994909388157655, 0.16561105130713694, 0.14729115618611, 0.3010299167556304, 0.3170295462257827, 0.2966733824461244, 0.2956406822282138, 0.28645334566636493, 0.2842662333728533, 0.31211570232693076, 0.33267930876831875, 0.32000907771596077, 0.21342074651247045, 0.24595390767917136, 0.22539042915934882, 0.2404053693184156, 0.24686464326867985, 0.22417491651488253, 0.22773645851620405, 0.24109285438122785, 0.27245944967673263, 0.20586664595451398, 0.17378440894224423, 0.18207872801728264, 0.17663165019642768, 0.19138126371604958, 0.18911373794894804, 0.21112570827907817, 0.17403437358907392, 0.20586253794108256, 0.1889159148454833, 0.18511783697499107, 0.18065670835132752, 0.24170097978727, 0.22326033567657788, 0.1877314629874155, 0.18018166810775726, 0.24805166213252527, 0.2023258813223625, 0.674277550285383, 0.15751244278663346, 0.664221332600748, 0.17118997463951258, 0.1816919143544864, 0.6444313774502815, 0.19743370741589872, 0.15859379176176458, 0.17495363338437897, 0.4555734452901248, 0.4984993276277342, 0.2040849714776789, 0.18405327214497924, 0.5562857663377911, 0.30168246447863467, 0.20963105451768682, 0.5974353725777695, 0.589082894915644, 0.19340664595298285, 0.18863827879011263, 0.17739051963549113, 0.1837890138854429, 0.19182294966566116, 0.1865890323843422, 0.18096125934155638, 0.18460929313342556, 0.18248308393848378, 0.09052906337023747, 0.07340293597427738, 0.07058947928534398, 0.06644823394682575, 0.06468583509186299, 0.07422275254447519, 0.07017398173298695, 0.08672696321704532, 0.07844217797626774]}, "mutation_prompt": null}
{"id": "b06f6622-a0ea-4a66-aec4-7fcdf12d1310", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Dynamic Population Resizing\n            if self.evaluations < self.budget * 0.5:\n                self.population_size = max(10, int(self.population_size_initial * 0.9))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with dynamic population resizing to improve convergence efficiency.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fa833380-807c-423d-939d-bb42fba81c6c", "metadata": {"aucs": [0.7120086292868473, 0.7078536329500429, 0.736470826922167, 0.7016088323414426, 0.6633572657542004, 0.6935497258531413, 0.6867545702961286, 0.7262743078468513, 0.7069125341570547, 0.4893985090287599, 0.4981635123223289, 0.46280027261172585, 0.48232198235985857, 0.4627004899970736, 0.46920801281768754, 0.4883443831793295, 0.4779423965016273, 0.45919821051607146, 0.11171862720078352, 0.1337750373340768, 0.08782753604663518, 0.13444374999422293, 0.10825661986708823, 0.1108367602722572, 0.0871120612588, 0.10176322909321511, 0.12701707606768087, 0.10479594883176357, 0.09984275693655398, 0.08638266540738238, 0.08300085673972357, 0.08809376829066695, 0.10714798645562151, 0.10316449143413664, 0.11178282853625077, 0.10412284731097587, 0.9596127499617412, 0.9070257014742117, 0.9792019080135113, 0.9830434516433151, 0.9677702556054599, 0.9483483176281254, 0.9616230660348905, 0.9964070659403929, 0.9579412038981794, 0.359497529830498, 0.3587626383703728, 0.3383635492948034, 0.3600926410562305, 0.37532497748792426, 0.32588787139847286, 0.35809318072755014, 0.3806796605216505, 0.3342548116881878, 0.6142656737261551, 0.5522897761585117, 0.610782130281718, 0.6468182781924098, 0.664504106577819, 0.6708331913555943, 0.6106074136746642, 0.6263046673945415, 0.6230116665399488, 0.2393670380482592, 0.2921270615620961, 0.24427780835175705, 0.31506286306837017, 0.27809531218891115, 0.24073020847723814, 0.18928491930746882, 0.22940360901364565, 0.3046244259737798, 0.19131680351825175, 0.1861862635105337, 0.31078007276092423, 0.22543189413510667, 0.20078318352379498, 0.20594213045687082, 0.22136795586836688, 0.24059983635571824, 0.19997014111640998, 0.2562168700338997, 0.21982224019881103, 0.23401013265313064, 0.19370574530272622, 0.20161955744160054, 0.24502250210886822, 0.17800337379568643, 0.2441922489252728, 0.1763591421020192, 0.35859589251289414, 0.3567890301394978, 0.35795170313716096, 0.36044623108635765, 0.33993803945897794, 0.35754921002119455, 0.30863325528433116, 0.36262333806380764, 0.387813607427994, 0.07240830943139176, 0.04279633441371422, 0.02935249394400219, 0.07816537767147691, 0.06810642420316648, 0.06394917480245799, 0.09102757522125926, 0.09292144101754052, 0.05986138924550266, 0.19841363751758356, 0.20126624216032263, 0.21091205369937194, 0.21469018013192864, 0.22196082085457702, 0.19466578127184198, 0.17839808959855252, 0.1903775905775308, 0.20526927768668246, 0.5678265329008592, 0.5475090351530203, 0.5880869191462688, 0.5351205135678372, 0.5324658135658, 0.5291226279499877, 0.5216560925236309, 0.5574903031587617, 0.5479582765744023, 0.08921586741061782, 0.1012512892554478, 0.08810706268741664, 0.08408825826678767, 0.07160190563388369, 0.09302185071099944, 0.07851863122221803, 0.09843677995121147, 0.07718147360868133, 0.14626201804535977, 0.15255763564675195, 0.1903286051541324, 0.138210834122945, 0.24193572943741415, 0.1445149678090314, 0.18994909388157655, 0.16561105130713694, 0.14729115618611, 0.3010299167556304, 0.3170295462257827, 0.2966733824461244, 0.2956406822282138, 0.28645334566636493, 0.2842662333728533, 0.31211570232693076, 0.33267930876831875, 0.32000907771596077, 0.21342074651247045, 0.24595390767917136, 0.22539042915934882, 0.2404053693184156, 0.24686464326867985, 0.22417491651488253, 0.22773645851620405, 0.24109285438122785, 0.27245944967673263, 0.20586664595451398, 0.17378440894224423, 0.18207872801728264, 0.17663165019642768, 0.19138126371604958, 0.18911373794894804, 0.21112570827907817, 0.17403437358907392, 0.20586253794108256, 0.1889159148454833, 0.18511783697499107, 0.18065670835132752, 0.24170097978727, 0.22326033567657788, 0.1877314629874155, 0.18018166810775726, 0.24805166213252527, 0.2023258813223625, 0.674277550285383, 0.15751244278663346, 0.664221332600748, 0.17118997463951258, 0.1816919143544864, 0.6444313774502815, 0.19743370741589872, 0.15859379176176458, 0.17495363338437897, 0.4555734452901248, 0.4984993276277342, 0.2040849714776789, 0.18405327214497924, 0.5562857663377911, 0.30168246447863467, 0.20963105451768682, 0.5974353725777695, 0.589082894915644, 0.19340664595298285, 0.18863827879011263, 0.17739051963549113, 0.1837890138854429, 0.19182294966566116, 0.1865890323843422, 0.18096125934155638, 0.18460929313342556, 0.18248308393848378, 0.09052906337023747, 0.07340293597427738, 0.07058947928534398, 0.06644823394682575, 0.06468583509186299, 0.07422275254447519, 0.07017398173298695, 0.08672696321704532, 0.07844217797626774]}, "mutation_prompt": null}
{"id": "e02d1826-e2f1-4e5b-8faf-63d4c4277539", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Dynamic Population Resizing\n            if self.evaluations < self.budget * 0.5:\n                self.population_size = max(10, int(self.population_size_initial * 0.9))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with dynamic population resizing to improve convergence efficiency.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fa833380-807c-423d-939d-bb42fba81c6c", "metadata": {"aucs": [0.7120086292868473, 0.7078536329500429, 0.736470826922167, 0.7016088323414426, 0.6633572657542004, 0.6935497258531413, 0.6867545702961286, 0.7262743078468513, 0.7069125341570547, 0.4893985090287599, 0.4981635123223289, 0.46280027261172585, 0.48232198235985857, 0.4627004899970736, 0.46920801281768754, 0.4883443831793295, 0.4779423965016273, 0.45919821051607146, 0.11171862720078352, 0.1337750373340768, 0.08782753604663518, 0.13444374999422293, 0.10825661986708823, 0.1108367602722572, 0.0871120612588, 0.10176322909321511, 0.12701707606768087, 0.10479594883176357, 0.09984275693655398, 0.08638266540738238, 0.08300085673972357, 0.08809376829066695, 0.10714798645562151, 0.10316449143413664, 0.11178282853625077, 0.10412284731097587, 0.9596127499617412, 0.9070257014742117, 0.9792019080135113, 0.9830434516433151, 0.9677702556054599, 0.9483483176281254, 0.9616230660348905, 0.9964070659403929, 0.9579412038981794, 0.359497529830498, 0.3587626383703728, 0.3383635492948034, 0.3600926410562305, 0.37532497748792426, 0.32588787139847286, 0.35809318072755014, 0.3806796605216505, 0.3342548116881878, 0.6142656737261551, 0.5522897761585117, 0.610782130281718, 0.6468182781924098, 0.664504106577819, 0.6708331913555943, 0.6106074136746642, 0.6263046673945415, 0.6230116665399488, 0.2393670380482592, 0.2921270615620961, 0.24427780835175705, 0.31506286306837017, 0.27809531218891115, 0.24073020847723814, 0.18928491930746882, 0.22940360901364565, 0.3046244259737798, 0.19131680351825175, 0.1861862635105337, 0.31078007276092423, 0.22543189413510667, 0.20078318352379498, 0.20594213045687082, 0.22136795586836688, 0.24059983635571824, 0.19997014111640998, 0.2562168700338997, 0.21982224019881103, 0.23401013265313064, 0.19370574530272622, 0.20161955744160054, 0.24502250210886822, 0.17800337379568643, 0.2441922489252728, 0.1763591421020192, 0.35859589251289414, 0.3567890301394978, 0.35795170313716096, 0.36044623108635765, 0.33993803945897794, 0.35754921002119455, 0.30863325528433116, 0.36262333806380764, 0.387813607427994, 0.07240830943139176, 0.04279633441371422, 0.02935249394400219, 0.07816537767147691, 0.06810642420316648, 0.06394917480245799, 0.09102757522125926, 0.09292144101754052, 0.05986138924550266, 0.19841363751758356, 0.20126624216032263, 0.21091205369937194, 0.21469018013192864, 0.22196082085457702, 0.19466578127184198, 0.17839808959855252, 0.1903775905775308, 0.20526927768668246, 0.5678265329008592, 0.5475090351530203, 0.5880869191462688, 0.5351205135678372, 0.5324658135658, 0.5291226279499877, 0.5216560925236309, 0.5574903031587617, 0.5479582765744023, 0.08921586741061782, 0.1012512892554478, 0.08810706268741664, 0.08408825826678767, 0.07160190563388369, 0.09302185071099944, 0.07851863122221803, 0.09843677995121147, 0.07718147360868133, 0.14626201804535977, 0.15255763564675195, 0.1903286051541324, 0.138210834122945, 0.24193572943741415, 0.1445149678090314, 0.18994909388157655, 0.16561105130713694, 0.14729115618611, 0.3010299167556304, 0.3170295462257827, 0.2966733824461244, 0.2956406822282138, 0.28645334566636493, 0.2842662333728533, 0.31211570232693076, 0.33267930876831875, 0.32000907771596077, 0.21342074651247045, 0.24595390767917136, 0.22539042915934882, 0.2404053693184156, 0.24686464326867985, 0.22417491651488253, 0.22773645851620405, 0.24109285438122785, 0.27245944967673263, 0.20586664595451398, 0.17378440894224423, 0.18207872801728264, 0.17663165019642768, 0.19138126371604958, 0.18911373794894804, 0.21112570827907817, 0.17403437358907392, 0.20586253794108256, 0.1889159148454833, 0.18511783697499107, 0.18065670835132752, 0.24170097978727, 0.22326033567657788, 0.1877314629874155, 0.18018166810775726, 0.24805166213252527, 0.2023258813223625, 0.674277550285383, 0.15751244278663346, 0.664221332600748, 0.17118997463951258, 0.1816919143544864, 0.6444313774502815, 0.19743370741589872, 0.15859379176176458, 0.17495363338437897, 0.4555734452901248, 0.4984993276277342, 0.2040849714776789, 0.18405327214497924, 0.5562857663377911, 0.30168246447863467, 0.20963105451768682, 0.5974353725777695, 0.589082894915644, 0.19340664595298285, 0.18863827879011263, 0.17739051963549113, 0.1837890138854429, 0.19182294966566116, 0.1865890323843422, 0.18096125934155638, 0.18460929313342556, 0.18248308393848378, 0.09052906337023747, 0.07340293597427738, 0.07058947928534398, 0.06644823394682575, 0.06468583509186299, 0.07422275254447519, 0.07017398173298695, 0.08672696321704532, 0.07844217797626774]}, "mutation_prompt": null}
{"id": "b96c7f37-12fb-4709-9edd-b617802cd1de", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Dynamic Population Resizing\n            if self.evaluations < self.budget * 0.5:\n                self.population_size = max(10, int(self.population_size_initial * 0.9))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with dynamic population resizing to improve convergence efficiency.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fa833380-807c-423d-939d-bb42fba81c6c", "metadata": {"aucs": [0.7120086292868473, 0.7078536329500429, 0.736470826922167, 0.7016088323414426, 0.6633572657542004, 0.6935497258531413, 0.6867545702961286, 0.7262743078468513, 0.7069125341570547, 0.4893985090287599, 0.4981635123223289, 0.46280027261172585, 0.48232198235985857, 0.4627004899970736, 0.46920801281768754, 0.4883443831793295, 0.4779423965016273, 0.45919821051607146, 0.11171862720078352, 0.1337750373340768, 0.08782753604663518, 0.13444374999422293, 0.10825661986708823, 0.1108367602722572, 0.0871120612588, 0.10176322909321511, 0.12701707606768087, 0.10479594883176357, 0.09984275693655398, 0.08638266540738238, 0.08300085673972357, 0.08809376829066695, 0.10714798645562151, 0.10316449143413664, 0.11178282853625077, 0.10412284731097587, 0.9596127499617412, 0.9070257014742117, 0.9792019080135113, 0.9830434516433151, 0.9677702556054599, 0.9483483176281254, 0.9616230660348905, 0.9964070659403929, 0.9579412038981794, 0.359497529830498, 0.3587626383703728, 0.3383635492948034, 0.3600926410562305, 0.37532497748792426, 0.32588787139847286, 0.35809318072755014, 0.3806796605216505, 0.3342548116881878, 0.6142656737261551, 0.5522897761585117, 0.610782130281718, 0.6468182781924098, 0.664504106577819, 0.6708331913555943, 0.6106074136746642, 0.6263046673945415, 0.6230116665399488, 0.2393670380482592, 0.2921270615620961, 0.24427780835175705, 0.31506286306837017, 0.27809531218891115, 0.24073020847723814, 0.18928491930746882, 0.22940360901364565, 0.3046244259737798, 0.19131680351825175, 0.1861862635105337, 0.31078007276092423, 0.22543189413510667, 0.20078318352379498, 0.20594213045687082, 0.22136795586836688, 0.24059983635571824, 0.19997014111640998, 0.2562168700338997, 0.21982224019881103, 0.23401013265313064, 0.19370574530272622, 0.20161955744160054, 0.24502250210886822, 0.17800337379568643, 0.2441922489252728, 0.1763591421020192, 0.35859589251289414, 0.3567890301394978, 0.35795170313716096, 0.36044623108635765, 0.33993803945897794, 0.35754921002119455, 0.30863325528433116, 0.36262333806380764, 0.387813607427994, 0.07240830943139176, 0.04279633441371422, 0.02935249394400219, 0.07816537767147691, 0.06810642420316648, 0.06394917480245799, 0.09102757522125926, 0.09292144101754052, 0.05986138924550266, 0.19841363751758356, 0.20126624216032263, 0.21091205369937194, 0.21469018013192864, 0.22196082085457702, 0.19466578127184198, 0.17839808959855252, 0.1903775905775308, 0.20526927768668246, 0.5678265329008592, 0.5475090351530203, 0.5880869191462688, 0.5351205135678372, 0.5324658135658, 0.5291226279499877, 0.5216560925236309, 0.5574903031587617, 0.5479582765744023, 0.08921586741061782, 0.1012512892554478, 0.08810706268741664, 0.08408825826678767, 0.07160190563388369, 0.09302185071099944, 0.07851863122221803, 0.09843677995121147, 0.07718147360868133, 0.14626201804535977, 0.15255763564675195, 0.1903286051541324, 0.138210834122945, 0.24193572943741415, 0.1445149678090314, 0.18994909388157655, 0.16561105130713694, 0.14729115618611, 0.3010299167556304, 0.3170295462257827, 0.2966733824461244, 0.2956406822282138, 0.28645334566636493, 0.2842662333728533, 0.31211570232693076, 0.33267930876831875, 0.32000907771596077, 0.21342074651247045, 0.24595390767917136, 0.22539042915934882, 0.2404053693184156, 0.24686464326867985, 0.22417491651488253, 0.22773645851620405, 0.24109285438122785, 0.27245944967673263, 0.20586664595451398, 0.17378440894224423, 0.18207872801728264, 0.17663165019642768, 0.19138126371604958, 0.18911373794894804, 0.21112570827907817, 0.17403437358907392, 0.20586253794108256, 0.1889159148454833, 0.18511783697499107, 0.18065670835132752, 0.24170097978727, 0.22326033567657788, 0.1877314629874155, 0.18018166810775726, 0.24805166213252527, 0.2023258813223625, 0.674277550285383, 0.15751244278663346, 0.664221332600748, 0.17118997463951258, 0.1816919143544864, 0.6444313774502815, 0.19743370741589872, 0.15859379176176458, 0.17495363338437897, 0.4555734452901248, 0.4984993276277342, 0.2040849714776789, 0.18405327214497924, 0.5562857663377911, 0.30168246447863467, 0.20963105451768682, 0.5974353725777695, 0.589082894915644, 0.19340664595298285, 0.18863827879011263, 0.17739051963549113, 0.1837890138854429, 0.19182294966566116, 0.1865890323843422, 0.18096125934155638, 0.18460929313342556, 0.18248308393848378, 0.09052906337023747, 0.07340293597427738, 0.07058947928534398, 0.06644823394682575, 0.06468583509186299, 0.07422275254447519, 0.07017398173298695, 0.08672696321704532, 0.07844217797626774]}, "mutation_prompt": null}
{"id": "163924e8-6747-4634-b7b6-29d9c745c8ee", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Dynamic Population Resizing\n            if self.evaluations < self.budget * 0.5:\n                self.population_size = max(10, int(self.population_size_initial * 0.9))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with dynamic population resizing to improve convergence efficiency.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fa833380-807c-423d-939d-bb42fba81c6c", "metadata": {"aucs": [0.7120086292868473, 0.7078536329500429, 0.736470826922167, 0.7016088323414426, 0.6633572657542004, 0.6935497258531413, 0.6867545702961286, 0.7262743078468513, 0.7069125341570547, 0.4893985090287599, 0.4981635123223289, 0.46280027261172585, 0.48232198235985857, 0.4627004899970736, 0.46920801281768754, 0.4883443831793295, 0.4779423965016273, 0.45919821051607146, 0.11171862720078352, 0.1337750373340768, 0.08782753604663518, 0.13444374999422293, 0.10825661986708823, 0.1108367602722572, 0.0871120612588, 0.10176322909321511, 0.12701707606768087, 0.10479594883176357, 0.09984275693655398, 0.08638266540738238, 0.08300085673972357, 0.08809376829066695, 0.10714798645562151, 0.10316449143413664, 0.11178282853625077, 0.10412284731097587, 0.9596127499617412, 0.9070257014742117, 0.9792019080135113, 0.9830434516433151, 0.9677702556054599, 0.9483483176281254, 0.9616230660348905, 0.9964070659403929, 0.9579412038981794, 0.359497529830498, 0.3587626383703728, 0.3383635492948034, 0.3600926410562305, 0.37532497748792426, 0.32588787139847286, 0.35809318072755014, 0.3806796605216505, 0.3342548116881878, 0.6142656737261551, 0.5522897761585117, 0.610782130281718, 0.6468182781924098, 0.664504106577819, 0.6708331913555943, 0.6106074136746642, 0.6263046673945415, 0.6230116665399488, 0.2393670380482592, 0.2921270615620961, 0.24427780835175705, 0.31506286306837017, 0.27809531218891115, 0.24073020847723814, 0.18928491930746882, 0.22940360901364565, 0.3046244259737798, 0.19131680351825175, 0.1861862635105337, 0.31078007276092423, 0.22543189413510667, 0.20078318352379498, 0.20594213045687082, 0.22136795586836688, 0.24059983635571824, 0.19997014111640998, 0.2562168700338997, 0.21982224019881103, 0.23401013265313064, 0.19370574530272622, 0.20161955744160054, 0.24502250210886822, 0.17800337379568643, 0.2441922489252728, 0.1763591421020192, 0.35859589251289414, 0.3567890301394978, 0.35795170313716096, 0.36044623108635765, 0.33993803945897794, 0.35754921002119455, 0.30863325528433116, 0.36262333806380764, 0.387813607427994, 0.07240830943139176, 0.04279633441371422, 0.02935249394400219, 0.07816537767147691, 0.06810642420316648, 0.06394917480245799, 0.09102757522125926, 0.09292144101754052, 0.05986138924550266, 0.19841363751758356, 0.20126624216032263, 0.21091205369937194, 0.21469018013192864, 0.22196082085457702, 0.19466578127184198, 0.17839808959855252, 0.1903775905775308, 0.20526927768668246, 0.5678265329008592, 0.5475090351530203, 0.5880869191462688, 0.5351205135678372, 0.5324658135658, 0.5291226279499877, 0.5216560925236309, 0.5574903031587617, 0.5479582765744023, 0.08921586741061782, 0.1012512892554478, 0.08810706268741664, 0.08408825826678767, 0.07160190563388369, 0.09302185071099944, 0.07851863122221803, 0.09843677995121147, 0.07718147360868133, 0.14626201804535977, 0.15255763564675195, 0.1903286051541324, 0.138210834122945, 0.24193572943741415, 0.1445149678090314, 0.18994909388157655, 0.16561105130713694, 0.14729115618611, 0.3010299167556304, 0.3170295462257827, 0.2966733824461244, 0.2956406822282138, 0.28645334566636493, 0.2842662333728533, 0.31211570232693076, 0.33267930876831875, 0.32000907771596077, 0.21342074651247045, 0.24595390767917136, 0.22539042915934882, 0.2404053693184156, 0.24686464326867985, 0.22417491651488253, 0.22773645851620405, 0.24109285438122785, 0.27245944967673263, 0.20586664595451398, 0.17378440894224423, 0.18207872801728264, 0.17663165019642768, 0.19138126371604958, 0.18911373794894804, 0.21112570827907817, 0.17403437358907392, 0.20586253794108256, 0.1889159148454833, 0.18511783697499107, 0.18065670835132752, 0.24170097978727, 0.22326033567657788, 0.1877314629874155, 0.18018166810775726, 0.24805166213252527, 0.2023258813223625, 0.674277550285383, 0.15751244278663346, 0.664221332600748, 0.17118997463951258, 0.1816919143544864, 0.6444313774502815, 0.19743370741589872, 0.15859379176176458, 0.17495363338437897, 0.4555734452901248, 0.4984993276277342, 0.2040849714776789, 0.18405327214497924, 0.5562857663377911, 0.30168246447863467, 0.20963105451768682, 0.5974353725777695, 0.589082894915644, 0.19340664595298285, 0.18863827879011263, 0.17739051963549113, 0.1837890138854429, 0.19182294966566116, 0.1865890323843422, 0.18096125934155638, 0.18460929313342556, 0.18248308393848378, 0.09052906337023747, 0.07340293597427738, 0.07058947928534398, 0.06644823394682575, 0.06468583509186299, 0.07422275254447519, 0.07017398173298695, 0.08672696321704532, 0.07844217797626774]}, "mutation_prompt": null}
{"id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 8, "fitness": 0.3878319777337218, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "fa833380-807c-423d-939d-bb42fba81c6c", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "238009bd-e6d0-44ba-a68c-58085a0c6b28", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "d97fb25c-cb2b-4410-a6d4-3e670ab981f4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "0db7cd1c-13bf-4d96-8c68-9e35e84cb1a2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "18ffc5eb-f444-4717-887b-4f1fa6a33f8f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization with Elite Preservation\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                elite_idx = np.argmin(self.fitness)  # Preserve the best so far\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.population[0] = self.population[elite_idx]  # Keep the elite solution\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor, strategic reinitialization, and elite preservation for improved convergence.", "configspace": "", "generation": 12, "fitness": 0.38771351478056, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17608522641588775, 0.8427810794080323, 0.16426889074144257, 0.7542570162488828, 0.20593553316694957, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.16789430812333994, 0.8069569062696433, 0.8306000286503776, 0.2113348686327311, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15346798261282635, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "dda884d5-0906-407f-b447-87553056d119", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Dynamic Crossover Probability\n                self.crossover_probability = 0.6 + 0.4 * np.sin(np.pi * self.evaluations / self.budget)\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor, strategic reinitialization, and dynamic crossover probability for improved exploration and convergence.", "configspace": "", "generation": 13, "fitness": 0.37366032547158445, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8112872032936196, 0.8157323264013332, 0.8261236861257811, 0.8247021858694898, 0.8058288074685828, 0.8048565780043684, 0.8048125753808005, 0.816197628552401, 0.7940247840106257, 0.6255229256991164, 0.6345441232570719, 0.652286068286857, 0.6442267370271132, 0.6312190383887029, 0.6145661003182882, 0.6686162447647473, 0.6495942581643692, 0.569119377248415, 0.11336044804511436, 0.13446712920191606, 0.10397015471512316, 0.13683543079587357, 0.12416069771633298, 0.13077344497492593, 0.12407718382990462, 0.11437913070833217, 0.1122703670591414, 0.08856362506951831, 0.12834011698461378, 0.11229655015870854, 0.14333277922841148, 0.11957396464934411, 0.10792943071496042, 0.11823664433817427, 0.11135430629523657, 0.10628096351139338, 0.9316951835599587, 0.9072442372297415, 0.8962372202774748, 0.8822128665944713, 0.9567240922356005, 0.9660371253718029, 0.9613674666288963, 0.9269612179782922, 0.9352292396674339, 0.4569881776043683, 0.40517513809977024, 0.4442412738395607, 0.49148482616304, 0.44529438831697565, 0.47697862109673095, 0.4387630258545465, 0.43090561691839335, 0.44993040029358566, 0.7707640199427722, 0.7495815079131041, 0.2214119478412112, 0.7940627928325616, 0.8109008312674987, 0.7634271469681303, 0.2342356526066438, 0.6960489315701441, 0.7263891724039022, 0.3065621583747248, 0.3294386649572778, 0.24985554455314896, 0.22999366339134109, 0.2535760624749698, 0.2372807336312126, 0.32570206612121744, 0.3263727616951265, 0.18735612434566107, 0.28494883617392275, 0.20247094528661247, 0.3722171309490553, 0.28749218593621684, 0.289102903019233, 0.5813799242821462, 0.2820345016114303, 0.18147457846045367, 0.35098752516814824, 0.3764153832582845, 0.37904322335057206, 0.36631709951081304, 0.3174140648232182, 0.4002777217357224, 0.41348293659446356, 0.3778861937558077, 0.3694062657931527, 0.18202676621100622, 0.4961427473705501, 0.4844615972182935, 0.5758794900345101, 0.44543312350980024, 0.46626351770634067, 0.4917076860405294, 0.5036313485480934, 0.534819066354383, 0.5213920154195066, 0.15655460701350798, 0.07670860158401571, 0.22508670904438866, 0.18372424425548062, 0.19294999988440598, 0.14250935546341392, 0.2352696488871867, 0.1379704707035122, 0.26824862707410135, 0.2908949686401403, 0.28450594612079727, 0.3445676078485169, 0.32079345866407694, 0.32173746461545316, 0.3496648686003474, 0.3163666480588754, 0.3111465599198435, 0.3056951201216128, 0.7429011047899536, 0.7429650698855987, 0.7536572809157306, 0.7536006896456245, 0.7009192567504317, 0.7272609427258152, 0.7224337527033615, 0.7243812015711659, 0.7318175891631507, 0.12038711817665226, 0.08505616996714238, 0.10623383792671026, 0.08844146791328644, 0.11270577505901092, 0.097816917182732, 0.10176530872425338, 0.10554081253664205, 0.10834111910167521, 0.13165332596774315, 0.12703724591714471, 0.13519521821799985, 0.14299584636368978, 0.13334325405561864, 0.14500063161553955, 0.14246354705780706, 0.15369228469680307, 0.1741658781975901, 0.33835348811175703, 0.37294064170252594, 0.37844569048783516, 0.39081879506591954, 0.3623701215216796, 0.4073474449547132, 0.3841602204250484, 0.4241619363877498, 0.4225570489935955, 0.32564177199452293, 0.30139500273166264, 0.2844476812101039, 0.3072764704088107, 0.3162407694783552, 0.2981590779389547, 0.3161556578442679, 0.3177094083392713, 0.32186177534059157, 0.19332080751876712, 0.20897357400209793, 0.19652416652128324, 0.20013387865417442, 0.19248235265985936, 0.19390890893155843, 0.2015387664047964, 0.1744991871183884, 0.21590483075184808, 0.1916861362518677, 0.19159482239626413, 0.18885318259216166, 0.22245400459947018, 0.20487564250632018, 0.1945657520378392, 0.2424845085391426, 0.21166597236655327, 0.18689024901913498, 0.7321350303685576, 0.8224097668189221, 0.6965589831779644, 0.7344625991730671, 0.18666819639299548, 0.6358665827133461, 0.6116002377163926, 0.6482653217770189, 0.7355384626133716, 0.1698832149786813, 0.16421208698912648, 0.5890140368712373, 0.7344169999572431, 0.1900025373344978, 0.6245851807645343, 0.15763733153734516, 0.20909102052240358, 0.2025614593908952, 0.17745579689277224, 0.19836585921949246, 0.19126232603090465, 0.18277183553480436, 0.18648126665535103, 0.1805855450352185, 0.1857879135349758, 0.19177518325204868, 0.17767616135372555, 0.07738508741728378, 0.08975720059647452, 0.09965847674247963, 0.08275898689403949, 0.08108542657608775, 0.081406534668653, 0.08470238070388492, 0.08283233085222053, 0.08140394666452044]}, "mutation_prompt": null}
{"id": "3ec14ece-9f09-42e2-bf23-877419603ea3", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        dynamic_population = self.population_size_initial\n        while self.evaluations < self.budget:\n            for i in range(dynamic_population):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(dynamic_population) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(dynamic_population):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                dynamic_population = max(3, dynamic_population // 2)\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (dynamic_population, self.dim))\n                self.fitness = np.full(dynamic_population, np.inf)\n                for i in range(dynamic_population):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Refined Enhanced Differential Evolution with a dynamic population size and an improved reinitialization strategy for better exploration.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('not enough values to unpack (expected 3, got 2)').", "error": "ValueError('not enough values to unpack (expected 3, got 2)')", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {}, "mutation_prompt": null}
{"id": "813bfbd4-1923-4a5a-b422-e5fc07963de1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "f13d3407-0d2a-4ca9-941c-116a4d07edd4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability_initial = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Dynamic Crossover Probability\n                crossover_probability = self.crossover_probability_initial * (1 - self.evaluations / self.budget)\n                crossover_points = np.random.rand(self.dim) < crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Refined Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    if self.evaluations >= self.budget:\n                        break\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Improved Enhanced Differential Evolution with dynamic crossover probability and refined reinitialization for better diversity and convergence.", "configspace": "", "generation": 16, "fitness": 0.31195020947754887, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.820269470544946, 0.7896482051742049, 0.8135384920274032, 0.8136625701870527, 0.8304375570084916, 0.8122167000730633, 0.8346650941177197, 0.8174628658318435, 0.8165084334467198, 0.6399283927930102, 0.6081959357242112, 0.6326547836663375, 0.6254582360749155, 0.6384150799905748, 0.648918015179716, 0.6661599328715851, 0.6191929063935948, 0.656444641633237, 0.21471425382740839, 0.20565640795421392, 0.27030082492892393, 0.23111932399525725, 0.22475126834814485, 0.18140421011910157, 0.2571997067941557, 0.25228955512849993, 0.2421930486029753, 0.13446081193300274, 0.13222370743885936, 0.11918038750519666, 0.20178421470569285, 0.24047383973555336, 0.15565581869683587, 0.11359918318895101, 0.15141280825636882, 0.13287394300579258, 0.9630621398258746, 0.8975550574975236, 0.947740250810694, 0.8985291050281343, 0.9315160243031377, 0.8913236023819336, 0.9178077022435509, 0.9142302162622001, 0.9778471767024739, 0.30187292343815675, 0.36785910127199417, 0.3557435343462617, 0.3513854925110458, 0.31860737638868475, 0.4061123381207429, 0.3286774193100097, 0.329169957686295, 0.32092575945742496, 0.6388101014799383, 0.7420017641719887, 0.33283303406687237, 0.36756686486641543, 0.7720650484793774, 0.6430768407749043, 0.6419479191725717, 0.7450893340263751, 0.7493009259204668, 0.18269848769922348, 0.19720682119954536, 0.1847755915259175, 0.1527187561272041, 0.18022501703805904, 0.22263414895244982, 0.18352093502732714, 0.16028015494952674, 0.17483015404060187, 0.18906639960515936, 0.16289460521227972, 0.15131621409982932, 0.18081880960862173, 0.15077211100814236, 0.1448623023451835, 0.15552539518228536, 0.2026547191244975, 0.1878761544561356, 0.046662994112251166, 0.07377126170465276, 0.057386388780561015, 0.11270815021563363, 0.07914006841275367, 0.08238670844056983, 0.0844966141390312, 0.031745267488047846, 0.1594416994185367, 0.22926135544139092, 0.20844980226022003, 0.19861282493589616, 0.16157229057727762, 0.18922820349395153, 0.21480754091971543, 0.27617211051558965, 0.21419052659974758, 0.22869818642715734, 0.00770836869358138, 0.006602200365817379, 0.02840166238203745, 0.027866067916618498, 0.031009486857117352, 0.049544649810540964, 0.036215633228399935, 0.05766557260567273, 0.08065438706027994, 0.16848913599521198, 0.15851731810151448, 0.16722520187924528, 0.19246683360181072, 0.174950743276166, 0.17955629293523467, 0.1515324640698451, 0.16230472141185603, 0.16744559319189045, 0.5305869046925131, 0.5135189449194733, 0.509613918829551, 0.5230446507809912, 0.5397961308966657, 0.5116806735527657, 0.5465246386965618, 0.5101370761524685, 0.5475067844629105, 0.11899431669408456, 0.11174387989374279, 0.10812405153333549, 0.09673539877128168, 0.09610935356695882, 0.10917155378018562, 0.12506249489018795, 0.10707156856225519, 0.11555916487901974, 0.1510327522979269, 0.13524456506010285, 0.14041610797593806, 0.1296321576946019, 0.15011044439042942, 0.1338198204763239, 0.1413236583416947, 0.1564553072731838, 0.15922769913478418, 0.34267398764766277, 0.29875196658344694, 0.34851520287308635, 0.33038766845605816, 0.3295229000568386, 0.32473805777219955, 0.36729306429213826, 0.38976935198106244, 0.34061232797208263, 0.24229502760780164, 0.2625399631797062, 0.2521462559900528, 0.25784509022763846, 0.23080055893237472, 0.2408441195556893, 0.2592501399916245, 0.27992352771614737, 0.2641262971601337, 0.21540977273435014, 0.19265464606074867, 0.19425325393223147, 0.20022644400262257, 0.19368989648288348, 0.1928282979802166, 0.2213906620752839, 0.2092160691035223, 0.2171366234988894, 0.1872818969837795, 0.20325525784397747, 0.2346617476906454, 0.19891672775364133, 0.19385384816169293, 0.20592089410203684, 0.19318443950681397, 0.22051720573789924, 0.22285638800522867, 0.7896801427505228, 0.8128951211455855, 0.47409099241158914, 0.17283237762841164, 0.4243719392715226, 0.6775758624033937, 0.4160090197837917, 0.272329240574974, 0.49721262716284687, 0.3673980939992466, 0.20584415295322878, 0.5769091168476521, 0.16200931023850174, 0.20508409355630297, 0.5401309206979494, 0.21251779182445651, 0.3339810436295926, 0.45484596073246697, 0.2019969052478846, 0.1926607959472727, 0.18349576106849286, 0.18864243107961742, 0.1827638401983922, 0.1920613841160146, 0.19036850774038871, 0.1868181027737026, 0.18273351738630828, 0.08624148204829452, 0.0813491432707617, 0.07611960820751862, 0.07603894826936852, 0.08709552743646876, 0.08763881225724812, 0.08230471018855912, 0.08842489101102169, 0.08194673152264509]}, "mutation_prompt": null}
{"id": "135c1965-4bc7-41c8-9ec0-946e304a19b8", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "de619ddc-a627-4ec2-86c0-aef6ce17e98c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            \n            # Adaptive Population Resizing\n            if self.evaluations < self.budget * 0.5:\n                self.population_size = max(10, self.population_size // 2)\n            else:\n                self.population_size = self.population_size_initial\n            \n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Covariance-Guided Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.multivariate_normal(mean_solution, covariance_matrix, self.population_size)\n                self.population = np.clip(self.population, self.lower_bound, self.upper_bound)\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced DE with adaptive population resizing and covariance-guided reinitialization for improved exploration and exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.250039925641961, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.6970229061521835, 0.5800715604702913, 0.49815848844610877, 0.4506770644653685, 0.4928080668294641, 0.6708376792964448, 0.6454166284086453, 0.7636628455542792, 0.48445384458836005, 0.14408285151578637, 0.13437808861496991, 0.13917279084563527, 0.1598242605649275, 0.18907213480325413, 0.02899629878583143, 0.19013643942539726, 0.35428192073892917, 0.19483171125860732, 0.1402590299923413, 0.167501201132499, 0.11222510970550026, 0.11331590180421258, 0.11235027219401472, 0.1749874130127237, 0.14545896614873055, 0.1623080429383359, 0.17118533466074148, 0.09572078780272752, 0.06336297061431106, 0.09878229157610618, 0.13148269544211622, 0.05753057214775614, 0.10820122361721018, 0.12227202631915823, 0.12583937556531744, 0.10068373566031352, 0.9603615569585876, 0.9705091203020197, 0.9121410574471218, 0.9544190722658309, 0.9904985798865414, 0.9557823796715375, 0.9638992462286732, 0.9863264231373007, 0.97390489814952, 0.20621033742577743, 0.2162809553135605, 0.17496561642122144, 0.24070164000760508, 0.22984550900019962, 0.22899208743025323, 0.17820069187493404, 0.181113229037014, 0.2928771805131385, 0.21702299619076482, 0.31664137021890293, 0.19358365726143867, 0.1728455421898405, 0.25331940074226333, 0.3383029108481067, 0.1586080903291195, 0.46165640421399134, 0.3704650888277494, 0.2587659691310027, 0.1433493554650317, 0.22699847385123884, 0.17276903070459726, 0.13877889976368973, 0.19625164380689575, 0.13538438172686074, 0.3495039224461245, 0.15334232077525245, 0.21031178192155053, 0.1795811668503433, 0.32659190042802133, 0.523281128534925, 0.13348522958782538, 0.12124123508369633, 0.24055053150885009, 0.1318243604379632, 0.13325034792004042, 0.013358567898683171, 0.0683312612417647, 0.1269365077609771, 0.1684098525281128, 0.03267556312497111, 0.05441554131688009, 0.00581272797316601, 0.02153857775821688, 0.0041291175401388935, 0.14035766695694818, 0.17929787617906712, 0.1639420178784856, 0.11712810888781022, 0.09870505769801108, 0.10085215136353476, 0.1953495569854592, 0.1506135258131417, 0.29411305505551266, 0.02680572587417207, 0.04208325780155464, 0.07399395952477461, 0.12347096529877577, 0.09314507505923542, 0.06274982976428967, 0.0478882717894803, 0.13760155351083814, 0.033196283340981014, 0.10329473066975248, 0.09657881009082414, 0.07214494803149551, 0.08458050038559795, 0.11248757839892332, 0.3453409288359769, 0.12991451086384953, 0.1998916571459719, 0.0742723214912896, 0.562531005582041, 0.34803160002476885, 0.47198103391372237, 0.46377788715146995, 0.4922300675495225, 0.3911637971281723, 0.3662974081799557, 0.37764082906383345, 0.40116265917840654, 0.1255110794648746, 0.09552626246072482, 0.08938253978428423, 0.12170715871452198, 0.09412166688455748, 0.15586122263359825, 0.12768149785433647, 0.15212415464716944, 0.11586738319470902, 0.21515411806964124, 0.14639779433583244, 0.15990193834206312, 0.2906797858894141, 0.14908756132064205, 0.22742988739742453, 0.17509412251473278, 0.19473035319362497, 0.1366915858275174, 0.24211049062497159, 0.28696938559009255, 0.22257841735446116, 0.36561921965642175, 0.27066481918891816, 0.5525385424041871, 0.4206991683221317, 0.3991941515848648, 0.431700179318405, 0.2757616521342703, 0.29220127462441925, 0.2969111312247449, 0.22250305799203107, 0.40515144662419367, 0.4144842554102093, 0.1519335166297331, 0.20643517097596153, 0.27260031662916795, 0.22881293841045958, 0.20533186279498983, 0.24015403476780106, 0.23790363350506105, 0.19617951589638616, 0.22886980835871795, 0.22954848523487204, 0.19128543707896706, 0.21141639032934645, 0.19452644130242847, 0.21134517570042577, 0.1744430582372707, 0.2111970993482819, 0.20698092817548508, 0.19812586509109642, 0.17992581120740037, 0.18238996430548682, 0.1815893826067576, 0.17077273931610848, 0.18760461469065493, 0.18289890342362913, 0.5565231957254, 0.19770087908289868, 0.44555125087507164, 0.13975389770820623, 0.46738268785828596, 0.1672519400069059, 0.5937724420849728, 0.20973701477362872, 0.47607307004136035, 0.20867729520966483, 0.164216310290778, 0.43454987263129263, 0.21279549548088406, 0.43858773212973556, 0.49472645301870044, 0.17768480307743106, 0.1846792367780139, 0.17649607698682956, 0.17534751516043756, 0.18410288963607835, 0.18507418440505186, 0.19765137055768722, 0.19584413352609986, 0.18917410914403632, 0.09025551913345065, 0.09037952413887684, 0.09360167942537723, 0.09730693654989286, 0.09405334552068711, 0.0829363546580516, 0.09681924080118098, 0.07866965769431322, 0.0906262434057249]}, "mutation_prompt": null}
{"id": "8189d6c8-d069-4b2e-9627-4008323e43eb", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Dynamic Population Size Adjustment\n            if np.std(self.fitness) < 1e-3:\n                self.population_size = max(5, int(self.population_size * 0.9))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with dynamic population size adjustment for improved adaptability.", "configspace": "", "generation": 19, "fitness": 0.3687270399601547, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.7603145647783256, 0.7375415576730255, 0.7472857774789192, 0.7122962971006852, 0.671279873682212, 0.7225734041922487, 0.6995556825094351, 0.7076762286042199, 0.7378426719465475, 0.4755427562476532, 0.46406964373788406, 0.508953081305325, 0.5536461953128371, 0.4781729864267412, 0.5103093964514791, 0.4816014423649403, 0.45162061652900554, 0.444501688099353, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892055425135985, 0.10710321465351369, 0.10072480586024413, 0.1215803073282794, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4274608354645162, 0.4461935984310339, 0.4135219198196681, 0.4459254606161519, 0.4384728026825869, 0.523836631065355, 0.445820164611748, 0.4463677300817426, 0.4594901929010543, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.3710145618717532, 0.32426433084769546, 0.26092702920179744, 0.3828352040444917, 0.4867310173965954, 0.32523671479352223, 0.3889979286045434, 0.36492737798411223, 0.3166212791041787, 0.3970725387034747, 0.37763480399009464, 0.32893592782172787, 0.24303150084303593, 0.2297794885802802, 0.2816603858308344, 0.29589089297453863, 0.3636106831551087, 0.3231695120726026, 0.33553641150922553, 0.3540368032804294, 0.331935482599617, 0.4050818167341448, 0.37780133303329966, 0.356950245460245, 0.37429158132439033, 0.35770033714303184, 0.41760779016874916, 0.42445239019793646, 0.43074413200949724, 0.4333849572750258, 0.42444021434599144, 0.24010421221570255, 0.44013732691560503, 0.43801279730491427, 0.5300638404368228, 0.46624037454180745, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.25652025148308255, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.3124518655888642, 0.3203699546951928, 0.31910744777583677, 0.33765248737668185, 0.33016301792690894, 0.3097981077132683, 0.30961170676085004, 0.32189016628066747, 0.25036625840342475, 0.585111110646511, 0.5977775815089947, 0.6108378660668158, 0.5747543345835193, 0.5419405673799087, 0.5538712446410607, 0.5663779159446063, 0.5572766051914737, 0.5643301479109804, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.13644594903004348, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.39508136763922586, 0.4410903167190655, 0.4300788681181493, 0.38789498622202123, 0.3805641404961738, 0.3856595014429095, 0.3988308399896623, 0.4422751037352366, 0.4069875172735832, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374888142248373, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469531295466237, 0.19651919621329694, 0.16545281777375298, 0.8426162716815963, 0.1642689911622114, 0.7575914201198826, 0.19539193029394242, 0.7285222747415675, 0.7202913058616378, 0.8154921900816147, 0.8013594513609358, 0.8051364111134084, 0.16789427649003996, 0.8000467423476203, 0.8269629495430431, 0.2033121315127422, 0.7752711646187178, 0.21209411579733595, 0.7160866944933866, 0.15346802686491645, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.18830632365726296, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "e85376ea-86a1-480b-8cd4-e596a7e14f1a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "bc6b0bb9-d37a-42db-8f7d-44b0845af006", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.1 * np.random.rand()  # Self-adaptive crossover probability\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            if self.evaluations < self.budget * 0.5 and np.std(self.fitness) < 0.01:\n                self.population = self.population + np.random.normal(0, 0.1, self.population.shape)  # Dynamic strategy switching\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with self-adaptive crossover probability and dynamic strategy switching for robust optimization.", "configspace": "", "generation": 21, "fitness": 0.3102599357744819, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.20.", "error": "", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.4966019922001359, 0.49282869938185725, 0.47771454771159716, 0.45197655598651176, 0.5022637559123276, 0.48327390951225, 0.46644044264610707, 0.4286444472693667, 0.42932679984159716, 0.35705972742406256, 0.3783018129212392, 0.3428961590826015, 0.36748832827567335, 0.33785615904004684, 0.36398685905934414, 0.3492859584473188, 0.33298256930718073, 0.4027823530841138, 0.11134946944636481, 0.1292616123057514, 0.1406064752551538, 0.10950571870786441, 0.153157834845561, 0.11509149157127163, 0.1291072830601746, 0.136451468199416, 0.11815984585946715, 0.12304731889849685, 0.12228341869646175, 0.09691961790371983, 0.09993225968646546, 0.09853656955294188, 0.13448391730149611, 0.09949173384251297, 0.093156287207797, 0.10661378298268742, 0.859429340667168, 0.8949580098921412, 0.8730890320581974, 0.8591401590600802, 0.9770560145462289, 0.9236031801480159, 0.8804192753040891, 0.9418416815187428, 0.931914424096184, 0.3086666406805336, 0.33546035226334847, 0.3880339011170185, 0.3241843599037736, 0.3170053097942064, 0.3120930069930994, 0.3225781421854377, 0.34641925584350075, 0.3151664262510858, 0.8398564203426319, 0.7643294299011394, 0.7955937017680914, 0.8656184722810938, 0.8245217044424672, 0.812976584015844, 0.8216225812619492, 0.7778943226581777, 0.7939065025575456, 0.251864546129445, 0.3061254673478646, 0.3850691312054527, 0.36934257160090667, 0.20487102844657257, 0.40061822030054595, 0.19830657730500356, 0.1820054198632859, 0.2781786417318455, 0.30851086157263485, 0.2058127352551392, 0.29722919025745087, 0.24170770761194516, 0.3008421166996471, 0.1984415938649814, 0.2633897210806484, 0.25042503516517356, 0.33189036526596627, 0.29535667783980657, 0.2737357085674613, 0.2626098270575301, 0.2657580707795222, 0.2605409905349235, 0.280245725199772, 0.297154956028432, 0.2629728096531293, 0.29311896562851003, 0.3250024888375578, 0.3311127475422887, 0.4006421669453457, 0.40827463098982986, 0.3447389127183471, 0.32290508854567, 0.3841573983533395, 0.42533494765532975, 0.33643616717796754, 0.15540729870901682, 0.10734791215989647, 0.10321899597451034, 0.12142337637551537, 0.15400121527288646, 0.12261791067474859, 0.13512464375522615, 0.1463989776034299, 0.08220862642071392, 0.25756195009942284, 0.24177858226337845, 0.2868260603412697, 0.27018351486040937, 0.28977370668661273, 0.2916974268108381, 0.2876769916266724, 0.2609748147598747, 0.25371587311316746, 0.429312439446749, 0.40371645642251097, 0.4453837685968267, 0.4244140721238331, 0.45376828024091354, 0.43021505298846974, 0.41134663961369866, 0.41935830759464177, 0.4156691515070339, 0.10384640083235486, 0.11671331784809513, 0.10336565457585223, 0.11400393367174344, 0.10077440926685144, 0.10102806476681814, 0.10812306034489005, 0.10569070929600288, 0.11651444161373781, 0.15177867033162706, 0.1855827766088889, 0.16455942482666397, 0.13931939561304407, 0.16190897996067743, 0.12539512475968662, 0.28778854942169296, 0.14478617573559882, 0.18040720956234801, 0.34052077691035154, 0.34714436419001005, 0.34459408789254564, 0.37072074332149196, 0.347710543118829, 0.3683615014286956, 0.3585300530739167, 0.35944863728959076, 0.35022608082379414, 0.3182779410828621, 0.28595009340163335, 0.2982195635467595, 0.3273463302307904, 0.2986278901914875, 0.288975502397927, 0.3566695278014046, 0.3178312937348805, 0.3091046900284081, 0.20003162486959314, 0.1868534403179457, 0.18327541391701874, 0.1934763567975829, 0.20872676575814686, 0.20576617344491532, 0.20557659700921382, 0.21025814289239408, 0.20232026332004316, 0.20123350631399906, 0.20335009225836798, 0.2697796060284553, 0.44423244866222644, 0.1796598338596448, 0.18325714992370434, 0.1833664157875431, 0.185698097985473, 0.2963282379543092, 0.5812144148686933, 0.15238128521931082, 0.1691431666412041, 0.4837067595034136, 0.5523412944954915, 0.517665229294208, 0.15688968064010855, 0.19277426687458887, 0.4771754278971335, 0.43978492164033256, 0.15232426730746207, 0.526741865793519, 0.1929682657346251, 0.1635415868779908, 0.557989629252475, 0.15642708621887158, 0.20680762843911493, 0.313610266124444, 0.18352894481778348, 0.19194370306787756, 0.1811077396788986, 0.18613117996998918, 0.17813314378478085, 0.2032294718525448, 0.20077623157161706, 0.18523277972954555, 0.18090163607756438, 0.08591908104002177, 0.07896824696471882, 0.07957298723332318, 0.08753246573530671, 0.08568357017518824, 0.09252482951635044, 0.08135047658695971, 0.08139104885124959, 0.08359879042858576]}, "mutation_prompt": null}
{"id": "ed20011c-cb6c-427c-aa95-aac9f6fed1d1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            self.population_size = int(self.population_size_initial * (1 - self.evaluations / self.budget)) + 5 # Dynamic population size\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Selective Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                weak_indices = np.argsort(self.fitness)[-self.population_size//4:] # reinitialize weakest solutions\n                self.population[weak_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(weak_indices), self.dim))\n                for i in weak_indices:\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with dynamic population size adjustment and selective reinitialization for improved convergence.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 27 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 27 is out of bounds for axis 0 with size 25')", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {}, "mutation_prompt": null}
{"id": "961d7884-390f-4036-8b3f-84c45b81fff8", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                # Gaussian Perturbation in Mutation\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c) + perturbation, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation and Gaussian perturbation for exploration improvement.", "configspace": "", "generation": 23, "fitness": 0.2542819194755663, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.5070423902440959, 0.5198888889625064, 0.5270682451001284, 0.5491817182605881, 0.5081468657294599, 0.5172946852235639, 0.5164906113182872, 0.5171326186733469, 0.5071487583489223, 0.1371515564760708, 0.12723345977126355, 0.12257268453007619, 0.1393902660938584, 0.10588338015343812, 0.138958276763971, 0.12337635380552459, 0.08857374538711316, 0.09659687604866651, 0.11051838937182423, 0.10775170592938343, 0.128443037722207, 0.12141110807692435, 0.11640501933974556, 0.12544749171581948, 0.10385392030881324, 0.11649052568410412, 0.1058686775559945, 0.1169666514882387, 0.10726311809223121, 0.10062786486748987, 0.09431985718382074, 0.09832594607562228, 0.08904326153004072, 0.0947803203068257, 0.1097804486881998, 0.09569303485204128, 0.8865488860159484, 0.9129106600775195, 0.8985551917970532, 0.9912727408864128, 0.9150331214487881, 0.8860288095120639, 0.8998292060959326, 0.9089621053039842, 0.870337696676925, 0.29630023167650454, 0.2906966994532928, 0.29654743695523844, 0.2900581193644787, 0.2752136650917347, 0.2901440456248482, 0.29832518020417176, 0.30127112343888607, 0.29059241377943257, 0.7586464230999515, 0.7410271802593673, 0.5839510116317204, 0.785142319781492, 0.6943668374589349, 0.692208746926446, 0.2847960407339699, 0.7136167942861493, 0.5944210443754083, 0.17945747800853873, 0.15804578236474776, 0.1733474499765698, 0.1834025195317287, 0.17641020300729537, 0.18975783205194874, 0.184145046750668, 0.19021579164944546, 0.18739195605578485, 0.16709131414423684, 0.16830364272635923, 0.17048281616393302, 0.1789066545647886, 0.1789278809102256, 0.19049958067609496, 0.19186259963519814, 0.16605516080988436, 0.1833556575096128, 0.07887797606054026, 0.11082690331524259, 0.0943817169285317, 0.12748190453052188, 0.09830212527544024, 0.04675247140190353, 0.05978766379467837, 0.09529880848077099, 0.06236552448345101, 0.17408614920439447, 0.17790258827512806, 0.17083379568571433, 0.1528975621488896, 0.1562872880515742, 0.14838199399189722, 0.15738230822472343, 0.158457175303923, 0.15824913350102232, 0.02360586779543883, 0.009893451367647632, 0.0061600776032295634, 0.01589636009215989, 0.010494069669577555, 0.02471594227751739, 0.0017756266430444256, 0.0045463759280044425, 9.999999999998899e-05, 0.1400128676038055, 0.14060865148969082, 0.14436701266840812, 0.14006928648593675, 0.14468141349449448, 0.13950511580300395, 0.13332960774388924, 0.13115944226971388, 0.13214692411839968, 0.4886597944640221, 0.46393378853555345, 0.4677014127217284, 0.46293310457347236, 0.48225821432082094, 0.4517984502408351, 0.46344983550132957, 0.45595749040095923, 0.4462994868376523, 0.1065167946788319, 0.09651130998695079, 0.10985298710337299, 0.09197561449625502, 0.10879598401700263, 0.11324318179980797, 0.1090901244963387, 0.09278190673457376, 0.09754884583815981, 0.13316156622872566, 0.15137585085134675, 0.1348115986937719, 0.1402893318078986, 0.1517775451547927, 0.1572761180811082, 0.1401880586311569, 0.1734369767963322, 0.15879995770548683, 0.31448669586428746, 0.3093151386923243, 0.31352323500793833, 0.30426346766111334, 0.30652176690590494, 0.29690144777259353, 0.32224927471118014, 0.31141044607475077, 0.30975075893144743, 0.2553700227655803, 0.24782872091613017, 0.23907186777187628, 0.2607844744701867, 0.24461877786875208, 0.23675903235100693, 0.25839895065903895, 0.24905827057339225, 0.25759691498101445, 0.19330106912770462, 0.19340422625047493, 0.19352387078770383, 0.18609461147937256, 0.20787298387383113, 0.20044872786104428, 0.2069420354720053, 0.17766370584742908, 0.24639972755290407, 0.1842588396993491, 0.20475056266500646, 0.19758665172462853, 0.20025311435377458, 0.2226139594210561, 0.1952154943841291, 0.18319341546197854, 0.17411576788251226, 0.18971089042916156, 0.18388520948653297, 0.18198672362446333, 0.15169858233247802, 0.17750734797674028, 0.1666043140745449, 0.6315925178871862, 0.5530583192720275, 0.16154289044982273, 0.5880286825291743, 0.6835647825921269, 0.5771617987110063, 0.6496646799108805, 0.40848967977851613, 0.16554231861165336, 0.5829400677605349, 0.15309852036839855, 0.16410198620760386, 0.2065038667773188, 0.17889690806683245, 0.1797675409823305, 0.17765840625100704, 0.17643421306949636, 0.17796542004912097, 0.17850836415730098, 0.17668702969240968, 0.18936449992606819, 0.18401785401338888, 0.0817203170841394, 0.08373562661360046, 0.08032778696711851, 0.0885735570563464, 0.08146416526040068, 0.08647003572766532, 0.07491097409084646, 0.07730497548134863, 0.09022435504477577]}, "mutation_prompt": null}
{"id": "18458e82-d23d-4c62-a4ba-73269f2043ab", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "01c2112d-a925-401e-a8a4-a4bfeab1e237", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "9e214738-f7fe-4bcb-9b13-5733e37c49c4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "b243d5d8-fa87-403d-9a3a-702b23751fe2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "a8909e70-95d3-4250-b523-31e68ad91221", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Strategic Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation factor and strategic reinitialization for improved convergence.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8448359206407715, 0.8303234509084114, 0.8235272173197524, 0.837333796681604, 0.7968829216159826, 0.8379325188099078, 0.8315667954249253, 0.8266692137912074, 0.8369027449521302, 0.6332065230503654, 0.6728055281122338, 0.6230352377830026, 0.6743658924681502, 0.6615771464474526, 0.6623762198412992, 0.6865375274897927, 0.6411461607945107, 0.6448587361094169, 0.11971982615961929, 0.12018828543179949, 0.12383943155440102, 0.114666238054009, 0.11572973867223735, 0.10834047749547338, 0.14468417066090988, 0.11102511092696021, 0.11469220255692891, 0.13892013568878103, 0.10710321465351369, 0.10072480586024413, 0.12158013104481125, 0.10697613861602617, 0.12085298905626463, 0.10807769123765743, 0.11552894924020962, 0.1114869361416666, 0.9670742405363472, 0.9381618424157966, 0.8552878087746114, 0.9123188085558989, 0.8776158381885527, 0.5811529402533815, 0.9295558609529667, 0.9113033950646008, 0.9524694897734968, 0.4417924884115054, 0.4511806506001662, 0.406412989634508, 0.47952337515494226, 0.444920153797548, 0.5260555960329173, 0.4732170698338347, 0.4671709313670753, 0.4606552606413604, 0.8279246127170706, 0.8418907699896698, 0.8057797930655493, 0.8151609548455492, 0.8412182923658311, 0.8591868049242717, 0.8182527210828363, 0.8428825269747264, 0.7724547644568618, 0.384577348228051, 0.3045265983646942, 0.26092702920179744, 0.3890360726144634, 0.5594828129796536, 0.3116175507469203, 0.3773165804135916, 0.3450213702965762, 0.2985948817160593, 0.3658051969405428, 0.3652800999321755, 0.300636801924995, 0.24303150084303593, 0.2297794885802802, 0.27200995728877586, 0.2880700108966737, 0.3163217236995651, 0.3079564544771969, 0.3344672140540871, 0.35084598602779293, 0.3300162923443887, 0.3786076922206807, 0.3976414099460114, 0.3768856145526652, 0.384101003546895, 0.38418992570627863, 0.44626762565458433, 0.5037945748705844, 0.4300136484806022, 0.4707143467235232, 0.4242251722408339, 0.23959712368038222, 0.5342276054487882, 0.5261806214012212, 0.591890541059347, 0.5829048912039563, 0.07545312314260866, 0.11346587501813687, 0.13081046083658254, 0.24827275367437773, 0.16721160185929673, 0.10856544858427275, 0.16902493690697962, 0.1524132453860073, 0.20415501587565876, 0.29812124598223444, 0.3081413795113672, 0.314027707834469, 0.3174276810411957, 0.32583867202811134, 0.3027601026789971, 0.3030125140714901, 0.3047384405008413, 0.25036625840342475, 0.7087153551285654, 0.7246305729095681, 0.744036838356838, 0.7332537936655275, 0.6743969418193971, 0.7163122842157548, 0.6966442798017161, 0.6902809983305107, 0.716488973567747, 0.10743147870738434, 0.10232523045285458, 0.10706118767251938, 0.1076639927209273, 0.09632341373896902, 0.10033055326707452, 0.09790041718518172, 0.11809029625567169, 0.1364452561576429, 0.1247976597917212, 0.127603830157638, 0.20489482958011374, 0.1385935146629519, 0.17305064276355464, 0.17868372046460468, 0.13434368254455498, 0.15057692303318015, 0.15325476085927314, 0.386950183320225, 0.4194127258158936, 0.4003252892152356, 0.3805787685987846, 0.36734696945934264, 0.3761577473669965, 0.3981666790725116, 0.42985824886754964, 0.41240970294602153, 0.31418113871889464, 0.3351839632158433, 0.3378299824618076, 0.27818872375640413, 0.3213703126911498, 0.31057593451877896, 0.2886925272059411, 0.3118116116450811, 0.30843829605438045, 0.21054838706773182, 0.20323404917418775, 0.19490411880345704, 0.18844849101135208, 0.19866837772044388, 0.1978174121555598, 0.20974538447576696, 0.20113709249087286, 0.2088045760235807, 0.20499888052412085, 0.18732496761774342, 0.1890853694659005, 0.23374802772927905, 0.18173731535327475, 0.21330529141332966, 0.20305927395074774, 0.20469170212458776, 0.19651919621329694, 0.17645248730288, 0.8427810794080323, 0.16431558965246496, 0.7542570162488828, 0.19772985229555584, 0.724499513541724, 0.714662751165879, 0.8150158348700274, 0.7971312431039794, 0.794816106710293, 0.20891996674097002, 0.8069569062696433, 0.8306000286503776, 0.20331240238368076, 0.7692046883786756, 0.2120940725274446, 0.7406975073694295, 0.15384450920058956, 0.1803774629857784, 0.18871635765716588, 0.19088313341730057, 0.19767083079452807, 0.17681691913677555, 0.1883060047663776, 0.17749537609188115, 0.18249398763077107, 0.17703875498477628, 0.08184786532256971, 0.07787823955280238, 0.08646041823740092, 0.07865170892338125, 0.09361754453517857, 0.08195123109498959, 0.08824766515290428, 0.09011013699529835, 0.08545461397796028]}, "mutation_prompt": null}
{"id": "eca2b2d4-6286-437a-8298-93e7827a7957", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Dynamic Population Size and Adaptive Reinitialization\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population_size = max(10, int(self.population_size * 0.9)) # Reduce population size\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with dynamic population size and adaptive reinitialization for improved global exploration and convergence.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 22 is out of bounds for axis 0 with size 22').", "error": "IndexError('index 22 is out of bounds for axis 0 with size 22')", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {}, "mutation_prompt": null}
{"id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 30, "fitness": 0.3893778210625806, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "22056b22-81dc-4ad8-b7c1-38e7a31d4be0", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "da327249-0d3d-4bfb-8fb3-9dddb878f0e1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "f740cd1d-729e-414e-af39-8bd2c6484709", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "2d1bc27a-21a9-4fb8-b2e8-5d842f6385f3", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            fitness_variance = np.var(self.fitness)\n            self.crossover_probability = 0.6 + 0.4 * np.exp(-fitness_variance)  # Adaptive Crossover Probability\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population_size = int(self.population_size * 1.1)  # Dynamic Population Resizing\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced exploration through the integration of adaptive crossover probability and dynamic population resizing based on fitness variance.", "configspace": "", "generation": 33, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 25')", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {}, "mutation_prompt": null}
{"id": "e36a8473-316c-4bc9-a727-5492ca547dbe", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "37fe5b68-7e42-45a4-9d9e-49888dd4eea4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution * 1.05, covariance_matrix)  # slight boost\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                self.fitness = np.full(self.population_size, np.inf)\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Adaptive Differential Evolution with periodic diversity boost and enhanced mutation strategy for improved exploration and convergence.", "configspace": "", "generation": 35, "fitness": 0.3670141914285336, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.829202482745304, 0.7963282196242305, 0.8011003511820769, 0.8215598236651573, 0.8159550174379183, 0.8212965030277638, 0.8301769271324517, 0.8153194647909286, 0.8185601232979123, 0.6406446448379045, 0.6645367678848677, 0.6459085394406087, 0.6655197261956368, 0.6508626995635207, 0.6074624141664001, 0.6469446535750283, 0.6358537608083833, 0.668971461894968, 0.11502585522024833, 0.10472424456831719, 0.12294635180126079, 0.11085163064530756, 0.1266783038499134, 0.12744770812063322, 0.12426231655465614, 0.13311149242322995, 0.12145923469148534, 0.10947408843222706, 0.10285621530099709, 0.11030685098714188, 0.11468354939086134, 0.10458307868376482, 0.10445784600423669, 0.12267157667716311, 0.10911405895993098, 0.1142762577253652, 0.9670742405363472, 0.9622635700853294, 0.9375608278723135, 0.9520312566069072, 0.953563663914688, 0.5039010636628696, 0.9513756598258304, 0.9611734401620088, 0.9695441464232848, 0.42486838558856566, 0.42029692994637546, 0.4580032678907575, 0.37745832214779007, 0.420647120123115, 0.45724264736809495, 0.4041918376580931, 0.5127901544484285, 0.48990337252818084, 0.8322849947270372, 0.8097524986477541, 0.7922554741727522, 0.7859288551574273, 0.8242425090064674, 0.7813590852011226, 0.756812161085221, 0.815823922150234, 0.8075067278606355, 0.2855642038406617, 0.37341401788387063, 0.2116211651533908, 0.22730591673724765, 0.31305670088773896, 0.286155908959843, 0.22656818784264066, 0.1591991457397104, 0.17924203771608738, 0.25293216960622233, 0.2025447267083278, 0.159970993866282, 0.22512234334195613, 0.2519031431923391, 0.23429273590875999, 0.26532934898742055, 0.303357468533338, 0.288484378082973, 0.26205510978886526, 0.22291080200546254, 0.27280469322729994, 0.4079285212786241, 0.05073030169058579, 0.3002032231928031, 0.39537171386561454, 0.2805830670739279, 0.3160113367502819, 0.5035902329771915, 0.45530496167867873, 0.4036169825468424, 0.4627624272507319, 0.5265725863764735, 0.468974465633371, 0.5062922206799949, 0.3487852886846404, 0.5540235336896632, 0.08170880514913026, 0.17285707811622364, 0.07012169378209843, 0.27200096651539063, 0.22602673837043785, 0.27510637784492165, 0.09443650041437923, 0.12622772885811806, 0.14917917949646198, 0.22975836365782298, 0.2950990281112815, 0.2916906537121655, 0.2899242425004258, 0.310436487267051, 0.31028464930040733, 0.2960203047322548, 0.2894474459553481, 0.29758347286994735, 0.6352324464030551, 0.6571775156815678, 0.6835509067983824, 0.725896333393647, 0.6762997620240538, 0.6281947210383492, 0.6653410235995977, 0.6302806886269661, 0.6951679769220336, 0.09593559058296197, 0.10662758222284463, 0.09919195180508744, 0.09293073891962889, 0.0993109044144892, 0.1084520061559382, 0.12364344294954721, 0.09283264957063331, 0.09671091812995314, 0.19069905008888932, 0.14697069004234986, 0.14039936654170992, 0.1385935146629519, 0.13555845245312081, 0.1511259533436241, 0.1900215643603521, 0.1481117297822857, 0.1762939832515189, 0.3715745698528241, 0.39019025317627776, 0.3872351562613938, 0.41067660726581745, 0.366885980362761, 0.392585212003425, 0.3813020109547446, 0.4086382754047254, 0.39831867528358333, 0.2967525629663821, 0.30611536023661334, 0.3046558888385359, 0.30018335397519236, 0.30318710586056286, 0.28347654366693864, 0.3086454303421612, 0.30328212966110457, 0.3134124643434777, 0.23264172108124326, 0.1893630685731218, 0.1927861132295794, 0.22003168833891162, 0.22204650784696756, 0.21581732829641964, 0.22395078821056602, 0.21357141891335363, 0.19903056594809865, 0.19410782184018516, 0.18123261674271707, 0.31420687754289034, 0.2237133268394068, 0.18657670108544278, 0.19793667580955232, 0.21750082167934892, 0.24435495438186383, 0.19220000388353964, 0.16543387046914848, 0.840855310892304, 0.15151324112498354, 0.7781356485789155, 0.19474401649353168, 0.7337198954020321, 0.7164530447961492, 0.8122049921960773, 0.826632829862232, 0.8055112651855734, 0.20502617812240864, 0.6768041544828948, 0.16652387004681846, 0.19541743357069907, 0.7466927197736343, 0.21152913435713283, 0.21183132135731197, 0.15359771551751222, 0.18169274361891496, 0.20461072253442691, 0.18563161279387863, 0.17610590431895345, 0.17617120090849403, 0.1786156725710103, 0.18625833786660861, 0.17588598482829942, 0.19218042933901325, 0.08448997085839327, 0.08246774393036072, 0.0874189493636155, 0.08360669536842069, 0.08148865411671902, 0.08977980439374844, 0.08486995660307217, 0.08862853729233355, 0.07631158702319207]}, "mutation_prompt": null}
{"id": "b7519841-f809-47b2-99af-6e0d926a9682", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "af42badd-ecf0-4a9e-9d98-2278545e9dec", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "e80bd848-7209-4cdd-b68d-3015ac248a81", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "b417d552-7ff0-483b-b93e-462dd0ca3918", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "df6bcf54-983e-40b6-92e6-edfd043551c1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "3f8f77b9-59dd-45eb-8a5a-291879a6580a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "5b38cd11-9d64-47d0-b4fb-6c36a652bb65", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.6 + 0.4 * (1 - self.evaluations / self.budget)\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Refined Enhanced Differential Evolution with adaptive crossover probability based on evaluation progress for improved convergence.", "configspace": "", "generation": 42, "fitness": 0.3757150188191908, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8481253353909771, 0.8344351861338823, 0.8486088789934869, 0.8098094428581376, 0.8411588741094791, 0.8545883690499856, 0.8217205544509445, 0.836604598544545, 0.8072441461624141, 0.6585601330397299, 0.6814935981169519, 0.6565056637351179, 0.6598587095216908, 0.5877549209250268, 0.6708921073306277, 0.6551626113612077, 0.6036689716035835, 0.6522592942831833, 0.1462135511886541, 0.12682565560783454, 0.12021793602988018, 0.1142259360968847, 0.1293345893707759, 0.1637726854919278, 0.23290819582235966, 0.11615893799289423, 0.12203861950843364, 0.1150640795430703, 0.1088757778552839, 0.12584393490757884, 0.10338151426498066, 0.10364381461913397, 0.12616806717853035, 0.1115445743407325, 0.12236222309374012, 0.10404422656226164, 0.8450782724929541, 0.878157380406608, 0.8919087130786624, 0.802614984936698, 0.811810399001475, 0.5814572539372942, 0.9413311667840156, 0.9903908144296678, 0.8731972793085457, 0.4948838577295196, 0.4697363228746939, 0.4634896244151905, 0.4764715346908637, 0.40912993532987707, 0.47111711526027555, 0.4725091361902698, 0.3204931573749885, 0.36081491310375247, 0.8617779772715358, 0.8489622435813089, 0.8025822008406296, 0.8523074144908993, 0.822876263025832, 0.879265634690938, 0.839225895850023, 0.8623645558110347, 0.8247953945349048, 0.2509705062848091, 0.23507928237619868, 0.2704615691025196, 0.2354995550723491, 0.20248350248147928, 0.23473136562329966, 0.25763007852642794, 0.2179115556791945, 0.4050161871733672, 0.40576053865819917, 0.12756718844070059, 0.4210207634039378, 0.20789420890125654, 0.30006600903595904, 0.29801808945031183, 0.3204872320114738, 0.28654085460353484, 0.35934612740236394, 0.3859179435596002, 0.28255226173482284, 0.34598299450230774, 0.3695454898915156, 0.3861907265722274, 0.4549760858658507, 0.358451559597609, 0.143173177963419, 0.3573046922474101, 0.4891368946561637, 0.4818008472237899, 0.5392074342614166, 0.3298660090627439, 0.3679777309662772, 0.4873115069380265, 0.3432816615272971, 0.3303266061168564, 0.5095834834559274, 0.1867769202738666, 0.15785207730809347, 0.14922034663880945, 0.09560069991510822, 0.19065901615519787, 0.23285770787991467, 0.15346650035296494, 0.18711375937486252, 0.22531114304668587, 0.2713486737294549, 0.3144008377304781, 0.276403362931671, 0.23210883933396909, 0.2867122622219689, 0.24613414352691676, 0.24602057433159075, 0.21157182983413436, 0.25527332405745096, 0.6541918169718057, 0.6902364607869648, 0.6187603510539245, 0.6437707032335738, 0.5969572387251219, 0.6328424308602894, 0.6614100428317555, 0.6102491018049925, 0.6986545495718317, 0.0966007294195973, 0.1108775988247882, 0.10240632776529601, 0.12077985652911483, 0.1324041787122705, 0.09356308786867162, 0.10450159043623608, 0.09776310346282657, 0.09747774118561847, 0.15176861977891853, 0.14307135641439817, 0.1974124785081779, 0.20961961702793508, 0.1616312278554618, 0.1274115042099816, 0.18195400805131268, 0.14714350995981185, 0.12467800479420854, 0.40991267632367534, 0.38852899935206975, 0.43061025689691834, 0.40296685701520496, 0.36303638687432527, 0.38669526816973987, 0.42377291518382276, 0.45072665647221755, 0.427352384283607, 0.33014739380210745, 0.3598447997549682, 0.2786840761586331, 0.29334051245628967, 0.2567276514022663, 0.3306066055670155, 0.31840286654056804, 0.34765196753888783, 0.31315792613731663, 0.1953880754037648, 0.2467978706842281, 0.21367676699228066, 0.20774844512497814, 0.22928722101864918, 0.186421787548546, 0.20362793848973482, 0.19592918784999347, 0.2106243184536477, 0.23976952918361816, 0.1957955477145864, 0.1989207270089598, 0.4229208727591033, 0.20969339986308655, 0.3262544889353991, 0.19914380636293227, 0.18874807539721483, 0.2053793609088006, 0.18510272507001213, 0.185254895249372, 0.8792463893957931, 0.7899304744562101, 0.6242246941911044, 0.7992169709173825, 0.8131362160452612, 0.8506801066671295, 0.821451333886901, 0.5333689649112994, 0.6187656031420742, 0.16734156303737968, 0.20041386777741188, 0.20648981361921404, 0.6140255631908634, 0.2103544135581752, 0.600667905579507, 0.11563342144899402, 0.17861651504647458, 0.19020209733426996, 0.18626677698971683, 0.20520248289312404, 0.17880445291230573, 0.21528932729308048, 0.1789897884447097, 0.19059499658193357, 0.19132957127005223, 0.08519994880505166, 0.08781803762612994, 0.08231923440420452, 0.08451036051834704, 0.07263133878718853, 0.0837392857874012, 0.0813937398778708, 0.08526979703606119, 0.07680163937698925]}, "mutation_prompt": null}
{"id": "8a89b313-2a3f-4612-8cd9-bb2bd2f8c411", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Dynamic Crossover Probability\n                self.crossover_probability = 0.9 - 0.4 * (self.evaluations / self.budget)\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with improved diversity preservation and dynamic crossover adjustment based on convergence rate.", "configspace": "", "generation": 43, "fitness": 0.34453952671243854, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8348625090607404, 0.8403835469808077, 0.8097559703765136, 0.8145868970044753, 0.8110188367248727, 0.8225978814161795, 0.83392558794499, 0.8387205790578526, 0.8011583936214617, 0.6295656540633053, 0.6678600076427315, 0.6408036038297723, 0.6585758168242403, 0.6413481321657684, 0.6726567773151827, 0.6558845204342274, 0.6390962312615938, 0.6753679080742503, 0.18711435394915443, 0.14519427523788542, 0.20988034548117795, 0.1590043905070324, 0.1666046869333837, 0.21256892374109848, 0.16559999560058714, 0.1257649636927306, 0.1766453401947421, 0.1316596566712287, 0.1307107828264802, 0.11771069672056378, 0.12371319758195054, 0.13036175388218396, 0.1198254105614529, 0.1266371150020661, 0.1171384285541095, 0.11629087256965065, 0.9670742405363472, 0.9070982230338993, 0.8584165245983236, 0.8580651713152424, 0.9049415659240416, 0.7981584003714808, 0.9306613786866608, 0.945242977204569, 0.9471609959176557, 0.37617356294474014, 0.3757815470321697, 0.4053679133339537, 0.4066409283775372, 0.42567435770704165, 0.4230991911415778, 0.41674821121405825, 0.40896696538813304, 0.4592087388356494, 0.756110490866954, 0.7860801924132479, 0.8108483451439589, 0.7946285331089623, 0.8174058638257136, 0.7709400791233925, 0.789416472336474, 0.7712811590709614, 0.8164621022723306, 0.22033504737235776, 0.2045567543816893, 0.2258328237217172, 0.23892685973294248, 0.12930626771495768, 0.19256766278596937, 0.25953747486990186, 0.22114475573053327, 0.20364243269707727, 0.2092253619580734, 0.24895662556165832, 0.23564379236443822, 0.16783434566885758, 0.251857655552461, 0.21807707787085184, 0.21839915691847922, 0.24472305618002088, 0.1761372239217066, 0.16264803878298384, 0.12042085048605755, 0.12253822835662542, 0.19454560127287346, 0.19703425168208888, 0.11357318606711109, 0.13951270837937535, 0.12922668087136557, 0.12754352288598292, 0.252790142585958, 0.32974044220295384, 0.2760093236063995, 0.30461043901802143, 0.2549794527323114, 0.2723110411876559, 0.3420000418994352, 0.3070065034998767, 0.296380941016785, 0.05095672345996993, 0.0769352891151942, 0.06330287047326943, 0.09756877552749943, 0.11417007451293104, 0.12329554378374707, 0.11213411241479121, 0.08991241705559039, 0.09677235114905702, 0.19452722823636925, 0.20044349104954173, 0.21361198386125502, 0.20819439579798993, 0.21075118402338078, 0.20778541630646108, 0.1926198553469356, 0.22260820163695327, 0.2130953770363906, 0.553300284816362, 0.5503536940477972, 0.5346703611862128, 0.5572286794239503, 0.5596097380697058, 0.5487486896476917, 0.570354982997574, 0.5540226763982684, 0.5521865104480992, 0.1047592263544842, 0.1053160239918467, 0.09721598649672791, 0.08996457859771967, 0.08749575576980861, 0.11243099585844996, 0.10312282139918427, 0.1099275220019239, 0.09701363242467764, 0.13590942470768475, 0.12722965035014389, 0.17529832398371525, 0.13958315542977884, 0.14242723883890118, 0.13049331633264316, 0.13749986088122712, 0.14362852337638543, 0.1341294837013749, 0.3407220171554789, 0.3451825854948397, 0.35531197280179694, 0.3846560274905041, 0.3534708234409242, 0.35447439368339817, 0.3723739738628178, 0.40266179626712717, 0.39000658620528306, 0.24922839979915445, 0.28751639774868654, 0.32313485854952373, 0.22869310294563427, 0.2504286176113375, 0.23929827523035263, 0.2901665445675895, 0.30888142821467457, 0.28656888442076456, 0.20273180088503662, 0.1975568159001061, 0.20675058803088187, 0.19421754382026912, 0.20393437835312433, 0.22241734746804664, 0.20008756667749883, 0.18788530147811167, 0.19635705753218013, 0.21732648877710348, 0.20331930748390592, 0.190190551947086, 0.22537081272972692, 0.19050385268689884, 0.19802881589492183, 0.18434507750641715, 0.21390520125220536, 0.21920156483445163, 0.7465065445673643, 0.8158830580350334, 0.16870968979536005, 0.709608022294053, 0.5248029356946137, 0.7414922266767309, 0.5358860207846585, 0.686026729435576, 0.7172198343046265, 0.7698241816354898, 0.5934028330770145, 0.5151703070212985, 0.7471222835028806, 0.3032055435886899, 0.6922128741400099, 0.2105473367618399, 0.17040295759299073, 0.42652111406235405, 0.18704472848201803, 0.18036616962618968, 0.1864500556140195, 0.18555252297696623, 0.18100789229842895, 0.19079668592946186, 0.18415132549446, 0.20433808254877117, 0.17476750717661216, 0.07596955446054576, 0.07356846533623684, 0.08606884378103807, 0.0769771174782865, 0.08033820388503465, 0.0803149975281845, 0.09160276235783571, 0.08308562595968394, 0.07625560214575433]}, "mutation_prompt": null}
{"id": "17581367-8fa9-4861-a552-556516e27982", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "b7624087-7aac-49e1-ba37-d0c593799763", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "cfcdb374-7cb2-433b-9b63-b925b9a6b890", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n            \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor (minor tweak)\n                self.mutation_factor = 0.6 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Periodic Subpopulation Boost\n            if self.evaluations % (self.budget // 5) == 0:\n                boost_size = int(0.1 * self.population_size)\n                boost_population = np.random.uniform(self.lower_bound, self.upper_bound, (boost_size, self.dim))\n                for i in range(boost_size):\n                    boost_fitness = func(boost_population[i])\n                    self.evaluations += 1\n                    if boost_fitness < np.max(self.fitness):\n                        worst_idx = np.argmax(self.fitness)\n                        self.population[worst_idx] = boost_population[i]\n                        self.fitness[worst_idx] = boost_fitness\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive mutation and periodic subpopulation boosting for improved global exploration.", "configspace": "", "generation": 46, "fitness": 0.33898997278611265, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.7779137668652931, 0.7375492579256152, 0.7690373822925634, 0.7719473187388423, 0.7914875947177696, 0.786875216170118, 0.7874980123661112, 0.8153452024509014, 0.791229452579363, 0.5634384295685536, 0.5766073351797726, 0.5845285209897357, 0.5138447164955717, 0.5477449195252103, 0.5326611533041692, 0.5387810602495506, 0.5882269640540938, 0.5467946577255052, 0.1083592043976167, 0.10686802657337102, 0.11323059881805853, 0.10765146406328308, 0.11325354106713881, 0.11535129766276409, 0.10362606241859307, 0.10338862012648065, 0.1017470719449799, 0.10380042636658182, 0.10853115668546653, 0.09716652000047254, 0.09322876007364378, 0.11418910243543978, 0.11801814771184926, 0.08769061086467134, 0.08759773843902607, 0.1127588273407567, 0.9377179844727682, 0.9314318127149228, 0.8823153193602398, 0.9165691293025928, 0.899765919962507, 0.8954663652707634, 0.9398691509959642, 0.9542685134799542, 0.9560717243882217, 0.3590483116218298, 0.41267460393824873, 0.3521981788673072, 0.3591315979526377, 0.3739132036095588, 0.39888961370714016, 0.383593605820138, 0.41037705162101534, 0.40085654712194707, 0.7066730298660935, 0.7220205791682721, 0.6837632436751424, 0.7442862421977668, 0.7607206575730092, 0.7680595581374479, 0.7015956241307539, 0.7257846121276736, 0.7479164156302958, 0.26839739806698604, 0.33559631067597606, 0.317910967808709, 0.2183730704404897, 0.2694741090422498, 0.3037542274175239, 0.3089508308410954, 0.2673661814891597, 0.27288445565063313, 0.3367768245907591, 0.29569259915732304, 0.23514966596334685, 0.3283053619343478, 0.2631741256640604, 0.3135130097596214, 0.2792277013138966, 0.33434469951964607, 0.31266933792759066, 0.19112769596668933, 0.2665023457379665, 0.32733747581909833, 0.2957953792396718, 0.2766583366140186, 0.32779681180207143, 0.24780962137546358, 0.23091305337609014, 0.28933551216886166, 0.39740000564640476, 0.4302022540170053, 0.42443097950347064, 0.37161344756035464, 0.3287572911500506, 0.389520302432684, 0.4079272680351903, 0.3735848603315979, 0.4326913968492059, 0.11807247535674836, 0.1478160247840815, 0.14950583455927902, 0.22709163060872561, 0.1609907739795179, 0.15570314911172778, 0.11202175418833138, 0.14301982710575467, 0.09776128291090336, 0.27733517372779115, 0.23987880224889846, 0.22529043198849463, 0.26817733591274395, 0.2568073549069474, 0.27875628638767913, 0.2219931600957772, 0.2506063397497723, 0.22907017737476232, 0.6238645966981786, 0.6345505161901542, 0.6251757229696899, 0.6204249080861511, 0.6503623993045311, 0.6261093447400472, 0.5747039315755781, 0.6149152372446882, 0.6328090626814074, 0.09789764276076951, 0.1330818128180704, 0.10689199476353695, 0.10645472741189588, 0.11644357051819842, 0.09924919231547424, 0.10337493966697509, 0.10081684343159558, 0.09228224287972375, 0.15716346529773983, 0.13498468142128017, 0.14066579741708374, 0.12960556298353443, 0.24154831655001674, 0.14459473423899505, 0.1461463711417793, 0.15183956142898425, 0.16256771711957085, 0.36975421543276465, 0.3447599159601552, 0.35785190233248265, 0.31396523052475245, 0.321507291180279, 0.36341102459471863, 0.3866221023730474, 0.3503609961512346, 0.33337239337747104, 0.27185588070388167, 0.26731362848353124, 0.30829378240924743, 0.27766961958501624, 0.2740799899344304, 0.2593777712299772, 0.3016913665893094, 0.29343384737801526, 0.2979829406275748, 0.192974941372424, 0.22243559371099508, 0.21692685091933028, 0.18762539475195772, 0.2406585523561503, 0.18801647464717564, 0.19960507206937506, 0.1901344789109155, 0.23538295677078158, 0.18752452513796902, 0.1832608253629867, 0.1869483424024425, 0.21141127464455522, 0.2031329357552718, 0.1947642949770605, 0.18561561407020744, 0.2800852786448158, 0.1978899601255224, 0.7290776996300182, 0.16913140949038385, 0.1459035684321106, 0.18265202101048328, 0.16333761767543742, 0.7218027896143033, 0.1682381905786442, 0.17661165999935058, 0.6847207163724978, 0.1667805376179231, 0.6579113454992691, 0.2088762130418722, 0.6649605736793784, 0.19758947724762388, 0.6758671190376028, 0.2099468406778523, 0.20759597089094173, 0.21124030451336206, 0.19118173149024154, 0.18286521918957865, 0.19313545784219643, 0.18344981548644645, 0.20463661973559577, 0.17834381952485767, 0.21182346773526894, 0.184594855184685, 0.18344830393063472, 0.08050061621441584, 0.08199367412433967, 0.07144156064980378, 0.08865135397815649, 0.10081233740144258, 0.07754037748036391, 0.07417741258233523, 0.0748557616877672, 0.07610605860927278]}, "mutation_prompt": null}
{"id": "b0f5891e-0d25-4fb4-99e7-e836eeb0151a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "a428e371-5de2-4a8d-be51-bc82b1230d54", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "e9a8d99b-1e12-4215-a579-8b8a99863724", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "97948b56-9cbf-47cb-99ec-b07b3bb601d1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "669e2d92-1d2c-49ea-84cf-2167e8bc6779", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "cdee897c-4a09-4448-8670-65b8e344b390", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "f464e464-ba06-4ffd-ab3a-b8e6e7ad5fbd", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "7975eb54-00df-4b1a-9755-2df3da20be21", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "5ff789fa-98a1-4d93-9396-ef5b647e2efa", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                \n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Dynamic Crossover Probability\n                self.crossover_probability = 0.5 + 0.4 * (1 - np.std(self.fitness) / np.mean(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Elitist Selection\n            elite_idx = np.argsort(self.fitness)[:self.population_size // 2]\n            self.population = self.population[elite_idx]\n            self.fitness = self.fitness[elite_idx]\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Improved Enhanced Differential Evolution with dynamic crossover probability and elitist selection for enhanced convergence.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 17 is out of bounds for axis 0 with size 12').", "error": "IndexError('index 17 is out of bounds for axis 0 with size 12')", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {}, "mutation_prompt": null}
{"id": "80dc42fb-4019-47ea-bc25-d9e2696d15ca", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            # Improved Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Adjusted Reinitialization Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with improved covariance scaling and adjusted reinitialization strategy for better exploration.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8339965204895687, 0.8282834437139888, 0.800999386401248, 0.8305289533739971, 0.8090782612709414, 0.8359494962381396, 0.8150212918953833, 0.8295197371670607, 0.8335549263015668, 0.6417358314642398, 0.6545371832578306, 0.6680095782741, 0.6630665134789131, 0.6838917520551004, 0.6312998198316679, 0.6534847979567753, 0.6189777953631844, 0.695955909332778, 0.11667986814753073, 0.13515185373616312, 0.1291424266571808, 0.14178807013750938, 0.12052628038277258, 0.10781583032822928, 0.11615934913494053, 0.10477337088348082, 0.1290711941889856, 0.1920021684990546, 0.11360093871640276, 0.11478572977693058, 0.11608818601802673, 0.1227857142566916, 0.1045738375810017, 0.10763618598982161, 0.0985521324940013, 0.09517911846269633, 0.9670742405363472, 0.938231755255765, 0.8290011765975849, 0.901557456791893, 0.9333113942221808, 0.7535177227050553, 0.9093345454437783, 0.9232665414343936, 0.9524694897734968, 0.49076950665947583, 0.4418643297672471, 0.41059749496652453, 0.4717995226479418, 0.4467414082267518, 0.5484596726156454, 0.4458613658644439, 0.4813645950245815, 0.472519159090491, 0.7949563433366835, 0.8017697751689397, 0.767781367015258, 0.8464121281434341, 0.8632089737399727, 0.8142457301637359, 0.8137735361721066, 0.8077877884910989, 0.8213395450284118, 0.3189371152691465, 0.2532395724520129, 0.3019855897005266, 0.291850512698812, 0.4310939631822511, 0.4232467539148058, 0.3566602076641344, 0.30017016305318467, 0.3257478801715027, 0.27607303025706365, 0.3259308230669602, 0.33461499635856984, 0.3070518837890005, 0.23902494761133708, 0.30195201922171844, 0.2987527336363588, 0.3705069419254262, 0.2513941040825769, 0.4407196716992049, 0.33378807351402107, 0.25062729650611304, 0.31990058075831096, 0.43141649343434163, 0.3566887184937849, 0.36393819642767933, 0.38704414710974266, 0.3960904972292001, 0.5600814458660015, 0.5167464210587425, 0.4100465524155028, 0.46690904551692414, 0.2955953549235293, 0.5257388787056705, 0.5099063553303254, 0.6381752774317573, 0.524953665431279, 0.08592798970912319, 0.08812921712396271, 0.2709296274514126, 0.27885632271202854, 0.24857845953630509, 0.13921328424761725, 0.25488296167263924, 0.1960308023631525, 0.22356946477189443, 0.31362842065968444, 0.2957548196253421, 0.3152668127314965, 0.3265694637328811, 0.3302390279324543, 0.32194430834847876, 0.29661129796744745, 0.32080357204856513, 0.30317379433477354, 0.6979449139890954, 0.7067141623125899, 0.624703376256661, 0.6892677621243657, 0.6464766942879203, 0.7115473279892957, 0.681640916510575, 0.7388895795094546, 0.7076641963389132, 0.09875493377685363, 0.0942385795656272, 0.11464373735083244, 0.0943917841801224, 0.10845989323304583, 0.10624399924893135, 0.09055099242406073, 0.11058412721676358, 0.10417323051085114, 0.14424758168476215, 0.13725851704963965, 0.16138379455494356, 0.1385935146629519, 0.1520300416171414, 0.2209812447665649, 0.1302323051352421, 0.16175829719070878, 0.19298085391398467, 0.39962815945848784, 0.393259152917002, 0.3610775332969234, 0.41563112672439895, 0.398130433896402, 0.4049969156095822, 0.4074514264866488, 0.41370658529609006, 0.36618755834353955, 0.29805465345897275, 0.3148201614125852, 0.31973282707785344, 0.28478550932362234, 0.2978208511808813, 0.3236421499966108, 0.3300854670485712, 0.325874416550616, 0.32800982355565644, 0.19374851111410685, 0.20558402312917157, 0.2110946772996255, 0.20440095348489162, 0.2040501292433684, 0.21981004345178934, 0.2158182610666738, 0.20072370847071752, 0.17766298117916446, 0.20264957257479033, 0.19109197445233983, 0.1927479856114478, 0.2302110783977751, 0.186468401467219, 0.18149974727844365, 0.18503296191440088, 0.1895470670606284, 0.19955898874175693, 0.17637801237042516, 0.8426548622364312, 0.15074255191033625, 0.7444366567602345, 0.19489369906062093, 0.7287238644512584, 0.6682581934281884, 0.8048451500550295, 0.7552063350375218, 0.8015941468002692, 0.1684089212590416, 0.6486582317245362, 0.7222610407831552, 0.6600823553638762, 0.7619303266489098, 0.21205562115630305, 0.7472504297225278, 0.15350919423092457, 0.1814807717293062, 0.17887794474330587, 0.17638526376575359, 0.17815817929567224, 0.1845672976692222, 0.19826400786711296, 0.1746376289040178, 0.22094836024473208, 0.19482906666810385, 0.08239842101662453, 0.08096987387836174, 0.08369545026822034, 0.08289241115929802, 0.08285320002268459, 0.08702790772574898, 0.0818168131822744, 0.08517562348890662, 0.07785978489589374]}, "mutation_prompt": null}
{"id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 57, "fitness": 0.40525845794348997, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "b3175cbc-96ec-4c3c-ba1e-4c777956ddaa", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "de2021fb-2e19-4b78-beee-374322287553", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "151dc749-98c4-4371-946c-388c24c77c26", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                diversity = np.std(self.population, axis=0).mean()\n                self.mutation_factor = 0.5 + 0.3 * (1 - (self.evaluations / self.budget) * diversity)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            if np.std(self.fitness) < 1e-3 and self.evaluations < self.budget * 0.5:  # Early convergence detection\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n            else:\n                for _ in range(self.population_size):\n                    if self.evaluations >= self.budget:\n                        break\n                    local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.evaluations += 1\n                    if local_fitness < self.fitness[best_idx]:\n                        self.population[best_idx] = local_solution\n                        self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration with adaptive mutation factor based on diversity and early convergence detection for rediversification.", "configspace": "", "generation": 59, "fitness": 0.32099593357632855, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.21.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.49029880069135723, 0.5226003794715075, 0.4834943396804663, 0.5330144303952542, 0.5643463460005257, 0.528064376974528, 0.509168743560608, 0.5417580291599959, 0.536094708408094, 0.39654940023617624, 0.4486074808214068, 0.4492630353666327, 0.413422486497792, 0.4012113581036366, 0.40962023917137813, 0.44699745288687687, 0.4301656635680531, 0.44641303971634594, 0.12490820571268468, 0.10253469860764763, 0.0981915832016208, 0.09518175654918726, 0.1185232484524873, 0.09328942842407939, 0.1117352110276153, 0.09855562606968038, 0.09892919736848815, 0.09090634132476039, 0.0928887019820448, 0.09196626950922304, 0.09125486134160887, 0.09274375849168204, 0.10106294391572423, 0.09890084454926995, 0.0728456503000543, 0.08757878536059582, 0.9311647948815789, 0.9434270114457638, 0.9603967572517147, 0.7628078736254627, 0.9619580412612754, 0.9132054521833382, 0.8529783959889936, 0.9964070106210905, 0.9825089436532689, 0.3477725874266606, 0.36065801689099, 0.31393487405463105, 0.35153396651780544, 0.2903750417568842, 0.3265850320638838, 0.3324205623331079, 0.3339178962046443, 0.3496943880004254, 0.7666551360346373, 0.6896691359411814, 0.7274608034541314, 0.8188120510295501, 0.7342091265961515, 0.7262586773213353, 0.7452249387947869, 0.7131239476291189, 0.706284970154196, 0.20657877139503067, 0.30199460158900415, 0.300171750007574, 0.24255277974304534, 0.32676276311690555, 0.24062255475438388, 0.27627431302439687, 0.28748206359344963, 0.31207326207337815, 0.12459161453946199, 0.2137715816982797, 0.39005328777340464, 0.24238502776004223, 0.32308147539823295, 0.24261480633800137, 0.35792078658759996, 0.31130333843188995, 0.2829009859607501, 0.28078362930051637, 0.23830753186634834, 0.24131209354827687, 0.3008927674457159, 0.3141179289660697, 0.34172664440126765, 0.3296130138410357, 0.31653856224812726, 0.3114502529535168, 0.46910059058319, 0.4001517565259731, 0.44077389722965776, 0.44969193253601125, 0.4534334387563804, 0.430352209405108, 0.44616129067183374, 0.40883575641187275, 0.46665958093988325, 0.1348245137948999, 0.11704757144414502, 0.17775960902612153, 0.12328168890940994, 0.1956673944115429, 0.046894686323312285, 0.14157736083725014, 0.15098384513176988, 0.08975861210080094, 0.274546417308263, 0.2565819771375132, 0.2515423091732366, 0.24937332789677835, 0.25384143439440054, 0.2641073958245853, 0.27844900165010933, 0.2710355272599182, 0.2709608485245373, 0.4848317953757957, 0.4622562121060363, 0.4670972523896847, 0.4659507907683812, 0.48071046312172894, 0.5158390828799646, 0.5008548315297054, 0.4517192271581637, 0.4716562786995152, 0.12249150008387155, 0.0895941151813644, 0.1021790658115499, 0.09268189020562134, 0.09165692227741729, 0.0902278228200144, 0.10796884353653968, 0.11554784300975263, 0.09426996396875709, 0.17551075354955392, 0.1780644637516614, 0.1861769007428764, 0.17960219905674113, 0.14667526763673833, 0.16952448447982316, 0.15349767771207934, 0.2716847035354787, 0.1832680362699871, 0.3314838539938191, 0.3398372045350999, 0.31232845411490284, 0.31370614228610716, 0.3267507252149705, 0.33098822865831246, 0.3367287035681604, 0.3221241852540696, 0.3051928244307951, 0.26833604289995205, 0.26106356483505655, 0.2566163917647859, 0.2503967330781266, 0.2736654110971579, 0.3073446929178274, 0.287569280962241, 0.2949319488112684, 0.24557074905511933, 0.20745824315984351, 0.20470675275423444, 0.18970508048226153, 0.20544694271937425, 0.19287599139932476, 0.19720672174183773, 0.20342028820520486, 0.1830994908094643, 0.18220534487055096, 0.18496667979404102, 0.18167551075388055, 0.18840781750096613, 0.21591167130915123, 0.20199449607083897, 0.1896712604346973, 0.18050588714470195, 0.19577819411995057, 0.1758099424818509, 0.6622136527914406, 0.4754355595610843, 0.7328918063665897, 0.5424259444781632, 0.6121701480035098, 0.5503668843764354, 0.17597003695119418, 0.16868298703778806, 0.6227293062591974, 0.1909773005981097, 0.5809323322849038, 0.5629175703928105, 0.2033496894916288, 0.6089907464059163, 0.20090498547770896, 0.20497516078935007, 0.48339724280818797, 0.20265810083332936, 0.1815595192777515, 0.18927162917620632, 0.18941435415693286, 0.18476336724845854, 0.1794186363467386, 0.19684070373304197, 0.2094617134325939, 0.19615364398078494, 0.17947506950599468, 0.08483049404145382, 0.07198192163406769, 0.07139829228281092, 0.07137769144121209, 0.09158880162619354, 0.08433782421070724, 0.08666417444484653, 0.08234224975940418, 0.0814272518117507]}, "mutation_prompt": null}
{"id": "515117cd-1b1b-4f71-8109-db6be6fd69d5", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                \n                # Rotation-Based Mutation\n                rotation_matrix = np.eye(self.dim)\n                angle = np.pi * (self.evaluations / self.budget)\n                rotation_matrix[0, 0] = rotation_matrix[1, 1] = np.cos(angle)\n                rotation_matrix[0, 1] = -np.sin(angle)\n                rotation_matrix[1, 0] = np.sin(angle)\n                local_solution = np.dot(rotation_matrix, local_solution)\n                \n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance local search with rotation-based mutation to improve convergence diversity.", "configspace": "", "generation": 60, "fitness": 0.3367154713260049, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8132338467487431, 0.7106771708698338, 0.8076569751025401, 0.8064141816823911, 0.6681077284054211, 0.8226690905101188, 0.7504209379958895, 0.5746535834607716, 0.39669232142959476, 0.6922028079973992, 0.6789434257635574, 0.6684929106074156, 0.6540545235613895, 0.6627693730333624, 0.672038461729623, 0.2648813881263933, 0.6490597467628687, 0.5592454146922885, 0.1289706536818197, 0.10469769710863397, 0.11224197823346971, 0.16219146805575824, 0.13720042722820325, 0.10838610525638814, 0.11132281852721682, 0.1117466936084045, 0.09924011773968144, 0.09213008765062036, 0.09908536334409823, 0.05442653916725704, 0.09606407068699752, 0.10655507136096598, 0.086690694533748, 0.12666457206975223, 0.10371589913675072, 0.09574076974486145, 0.4747370532029521, 0.8784256539662841, 0.41472389680950517, 0.43153276101592897, 0.25916016154894916, 0.4773035941883458, 0.15860599720740498, 0.9537134648085426, 0.9265742657216856, 0.26003915104965347, 0.06877617798444113, 0.3100740995199459, 0.16309404123377336, 0.26078651406005715, 0.4873386772420787, 0.20682522908651502, 0.45252772376782957, 0.18271189132968357, 0.866359767009687, 0.34393262756914733, 0.8685568509533922, 0.28114710469003, 0.8410995600987727, 0.7532068574044786, 0.8417589100249244, 0.8413295313001229, 0.3815161154834995, 0.1658762865824558, 0.17357251237930815, 0.14990014529818219, 0.15595959392797298, 0.15610663375904954, 0.15687507957759295, 0.13324305078898668, 0.1272022609896114, 0.15351406252335398, 0.16836912432535422, 0.1535251554644479, 0.1765471390122193, 0.17703765798701665, 0.14070424274480087, 0.21170684984660848, 0.23605472760648416, 0.1736877782206233, 0.2948748200867748, 0.09398450406941117, 0.535463138803285, 0.24191680869645882, 0.4410654682560389, 0.10959992937981655, 0.5894272436680921, 0.2627477479027567, 0.5422250768543811, 0.524573982341906, 0.7070696352200958, 0.6603152743384118, 0.20233012158385677, 0.1967233095407569, 0.4033432118420959, 0.2105251178809634, 0.23171227359890711, 0.670252418806238, 0.7543145698564588, 0.15551707306194873, 0.08800227153566798, 0.2019858365467856, 0.30333559822969625, 0.30535100392805903, 0.3011813127194072, 0.23406058042433753, 0.323280290341028, 0.13422823540936002, 0.3510637926134954, 0.39443082288611797, 0.4778053783428151, 0.0909503052573013, 0.1940188671173393, 0.4400275322597399, 0.4524096348667187, 0.4149006188551888, 0.4465483762217778, 0.8072932528319787, 0.6205830919057682, 0.8210247263194959, 0.5053986807982976, 0.8147661497619088, 0.6396373659276193, 0.7595743045132378, 0.7875481642980869, 0.7828187845445044, 0.09893423188529415, 0.11013796136064191, 0.09190896774903135, 0.10876075769354343, 0.10418796378165918, 0.11719922519856918, 0.09921573811088269, 0.10536284061285639, 0.15390989319441306, 0.14636421348302642, 0.14425018114873656, 0.14546466790773116, 0.21701610898669366, 0.22842780319929634, 0.18817800359185777, 0.150102897669672, 0.12340870538092108, 0.2903972996965455, 0.4528813426647246, 0.3593751307926949, 0.431922511946773, 0.3581063655187119, 0.3988917907417162, 0.34463026574554256, 0.4041112651021618, 0.4234746022212057, 0.38048036710206357, 0.26424762424927006, 0.32565486797443377, 0.3407214807765867, 0.2860968464939816, 0.4230321724441749, 0.35464179391614437, 0.3678294055478184, 0.40248497964676566, 0.4212223956449833, 0.19475455902607441, 0.2210295158457246, 0.190918383334435, 0.18731517011622034, 0.19443066409260668, 0.22752163599433572, 0.23857899507587432, 0.19385539330011547, 0.20971751828132523, 0.18459169603895642, 0.19439709553005824, 0.1983510979093438, 0.18234862471527935, 0.17776084505017775, 0.2001031234741718, 0.2033144278304716, 0.24829360445522586, 0.2069922308782315, 0.877457559859555, 0.3914339887021079, 0.18517056933732678, 0.6618845989029949, 0.20032993053691095, 0.19296885977406641, 0.8059982882677845, 0.16737451308545426, 0.7456613647971744, 0.8237170191048684, 0.5928311553348091, 0.20414839127947038, 0.20587487535009485, 0.4037797484992196, 0.8554208015367625, 0.2127661258782727, 0.13869705219016937, 0.15540302219481406, 0.17253447411001832, 0.20720633923513576, 0.17720452251325647, 0.1807426674648135, 0.18012121375062762, 0.17923319555310735, 0.1844219381886928, 0.1857747687000184, 0.1850723164529452, 0.08657732415915942, 0.08446922288278769, 0.08522974806809802, 0.08110309049909536, 0.08350311311060121, 0.07430905154981915, 0.07995460203479121, 0.07276626787438778, 0.08686123633778042]}, "mutation_prompt": null}
{"id": "7ba0012b-4b57-410f-9b80-3ad3ab5729e0", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            cov_scaling = 1 + (self.evaluations / self.budget) * np.std(self.fitness)  # Dynamic Covariance Scaling\n            covariance_matrix = np.cov(self.population, rowvar=False) * cov_scaling + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance local search efficiency by dynamically adjusting covariance scaling based on population convergence, while maintaining the rest of the strategy.", "configspace": "", "generation": 61, "fitness": 0.3987269009899976, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8411190151181466, 0.7950574817731721, 0.8439907931285953, 0.7666312003474953, 0.8584974762426615, 0.8189789517559865, 0.8308887456455676, 0.8356934895525276, 0.8145087529888398, 0.6680079709709923, 0.4053908705529913, 0.6452314345035949, 0.6725374695515989, 0.30137401958754484, 0.6807372459847745, 0.6531383124345782, 0.6401540636920803, 0.5845506644298559, 0.11553666880970559, 0.1031603554990439, 0.12223680661093439, 0.11651647655945385, 0.11604988509309988, 0.09958688689720618, 0.10032963986597954, 0.10643487006024643, 0.1440105568759663, 0.08792711606725645, 0.09469321968986155, 0.09236211017699447, 0.10032649607433974, 0.0969424902650513, 0.11337350198740392, 0.10774860845236978, 0.11054395480890711, 0.08788154212957466, 0.7379384187735775, 0.9524946286200645, 0.8348654511501035, 0.6655271333119592, 0.27806532515399185, 0.23631243272227886, 0.8509410000941618, 0.9572088051222254, 0.8272091720626505, 0.3042809531765154, 0.2451214910531957, 0.46647757321244887, 0.5331206559552368, 0.34458637373343814, 0.4980108647826065, 0.465939935750767, 0.24981252876964477, 0.4682438129896256, 0.8832947242540973, 0.8780116656032182, 0.8722323498060423, 0.8679969164111914, 0.8791370446808825, 0.8944902487144203, 0.8424397293016905, 0.6179232023676398, 0.8286599810811621, 0.4082321726683633, 0.12725398150218603, 0.3941524901524476, 0.532701533207522, 0.12934769362018383, 0.12746682447977675, 0.662892833606374, 0.16512243691513373, 0.37893318286919864, 0.2815413677643811, 0.3020617981663538, 0.3496166749648216, 0.5575339026010303, 0.32373155183998037, 0.612401754079556, 0.4769528290677415, 0.26781516455082044, 0.26750649542337823, 0.35250333502765996, 0.5498259904128575, 0.5025611244383563, 0.5846445056275025, 0.45801700767484277, 0.5675933527894059, 0.5577912443144173, 0.5357161950135536, 0.5999921817565799, 0.6672959797787743, 0.6989966872584779, 0.6952948042734994, 0.5955877595621522, 0.6122932238947942, 0.6346077372170316, 0.5086320920509522, 0.701664229070514, 0.5777079064891195, 0.15431653180888238, 0.08023125649178187, 0.10459860346397487, 0.2263760972861001, 0.4179975016989247, 0.34262102249155657, 0.22893763146794477, 0.09237763586260495, 0.10167950614357091, 0.47212431402904764, 0.4246438822395904, 0.2530711268683885, 0.4251808440198327, 0.3062674516593029, 0.33390560471433883, 0.4992963514879216, 0.4705588904460939, 0.2788959749925797, 0.6175153236951036, 0.7844106093481094, 0.5124960602427925, 0.8189339225112013, 0.801183446384221, 0.7526384174183544, 0.8004753057445112, 0.7242955360898825, 0.8056027425322253, 0.10915086392329343, 0.1204545802341741, 0.11320082471505233, 0.09461760836022493, 0.10072849716461463, 0.12862137394662954, 0.11067929676076604, 0.11088207586530352, 0.12541205126524269, 0.22950637448877143, 0.1293475297137593, 0.20636145887216462, 0.16069754204470932, 0.2274591536123125, 0.1407564972787071, 0.2000398119343083, 0.2590382202652921, 0.19662939139262736, 0.43294951917981317, 0.4469031530278027, 0.4204612254588658, 0.4604917983966559, 0.43165611475204246, 0.4204638752173133, 0.436489587913073, 0.46267696731212016, 0.4409194929316642, 0.36916506924021264, 0.3626248068248977, 0.36974831901390903, 0.3746331393050064, 0.30339126298748453, 0.35849213411608094, 0.40965645824947783, 0.4163652229983773, 0.3904461824776946, 0.19494420666015533, 0.2514064391570854, 0.1850435932512432, 0.23283185339976242, 0.2035916929469136, 0.20274218323043947, 0.22147830164344162, 0.21369015184705664, 0.19135983108594368, 0.19819013296949362, 0.3102566538132422, 0.1745960216428606, 0.2188225800850392, 0.21425252956533392, 0.2005828149656833, 0.1956606719236793, 0.18625164533680016, 0.20170509958775196, 0.8900369935179687, 0.18520974422308722, 0.18358255846428717, 0.8553635615842691, 0.20490408390002635, 0.7981184098478196, 0.7898485403483522, 0.7044074838077454, 0.8436018133091622, 0.8972748617000929, 0.15375546910019655, 0.7850538206712876, 0.7274313932791048, 0.2110672120208421, 0.15795835020291893, 0.21315145068074526, 0.14843505050595873, 0.41286028429312815, 0.19751952216686852, 0.18443574098492488, 0.17329471229775428, 0.18955563039565493, 0.18670473892377715, 0.19022976044321793, 0.17045084973317826, 0.19538431675508627, 0.18675092313156227, 0.07937039504739551, 0.13048609883726492, 0.07916758413164171, 0.08222459716934338, 0.07048886617197347, 0.07976645861876364, 0.07722799677172787, 0.08967092944474298, 0.08258332889742181]}, "mutation_prompt": null}
{"id": "06aab868-6406-4389-b6dc-d1089179dadc", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "408b6ecd-800c-47d5-a987-f3515b15eea2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.4 * np.abs(np.sin(np.pi * (self.evaluations / self.budget)))  # Adaptive mutation scaling\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                reinitialize_fraction = int(self.population_size * 0.2)  # Reinitialize 20% of the population\n                for i in range(reinitialize_fraction):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance convergence by introducing adaptive mutation scaling and reinitializing a fraction of the population based on stagnation.", "configspace": "", "generation": 63, "fitness": 0.3704484054131556, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.7072528886794412, 0.7647166265180569, 0.7698330231955829, 0.6860212164544615, 0.7216908619043543, 0.7666186460666291, 0.7395674454992403, 0.763497312592551, 0.7085640122267084, 0.42608963669642796, 0.4713590846478205, 0.46995533432871817, 0.38636741226783144, 0.47609225727620275, 0.4288091816882871, 0.515503835597666, 0.5090138029329583, 0.44207419249574764, 0.1025076188186338, 0.10404859362648933, 0.10715668293466718, 0.10688724303393993, 0.1420083396163514, 0.13457537881787363, 0.1351334781972453, 0.109706643182094, 0.0913820497392629, 0.09459443869276696, 0.103668850250345, 0.10563927380616556, 0.09909902449909458, 0.09858965835943423, 0.11732766869214206, 0.08478106373228678, 0.08425840086330139, 0.095652476119239, 0.9013432864159627, 0.8036818463419997, 0.9535983089135512, 0.9299768036683482, 0.7567488845006223, 0.7701347923971831, 0.9119106330116524, 0.968724477228986, 0.9487882160477804, 0.39829598669588495, 0.3355273526431075, 0.36963245701168423, 0.35386902872212256, 0.3788942528911291, 0.3732643286572598, 0.41836411267218154, 0.41853953094002105, 0.403628650949742, 0.8524120995918114, 0.7925443020352554, 0.6870090717760133, 0.8188822169224301, 0.8328387729479646, 0.8538730405431352, 0.7889110392278584, 0.826336066984608, 0.7962650764463193, 0.3613102858446998, 0.30941831013637233, 0.2848977301432817, 0.3231772695044882, 0.3373486134173438, 0.4178891379482932, 0.4225301517108001, 0.4332460145684005, 0.4308255397208859, 0.3701406599076599, 0.4463526940665291, 0.36066093361867413, 0.4206086697834971, 0.29036353534182835, 0.12925472567372176, 0.36593256432509813, 0.32851009140767695, 0.34475505403619466, 0.27882335580981454, 0.3196392210869927, 0.26408774758491294, 0.33388835374076153, 0.3541817140531741, 0.31591724128721355, 0.3534741555591907, 0.39052061439589014, 0.3617748497204326, 0.5796477450448732, 0.50024231125002, 0.4834079367995999, 0.44450596549191035, 0.3615824794920166, 0.49741467636805725, 0.5471187296127831, 0.4583726549152215, 0.46227212530554884, 0.09059183881702515, 0.182881572530041, 0.09938859127831368, 0.21355994010596546, 0.15158230094680913, 0.07011355680903031, 0.12401155689275745, 0.13694971349215523, 0.15065911407254062, 0.3076117794018731, 0.2514918965772146, 0.30243692678473233, 0.32868987490079504, 0.27881813362526886, 0.30991868227908514, 0.313183363777387, 0.33312408173246777, 0.3211205960753013, 0.6606838514096172, 0.6848104577625158, 0.6689388558688271, 0.679102453744426, 0.7043501207943503, 0.7134511582334444, 0.6395477653622434, 0.6857388662094215, 0.6881519596988686, 0.10551032627879631, 0.13133690910931695, 0.1307937515603559, 0.14756971867091073, 0.09606090096518671, 0.11409776950441697, 0.11740711966684825, 0.11333601709654473, 0.10926102701445284, 0.2184805291330928, 0.1823005839999371, 0.146748554784786, 0.22264180888483875, 0.1791104213125656, 0.14545152668791683, 0.16327664540316222, 0.15083362488699492, 0.15813616759482063, 0.34575906321274086, 0.37201151603982097, 0.3297205265623461, 0.36744353910817185, 0.35325814449886195, 0.36619727186843753, 0.3599965634394193, 0.3499396234299167, 0.3675791986999851, 0.28763558865669414, 0.28556649846844817, 0.2701057278754896, 0.2668018950274754, 0.3189152833456673, 0.31004834617595356, 0.2719755039765155, 0.28936944132832754, 0.2927830619808065, 0.2086019007287485, 0.19529205410712103, 0.20504645648541264, 0.1891441239771593, 0.19473993051134553, 0.19835951818844988, 0.1985993577492644, 0.20970883233558157, 0.19173285001761553, 0.19690091277583388, 0.18437890081024322, 0.22619041672056173, 0.230092368965919, 0.2014229993152633, 0.21168496016894955, 0.2006685949607564, 0.1871588075973838, 0.25969044806525354, 0.8440373417995216, 0.7319263558516795, 0.1860359881193877, 0.7107295566373575, 0.6641066386643952, 0.6543637681813432, 0.8070951359236662, 0.8184967582959062, 0.7752913328805472, 0.8702291291879973, 0.2037569127476263, 0.20830498500582484, 0.19948522763707754, 0.2092074140672674, 0.7485093017100315, 0.21287905601755108, 0.6169195390787736, 0.7626898308655378, 0.1889415379297419, 0.17644522989175437, 0.18347613223971826, 0.20050183270303568, 0.201086087838537, 0.18724556323648756, 0.2165016863062892, 0.27150890861423527, 0.2140234509714133, 0.07946877345398229, 0.0958510321923457, 0.07572511019952022, 0.07331206807587864, 0.07321859042340206, 0.08310965188304165, 0.09210126259441276, 0.08469389278261019, 0.07966569741185503]}, "mutation_prompt": null}
{"id": "33afc15b-7746-4c05-a5ec-d504695794f2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.6 + 0.4 * np.sin(np.pi * self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                reset_flag = np.random.rand() < 0.1\n                if reset_flag:\n                    self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                else:\n                    for i in range(self.population_size):\n                        self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                for i in range(self.population_size):\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Improve algorithm performance by enhancing mutation diversity through time-varying factor adjustments and occasional global resets.", "configspace": "", "generation": 64, "fitness": 0.31812928034344734, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.6039556413690695, 0.5977711568734926, 0.6019303835776518, 0.6398633845607956, 0.6939163341804191, 0.6871441748639877, 0.6897874784801261, 0.6062113746993203, 0.6114992577248003, 0.3252397748692748, 0.2992097607019688, 0.3091631394379186, 0.30445576020388987, 0.3290484477959046, 0.3725178476214288, 0.3608574248244911, 0.30557293036150013, 0.32984953103447057, 0.11589906448513265, 0.18225753722493587, 0.14043596256984414, 0.11612026398207598, 0.10061934840359299, 0.1463493211698309, 0.10625548728793344, 0.12037378685787992, 0.13169638335178058, 0.0930518640696637, 0.11348485014027976, 0.1061142094166847, 0.09755030708508039, 0.09918293244625764, 0.11278790476875966, 0.10506311114404254, 0.09001693369105346, 0.08032139227303436, 0.8672712087922666, 0.9700076670448291, 0.9349858027610483, 0.7365158814555524, 0.8246821577258969, 0.6656439451054362, 0.8745087550806696, 0.9709921059295039, 0.9775641920113158, 0.3117885363368169, 0.30184256473623927, 0.2711448617092198, 0.3660405030878675, 0.2939731877740146, 0.34451115979436586, 0.31730573056223377, 0.3081226026803764, 0.3138430292713944, 0.6702606373769688, 0.7136077783674657, 0.7591967736828023, 0.7085210030953124, 0.7116194791145591, 0.792845232797579, 0.694275599457166, 0.7162447400054796, 0.7340602702488046, 0.3134827619049776, 0.33738143224923034, 0.21565878867018407, 0.25453599549669115, 0.2538012230768283, 0.1254963977873298, 0.25557723220627593, 0.26635014751874564, 0.28464988032492133, 0.29618811374755494, 0.3033719400634515, 0.3339989934353089, 0.265922058000869, 0.2588710085080279, 0.2726534991155325, 0.2659179360723035, 0.20777343008554472, 0.2389776419217836, 0.153437091001575, 0.1598713020446092, 0.22679178557385649, 0.2586112233660137, 0.19102148782931028, 0.18035787180913687, 0.20333253107048943, 0.23758225403253697, 0.2250903145216293, 0.3374254573642731, 0.3828814600207018, 0.34488600194926566, 0.31097654711251554, 0.351575540864835, 0.3072344596407266, 0.3609234935280585, 0.2781837362975397, 0.3514228014699534, 0.03358728399631894, 0.030425539750604358, 0.06634338844088994, 0.03712630987544219, 0.08689219972978768, 0.06382537924798781, 0.03492531501865592, 0.07910653096305209, 0.13316076934191312, 0.23800109327798868, 0.22840395517274614, 0.23735577563499166, 0.2179931275257373, 0.2104748755938134, 0.23383956561085784, 0.2245638271529108, 0.25051669685288136, 0.24660768198733485, 0.5724765334640225, 0.5031102447090977, 0.5383546589570228, 0.5339632352747352, 0.5269318752958452, 0.5614702436290482, 0.5377986495785042, 0.5098211241483477, 0.5173901581039352, 0.1186364413813461, 0.12539966462018814, 0.11548795444961268, 0.11701003644769803, 0.10945092772475196, 0.10589646186498558, 0.11092954542079458, 0.09719813047178105, 0.10310378413826204, 0.14871770093088654, 0.1929039667085497, 0.2299390286059083, 0.2724698745039278, 0.17244756979972586, 0.14126309374374724, 0.14417927124791718, 0.2593843055256221, 0.29519989524055745, 0.31104472056582044, 0.3145331519040273, 0.3391275598216037, 0.337636034619754, 0.3332620708865599, 0.3227009481261015, 0.3112586184482776, 0.3389409294382888, 0.32399999859624895, 0.2562022782976532, 0.24539155067146723, 0.2644466142665217, 0.22419355201182933, 0.24734661083756282, 0.24002348128404138, 0.23827338220193583, 0.29791845214439483, 0.23677080132408623, 0.19650748353886693, 0.20223145790520858, 0.1941087634436789, 0.22803732560754186, 0.21747239713982136, 0.18880499830768127, 0.19598489288928078, 0.18907930061392675, 0.21010402556856778, 0.20971110432829843, 0.20609409058223926, 0.19051226778634545, 0.2125373692697331, 0.1856034958424747, 0.17777045655128754, 0.182683369331324, 0.18637867692508503, 0.19055209266699868, 0.7012258010877297, 0.17986754354171153, 0.6552861687216204, 0.6849401020654708, 0.17858645990826894, 0.4427083766649059, 0.6120357602279931, 0.7812409252858361, 0.676207853290272, 0.7373036985119512, 0.6646959060682935, 0.20617589999119668, 0.699378886402199, 0.19846428360443635, 0.7399574586808464, 0.5870661320076855, 0.20463173756433528, 0.6769793973248881, 0.18961624870464056, 0.19891211484464477, 0.19038485592386667, 0.1849339167921925, 0.17833000225941686, 0.18306662518215944, 0.23406348660905396, 0.20781870625993892, 0.22847143586612229, 0.07378557497333982, 0.08778130888556857, 0.08320832077360252, 0.08218584663278339, 0.07913859307923499, 0.08563376938325618, 0.09181870618625432, 0.07390742472991207, 0.08562350200757829]}, "mutation_prompt": null}
{"id": "653d6efd-48fa-4b39-983e-e030d6a267ac", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Fitness-based scaling factor for mutation\n                self.mutation_factor = 0.5 + 0.3 * (1 - self.fitness[i] / max(self.fitness))\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Enhanced focused diversification strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound) * (1 - self.evaluations / self.budget)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a fitness-based scaling factor for mutation and enhance focused diversification by incorporating a dynamic radius adjustment based on evaluations.", "configspace": "", "generation": 65, "fitness": 0.35372545416985934, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.7433920034185053, 0.7455896222789244, 0.7893546425855634, 0.722644428377021, 0.8512649178063851, 0.8377257392293791, 0.6631414938986833, 0.7688969491246107, 0.7138324262658765, 0.3593636441014558, 0.4506993766557331, 0.663882371979494, 0.6728283653154645, 0.22146962880689203, 0.3997882484749311, 0.5225358314653502, 0.3749172120103548, 0.37931055811078396, 0.11006887130779253, 0.12023736409505514, 0.11701419842211869, 0.13463069922511772, 0.4226909944013252, 0.12317886182185267, 0.11913167981394235, 0.14091870427810604, 0.1326105876431084, 0.1115120184810019, 0.11488539673024711, 0.09880698864622117, 0.10892478527251481, 0.12391834965307824, 0.11969692064348181, 0.09570758594291984, 0.10207412291521811, 0.11013708591450411, 0.9731925323576299, 0.9449662055684366, 0.948070055208232, 0.1408811864139956, 0.13698489886247012, 0.3271996733669995, 0.8017202158247783, 0.8269673749299937, 0.8842544947708976, 0.39556512347075545, 0.421194009174117, 0.13537385510111033, 0.22376668944386424, 0.49084426933063785, 0.34355562565784037, 0.34856110342882274, 0.3777259337285822, 0.2325845212950669, 0.8315206000541727, 0.8451135920811151, 0.8693725585322082, 0.8590159892682332, 0.8403536322352055, 0.47460244506571114, 0.8361587435899477, 0.8359663530818662, 0.8254313041292827, 0.199351389665945, 0.2622230357226556, 0.32536340214210313, 0.1848756283100932, 0.18962183106145458, 0.13001542835500934, 0.23988437540571672, 0.17802634384186478, 0.31878222649587173, 0.2841416433605115, 0.16705925478837835, 0.15963821438085413, 0.21840489705037824, 0.188757391977302, 0.16605852146329214, 0.4850424280765989, 0.28800696798929537, 0.22135744690062154, 0.2737603619190502, 0.2745600745712642, 0.45546600151371186, 0.45141488321296486, 0.519997005603514, 0.19290876820569425, 0.24793219964509905, 0.2113516456178649, 0.2479426506939476, 0.4550289461995428, 0.5261562242821991, 0.4390220009658027, 0.5421836938953609, 0.40174151914068346, 0.16145145496612112, 0.6218466383858017, 0.29924913845294965, 0.4632349722595327, 0.08991702120151435, 0.12917341919789127, 0.1214172363120386, 0.1000666835991949, 0.15505628716267728, 0.21499928903589438, 0.21088715244527834, 0.17885238980178497, 0.1780491264997488, 0.38340075953886066, 0.30446656987240484, 0.26865067907542606, 0.40650321048866445, 0.5232131895006913, 0.3473876104559085, 0.22524343950026848, 0.3207674105372532, 0.23366748763795286, 0.48735853481325964, 0.564839150873439, 0.6751624429710564, 0.6250663738621387, 0.42114737271809144, 0.5852113026502568, 0.6253443347994138, 0.7002185172346677, 0.8149704220984865, 0.13044568458964367, 0.12601926479789638, 0.1179205312397884, 0.10770421212929338, 0.1171030739764658, 0.11650747981414589, 0.13064454951836546, 0.12376919456721847, 0.14837887000212158, 0.18795927995695905, 0.2913448929445618, 0.1586659020229274, 0.18171776966599817, 0.22433202205959257, 0.16545840766443576, 0.18130020917013978, 0.23944172694954546, 0.1657466506731906, 0.37556180119667926, 0.5171613690893553, 0.3172195920376022, 0.49552671453164343, 0.44325093044438657, 0.4461060833147068, 0.3826858071265963, 0.4758436598920752, 0.4923035022134361, 0.44170527684935923, 0.4184442774543472, 0.27885452092993424, 0.3491846053360146, 0.3573695679252792, 0.3581921720724158, 0.2127917307487649, 0.2777248517165781, 0.5057938240260489, 0.20546917690264688, 0.20693037461894714, 0.21767463767868844, 0.2139973036746422, 0.18877667633073847, 0.21576749405758056, 0.20716988832807914, 0.19090533060897907, 0.20724319976866978, 0.21903133130253338, 0.19361188162167287, 0.18617554153793925, 0.18085156412629066, 0.19089565308251466, 0.20325373458107487, 0.21609303486300435, 0.2094964658558508, 0.20748455626805307, 0.5397163504596252, 0.1828809744953609, 0.8439934670005291, 0.8384830771495988, 0.7023323643406352, 0.7862417084890593, 0.8316170641712959, 0.6421809575063493, 0.6613717134468708, 0.7595773146227426, 0.39054554667801855, 0.5815126102270801, 0.20278804363645841, 0.20981799717037297, 0.8271603252435075, 0.21038715324667046, 0.20455441337512903, 0.4594510220601915, 0.18644470067143715, 0.19074751376670163, 0.18586313671645882, 0.17297146334851754, 0.19898809325411881, 0.20511510067874228, 0.18982300072534852, 0.17723334882098385, 0.17431076244023336, 0.08544409103260953, 0.0899897524515374, 0.0857099421612958, 0.08093623149259965, 0.08470481809750541, 0.08975267082011706, 0.08303548268222549, 0.09596639984521083, 0.09141995302076122]}, "mutation_prompt": null}
{"id": "60594b81-cd2a-4f50-97b4-af7041f23d88", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "8c2b0203-7d29-4423-b254-07ed323e4457", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "cd0b21da-1dad-4020-ad02-5d0f7fcfc172", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "f1637a3e-1d58-4480-9c5a-11a60b484a64", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            dynamic_scaling = 1 + 0.5 * (self.evaluations / self.budget)  # Dynamic scaling factor\n            covariance_matrix = np.cov(self.population, rowvar=False) * dynamic_scaling + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a dynamic scaling factor for covariance matrix adaptation to improve local exploitation.", "configspace": "", "generation": 69, "fitness": 0.39147018175496945, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8122078589530226, 0.534624145061455, 0.8254953228512336, 0.7941340442017109, 0.8445596935865292, 0.6692554067681435, 0.8522638131364837, 0.8381708631773452, 0.8249263322960513, 0.6908393208740843, 0.6481978097120253, 0.6162446824308351, 0.7043082823403488, 0.649752292231869, 0.4607190033861134, 0.693387801862728, 0.31112687181147514, 0.6963111636533434, 0.1043752046569274, 0.11636207790501885, 0.11655514863637295, 0.0953251331721805, 0.1352887123388795, 0.15209018100932847, 0.11927638503910876, 0.13836744618262709, 0.1192897025965367, 0.09208153327968394, 0.10884326704526026, 0.0988949084083035, 0.1293926707744386, 0.13909300498971355, 0.08930421253412024, 0.13307105849637269, 0.10057348989718828, 0.07804514073812374, 0.6738083305428073, 0.6685322887378964, 0.8553144896326546, 0.6305108400624666, 0.41190598132476863, 0.569625668688861, 0.5736055822185053, 0.9578383447289381, 0.8605656817950849, 0.28949739294158583, 0.28730534222594994, 0.4822384439458236, 0.34128121722380356, 0.4773542658319826, 0.4840862542919253, 0.47540503566083625, 0.43764920063176127, 0.5255181336944088, 0.8825228956493016, 0.23465371924241551, 0.8715074223195572, 0.8340109864659137, 0.8173998084838668, 0.8731093462002536, 0.8483072174817599, 0.8584809403197986, 0.8526034941218006, 0.34460321168779506, 0.2382383784828802, 0.25109774891207515, 0.2985736747516057, 0.26570641362969283, 0.2748674556559586, 0.5053724860820157, 0.13867721734700278, 0.22000689344902802, 0.12872841540420998, 0.27245150008405117, 0.5012958128899854, 0.2795064858795503, 0.3626921889659611, 0.24713550989838318, 0.19233455506613095, 0.37088256991945423, 0.47591243092392754, 0.18543799297323516, 0.6361204347224139, 0.5488416677526202, 0.5979927323186565, 0.6039487990642143, 0.21883039551929484, 0.27651046588902006, 0.607396466761521, 0.645034613426335, 0.7169614861145032, 0.695472191662359, 0.7070073079736399, 0.5692636776186015, 0.7071178550679702, 0.7056255672891129, 0.6898659940819633, 0.6192382119623085, 0.7206178767922375, 0.23253231632628735, 0.16908764986602876, 0.20420863847812654, 0.3515988615497998, 0.5730410172282878, 0.4254152311103476, 0.11499503216639984, 0.17675855492586268, 0.1751145772559286, 0.47886725966163934, 0.42201248077631015, 0.4448992496692119, 0.4927693768275525, 0.4523431965591217, 0.5269670447423701, 0.46710300133375626, 0.45519856532424596, 0.46010406265816095, 0.8068784075088951, 0.7858782360733593, 0.6017278333100667, 0.8429804847005294, 0.8341104988569905, 0.5563263172102741, 0.7952755025521693, 0.6514211692111489, 0.5947225035486643, 0.10909167008759868, 0.12050684420319269, 0.13292768520189946, 0.11367849332851732, 0.14529923060598338, 0.12829655660732353, 0.18913628568441132, 0.10751239474751495, 0.16194704335799615, 0.13324770852450896, 0.1553729749686641, 0.19326083078472533, 0.24500183761971372, 0.19235508207350027, 0.15701759180233144, 0.17197212770293568, 0.21264013517710878, 0.1655363925019383, 0.4263853649767191, 0.4227677648517143, 0.4700774386133103, 0.45493657196111403, 0.42759012458581713, 0.48470442446355344, 0.2579049070127424, 0.3062760991624014, 0.33388790120904355, 0.4453937076395912, 0.28853750421191504, 0.3538161395008801, 0.3735164501475593, 0.3378379967176969, 0.3622159693901408, 0.23787338952781845, 0.3800525406262164, 0.3773125982248222, 0.228134156713936, 0.2012515262657707, 0.2244485059877097, 0.1942931133925615, 0.20734128236868998, 0.20808276788652458, 0.24058208182061913, 0.19743133118434564, 0.20536476252323155, 0.18893087949662934, 0.18905487288288958, 0.1954239292569948, 0.2511090191727018, 0.1966525624136235, 0.17865034304906635, 0.2326943568947648, 0.34292944222075394, 0.23966036092653342, 0.8934249280743631, 0.5568265244629268, 0.1847176883917241, 0.1775228889721302, 0.20137242407827738, 0.7817603320751914, 0.8373752786774974, 0.16740654704052882, 0.6221597183349817, 0.7462312865163165, 0.20242104871666422, 0.1673904470536014, 0.19995054402717582, 0.20878395890853207, 0.8289877929415908, 0.21299975758423872, 0.7541979074456013, 0.3486549229926048, 0.18691417900762475, 0.1923016472663741, 0.17754230633854007, 0.17979825136024286, 0.18992324143037165, 0.17587918713184847, 0.19095770545218693, 0.18576556549232415, 0.1760116851879393, 0.08880995671600977, 0.08076657446535718, 0.10097487980131048, 0.08532296929815908, 0.09285042699691881, 0.09149028272481552, 0.08433836936557004, 0.07799860093573929, 0.09071029559688537]}, "mutation_prompt": null}
{"id": "25553402-ac15-4d2b-b4c6-edb3745a16d0", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "c28dbdcf-4fb0-41cc-be8c-1dcfdb77ee82", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def stochastic_ranking(self, func):\n        constraint_violation = np.array([np.sum(ind < self.lower_bound) + np.sum(ind > self.upper_bound) for ind in self.population])\n        combined_scores = 0.5 * self.fitness + 0.5 * constraint_violation\n        sorted_indices = np.argsort(combined_scores)\n        self.population = self.population[sorted_indices]\n        self.fitness = self.fitness[sorted_indices]\n\n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n            self.stochastic_ranking(func)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce stochastic ranking to balance exploration and exploitation by using a mixed evaluation of fitness and constraint violation.", "configspace": "", "generation": 71, "fitness": 0.40008262414830786, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8441026438832246, 0.8257881610367981, 0.8374131303601509, 0.768843001353914, 0.8416337202865735, 0.8575186780038003, 0.8216870093356595, 0.8111492661640333, 0.7044279746308302, 0.6593684040532171, 0.6695153268841217, 0.6623266760110588, 0.6252273027036463, 0.6560770750861218, 0.6579260196261429, 0.6083400248921373, 0.6552735982566644, 0.6412379925689238, 0.10373664862099163, 0.09430422676587513, 0.10883598896546898, 0.10610545908443514, 0.13499841510489075, 0.1254134016088998, 0.0966185694098729, 0.13059349288484623, 0.12961246239647317, 0.10030728904717767, 0.10507817319633528, 0.09111747799985348, 0.09868506795354803, 0.11458304332472358, 0.1148966873625995, 0.09036175969430715, 0.11356908058175008, 0.0966342607177808, 0.7571163557559384, 0.9016942586945742, 0.7461129337482351, 0.7918524967662567, 0.6684782716153211, 0.744133539348673, 0.7142767146230493, 0.971455403709382, 0.7866919959879952, 0.3176430927165147, 0.449778441600589, 0.3615810765786567, 0.5861817913044098, 0.520893957221899, 0.5409273960563118, 0.3295921338946207, 0.4645051446108921, 0.4404050519773881, 0.8829246416669733, 0.8558710072610572, 0.8420504467942439, 0.3911211607388152, 0.8548392986735164, 0.863026960377603, 0.834638384632524, 0.8455369172943448, 0.822968851723953, 0.13109398425541074, 0.33197816681838543, 0.3733827253964118, 0.3637402291677465, 0.33234533192169313, 0.48164865524697453, 0.2443103882715102, 0.29364455800435685, 0.3608836355159012, 0.2750891473315149, 0.25093803698798056, 0.5626579389116451, 0.2967331967750567, 0.37180895852497564, 0.40500615478499835, 0.6626185881234621, 0.23657341744283134, 0.3981530775655264, 0.47558424262976373, 0.4461654915974145, 0.44741352076721463, 0.291154849304587, 0.1879340298656187, 0.49083820622516683, 0.5459285942542229, 0.5769976571486333, 0.5835690640264463, 0.6571043437418495, 0.6832522397931531, 0.6757169605372957, 0.644040597834787, 0.5655290882661703, 0.18172126830753688, 0.6960407731070073, 0.71467990380496, 0.6529463153327593, 0.28798753641318353, 0.1058001967330956, 0.14333458049606596, 0.3334099034249062, 0.38137560767070644, 0.26398583967283207, 0.2511334799981636, 0.14319767729844446, 0.14453627156040638, 0.3785886693709042, 0.25658544298094466, 0.4308760801464989, 0.2754604185696299, 0.3825024194931306, 0.4027881524635337, 0.4133406333240227, 0.4576176406837321, 0.4260759845016221, 0.5602947694464427, 0.7836258467760884, 0.7831190319352953, 0.8223209304006862, 0.7812962080059882, 0.6812981011710949, 0.7862734884924573, 0.7951691570290178, 0.7889558298752573, 0.10689576988193572, 0.2487974148592893, 0.10628856945926468, 0.12065767253002435, 0.09916062434772832, 0.12157605797866511, 0.09874244973674617, 0.10113081234602084, 0.10714094096410376, 0.15593696790401024, 0.24459278484991842, 0.232256844687023, 0.2137463542123882, 0.1737569632046636, 0.23632600372161194, 0.19177867390068581, 0.1644844324987247, 0.13047705253476183, 0.4177246232174948, 0.39326976871014263, 0.41573886322952436, 0.4566105007133451, 0.4620303263365687, 0.47016949594429003, 0.41615461508372464, 0.428535162664219, 0.4626085576989223, 0.3564964082723523, 0.313942454079839, 0.3747430528275725, 0.3497069761760935, 0.37880327380393597, 0.37304057519608635, 0.36542329937294693, 0.40888403191799094, 0.2826350059695888, 0.23155008867375426, 0.20710825883065676, 0.20941116861779752, 0.21230592208007326, 0.21521150033664305, 0.19662168971121252, 0.21050643054091156, 0.19370212805565046, 0.21442680951512716, 0.21579595689498954, 0.213640025947206, 0.1877331784865759, 0.2128016519319773, 0.18409388483154587, 0.19045891505645518, 0.19521342724547985, 0.213492351608929, 0.18506761448734965, 0.8024740417421103, 0.18393604257094143, 0.17978777179421945, 0.7074351764496087, 0.16461464105841284, 0.1662284129850199, 0.6937234240745931, 0.8088014756428177, 0.7243009296424505, 0.12628656127921623, 0.15457847931761026, 0.8749617668404133, 0.20099964170357376, 0.20319704506076564, 0.8153380998006629, 0.211182203287124, 0.866872449375859, 0.7796165354398534, 0.1844833954407744, 0.20157046950676083, 0.1995298219987781, 0.18544852520896082, 0.18333618588619516, 0.18593199296178742, 0.18100840054564604, 0.2372636874465145, 0.1833737665896974, 0.08152581145153004, 0.08818008335457594, 0.0788758804536952, 0.10590930396956988, 0.07783794452128312, 0.08273767803483767, 0.09972241219146294, 0.09674273016509904, 0.0908511738018376]}, "mutation_prompt": null}
{"id": "080f59e4-715c-4cc9-8833-30f481745784", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "e715ecba-a544-4b54-9bf5-627b96c11ac1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.temperature = 1.0  # Initialize temperature for exploration-exploitation balance\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix * self.temperature)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n            \n            # Decrease temperature over time\n            self.temperature = max(0.1, self.temperature * 0.99)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce a temperature-based exploration factor that decreases over time to balance exploration and exploitation dynamically.", "configspace": "", "generation": 73, "fitness": 0.37465438833131304, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8346595055587458, 0.7490796763938147, 0.860645197442703, 0.4984810744533509, 0.8712254494773639, 0.4739212089025132, 0.8611439249803201, 0.8358432996776286, 0.8384842721887392, 0.6390625527142885, 0.672960322499297, 0.6799812842249396, 0.6676284065795037, 0.6982698508727326, 0.6871748831153339, 0.5374502468008027, 0.6919489646903322, 0.6784770970534533, 0.11005431991773695, 0.13163137202531594, 0.13433334985435663, 0.10971760463523239, 0.1207327070200217, 0.1224041867999518, 0.11124766463958369, 0.10587773962322877, 0.11816132693658399, 0.09842924733099556, 0.10176808847275665, 0.10236744322379232, 0.10352778816489494, 0.096051969785097, 0.10260862092719658, 0.1082250133091085, 0.11622566070222096, 0.1053269525448437, 0.5437963666890779, 0.6416694656988093, 0.766755757874177, 0.7656654312195478, 0.15096816506068933, 0.14653979204416678, 0.3171080561922195, 0.9542928599068312, 0.8323718891233134, 0.4524412157430695, 0.1985996229132304, 0.1860204401968354, 0.2240376602473524, 0.5323282110362191, 0.29436864153219733, 0.27162021833277017, 0.3605463996058059, 0.4425519190340801, 0.8654140438335113, 0.8371197463120381, 0.8518099640812931, 0.8835842239643116, 0.826104811186379, 0.8604393524472045, 0.3151216222116229, 0.8553377239717801, 0.8367414892579946, 0.22183989314122965, 0.18466907898469131, 0.1576457419415026, 0.5254032659847006, 0.14928014000957246, 0.20574978812605427, 0.5045561718536097, 0.13999016984444457, 0.19740413084095298, 0.5307144572876541, 0.2485086209273416, 0.21940329497261268, 0.18976616296526982, 0.18020612840498795, 0.1928457512681463, 0.1972328910801151, 0.29294911629693043, 0.1690133166031843, 0.24291732320137727, 0.3585124929159099, 0.4636319978775818, 0.6278889503574878, 0.40906332185547745, 0.5967400540916568, 0.5676998914527422, 0.4470029654850206, 0.5389086194276214, 0.6594492036354604, 0.7201712030579203, 0.7167765217935718, 0.6840340501850346, 0.6795057289378017, 0.1911033434887407, 0.7005380142189392, 0.6884988763627251, 0.6962979596753052, 0.2883560621522834, 0.16156678683470782, 0.24218701884861904, 0.260041101711326, 0.396418313228068, 0.16889477833794375, 0.3268325123965563, 0.2175989118843299, 0.10495128567501288, 0.3919347452312453, 0.46329918220185307, 0.4646161229366921, 0.24432997371322296, 0.4300899599670679, 0.5081934494237177, 0.469549146698759, 0.473373430291985, 0.4754824927787433, 0.7907935739625362, 0.7727673436671842, 0.7482216834067947, 0.8331472385573828, 0.761156147771396, 0.7392882382198864, 0.8033460733687389, 0.677861769086384, 0.5980807556580767, 0.10678483532682526, 0.13264655247035284, 0.14383238573133517, 0.11841174476182537, 0.10486067377232944, 0.12278347192141481, 0.10292279027079299, 0.11440871584578727, 0.11531320812770862, 0.17290106971616737, 0.14679780622853655, 0.17480332091498962, 0.28890165787423105, 0.15488663592830543, 0.1430321903105234, 0.18546088485923362, 0.21068358525725817, 0.21791034313596203, 0.4607755922180521, 0.311648375626124, 0.4636859500130639, 0.4726220159257095, 0.3840832146490738, 0.46609330091501777, 0.4255187515423118, 0.47863042141892465, 0.4296603609825007, 0.39408626495294174, 0.3469747926775355, 0.34004292888192933, 0.35468269297627475, 0.4069933078336698, 0.382534413348671, 0.42382942061603746, 0.43443072780855396, 0.2766953219820496, 0.22441685503356124, 0.22039539447957346, 0.22526329712753146, 0.22896493181174926, 0.2082200994445781, 0.18586092294348833, 0.2069189629352154, 0.22736109002553917, 0.19933083008110697, 0.1883266193939933, 0.23431750248379668, 0.18223899793175258, 0.1860809817706337, 0.20997889745364984, 0.17933023928236724, 0.2142275904586698, 0.34051799555189044, 0.20302137843178958, 0.890533155014452, 0.3993776859470095, 0.18497951544248337, 0.17777938380870306, 0.1956625474422422, 0.7919278922931563, 0.8335021517988899, 0.16739702021311753, 0.4544231250188079, 0.7495817014811286, 0.1540274883129792, 0.2071991687269027, 0.20029816087617658, 0.20697480833503712, 0.8103916651938856, 0.21300883944635263, 0.47536311706633383, 0.17546092565184446, 0.1927920027726332, 0.18487656575851974, 0.17718629717288537, 0.1739783484097166, 0.1816741343649283, 0.18922485694628577, 0.17380198031624838, 0.1900624280295392, 0.1829937611669581, 0.09084030499086526, 0.08508490969231608, 0.08626680021070066, 0.10856150439967738, 0.10088805377505161, 0.08411928514250488, 0.08811349938759327, 0.09073413665846897, 0.08437824501712599]}, "mutation_prompt": null}
{"id": "6e8cda0f-c5b9-4449-a95c-4e8548240876", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.stagnation_counter = 0  # Track performance stagnation\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            prev_best_fitness = np.min(self.fitness)  # Track previous best fitness\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            current_best_fitness = np.min(self.fitness)\n            if prev_best_fitness == current_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n\n            if self.stagnation_counter > 10:  # Reduce population size on stagnation\n                self.population_size = max(5, self.population_size - int(0.1 * self.population_size))\n                self.population = self.population[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n                self.stagnation_counter = 0\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Incorporate dynamic population size reduction based on performance stagnation to enhance convergence efficiency.", "configspace": "", "generation": 74, "fitness": 0.38532057377507306, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8361767381623377, 0.7774306109505409, 0.8600520142789224, 0.6242496331664106, 0.7651892901127167, 0.8270134998304816, 0.7940614581904747, 0.6946571208575704, 0.7040283985167259, 0.6583627607131788, 0.3662608955071359, 0.4965600150324889, 0.7065996062079325, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.13692366436668657, 0.1410649057579254, 0.10960654757943245, 0.15221246002223743, 0.12435541115534376, 0.09599458422446572, 0.12336225063758977, 0.1103902564096495, 0.12469465309621208, 0.11383591175619856, 0.1062428306367399, 0.08487857091641238, 0.09592892795761943, 0.12542773481296465, 0.08989923491728424, 0.10207296224317852, 0.1094455291562646, 0.08757911994433687, 0.6663508730613124, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.39802535481302015, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.4447430578196768, 0.4617979754634788, 0.23558782722264615, 0.41316018892133455, 0.5385926254790443, 0.45097503322578214, 0.5157593883116427, 0.3765159703328713, 0.8601511728236635, 0.3287483331616542, 0.8692481131104604, 0.8604680434173724, 0.8684543984022288, 0.8727832017744995, 0.8255321101384724, 0.38945275064609297, 0.8429581227448563, 0.24900960721571064, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.42915227068651374, 0.2950648783017624, 0.5658393393886912, 0.28017916519590513, 0.22469256630035717, 0.28997814673921496, 0.33246884921002307, 0.18163167172650962, 0.13097866896934685, 0.2888253475505532, 0.2989347964596182, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.13610893846537697, 0.26344713534285247, 0.5119203317485834, 0.28513298460399084, 0.1920811198993061, 0.22270113924309842, 0.6498931933738016, 0.6954485534740293, 0.40382795548735473, 0.6004321311501655, 0.5419024461919157, 0.6905411876426917, 0.6897698641010221, 0.24086272852372104, 0.641848036266417, 0.21123858124816441, 0.504351204521527, 0.22394515536725845, 0.27432996507076357, 0.18080536641804534, 0.16861917536009896, 0.32481152498885535, 0.26732924725776075, 0.18285683615170534, 0.3100489687663027, 0.0974824342615288, 0.43998574618562036, 0.22862616686886483, 0.4805751551393518, 0.44928224758002744, 0.46856044199306146, 0.3905404294731568, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.5637697010509943, 0.49604713089418306, 0.6501394636375758, 0.8098801999137707, 0.8331800668337026, 0.8413487990338218, 0.8049371619497694, 0.6392080112182146, 0.12406766532659985, 0.12892544162010944, 0.12753666819441678, 0.11813770158365, 0.1132179589608906, 0.14484033908444693, 0.11174245669239935, 0.1337233101756068, 0.101401586716796, 0.15704922255469955, 0.13957240137143057, 0.19661476218947505, 0.22186024936134963, 0.21162418958381113, 0.16853797349411803, 0.23159970773858662, 0.14679420402917764, 0.4291288760206531, 0.4265297625948541, 0.44258874553202265, 0.47015879324644005, 0.4893381691890277, 0.43188782664657444, 0.4785359169337384, 0.4556910015865523, 0.4258170582126889, 0.20367562782962423, 0.3561138456530426, 0.35998557062078207, 0.31861165351141896, 0.38079440841781675, 0.35453987254196007, 0.2947122260170305, 0.4377231638649095, 0.3795135303053233, 0.3264798545531242, 0.2194783898097774, 0.21664208451161726, 0.26400369827244263, 0.23798349569480237, 0.2076586546533593, 0.23810820035103963, 0.20350052044060352, 0.21172304291810862, 0.21484941635504906, 0.35271205762621316, 0.21788113385006513, 0.18649374957994036, 0.223233984772794, 0.2280463072574569, 0.19976327499766722, 0.19047423821938014, 0.19459627039669392, 0.19546383742276308, 0.8927997777861317, 0.7243268971165107, 0.18514408895279388, 0.8056459135092369, 0.34352439827463255, 0.7647119009046454, 0.8395123409660377, 0.16741194285333805, 0.7993729073722196, 0.8797788987442174, 0.202218180945122, 0.1673755956762798, 0.1975867765665691, 0.2084833676572706, 0.8091198546944793, 0.2129726395230651, 0.8133776319845218, 0.15485334804487771, 0.19648286938463366, 0.21065214930981824, 0.22569991411547985, 0.19889500128712112, 0.179696728730661, 0.19101692264861403, 0.22738824171455863, 0.1994854523187376, 0.21612062394939235, 0.10348901962215007, 0.08579950851432327, 0.09093553197206095, 0.09630462855326838, 0.08621854162202691, 0.09956037118261918, 0.0952293412612304, 0.09405261674570009, 0.10136670805059589]}, "mutation_prompt": null}
{"id": "13e13942-f6ba-4877-bb8c-adea0e4ebabc", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor based on Population Diversity\n                diversity = np.std(self.population, axis=0)\n                diversity_factor = np.mean(diversity) / (self.upper_bound - self.lower_bound)\n                self.mutation_factor = 0.5 + 0.3 * diversity_factor\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration by incorporating adaptive mutation factor dynamically based on population diversity to improve convergence.", "configspace": "", "generation": 75, "fitness": 0.36014216352753253, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.7134849101204267, 0.7979645395475063, 0.8519811513874785, 0.6996878089502134, 0.8423553351407703, 0.8232741998661761, 0.8147184667317614, 0.8129218929626284, 0.7982971969084645, 0.516100211563653, 0.6900783915847502, 0.6893706807201361, 0.3964554118567536, 0.38797873097607694, 0.5329986462507217, 0.3165116787806974, 0.5100977851709263, 0.7012765286564338, 0.11156629871929358, 0.11563160148348595, 0.11427253418386285, 0.11453393120553679, 0.13573434261453243, 0.12158405040304332, 0.11269498340194317, 0.10891650386075402, 0.1285276734219004, 0.09689186737980293, 0.1025412017593339, 0.11767331166927997, 0.1298162070051494, 0.09578968305073798, 0.0994537882701636, 0.11020321220867868, 0.12479704432853655, 0.14732251301602406, 0.9602865358782701, 0.8737978948203347, 0.8822707291513794, 0.5180571064594788, 0.1681209511054882, 0.7458811019748631, 0.7946403878731317, 0.9427166257785544, 0.9560076400042116, 0.43599981464318427, 0.22235542102607087, 0.3232571973364732, 0.2287089064421558, 0.27510188055015794, 0.4454958977942527, 0.21613501003332192, 0.35388466769077864, 0.40759661863571406, 0.8674274801752645, 0.8591490870496038, 0.8510123687108999, 0.8332235115282627, 0.8695546543689315, 0.87617455459005, 0.8370193065505558, 0.8054901121105371, 0.35559966775451546, 0.19708467842131105, 0.20323431401880487, 0.23121578692944222, 0.38845789708021805, 0.1352684934740297, 0.15109402227708202, 0.22918826137775028, 0.1457279540657762, 0.35737010054511753, 0.22637535739670223, 0.12545601419507224, 0.17942700906879705, 0.14761169396550378, 0.15509375992014396, 0.19613678147208025, 0.20002951147708314, 0.15223797694607055, 0.24630434315771443, 0.3406147505720333, 0.49900468460895286, 0.11899610367123181, 0.4700509027452233, 0.505013534404979, 0.09899842461236807, 0.18843542023082416, 0.297974669564672, 0.061877937977622754, 0.30884212960064394, 0.5869394875928868, 0.7279787101066548, 0.5026914092662059, 0.45839699870909434, 0.5690757640056019, 0.3962283293065797, 0.3666856349309312, 0.2673611658720936, 0.1710034923591669, 0.4155601222139528, 0.15708921163507983, 0.22030170337965715, 0.1838439040719263, 0.2760179957625968, 0.20215857764145462, 0.1634009534975328, 0.10898474609697573, 0.28711022699270683, 0.31059299670855234, 0.29543655507578637, 0.2573046996544004, 0.2459452638489914, 0.2827409203912251, 0.4489718554769868, 0.2745922623688488, 0.2743062192817417, 0.7587625424798345, 0.7433157270558919, 0.4323871053815156, 0.6993760983500421, 0.5158146796455816, 0.6935539347689921, 0.8027046523022683, 0.5607786877900482, 0.5566268222037729, 0.14159032056636278, 0.12117997990648632, 0.12583184593271768, 0.10033686645691742, 0.12895918403147788, 0.13568267056000038, 0.10195818456545913, 0.11553628555411055, 0.14067999265823783, 0.18606099699646161, 0.14565271009560676, 0.13789054196986983, 0.25010772980223406, 0.15434220577782887, 0.1543209248529973, 0.140191779063648, 0.15025775667252095, 0.23967120707988165, 0.27581977100363186, 0.49250695821074586, 0.5034001555156958, 0.46802374136369074, 0.4473499863574726, 0.5208524490119619, 0.526117284255605, 0.28938232547431275, 0.5034622967832809, 0.4008555052510464, 0.3755763291583132, 0.40121729922364413, 0.4125696190550565, 0.40461134620971206, 0.3598541731210745, 0.4756131169362299, 0.4226737539513977, 0.49940507822039504, 0.2037935232287742, 0.2208764254044835, 0.22640190448903164, 0.20012821854933627, 0.2006012204875235, 0.21885367967299385, 0.24846340467063988, 0.1853492931738765, 0.2056274750336552, 0.19994043531372774, 0.22554050434500883, 0.18545737602114865, 0.17942823930730023, 0.18618772872285672, 0.2046272348013869, 0.18924730735473427, 0.21449881317060393, 0.24961994304394308, 0.5629602338538862, 0.1822276565705241, 0.19536314199104743, 0.8282677356715048, 0.817176985957713, 0.7988474428495154, 0.7172029308350449, 0.7117349977990138, 0.8428279560981622, 0.3464595031935517, 0.7592310900984849, 0.20716310811336902, 0.7984127126092193, 0.41152875193496563, 0.19261321662206354, 0.2129201893342303, 0.20769298661257285, 0.6742070489198972, 0.17300781052675107, 0.17686906010212644, 0.1725348271956293, 0.20593662583444206, 0.1857720591057006, 0.18355776100257948, 0.18488078714561973, 0.19358633305072848, 0.18773195230198902, 0.08947846333341625, 0.0953968485906076, 0.08677067400513239, 0.0959115525841866, 0.09561679977288584, 0.08723130958724645, 0.08450865526112228, 0.08756048302396846, 0.08370111682412584]}, "mutation_prompt": null}
{"id": "2c344c8a-617e-48d3-a3ac-22dc4464480a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "6051a385-0355-41f5-a983-611ba13f4b54", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "3201adf6-6ecd-4c45-9fee-dd314f6d3332", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Dynamic Mutation Strategy\n                variance_factor = np.var(self.population) / (self.upper_bound - self.lower_bound)\n                self.mutation_factor = 0.5 + 0.3 * (variance_factor)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploitation by introducing a dynamic mutation strategy based on variance monitoring and selective local search intensification.", "configspace": "", "generation": 78, "fitness": 0.3753937698804552, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8070336810151874, 0.721048064747009, 0.8036833520254305, 0.7317292506657224, 0.7046973690019895, 0.7149423529069315, 0.8195976267454302, 0.831327375624976, 0.7975589265868422, 0.4215681574817032, 0.3250370858713444, 0.6683300001065853, 0.4854059869990669, 0.6270707163633435, 0.6653283832923119, 0.4176164742545496, 0.595121839699431, 0.462357983278878, 0.13000946913544664, 0.2289970223104727, 0.11386818527622511, 0.1126431814996176, 0.10516630956141249, 0.11094365267946105, 0.10186937831497667, 0.12826625145209292, 0.1118064594096091, 0.09870492415450138, 0.09427149680686286, 0.1075389284534598, 0.09641553396610503, 0.11170577220324884, 0.11601485172397574, 0.09866289016819463, 0.11271097571256472, 0.08821802655503685, 0.9600777141754632, 0.9510019645435731, 0.9517121022849988, 0.9555707560058608, 0.9544542844281081, 0.9192680987027463, 0.9232523838437117, 0.9964062485164312, 0.9824673754777188, 0.46853991959529995, 0.4475533241363956, 0.3999825440907515, 0.39082492751930964, 0.39631406840691075, 0.4023700924853013, 0.38471212621831175, 0.39367584960596336, 0.35078278202775715, 0.22904135833152528, 0.4189045764174041, 0.8226060100809708, 0.8353182607667587, 0.8373688120436116, 0.789296887572867, 0.7315818270616952, 0.8043454953367504, 0.818127552478699, 0.26148149885819083, 0.2051664217593503, 0.3443475449520129, 0.2858925368165295, 0.3003552217015679, 0.36148193607076173, 0.12490718710966864, 0.3819721668452818, 0.18486029360705325, 0.16122450750484463, 0.11528836457303826, 0.15362786554779906, 0.17907620742480646, 0.223257130352832, 0.22697368998837986, 0.22550372009441277, 0.14728648740767125, 0.22601366319546246, 0.38662894046788165, 0.4075627899127563, 0.363320456530573, 0.3538697398830639, 0.2885684542760033, 0.304067166455924, 0.4534177484359696, 0.48562234653403, 0.16144697231608096, 0.6236582552359444, 0.47339406916944415, 0.6078411570086265, 0.6206366535026926, 0.3682874483685086, 0.6061044802466282, 0.611206043101669, 0.49796206655551223, 0.5045945284211245, 0.13786255270857362, 0.11311310751484671, 0.08718169256624808, 0.19888305616999435, 0.0992805415375918, 0.22221458329844102, 0.26050129359390284, 0.1626219446796422, 0.13809516385081766, 0.3436333633367491, 0.3300564590880154, 0.34373964114278355, 0.2549998052586393, 0.2740815715054459, 0.27385066710884076, 0.30073277249638397, 0.3059945431994152, 0.3202017117677006, 0.7715049138837862, 0.6454602116809158, 0.7791088964776273, 0.7163229179870296, 0.7028079398460889, 0.7378929408610793, 0.5867439942362007, 0.7942737325348176, 0.703008219165367, 0.10583747139371713, 0.0909573160023448, 0.11873376457128193, 0.12535840903386541, 0.11237426641544213, 0.14790582628485005, 0.10405187548070449, 0.08770359703598785, 0.10610440215931483, 0.18067706545905604, 0.14705855381623767, 0.15260660690895655, 0.1628831990158608, 0.25666694812613466, 0.20374983059802731, 0.16557053414600087, 0.14401357347681498, 0.27157257320154427, 0.4587344372405443, 0.3894320482420889, 0.4325017521384307, 0.45229718922064166, 0.4070851372244034, 0.44348116674244953, 0.4093245054799939, 0.37555989228585573, 0.37246069830736706, 0.32826866369607555, 0.38382736904924963, 0.35202978777872795, 0.4392824294440473, 0.3453304441198669, 0.3298452576489095, 0.3143808022297093, 0.3229189406366809, 0.3336011685261505, 0.18939782513333525, 0.19091925864475945, 0.18985523449154706, 0.19121624613542942, 0.2024346030486005, 0.19531598160736818, 0.2107857293108213, 0.1944244167937541, 0.21411148233799215, 0.21362724214027762, 0.19761963386183246, 0.19508565413559964, 0.20204334252434286, 0.18963892115936976, 0.2180443701927527, 0.19471160835379897, 0.24147869738241623, 0.19503326572964697, 0.18184441558836906, 0.7578560393845655, 0.8135243397210722, 0.7866968994038217, 0.1873652217495798, 0.6316454983828511, 0.6781622258840245, 0.6671103741699391, 0.6619794370335248, 0.5025511624625825, 0.7329485548436057, 0.7851015722245844, 0.27515334208771414, 0.6945934564027821, 0.7065818631766618, 0.19678656796863714, 0.8129065065657539, 0.19735860764594026, 0.19459804866640296, 0.1892615607856395, 0.18334930725673382, 0.20512397539124527, 0.2231094789827499, 0.2543198298031142, 0.20990317670683856, 0.20632498743092986, 0.19197575060049799, 0.08994647812670609, 0.08507677430730032, 0.080162522904344, 0.07854529894998918, 0.07704900799963466, 0.08869177660190397, 0.08947166373317827, 0.07700801769711396, 0.07714026148306408]}, "mutation_prompt": null}
{"id": "97bde479-136b-490f-9e10-ce0a2c846ca2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "96c1051d-c1e6-4eb8-8f8d-44d940b5cc82", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "ea6ba53c-cdab-4c4c-a04f-f518ac708b7c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adjust mutation factor based on fitness diversity\n                fitness_diff = np.std(self.fitness) / max(self.fitness)\n                self.mutation_factor = 0.5 + 0.4 * fitness_diff\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance balance between exploration and exploitation using adaptive mutation scaling based on fitness diversity.", "configspace": "", "generation": 81, "fitness": 0.32454860545810926, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8214404409221604, 0.7437806089186672, 0.836915386343436, 0.6251994138250525, 0.7299801896703177, 0.8488275088320412, 0.6680912965009745, 0.7951334460243278, 0.38239136361861803, 0.28782397323833175, 0.4303408698554825, 0.6352120427037375, 0.32454053351348944, 0.681133285951085, 0.3628742213512519, 0.26433297953587087, 0.2169485418461502, 0.3680364714115931, 0.11893962640301581, 0.1222820913105439, 0.12858609899083784, 0.11875898845516308, 0.13034626373851932, 0.12150262168801362, 0.12119493215653165, 0.15065088003136007, 0.11814901215968787, 0.08109693090710002, 0.07409234222549954, 0.14673263643106116, 0.11370849783607395, 0.10812045609722831, 0.09123033039738526, 0.12624929205153568, 0.12105161906354511, 0.10803881874602994, 0.9525512765261593, 0.9570199155002456, 0.9196873829989235, 0.8750646562355167, 0.2588676076060805, 0.6937876344283034, 0.5895752886582437, 0.8963944132477939, 0.9751656793842143, 0.256847915794977, 0.39804788228458765, 0.37265243426227757, 0.43191035847973136, 0.2831090737583103, 0.29077383070608176, 0.4396560438510192, 0.17303628730694876, 0.2204712555809003, 0.8858711545490672, 0.8523332439087746, 0.8584767251854639, 0.8802306615212224, 0.849427731688337, 0.8693371567487818, 0.33268054801076874, 0.8004249698458111, 0.8233206353023862, 0.17729120545307864, 0.2081123803721091, 0.1914375009844651, 0.11894580444483638, 0.2761562869497193, 0.5517279674470653, 0.3295192865243671, 0.2544972581658961, 0.6356476573574786, 0.1765978644178362, 0.20122147529871104, 0.16815071723466812, 0.2579697400948482, 0.18070196925971105, 0.3106712492452708, 0.16917657267852337, 0.2519184695476926, 0.26212938902702343, 0.1292805345887209, 0.2065214039668415, 0.1267152373194549, 0.24646020485988906, 0.3722626315765416, 0.415898746536278, 0.6181707396959116, 0.11582488546369918, 0.07863612286408583, 0.6947945000793142, 0.48749788073891664, 0.6292103644788825, 0.30544537569814934, 0.39312756716865827, 0.3988662721544296, 0.5811673799559767, 0.44052744609105254, 0.2459590140305693, 0.07753270420583724, 0.10357912392538526, 0.0736688012800405, 0.10188811490089555, 0.0751652946243343, 0.12156203378352715, 0.13122701175870044, 0.28698775500887574, 0.22253186792231217, 0.34715369441635757, 0.27426406829846717, 0.3023491779220754, 0.11631668608928614, 0.10037334064452574, 0.11414790090709559, 0.25281036926325473, 0.19143987945194518, 0.047925054191609195, 0.5416914450651238, 0.3962527066482502, 0.4840477138186621, 0.44243316641137953, 0.25601237797543785, 0.460861696687902, 0.527765034540101, 0.5436479040871798, 0.7436423492222338, 0.12571530749473225, 0.10149415006674722, 0.1253319219096899, 0.13031972118555202, 0.11519133677623217, 0.1330856270541666, 0.09462142578644794, 0.09735611999760008, 0.11561126981011172, 0.16745639938056156, 0.20139850969067608, 0.2330283186302876, 0.19904334806592305, 0.2227051705540496, 0.18130276796003442, 0.20773371850945854, 0.2648008632229091, 0.16543713244769476, 0.4994596804303305, 0.5373948339025036, 0.2779413746686662, 0.4905230308038946, 0.473332002582304, 0.45820591545996825, 0.5345150837794705, 0.4379030492760536, 0.4742768446113128, 0.24997386093358875, 0.302921912309819, 0.17890482463768564, 0.49170959815930193, 0.4176752474767702, 0.3833443671068437, 0.38871403031462703, 0.4725018094505621, 0.46779486532802717, 0.2034271327976066, 0.22626881486411776, 0.18580659396008725, 0.22164848365985645, 0.2147012402426457, 0.20983154355658917, 0.2291847846873264, 0.21621147213936542, 0.2205554989116294, 0.20694745918424906, 0.19916431809431967, 0.1869269412164527, 0.21224226696491322, 0.21039802189059897, 0.1902728130626853, 0.24289252923969873, 0.19266226343253556, 0.21299513513241286, 0.16314411656675698, 0.1819143533098495, 0.8266070751319573, 0.7762731772508042, 0.318912833599454, 0.18902608876640448, 0.3675571314876904, 0.17464879920289988, 0.17069537637094312, 0.12721487335192416, 0.41746279754460525, 0.20468360114178086, 0.20641485845442265, 0.19993312990543133, 0.3892774902172226, 0.20621953161409678, 0.37303004299108555, 0.15465769261710027, 0.1892965560844162, 0.19516687226311147, 0.20347620255037413, 0.1992596344377111, 0.18761219669545015, 0.18779413782516496, 0.19557256967916592, 0.28081352140912996, 0.20746779528831383, 0.07908270210975155, 0.08426135060071371, 0.08299013492080809, 0.08954935038628808, 0.08810749053572908, 0.09863508525748044, 0.09661380416091614, 0.084063595259382, 0.09822790620746324]}, "mutation_prompt": null}
{"id": "5a12c495-ae55-4981-bf32-6cf1d7d8625a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "a65c5d6d-6bba-404f-8952-184b5e7aab51", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "cc2d95eb-7e99-44b6-9ef3-b829d91f3fe0", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        best_solution = None\n        best_fitness = np.inf\n\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n            if self.fitness[i] < best_fitness:\n                best_fitness = self.fitness[i]\n                best_solution = self.population[i].copy()\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget) * (best_fitness / (self.fitness[i] + 1e-9))\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial_vector.copy()\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n                    if local_fitness < best_fitness:\n                        best_fitness = local_fitness\n                        best_solution = local_solution.copy()\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce elitism by preserving the best solution and using fitness-based scaling in mutation for enhanced convergence.", "configspace": "", "generation": 84, "fitness": 0.4006945173347674, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8319531057162585, 0.8445811562007055, 0.854576783445155, 0.8144549195741282, 0.8575380282614429, 0.8467639310738029, 0.8347752465877825, 0.8267276788566604, 0.8407648466602552, 0.575927192933231, 0.6131074262849525, 0.6112250972531388, 0.6758633978060307, 0.6811954947015721, 0.6698922746440229, 0.6176527908553024, 0.6936909666107576, 0.6428482493423866, 0.13362508212366808, 0.1418869061695437, 0.11844525872162726, 0.1553193445691501, 0.1128115321919706, 0.10110130518871696, 0.11690544367753519, 0.10353092181447465, 0.12519851880788624, 0.1103357616699363, 0.11838215274944652, 0.1197786304714702, 0.0853583396685732, 0.10753270328966702, 0.09439619134800037, 0.11250162035278777, 0.10504517511810063, 0.09745937546458694, 0.8889898999242196, 0.8597575243056238, 0.8350851840390578, 0.7230378682896472, 0.3935313331106699, 0.754246714531887, 0.631156065824273, 0.9578343721624725, 0.882765107509387, 0.5090762354464325, 0.26673753924825183, 0.29676861190614423, 0.49495111639108036, 0.3991651042483776, 0.303345650632004, 0.39785235583466716, 0.4042858146444893, 0.21617317085733534, 0.8725995517795728, 0.8783450279686563, 0.28270726441098026, 0.8391562686476695, 0.8854827048890266, 0.7510637423440452, 0.8147679906591956, 0.8103518002349301, 0.8512199538306459, 0.2761387748129748, 0.6517431092641104, 0.3396440130565457, 0.37001663135263574, 0.13180569262871777, 0.17718346967134657, 0.3089751888823251, 0.2521443828709786, 0.3922945485350533, 0.24891166546098797, 0.6350591710616149, 0.41918519075246197, 0.3811377733567235, 0.3770307835976786, 0.4762756847823649, 0.19937005477211056, 0.4294338287021576, 0.3213904967388237, 0.5710276050905765, 0.13020282805309202, 0.42637267769990006, 0.6486141989252407, 0.6010918619445718, 0.6449813895442614, 0.5435360609892514, 0.6670758989884162, 0.5803497834769756, 0.7285489401067338, 0.3725485996146668, 0.7036928897399745, 0.1786125644161921, 0.6221093199238088, 0.6279368674748452, 0.7088044432481443, 0.7007081467816005, 0.7222966322651929, 0.26110201871698724, 0.14235127403595438, 0.064773961999257, 0.24200723968145443, 0.12611934202796127, 0.10390660606112656, 0.16800038546089813, 0.21462264776533446, 0.10970423118970574, 0.41950791384114616, 0.43202159498624415, 0.465940237801889, 0.36545181042309827, 0.47512446434990374, 0.4540270268347294, 0.13155390621173446, 0.49994086026926976, 0.469827717963076, 0.8104237667053329, 0.7511657547445888, 0.5286020620574148, 0.5619576239760395, 0.7415942927054953, 0.8207819916257325, 0.8081044383313215, 0.795117623161817, 0.7475016383591353, 0.1190251582274805, 0.11852942820495116, 0.1370613848490395, 0.10159595177092018, 0.10919238365228356, 0.12955834613695294, 0.12651483125315754, 0.11687173086862912, 0.10576444771018012, 0.14392662112448218, 0.2197375682451349, 0.19796844419691362, 0.1604256054641222, 0.18785969981517348, 0.23059916287622195, 0.23975386584272873, 0.2882734002124967, 0.1512825600630957, 0.44435367770422485, 0.4259003227991951, 0.47156484316640046, 0.4829774950602962, 0.4555167118458294, 0.4721810101776538, 0.4238337500875664, 0.40687994895920343, 0.44741596954107155, 0.37443413172694295, 0.2036851332377826, 0.2015553586074469, 0.38560001450035586, 0.3419143237925212, 0.35051567913185067, 0.4110685337458091, 0.44353963969981547, 0.443249154208606, 0.21498471871814373, 0.21202949533836934, 0.194599864928498, 0.2100524993088133, 0.18490787084436844, 0.22772334787009085, 0.21947135951781616, 0.2013062807526791, 0.20301732701117303, 0.19484231816353403, 0.1933769442145422, 0.1961475489026686, 0.262015777026095, 0.2234636506632427, 0.2091601382325461, 0.20497490572387755, 0.19447587407683375, 0.21121456566342622, 0.8660041689848125, 0.7037353549705703, 0.18466512162107906, 0.8675035579732968, 0.17558600111115918, 0.7844642375486419, 0.8468139930083164, 0.16738163718423327, 0.7749330955642749, 0.7847771683282413, 0.2026788848230584, 0.1673806373882657, 0.20006744521091835, 0.20824417315278343, 0.8567144318322666, 0.2126674253882883, 0.7528048455768969, 0.5711756236624748, 0.19696128762649334, 0.194320747499375, 0.18811663500064502, 0.17898813053027773, 0.20364466404299886, 0.19103715408670552, 0.1922463245554955, 0.1940679576942984, 0.17860776912426712, 0.10754707332715607, 0.09195191003743963, 0.10115984434310743, 0.0798651171369491, 0.07795150920135985, 0.09027610041633638, 0.08428816489036084, 0.0828390264649077, 0.0895673257935865]}, "mutation_prompt": null}
{"id": "56b37018-e159-46cd-a603-1c3fb0df3861", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        elite_solution = None  # Added line for tracking elite solution\n        elite_fitness = np.inf  # Added line for tracking elite fitness\n        \n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.6 + 0.4 * (self.evaluations / self.budget)  # Adjusted mutation factor range\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    \n                    # Added block for adaptive elitism\n                    if trial_fitness < elite_fitness:\n                        elite_fitness = trial_fitness\n                        elite_solution = trial_vector\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        # Use elite solution if it exists and is better than current best\n        if elite_solution is not None and elite_fitness < self.fitness[best_idx]:\n            return elite_solution\n\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance solution quality by refining mutation strategy and incorporating adaptive elitism for improved convergence.", "configspace": "", "generation": 85, "fitness": 0.36595904899181625, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.7341347682795083, 0.7421500044570378, 0.7515717720138955, 0.7517724856953508, 0.795154804312141, 0.8104962154050801, 0.7831505491608577, 0.7984762781694166, 0.7692293830519226, 0.5202981704860006, 0.4612463026129232, 0.48629194592019154, 0.43209871648339737, 0.5033043943004529, 0.48078996655124595, 0.5057691178508368, 0.5679099889851089, 0.4724139878065169, 0.09012079796662997, 0.12085250940903114, 0.09824647654137353, 0.10067054767557981, 0.11319026575469726, 0.09544389123081054, 0.09453304065184842, 0.09565951627016545, 0.09211455839851934, 0.09604865440955368, 0.11279547457866135, 0.1094869273511595, 0.09654504583692647, 0.09234805762939047, 0.09143383175820541, 0.09545677366703187, 0.10667928303171159, 0.09958256798005038, 0.8016671986878141, 0.9517590410795236, 0.8500780825600588, 0.8174045339800227, 0.7480771719913155, 0.8469011589495103, 0.9242532027923233, 0.9635264095488416, 0.9775497300672438, 0.35702119145295064, 0.34418514228376385, 0.4100638034226729, 0.4143800153294054, 0.4006317343709236, 0.366211827841596, 0.3601762200953771, 0.3520708274984714, 0.40734042158610195, 0.7623110182066039, 0.8509019916455833, 0.8000165757821768, 0.8015058507339834, 0.8089037786163586, 0.8213047936819113, 0.7964428137200177, 0.7561439102053528, 0.7939141761064225, 0.4204175812461053, 0.3731128288032489, 0.2468463758591517, 0.3984886273700943, 0.2966698863398187, 0.3357814174513547, 0.43268848198363585, 0.46571472060653996, 0.4537309195865139, 0.35718916298413816, 0.2512489046463605, 0.308312398886484, 0.25469747183451685, 0.34280834820911665, 0.25247783962196724, 0.36011684687938095, 0.3022105419295158, 0.36943730244312734, 0.336033555030122, 0.4082705583119731, 0.35262160648718777, 0.45753747146280344, 0.4179379111207868, 0.3638489084763393, 0.3124361866201534, 0.3670257654870357, 0.3356788720132383, 0.5374445276642109, 0.49351421673269535, 0.5133393260307781, 0.4956934688522371, 0.48114520951798134, 0.4395350203695717, 0.46862317945137266, 0.5450815874854935, 0.5943819823345584, 0.12083692297530546, 0.10847391709743714, 0.02882991149233216, 0.22262897599397502, 0.23987087556312225, 0.1930330332816843, 0.09623940006772425, 0.09934222905226076, 0.11436092009924903, 0.30626566707056957, 0.29980071229636474, 0.293935525343041, 0.28444289904796627, 0.30085291448181206, 0.3116469879310514, 0.30800087097365936, 0.32765406632496075, 0.3132494970747487, 0.6652457749056321, 0.7075184119070832, 0.6437979737852946, 0.6746619665631307, 0.7083122776703552, 0.6736310689451834, 0.7075643598238661, 0.6942109628679253, 0.6989523223683866, 0.11180761861095256, 0.1078232060514418, 0.14376643493926933, 0.10125494170319671, 0.10909848770557762, 0.10113418471007407, 0.08674493338261546, 0.08916316621560272, 0.106543641497434, 0.16866402640674116, 0.19094868689577704, 0.15588410315228796, 0.26059522211927433, 0.14707206337523915, 0.19614947151628004, 0.1971122224486721, 0.19134395876466948, 0.17216406328477496, 0.32314088186238155, 0.348866756453302, 0.3484250562006115, 0.3649215877538886, 0.32470767137593415, 0.3424896223271179, 0.3671653306463636, 0.3411176332181617, 0.3202372792727727, 0.3044028435600924, 0.33985173759559073, 0.32872297739645917, 0.2989914296337186, 0.27870378622882186, 0.2931890334470989, 0.3082774485760911, 0.3368853672159541, 0.32332144542195695, 0.1924757192964185, 0.2076328801545676, 0.19741360821955845, 0.2007449831026178, 0.20705593216057505, 0.2083376266132907, 0.22257831112500914, 0.20645642661367392, 0.190827965558387, 0.19303430639409047, 0.20148719406749682, 0.18159875542937065, 0.21478359487295828, 0.2493054788350999, 0.18260183448025324, 0.1903973309539445, 0.20327012781281018, 0.20410416844876234, 0.1856182111532263, 0.17090218719610129, 0.1463111044028157, 0.8229671025056262, 0.18630127857615209, 0.6524633755947943, 0.6809977560614303, 0.8040100558812553, 0.7472109416896964, 0.2009017484275063, 0.8130138561484794, 0.20501761994525947, 0.1236910091169231, 0.8065891957823377, 0.8091605156785373, 0.21125617599947977, 0.6756399692368416, 0.2040229081914241, 0.1879476605674426, 0.1867643152731826, 0.17710923725396643, 0.18189534479851666, 0.2229113711585523, 0.1852597385813295, 0.19937813456959252, 0.1864600518245888, 0.1970648845761499, 0.07573961753024827, 0.08262368294083366, 0.07929689271801743, 0.07565209906292425, 0.07748162017659321, 0.07250014814576333, 0.09307965121382289, 0.08550299875232226, 0.11194840734220013]}, "mutation_prompt": null}
{"id": "3206914d-d012-44ba-98e4-d63b0706e26b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "93cf8f7d-b8f0-4cee-ae48-c8deb083ba7c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            dynamic_scaling_factor = 1 - (self.evaluations / self.budget)\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * dynamic_scaling_factor + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Integrate a dynamic scaling factor to enhance local and global search balance, optimizing convergence speed and solution quality.", "configspace": "", "generation": 87, "fitness": 0.38444378416714986, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8530777615104747, 0.5342638280947496, 0.8372986460537023, 0.6698993314070728, 0.856512097638694, 0.5286319325161466, 0.8479759144720359, 0.7837433529973521, 0.8322785405346388, 0.6959466415935158, 0.687173447323385, 0.7022679501891032, 0.6582288754466386, 0.4138050457525968, 0.6095068743909807, 0.3394492288314568, 0.42203691118691233, 0.6681623582657048, 0.10968251789552319, 0.10342851337085412, 0.09786515398967799, 0.12096938444856753, 0.10888628344555962, 0.13961807906538182, 0.12426235154794862, 0.12300498807485505, 0.13793297249871161, 0.10001758637463232, 0.10262006312095706, 0.0912624225470654, 0.10452183993970887, 0.11090152659597807, 0.09359966911918238, 0.1329425300388144, 0.092088892538425, 0.14188809750463993, 0.44446021826019755, 0.821948234887244, 0.7689973003020049, 0.7182306231325173, 0.14938218328309738, 0.34613875622713974, 0.5731969187844496, 0.9542759681099235, 0.8476766713493309, 0.38790646273467955, 0.08673424881097058, 0.40889546204254756, 0.22260474261395236, 0.2595907427127667, 0.5514778617088012, 0.5340669134211262, 0.3609353967937844, 0.32563791586887847, 0.868506788990121, 0.852659230763604, 0.855405502644557, 0.8751584256175106, 0.7937306101914995, 0.8686984122707931, 0.8675108238690118, 0.866673404920657, 0.8742750280736654, 0.2726591084793656, 0.5042974296576521, 0.2995153376023967, 0.1675086068326609, 0.2507584678350194, 0.674579897604397, 0.3697398048310181, 0.16884034441969997, 0.24352066633230784, 0.3353233256142898, 0.29023462134350086, 0.544922277614585, 0.2471853414279208, 0.2844374167754026, 0.20239339896869302, 0.22746131369859968, 0.3525141514157424, 0.1746538493851476, 0.47011053322661367, 0.5613944868156422, 0.5687178100072585, 0.6187906218668102, 0.564860039436771, 0.3651482132917565, 0.5914214803725804, 0.385746279896816, 0.41291564951727777, 0.7667011948161673, 0.673549290765821, 0.5926895883806527, 0.6512358225452388, 0.6902389110390668, 0.10017800452943826, 0.7146391431401007, 0.6879117235544513, 0.6365062084299868, 0.2082490040161098, 0.25338446431572936, 0.1959316509434651, 0.0970759018232078, 0.3607773532941235, 0.27812025337356516, 0.22472681662276517, 0.24476734257458088, 0.28865798743657134, 0.45600915311963564, 0.3732789880266578, 0.441669671268062, 0.41314601751797286, 0.45289509188499133, 0.4449671759696212, 0.24490604228431923, 0.4620388220119682, 0.47315632612166725, 0.6780083853147421, 0.6669659891565627, 0.709307642202667, 0.8192224888032925, 0.7553668056448027, 0.8123159141517793, 0.8109752368449377, 0.8357613098419399, 0.6387795499659159, 0.09665416942528449, 0.12482189795660126, 0.13989719755191599, 0.11274311494463085, 0.10681784343137024, 0.14671687349027596, 0.1011052490708153, 0.10745365849450883, 0.12808700984970278, 0.165159605733315, 0.14071558643929127, 0.2611880338029311, 0.17978425532403675, 0.18837289147747505, 0.1277399605952909, 0.18908188827625227, 0.20943876392458027, 0.14274401674441173, 0.4418731115853364, 0.4481636740511389, 0.45737224504853236, 0.4501396942714999, 0.27269212659482056, 0.4718684828246068, 0.45280525402328753, 0.445244360999684, 0.2518325767009061, 0.43292420963386613, 0.3919818590059009, 0.432141516659322, 0.2948328669847058, 0.3042113348042399, 0.4079799737636325, 0.48376904969739454, 0.41630276734928306, 0.355982902044357, 0.21803194826468375, 0.20883580202931762, 0.21370931038080176, 0.1942354506701306, 0.22767392670058595, 0.22174835547091876, 0.2188530663562116, 0.2171285400320927, 0.20908274885487654, 0.18834066965481744, 0.22051808800621342, 0.18937636439704386, 0.21111093400560277, 0.4541737117565765, 0.1872226281634215, 0.2076028773216858, 0.18898554722846084, 0.2022054615290123, 0.892421025076967, 0.3919070532653751, 0.1851777747704797, 0.1776419071194456, 0.19519008807578597, 0.8229398104570211, 0.8434678929405538, 0.167400132082705, 0.40909793545054696, 0.6476652991082044, 0.6447381199513467, 0.20665651400431484, 0.3278717108613932, 0.20711400948476932, 0.8534699530462975, 0.21288658153327977, 0.5426429733178869, 0.15487086091969848, 0.1872917952697275, 0.2157590658867854, 0.2026631043998517, 0.17069645584843984, 0.18330274280630443, 0.1790044695568349, 0.20258261504120345, 0.19452562968348375, 0.1968802617635511, 0.09061346449130903, 0.08265861724922396, 0.08428282595721792, 0.09779756867845768, 0.08679152931582279, 0.08231405749771226, 0.08507533567782721, 0.09637565105740109, 0.09431889035050156]}, "mutation_prompt": null}
{"id": "0d72dbd6-7fe3-4e46-ae93-ea7a493f7310", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Dynamic Mutation Factor\n                diversity = np.std(self.population, axis=0).mean()\n                self.mutation_factor = 0.5 + 0.5 * (diversity / (self.upper_bound - self.lower_bound))\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Improve convergence by introducing a dynamic adjustment of the differential mutation factor based on population diversity metrics.", "configspace": "", "generation": 88, "fitness": 0.3571177969803414, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.7258929022884058, 0.8087638227934317, 0.8270260054935654, 0.8179996980883315, 0.679869228684741, 0.8240766671128555, 0.7626894185869324, 0.7356129830186853, 0.8316337482358588, 0.3817097915073562, 0.7097071322740298, 0.49654966511073184, 0.44783324868431673, 0.38543356654232686, 0.6236200076985148, 0.50737111738886, 0.4370196227718388, 0.71271711114568, 0.11738619629498992, 0.12294513149382713, 0.148364739861079, 0.1496869195533811, 0.12903596222724978, 0.09977736263508596, 0.1252299116349348, 0.13498744522247363, 0.1219092551668951, 0.11352307448484622, 0.08361181073004498, 0.12259259219310392, 0.12690734863000452, 0.11524728387157279, 0.11510725017761703, 0.12497093893770306, 0.10373034123508607, 0.11124260510778061, 0.8942747146492367, 0.5647773304841535, 0.9353216348771423, 0.35688692703273905, 0.14411862111857499, 0.3740000318426193, 0.5005114995459692, 0.9196854806423019, 0.9776316270444675, 0.4115684948858227, 0.3868534832237438, 0.38118213353014674, 0.4157031098538534, 0.36093906318281366, 0.4365995104660616, 0.45890847334267304, 0.4137441188463997, 0.3787512760357883, 0.8569663493063276, 0.8282901153686125, 0.7856040192114088, 0.8971332918813214, 0.8727787899913368, 0.8404151133660496, 0.8315105145982337, 0.36997268667203986, 0.8437946171801263, 0.20854486038895825, 0.1338315031007482, 0.28084682495656976, 0.2273591669417705, 0.39187535129833306, 0.12547743969288216, 0.23621517522213953, 0.21664838383110985, 0.26183274860571315, 0.21900784450650157, 0.1433247303755979, 0.15130949614641453, 0.15908646794708325, 0.16192569961794956, 0.15533907420976245, 0.2168357464219185, 0.22901060896828562, 0.15696033396807785, 0.1267957061557512, 0.3487778642517848, 0.3177290676649416, 0.6113322665697476, 0.3640996559054446, 0.6030328903043174, 0.29012617767099336, 0.3903607461214328, 0.4134807053011904, 0.36962547971679427, 0.673962188061599, 0.2925986173054801, 0.5520009784157931, 0.30547182139189855, 0.4789078951984912, 0.5391388381964225, 0.4038246588920449, 0.463881007460179, 0.1806016619067694, 0.12586000492834337, 0.2502826808610843, 0.24373763107294055, 0.16379485624083123, 0.178888768453766, 0.20758150264067377, 0.10244956077264356, 0.11405376510983711, 0.29925344310885216, 0.29760283382382946, 0.34195015216862634, 0.3146827294010479, 0.23738102192553334, 0.3220452583109845, 0.16468257755943783, 0.42076368904717587, 0.50413308374501, 0.5505709022254202, 0.4865163829574297, 0.5307424410028165, 0.5327123863253151, 0.608353993659691, 0.8037497437298287, 0.5670292852825254, 0.6306162289708145, 0.554177425715106, 0.10372647229729204, 0.11164551842425685, 0.22254089237318464, 0.1336588452074582, 0.12387298180832351, 0.14102206077568824, 0.09542266151696366, 0.12987245743275289, 0.12567931678418442, 0.14809978968109028, 0.437843911183293, 0.16125520324966125, 0.1902585906906875, 0.13769574889894265, 0.18693280079231922, 0.20728797345802852, 0.2119300802509767, 0.19083287713328723, 0.4389557644859158, 0.5130299164352781, 0.4161601964886533, 0.48301621579767673, 0.3911853697719728, 0.4821566443700557, 0.45347455607334675, 0.49657967149641613, 0.4067691880108769, 0.35588803615772036, 0.44753004066586743, 0.3572354919876979, 0.4614124521009608, 0.3774699684319097, 0.34714486584921445, 0.3861382535355179, 0.49385879368651076, 0.3356418110874747, 0.19969672642042058, 0.22737431637031846, 0.20162142507514613, 0.19890410485219412, 0.23508401704931947, 0.20271177846412436, 0.1904158731584079, 0.2073302003423949, 0.21774408037082038, 0.19888480035854206, 0.1875252078753502, 0.21982790996443669, 0.19157253220014847, 0.3094730725010445, 0.18559738553169114, 0.20540238351398077, 0.41765945578524943, 0.21554639686316657, 0.3870909746000538, 0.847025946598341, 0.7853332602677648, 0.7686155099210777, 0.6466002373259037, 0.1743718058384799, 0.16601183898930483, 0.8432123290715529, 0.1653414411706905, 0.6295701556861439, 0.20414970816704003, 0.20669354366735337, 0.20048876856414022, 0.8011662017721166, 0.8367930763728314, 0.34524628214271624, 0.2062216177979188, 0.4168703026364152, 0.1767962245118011, 0.19636069608630313, 0.17575676536868545, 0.18989381075966572, 0.18608680956463308, 0.16892983439908316, 0.20636023344918297, 0.2445462458548341, 0.19769425012325503, 0.08443739361457103, 0.07409899534516262, 0.0864919171649815, 0.08969760292160123, 0.08382451982043115, 0.08836086941457721, 0.09117066598464973, 0.09234048189364841, 0.08369977900406289]}, "mutation_prompt": null}
{"id": "70b7af16-f2e4-4825-b449-c7b959a1b055", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Adaptive Mutation Factor\n                progress_factor = (1 - self.evaluations / self.budget)\n                self.mutation_factor = 0.5 + 0.3 * progress_factor\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce adaptive mutation factor scaling based on progress, while maintaining existing adaptive crossover and diversification strategies.", "configspace": "", "generation": 89, "fitness": 0.3645406913858813, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.7388635276294746, 0.7350361859892842, 0.7119931833746934, 0.7135690667436576, 0.7526974653681082, 0.7337925537007768, 0.727884475106511, 0.752499059272402, 0.7367952364022887, 0.5505402838596183, 0.5611257054852804, 0.5652897511684942, 0.5446796529963758, 0.5621953672855655, 0.48791633984489446, 0.5700341230475282, 0.5252045006379313, 0.5095837297404844, 0.10379208903930248, 0.12762377201103625, 0.10363216432191857, 0.1121664013634921, 0.13779876655580925, 0.1142361976417473, 0.11530931499203745, 0.10627444142132159, 0.12518653136233882, 0.09645119616286357, 0.09527144844749169, 0.08770769704763914, 0.09925519857095988, 0.10275601644512367, 0.09299128800296641, 0.10334501410130525, 0.09553675556956565, 0.0802499330240789, 0.8237153797318907, 0.8925903406025704, 0.9604092205595087, 0.6855982993567487, 0.9619585843021031, 0.9067134183945601, 0.8071478489429398, 0.9964070473686176, 0.9825094827257054, 0.4111571197590521, 0.36148711581041315, 0.3636935107273851, 0.37739285094416863, 0.4050506873673969, 0.44914659327367146, 0.4170920811951955, 0.3594532254409928, 0.4022726401735057, 0.6898394767113432, 0.7383635707988068, 0.7418681419237324, 0.7308405580349568, 0.7554999233737243, 0.7661176821138662, 0.7647755029430163, 0.7524344075080929, 0.7497243996298821, 0.2572328936609064, 0.3125202777700904, 0.3238743087786208, 0.43117327581725196, 0.3135666659338844, 0.3588177707049961, 0.2758291068137595, 0.413269079125935, 0.25134044969775626, 0.2906257502021825, 0.2767713973850464, 0.12371920623924271, 0.3118976063715062, 0.20134739710091754, 0.2534353081209906, 0.1770398738074529, 0.3645551049252932, 0.30080548357824055, 0.4074146248591035, 0.3196705787251155, 0.3919289494292907, 0.4601118394165157, 0.34476772705791403, 0.34697061227046133, 0.32424799029397755, 0.3776046051413141, 0.4173818342997704, 0.5311032108345277, 0.568356864559721, 0.501262099524044, 0.4497769392760218, 0.495835023551208, 0.5530765515072062, 0.5802696559679098, 0.5199313616308348, 0.5672872464247278, 0.11794119876153852, 0.04664739614406588, 0.18250166653168565, 0.11613478068068994, 0.11753086523480893, 0.23213101426370208, 0.12967784336374755, 0.14645385928964583, 0.12333377510059529, 0.30897736016301447, 0.2608325912273738, 0.33280069443843074, 0.341843791641249, 0.33239430242678747, 0.31324229159495653, 0.3308273541888066, 0.3284269839027594, 0.3217021788730199, 0.7159597722964692, 0.6716365508895294, 0.7065144905039422, 0.6845356777034597, 0.7065991541592211, 0.7114792141545399, 0.6770178319663833, 0.6816557148457085, 0.695629386892508, 0.10718340417447103, 0.08672382248644628, 0.09577477112868782, 0.10980842627036924, 0.12462102023800292, 0.10457362070393794, 0.11773110920987073, 0.08991458939050023, 0.08599375328536918, 0.1412141160642404, 0.2469416186984631, 0.1364089956976895, 0.23186299940593447, 0.18184535431508586, 0.18427059862570272, 0.20006305199098007, 0.1333419183142096, 0.1766045317564955, 0.3476096119227463, 0.3617810500355192, 0.35200871585308247, 0.35312390326039744, 0.36832738828108735, 0.3330930636484458, 0.3905974229579384, 0.37872050520652634, 0.4008564707682729, 0.3114140360928883, 0.3001862416126141, 0.3220813449798917, 0.2763100454009124, 0.3099353572971131, 0.31355827372738976, 0.32186815428218374, 0.31134698614376344, 0.3205198126243657, 0.20172817900235795, 0.2061557429197628, 0.19462069349479894, 0.24910970295011792, 0.21160890577313995, 0.18210097315962948, 0.18151025188851022, 0.18552590587491058, 0.21749611640948774, 0.2965678416560158, 0.18722885648166743, 0.17927212518228752, 0.19953569266938176, 0.1839847929980427, 0.4455961614511351, 0.20221343498846833, 0.1782385873270509, 0.18004348558809902, 0.8167419044041271, 0.7739733889663017, 0.8179894950934808, 0.7277902098116734, 0.17238158205328236, 0.638670647664497, 0.1638108622657115, 0.710565867868393, 0.1587502676868806, 0.20506128418031533, 0.6815683579560986, 0.7309855903774038, 0.2023181707002788, 0.16347649545613074, 0.20360072505813465, 0.14450063185228468, 0.8057128123766697, 0.1996047680973564, 0.18600002544906913, 0.20841396052452432, 0.21644197290460399, 0.18967550055113735, 0.2007863592034158, 0.19885542038422677, 0.19637881173213334, 0.22551300769727856, 0.2190583648119271, 0.07887789823042146, 0.07520523070240304, 0.08270564386266666, 0.07207086328546608, 0.0814041525316812, 0.07354643898639102, 0.08836278261904751, 0.0766859635400029, 0.0807603893078771]}, "mutation_prompt": null}
{"id": "8adb0283-2a0c-4ece-8048-09d3a4c0bc2c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "1d4bac65-fc99-4cfa-9739-f8bde6f85e67", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "7a0149ac-a4c7-4371-9f09-cb6e33af7b66", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                # Fitness-based mutation scaling\n                self.mutation_factor = 0.4 + 0.6 * (1 - (self.fitness[i] / np.max(self.fitness)))\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Refined Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.15 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Improve exploration by incorporating fitness-based mutation scaling and refined focused diversification.", "configspace": "", "generation": 92, "fitness": 0.27642582705841373, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.7135938423762128, 0.73509786111981, 0.5585197163773254, 0.7180932390020742, 0.7745643186187573, 0.7394174565229563, 0.5956817634879389, 0.4957554664790962, 0.27198968885882013, 0.18644926749379043, 0.20110636305460683, 0.431027802733853, 0.36705288403700465, 0.3491537269391457, 0.22817995052894857, 0.34879683178326015, 0.38533441359196396, 0.23793085263127045, 0.10823303608536994, 0.13614341375007644, 0.10346216060449498, 0.13298758530242505, 0.11762955378831486, 0.149098240778768, 0.13400704406550557, 0.16710205330438144, 0.14168984074878788, 0.09287917422785852, 0.058156159952071684, 0.11502165619892657, 0.11344352022450599, 0.1282612015374378, 0.12717529345055578, 0.12068187939778596, 0.09522016941862022, 0.0942586598054922, 0.9189374072302273, 0.8668441392461786, 0.9577152870824156, 0.11853382948270808, 0.7989456433228852, 0.45979664463361125, 0.36366939675992416, 0.9822336037792608, 0.9038470258064032, 0.14240800085203065, 0.22747786903700207, 0.2786751564879011, 0.29409266393406996, 0.1543168986906066, 0.1739867156770053, 0.16419533820563814, 0.11932710423333137, 0.15977696261714847, 0.29448388925236724, 0.8638229226974431, 0.8983487805839617, 0.4006681279181592, 0.3311801994484447, 0.9014696197174586, 0.8477833319286477, 0.8529981768934304, 0.24779078228642626, 0.1546032008683894, 0.13684536112065215, 0.15301828804745687, 0.12665972716199025, 0.12308493400859932, 0.13688957761814147, 0.23715754201407113, 0.13272932134571525, 0.4482950835634595, 0.211865806284813, 0.13958145261204336, 0.17060003568386162, 0.1917450618793458, 0.13535395874243983, 0.12580232362304433, 0.16281636079431883, 0.1432612059982703, 0.17535958626062897, 0.07776509054418534, 0.154643038477425, 0.27259960009676143, 0.2887841408943991, 0.3340941949623293, 0.3044901462438617, 0.34225791174392484, 0.27294618663337145, 0.11639594419630905, 0.21801621132360138, 0.27263482643894255, 0.3614456672286409, 0.29511038766822617, 0.25158783421807973, 0.17455953456205864, 0.43811568562773906, 0.3708541122972724, 0.2446264325748544, 0.16423890125047313, 0.1458898466180193, 0.05936053822600984, 0.08304133442556338, 0.12380124672831405, 0.1071745457284824, 0.23669438851717828, 0.1394927872844921, 0.12570761936751862, 0.28958299657563524, 0.29104873829809097, 0.2218446654454137, 0.23596386603641661, 0.3527062129746642, 0.14156387228271994, 0.14422344250738717, 0.17130706488379344, 0.15471990900387178, 0.3714298578645424, 0.38845608512299934, 0.28518317723714026, 0.25272803120392207, 0.298777830466637, 0.5048850080545797, 0.5507579895957406, 0.3533770484934653, 0.5767220342950894, 0.13493283339076312, 0.07430748863884129, 0.16412911721350976, 0.12693232378131758, 0.13130710903137766, 0.14087234083253042, 0.10987756704862628, 0.11126139577776617, 0.11490897767437724, 0.20371461840357652, 0.18762964839628848, 0.20504087231856005, 0.18007632255136719, 0.23355818649165805, 0.2557915161981795, 0.1459869512007299, 0.20970439242175398, 0.15555984354622965, 0.37670010849809876, 0.26692796635880534, 0.27939364341363615, 0.3011926802421657, 0.45571233082399565, 0.440014838810862, 0.24000124859411576, 0.32969192075948883, 0.36831489975355536, 0.2772631430814194, 0.2932879049456828, 0.33077732182491404, 0.3611701368790169, 0.19890758088209315, 0.37420156086621703, 0.2517904838901811, 0.36739394146006465, 0.28679658949573195, 0.2073157415177418, 0.2176845456467743, 0.20366334421239674, 0.204636174667978, 0.2139790600668915, 0.24233841083850427, 0.23679999775699412, 0.19281423668352038, 0.22769704179998618, 0.2175928051896312, 0.19114949180045215, 0.2221600049630741, 0.18685792511270183, 0.18840105635638305, 0.1864104992331379, 0.1858637478403703, 0.18892523197713706, 0.1863934704761867, 0.1844461563344465, 0.36979417785311886, 0.19973628960865564, 0.656079934196202, 0.6745656144359669, 0.618590068027209, 0.1659105069171659, 0.16904868474084722, 0.16224191101798058, 0.369630205982735, 0.2091412012103533, 0.33109973892397493, 0.20879606162996522, 0.36123736894268443, 0.7379137269537052, 0.20999229008614373, 0.13197134310913994, 0.20211907216033986, 0.1913181952860047, 0.22110942564815916, 0.18402209785684365, 0.1735313059088125, 0.21696797220307218, 0.20092534234266224, 0.18361012377741093, 0.17513342051140623, 0.1718736522839106, 0.09061125386424695, 0.09225153978876477, 0.08414809921556154, 0.08981685851787968, 0.0795068326173698, 0.08574114248947795, 0.09089922333131184, 0.08564479309177808, 0.07894400418441705]}, "mutation_prompt": null}
{"id": "6edec510-fea5-4656-b741-14a328793992", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "b9736757-4fa7-40f2-a08b-50d7f78ee0f2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n            \n            # Incorporate swarm intelligence-inspired leader selection\n            best_idx = np.argmin(self.fitness)\n            leader_idx = np.random.choice(np.argsort(self.fitness)[:2])\n            best_solution = self.population[leader_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance convergence by incorporating swarm intelligence-inspired leader selection for guided exploration.", "configspace": "", "generation": 94, "fitness": 0.39805265068932794, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8510699569166915, 0.7769264193514922, 0.806071932007504, 0.7511771763697535, 0.8469693692695027, 0.8375432902134963, 0.8584975980707852, 0.8466438877883341, 0.7592300091568134, 0.6647903860622364, 0.6690397902566905, 0.6848492834854767, 0.6504765382450933, 0.6841494113880751, 0.6674649754225384, 0.48194194490257525, 0.7111916133151768, 0.6878622251226933, 0.11558824008672286, 0.11379103593078033, 0.10431936712490775, 0.11740635759268703, 0.11537617990730775, 0.12100508390113573, 0.14373314132100545, 0.12202183033599845, 0.11657643838065146, 0.11171121931557515, 0.08825895789643945, 0.1355341325763364, 0.11609641248241731, 0.11020175841453617, 0.10717150002634823, 0.09310304896813382, 0.11677736979114417, 0.11540893811154729, 0.973734636283231, 0.8153973269669538, 0.7980365093267425, 0.5516529029081678, 0.8236686427183795, 0.44170634291117916, 0.6171235752255113, 0.9884630949502301, 0.8759225172560173, 0.39652902364024345, 0.2754567419161916, 0.3753742694801394, 0.2966774639128785, 0.3055717984339096, 0.3017130835336217, 0.3096286768406318, 0.2892845445005864, 0.5338722929752158, 0.8343138076077885, 0.8215967337915515, 0.7608500565356682, 0.8529348418596784, 0.8942761583984583, 0.8349956724832632, 0.8435632408059148, 0.8948404064408709, 0.2446678707798522, 0.5854642012583743, 0.12743625220557953, 0.32711934994469216, 0.3124705128817009, 0.2749153869244083, 0.12769346078921595, 0.3176601339698203, 0.4776192278519452, 0.3916583142679566, 0.7214602546118689, 0.3404337165919704, 0.2528761552104455, 0.36417154362107396, 0.47158265080174855, 0.2284743900644105, 0.43265265198746616, 0.34158034213963506, 0.3802878382301913, 0.5147295042558397, 0.6399236134074006, 0.37818656886608815, 0.5921947297486521, 0.5759576454002564, 0.6000188272353406, 0.538532366400607, 0.5907903978699701, 0.46444836082348595, 0.6554288695082502, 0.690722511686241, 0.700760214373634, 0.6563754076293977, 0.3233263692914069, 0.6584640463301025, 0.5889928659787538, 0.3188919374967609, 0.7148359883385769, 0.144715380292067, 0.19237684052265347, 0.25450955662477914, 0.10601771109801705, 0.44152646131180184, 0.3980828258194311, 0.13385148612533226, 0.11151455550726896, 0.13272962298869606, 0.4515532883488794, 0.45580270693790315, 0.45106091998791153, 0.43909640178311726, 0.4613263397991718, 0.36581155418218436, 0.43543848459853296, 0.30195878347108795, 0.3266611400147794, 0.7261076544800588, 0.5509192086628961, 0.5856776337310294, 0.7246114367583021, 0.7940300697976341, 0.6064206662039653, 0.6408509750091946, 0.7793979949793316, 0.8141097782954794, 0.12983151818135286, 0.12462493980733547, 0.12012308314456366, 0.13455892823078008, 0.09174698746453525, 0.13068791755302023, 0.12082139679634707, 0.13608627164893972, 0.09450621232127998, 0.1431413759672885, 0.16227258966056612, 0.6150440353020865, 0.2589310326576316, 0.14424268104351445, 0.23012042653448184, 0.213756430960655, 0.13569860323821636, 0.23474549421878899, 0.4611323698556343, 0.42066160425996246, 0.449436316560342, 0.4385962379914262, 0.4297365966270824, 0.41309917138770325, 0.35854080564339486, 0.4566089888144904, 0.47118722796340695, 0.3578356808875066, 0.3639320614595982, 0.3639707334628933, 0.43647213540633256, 0.35111987889240415, 0.33417513309666846, 0.28383608741976063, 0.3575938227524271, 0.41065478693800783, 0.19966683981493727, 0.2038877353733597, 0.22038420927875024, 0.19816974417733157, 0.2008331013626352, 0.20970638831537836, 0.20120703602930834, 0.1981094045430919, 0.21352875981682995, 0.19413277654276173, 0.21045228479973166, 0.20121931040657348, 0.22750320533403212, 0.18650194908041173, 0.19327296472814326, 0.18246823063842332, 0.17460004938444895, 0.2891449913387898, 0.18568127513235522, 0.18201784887586459, 0.18306136161838926, 0.8166576884047827, 0.765335747536976, 0.20177035232450158, 0.8295619923313237, 0.16593426245036902, 0.7901088975163408, 0.8256973349342072, 0.8230885972257622, 0.21071280587384345, 0.7059522456422833, 0.16519420158285958, 0.5999796155640793, 0.20948923444437828, 0.8752928856037978, 0.15421384468903365, 0.18764774656557293, 0.19814777222737634, 0.18463532458084841, 0.17593703787653736, 0.1921131603870575, 0.17739803670622256, 0.19433639810856407, 0.17910410957444578, 0.1870392332513644, 0.07856091449125857, 0.09061621888968363, 0.08951764188569011, 0.08705096794195144, 0.09549324506117285, 0.0836476282955495, 0.08193459768674805, 0.08685914522912974, 0.0791394959528916]}, "mutation_prompt": null}
{"id": "d498cec1-9d36-474c-80ec-2e8d6b005c31", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Stochastic Ranking\n            if np.random.rand() < 0.05:\n                perm = np.random.permutation(self.population_size)\n                for j in perm:\n                    k = (j + 1) % self.population_size\n                    if self.fitness[j] > self.fitness[k]:\n                        self.population[[j, k]] = self.population[[k, j]]\n                        self.fitness[[j, k]] = self.fitness[[k, j]]\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Introduce stochastic ranking to balance exploration and exploitation, enhancing robustness against premature convergence.", "configspace": "", "generation": 95, "fitness": 0.3954643306617815, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8324443619235835, 0.8181402501054403, 0.8302947856411962, 0.8408916843785439, 0.8345755611829163, 0.7487478936617279, 0.7886478927793092, 0.806446272726822, 0.29209708167711934, 0.6619188776577875, 0.6791937576850575, 0.6750757325651319, 0.7063217419386891, 0.6711243066683317, 0.661597695051132, 0.6405115143295536, 0.6909716757276316, 0.6645078466636265, 0.08960638985164282, 0.11884160933187671, 0.11299931378726413, 0.11894667733493769, 0.12038403261087571, 0.11497889964391073, 0.125689112686455, 0.14224387061271992, 0.1326790018241838, 0.11352999772450223, 0.09546569433602525, 0.10836822974311544, 0.11895603670507149, 0.10027940001369384, 0.10641063877823742, 0.09338257946413375, 0.14260545096181598, 0.09873053315194846, 0.9550217458484812, 0.7685307894218589, 0.6234871180960617, 0.4836611674892449, 0.5776390429913585, 0.7329793579751479, 0.7443595870529099, 0.8369193271320776, 0.988066360674124, 0.43329089798917253, 0.4299082204496014, 0.4285568459314464, 0.5435300548241213, 0.4257526421132686, 0.5079094300059246, 0.5589355256111457, 0.4619682986589243, 0.398554277028799, 0.23430132907483847, 0.8373546810331771, 0.8214745484004204, 0.8692990232078683, 0.2768174008630816, 0.8614441822976213, 0.24332121366462556, 0.8845692385182518, 0.8647304273060351, 0.351299555960068, 0.4906692323935723, 0.38199188616719826, 0.4980809267931151, 0.23913717470545404, 0.1262705692018129, 0.4943912909711756, 0.2622737568023118, 0.35563124730790874, 0.3580641173067416, 0.27074230266832533, 0.3194714537963391, 0.3083152672512137, 0.35898429252264086, 0.3393274219282162, 0.3733729995619022, 0.2625582210428137, 0.2798402550281247, 0.5721321713533469, 0.5575338121393971, 0.5362019088667077, 0.49957524630382266, 0.57319791884705, 0.5805316271441997, 0.6119798725966852, 0.5221709888776105, 0.6260616546865515, 0.6495250394112668, 0.35858480837091056, 0.6782679246597718, 0.6813119307229728, 0.4432056208283648, 0.6783145222277058, 0.7280801774957724, 0.684369307434485, 0.6795147397734176, 0.3367793415070901, 0.2798923006133964, 0.14569432223407308, 0.12206930176000386, 0.43326347620506744, 0.4901104047880577, 0.17132429071858457, 0.2257758885745177, 0.1556296895283682, 0.4645716678918592, 0.4560048187404554, 0.49047027720861025, 0.4295373471514953, 0.4107447994493145, 0.417722435990859, 0.4844797542308613, 0.46718208952031604, 0.4580503939932139, 0.7919174883150619, 0.8307979660893097, 0.7216948973565145, 0.591324796905084, 0.7112600185487189, 0.8055528700002477, 0.7759403432305456, 0.8051100300743842, 0.8148983726750769, 0.09028473878564147, 0.10618265880474043, 0.0910753612001366, 0.10357812584999415, 0.13901751726313683, 0.12429754747629518, 0.10211712258294225, 0.11428003968213563, 0.09740022812257121, 0.20400850978620733, 0.15108373405799502, 0.15098144526314394, 0.17137783911712035, 0.3644757767894097, 0.21017031274587694, 0.16420895909970568, 0.16680413229509816, 0.2381852056259971, 0.4069434827700664, 0.4283698860570466, 0.44665560378552427, 0.43968327901225035, 0.47348149034896236, 0.42704644706076456, 0.36590453083543784, 0.45542894911364906, 0.46721751149782564, 0.34054992045210464, 0.35269284058627515, 0.33263876496365796, 0.40468397788517874, 0.33203761368243145, 0.33920978732637164, 0.41482410445477336, 0.3934253112015169, 0.32686251817395917, 0.2254762112539459, 0.22757917016018858, 0.19051133568174605, 0.21984773666193158, 0.2220137130884139, 0.19569406963270775, 0.205081764662141, 0.22116757051977698, 0.2001500028322737, 0.20072072016353526, 0.25648926386065674, 0.1970150094713201, 0.18970310120365264, 0.177730504100289, 0.2033175473454768, 0.22828669375406907, 0.21797587270169005, 0.2026490825271573, 0.18632383519613838, 0.850696465100694, 0.18215967671907618, 0.1758003424160457, 0.1918868141972876, 0.7690188761214259, 0.1644335573265725, 0.1857288660705978, 0.8629850772432465, 0.8762478185648934, 0.865810598760112, 0.1547049617746752, 0.20510657037442392, 0.16421369852665835, 0.16679385431274418, 0.21091576287213254, 0.5759520943504095, 0.7621017064026216, 0.18564038915709402, 0.19459124310952924, 0.1822424025815842, 0.17439831060807776, 0.17633751542121723, 0.18272930703645673, 0.202744820773049, 0.1843735405280803, 0.18698178119661757, 0.08574874780580011, 0.08262634327691232, 0.09186995168562695, 0.07573236247750903, 0.08381830657403533, 0.08222388131171543, 0.08482208945375935, 0.09059804313963216, 0.09457140606577863]}, "mutation_prompt": null}
{"id": "fc8c7efa-145a-4704-a23e-668abdd75daf", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width) + np.random.normal(0, 0.05, self.dim)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploitation by integrating region-based adaptive local search and controlled diversity based on Gaussian perturbation.", "configspace": "", "generation": 96, "fitness": 0.40525845794348997, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "f134642e-ff8d-487b-9612-f80662626474", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "cc6ab886-54d6-4e86-9675-d02a282181d1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
{"id": "5edbc317-6775-454f-a6ba-d459c4a61d11", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size_initial = 20 + dim\n        self.population_size = self.population_size_initial\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        \n    def __call__(self, func):\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                indices = np.random.permutation([idx for idx in range(self.population_size) if idx != i])\n                a, b, c = self.population[indices[:3]]\n                self.mutation_factor = 0.5 + 0.3 * (self.evaluations / self.budget)\n                mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.population[i])\n                # Adaptive Crossover Probability\n                self.crossover_probability = 0.8 + 0.2 * (self.fitness[i] / max(self.fitness))\n                crossover_points = np.random.rand(self.dim) < self.crossover_probability\n                if not np.any(crossover_points):\n                    crossover_points[np.random.randint(0, self.dim)] = True\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            if self.evaluations >= self.budget:\n                break\n\n            best_idx = np.argmin(self.fitness)\n            best_solution = self.population[best_idx]\n            covariance_matrix = np.cov(self.population, rowvar=False) * (1 + (self.evaluations / self.budget)) + 1e-5 * np.eye(self.dim)\n            mean_solution = np.mean(self.population, axis=0)\n            for _ in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                local_solution = np.random.multivariate_normal(mean_solution, covariance_matrix)\n                local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_solution)\n                self.evaluations += 1\n                if local_fitness < self.fitness[best_idx]:\n                    self.population[best_idx] = local_solution\n                    self.fitness[best_idx] = local_fitness\n\n            # Focused Diversification Strategy\n            if self.evaluations >= self.budget * 0.75 and np.std(self.fitness) < 1e-3:\n                range_width = 0.1 * (self.upper_bound - self.lower_bound)\n                for i in range(self.population_size):\n                    self.population[i] = np.random.uniform(best_solution - range_width, best_solution + range_width)\n                    self.fitness[i] = func(self.population[i])\n                    self.evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhance exploration through adaptive crossover probability and focused diversification strategy based on dynamic range adaptation.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2f48110f-ee09-48f0-9d8b-596a6b3dbac3", "metadata": {"aucs": [0.8415824585492067, 0.7520027627969942, 0.8243851865652763, 0.7774306109505409, 0.8600520142789224, 0.6193181745518732, 0.856160875493077, 0.8270134998304816, 0.81742902132692, 0.6752295658716305, 0.7040283985167259, 0.6583627607131788, 0.6427580990851041, 0.6612740502807255, 0.6562978348102593, 0.6700061024663295, 0.6694185991161399, 0.6981470550396247, 0.0885043679117673, 0.13127752022463557, 0.12317570022622493, 0.12533817885435983, 0.12836117654691903, 0.1600057839894211, 0.1159508561068946, 0.12156118748605627, 0.12358714389648517, 0.10762472702492543, 0.09579417348508323, 0.10074167195634931, 0.10021206225035362, 0.10294401543753606, 0.11126181509244104, 0.10642135983287293, 0.12692656371066824, 0.0878632933818908, 0.671887550073778, 0.7182204274191369, 0.8819645327345449, 0.5981049102145373, 0.40043164252541497, 0.597818597392113, 0.738690078535688, 0.9578581077186322, 0.8068124517082959, 0.41148252947647135, 0.40655017360982293, 0.46024258391600137, 0.23558782722264615, 0.38879492975737895, 0.5385926254790443, 0.4462736711475641, 0.5157593883116427, 0.49590262301741495, 0.8523055199444416, 0.7850879963643517, 0.8682584704068286, 0.8480109681049596, 0.8237392701532336, 0.8727832017744995, 0.8486345073018529, 0.8382903265991171, 0.8214794157421366, 0.47215981693317877, 0.3237322029501227, 0.29537361540482476, 0.5290629425407798, 0.2208088264794439, 0.31964833606033505, 0.3262967901196234, 0.3800995615156635, 0.1776057265677382, 0.22469256630035717, 0.28997814673921496, 0.5020967022553471, 0.18200818776719785, 0.2982379744629441, 0.2888253475505532, 0.21845601588271513, 0.4058130369686489, 0.21789023409328834, 0.41065559603468027, 0.6164304374351515, 0.6186971993123831, 0.44755944337280484, 0.5774162903258162, 0.5250281524193837, 0.5252380165150075, 0.6498931933738016, 0.6491254528926245, 0.7581982755510109, 0.7301895102476053, 0.7126396456677322, 0.6905411876426917, 0.685230980738703, 0.3074550501755452, 0.641848036266417, 0.6866116672436038, 0.7208914108606577, 0.1449433854349529, 0.27432996507076357, 0.15632624520214689, 0.2608718550057719, 0.2198100238072742, 0.41241259647549255, 0.24382784524504997, 0.2649488003790068, 0.12555013675714222, 0.43998574618562036, 0.4408410705331228, 0.4805751551393518, 0.44928224758002744, 0.45930852026746705, 0.4488500596017976, 0.4349592145538178, 0.4780757752176935, 0.34792034226334123, 0.7761144316713374, 0.8164254743599582, 0.5378346027176047, 0.6501394636375758, 0.8146432320248272, 0.8331800668337026, 0.6695885466303918, 0.8049371619497694, 0.6392080112182146, 0.1142165574675903, 0.12943988754367952, 0.10659395725375598, 0.09664724169075689, 0.10632786325764665, 0.11248361840153209, 0.10030920659475073, 0.10400947462700538, 0.11499456182021173, 0.13825787525639066, 0.1456342318671584, 0.13835396537927414, 0.2829417203112866, 0.16055781910062195, 0.1636590451556491, 0.18526899594678425, 0.16362885400339744, 0.12906229929740898, 0.43965288322852714, 0.3970953801877971, 0.47699025407837015, 0.43026798613479145, 0.4362836690166282, 0.46079413708812866, 0.444217903008027, 0.4292880001792537, 0.19574986843922426, 0.3726008639401108, 0.3775444982501144, 0.25109485241154383, 0.36119543771118456, 0.36979373080263855, 0.3693885275544163, 0.41230251643696647, 0.37721448833085947, 0.31551680298862694, 0.21543841087184223, 0.23171960334823494, 0.19645047629579693, 0.20572763514619585, 0.20585389232131723, 0.18724120589980342, 0.19847676153987526, 0.19653466490374005, 0.2073297748751025, 0.19316624531577042, 0.22891891179661938, 0.47810095378515016, 0.1937181489033022, 0.19387997836204152, 0.21049855693418318, 0.19557113264446901, 0.20704432796678418, 0.18987537982721892, 0.8926986517582817, 0.7291774975222663, 0.18439614593806242, 0.8296766807936831, 0.20142694121174143, 0.7499651055628268, 0.8377281696945829, 0.1674111277963498, 0.7993729073722196, 0.7951386053755987, 0.20231228098464515, 0.1673755956762798, 0.1997750479262792, 0.2084833676572706, 0.8514771535105189, 0.21297676364225404, 0.8133776319845218, 0.5275206207913272, 0.21276897495896452, 0.18733705194386407, 0.17378381313878222, 0.19291920340681734, 0.18001083562983422, 0.17825865381533823, 0.18330723708628704, 0.18871333641507682, 0.18678014818962174, 0.08504396462965813, 0.0888388968159326, 0.07345322535033394, 0.08231193788637137, 0.09965264785190775, 0.08539438562114332, 0.0910100513348927, 0.08857832330487492, 0.09311035097560738]}, "mutation_prompt": null}
